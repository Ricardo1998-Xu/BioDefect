{"project": "bowtie2", "commit_id": "100_bowtie2_2.5.1_aligner_seed2.h_resetRead.cpp", "target": 0, "func": "void resetRead() {\n\t\tdf_.clear();     // clear Descents\n\t\tassert_leq(df_.totalSizeBytes(), 100);\n\t\tpf_.clear();     // clear DescentPoss\n\t\tassert_leq(pf_.totalSizeBytes(), 100);\n\t\theap_.clear();   // clear Heap\n\t\tassert_leq(heap_.totalSizeBytes(), 100);\n\t\troots_.clear();  // clear roots\n\t\tassert_leq(roots_.totalSizeBytes(), 100);\n\t\tconfs_.clear();  // clear confs\n\t\tassert_leq(confs_.totalSizeBytes(), 100);\n        alsink_.reset(); // clear alignment sink\n\t\tassert_leq(alsink_.totalSizeBytes(), 100);\n\t\tre_.reset();\n\t\tassert_leq(re_.totalSizeBytes(), 100);\n\t\trootsInited_ = 0; // haven't yet created initial descents\n\t\tcurPen_ = 0;      //\n\t}", "idx": 0}
{"project": "bowtie2", "commit_id": "101_bowtie2_2.5.1_aligner_seed2.h_nextPartial.cpp", "target": 0, "func": "bool nextPartial(\n\t\tconst DescentDriver& dr,\n\t\tconst Ebwt& ebwtFw,          // forward Bowtie index for walking left\n\t\tconst BitPairReference& ref, // bitpair-encoded reference\n\t\tRandomSource& rnd,\n\t\tAlnRes& rs,\n\t\tWalkMetrics& met,\n\t\tPerReadMetrics& prm)\n\t{\n\t\t// Sample one alignment randomly from pool of remaining alignments\n\t\tsize_t ri = (size_t)rnd_.next(rnd);\n\t\tsize_t off = 0;\n\t\tDescentAlignment al;\n\t\tsize_t rangei = 0;\n\t\t// Convert random alignment index into a <range, offset> coordinate\n\t\tdr.sink().elt(ri, al, rangei, off);\n\t\tassert_lt(off, al.size());\n\t\tCoord refcoord;\n\t\tWalkResult wr;\n\t\tTIndexOffU tidx = 0, toff = 0, tlen = 0;\n\t\tgws_[rangei].advanceElement(\n\t\t\t(TIndexOffU)off,\n\t\t\tebwtFw,       // forward Bowtie index for walking left\n\t\t\tref,          // bitpair-encoded reference\n\t\t\tsas_[rangei], // SA range with offsets\n\t\t\tgwstate_,     // GroupWalk state; scratch space\n\t\t\twr,           // put the result here\n\t\t\tmet,          // metrics\n\t\t\tprm);         // per-read metrics\n\t\tassert_neq(OFF_MASK, wr.toff);\n\t\tbool straddled = false;\n\t\tebwtFw.joinedToTextOff(\n\t\t\twr.elt.len,\n\t\t\twr.toff,\n\t\t\ttidx,\n\t\t\ttoff,\n\t\t\ttlen,\n\t\t\ttrue,        // reject straddlers?\n\t\t\tstraddled);  // straddled?\n\t\tif(tidx == OFF_MASK) {\n\t\t\t// The seed hit straddled a reference boundary so the seed\n\t\t\t// hit isn't valid\n\t\t\treturn false;\n\t\t}\n\t\trefcoord.init(tidx, (int64_t)toff, dr.sink()[rangei].fw);\n\t\tconst EList<Edit>& edits = dr.sink().edits();\n\t\tsize_t ns = 0, ngap = 0, nrefn = 0;\n\t\tfor(size_t i = al.ei; i < al.ei + al.en; i++) {\n\t\t\tif(edits[i].qchr == 'N' || edits[i].chr == 'N') ns++;\n\t\t\tif(edits[i].chr == 'N') nrefn++;\n\t\t\tif(edits[i].isGap()) ngap++;\n\t\t}\n\t\treturn true;\n\t}", "idx": 1}
{"project": "bowtie2", "commit_id": "102_bowtie2_2.5.1_aligner_seed2.h_next.cpp", "target": 0, "func": "bool next(\n\t\tconst DescentDriver& dr,\n\t\tconst Ebwt& ebwtFw,          // forward Bowtie index for walking left\n\t\tconst BitPairReference& ref, // bitpair-encoded reference\n\t\tRandomSource& rnd,\n\t\tAlnRes& rs,\n\t\tWalkMetrics& met,\n\t\tPerReadMetrics& prm)\n\t{\n\t\t// Sample one alignment randomly from pool of remaining alignments\n\t\tsize_t ri = (size_t)rnd_.next(rnd);\n\t\tsize_t off = 0;\n\t\tDescentAlignment al;\n\t\tsize_t rangei = 0;\n\t\t// Convert random alignment index into a <range, offset> coordinate\n\t\tdr.sink().elt(ri, al, rangei, off);\n\t\tassert_lt(off, al.size());\n\t\tCoord refcoord;\n\t\tWalkResult wr;\n\t\tTIndexOffU tidx = 0, toff = 0, tlen = 0;\n\t\tgws_[rangei].advanceElement(\n\t\t\t(TIndexOffU)off,\n\t\t\tebwtFw,       // forward Bowtie index for walking left\n\t\t\tref,          // bitpair-encoded reference\n\t\t\tsas_[rangei], // SA range with offsets\n\t\t\tgwstate_,     // GroupWalk state; scratch space\n\t\t\twr,           // put the result here\n\t\t\tmet,          // metrics\n\t\t\tprm);         // per-read metrics\n\t\tassert_neq(OFF_MASK, wr.toff);\n\t\tbool straddled = false;\n\t\tebwtFw.joinedToTextOff(\n\t\t\twr.elt.len,\n\t\t\twr.toff,\n\t\t\ttidx,\n\t\t\ttoff,\n\t\t\ttlen,\n\t\t\ttrue,        // reject straddlers?\n\t\t\tstraddled);  // straddled?\n\t\tif(tidx == OFF_MASK) {\n\t\t\t// The seed hit straddled a reference boundary so the seed\n\t\t\t// hit isn't valid\n\t\t\treturn false;\n\t\t}\n\t\t// Coordinate of the seed hit w/r/t the pasted reference string\n\t\trefcoord.init(tidx, (int64_t)toff, dr.sink()[rangei].fw);\n\t\tconst EList<Edit>& edits = dr.sink().edits();\n\t\tsize_t ns = 0, ngap = 0, nrefn = 0;\n\t\tfor(size_t i = al.ei; i < al.ei + al.en; i++) {\n\t\t\tif(edits[i].qchr == 'N' || edits[i].chr == 'N') ns++;\n\t\t\tif(edits[i].chr == 'N') nrefn++;\n\t\t\tif(edits[i].isGap()) ngap++;\n\t\t}\n\t\tAlnScore asc(\n\t\t\t-dr.sink().bestPenalty(),  // numeric score\n\t\t\tdr.query().length() - edits.size(),\n\t\t\t(int)edits.size(),         // # edits\n\t\t\tns,                        // # Ns\n\t\t\tngap);                     // # gaps\n\t\trs.init(\n\t\t\tdr.query().length(),       // # chars after hard trimming\n\t\t\tasc,                       // alignment score\n\t\t\t&dr.sink().edits(),        // nucleotide edits array\n\t\t\tal.ei,                     // nucleotide edits first pos\n\t\t\tal.en,                     // nucleotide edits last pos\n\t\t\tNULL,                      // ambig base array\n\t\t\t0,                         // ambig base first pos\n\t\t\t0,                         // ambig base last pos\n\t\t\trefcoord,                  // coord of leftmost aligned char in ref\n\t\t\ttlen,                      // length of reference aligned to\n\t\t\t-1,                        // # seed mms allowed\n\t\t\t-1,                        // seed length\n\t\t\t-1,                        // seed interval\n\t\t\tdr.minScore(),             // minimum score for valid alignment\n\t\t\tfalse,                     // soft pre-trimming?\n\t\t\t0,                         // 5p pre-trimming\n\t\t\t0,                         // 3p pre-trimming\n\t\t\tfalse,                     // soft trimming?\n\t\t\t0,                         // 5p trimming\n\t\t\t0);                        // 3p trimming\n\t\trs.setRefNs(nrefn);\n\t\treturn true;\n\t}", "idx": 2}
{"project": "bowtie2", "commit_id": "103_bowtie2_2.5.1_aligner_seed_policy.cpp_parseFuncType.cpp", "target": 0, "func": "static int parseFuncType(const std::string& otype) {\n\tstring type = otype;\n\tif(type == \"C\" || type == \"Constant\") {\n\t\treturn SIMPLE_FUNC_CONST;\n\t} else if(type == \"L\" || type == \"Linear\") {\n\t\treturn SIMPLE_FUNC_LINEAR;\n\t} else if(type == \"S\" || type == \"Sqrt\") {\n\t\treturn SIMPLE_FUNC_SQRT;\n\t} else if(type == \"G\" || type == \"Log\") {\n\t\treturn SIMPLE_FUNC_LOG;\n\t}\n\tstd::cerr << \"Error: Bad function type '\" << otype.c_str()\n\t          << \"'.  Should be C (constant), L (linear), \"\n\t          << \"S (square root) or G (natural log).\" << std::endl;\n\tthrow 1;\n}", "idx": 3}
{"project": "bowtie2", "commit_id": "104_bowtie2_2.5.1_aligner_seed_policy.cpp_PARSE_FUNC.cpp", "target": 0, "func": "define PARSE_FUNC(fv) { \\\n\tif(ctoks.size() >= 1) { \\\n\t\tfv.setType(parseFuncType(ctoks[0])); \\\n\t} \\\n\tif(ctoks.size() >= 2) { \\\n\t\tdouble co; \\\n\t\tistringstream tmpss(ctoks[1]); \\\n\t\ttmpss >> co; \\\n\t\tfv.setConst(co); \\\n\t} \\\n\tif(ctoks.size() >= 3) { \\\n\t\tdouble ce; \\\n\t\tistringstream tmpss(ctoks[2]); \\\n\t\ttmpss >> ce; \\\n\t\tfv.setCoeff(ce); \\\n\t} \\\n\tif(ctoks.size() >= 4) { \\\n\t\tdouble mn; \\\n\t\tistringstream tmpss(ctoks[3]); \\\n\t\ttmpss >> mn; \\\n\t\tfv.setMin(mn); \\\n\t} \\\n\tif(ctoks.size() >= 5) { \\\n\t\tdouble mx; \\\n\t\tistringstream tmpss(ctoks[4]); \\\n\t\ttmpss >> mx; \\\n\t\tfv.setMin(mx); \\\n\t} \\\n}", "idx": 4}
{"project": "bowtie2", "commit_id": "105_bowtie2_2.5.1_aligner_seed_policy.cpp_main.cpp", "target": 0, "func": "ifdef ALIGNER_SEED_POLICY_MAIN\nint main() {\n\n\tint bonusMatchType;\n\tint bonusMatch;\n\tint penMmcType;\n\tint penMmc;\n\tint penNType;\n\tint penN;\n\tint penRdExConst;\n\tint penRfExConst;\n\tint penRdExLinear;\n\tint penRfExLinear;\n\tSimpleFunc costMin;\n\tSimpleFunc costFloor;\n\tSimpleFunc nCeil;\n\tbool nCatPair;\n\tint multiseedMms;\n\tint multiseedLen;\n\tSimpleFunc msIval;\n\tSimpleFunc posfrac;\n\tSimpleFunc rowmult;\n\tuint32_t mhits;\n\n\t{\n\t\tcout << \"Case 1: Defaults 1 ... \";\n\t\tconst char *pol = \"\";\n\t\tSeedAlignmentPolicy::parseString(\n\t\t\tstring(pol),\n\t\t\tfalse,              // --local?\n\t\t\tfalse,              // noisy homopolymers a la 454?\n\t\t\tfalse,              // ignore qualities?\n\t\t\tbonusMatchType,\n\t\t\tbonusMatch,\n\t\t\tpenMmcType,\n\t\t\tpenMmc,\n\t\t\tpenNType,\n\t\t\tpenN,\n\t\t\tpenRdExConst,\n\t\t\tpenRfExConst,\n\t\t\tpenRdExLinear,\n\t\t\tpenRfExLinear,\n\t\t\tcostMin,\n\t\t\tcostFloor,\n\t\t\tnCeil,\n\t\t\tnCatPair,\n\t\t\tmultiseedMms,\n\t\t\tmultiseedLen,\n\t\t\tmsIval,\n\t\t\tmhits);\n\t\t\n\t\tassert_eq(DEFAULT_MATCH_BONUS_TYPE,   bonusMatchType);\n\t\tassert_eq(DEFAULT_MATCH_BONUS,        bonusMatch);\n\t\tassert_eq(DEFAULT_MM_PENALTY_TYPE,    penMmcType);\n\t\tassert_eq(DEFAULT_MM_PENALTY_MAX,     penMmcMax);\n\t\tassert_eq(DEFAULT_MM_PENALTY_MIN,     penMmcMin);\n\t\tassert_eq(DEFAULT_N_PENALTY_TYPE,     penNType);\n\t\tassert_eq(DEFAULT_N_PENALTY,          penN);\n\t\tassert_eq(DEFAULT_MIN_CONST,          costMin.getConst());\n\t\tassert_eq(DEFAULT_MIN_LINEAR,         costMin.getCoeff());\n\t\tassert_eq(DEFAULT_FLOOR_CONST,        costFloor.getConst());\n\t\tassert_eq(DEFAULT_FLOOR_LINEAR,       costFloor.getCoeff());\n\t\tassert_eq(DEFAULT_N_CEIL_CONST,       nCeil.getConst());\n\t\tassert_eq(DEFAULT_N_CAT_PAIR,         nCatPair);\n\n\t\tassert_eq(DEFAULT_READ_GAP_CONST,     penRdExConst);\n\t\tassert_eq(DEFAULT_READ_GAP_LINEAR,    penRdExLinear);\n\t\tassert_eq(DEFAULT_REF_GAP_CONST,      penRfExConst);\n\t\tassert_eq(DEFAULT_REF_GAP_LINEAR,     penRfExLinear);\n\t\tassert_eq(DEFAULT_SEEDMMS,            multiseedMms);\n\t\tassert_eq(DEFAULT_IVAL,               msIval.getType());\n\t\tassert_eq(DEFAULT_IVAL_A,             msIval.getCoeff());\n\t\tassert_eq(DEFAULT_IVAL_B,             msIval.getConst());\n\t\t\n\t\tcout << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\tcout << \"Case 2: Defaults 2 ... \";\n\t\tconst char *pol = \"\";\n\t\tSeedAlignmentPolicy::parseString(\n\t\t\tstring(pol),\n\t\t\tfalse,              // --local?\n\t\t\ttrue,               // noisy homopolymers a la 454?\n\t\t\tfalse,              // ignore qualities?\n\t\t\tbonusMatchType,\n\t\t\tbonusMatch,\n\t\t\tpenMmcType,\n\t\t\tpenMmc,\n\t\t\tpenNType,\n\t\t\tpenN,\n\t\t\tpenRdExConst,\n\t\t\tpenRfExConst,\n\t\t\tpenRdExLinear,\n\t\t\tpenRfExLinear,\n\t\t\tcostMin,\n\t\t\tcostFloor,\n\t\t\tnCeil,\n\t\t\tnCatPair,\n\t\t\tmultiseedMms,\n\t\t\tmultiseedLen,\n\t\t\tmsIval,\n\t\t\tmhits);\n\t\t\n\t\tassert_eq(DEFAULT_MATCH_BONUS_TYPE,   bonusMatchType);\n\t\tassert_eq(DEFAULT_MATCH_BONUS,        bonusMatch);\n\t\tassert_eq(DEFAULT_MM_PENALTY_TYPE,    penMmcType);\n\t\tassert_eq(DEFAULT_MM_PENALTY_MAX,     penMmc);\n\t\tassert_eq(DEFAULT_MM_PENALTY_MIN,     penMmc);\n\t\tassert_eq(DEFAULT_N_PENALTY_TYPE,     penNType);\n\t\tassert_eq(DEFAULT_N_PENALTY,          penN);\n\t\tassert_eq(DEFAULT_MIN_CONST,          costMin.getConst());\n\t\tassert_eq(DEFAULT_MIN_LINEAR,         costMin.getCoeff());\n\t\tassert_eq(DEFAULT_FLOOR_CONST,        costFloor.getConst());\n\t\tassert_eq(DEFAULT_FLOOR_LINEAR,       costFloor.getCoeff());\n\t\tassert_eq(DEFAULT_N_CEIL_CONST,       nCeil.getConst());\n\t\tassert_eq(DEFAULT_N_CAT_PAIR,         nCatPair);\n\n\t\tassert_eq(DEFAULT_READ_GAP_CONST_BADHPOLY,  penRdExConst);\n\t\tassert_eq(DEFAULT_READ_GAP_LINEAR_BADHPOLY, penRdExLinear);\n\t\tassert_eq(DEFAULT_REF_GAP_CONST_BADHPOLY,   penRfExConst);\n\t\tassert_eq(DEFAULT_REF_GAP_LINEAR_BADHPOLY,  penRfExLinear);\n\t\tassert_eq(DEFAULT_SEEDMMS,            multiseedMms);\n\t\tassert_eq(DEFAULT_IVAL,               msIval.getType());\n\t\tassert_eq(DEFAULT_IVAL_A,             msIval.getCoeff());\n\t\tassert_eq(DEFAULT_IVAL_B,             msIval.getConst());\n\t\t\n\t\tcout << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\tcout << \"Case 3: Defaults 3 ... \";\n\t\tconst char *pol = \"\";\n\t\tSeedAlignmentPolicy::parseString(\n\t\t\tstring(pol),\n\t\t\ttrue,               // --local?\n\t\t\tfalse,              // noisy homopolymers a la 454?\n\t\t\tfalse,              // ignore qualities?\n\t\t\tbonusMatchType,\n\t\t\tbonusMatch,\n\t\t\tpenMmcType,\n\t\t\tpenMmc,\n\t\t\tpenNType,\n\t\t\tpenN,\n\t\t\tpenRdExConst,\n\t\t\tpenRfExConst,\n\t\t\tpenRdExLinear,\n\t\t\tpenRfExLinear,\n\t\t\tcostMin,\n\t\t\tcostFloor,\n\t\t\tnCeil,\n\t\t\tnCatPair,\n\t\t\tmultiseedMms,\n\t\t\tmultiseedLen,\n\t\t\tmsIval,\n\t\t\tmhits);\n\t\t\n\t\tassert_eq(DEFAULT_MATCH_BONUS_TYPE_LOCAL,   bonusMatchType);\n\t\tassert_eq(DEFAULT_MATCH_BONUS_LOCAL,        bonusMatch);\n\t\tassert_eq(DEFAULT_MM_PENALTY_TYPE,    penMmcType);\n\t\tassert_eq(DEFAULT_MM_PENALTY_MAX,     penMmcMax);\n\t\tassert_eq(DEFAULT_MM_PENALTY_MIN,     penMmcMin);\n\t\tassert_eq(DEFAULT_N_PENALTY_TYPE,     penNType);\n\t\tassert_eq(DEFAULT_N_PENALTY,          penN);\n\t\tassert_eq(DEFAULT_MIN_CONST_LOCAL,    costMin.getConst());\n\t\tassert_eq(DEFAULT_MIN_LINEAR_LOCAL,   costMin.getCoeff());\n\t\tassert_eq(DEFAULT_FLOOR_CONST_LOCAL,  costFloor.getConst());\n\t\tassert_eq(DEFAULT_FLOOR_LINEAR_LOCAL, costFloor.getCoeff());\n\t\tassert_eq(DEFAULT_N_CEIL_CONST,       nCeil.getConst());\n\t\tassert_eq(DEFAULT_N_CEIL_LINEAR,      nCeil.getCoeff());\n\t\tassert_eq(DEFAULT_N_CAT_PAIR,         nCatPair);\n\n\t\tassert_eq(DEFAULT_READ_GAP_CONST,     penRdExConst);\n\t\tassert_eq(DEFAULT_READ_GAP_LINEAR,    penRdExLinear);\n\t\tassert_eq(DEFAULT_REF_GAP_CONST,      penRfExConst);\n\t\tassert_eq(DEFAULT_REF_GAP_LINEAR,     penRfExLinear);\n\t\tassert_eq(DEFAULT_SEEDMMS,            multiseedMms);\n\t\tassert_eq(DEFAULT_IVAL,               msIval.getType());\n\t\tassert_eq(DEFAULT_IVAL_A,             msIval.getCoeff());\n\t\tassert_eq(DEFAULT_IVAL_B,             msIval.getConst());\n\n\t\tcout << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\tcout << \"Case 4: Simple string 1 ... \";\n\t\tconst char *pol = \"MMP=C44;MA=4;RFG=24,12;FL=C,8;RDG=2;NP=C4;MIN=C,7\";\n\t\tSeedAlignmentPolicy::parseString(\n\t\t\tstring(pol),\n\t\t\ttrue,               // --local?\n\t\t\tfalse,              // noisy homopolymers a la 454?\n\t\t\tfalse,              // ignore qualities?\n\t\t\tbonusMatchType,\n\t\t\tbonusMatch,\n\t\t\tpenMmcType,\n\t\t\tpenMmc,\n\t\t\tpenNType,\n\t\t\tpenN,\n\t\t\tpenRdExConst,\n\t\t\tpenRfExConst,\n\t\t\tpenRdExLinear,\n\t\t\tpenRfExLinear,\n\t\t\tcostMin,\n\t\t\tcostFloor,\n\t\t\tnCeil,\n\t\t\tnCatPair,\n\t\t\tmultiseedMms,\n\t\t\tmultiseedLen,\n\t\t\tmsIval,\n\t\t\tmhits);\n\t\t\n\t\tassert_eq(COST_MODEL_CONSTANT,        bonusMatchType);\n\t\tassert_eq(4,                          bonusMatch);\n\t\tassert_eq(COST_MODEL_CONSTANT,        penMmcType);\n\t\tassert_eq(44,                         penMmc);\n\t\tassert_eq(COST_MODEL_CONSTANT,        penNType);\n\t\tassert_eq(4.0f,                       penN);\n\t\tassert_eq(7,                          costMin.getConst());\n\t\tassert_eq(DEFAULT_MIN_LINEAR_LOCAL,   costMin.getCoeff());\n\t\tassert_eq(8,                          costFloor.getConst());\n\t\tassert_eq(DEFAULT_FLOOR_LINEAR_LOCAL, costFloor.getCoeff());\n\t\tassert_eq(DEFAULT_N_CEIL_CONST,       nCeil.getConst());\n\t\tassert_eq(DEFAULT_N_CEIL_LINEAR,      nCeil.getCoeff());\n\t\tassert_eq(DEFAULT_N_CAT_PAIR,         nCatPair);\n\n\t\tassert_eq(2.0f,                       penRdExConst);\n\t\tassert_eq(DEFAULT_READ_GAP_LINEAR,    penRdExLinear);\n\t\tassert_eq(24.0f,                      penRfExConst);\n\t\tassert_eq(12.0f,                      penRfExLinear);\n\t\tassert_eq(DEFAULT_SEEDMMS,            multiseedMms);\n\t\tassert_eq(DEFAULT_IVAL,               msIval.getType());\n\t\tassert_eq(DEFAULT_IVAL_A,             msIval.getCoeff());\n\t\tassert_eq(DEFAULT_IVAL_B,             msIval.getConst());\n\n\t\tcout << \"PASSED\" << endl;\n\t}\n}", "idx": 5}
{"project": "bowtie2", "commit_id": "106_bowtie2_2.5.1_aligner_sw.cpp_printUsage.cpp", "target": 0, "func": "static void printUsage(ostream& os) {\n\tos << \"Usage: aligner_sw <read-seq> <ref-nuc-seq> [options]*\" << endl;\n\tos << \"Options:\" << endl;\n\tos << \"  -s/--snppen <int>   penalty incurred by SNP; used for decoding\"\n\t   << endl;\n\tos << \"  -m/--misspen <int>  quality to use for read chars\" << endl;\n\tos << \"  -r/-seed <int>      seed for pseudo-random generator\" << endl;\n}", "idx": 6}
{"project": "bowtie2", "commit_id": "107_bowtie2_2.5.1_aligner_sw.cpp_parse.cpp", "target": 0, "func": "T parse(const char *s) {\n\tT tmp;\n\tstringstream ss(s);\n\tss >> tmp;\n\treturn tmp;\n}", "idx": 7}
{"project": "bowtie2", "commit_id": "108_bowtie2_2.5.1_aligner_sw.cpp_doTestCase2.cpp", "target": 0, "func": "static void doTestCase2(\n\tSwAligner&         al,\n\tconst char        *read,\n\tconst char        *qual,\n\tconst char        *refin,\n\tTRefOff            off,\n\tconst Scoring&     sc,\n\tfloat              costMinConst,\n\tfloat              costMinLinear,\n\tSwResult&          res,\n\tbool               nsInclusive = false,\n\tbool               filterns = false,\n\tuint32_t           seed = 0)\n{\n\tbtread.install(read, true);\n\tTAlScore minsc = (TAlScore)(Scoring::linearFunc(\n\t\tbtread.length(),\n\t\tcostMinConst,\n\t\tcostMinLinear));\n\tTAlScore floorsc = (TAlScore)(Scoring::linearFunc(\n\t\tbtread.length(),\n\t\tcostFloorConst,\n\t\tcostFloorLinear));\n\tbtqual.install(qual);\n\tbtref.install(refin);\n\tdoTestCase(\n\t\tal,\n\t\tbtread,\n\t\tbtqual,\n\t\tbtref,\n\t\toff,\n\t\tNULL,\n\t\tsc,  \n\t\tminsc,\n\t\tfloorsc,\n\t\tres,\n\t\tnsInclusive,\n\t\tfilterns,\n\t\tseed\n\t);\n}", "idx": 8}
{"project": "bowtie2", "commit_id": "109_bowtie2_2.5.1_aligner_sw.cpp_doTestCase3.cpp", "target": 0, "func": "static void doTestCase3(\n\tSwAligner&         al,\n\tconst char        *read,\n\tconst char        *qual,\n\tconst char        *refin,\n\tTRefOff            off,\n\tScoring&           sc,\n\tfloat              costMinConst,\n\tfloat              costMinLinear,\n\tfloat              nCeilConst,\n\tfloat              nCeilLinear,\n\tSwResult&          res,\n\tbool               nsInclusive = false,\n\tbool               filterns = false,\n\tuint32_t           seed = 0)\n{\n\tbtread.install(read, true);\n\t// Calculate the penalty ceiling for the read\n\tTAlScore minsc = (TAlScore)(Scoring::linearFunc(\n\t\tbtread.length(),\n\t\tcostMinConst,\n\t\tcostMinLinear));\n\tTAlScore floorsc = (TAlScore)(Scoring::linearFunc(\n\t\tbtread.length(),\n\t\tcostFloorConst,\n\t\tcostFloorLinear));\n\tbtqual.install(qual);\n\tbtref.install(refin);\n\tsc.nCeil.setType(SIMPLE_FUNC_LINEAR);\n\tsc.nCeil.setConst(costMinConst);\n\tsc.nCeil.setCoeff(costMinLinear);\n\tdoTestCase(\n\t\tal,\n\t\tbtread,\n\t\tbtqual,\n\t\tbtref,\n\t\toff,\n\t\tNULL,\n\t\tsc,  \n\t\tminsc,\n\t\tfloorsc,\n\t\tres,\n\t\tnsInclusive,\n\t\tfilterns,\n\t\tseed\n\t);\n}", "idx": 9}
{"project": "bowtie2", "commit_id": "10_bowtie2_2.5.1_aligner_cache.h_reset.cpp", "target": 0, "func": "void reset() { topf = topb = OFF_MASK; offs.reset(); }", "idx": 10}
{"project": "bowtie2", "commit_id": "110_bowtie2_2.5.1_aligner_sw.cpp_doTestCase4.cpp", "target": 0, "func": "static void doTestCase4(\n\tSwAligner&         al,\n\tconst char        *read,\n\tconst char        *qual,\n\tconst char        *refin,\n\tTRefOff            off,\n\tEList<bool>&       en,\n\tScoring&           sc,\n\tfloat              costMinConst,\n\tfloat              costMinLinear,\n\tfloat              nCeilConst,\n\tfloat              nCeilLinear,\n\tSwResult&          res,\n\tbool               nsInclusive = false,\n\tbool               filterns = false,\n\tuint32_t           seed = 0)\n{\n\tbtread.install(read, true);\n\t// Calculate the penalty ceiling for the read\n\tTAlScore minsc = (TAlScore)(Scoring::linearFunc(\n\t\tbtread.length(),\n\t\tcostMinConst,\n\t\tcostMinLinear));\n\tTAlScore floorsc = (TAlScore)(Scoring::linearFunc(\n\t\tbtread.length(),\n\t\tcostFloorConst,\n\t\tcostFloorLinear));\n\tbtqual.install(qual);\n\tbtref.install(refin);\n\tsc.nCeil.setType(SIMPLE_FUNC_LINEAR);\n\tsc.nCeil.setConst(costMinConst);\n\tsc.nCeil.setCoeff(costMinLinear);\n\tdoTestCase(\n\t\tal,\n\t\tbtread,\n\t\tbtqual,\n\t\tbtref,\n\t\toff,\n\t\t&en,\n\t\tsc,  \n\t\tminsc,\n\t\tfloorsc,\n\t\tres,\n\t\tnsInclusive,\n\t\tfilterns,\n\t\tseed\n\t);\n}", "idx": 11}
{"project": "bowtie2", "commit_id": "111_bowtie2_2.5.1_aligner_sw.cpp_doTests.cpp", "target": 0, "func": "static void doTests() {\n\tbonusMatchType  = DEFAULT_MATCH_BONUS_TYPE;\n\tbonusMatch      = DEFAULT_MATCH_BONUS;\n\tpenMmcType      = DEFAULT_MM_PENALTY_TYPE;\n\tpenMmc          = DEFAULT_MM_PENALTY;\n\tpenSnp          = DEFAULT_SNP_PENALTY;\n\tpenNType        = DEFAULT_N_PENALTY_TYPE;\n\tpenN            = DEFAULT_N_PENALTY;\n\tnPairCat        = DEFAULT_N_CAT_PAIR;\n\tpenRdExConst    = DEFAULT_READ_GAP_CONST;\n\tpenRfExConst    = DEFAULT_REF_GAP_CONST;\n\tpenRdExLinear   = DEFAULT_READ_GAP_LINEAR;\n\tpenRfExLinear   = DEFAULT_REF_GAP_LINEAR;\n\tcostMinConst    = DEFAULT_MIN_CONST;\n\tcostMinLinear   = DEFAULT_MIN_LINEAR;\n\tcostFloorConst  = DEFAULT_FLOOR_CONST;\n\tcostFloorLinear = DEFAULT_FLOOR_LINEAR;\n\tnCeilConst      = 1.0f; // constant factor in N ceil w/r/t read len\n\tnCeilLinear     = 0.1f; // coeff of linear term in N ceil w/r/t read len\n\tmultiseedMms    = DEFAULT_SEEDMMS;\n\tmultiseedLen    = DEFAULT_SEEDLEN;\n\t// Set up penalities\n\tScoring sc(\n\t\tbonusMatch,\n\t\tpenMmcType,    // how to penalize mismatches\n\t\t30,        // constant if mm pelanty is a constant\n\t\t30,        // penalty for decoded SNP\n\t\tcostMinConst,  // constant factor in N ceiling w/r/t read length\n\t\tcostMinLinear, // coeff of linear term in N ceiling w/r/t read length\n\t\tcostFloorConst,  // constant factor in N ceiling w/r/t read length\n\t\tcostFloorLinear, // coeff of linear term in N ceiling w/r/t read length\n\t\tnCeilConst,    // constant factor in N ceiling w/r/t read length\n\t\tnCeilLinear,   // coeff of linear term in N ceiling w/r/t read length\n\t\tpenNType,      // how to penalize Ns in the read\n\t\tpenN,          // constant if N pelanty is a constant\n\t\tnPairCat,      // true -> concatenate mates before N filtering\n\t\t25,  // constant coeff for cost of gap in read\n\t\t25,  // constant coeff for cost of gap in ref\n\t\t15, // linear coeff for cost of gap in read\n\t\t15, // linear coeff for cost of gap in ref\n\t\t1,             // # rows at top/bot can only be entered diagonally\n\t\t-1,            // min row idx to backtrace from; -1 = no limit\n\t\tfalse          // sort results first by row then by score?\n\t);\n\t// Set up alternative penalities\n\tScoring sc2(\n\t\tbonusMatch,\n\t\tCOST_MODEL_QUAL, // how to penalize mismatches\n\t\t30,          // constant if mm pelanty is a constant\n\t\t30,          // penalty for decoded SNP\n\t\tcostMinConst,  // constant factor in N ceiling w/r/t read length\n\t\tcostMinLinear, // coeff of linear term in N ceiling w/r/t read length\n\t\tcostFloorConst,  // constant factor in N ceiling w/r/t read length\n\t\tcostFloorLinear, // coeff of linear term in N ceiling w/r/t read length\n\t\t1.0f,            // constant factor in N ceiling w/r/t read length\n\t\t1.0f,            // coeff of linear term in N ceiling w/r/t read length\n\t\tpenNType,        // how to penalize Ns in the read\n\t\tpenN,            // constant if N pelanty is a constant\n\t\tnPairCat,        // true -> concatenate mates before N filtering\n\t\t25,    // constant coeff for cost of gap in read\n\t\t25,    // constant coeff for cost of gap in ref\n\t\t15,   // linear coeff for cost of gap in read\n\t\t15,   // linear coeff for cost of gap in ref\n\t\t1,               // # rows at top/bot can only be entered diagonally\n\t\t-1,              // min row idx to backtrace from; -1 = no limit\n\t\tfalse            // sort results first by row then by score?\n\t);\n\tSwResult res;\n\t\n\t//\n\t// Basic nucleotide-space tests\n\t//\n\tcerr << \"Running tests...\" << endl;\n\tint tests = 1;\n\tbool nIncl = false;\n\tbool nfilter = false;\n\n\tSwAligner al;\n\tRandomSource rnd(73);\n\tfor(int i = 0; i < 3; i++) {\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \"\n\t\t     << (i*4) << \", exact)...\";\n\t\tsc.rdGapConst = 40;\n\t\tsc.rfGapConst = 40;\n\t\tsc.rdGapLinear = 15;\n\t\tsc.rfGapLinear = 15;\n\t//        A           C           G           T           A           C           G           T\n\t//    H   E   F   H   E   F   H   E   F   H   E   F   H   E   F   H   E   F   H   E   F   H   E   F\n\t// A  0   lo  lo -30  lo  lo -30  lo  lo -30 lo lo 0 lo lo -30 lo lo-30 lo lo-30 lo lo\n\t// C -30  lo -55  0  -85 -85 -55 -55 -85\n\t// G -30  lo -70 -55 -85 -55  0 -100-100\n\t// T -30  lo -85 -60 -85 -70 -55-100 -55\n\t// A  0   lo -85 -55 -55 -85 -70 -70 -70\n\t// C -30  lo -55  0  -85-100 -55 -55 -85\n\t// G -30  lo -70 -55 -85 -55  0 -100-100\n\t// T -30  lo -85 -60 -85 -70 -55-100 -55\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTACGT\",         // read\n\t\t\t\"IIIIIIII\",         // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), 0);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tassert(res.alres.ned().empty());\n\t\tassert(res.alres.aed().empty());\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tassert(al.done());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1mm allowed by minsc)...\";\n\t\tsc.setMmPen(COST_MODEL_CONSTANT, 30);\n\t\t//sc.setMatchBonus(10);\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTTCGT\",         // read\n\t\t\t\"IIIIIIII\",         // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), -30);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tassert(al.done());\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1mm allowed by minsc, check qual 1)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTTCGT\",         // read\n\t\t\t\"ABCDEFGH\",         // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc2,                // scoring scheme\n\t\t\t-40.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tsize_t lo, hi;\n\t\tif(i == 0) {\n\t\t\tlo = 0; hi = 1;\n\t\t} else if(i == 1) {\n\t\t\tlo = 1; hi = 2;\n\t\t} else {\n\t\t\tlo = 2; hi = 3;\n\t\t}\n\t\tfor(size_t j = lo; j < hi; j++) {\n\t\t\tal.nextAlignment(res, rnd);\n\t\t\tassert(!res.empty());\n\t\t\tassert_eq(j*4, res.alres.refoff());\n\t\t\tassert_eq(8, res.alres.refExtent());\n\t\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\t\tassert_eq(res.alres.score().score(), -36);\n\t\t\tassert_eq(res.alres.score().ns(), 0);\n\t\t\tres.reset();\n\t\t}\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1mm allowed by minsc, check qual 2)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGAACGT\",         // read\n\t\t\t\"ABCDEFGH\",         // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc2,                // scoring scheme\n\t\t\t-40.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), -35);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tassert(res.empty());\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1mm allowed by minsc, check qual )...\";\n\t\tassert(res.empty());\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"TCGTACGT\",         // read\n\t\t\t\"ABCDEFGH\",         // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc2,                // scoring scheme\n\t\t\t-40.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), -32);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tassert(res.empty());\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1mm at the beginning, allowed by minsc)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"CCGTACGT\",         // read\n\t\t\t\"IIIIIIII\",         // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), -30);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tassert_eq(1, res.alres.ned().size());\n\t\tassert_eq(0, res.alres.aed().size());\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1 n in read, allowed)...\";\n\t\tdoTestCase3(\n\t\t\tal,\n\t\t\t\"ACGTNCGT\",         // read\n\t\t\t\"IIIIIIII\",         // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\t1.0f,               // allow 1 N\n\t\t\t0.0f,               // allow 1 N\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), -1);\n\t\tassert_eq(res.alres.score().ns(), 1);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 2 n in read, allowed)...\";\n\t\tdoTestCase3(\n\t\t\tal,\n\t\t\t\"ACGNNCGT\",         // read\n\t\t\t\"IIIIIIII\",         // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\t2.0f,               // const coeff for N ceiling\n\t\t\t0.0f,               // linear coeff for N ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), -2);\n\t\tassert_eq(res.alres.score().ns(), 2);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 2 n in read, 1 at beginning, allowed)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"NCGTNCGT\",         // read\n\t\t\t\"IIIIIIII\",         // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), -2);\n\t\tassert_eq(res.alres.score().ns(), 2);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1 n in ref, allowed)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTACGT\",         // read\n\t\t\t\"IIIIIIII\",         // qual\n\t\t\t\"ACGTNCGTACGTANGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), -1);\n\t\tassert_eq(res.alres.score().ns(), 1);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1mm disallowed by minsc)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTTCGT\",         // read\n\t\t\t\"IIIIIIII\",         // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-10.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tassert(al.done());\n\t\t// Read gap with equal read and ref gap penalties\n\t\tcerr << \"PASSED\" << endl;\n\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", read gap allowed by minsc)...\";\n\t\tassert(res.empty());\n\t\tsc.rfGapConst = 25;\n\t\tsc.rdGapConst = 25;\n\t\tsc.rfGapLinear = 15;\n\t\tsc.rdGapLinear = 15;\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTCGT\",          // read\n\t\t\t\"IIIIIII\",          // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-40.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 1);\n\t\tassert_eq(res.alres.score().score(), -40);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", read gap disallowed by minsc)...\";\n\t\tsc.rfGapConst = 25;\n\t\tsc.rdGapConst = 25;\n\t\tsc.rfGapLinear = 15;\n\t\tsc.rdGapLinear = 15;\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTCGT\",          // read\n\t\t\t\"IIIIIII\",          // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tassert(al.done());\n\t\tres.reset();\n\n\t\tcerr << \"PASSED\" << endl;\n\t\t// Ref gap with equal read and ref gap penalties\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", ref gap allowed by minsc)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTAACGT\",        // read\n\t\t\t\"IIIIIIIII\",        // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-40.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 1);\n\t\tassert_eq(res.alres.score().score(), -40);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", read gap disallowed by gap barrier)...\";\n\t\tsc.rfGapConst = 25;\n\t\tsc.rdGapConst = 25;\n\t\tsc.rfGapLinear = 15;\n\t\tsc.rdGapLinear = 15;\n\t\tsc.gapbar = 4;\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTCGT\",          // read\n\t\t\t\"IIIIIII\",          // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-40.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tsc.gapbar = 1;\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tassert(al.done());\n\t\tres.reset();\n\n\t\tcerr << \"PASSED\" << endl;\n\t\t// Ref gap with equal read and ref gap penalties\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", ref gap allowed by minsc, gapbar=3)...\";\n\t\tsc.gapbar = 3;\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTAACGT\",        // read\n\t\t\t\"IIIIIIIII\",        // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-40.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tsc.gapbar = 1;\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 1);\n\t\tassert_eq(res.alres.score().score(), -40);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\n\t\t// Ref gap with equal read and ref gap penalties\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", ref gap allowed by minsc, gapbar=4)...\";\n\t\tsc.gapbar = 4;\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTAACGT\",        // read\n\t\t\t\"IIIIIIIII\",        // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-40.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tsc.gapbar = 1;\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 1);\n\t\tassert_eq(res.alres.score().score(), -40);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", ref gap disallowed by minsc)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTAACGT\",        // read\n\t\t\t\"IIIIIIIII\",        // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tassert(al.done());\n\t\tcerr << \"PASSED\" << endl;\n\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", ref gap disallowed by gap barrier)...\";\n\t\tsc.gapbar = 5;\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTAACGT\",        // read\n\t\t\t\"IIIIIIIII\",        // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-40.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tsc.gapbar = 1;\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tassert(al.done());\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\t// Read gap with one read gap and zero ref gaps allowed\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1 read gap, ref gaps disallowed by minsc)...\";\n\t\tsc.rfGapConst = 35;\n\t\tsc.rdGapConst = 25;\n\t\tsc.rfGapLinear = 20;\n\t\tsc.rdGapLinear = 10;\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTCGT\",          // read\n\t\t\t\"IIIIIII\",          // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-40.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 1);\n\t\tassert_eq(res.alres.score().score(), -35);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", gaps disallowed by minsc)...\";\n\t\tsc.rfGapConst = 25;\n\t\tsc.rdGapConst = 25;\n\t\tsc.rfGapLinear = 10;\n\t\tsc.rdGapLinear = 10;\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTCGT\",          // read\n\t\t\t\"IIIIIII\",          // qual \n\t\t\t\"ACGTACGTACGTACGT\", // ref \n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tassert(res.empty());\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\t// Ref gap with one ref gap and zero read gaps allowed\n\t\tsc.rfGapConst = 25;\n\t\tsc.rdGapConst = 35;\n\t\tsc.rfGapLinear = 12;\n\t\tsc.rdGapLinear = 22;\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1 ref gap, read gaps disallowed by minsc)...\";\n\t\tassert(res.empty());\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTAACGT\",\n\t\t\t\"IIIIIIIII\",\n\t\t\t\"ACGTACGTACGTACGT\",\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-40.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 1);\n\t\tassert_eq(res.alres.score().score(), -37);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t\t<< \", gaps disallowed by minsc)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTAACGT\",\n\t\t\t\"IIIIIIIII\",\n\t\t\t\"ACGTACGTACGTACGT\",\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tassert(al.done());\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\t// Read gap with one read gap and two ref gaps allowed\n\t\tsc.rfGapConst = 20;\n\t\tsc.rdGapConst = 25;\n\t\tsc.rfGapLinear = 10;\n\t\tsc.rdGapLinear = 15;\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1 read gap, 2 ref gaps allowed by minsc)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTCGT\",\n\t\t\t\"IIIIIII\",\n\t\t\t\"ACGTACGTACGTACGT\",\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-40.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 1);\n\t\tassert_eq(res.alres.score().score(), -40);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", gaps disallowed by minsc)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTCGT\",\n\t\t\t\"IIIIIII\",\n\t\t\t\"ACGTACGTACGTACGT\",\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tassert(al.done());\n\t\tcerr << \"PASSED\" << endl;\n\n\t\t// Ref gap with one ref gap and two read gaps allowed\n\t\tsc.rfGapConst = 25;\n\t\tsc.rdGapConst = 11;  // if this were 10, we'd have ties\n\t\tsc.rfGapLinear = 15;\n\t\tsc.rdGapLinear = 10;\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1 ref gap, 2 read gaps allowed by minsc)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTAACGT\",\n\t\t\t\"IIIIIIIII\",\n\t\t\t\"ACGTACGTACGTACGT\",\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-40.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 1);\n\t\tassert_eq(res.alres.score().score(), -40);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4) << \", gaps disallowed by minsc)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTAACGT\",\n\t\t\t\"IIIIIIIII\",\n\t\t\t\"ACGTACGTACGTACGT\",\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tres.reset();\n\t\tassert(al.done());\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\t// Read gap with two read gaps and two ref gaps allowed\n\t\tsc.rfGapConst = 15;\n\t\tsc.rdGapConst = 15;\n\t\tsc.rfGapLinear = 10;\n\t\tsc.rdGapLinear = 10;\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 2 ref gaps, 2 read gaps allowed by minsc)...\";\n\t\tdoTestCase3(\n\t\t\tal,\n\t\t\t\"ACGTCGT\",\n\t\t\t\"IIIIIII\",\n\t\t\t\"ACGTACGTACGTACGT\",\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-40.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\t1.0,                // const coeff for N ceiling\n\t\t\t0.0,                // linear coeff for N ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\ttrue);              // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tif(!res.empty()) {\n\t\t\t//al.printResultStacked(res, cerr); cerr << endl;\n\t\t}\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 1);\n\t\tassert_eq(res.alres.score().score(), -25);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\t// The following alignment is possible when i == 2:\n\t\t//   ACGTACGTACGTACGTN\n\t\t// A             x\n\t\t// C              x\n\t\t// G               x\n\t\t// T                x\n\t\t// C                x\n\t\t// G                x\n\t\t// T                 x\n\t\tassert(i == 2 || res.empty());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tsc.rfGapConst = 10;\n\t\tsc.rdGapConst = 10;\n\t\tsc.rfGapLinear = 10;\n\t\tsc.rdGapLinear = 10;\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1 ref gap, 1 read gap allowed by minsc)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTCGT\",\n\t\t\t\"IIIIIII\",\n\t\t\t\"ACGTACGTACGTACGT\",\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 1);\n\t\tassert_eq(res.alres.score().score(), -20);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\t// Ref gap with two ref gaps and zero read gaps allowed\n\t\tsc.rfGapConst = 15;\n\t\tsc.rdGapConst = 15;\n\t\tsc.rfGapLinear = 5;\n\t\tsc.rdGapLinear = 5;\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 2 ref gaps, 2 read gaps allowed by minsc)...\";\n\t\t// Careful: it might be possible for the read to align with overhang\n\t\t// instead of with a gap\n\t\tdoTestCase3(\n\t\t\tal,\n\t\t\t\"ACGTAACGT\",\n\t\t\t\"IIIIIIIII\",\n\t\t\t\"ACGTACGTACGTACGT\",\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-35.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\t1.0f,               // needed to avoid overhang alignments\n\t\t\t0.0f,               // needed to avoid overhang alignments\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\ttrue);              // filter Ns\n\t\tif(i == 0) {\n\t\t\tlo = 0; hi = 1;\n\t\t} else if(i == 1) {\n\t\t\tlo = 1; hi = 2;\n\t\t} else {\n\t\t\tlo = 2; hi = 3;\n\t\t}\n\t\tfor(size_t j = lo; j < hi; j++) {\n\t\t\tal.nextAlignment(res, rnd);\n\t\t\tassert(!res.empty());\n\t\t\t//al.printResultStacked(res, cerr); cerr << endl;\n\t\t\tassert(res.alres.refoff() == 0 ||\n\t\t\t       res.alres.refoff() == 4 ||\n\t\t\t\t   res.alres.refoff() == 8);\n\t\t\tassert_eq(8, res.alres.refExtent());\n\t\t\tassert_eq(res.alres.score().gaps(), 1);\n\t\t\tassert_eq(res.alres.score().score(), -20);\n\t\t\tassert_eq(res.alres.score().ns(), 0);\n\t\t\tres.reset();\n\t\t}\n\t\tal.nextAlignment(res, rnd);\n\t\t//assert(res.empty());\n\t\t//res.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tsc.rfGapConst = 25;\n\t\tsc.rdGapConst = 25;\n\t\tsc.rfGapLinear = 4;\n\t\tsc.rdGapLinear = 4;\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1 ref gap, 1 read gap allowed by minsc)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTAACGT\",\n\t\t\t\"IIIIIIIII\",\n\t\t\t\"ACGTACGTACGTACGT\",\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 1);\n\t\tassert_eq(res.alres.score().score(), -29);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", short read)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"A\",\n\t\t\t\"I\",\n\t\t\t\"AAAAAAAAAAAA\",\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), 0);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\n\t\tif(i == 0) {\n\t\t\tcerr << \"  Test \" << tests++\n\t\t\t     << \" (nuc space, offset 0, short read & ref)...\";\n\t\t\tdoTestCase2(\n\t\t\t\tal,\n\t\t\t\t\"A\",\n\t\t\t\t\"I\",\n\t\t\t\t\"A\",\n\t\t\t\t0,                  // off\n\t\t\t\tsc,                 // scoring scheme\n\t\t\t\t-30.0f,             // const coeff for cost ceiling\n\t\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\t\tres,                // result\n\t\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\t\tnfilter);           // filter Ns\n\t\t\tal.nextAlignment(res, rnd);\n\t\t\tassert(!res.empty());\n\t\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\t\tassert_eq(res.alres.score().score(), 0);\n\t\t\tassert_eq(res.alres.score().ns(), 0);\n\t\t\tres.reset();\n\t\t\tcerr << \"PASSED\" << endl;\n\t\t}\n\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", short read, many allowed gaps)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"A\",\n\t\t\t\"I\",\n\t\t\t\"AAAAAAAAAAAA\",\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t-150.0f,            // const coeff for cost ceiling\n\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), 0);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\n\t\tif(i == 0) {\n\t\t\tcerr << \"  Test \" << tests++\n\t\t\t     << \" (nuc space, offset 0, short read & ref, \"\n\t\t\t\t << \"many allowed gaps)...\";\n\t\t\tdoTestCase2(\n\t\t\t\tal,\n\t\t\t\t\"A\",\n\t\t\t\t\"I\",\n\t\t\t\t\"A\",\n\t\t\t\t0,                  // off\n\t\t\t\tsc,                 // scoring scheme\n\t\t\t\t-150.0f,            // const coeff for cost ceiling\n\t\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\t\tres,                // result\n\t\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\t\tnfilter);           // filter Ns\n\t\t\tal.nextAlignment(res, rnd);\n\t\t\tassert(!res.empty());\n\t\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\t\tassert_eq(res.alres.score().score(), 0);\n\t\t\tassert_eq(res.alres.score().ns(), 0);\n\t\t\tres.reset();\n\t\t\tcerr << \"PASSED\" << endl;\n\t\t}\n\t}\n\n\t// A test case where a valid alignment with a worse score should be\n\t// accepted over a valid alignment with a better score but too many\n\t// Ns\n\tcerr << \"  Test \" << tests++ << \" (N ceiling 1)...\";\n\tsc.mmcostType = COST_MODEL_CONSTANT;\n\tsc.mmcost = 10;\n\tsc.snp = 30;\n\tsc.nCeilConst  = 0.0f;\n\tsc.nCeilLinear = 0.0f;\n\tsc.rfGapConst  = 10;\n\tsc.rdGapLinear = 10;\n\tsc.rfGapConst  = 10;\n\tsc.rfGapLinear = 10;\n\tsc.setNPen(COST_MODEL_CONSTANT, 2);\n\tsc.gapbar = 1;\n\t// No Ns allowed, so this hit should be filtered\n\tdoTestCase2(\n\t\tal,\n\t\t\"ACGTACGT\", // read seq\n\t\t\"IIIIIIII\", // read quals\n\t\t\"NCGTACGT\", // ref seq\n\t\t0,          // offset\n\t\tsc,         // scoring scheme\n\t\t-25.0f,     // const coeff for cost ceiling\n\t\t0.0f,       // linear coeff for cost ceiling\n\t\tres,        // result\n\t\tfalse,      // ns are in inclusive\n\t\ttrue,       // nfilter\n\t\t0);\n\tal.nextAlignment(res, rnd);\n\tassert(res.empty());\n\tcerr << \"PASSED\" << endl;\n\tres.reset();\n\n\t// 1 N allowed, so this hit should stand\n\tcerr << \"  Test \" << tests++ << \" (N ceiling 2)...\";\n\tdoTestCase3(\n\t\tal,\n\t\t\"ACGTACGT\", // read seq\n\t\t\"IIIIIIII\", // read quals\n\t\t\"NCGTACGT\", // ref seq\n\t\t0,          // offset\n\t\tsc,         // scoring scheme\n\t\t-25.0f,     // const coeff for cost ceiling\n\t\t0.0f,       // linear coeff for cost ceiling\n\t\t1.0f,       // constant coefficient for # Ns allowed\n\t\t0.0f,       // linear coefficient for # Ns allowed\n\t\tres,        // result\n\t\tfalse,      // ns are in inclusive\n\t\tfalse,      // nfilter - NOTE: FILTER OFF\n\t\t0);\n\tal.nextAlignment(res, rnd);\n\tassert(!res.empty());\n\tassert_eq(0,  res.alres.score().gaps());\n\tassert_eq(-2, res.alres.score().score());\n\tassert_eq(1,  res.alres.score().ns());\n\tcerr << \"PASSED\" << endl;\n\tres.reset();\n\n\t// 1 N allowed, but we set st_ such that this hit should not stand\n\tfor(size_t i = 0; i < 2; i++) {\n\t\tcerr << \"  Test \" << tests++ << \" (N ceiling 2 with st_ override)...\";\n\t\tEList<bool> en;\n\t\ten.resize(3); en.fill(true);\n\t\tif(i == 1) {\n\t\t\ten[1] = false;\n\t\t}\n\t\tsc.rfGapConst  = 10;\n\t\tsc.rdGapLinear = 10;\n\t\tsc.rfGapConst  = 10;\n\t\tsc.rfGapLinear = 10;\n\t\tdoTestCase4(\n\t\t\tal,\n\t\t\t\"ACGTACGT\", // read seq\n\t\t\t\"IIIIIIII\", // read quals\n\t\t\t\"NCGTACGT\", // ref seq\n\t\t\t0,          // offset\n\t\t\ten,         // rectangle columns where solution can end\n\t\t\tsc,         // scoring scheme\n\t\t\t-25.0f,     // const coeff for cost ceiling\n\t\t\t0.0f,       // linear coeff for cost ceiling\n\t\t\t1.0f,       // constant coefficient for # Ns allowed\n\t\t\t0.0f,       // linear coefficient for # Ns allowed\n\t\t\tres,        // result\n\t\t\tfalse,      // ns are in inclusive\n\t\t\tfalse,      // nfilter - NOTE: FILTER OFF\n\t\t\t0);\n\t\tal.nextAlignment(res, rnd);\n\t\tif(i > 0) {\n\t\t\tassert(res.empty());\n\t\t} else {\n\t\t\tassert(!res.empty());\n\t\t}\n\t\tcerr << \"PASSED\" << endl;\n\t\tres.reset();\n\t}\n\n\t// No Ns allowed, so this hit should be filtered\n\tcerr << \"  Test \" << tests++ << \" (N ceiling 3)...\";\n\tsc.nCeilConst = 1.0f;\n\tsc.nCeilLinear = 0.0f;\n\tdoTestCase2(\n\t\tal,\n\t\t\"ACGTACGT\", // read seq\n\t\t\"IIIIIIII\", // read quals\n\t\t\"NCGTACGT\", // ref seq\n\t\t0,          // offset\n\t\tsc,         // scoring scheme\n\t\t-25.0f,     // const coeff for cost ceiling\n\t\t0.0f,       // linear coeff for cost ceiling\n\t\tres,        // result\n\t\tfalse,      // ns are in inclusive\n\t\ttrue,       // nfilter - NOTE: FILTER ON\n\t\t0);\n\tal.nextAlignment(res, rnd);\n\tassert(!res.empty());\n\tassert_eq(0,  res.alres.score().gaps());\n\tassert_eq(-2, res.alres.score().score());\n\tassert_eq(1,  res.alres.score().ns());\n\tcerr << \"PASSED\" << endl;\n\tres.reset();\n\n\t// No Ns allowed, so this hit should be filtered\n\tcerr << \"  Test \" << tests++ << \" (redundant alignment elimination 1)...\";\n\tsc.nCeilConst = 1.0f;\n\tsc.nCeilLinear = 0.0f;\n\tsc.rfGapConst  = 25;\n\tsc.rdGapLinear = 15;\n\tsc.rfGapConst  = 25;\n\tsc.rfGapLinear = 15;\n\tdoTestCase2(\n\t\tal,\n\t\t//                   1         2         3         4\n\t\t//         01234567890123456789012345678901234567890123456\n\t\t          \"AGGCTATGCCTCTGACGCGATATCGGCGCCCACTTCAGAGCTAACCG\",\n\t\t          \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\",\n\t\t  \"TTTTTTTTAGGCTATGCCTCTGACGCGATATCGGCGCCCACTTCAGAGCTAACCGTTTTTTT\",\n\t\t// 01234567890123456789012345678901234567890123456789012345678901\n\t\t//           1         2         3         4         5         6\n\t\t8,          // offset\n\t\tsc,         // scoring scheme\n\t\t-25.0f,     // const coeff for cost ceiling\n\t\t-5.0f,      // linear coeff for cost ceiling\n\t\tres,        // result\n\t\tfalse,      // ns are in inclusive\n\t\ttrue,       // nfilter - NOTE: FILTER ON\n\t\t0);\n\tal.nextAlignment(res, rnd);\n\tassert(!res.empty());\n\tassert_eq(8, res.alres.refoff());\n\tassert_eq(47, res.alres.refExtent());\n\tassert_eq(0, res.alres.score().gaps());\n\tassert_eq(0, res.alres.score().score());\n\tassert_eq(0, res.alres.score().ns());\n\tres.reset();\n\tal.nextAlignment(res, rnd);\n\tassert(res.empty());\n\tassert(al.done());\n\tcerr << \"PASSED\" << endl;\n\tres.reset();\n\t\n}", "idx": 12}
{"project": "bowtie2", "commit_id": "112_bowtie2_2.5.1_aligner_sw.cpp_doLocalTests.cpp", "target": 0, "func": "static void doLocalTests() {\n\tbonusMatchType  = DEFAULT_MATCH_BONUS_TYPE;\n\tbonusMatch      = DEFAULT_MATCH_BONUS_LOCAL;\n\tpenMmcType      = DEFAULT_MM_PENALTY_TYPE;\n\tpenMmc          = DEFAULT_MM_PENALTY;\n\tpenSnp          = DEFAULT_SNP_PENALTY;\n\tpenNType        = DEFAULT_N_PENALTY_TYPE;\n\tpenN            = DEFAULT_N_PENALTY;\n\tnPairCat        = DEFAULT_N_CAT_PAIR;\n\tpenRdExConst    = DEFAULT_READ_GAP_CONST;\n\tpenRfExConst    = DEFAULT_REF_GAP_CONST;\n\tpenRdExLinear   = DEFAULT_READ_GAP_LINEAR;\n\tpenRfExLinear   = DEFAULT_REF_GAP_LINEAR;\n\tcostMinConst    = DEFAULT_MIN_CONST_LOCAL;\n\tcostMinLinear   = DEFAULT_MIN_LINEAR_LOCAL;\n\tcostFloorConst  = DEFAULT_FLOOR_CONST_LOCAL;\n\tcostFloorLinear = DEFAULT_FLOOR_LINEAR_LOCAL;\n\tnCeilConst      = 1.0f; // constant factor in N ceil w/r/t read len\n\tnCeilLinear     = 0.1f; // coeff of linear term in N ceil w/r/t read len\n\tmultiseedMms    = DEFAULT_SEEDMMS;\n\tmultiseedLen    = DEFAULT_SEEDLEN;\n\t// Set up penalities\n\tScoring sc(\n\t\t10,\n\t\tpenMmcType,    // how to penalize mismatches\n\t\t30,            // constant if mm pelanty is a constant\n\t\tpenSnp,        // penalty for decoded SNP\n\t\tcostMinConst,  // constant factor in N ceiling w/r/t read length\n\t\tcostMinLinear, // coeff of linear term in N ceiling w/r/t read length\n\t\tcostFloorConst,  // constant factor in N ceiling w/r/t read length\n\t\tcostFloorLinear, // coeff of linear term in N ceiling w/r/t read length\n\t\tnCeilConst,    // constant factor in N ceiling w/r/t read length\n\t\tnCeilLinear,   // coeff of linear term in N ceiling w/r/t read length\n\t\tpenNType,      // how to penalize Ns in the read\n\t\tpenN,          // constant if N pelanty is a constant\n\t\tnPairCat,      // true -> concatenate mates before N filtering\n\t\t25,            // constant coeff for cost of gap in read\n\t\t25,            // constant coeff for cost of gap in ref\n\t\t15,            // linear coeff for cost of gap in read\n\t\t15,            // linear coeff for cost of gap in ref\n\t\t1,             // # rows at top/bot can only be entered diagonally\n\t\t-1,            // min row idx to backtrace from; -1 = no limit\n\t\tfalse          // sort results first by row then by score?\n\t);\n\tSwResult res;\n\t\n\t//\n\t// Basic nucleotide-space tests\n\t//\n\tcerr << \"Running local tests...\" << endl;\n\tint tests = 1;\n\tbool nIncl = false;\n\tbool nfilter = false;\n\n\tSwAligner al;\n\tRandomSource rnd(73);\n\tfor(int i = 0; i < 3; i++) {\n\t\tcerr << \"  Test \" << tests++ << \" (short nuc space, offset \"\n\t\t     << (i*4) << \", exact)...\";\n\t\tsc.rdGapConst = 40;\n\t\tsc.rfGapConst = 40;\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGT\",             // read\n\t\t\t\"IIII\",             // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t0.0f,               // const coeff for cost ceiling\n\t\t\t8.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(4, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), 40);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tassert(res.alres.ned().empty());\n\t\tassert(res.alres.aed().empty());\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tassert(al.done());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\n\t\t//     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n\t\t//     A C G T A C G T A C G T A C G T\n\t\t// 0 C\n\t\t// 1 C   x\n\t\t// 2 G     x\n\t\t// 3 T       x\n\n\t\tcerr << \"  Test \" << tests++ << \" (short nuc space, offset \"\n\t\t     << (i*4) << \", 1mm)...\";\n\t\tsc.rdGapConst = 40;\n\t\tsc.rfGapConst = 40;\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"CCGT\",             // read\n\t\t\t\"IIII\",             // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t0.0f,               // const coeff for cost ceiling\n\t\t\t7.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4+1, res.alres.refoff());\n\t\tassert_eq(3, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), 30);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tassert(res.alres.ned().empty());\n\t\tassert(res.alres.aed().empty());\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tassert(al.done());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\n\t\tcerr << \"  Test \" << tests++ << \" (short nuc space, offset \"\n\t\t     << (i*4) << \", 1mm)...\";\n\t\tsc.rdGapConst = 40;\n\t\tsc.rfGapConst = 40;\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGA\",             // read\n\t\t\t\"IIII\",             // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t0.0f,               // const coeff for cost ceiling\n\t\t\t7.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(3, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), 30);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tassert(res.alres.ned().empty());\n\t\tassert(res.alres.aed().empty());\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tassert(al.done());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\n\t\tif(i == 0) {\n\t\t\tcerr << \"  Test \" << tests++ << \" (short nuc space, offset \"\n\t\t\t\t << (i*4) << \", 1mm, match bonus=20)...\";\n\t\t\tsc.rdGapConst = 40;\n\t\t\tsc.rfGapConst = 40;\n\t\t\tsc.setMatchBonus(20);\n\t\t\tdoTestCase2(\n\t\t\t\tal,\n\t\t\t\t\"TTGT\",             // read\n\t\t\t\t\"IIII\",             // qual\n\t\t\t\t\"TTGA\",             // ref in\n\t\t\t\ti*4,                // off\n\t\t\t\tsc,                 // scoring scheme\n\t\t\t\t25.0f,               // const coeff for cost ceiling\n\t\t\t\t0.0f,               // linear coeff for cost ceiling\n\t\t\t\tres,                // result\n\t\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\t\tnfilter);           // filter Ns\n\t\t\tassert(!al.done());\n\t\t\tal.nextAlignment(res, rnd);\n\t\t\tassert(!res.empty());\n\t\t\tassert_eq(i*4, res.alres.refoff());\n\t\t\tassert_eq(3, res.alres.refExtent());\n\t\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\t\tassert_eq(res.alres.score().score(), 60);\n\t\t\tassert_eq(res.alres.score().ns(), 0);\n\t\t\tassert(res.alres.ned().empty());\n\t\t\tassert(res.alres.aed().empty());\n\t\t\tres.reset();\n\t\t\tal.nextAlignment(res, rnd);\n\t\t\tassert(res.empty());\n\t\t\tassert(al.done());\n\t\t\tres.reset();\n\t\t\tsc.setMatchBonus(10);\n\t\t\tcerr << \"PASSED\" << endl;\n\t\t}\n\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \"\n\t\t     << (i*4) << \", exact)...\";\n\t\tsc.rdGapConst = 40;\n\t\tsc.rfGapConst = 40;\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTACGT\",         // read\n\t\t\t\"IIIIIIII\",         // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t0.0f,               // const coeff for cost ceiling\n\t\t\t8.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), 80);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tassert(res.alres.ned().empty());\n\t\tassert(res.alres.aed().empty());\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(res.empty());\n\t\tassert(al.done());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t\t\n\t\tcerr << \"  Test \" << tests++ << \" (long nuc space, offset \"\n\t\t     << (i*8) << \", exact)...\";\n\t\tsc.rdGapConst = 40;\n\t\tsc.rfGapConst = 40;\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTACGTACGTACGTACGTA\", // read\n\t\t\t\"IIIIIIIIIIIIIIIIIIIII\",  // qual\n\t\t\t\"ACGTACGTACGTACGTACGTACGTACGTACGTACGTA\", // ref in\n\t\t//   ACGTACGTACGTACGTACGT\n\t\t//           ACGTACGTACGTACGTACGT\n\t\t//                   ACGTACGTACGTACGTACGT\n\t\t\ti*8,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t0.0f,               // const coeff for cost ceiling\n\t\t\t8.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*8, res.alres.refoff());\n\t\tassert_eq(21, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), 210);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tassert(res.alres.ned().empty());\n\t\tassert(res.alres.aed().empty());\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\t//assert(res.empty());\n\t\t//assert(al.done());\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\n\t\tcerr << \"  Test \" << tests++ << \" (nuc space, offset \" << (i*4)\n\t\t     << \", 1mm allowed by minsc)...\";\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTTCGT\",         // read\n\t\t\t\"IIIIIIII\",         // qual\n\t\t\t\"ACGTACGTACGTACGT\", // ref in\n\t\t\ti*4,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t0.0f,               // const coeff for cost ceiling\n\t\t\t5.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*4, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), 40);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\t//assert(res.empty());\n\t\t//assert(al.done());\n\t\tcerr << \"PASSED\" << endl;\n\n\t\tcerr << \"  Test \" << tests++ << \" (long nuc space, offset \"\n\t\t     << (i*8) << \", 6mm allowed by minsc)...\";\n\t\tsc.rdGapConst = 50;\n\t\tsc.rfGapConst = 50;\n\t\tsc.rdGapLinear = 45;\n\t\tsc.rfGapLinear = 45;\n\t\tdoTestCase2(\n\t\t\tal,\n\t\t\t\"ACGTACGATGCATCGTACGTA\", // read\n\t\t\t\"IIIIIIIIIIIIIIIIIIIII\",  // qual\n\t\t\t\"ACGTACGTACGTACGTACGTACGTACGTACGTACGTA\", // ref in\n\t\t//   ACGTACGTACGTACGTACGT\n\t\t//           ACGTACGTACGTACGTACGT\n\t\t//                   ACGTACGTACGTACGTACGT\n\t\t\ti*8,                // off\n\t\t\tsc,                 // scoring scheme\n\t\t\t0.0f,               // const coeff for cost ceiling\n\t\t\t1.0f,               // linear coeff for cost ceiling\n\t\t\tres,                // result\n\t\t\tnIncl,              // Ns inclusive (not mismatches)\n\t\t\tnfilter);           // filter Ns\n\t\tassert(!al.done());\n\t\tal.nextAlignment(res, rnd);\n\t\tassert(!res.empty());\n\t\tassert_eq(i*8 + 13, res.alres.refoff());\n\t\tassert_eq(8, res.alres.refExtent());\n\t\tassert_eq(res.alres.score().gaps(), 0);\n\t\tassert_eq(res.alres.score().score(), 80);\n\t\tassert_eq(res.alres.score().ns(), 0);\n\t\tassert(res.alres.ned().empty());\n\t\tassert(res.alres.aed().empty());\n\t\tres.reset();\n\t\tal.nextAlignment(res, rnd);\n\t\tres.reset();\n\t\tcerr << \"PASSED\" << endl;\n\t}\n}", "idx": 13}
{"project": "bowtie2", "commit_id": "113_bowtie2_2.5.1_aligner_sw.h_printResultStacked.cpp", "target": 0, "func": "void printResultStacked(\n\t\tconst SwResult& res,\n\t\tstd::ostream& os)\n\t{\n\t\tres.alres.printStacked(*rd_, os);\n\t}", "idx": 14}
{"project": "bowtie2", "commit_id": "114_bowtie2_2.5.1_aligner_sw.h_reset.cpp", "target": 0, "func": "inline void reset() { initedRef_ = initedRead_ = false; }", "idx": 15}
{"project": "bowtie2", "commit_id": "115_bowtie2_2.5.1_aligner_sw.h_merge.cpp", "target": 0, "func": "void merge(\n\t\tSSEMetrics& sseU8ExtendMet,\n\t\tSSEMetrics& sseU8MateMet,\n\t\tSSEMetrics& sseI16ExtendMet,\n\t\tSSEMetrics& sseI16MateMet,\n\t\tuint64_t&   nbtfiltst,\n\t\tuint64_t&   nbtfiltsc,\n\t\tuint64_t&   nbtfiltdo)\n\t{\n\t\tsseU8ExtendMet.merge(sseU8ExtendMet_);\n\t\tsseU8MateMet.merge(sseU8MateMet_);\n\t\tsseI16ExtendMet.merge(sseI16ExtendMet_);\n\t\tsseI16MateMet.merge(sseI16MateMet_);\n\t\tnbtfiltst += nbtfiltst_;\n\t\tnbtfiltsc += nbtfiltsc_;\n\t\tnbtfiltdo += nbtfiltdo_;\n\t}", "idx": 16}
{"project": "bowtie2", "commit_id": "116_bowtie2_2.5.1_aligner_sw.h_resetCounters.cpp", "target": 0, "func": "void resetCounters() {\n\t\tsseU8ExtendMet_.reset();\n\t\tsseU8MateMet_.reset();\n\t\tsseI16ExtendMet_.reset();\n\t\tsseI16MateMet_.reset();\n\t\tnbtfiltst_ = nbtfiltsc_ = nbtfiltdo_ = 0;\n\t}", "idx": 17}
{"project": "bowtie2", "commit_id": "117_bowtie2_2.5.1_aligner_swsse.h_clear.cpp", "target": 0, "func": "void clear() { reset(); }", "idx": 18}
{"project": "bowtie2", "commit_id": "118_bowtie2_2.5.1_aligner_swsse.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tdp = dpsat = dpfail = dpsucc = \n\t\tcol = cell = inner = fixup =\n\t\tgathsol = bt = btfail = btsucc = btcell =\n\t\tcorerej = nrej = 0;\n\t}", "idx": 19}
{"project": "bowtie2", "commit_id": "119_bowtie2_2.5.1_aligner_swsse.h_merge.cpp", "target": 0, "func": "void merge(const SSEMetrics& o) {\n\t\tdp       += o.dp;\n\t\tdpsat    += o.dpsat;\n\t\tdpfail   += o.dpfail;\n\t\tdpsucc   += o.dpsucc;\n\t\tcol      += o.col;\n\t\tcell     += o.cell;\n\t\tinner    += o.inner;\n\t\tfixup    += o.fixup;\n\t\tgathsol  += o.gathsol;\n\t\tbt       += o.bt;\n\t\tbtfail   += o.btfail;\n\t\tbtsucc   += o.btsucc;\n\t\tbtcell   += o.btcell;\n\t\tcorerej  += o.corerej;\n\t\tnrej     += o.nrej;\n\t}", "idx": 20}
{"project": "bowtie2", "commit_id": "11_bowtie2_2.5.1_aligner_cache.h_init.cpp", "target": 0, "func": "void init(const SATuple& src, size_t first, size_t last) {\n\t\tassert_neq(OFF_MASK, src.topb);\n\t\tkey = src.key;\n\t\ttopf = (TIndexOffU)(src.topf + first);\n\t\ttopb = OFF_MASK; // unknown!\n\t\toffs.init(src.offs, first, last);\n\t}", "idx": 21}
{"project": "bowtie2", "commit_id": "120_bowtie2_2.5.1_aligner_swsse.h_ptr.cpp", "target": 0, "func": "inline SSERegI *ptr() {\n\t\tassert(inited_);\n\t\treturn matbuf_.ptr();\n\t}", "idx": 22}
{"project": "bowtie2", "commit_id": "121_bowtie2_2.5.1_aligner_swsse.h_resetRow.cpp", "target": 0, "func": "void resetRow(size_t i) {\n\t\tassert(!reset_[i]);\n\t\tmasks_[i].resizeNoCopy(ncol_);\n\t\tmasks_[i].fillZero();\n\t\treset_[i] = true;\n\t}", "idx": 23}
{"project": "bowtie2", "commit_id": "122_bowtie2_2.5.1_aligner_swsse_ee_i16.cpp_assert_all_eq0.cpp", "target": 0, "func": "define assert_all_eq0(x) { \\\n\tSSERegI z = sse_setzero_siall(); \\\n\tSSERegI tmp = sse_setzero_siall(); \\\n\tz = sse_xor_siall(z, z); \\\n\ttmp = sse_cmpeq_epi16(x, z); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 24}
{"project": "bowtie2", "commit_id": "123_bowtie2_2.5.1_aligner_swsse_ee_i16.cpp_assert_all_gt.cpp", "target": 0, "func": "define assert_all_gt(x, y) { \\\n\tSSERegI tmp = sse_cmpgt_epi16(x, y); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 25}
{"project": "bowtie2", "commit_id": "124_bowtie2_2.5.1_aligner_swsse_ee_i16.cpp_assert_all_gt_lo.cpp", "target": 0, "func": "define assert_all_gt_lo(x) { \\\n\tSSERegI z = sse_setzero_siall(); \\\n\tSSERegI tmp = sse_setzero_siall(); \\\n\tz = sse_xor_siall(z, z); \\\n\ttmp = sse_cmpgt_epi16(x, z); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 26}
{"project": "bowtie2", "commit_id": "125_bowtie2_2.5.1_aligner_swsse_ee_i16.cpp_assert_all_lt.cpp", "target": 0, "func": "define assert_all_lt(x, y) { \\\n\tSSERegI tmp = sse_cmplt_epi16(x, y); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 27}
{"project": "bowtie2", "commit_id": "126_bowtie2_2.5.1_aligner_swsse_ee_i16.cpp_assert_all_leq.cpp", "target": 0, "func": "define assert_all_leq(x, y) { \\\n\tSSERegI tmp = sse_cmpgt_epi16(x, y); \\\n\tassert_eq(0x0000, sse_movemask_epi8(tmp)); \\\n}", "idx": 28}
{"project": "bowtie2", "commit_id": "127_bowtie2_2.5.1_aligner_swsse_ee_i16.cpp_assert_all_lt_hi.cpp", "target": 0, "func": "define assert_all_lt_hi(x) { \\\n\tSSERegI z = sse_setzero_siall(); \\\n\tSSERegI tmp = sse_setzero_siall(); \\\n\tz = sse_cmpeq_epi16(z, z); \\\n\tz = sse_srli_epi16(z, 1); \\\n\ttmp = sse_cmplt_epi16(x, z); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 29}
{"project": "bowtie2", "commit_id": "128_bowtie2_2.5.1_aligner_swsse_ee_i16.cpp_MOVE_VEC_PTR_UP.cpp", "target": 0, "func": "define MOVE_VEC_PTR_UP(vec, rowvec, rowelt) { \\\n\tif(rowvec == 0) { \\\n\t\trowvec += d.mat_.nvecrow_; \\\n\t\tvec += d.mat_.colstride_; \\\n\t\trowelt--; \\\n\t} \\\n\trowvec--; \\\n\tvec -= ROWSTRIDE; \\\n}", "idx": 30}
{"project": "bowtie2", "commit_id": "129_bowtie2_2.5.1_aligner_swsse_ee_i16.cpp_MOVE_VEC_PTR_LEFT.cpp", "target": 0, "func": "define MOVE_VEC_PTR_LEFT(vec, rowvec, rowelt) { vec -= d.mat_.colstride_; }", "idx": 31}
{"project": "bowtie2", "commit_id": "12_bowtie2_2.5.1_aligner_cache.h_addRange.cpp", "target": 0, "func": "void addRange(TIndexOffU numElts) {\n\t\trangen_++;\n\t\teltn_ += numElts;\n\t}", "idx": 32}
{"project": "bowtie2", "commit_id": "130_bowtie2_2.5.1_aligner_swsse_ee_i16.cpp_MOVE_VEC_PTR_UPLEFT.cpp", "target": 0, "func": "define MOVE_VEC_PTR_UPLEFT(vec, rowvec, rowelt) { \\\n \tMOVE_VEC_PTR_UP(vec, rowvec, rowelt); \\\n \tMOVE_VEC_PTR_LEFT(vec, rowvec, rowelt); \\\n}", "idx": 33}
{"project": "bowtie2", "commit_id": "131_bowtie2_2.5.1_aligner_swsse_ee_i16.cpp_MOVE_ALL_LEFT.cpp", "target": 0, "func": "define MOVE_ALL_LEFT() { \\\n\tMOVE_VEC_PTR_LEFT(cur_vec, rowvec, rowelt); \\\n\tMOVE_VEC_PTR_LEFT(left_vec, left_rowvec, left_rowelt); \\\n\tMOVE_VEC_PTR_LEFT(up_vec, up_rowvec, up_rowelt); \\\n\tMOVE_VEC_PTR_LEFT(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 34}
{"project": "bowtie2", "commit_id": "132_bowtie2_2.5.1_aligner_swsse_ee_i16.cpp_MOVE_ALL_UP.cpp", "target": 0, "func": "define MOVE_ALL_UP() { \\\n\tMOVE_VEC_PTR_UP(cur_vec, rowvec, rowelt); \\\n\tMOVE_VEC_PTR_UP(left_vec, left_rowvec, left_rowelt); \\\n\tMOVE_VEC_PTR_UP(up_vec, up_rowvec, up_rowelt); \\\n\tMOVE_VEC_PTR_UP(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 35}
{"project": "bowtie2", "commit_id": "133_bowtie2_2.5.1_aligner_swsse_ee_i16.cpp_MOVE_ALL_UPLEFT.cpp", "target": 0, "func": "define MOVE_ALL_UPLEFT() { \\\n\tMOVE_VEC_PTR_UPLEFT(cur_vec, rowvec, rowelt); \\\n\tMOVE_VEC_PTR_UPLEFT(left_vec, left_rowvec, left_rowelt); \\\n\tMOVE_VEC_PTR_UPLEFT(up_vec, up_rowvec, up_rowelt); \\\n\tMOVE_VEC_PTR_UPLEFT(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 36}
{"project": "bowtie2", "commit_id": "134_bowtie2_2.5.1_aligner_swsse_ee_i16.cpp_NEW_ROW_COL.cpp", "target": 0, "func": "define NEW_ROW_COL(row, col) { \\\n\trowelt = row / d.mat_.nvecrow_; \\\n\trowvec = row % d.mat_.nvecrow_; \\\n\teltvec = (col * d.mat_.colstride_) + (rowvec * ROWSTRIDE); \\\n\tcur_vec = d.mat_.matbuf_.ptr() + eltvec; \\\n\tleft_vec = cur_vec; \\\n\tleft_rowelt = rowelt; \\\n\tleft_rowvec = rowvec; \\\n\tMOVE_VEC_PTR_LEFT(left_vec, left_rowvec, left_rowelt); \\\n\tup_vec = cur_vec; \\\n\tup_rowelt = rowelt; \\\n\tup_rowvec = rowvec; \\\n\tMOVE_VEC_PTR_UP(up_vec, up_rowvec, up_rowelt); \\\n\tupleft_vec = up_vec; \\\n\tupleft_rowelt = up_rowelt; \\\n\tupleft_rowvec = up_rowvec; \\\n\tMOVE_VEC_PTR_LEFT(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 37}
{"project": "bowtie2", "commit_id": "135_bowtie2_2.5.1_aligner_swsse_ee_u8.cpp_assert_all_eq0.cpp", "target": 0, "func": "define assert_all_eq0(x) { \\\n\tSSERegI z = sse_setzero_siall(); \\\n\tSSERegI tmp = sse_setzero_siall(); \\\n\tz = sse_xor_siall(z, z); \\\n\ttmp = sse_cmpeq_epi16(x, z); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 38}
{"project": "bowtie2", "commit_id": "136_bowtie2_2.5.1_aligner_swsse_ee_u8.cpp_assert_all_gt.cpp", "target": 0, "func": "define assert_all_gt(x, y) { \\\n\tSSERegI tmp = sse_cmpgt_epu8(x, y); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 39}
{"project": "bowtie2", "commit_id": "137_bowtie2_2.5.1_aligner_swsse_ee_u8.cpp_assert_all_gt_lo.cpp", "target": 0, "func": "define assert_all_gt_lo(x) { \\\n\tSSERegI z = sse_setzero_siall(); \\\n\tSSERegI tmp = sse_setzero_siall(); \\\n\tz = sse_xor_siall(z, z); \\\n\ttmp = sse_cmpgt_epu8(x, z); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 40}
{"project": "bowtie2", "commit_id": "138_bowtie2_2.5.1_aligner_swsse_ee_u8.cpp_assert_all_lt.cpp", "target": 0, "func": "define assert_all_lt(x, y) { \\\n\tSSERegI z = sse_setzero_siall(); \\\n\tz = sse_xor_siall(z, z); \\\n\tSSERegI tmp = sse_subs_epu8(y, x); \\\n\ttmp = sse_cmpeq_epi16(tmp, z); \\\n\tassert_eq(0x0000, sse_movemask_epi8(tmp)); \\\n}", "idx": 41}
{"project": "bowtie2", "commit_id": "139_bowtie2_2.5.1_aligner_swsse_ee_u8.cpp_assert_all_lt_hi.cpp", "target": 0, "func": "define assert_all_lt_hi(x) { \\\n\tSSERegI z = sse_setzero_siall(); \\\n\tSSERegI tmp = sse_setzero_siall(); \\\n\tz = sse_cmpeq_epu8(z, z); \\\n\tz = sse_srli_epu8(z, 1); \\\n\ttmp = sse_cmplt_epu8(x, z); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 42}
{"project": "bowtie2", "commit_id": "13_bowtie2_2.5.1_aligner_cache.h_valid.cpp", "target": 0, "func": "bool valid() { return len != OFF_MASK; }", "idx": 43}
{"project": "bowtie2", "commit_id": "140_bowtie2_2.5.1_aligner_swsse_ee_u8.cpp_MOVE_VEC_PTR_UP.cpp", "target": 0, "func": "define MOVE_VEC_PTR_UP(vec, rowvec, rowelt) { \\\n\tif(rowvec == 0) { \\\n\t\trowvec += d.mat_.nvecrow_; \\\n\t\tvec += d.mat_.colstride_; \\\n\t\trowelt--; \\\n\t} \\\n\trowvec--; \\\n\tvec -= ROWSTRIDE; \\\n}", "idx": 44}
{"project": "bowtie2", "commit_id": "141_bowtie2_2.5.1_aligner_swsse_ee_u8.cpp_MOVE_VEC_PTR_LEFT.cpp", "target": 0, "func": "define MOVE_VEC_PTR_LEFT(vec, rowvec, rowelt) { vec -= d.mat_.colstride_; }", "idx": 45}
{"project": "bowtie2", "commit_id": "142_bowtie2_2.5.1_aligner_swsse_ee_u8.cpp_MOVE_VEC_PTR_UPLEFT.cpp", "target": 0, "func": "define MOVE_VEC_PTR_UPLEFT(vec, rowvec, rowelt) { \\\n \tMOVE_VEC_PTR_UP(vec, rowvec, rowelt); \\\n \tMOVE_VEC_PTR_LEFT(vec, rowvec, rowelt); \\\n}", "idx": 46}
{"project": "bowtie2", "commit_id": "143_bowtie2_2.5.1_aligner_swsse_ee_u8.cpp_MOVE_ALL_LEFT.cpp", "target": 0, "func": "define MOVE_ALL_LEFT() { \\\n\tMOVE_VEC_PTR_LEFT(cur_vec, rowvec, rowelt); \\\n\tMOVE_VEC_PTR_LEFT(left_vec, left_rowvec, left_rowelt); \\\n\tMOVE_VEC_PTR_LEFT(up_vec, up_rowvec, up_rowelt); \\\n\tMOVE_VEC_PTR_LEFT(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 47}
{"project": "bowtie2", "commit_id": "144_bowtie2_2.5.1_aligner_swsse_ee_u8.cpp_MOVE_ALL_UP.cpp", "target": 0, "func": "define MOVE_ALL_UP() { \\\n\tMOVE_VEC_PTR_UP(cur_vec, rowvec, rowelt); \\\n\tMOVE_VEC_PTR_UP(left_vec, left_rowvec, left_rowelt); \\\n\tMOVE_VEC_PTR_UP(up_vec, up_rowvec, up_rowelt); \\\n\tMOVE_VEC_PTR_UP(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 48}
{"project": "bowtie2", "commit_id": "145_bowtie2_2.5.1_aligner_swsse_ee_u8.cpp_MOVE_ALL_UPLEFT.cpp", "target": 0, "func": "define MOVE_ALL_UPLEFT() { \\\n\tMOVE_VEC_PTR_UPLEFT(cur_vec, rowvec, rowelt); \\\n\tMOVE_VEC_PTR_UPLEFT(left_vec, left_rowvec, left_rowelt); \\\n\tMOVE_VEC_PTR_UPLEFT(up_vec, up_rowvec, up_rowelt); \\\n\tMOVE_VEC_PTR_UPLEFT(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 49}
{"project": "bowtie2", "commit_id": "146_bowtie2_2.5.1_aligner_swsse_ee_u8.cpp_NEW_ROW_COL.cpp", "target": 0, "func": "define NEW_ROW_COL(row, col) { \\\n\trowelt = row / d.mat_.nvecrow_; \\\n\trowvec = row % d.mat_.nvecrow_; \\\n\teltvec = (col * d.mat_.colstride_) + (rowvec * ROWSTRIDE); \\\n\tcur_vec = d.mat_.matbuf_.ptr() + eltvec; \\\n\tleft_vec = cur_vec; \\\n\tleft_rowelt = rowelt; \\\n\tleft_rowvec = rowvec; \\\n\tMOVE_VEC_PTR_LEFT(left_vec, left_rowvec, left_rowelt); \\\n\tup_vec = cur_vec; \\\n\tup_rowelt = rowelt; \\\n\tup_rowvec = rowvec; \\\n\tMOVE_VEC_PTR_UP(up_vec, up_rowvec, up_rowelt); \\\n\tupleft_vec = up_vec; \\\n\tupleft_rowelt = up_rowelt; \\\n\tupleft_rowvec = up_rowvec; \\\n\tMOVE_VEC_PTR_LEFT(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 50}
{"project": "bowtie2", "commit_id": "147_bowtie2_2.5.1_aligner_swsse_loc_i16.cpp_assert_all_eq0.cpp", "target": 0, "func": "define assert_all_eq0(x) { \\\n\tSSERegI z = sse_setzero_siall(); \\\n\tSSERegI tmp = sse_setzero_siall(); \\\n\tz = sse_xor_siall(z, z); \\\n\ttmp = sse_cmpeq_epi16(x, z); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 51}
{"project": "bowtie2", "commit_id": "148_bowtie2_2.5.1_aligner_swsse_loc_i16.cpp_assert_all_gt.cpp", "target": 0, "func": "define assert_all_gt(x, y) { \\\n\tSSERegI tmp = sse_cmpgt_epi16(x, y); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 52}
{"project": "bowtie2", "commit_id": "149_bowtie2_2.5.1_aligner_swsse_loc_i16.cpp_assert_all_gt_lo.cpp", "target": 0, "func": "define assert_all_gt_lo(x) { \\\n\tSSERegI z = sse_setzero_siall(); \\\n\tSSERegI tmp = sse_setzero_siall(); \\\n\tz = sse_xor_siall(z, z); \\\n\ttmp = sse_cmpgt_epi16(x, z); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 53}
{"project": "bowtie2", "commit_id": "14_bowtie2_2.5.1_aligner_cache.h_setLength.cpp", "target": 0, "func": "void setLength(size_t nlen) {\n\t\tassert_leq(nlen, offs.size());\n\t\toffs.setLength(nlen);\n\t}", "idx": 54}
{"project": "bowtie2", "commit_id": "150_bowtie2_2.5.1_aligner_swsse_loc_i16.cpp_assert_all_lt.cpp", "target": 0, "func": "define assert_all_lt(x, y) { \\\n\tSSERegI tmp = sse_cmplt_epi16(x, y); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 55}
{"project": "bowtie2", "commit_id": "151_bowtie2_2.5.1_aligner_swsse_loc_i16.cpp_assert_all_leq.cpp", "target": 0, "func": "define assert_all_leq(x, y) { \\\n\tSSERegI tmp = sse_cmpgt_epi16(x, y); \\\n\tassert_eq(0x0000, sse_movemask_epi8(tmp)); \\\n}", "idx": 56}
{"project": "bowtie2", "commit_id": "152_bowtie2_2.5.1_aligner_swsse_loc_i16.cpp_assert_all_lt_hi.cpp", "target": 0, "func": "define assert_all_lt_hi(x) { \\\n\tSSERegI z = sse_setzero_siall(); \\\n\tSSERegI tmp = sse_setzero_siall(); \\\n\tz = sse_cmpeq_epi16(z, z); \\\n\tz = sse_srli_epi16(z, 1); \\\n\ttmp = sse_cmplt_epi16(x, z); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 57}
{"project": "bowtie2", "commit_id": "153_bowtie2_2.5.1_aligner_swsse_loc_i16.cpp_MOVE_VEC_PTR_UP.cpp", "target": 0, "func": "define MOVE_VEC_PTR_UP(vec, rowvec, rowelt) { \\\n\tif(rowvec == 0) { \\\n\t\trowvec += d.mat_.nvecrow_; \\\n\t\tvec += d.mat_.colstride_; \\\n\t\trowelt--; \\\n\t} \\\n\trowvec--; \\\n\tvec -= ROWSTRIDE; \\\n}", "idx": 58}
{"project": "bowtie2", "commit_id": "154_bowtie2_2.5.1_aligner_swsse_loc_i16.cpp_MOVE_VEC_PTR_LEFT.cpp", "target": 0, "func": "define MOVE_VEC_PTR_LEFT(vec, rowvec, rowelt) { vec -= d.mat_.colstride_; }", "idx": 59}
{"project": "bowtie2", "commit_id": "155_bowtie2_2.5.1_aligner_swsse_loc_i16.cpp_MOVE_VEC_PTR_UPLEFT.cpp", "target": 0, "func": "define MOVE_VEC_PTR_UPLEFT(vec, rowvec, rowelt) { \\\n \tMOVE_VEC_PTR_UP(vec, rowvec, rowelt); \\\n \tMOVE_VEC_PTR_LEFT(vec, rowvec, rowelt); \\\n}", "idx": 60}
{"project": "bowtie2", "commit_id": "156_bowtie2_2.5.1_aligner_swsse_loc_i16.cpp_MOVE_ALL_LEFT.cpp", "target": 0, "func": "define MOVE_ALL_LEFT() { \\\n\tMOVE_VEC_PTR_LEFT(cur_vec, rowvec, rowelt); \\\n\tMOVE_VEC_PTR_LEFT(left_vec, left_rowvec, left_rowelt); \\\n\tMOVE_VEC_PTR_LEFT(up_vec, up_rowvec, up_rowelt); \\\n\tMOVE_VEC_PTR_LEFT(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 61}
{"project": "bowtie2", "commit_id": "157_bowtie2_2.5.1_aligner_swsse_loc_i16.cpp_MOVE_ALL_UP.cpp", "target": 0, "func": "define MOVE_ALL_UP() { \\\n\tMOVE_VEC_PTR_UP(cur_vec, rowvec, rowelt); \\\n\tMOVE_VEC_PTR_UP(left_vec, left_rowvec, left_rowelt); \\\n\tMOVE_VEC_PTR_UP(up_vec, up_rowvec, up_rowelt); \\\n\tMOVE_VEC_PTR_UP(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 62}
{"project": "bowtie2", "commit_id": "158_bowtie2_2.5.1_aligner_swsse_loc_i16.cpp_MOVE_ALL_UPLEFT.cpp", "target": 0, "func": "define MOVE_ALL_UPLEFT() { \\\n\tMOVE_VEC_PTR_UPLEFT(cur_vec, rowvec, rowelt); \\\n\tMOVE_VEC_PTR_UPLEFT(left_vec, left_rowvec, left_rowelt); \\\n\tMOVE_VEC_PTR_UPLEFT(up_vec, up_rowvec, up_rowelt); \\\n\tMOVE_VEC_PTR_UPLEFT(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 63}
{"project": "bowtie2", "commit_id": "159_bowtie2_2.5.1_aligner_swsse_loc_i16.cpp_NEW_ROW_COL.cpp", "target": 0, "func": "define NEW_ROW_COL(row, col) { \\\n\trowelt = row / d.mat_.nvecrow_; \\\n\trowvec = row % d.mat_.nvecrow_; \\\n\teltvec = (col * d.mat_.colstride_) + (rowvec * ROWSTRIDE); \\\n\tcur_vec = d.mat_.matbuf_.ptr() + eltvec; \\\n\tleft_vec = cur_vec; \\\n\tleft_rowelt = rowelt; \\\n\tleft_rowvec = rowvec; \\\n\tMOVE_VEC_PTR_LEFT(left_vec, left_rowvec, left_rowelt); \\\n\tup_vec = cur_vec; \\\n\tup_rowelt = rowelt; \\\n\tup_rowvec = rowvec; \\\n\tMOVE_VEC_PTR_UP(up_vec, up_rowvec, up_rowelt); \\\n\tupleft_vec = up_vec; \\\n\tupleft_rowelt = up_rowelt; \\\n\tupleft_rowvec = up_rowvec; \\\n\tMOVE_VEC_PTR_LEFT(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 64}
{"project": "bowtie2", "commit_id": "15_bowtie2_2.5.1_aligner_cache.h_queryQval.cpp", "target": 0, "func": "void queryQval(\n\t\tconst QVal& qv,\n\t\tEList<SATuple, S>& satups,\n\t\tsize_t& nrange,\n\t\tsize_t& nelt,\n\t\tbool getLock = true)\n\t{\n\t\tcurrent_->queryQval(qv, satups, nrange, nelt, getLock);\n\t}", "idx": 65}
{"project": "bowtie2", "commit_id": "160_bowtie2_2.5.1_aligner_swsse_loc_u8.cpp_assert_all_eq0.cpp", "target": 0, "func": "define assert_all_eq0(x) { \\\n\tSSERegI z = sse_setzero_siall(); \\\n\tSSERegI tmp = sse_setzero_siall(); \\\n\tz = sse_xor_siall(z, z); \\\n\ttmp = sse_cmpeq_epi16(x, z); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 66}
{"project": "bowtie2", "commit_id": "161_bowtie2_2.5.1_aligner_swsse_loc_u8.cpp_assert_all_gt.cpp", "target": 0, "func": "define assert_all_gt(x, y) { \\\n\tSSERegI tmp = sse_cmpgt_epu8(x, y); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 67}
{"project": "bowtie2", "commit_id": "162_bowtie2_2.5.1_aligner_swsse_loc_u8.cpp_assert_all_gt_lo.cpp", "target": 0, "func": "define assert_all_gt_lo(x) { \\\n\tSSERegI z = sse_setzero_siall(); \\\n\tSSERegI tmp = sse_setzero_siall(); \\\n\tz = sse_xor_siall(z, z); \\\n\ttmp = sse_cmpgt_epu8(x, z); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 68}
{"project": "bowtie2", "commit_id": "163_bowtie2_2.5.1_aligner_swsse_loc_u8.cpp_assert_all_lt.cpp", "target": 0, "func": "define assert_all_lt(x, y) { \\\n\tSSERegI z = sse_setzero_siall(); \\\n\tz = sse_xor_siall(z, z); \\\n\tSSERegI tmp = sse_subs_epu8(y, x); \\\n\ttmp = sse_cmpeq_epi16(tmp, z); \\\n\tassert_eq(0x0000, sse_movemask_epi8(tmp)); \\\n}", "idx": 69}
{"project": "bowtie2", "commit_id": "164_bowtie2_2.5.1_aligner_swsse_loc_u8.cpp_assert_all_lt_hi.cpp", "target": 0, "func": "define assert_all_lt_hi(x) { \\\n\tSSERegI z = sse_setzero_siall(); \\\n\tSSERegI tmp = sse_setzero_siall(); \\\n\tz = sse_cmpeq_epu8(z, z); \\\n\tz = sse_srli_epu8(z, 1); \\\n\ttmp = sse_cmplt_epu8(x, z); \\\n\tassert_eq(SSE_MASK_ALL, sse_movemask_epi8(tmp)); \\\n}", "idx": 70}
{"project": "bowtie2", "commit_id": "165_bowtie2_2.5.1_aligner_swsse_loc_u8.cpp_MOVE_VEC_PTR_UP.cpp", "target": 0, "func": "define MOVE_VEC_PTR_UP(vec, rowvec, rowelt) { \\\n\tif(rowvec == 0) { \\\n\t\trowvec += d.mat_.nvecrow_; \\\n\t\tvec += d.mat_.colstride_; \\\n\t\trowelt--; \\\n\t} \\\n\trowvec--; \\\n\tvec -= ROWSTRIDE; \\\n}", "idx": 71}
{"project": "bowtie2", "commit_id": "166_bowtie2_2.5.1_aligner_swsse_loc_u8.cpp_MOVE_VEC_PTR_LEFT.cpp", "target": 0, "func": "define MOVE_VEC_PTR_LEFT(vec, rowvec, rowelt) { vec -= d.mat_.colstride_; }", "idx": 72}
{"project": "bowtie2", "commit_id": "167_bowtie2_2.5.1_aligner_swsse_loc_u8.cpp_MOVE_VEC_PTR_UPLEFT.cpp", "target": 0, "func": "define MOVE_VEC_PTR_UPLEFT(vec, rowvec, rowelt) { \\\n \tMOVE_VEC_PTR_UP(vec, rowvec, rowelt); \\\n \tMOVE_VEC_PTR_LEFT(vec, rowvec, rowelt); \\\n}", "idx": 73}
{"project": "bowtie2", "commit_id": "168_bowtie2_2.5.1_aligner_swsse_loc_u8.cpp_MOVE_ALL_LEFT.cpp", "target": 0, "func": "define MOVE_ALL_LEFT() { \\\n\tMOVE_VEC_PTR_LEFT(cur_vec, rowvec, rowelt); \\\n\tMOVE_VEC_PTR_LEFT(left_vec, left_rowvec, left_rowelt); \\\n\tMOVE_VEC_PTR_LEFT(up_vec, up_rowvec, up_rowelt); \\\n\tMOVE_VEC_PTR_LEFT(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 74}
{"project": "bowtie2", "commit_id": "169_bowtie2_2.5.1_aligner_swsse_loc_u8.cpp_MOVE_ALL_UP.cpp", "target": 0, "func": "define MOVE_ALL_UP() { \\\n\tMOVE_VEC_PTR_UP(cur_vec, rowvec, rowelt); \\\n\tMOVE_VEC_PTR_UP(left_vec, left_rowvec, left_rowelt); \\\n\tMOVE_VEC_PTR_UP(up_vec, up_rowvec, up_rowelt); \\\n\tMOVE_VEC_PTR_UP(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 75}
{"project": "bowtie2", "commit_id": "16_bowtie2_2.5.1_aligner_cache.h_clear.cpp", "target": 0, "func": "void clear() {\n\t\tif(current_ != NULL) current_->clear();\n\t\tif(local_   != NULL) local_->clear();\n\t\tif(shared_  != NULL) shared_->clear();\n\t}", "idx": 76}
{"project": "bowtie2", "commit_id": "170_bowtie2_2.5.1_aligner_swsse_loc_u8.cpp_MOVE_ALL_UPLEFT.cpp", "target": 0, "func": "define MOVE_ALL_UPLEFT() { \\\n\tMOVE_VEC_PTR_UPLEFT(cur_vec, rowvec, rowelt); \\\n\tMOVE_VEC_PTR_UPLEFT(left_vec, left_rowvec, left_rowelt); \\\n\tMOVE_VEC_PTR_UPLEFT(up_vec, up_rowvec, up_rowelt); \\\n\tMOVE_VEC_PTR_UPLEFT(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 77}
{"project": "bowtie2", "commit_id": "171_bowtie2_2.5.1_aligner_swsse_loc_u8.cpp_NEW_ROW_COL.cpp", "target": 0, "func": "define NEW_ROW_COL(row, col) { \\\n\trowelt = row / d.mat_.nvecrow_; \\\n\trowvec = row % d.mat_.nvecrow_; \\\n\teltvec = (col * d.mat_.colstride_) + (rowvec * ROWSTRIDE); \\\n\tcur_vec = d.mat_.matbuf_.ptr() + eltvec; \\\n\tleft_vec = cur_vec; \\\n\tleft_rowelt = rowelt; \\\n\tleft_rowvec = rowvec; \\\n\tMOVE_VEC_PTR_LEFT(left_vec, left_rowvec, left_rowelt); \\\n\tup_vec = cur_vec; \\\n\tup_rowelt = rowelt; \\\n\tup_rowvec = rowvec; \\\n\tMOVE_VEC_PTR_UP(up_vec, up_rowvec, up_rowelt); \\\n\tupleft_vec = up_vec; \\\n\tupleft_rowelt = up_rowelt; \\\n\tupleft_rowvec = up_rowvec; \\\n\tMOVE_VEC_PTR_LEFT(upleft_vec, upleft_rowvec, upleft_rowelt); \\\n}", "idx": 78}
{"project": "bowtie2", "commit_id": "172_bowtie2_2.5.1_aligner_sw_common.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tsws = swcups = swrows = swskiprows = swskip = swsucc = swfail = swbts =\n\t\tsws10 = sws5 = sws3 =\n\t\trshit = ungapsucc = ungapfail = ungapnodec = 0;\n\t\texatts = exranges = exrows = exsucc = exooms = 0;\n\t\tmm1atts = mm1ranges = mm1rows = mm1succ = mm1ooms = 0;\n\t\tsdatts = sdranges = sdrows = sdsucc = sdooms = 0;\n\t}", "idx": 79}
{"project": "bowtie2", "commit_id": "173_bowtie2_2.5.1_aligner_sw_common.h_reverse.cpp", "target": 0, "func": "void reverse() {\n\t\talres.reverseEdits();\n\t}", "idx": 80}
{"project": "bowtie2", "commit_id": "174_bowtie2_2.5.1_aligner_sw_common.h_init.cpp", "target": 0, "func": "void init(\n\t\tuint64_t sws_,\n\t\tuint64_t sws10_,\n\t\tuint64_t sws5_,\n\t\tuint64_t sws3_,\n\t\tuint64_t swcups_,\n\t\tuint64_t swrows_,\n\t\tuint64_t swskiprows_,\n\t\tuint64_t swskip_,\n\t\tuint64_t swsucc_,\n\t\tuint64_t swfail_,\n\t\tuint64_t swbts_,\n\t\tuint64_t rshit_,\n\t\tuint64_t ungapsucc_,\n\t\tuint64_t ungapfail_,\n\t\tuint64_t ungapnodec_,\n\t\tuint64_t exatts_,\n\t\tuint64_t exranges_,\n\t\tuint64_t exrows_,\n\t\tuint64_t exsucc_,\n\t\tuint64_t exooms_,\n\t\tuint64_t mm1atts_,\n\t\tuint64_t mm1ranges_,\n\t\tuint64_t mm1rows_,\n\t\tuint64_t mm1succ_,\n\t\tuint64_t mm1ooms_,\n\t\tuint64_t sdatts_,\n\t\tuint64_t sdranges_,\n\t\tuint64_t sdrows_,\n\t\tuint64_t sdsucc_,\n\t\tuint64_t sdooms_)\n\t{\n\t\tsws        = sws_;\n\t\tsws10      = sws10_;\n\t\tsws5       = sws5_;\n\t\tsws3       = sws3_;\n\t\tswcups     = swcups_;\n\t\tswrows     = swrows_;\n\t\tswskiprows = swskiprows_;\n\t\tswskip     = swskip_;\n\t\tswsucc     = swsucc_;\n\t\tswfail     = swfail_;\n\t\tswbts      = swbts_;\n\t\tungapsucc  = ungapsucc_;\n\t\tungapfail  = ungapfail_;\n\t\tungapnodec = ungapnodec_;\n\t\t\n\t\t// Exact end-to-end attempts\n\t\texatts     = exatts_;\n\t\texranges   = exranges_;\n\t\texrows     = exrows_;\n\t\texsucc     = exsucc_;\n\t\texooms     = exooms_;\n\n\t\t// 1-mismatch end-to-end attempts\n\t\tmm1atts    = mm1atts_;\n\t\tmm1ranges  = mm1ranges_;\n\t\tmm1rows    = mm1rows_;\n\t\tmm1succ    = mm1succ_;\n\t\tmm1ooms    = mm1ooms_;\n\t\t\n\t\t// Seed attempts\n\t\tsdatts     = sdatts_;\n\t\tsdranges   = sdranges_;\n\t\tsdrows     = sdrows_;\n\t\tsdsucc     = sdsucc_;\n\t\tsdooms     = sdooms_;\n\t}", "idx": 81}
{"project": "bowtie2", "commit_id": "175_bowtie2_2.5.1_aligner_sw_common.h_update.cpp", "target": 0, "func": "void update(const SwResult& r) {\n\t\tsws        += r.sws;\n\t\tswcups     += r.swcups;\n\t\tswrows     += r.swrows;\n\t\tswskiprows += r.swskiprows;\n\t\tswskip     += r.swskip;\n\t\tswsucc     += r.swsucc;\n\t\tswfail     += r.swfail;\n\t\tswbts      += r.swbts;\n\t}", "idx": 82}
{"project": "bowtie2", "commit_id": "176_bowtie2_2.5.1_aligner_sw_common.h_merge.cpp", "target": 0, "func": "void merge(const SwMetrics& r) {\n                ThreadSafe ts(mutex_m);\n\t\tsws        += r.sws;\n\t\tsws10      += r.sws10;\n\t\tsws5       += r.sws5;\n\t\tsws3       += r.sws3;\n\t\tswcups     += r.swcups;\n\t\tswrows     += r.swrows;\n\t\tswskiprows += r.swskiprows;\n\t\tswskip     += r.swskip;\n\t\tswsucc     += r.swsucc;\n\t\tswfail     += r.swfail;\n\t\tswbts      += r.swbts;\n\t\trshit      += r.rshit;\n\t\tungapsucc  += r.ungapsucc;\n\t\tungapfail  += r.ungapfail;\n\t\tungapnodec += r.ungapnodec;\n\t\texatts     += r.exatts;\n\t\texranges   += r.exranges;\n\t\texrows     += r.exrows;\n\t\texsucc     += r.exsucc;\n\t\texooms     += r.exooms;\n\t\tmm1atts    += r.mm1atts;\n\t\tmm1ranges  += r.mm1ranges;\n\t\tmm1rows    += r.mm1rows;\n\t\tmm1succ    += r.mm1succ;\n\t\tmm1ooms    += r.mm1ooms;\n\t\tsdatts     += r.sdatts;\n\t\tsdranges   += r.sdranges;\n\t\tsdrows     += r.sdrows;\n\t\tsdsucc     += r.sdsucc;\n\t\tsdooms     += r.sdooms;\n\t}", "idx": 83}
{"project": "bowtie2", "commit_id": "177_bowtie2_2.5.1_aligner_sw_common.h_tallyGappedDp.cpp", "target": 0, "func": "void tallyGappedDp(size_t readGaps, size_t refGaps) {\n\t\tsize_t mx = max(readGaps, refGaps);\n\t\tif(mx < 10) sws10++;\n\t\tif(mx < 5)  sws5++;\n\t\tif(mx < 3)  sws3++;\n\t}", "idx": 84}
{"project": "bowtie2", "commit_id": "178_bowtie2_2.5.1_aligner_sw_driver.h_init.cpp", "target": 0, "func": "void init(size_t off_, size_t len_, size_t sz_) {\n\t\toff = off_; len = len_; sz = sz_;\n\t}", "idx": 85}
{"project": "bowtie2", "commit_id": "179_bowtie2_2.5.1_aligner_sw_driver.h_finishedRange.cpp", "target": 0, "func": "void finishedRange(size_t i) {\n\t\tassert_lt(i, masses_.size());\n\t\telim_[i] = true;\n\t\tmass_ -= masses_[i];\n\t}", "idx": 86}
{"project": "bowtie2", "commit_id": "17_bowtie2_2.5.1_aligner_cache.h_beginAlign.cpp", "target": 0, "func": "int beginAlign(\n\t\tconst BTDnaString& seq,\n\t\tconst BTString& qual,\n\t\tQVal& qv,              // out: filled in if we find it in the cache\n\t\tbool getLock = true)\n\t{\n\t\tassert(repOk());\n\t\tqk_.init(seq ASSERT_ONLY(, tmpdnastr_));\n\t\tif(qk_.cacheable()) {\n\t\t\t// Make a QNode for this key and possibly add the QNode to the\n\t\t\t// Red-Black map; but if 'seq' isn't cacheable, just create the\n\t\t\t// QNode (without adding it to the map).\n\t\t\tqv_ = current_->add(qk_, &cacheable_, getLock);\n\t\t} else {\n\t\t\tqv_ = &qvbuf_;\n\t\t}\n\t\tif(qv_ == NULL) {\n\t\t\tresetRead();\n \t\t\treturn -1; // Not in memory\n\t\t}\n\t\tqv_->reset();\n\t\treturn 0; // Need to search for it\n\t}", "idx": 87}
{"project": "bowtie2", "commit_id": "180_bowtie2_2.5.1_aligner_sw_driver.h_nextRead.cpp", "target": 0, "func": "void nextRead(bool paired, size_t mate1len, size_t mate2len) {\n\t\tredAnchor_.reset();\n\t\tseenDiags1_.reset();\n\t\tseenDiags2_.reset();\n\t\tseedExRangeFw_[0].clear(); // mate 1 fw\n\t\tseedExRangeFw_[1].clear(); // mate 2 fw\n\t\tseedExRangeRc_[0].clear(); // mate 1 rc\n\t\tseedExRangeRc_[1].clear(); // mate 2 rc\n\t\tsize_t maxlen = mate1len;\n\t\tif(paired) {\n\t\t\tredMate1_.reset();\n\t\t\tredMate1_.init(mate1len);\n\t\t\tredMate2_.reset();\n\t\t\tredMate2_.init(mate2len);\n\t\t\tif(mate2len > maxlen) {\n\t\t\t\tmaxlen = mate2len;\n\t\t\t}\n\t\t}\n\t\tredAnchor_.init(maxlen);\n\t}", "idx": 88}
{"project": "bowtie2", "commit_id": "181_bowtie2_2.5.1_aligner_sw_nuc.h_init.cpp", "target": 0, "func": "void init(size_t nelt, size_t nbest) {\n\t\tnelt_ = nelt;\n\t\tnbest_ = nbest;\n\t\telts_.resize(nelt * nbest);\n\t\tncur_.resize(nelt);\n\t\tncur_.fill(0);\n\t\tn_ = 0;\n\t}", "idx": 89}
{"project": "bowtie2", "commit_id": "182_bowtie2_2.5.1_aligner_sw_nuc.h_reset.cpp", "target": 0, "func": "void reset() { init(0, 0, 0); }", "idx": 90}
{"project": "bowtie2", "commit_id": "183_bowtie2_2.5.1_aligner_sw_nuc.h_dominatedBy.cpp", "target": 0, "func": "inline bool dominatedBy(const DpBtCandidate& o) {\n\t\tconst size_t SQ = 40;\n\t\tsize_t rowhi = row;\n\t\tsize_t rowlo = o.row;\n\t\tif(rowhi < rowlo) swap(rowhi, rowlo);\n\t\tsize_t colhi = col;\n\t\tsize_t collo = o.col;\n\t\tif(colhi < collo) swap(colhi, collo);\n\t\treturn (colhi - collo) <= SQ &&\n\t\t       (rowhi - rowlo) <= SQ;\n\t}", "idx": 91}
{"project": "bowtie2", "commit_id": "184_bowtie2_2.5.1_aln_sink.cpp_WRITE_NUM.cpp", "target": 0, "func": "define WRITE_NUM(o, x) { \\\n\titoa10(x, buf); \\\n\to.append(buf); \\\n}", "idx": 92}
{"project": "bowtie2", "commit_id": "185_bowtie2_2.5.1_aln_sink.cpp_printUptoWs.cpp", "target": 0, "func": "static inline void printUptoWs(\n\tBTString& s,\n\tconst T& str,\n\tbool chopws)\n{\n\tsize_t len = str.length();\n\tfor(size_t i = 0; i < len; i++) {\n\t\tif(!chopws || (str[i] != ' ' && str[i] != '\\t')) {\n\t\t\ts.append(str[i]);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}", "idx": 93}
{"project": "bowtie2", "commit_id": "186_bowtie2_2.5.1_aln_sink.cpp_testDones.cpp", "target": 0, "func": "bool testDones(\n\tconst ReportingState& st,\n\tbool done1,\n\tbool done2,\n\tbool done3,\n\tbool done4,\n\tbool done5,\n\tbool done6)\n{\n\tassert(st.doneConcordant()    == done1);\n\tassert(st.doneDiscordant()    == done2);\n\tassert(st.doneUnpaired(true)  == done3);\n\tassert(st.doneUnpaired(false) == done4);\n\tassert(st.doneUnpaired()      == done5);\n\tassert(st.done()              == done6);\n\tassert(st.repOk());\n\treturn true;\n}", "idx": 94}
{"project": "bowtie2", "commit_id": "187_bowtie2_2.5.1_aln_sink.cpp_main.cpp", "target": 0, "func": "int main(void) {\n\tcerr << \"Case 1 (simple unpaired 1) ... \";\n\t{\n\t\tuint64_t nconcord = 0, ndiscord = 0, nunpair1 = 0, nunpair2 = 0;\n\t\tbool pairMax = false, unpair1Max = false, unpair2Max = false;\n\t\tReportingParams rp(\n\t\t\t2,      // khits\n\t\t\t0,      // mhits\n\t\t\t0,      // pengap\n\t\t\tfalse,  // msample\n\t\t\tfalse,  // discord\n\t\t\tfalse); // mixed\n\t\tReportingState st(rp);\n\t\tst.nextRead(false); // unpaired read\n\t\tassert(testDones(st, true, true, false, true, false, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, true, true, false, true, false, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, true, true, true, true, true, true));\n\t\tst.finish();\n\t\tassert(testDones(st, true, true, true, true, true, true));\n\t\tassert_eq(0, st.numConcordant());\n\t\tassert_eq(0, st.numDiscordant());\n\t\tassert_eq(2, st.numUnpaired1());\n\t\tassert_eq(0, st.numUnpaired2());\n\t\tassert(st.repOk());\n\t\tst.getReport(nconcord, ndiscord, nunpair1, nunpair2,\n\t\t             pairMax, unpair1Max, unpair2Max);\n\t\tassert_eq(0, nconcord);\n\t\tassert_eq(0, ndiscord);\n\t\tassert_eq(2, nunpair1);\n\t\tassert_eq(0, nunpair2);\n\t\tassert(!pairMax);\n\t\tassert(!unpair1Max);\n\t\tassert(!unpair2Max);\n\t}\n\tcerr << \"PASSED\" << endl;\n\n\tcerr << \"Case 2 (simple unpaired 1) ... \";\n\t{\n\t\tuint64_t nconcord = 0, ndiscord = 0, nunpair1 = 0, nunpair2 = 0;\n\t\tbool pairMax = false, unpair1Max = false, unpair2Max = false;\n\t\tReportingParams rp(\n\t\t\t2,      // khits\n\t\t\t3,      // mhits\n\t\t\t0,      // pengap\n\t\t\tfalse,  // msample\n\t\t\tfalse,  // discord\n\t\t\tfalse); // mixed\n\t\tReportingState st(rp);\n\t\tst.nextRead(false); // unpaired read\n\t\tassert(testDones(st, true, true, false, true, false, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, true, true, false, true, false, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, true, true, false, true, false, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, true, true, false, true, false, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, true, true, true, true, true, true));\n\t\tassert_eq(0, st.numConcordant());\n\t\tassert_eq(0, st.numDiscordant());\n\t\tassert_eq(4, st.numUnpaired1());\n\t\tassert_eq(0, st.numUnpaired2());\n\t\tst.finish();\n\t\tassert(testDones(st, true, true, true, true, true, true));\n\t\tassert_eq(0, st.numConcordant());\n\t\tassert_eq(0, st.numDiscordant());\n\t\tassert_eq(4, st.numUnpaired1());\n\t\tassert_eq(0, st.numUnpaired2());\n\t\tassert(st.repOk());\n\t\tst.getReport(nconcord, ndiscord, nunpair1, nunpair2,\n\t\t             pairMax, unpair1Max, unpair2Max);\n\t\tassert_eq(0, nconcord);\n\t\tassert_eq(0, ndiscord);\n\t\tassert_eq(0, nunpair1);\n\t\tassert_eq(0, nunpair2);\n\t\tassert(!pairMax);\n\t\tassert(unpair1Max);\n\t\tassert(!unpair2Max);\n\t}\n\tcerr << \"PASSED\" << endl;\n\n\tcerr << \"Case 3 (simple paired 1) ... \";\n\t{\n\t\tuint64_t nconcord = 0, ndiscord = 0, nunpair1 = 0, nunpair2 = 0;\n\t\tbool pairMax = false, unpair1Max = false, unpair2Max = false;\n\t\tReportingParams rp(\n\t\t\t2,      // khits\n\t\t\t3,      // mhits\n\t\t\t0,      // pengap\n\t\t\tfalse,  // msample\n\t\t\tfalse,  // discord\n\t\t\tfalse); // mixed\n\t\tReportingState st(rp);\n\t\tst.nextRead(true); // unpaired read\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundUnpaired(false);\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundUnpaired(false);\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundUnpaired(false);\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundUnpaired(false);\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundConcordant();\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundConcordant();\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundConcordant();\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundConcordant();\n\t\tassert(testDones(st, true, true, true, true, true, true));\n\t\tassert_eq(4, st.numConcordant());\n\t\tassert_eq(0, st.numDiscordant());\n\t\tassert_eq(4, st.numUnpaired1());\n\t\tassert_eq(4, st.numUnpaired2());\n\t\tst.finish();\n\t\tassert(testDones(st, true, true, true, true, true, true));\n\t\tassert_eq(4, st.numConcordant());\n\t\tassert_eq(0, st.numDiscordant());\n\t\tassert_eq(4, st.numUnpaired1());\n\t\tassert_eq(4, st.numUnpaired2());\n\t\tassert(st.repOk());\n\t\tst.getReport(nconcord, ndiscord, nunpair1, nunpair2,\n\t\t             pairMax, unpair1Max, unpair2Max);\n\t\tassert_eq(0, nconcord);\n\t\tassert_eq(0, ndiscord);\n\t\tassert_eq(0, nunpair1);\n\t\tassert_eq(0, nunpair2);\n\t\tassert(pairMax);\n\t\tassert(!unpair1Max); // because !mixed\n\t\tassert(!unpair2Max); // because !mixed\n\t}\n\tcerr << \"PASSED\" << endl;\n\n\tcerr << \"Case 4 (simple paired 2) ... \";\n\t{\n\t\tuint64_t nconcord = 0, ndiscord = 0, nunpair1 = 0, nunpair2 = 0;\n\t\tbool pairMax = false, unpair1Max = false, unpair2Max = false;\n\t\tReportingParams rp(\n\t\t\t2,      // khits\n\t\t\t3,      // mhits\n\t\t\t0,      // pengap\n\t\t\tfalse,  // msample\n\t\t\ttrue,   // discord\n\t\t\ttrue);  // mixed\n\t\tReportingState st(rp);\n\t\tst.nextRead(true); // unpaired read\n\t\tassert(testDones(st, false, false, false, false, false, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, false, false, false, false, false, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, false, true, false, false, false, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, false, true, false, false, false, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, false, true, true, false, false, false));\n\t\tst.foundUnpaired(false);\n\t\tassert(testDones(st, false, true, true, false, false, false));\n\t\tst.foundUnpaired(false);\n\t\tassert(testDones(st, false, true, true, false, false, false));\n\t\tst.foundUnpaired(false);\n\t\tassert(testDones(st, false, true, true, false, false, false));\n\t\tst.foundUnpaired(false);\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundConcordant();\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundConcordant();\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundConcordant();\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tst.foundConcordant();\n\t\tassert(testDones(st, true, true, true, true, true, true));\n\t\tassert_eq(4, st.numConcordant());\n\t\tassert_eq(0, st.numDiscordant());\n\t\tassert_eq(4, st.numUnpaired1());\n\t\tassert_eq(4, st.numUnpaired2());\n\t\tst.finish();\n\t\tassert(testDones(st, true, true, true, true, true, true));\n\t\tassert_eq(4, st.numConcordant());\n\t\tassert_eq(0, st.numDiscordant());\n\t\tassert_eq(4, st.numUnpaired1());\n\t\tassert_eq(4, st.numUnpaired2());\n\t\tassert(st.repOk());\n\t\tst.getReport(nconcord, ndiscord, nunpair1, nunpair2,\n\t\t             pairMax, unpair1Max, unpair2Max);\n\t\tassert_eq(0, nconcord);\n\t\tassert_eq(0, ndiscord);\n\t\tassert_eq(0, nunpair1);\n\t\tassert_eq(0, nunpair2);\n\t\tassert(pairMax);\n\t\tassert(unpair1Max);\n\t\tassert(unpair2Max);\n\t}\n\tcerr << \"PASSED\" << endl;\n\n\tcerr << \"Case 5 (potential discordant after concordant) ... \";\n\t{\n\t\tuint64_t nconcord = 0, ndiscord = 0, nunpair1 = 0, nunpair2 = 0;\n\t\tbool pairMax = false, unpair1Max = false, unpair2Max = false;\n\t\tReportingParams rp(\n\t\t\t2,      // khits\n\t\t\t3,      // mhits\n\t\t\t0,      // pengap\n\t\t\tfalse,  // msample\n\t\t\ttrue,   // discord\n\t\t\ttrue);  // mixed\n\t\tReportingState st(rp);\n\t\tst.nextRead(true);\n\t\tassert(testDones(st, false, false, false, false, false, false));\n\t\tst.foundUnpaired(true);\n\t\tst.foundUnpaired(false);\n\t\tst.foundConcordant();\n\t\tassert(testDones(st, false, true, false, false, false, false));\n\t\tst.finish();\n\t\tassert(testDones(st, true, true, true, true, true, true));\n\t\tassert_eq(1, st.numConcordant());\n\t\tassert_eq(0, st.numDiscordant());\n\t\tassert_eq(1, st.numUnpaired1());\n\t\tassert_eq(1, st.numUnpaired2());\n\t\tassert(st.repOk());\n\t\tst.getReport(nconcord, ndiscord, nunpair1, nunpair2,\n\t\t             pairMax, unpair1Max, unpair2Max);\n\t\tassert_eq(1, nconcord);\n\t\tassert_eq(0, ndiscord);\n\t\tassert_eq(0, nunpair1);\n\t\tassert_eq(0, nunpair2);\n\t\tassert(!pairMax);\n\t\tassert(!unpair1Max);\n\t\tassert(!unpair2Max);\n\t}\n\tcerr << \"PASSED\" << endl;\n\n\tcerr << \"Case 6 (true discordant) ... \";\n\t{\n\t\tuint64_t nconcord = 0, ndiscord = 0, nunpair1 = 0, nunpair2 = 0;\n\t\tbool pairMax = false, unpair1Max = false, unpair2Max = false;\n\t\tReportingParams rp(\n\t\t\t2,      // khits\n\t\t\t3,      // mhits\n\t\t\t0,      // pengap\n\t\t\tfalse,  // msample\n\t\t\ttrue,   // discord\n\t\t\ttrue);  // mixed\n\t\tReportingState st(rp);\n\t\tst.nextRead(true);\n\t\tassert(testDones(st, false, false, false, false, false, false));\n\t\tst.foundUnpaired(true);\n\t\tst.foundUnpaired(false);\n\t\tassert(testDones(st, false, false, false, false, false, false));\n\t\tst.finish();\n\t\tassert(testDones(st, true, true, true, true, true, true));\n\t\tassert_eq(0, st.numConcordant());\n\t\tassert_eq(1, st.numDiscordant());\n\t\tassert_eq(0, st.numUnpaired1());\n\t\tassert_eq(0, st.numUnpaired2());\n\t\tassert(st.repOk());\n\t\tst.getReport(nconcord, ndiscord, nunpair1, nunpair2,\n\t\t             pairMax, unpair1Max, unpair2Max);\n\t\tassert_eq(0, nconcord);\n\t\tassert_eq(1, ndiscord);\n\t\tassert_eq(0, nunpair1);\n\t\tassert_eq(0, nunpair2);\n\t\tassert(!pairMax);\n\t\tassert(!unpair1Max);\n\t\tassert(!unpair2Max);\n\t}\n\tcerr << \"PASSED\" << endl;\n\n\tcerr << \"Case 7 (unaligned pair & uniquely aligned mate, mixed-mode) ... \";\n\t{\n\t\tuint64_t nconcord = 0, ndiscord = 0, nunpair1 = 0, nunpair2 = 0;\n\t\tbool pairMax = false, unpair1Max = false, unpair2Max = false;\n\t\tReportingParams rp(\n\t\t\t1,      // khits\n\t\t\t1,      // mhits\n\t\t\t0,      // pengap\n\t\t\tfalse,  // msample\n\t\t\ttrue,   // discord\n\t\t\ttrue);  // mixed\n\t\tReportingState st(rp);\n\t\tst.nextRead(true); // unpaired read\n\t\t// assert(st.doneConcordant()    == done1);\n\t\t// assert(st.doneDiscordant()    == done2);\n\t\t// assert(st.doneUnpaired(true)  == done3);\n\t\t// assert(st.doneUnpaired(false) == done4);\n\t\t// assert(st.doneUnpaired()      == done5);\n\t\t// assert(st.done()              == done6);\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, false, false, false, false, false, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, false, true, true, false, false, false));\n\t\tassert_eq(0, st.numConcordant());\n\t\tassert_eq(0, st.numDiscordant());\n\t\tassert_eq(2, st.numUnpaired1());\n\t\tassert_eq(0, st.numUnpaired2());\n\t\tst.finish();\n\t\tst.getReport(nconcord, ndiscord, nunpair1, nunpair2,\n\t\t             pairMax, unpair1Max, unpair2Max);\n\t\tassert_eq(0, nconcord);\n\t\tassert_eq(0, ndiscord);\n\t\tassert_eq(0, nunpair1);\n\t\tassert_eq(0, nunpair2);\n\t\tassert(!pairMax);\n\t\tassert(unpair1Max);\n\t\tassert(!unpair2Max);\n\t}\n\tcerr << \"PASSED\" << endl;\n\n\tcerr << \"Case 8 (unaligned pair & uniquely aligned mate, NOT mixed-mode) ... \";\n\t{\n\t\tuint64_t nconcord = 0, ndiscord = 0, nunpair1 = 0, nunpair2 = 0;\n\t\tbool pairMax = false, unpair1Max = false, unpair2Max = false;\n\t\tReportingParams rp(\n\t\t\t1,      // khits\n\t\t\t1,      // mhits\n\t\t\t0,      // pengap\n\t\t\tfalse,  // msample\n\t\t\ttrue,   // discord\n\t\t\tfalse); // mixed\n\t\tReportingState st(rp);\n\t\tst.nextRead(true); // unpaired read\n\t\t// assert(st.doneConcordant()    == done1);\n\t\t// assert(st.doneDiscordant()    == done2);\n\t\t// assert(st.doneUnpaired(true)  == done3);\n\t\t// assert(st.doneUnpaired(false) == done4);\n\t\t// assert(st.doneUnpaired()      == done5);\n\t\t// assert(st.done()              == done6);\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, false, false, true, true, true, false));\n\t\tst.foundUnpaired(true);\n\t\tassert(testDones(st, false, true, true, true, true, false));\n\t\tassert_eq(0, st.numConcordant());\n\t\tassert_eq(0, st.numDiscordant());\n\t\tassert_eq(2, st.numUnpaired1());\n\t\tassert_eq(0, st.numUnpaired2());\n\t\tst.finish();\n\t\tst.getReport(nconcord, ndiscord, nunpair1, nunpair2,\n\t\t             pairMax, unpair1Max, unpair2Max);\n\t\tassert_eq(0, nconcord);\n\t\tassert_eq(0, ndiscord);\n\t\tassert_eq(0, nunpair1);\n\t\tassert_eq(0, nunpair2);\n\t\tassert(!pairMax);\n\t\tassert(!unpair1Max); // not really relevant\n\t\tassert(!unpair2Max); // not really relevant\n\t}\n\tcerr << \"PASSED\" << endl;\n\n\tcerr << \"Case 9 (repetitive pair, only one mate repetitive) ... \";\n\t{\n\t\tuint64_t nconcord = 0, ndiscord = 0, nunpair1 = 0, nunpair2 = 0;\n\t\tbool pairMax = false, unpair1Max = false, unpair2Max = false;\n\t\tReportingParams rp(\n\t\t\t1,      // khits\n\t\t\t1,      // mhits\n\t\t\t0,      // pengap\n\t\t\ttrue,   // msample\n\t\t\ttrue,   // discord\n\t\t\ttrue);  // mixed\n\t\tReportingState st(rp);\n\t\tst.nextRead(true); // unpaired read\n\t\t// assert(st.doneConcordant()    == done1);\n\t\t// assert(st.doneDiscordant()    == done2);\n\t\t// assert(st.doneUnpaired(true)  == done3);\n\t\t// assert(st.doneUnpaired(false) == done4);\n\t\t// assert(st.doneUnpaired()      == done5);\n\t\t// assert(st.done()              == done6);\n\t\tst.foundConcordant();\n\t\tassert(st.repOk());\n\t\tst.foundUnpaired(true);\n\t\tassert(st.repOk());\n\t\tst.foundUnpaired(false);\n\t\tassert(st.repOk());\n\t\tassert(testDones(st, false, true, false, false, false, false));\n\t\tassert(st.repOk());\n\t\tst.foundConcordant();\n\t\tassert(st.repOk());\n\t\tst.foundUnpaired(true);\n\t\tassert(st.repOk());\n\t\tassert(testDones(st, true, true, true, false, false, false));\n\t\tassert_eq(2, st.numConcordant());\n\t\tassert_eq(0, st.numDiscordant());\n\t\tassert_eq(2, st.numUnpaired1());\n\t\tassert_eq(1, st.numUnpaired2());\n\t\tst.foundUnpaired(false);\n\t\tassert(st.repOk());\n\t\tassert(testDones(st, true, true, true, true, true, true));\t\t\n\t\tassert_eq(2, st.numConcordant());\n\t\tassert_eq(0, st.numDiscordant());\n\t\tassert_eq(2, st.numUnpaired1());\n\t\tassert_eq(2, st.numUnpaired2());\n\t\tst.finish();\n\t\tst.getReport(nconcord, ndiscord, nunpair1, nunpair2,\n\t\t             pairMax, unpair1Max, unpair2Max);\n\t\tassert_eq(1, nconcord);\n\t\tassert_eq(0, ndiscord);\n\t\tassert_eq(0, nunpair1);\n\t\tassert_eq(0, nunpair2);\n\t\tassert(pairMax);\n\t\tassert(unpair1Max); // not really relevant\n\t\tassert(unpair2Max); // not really relevant\n\t}\n\tcerr << \"PASSED\" << endl;\n}", "idx": 95}
{"project": "bowtie2", "commit_id": "188_bowtie2_2.5.1_aln_sink.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tstate_ = ReportingState::NO_READ;\n\t\tpaired_ = false;\n\t\tnconcord_ = 0;\n\t\tndiscord_ = 0;\n\t\tnunpair1_ = 0;\n\t\tnunpair2_ = 0;\n\t\tdoneConcord_ = false;\n\t\tdoneDiscord_ = false;\n\t\tdoneUnpair_  = false;\n\t\tdoneUnpair1_ = false;\n\t\tdoneUnpair2_ = false;\n\t\texitConcord_ = ReportingState::EXIT_DID_NOT_ENTER;\n\t\texitDiscord_ = ReportingState::EXIT_DID_NOT_ENTER;\n\t\texitUnpair1_ = ReportingState::EXIT_DID_NOT_ENTER;\n\t\texitUnpair2_ = ReportingState::EXIT_DID_NOT_ENTER;\n\t\tdone_ = false;\n\t}", "idx": 96}
{"project": "bowtie2", "commit_id": "189_bowtie2_2.5.1_aln_sink.h_init.cpp", "target": 0, "func": "void init(\n\t\tTHitInt khits_,\n\t\tTHitInt mhits_,\n\t\tTHitInt pengap_,\n\t\tbool msample_,\n\t\tbool discord_,\n\t\tbool mixed_)\n\t{\n\t\tkhits   = khits_;     // -k (or high if -a)\n\t\tmhits   = ((mhits_ == 0) ? std::numeric_limits<THitInt>::max() : mhits_);\n\t\tpengap  = pengap_;\n\t\tmsample = msample_;\n\t\tdiscord = discord_;\n\t\tmixed   = mixed_;\n\t}", "idx": 97}
{"project": "bowtie2", "commit_id": "18_bowtie2_2.5.1_aligner_cache.h_nextRead.cpp", "target": 0, "func": "void nextRead() {\n\t\tcurrent_->clear();\n\t\tresetRead();\n\t\tassert(!aligning());\n\t}", "idx": 98}
{"project": "bowtie2", "commit_id": "190_bowtie2_2.5.1_aln_sink.h_merge.cpp", "target": 0, "func": "void merge(const ReportingMetrics& met) {\n\t\tThreadSafe ts(mutex_m);\n\t\tnread         += met.nread;\n\n\t\tnpaired       += met.npaired;\n\t\tnunpaired     += met.nunpaired;\n\n\t\tnconcord_uni  += met.nconcord_uni;\n\t\tnconcord_uni1 += met.nconcord_uni1;\n\t\tnconcord_uni2 += met.nconcord_uni2;\n\t\tnconcord_rep  += met.nconcord_rep;\n\t\tnconcord_0    += met.nconcord_0;\n\n\t\tndiscord      += met.ndiscord;\n\n\t\tnunp_0_uni    += met.nunp_0_uni;\n\t\tnunp_0_uni1   += met.nunp_0_uni1;\n\t\tnunp_0_uni2   += met.nunp_0_uni2;\n\t\tnunp_0_rep    += met.nunp_0_rep;\n\t\tnunp_0_0      += met.nunp_0_0;\n\n\t\tnunp_rep_uni  += met.nunp_rep_uni;\n\t\tnunp_rep_uni1 += met.nunp_rep_uni1;\n\t\tnunp_rep_uni2 += met.nunp_rep_uni2;\n\t\tnunp_rep_rep  += met.nunp_rep_rep;\n\t\tnunp_rep_0    += met.nunp_rep_0;\n\n\t\tnunp_uni      += met.nunp_uni;\n\t\tnunp_uni1     += met.nunp_uni1;\n\t\tnunp_uni2     += met.nunp_uni2;\n\t\tnunp_rep      += met.nunp_rep;\n\t\tnunp_0        += met.nunp_0;\n\n\t\tsum_best1     += met.sum_best1;\n\t\tsum_best2     += met.sum_best2;\n\t\tsum_best      += met.sum_best;\n\t}", "idx": 99}
{"project": "bowtie2", "commit_id": "191_bowtie2_2.5.1_aln_sink.h_ReportingParams.cpp", "target": 0, "func": "explicit ReportingParams(\n\t\tTHitInt khits_,\n\t\tTHitInt mhits_,\n\t\tTHitInt pengap_,\n\t\tbool msample_,\n\t\tbool discord_,\n\t\tbool mixed_)\n\t{\n\t\tinit(khits_, mhits_, pengap_, msample_, discord_, mixed_);\n\t}", "idx": 100}
{"project": "bowtie2", "commit_id": "192_bowtie2_2.5.1_aln_sink.h_boostThreshold.cpp", "target": 0, "func": "void boostThreshold(SimpleFunc& func) {\n\t\tTHitInt mul = mult();\n\t\tassert_gt(mul, 0);\n\t\tif(mul == std::numeric_limits<THitInt>::max()) {\n\t\t\tfunc.setMin(std::numeric_limits<double>::max());\n\t\t} else if(mul > 1) {\n\t\t\tfunc.mult(mul);\n\t\t}\n\t}", "idx": 101}
{"project": "bowtie2", "commit_id": "193_bowtie2_2.5.1_aln_sink.h_convertUnpairedToDiscordant.cpp", "target": 0, "func": "void convertUnpairedToDiscordant() {\n\t\tassert_eq(1, numUnpaired1());\n\t\tassert_eq(1, numUnpaired2());\n\t\tassert_eq(0, numDiscordant());\n\t\texitUnpair1_ = exitUnpair2_ = ReportingState::EXIT_CONVERTED_TO_DISCORDANT;\n\t\tnunpair1_ = nunpair2_ = 0;\n\t\tndiscord_ = 1;\n\t\tassert_eq(1, numDiscordant());\n\t}", "idx": 102}
{"project": "bowtie2", "commit_id": "194_bowtie2_2.5.1_aln_sink.h_updateDone.cpp", "target": 0, "func": "inline void updateDone() {\n\t\tdoneUnpair_ = doneUnpair1_ && doneUnpair2_;\n\t\tdone_ = doneUnpair_ && doneDiscord_ && doneConcord_;\n\t}", "idx": 103}
{"project": "bowtie2", "commit_id": "195_bowtie2_2.5.1_aln_sink.h_finish.cpp", "target": 0, "func": "void finish(\n\t\tsize_t repThresh,\n\t\tbool discord,\n\t\tbool mixed,\n\t\tbool hadoopOut)\n\t{\n\t\t// Close output streams\n\t\tif(!quiet_) {\n\t\t\tprintAlSumm(\n\t\t\t\tmet_,\n\t\t\t\trepThresh,\n\t\t\t\tdiscord,\n\t\t\t\tmixed,\n\t\t\t\thadoopOut);\n\t\t}\n\t}", "idx": 104}
{"project": "bowtie2", "commit_id": "196_bowtie2_2.5.1_aln_sink.h_mergeMetrics.cpp", "target": 0, "func": "void mergeMetrics(const ReportingMetrics& met) {\n\t\tmet_.merge(met);\n\t}", "idx": 105}
{"project": "bowtie2", "commit_id": "197_bowtie2_2.5.1_alphabet.cpp_setIupacsCat.cpp", "target": 0, "func": "void setIupacsCat(uint8_t cat) {\n\tassert(cat < 4);\n\tasc2dnacat[(int)'B'] = asc2dnacat[(int)'b'] =\n\tasc2dnacat[(int)'D'] = asc2dnacat[(int)'d'] =\n\tasc2dnacat[(int)'H'] = asc2dnacat[(int)'h'] =\n\tasc2dnacat[(int)'K'] = asc2dnacat[(int)'k'] =\n\tasc2dnacat[(int)'M'] = asc2dnacat[(int)'m'] =\n\tasc2dnacat[(int)'N'] = asc2dnacat[(int)'n'] =\n\tasc2dnacat[(int)'R'] = asc2dnacat[(int)'r'] =\n\tasc2dnacat[(int)'S'] = asc2dnacat[(int)'s'] =\n\tasc2dnacat[(int)'V'] = asc2dnacat[(int)'v'] =\n\tasc2dnacat[(int)'W'] = asc2dnacat[(int)'w'] =\n\tasc2dnacat[(int)'X'] = asc2dnacat[(int)'x'] =\n\tasc2dnacat[(int)'Y'] = asc2dnacat[(int)'y'] = cat;\n}", "idx": 106}
{"project": "bowtie2", "commit_id": "198_bowtie2_2.5.1_alphabet.h_isUnambigNuc.cpp", "target": 0, "func": "static inline bool isUnambigNuc(char c) {\n\treturn asc2dnacat[(int)c] == 1;\n}", "idx": 107}
{"project": "bowtie2", "commit_id": "199_bowtie2_2.5.1_alphabet.h_comp.cpp", "target": 0, "func": "static inline char comp(char c) {\n\tswitch(c) {\n\tcase 'a': return 't';\n\tcase 'A': return 'T';\n\tcase 'c': return 'g';\n\tcase 'C': return 'G';\n\tcase 'g': return 'c';\n\tcase 'G': return 'C';\n\tcase 't': return 'a';\n\tcase 'T': return 'A';\n\tdefault: return c;\n\t}\n}", "idx": 108}
{"project": "bowtie2", "commit_id": "19_bowtie2_2.5.1_aligner_cache.h_resetRead.cpp", "target": 0, "func": "void resetRead() {\n\t\tcacheable_ = false;\n\t\trangen_ = eltsn_ = 0;\n\t\tqv_ = NULL;\n\t}", "idx": 109}
{"project": "bowtie2", "commit_id": "1_bowtie2_2.5.1_aligner_bt.cpp_DEBUG_CHECK.cpp", "target": 0, "func": "define DEBUG_CHECK(ss, row, col, hef) { \\\n\tif(prob_.cper_->debug() && row >= 0 && col >= 0) { \\\n\t\tTAlScore s = ss; \\\n\t\tif(s == MIN_I16) s = MIN_I64; \\\n\t\tif(local && s < 0) s = 0; \\\n\t\tTAlScore deb = prob_.cper_->debugCell(row, col, hef); \\\n\t\tif(local && deb < 0) deb = 0; \\\n\t\tassert_eq(s, deb); \\\n\t} \\\n}", "idx": 110}
{"project": "bowtie2", "commit_id": "200_bowtie2_2.5.1_alphabet.h_compDna.cpp", "target": 0, "func": "static inline int compDna(int c) {\n\tassert_leq(c, 4);\n\treturn dnacomp[c];\n}", "idx": 111}
{"project": "bowtie2", "commit_id": "201_bowtie2_2.5.1_alphabet.h_decodeNuc.cpp", "target": 0, "func": "static inline void decodeNuc(char c , int& num, int *alts) {\n\tswitch(c) {\n\tcase 'A': alts[0] = 0; num = 1; break;\n\tcase 'C': alts[0] = 1; num = 1; break;\n\tcase 'G': alts[0] = 2; num = 1; break;\n\tcase 'T': alts[0] = 3; num = 1; break;\n\tcase 'M': alts[0] = 0; alts[1] = 1; num = 2; break;\n\tcase 'R': alts[0] = 0; alts[1] = 2; num = 2; break;\n\tcase 'W': alts[0] = 0; alts[1] = 3; num = 2; break;\n\tcase 'S': alts[0] = 1; alts[1] = 2; num = 2; break;\n\tcase 'Y': alts[0] = 1; alts[1] = 3; num = 2; break;\n\tcase 'K': alts[0] = 2; alts[1] = 3; num = 2; break;\n\tcase 'V': alts[0] = 0; alts[1] = 1; alts[2] = 2; num = 3; break;\n\tcase 'H': alts[0] = 0; alts[1] = 1; alts[2] = 3; num = 3; break;\n\tcase 'D': alts[0] = 0; alts[1] = 2; alts[2] = 3; num = 3; break;\n\tcase 'B': alts[0] = 1; alts[1] = 2; alts[2] = 3; num = 3; break;\n\tcase 'N': alts[0] = 0; alts[1] = 1; alts[2] = 2; alts[3] = 3; num = 4; break;\n\tdefault: {\n\t\tstd::cerr << \"Bad IUPAC code: \" << c << \", (int: \" << (int)c << \")\" << std::endl;\n\t\tthrow std::runtime_error(\"\");\n\t}\n\t}\n}", "idx": 112}
{"project": "bowtie2", "commit_id": "202_bowtie2_2.5.1_assert_helpers.h_assert_in2.cpp", "target": 0, "func": "static inline void assert_in2(char c, const char *str, const char *file, int line) {\n\tconst char *s = str;\n\twhile(*s != '\\0') {\n\t\tif(c == *s) return;\n\t\ts++;\n\t}\n\tstd::cout << \"assert_in: (\" << c << \") not in  (\" << str << \")\" << std::endl;\n\tstd::cout << file << \":\" << line << std::endl;\n\tassert(0);\n}", "idx": 113}
{"project": "bowtie2", "commit_id": "203_bowtie2_2.5.1_assert_helpers.h_assert_range_helper.cpp", "target": 0, "func": "inline static void assert_range_helper(const T& begin,\n                                       const T& end,\n                                       const T& val,\n                                       const char *file,\n                                       int line)\n{\n\tif(val < begin || val > end) {\n\t\tstd::cout << \"assert_range: (\" << val << \") not in  [\"\n\t\t          << begin << \", \" << end << \"]\" << std::endl;\n\t\tstd::cout << file << \":\" << line << std::endl;\n\t\tassert(0);\n\t}\n}", "idx": 114}
{"project": "bowtie2", "commit_id": "204_bowtie2_2.5.1_banded.cpp_main.cpp", "target": 0, "func": "ifdef MAIN_BANDED\nint main(void) {\n\t\n}", "idx": 115}
{"project": "bowtie2", "commit_id": "205_bowtie2_2.5.1_banded.h_nextAlignment.cpp", "target": 0, "func": "void nextAlignment() {\n\t}", "idx": 116}
{"project": "bowtie2", "commit_id": "206_bowtie2_2.5.1_bitpack.h_pack_2b_in_8b.cpp", "target": 0, "func": "static inline void pack_2b_in_8b(const int two, uint8_t& eight, const int off) {\n\tassert_lt(two, 4);\n\tassert_lt(off, 4);\n\teight |= (two << (off*2));\n}", "idx": 117}
{"project": "bowtie2", "commit_id": "207_bowtie2_2.5.1_bitpack.h_unpack_2b_from_8b.cpp", "target": 0, "func": "static inline int unpack_2b_from_8b(const uint8_t eight, const int off) {\n\tassert_lt(off, 4);\n\treturn ((eight >> (off*2)) & 0x3);\n}", "idx": 118}
{"project": "bowtie2", "commit_id": "208_bowtie2_2.5.1_bitpack.h_pack_2b_in_32b.cpp", "target": 0, "func": "static inline void pack_2b_in_32b(const int two, uint32_t& thirty2, const int off) {\n\tassert_lt(two, 4);\n\tassert_lt(off, 16);\n\tthirty2 |= (two << (off*2));\n}", "idx": 119}
{"project": "bowtie2", "commit_id": "209_bowtie2_2.5.1_bitpack.h_unpack_2b_from_32b.cpp", "target": 0, "func": "static inline int unpack_2b_from_32b(const uint32_t thirty2, const int off) {\n\tassert_lt(off, 16);\n\treturn ((thirty2 >> (off*2)) & 0x3);\n}", "idx": 120}
{"project": "bowtie2", "commit_id": "20_bowtie2_2.5.1_aligner_driver.h_initRead.cpp", "target": 0, "func": "void initRead(\n\t\tconst Read& q1,\n\t\tbool nofw,\n\t\tbool norc,\n\t\tTAlScore minsc,\n\t\tTAlScore maxpen,\n\t\tconst Read* q2)\n\t{\n\t\t// Initialize search for mate 1.  This includes instantiating and\n\t\t// prioritizing all the search roots.\n\t\tdr1_.initRead(q1, nofw, norc, minsc, maxpen, q2, sel_);\n\t\tred1_.init(q1.length());\n\t\tpaired_ = false;\n\t\tif(q2 != NULL) {\n\t\t\t// Initialize search for mate 1.  This includes instantiating and\n\t\t\t// prioritizing all the search roots.\n\t\t\tdr2_.initRead(*q2, nofw, norc, minsc, maxpen, &q1, sel_);\n\t\t\tred2_.init(q2->length());\n\t\t\tpaired_ = true;\n\t\t} else {\n\t\t\tdr2_.reset();\n\t\t}\n\t\t// Initialize stopping conditions.  We use two conditions:\n\t\t// totsz: when memory footprint exceeds this many bytes\n\t\t// totfmops: when we've exceeded this many FM Index ops\n\t\tsize_t totsz = totsz_.f<size_t>(q1.length());\n\t\tsize_t totfmops = totfmops_.f<size_t>(q1.length());\n\t\tstop_.init(\n\t\t\ttotsz,\n\t\t\t0,\n\t\t\ttrue,\n\t\t\ttotfmops);\n\t}", "idx": 121}
{"project": "bowtie2", "commit_id": "210_bowtie2_2.5.1_blockwise_sa.h_hasMoreSuffixes.cpp", "target": 0, "func": "bool hasMoreSuffixes() {\n\t\tif(_itrPushedBackSuffix != OFF_MASK) return true;\n\t\ttry {\n\t\t\t_itrPushedBackSuffix = nextSuffix();\n\t\t} catch(out_of_range& e) {\n\t\t\tassert_eq(OFF_MASK, _itrPushedBackSuffix);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}", "idx": 122}
{"project": "bowtie2", "commit_id": "211_bowtie2_2.5.1_blockwise_sa.h_resetSuffixItr.cpp", "target": 0, "func": "void resetSuffixItr() {\n\t\t_itrBucket.clear();\n\t\t_itrBucketPos = OFF_MASK;\n\t\t_itrPushedBackSuffix = OFF_MASK;\n\t\treset();\n\t\tassert(suffixItrIsReset());\n\t}", "idx": 123}
{"project": "bowtie2", "commit_id": "212_bowtie2_2.5.1_blockwise_sa.h_suffixItrIsReset.cpp", "target": 0, "func": "bool suffixItrIsReset() {\n\t\treturn _itrBucket.size()    == 0 &&\n\t\t\t_itrBucketPos        == OFF_MASK &&\n\t\t\t_itrPushedBackSuffix == OFF_MASK &&\n\t\t\tisReset();\n\t}", "idx": 124}
{"project": "bowtie2", "commit_id": "213_bowtie2_2.5.1_blockwise_sa.h_nextSuffix.cpp", "target": 0, "func": "inline TIndexOffU nextSuffix() {\n\t\treturn _suffixes[_i++];\n\t}", "idx": 125}
{"project": "bowtie2", "commit_id": "214_bowtie2_2.5.1_blockwise_sa.h_reset.cpp", "target": 0, "func": "virtual void reset() {\n\t\tif(!_built) {\n\t\t\tbuild();\n\t\t}\n\t\tassert(_built);\n\t\t_cur = 0;\n\t}", "idx": 126}
{"project": "bowtie2", "commit_id": "215_bowtie2_2.5.1_blockwise_sa.h_isReset.cpp", "target": 0, "func": "re about to dole out the first bucket\n\tvirtual bool isReset() {\n\t\treturn _cur == 0;\n\t}", "idx": 127}
{"project": "bowtie2", "commit_id": "216_bowtie2_2.5.1_blockwise_sa.h_nextBlock.cpp", "target": 0, "func": "void nextBlock(int a, int b) {\n\t\treturn;\n\t}", "idx": 128}
{"project": "bowtie2", "commit_id": "217_bowtie2_2.5.1_blockwise_sa.h_simulateAllocs.cpp", "target": 0, "func": "static size_t simulateAllocs(const TStr& text, TIndexOffU bucketSz) {\n\t\tsize_t len = text.length();\n\t\t// _sampleSuffs and _itrBucket are in memory at the peak\n\t\tsize_t bsz = bucketSz;\n\t\tsize_t sssz = len / max<TIndexOffU>(bucketSz-1, 1);\n\t\tAutoArray<TIndexOffU> tmp(bsz + sssz + (1024 * 1024 /*out of caution*/), EBWT_CAT);\n\t\treturn bsz;\n\t}", "idx": 129}
{"project": "bowtie2", "commit_id": "218_bowtie2_2.5.1_blockwise_sa.h_build.cpp", "target": 0, "func": "void build() {\n\t\t// Calculate difference-cover sample\n\t\tassert(_dc.get() == NULL);\n\t\tif(_dcV != 0) {\n\t\t\t_dc.init(new TDC(this->text(), _dcV, this->verbose(), this->sanityCheck()));\n\t\t\t_dc.get()->build(_pool, this->_nthreads);\n\t\t}\n\t\t// Calculate sample suffixes\n\t\tif(this->bucketSz() <= this->text().length()) {\n\t\t\tVMSG_NL(\"Building samples\");\n\t\t\tbuildSamples();\n\t\t} else {\n\t\t\tVMSG_NL(\"Skipping building samples since text length \" <<\n\t\t\t\tthis->text().length() << \" is less than bucket size: \" <<\n\t\t\t\tthis->bucketSz());\n\t\t}\n\t\t_built = true;\n\t}", "idx": 130}
{"project": "bowtie2", "commit_id": "219_bowtie2_2.5.1_blockwise_sa.h_suffixLcp.cpp", "target": 0, "func": "inline\nstatic TIndexOffU suffixLcp(const T& t, TIndexOffU aOff, TIndexOffU bOff) {\n\tTIndexOffU c = 0;\n\tsize_t len = t.length();\n\tassert_leq(aOff, len);\n\tassert_leq(bOff, len);\n\twhile(aOff + c < len && bOff + c < len && t[aOff + c] == t[bOff + c]) c++;\n\treturn c;\n}", "idx": 131}
{"project": "bowtie2", "commit_id": "21_bowtie2_2.5.1_aligner_driver.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tdr1_.reset();\n\t\tdr2_.reset();\n\t\tred1_.reset();\n\t\tred2_.reset();\n\t}", "idx": 132}
{"project": "bowtie2", "commit_id": "220_bowtie2_2.5.1_blockwise_sa.h_lookupSuffixZ.cpp", "target": 0, "func": "static TIndexOffU lookupSuffixZ(\n\tconst T& t,\n\tTIndexOffU zOff,\n\tTIndexOffU off,\n\tconst EList<TIndexOffU>& z)\n{\n\tif(zOff < z.size()) {\n\t\tTIndexOffU ret = z[zOff];\n\t\tassert_eq(ret, suffixLcp(t, off + zOff, off));\n\t\treturn ret;\n\t}\n\tassert_leq(off + zOff, t.length());\n\treturn suffixLcp(t, off + zOff, off);\n}", "idx": 133}
{"project": "bowtie2", "commit_id": "221_bowtie2_2.5.1_bt2_build.cpp_resetOptions.cpp", "target": 0, "func": "static void resetOptions() {\n\tverbose      = true;  // be talkative (default)\n\tsanityCheck  = 0;     // do slow sanity checks\n\tformat       = FASTA; // input sequence format\n\tbmax         = OFF_MASK; // max blockwise SA bucket size\n\tbmaxMultSqrt = OFF_MASK; // same, as multplier of sqrt(n)\n\tbmaxDivN     = 4;          // same, as divisor of n\n\tdcv          = 1024;  // bwise SA difference-cover sample sz\n\tnoDc         = 0;     // disable difference-cover sample\n\tentireSA     = 0;     // 1 = disable blockwise SA\n\tseed         = 0;     // srandom seed\n\tshowVersion  = 0;     // just print version and quit?\n\t//   Ebwt parameters\n\tlineRate     = Ebwt::default_lineRate; // a \"line\" is 64 or 128 bytes\n\tlinesPerSide = 1;  // 1 64-byte line on a side\n\toffRate      = 4;  // sample 1 out of 16 SA elts\n\tftabChars    = 10; // 10 chars in initial lookup table\n\tbigEndian    = 0;  // little endian\n\tnsToAs       = false; // convert reference Ns to As prior to indexing\n\tdoSaFile     = false; // make a file with just the suffix array in it\n\tdoBwtFile    = false; // make a file with just the BWT string in it\n\tautoMem      = true;  // automatically adjust memory usage parameters\n\tpacked       = false; //\n\twriteRef     = true;  // write compact reference to .3.gEbwt_ext/.4.gEbwt_ext\n\tjustRef      = false; // *just* write compact reference, don't index\n\treverseEach  = false;\n\tnthreads     = 1;\n\twrapper.clear();\n}", "idx": 134}
{"project": "bowtie2", "commit_id": "222_bowtie2_2.5.1_bt2_build.cpp_printUsage.cpp", "target": 0, "func": "static void printUsage(ostream& out) {\n\tout << \"Bowtie 2 version \" << string(BOWTIE2_VERSION).c_str() << \" by Ben Langmead (langmea@cs.jhu.edu, www.cs.jhu.edu/~langmea)\" << endl;\n\n#ifdef BOWTIE_64BIT_INDEX\n\tstring tool_name = \"bowtie2-build-l\";\n#else\n\tstring tool_name = \"bowtie2-build-s\";\n#endif\n\tif(wrapper == \"basic-0\") {\n\t\ttool_name = \"bowtie2-build\";\n\t}\n\n\t//               1         2         3         4         5         6         7         8\n\t//      12345678901234567890123456789012345678901234567890123456789012345678901234567890\n\tout << \"Usage: \" << tool_name << \" [options]* <reference_in> <bt2_index_base>\" << endl\n\t    << \"    reference_in            comma-separated list of files with ref sequences\" << endl\n\t    << \"    bt2_index_base          write \" + gEbwt_ext + \" data to files with this dir/basename\" << endl\n\t    << \"*** Bowtie 2 indexes will work with Bowtie v1.2.3 and later. ***\" << endl\n\t    << \"Options:\" << endl\n\t    << \"    -f                      reference files are Fasta (default)\" << endl\n\t    << \"    -c                      reference sequences given on cmd line (as\" << endl\n\t    << \"                            <reference_in>)\" << endl;\n\tif(wrapper == \"basic-0\") {\n\tout << \"    --large-index           force generated index to be 'large', even if ref\" << endl\n\t    << \"                            has fewer than 4 billion nucleotides\" << endl\n\t    << \"    --debug                 use the debug binary; slower, assertions enabled\" << endl\n\t    << \"    --sanitized             use sanitized binary; slower, uses ASan and/or UBSan\" << endl\n\t    << \"    --verbose               log the issued command\" << endl;\n\t}\n\tout << \"    -a/--noauto             disable automatic -p/--bmax/--dcv memory-fitting\" << endl\n\t    << \"    -p/--packed             use packed strings internally; slower, less memory\" << endl\n\t    << \"    --bmax <int>            max bucket sz for blockwise suffix-array builder\" << endl\n\t    << \"    --bmaxdivn <int>        max bucket sz as divisor of ref len (default: 4)\" << endl\n\t    << \"    --dcv <int>             diff-cover period for blockwise (default: 1024)\" << endl\n\t    << \"    --nodc                  disable diff-cover (algorithm becomes quadratic)\" << endl\n\t    << \"    -r/--noref              don't build .3/.4 index files\" << endl\n\t    << \"    -3/--justref            just build .3/.4 index files\" << endl\n\t    << \"    -o/--offrate <int>      SA is sampled every 2^<int> BWT chars (default: 5)\" << endl\n\t    << \"    -t/--ftabchars <int>    # of chars consumed in initial lookup (default: 10)\" << endl\n\t    << \"    --threads <int>         # of threads\" << endl\n\t    //<< \"    --ntoa                  convert Ns in reference to As\" << endl\n\t    //<< \"    --big --little          endianness (default: little, this host: \"\n\t    //<< (currentlyBigEndian()? \"big\":\"little\") << \")\" << endl\n\t    << \"    --seed <int>            seed for random number generator\" << endl\n\t    << \"    -q/--quiet              verbose output (for debugging)\" << endl\n\t    << \"    --h/--help              print this message and quit\" << endl\n\t    << \"    --version               print version information and quit\" << endl\n\t    ;\n\tif(wrapper.empty()) {\n\t\tcerr << endl\n\t\t     << \"*** Warning ***\" << endl\n\t\t     << \"'\" << tool_name << \"' was run directly.  It is recommended \"\n\t\t     << \"that you run the wrapper script 'bowtie2-build' instead.\"\n\t\t     << endl << endl;\n\t}\n}", "idx": 135}
{"project": "bowtie2", "commit_id": "223_bowtie2_2.5.1_bt2_build.cpp_parseNumber.cpp", "target": 0, "func": "static T parseNumber(T lower, const char *errmsg) {\n\tchar *endPtr= NULL;\n\tT t = (T)strtoll(optarg, &endPtr, 10);\n\tif (endPtr != NULL) {\n\t\tif (t < lower) {\n\t\t\tcerr << errmsg << endl;\n\t\t\tprintUsage(cerr);\n\t\t\tthrow 1;\n\t\t}\n\t\treturn t;\n\t}\n\tcerr << errmsg << endl;\n\tprintUsage(cerr);\n\tthrow 1;\n\treturn -1;\n}", "idx": 136}
{"project": "bowtie2", "commit_id": "224_bowtie2_2.5.1_bt2_build.cpp_deleteIdxFiles.cpp", "target": 0, "func": "static void deleteIdxFiles(\n\tconst string& outfile,\n\tbool doRef,\n\tbool justRef)\n{\n\n\tfor(size_t i = 0; i < filesWritten.size(); i++) {\n\t\tcerr << \"Deleting \\\"\" << filesWritten[i].c_str()\n\t\t     << \"\\\" file written during aborted indexing attempt.\" << endl;\n\t\tremove(filesWritten[i].c_str());\n\t}\n}", "idx": 137}
{"project": "bowtie2", "commit_id": "225_bowtie2_2.5.1_bt2_build.cpp_renameIdxFiles.cpp", "target": 0, "func": "static void renameIdxFiles() {\n\tfor (size_t i = 0; i < filesWritten.size(); i++) {\n\t\tstd::string oldName = filesWritten[i] + \".tmp\";\n\t\tif (verbose)\n\t\t\tstd::cerr << \"Renaming \" << oldName << \" to \" << filesWritten[i] << std::endl;\n\t\tstd::rename(oldName.c_str(), filesWritten[i].c_str());\n\t}\n}", "idx": 138}
{"project": "bowtie2", "commit_id": "226_bowtie2_2.5.1_bt2_dp.cpp_resetOptions.cpp", "target": 0, "func": "write output to this file\n\nstatic void resetOptions() {\n\tgVerbose                = 0;\n\tgQuiet\t\t\t\t\t= false;\n\tsanityCheck\t\t\t\t= 0;  // enable expensive sanity checks\n\tseed\t\t\t\t\t= 0; // srandom() seed\n\tshowVersion\t\t\t\t= false; // just print version and quit?\n\tqUpto\t\t\t\t\t= 0xffffffffffffffff; // max # of queries to read\n\tnthreads\t\t\t\t= 1;     // number of pthreads operating concurrently\n\tskipReads\t\t\t\t= 0;     // # reads/read pairs to skip\n\tgGapBarrier\t\t\t\t= 4;     // disallow gaps within this many chars of either end of alignment\n\tbonusMatchType  = DEFAULT_MATCH_BONUS_TYPE;\n\tbonusMatch      = DEFAULT_MATCH_BONUS;\n\tpenMmcType      = DEFAULT_MM_PENALTY_TYPE;\n\tpenMmcMax       = DEFAULT_MM_PENALTY_MAX;\n\tpenMmcMin       = DEFAULT_MM_PENALTY_MIN;\n\tpenNType        = DEFAULT_N_PENALTY_TYPE;\n\tpenN            = DEFAULT_N_PENALTY;\n\tpenNCatPair     = DEFAULT_N_CAT_PAIR; // concatenate mates before N filtering?\n\tlocalAlign      = false;     // do local alignment in DP steps\n\tpenRdGapConst   = DEFAULT_READ_GAP_CONST;\n\tpenRfGapConst   = DEFAULT_REF_GAP_CONST;\n\tpenRdGapLinear  = DEFAULT_READ_GAP_LINEAR;\n\tpenRfGapLinear  = DEFAULT_REF_GAP_LINEAR;\n\tscoreMin.init  (SIMPLE_FUNC_LINEAR, DEFAULT_MIN_CONST,   DEFAULT_MIN_LINEAR);\n\tnCeil.init     (SIMPLE_FUNC_LINEAR, 0.0f, std::numeric_limits<double>::max(), 2.0f, 0.1f);\n\tmsIval.init    (SIMPLE_FUNC_LINEAR, 1.0f, std::numeric_limits<double>::max(), DEFAULT_IVAL_B, DEFAULT_IVAL_A);\n\tenable8            = true;  // use 8-bit SSE where possible?\n\tcminlen            = 2000;  // longer reads use checkpointing\n\tcpow2              = 4;     // checkpoint interval log2\n\tdoTri              = false; // do triangular mini-fills?\n\tignoreQuals = false;     // all mms incur same penalty, regardless of qual\n\tqueries.clear();         // list of query files\n\toutfile.clear();         // write output to this file\n}", "idx": 139}
{"project": "bowtie2", "commit_id": "227_bowtie2_2.5.1_bt2_dp.cpp_printUsage.cpp", "target": 0, "func": "static void printUsage(ostream& out) {\n\tout << \"Bowtie 2 dynamic programming engine, by Ben Langmead (langmea@cs.jhu.edu, www.cs.jhu.edu/~langmea)\" << endl;\n\tstring tool_name = \"bowtie2-dp\";\n\tout << \"Usage: \" << endl\n\t    << \"  \" << tool_name.c_str() << \" [options]* <in> <out>\" << endl\n\t    << endl\n\t    <<     \"  <in>           File with DP input problems (default: stdin)\" << endl\n\t    <<     \"  <out>          File with DP output solutions (default: stdout)\" << endl\n\t\t<< endl\n\t    << \"Options (defaults in parentheses):\" << endl\n\t\t<< endl\n\t    << \" Input:\" << endl\n\t    << \"  -s/--skip <int>    skip the first <int> problems in the input (none)\" << endl\n\t    << \"  -u/--upto <int>    stop after first <int> problems (no limit)\" << endl\n\t\t<< endl\n\t    << \" Alignment:\" << endl\n\t\t<< \"  --n-ceil <func>    func for max # non-A/C/G/Ts permitted in aln (L,0,0.15)\" << endl\n\t\t<< \"  --gbar <int>       disallow gaps within <int> nucs of read extremes (4)\" << endl\n\t\t<< \"  --ignore-quals     treat all quality values as 30 on Phred scale (off)\" << endl\n\t\t<< endl\n\t\t<< \"  --end-to-end       entire read must align; no clipping (on)\" << endl\n\t\t<< \"   OR\" << endl\n\t\t<< \"  --local            local alignment; ends might be soft clipped (off)\" << endl\n\t\t<< endl\n\t    << \" Scoring:\" << endl\n\t\t<< \"  --ma <int>         match bonus (0 for --end-to-end, 2 for --local) \" << endl\n\t\t<< \"  --mp <int>         max penalty for mismatch; lower qual = lower penalty (6)\" << endl\n\t\t<< \"  --np <int>         penalty for non-A/C/G/Ts in read/ref (1)\" << endl\n\t\t<< \"  --rdg <int>,<int>  read gap open, extend penalties (5,3)\" << endl\n\t\t<< \"  --rfg <int>,<int>  reference gap open, extend penalties (5,3)\" << endl\n\t\t<< \"  --score-min <func> min acceptable alignment score w/r/t read length\" << endl\n\t\t<< \"                     (G,20,8 for local, L,-0.6,-0.6 for end-to-end)\" << endl\n\t    << \"  --quiet            print nothing to stderr except serious errors\" << endl\n\t\t<< endl\n\t    << \" Performance:\" << endl\n\t    << \"  -p/--threads <int> number of alignment threads to launch (1)\" << endl\n\t\t<< endl\n\t    << \" Other:\" << endl\n\t    << \"  --version          print version information and quit\" << endl\n\t    << \"  -h/--help          print this usage message\" << endl\n\t    ;\n}", "idx": 140}
{"project": "bowtie2", "commit_id": "228_bowtie2_2.5.1_bt2_dp.cpp_parseInt.cpp", "target": 0, "func": "static int parseInt(int lower, const char *errmsg, const char *arg) {\n\treturn parseInt(lower, std::numeric_limits<int>::max(), errmsg, arg);\n}", "idx": 141}
{"project": "bowtie2", "commit_id": "229_bowtie2_2.5.1_bt2_dp.cpp_parse.cpp", "target": 0, "func": "T parse(const char *s) {\n\tT tmp;\n\tstringstream ss(s);\n\tss >> tmp;\n\treturn tmp;\n}", "idx": 142}
{"project": "bowtie2", "commit_id": "22_bowtie2_2.5.1_aligner_metrics.h_clear.cpp", "target": 0, "func": "void clear() {\n\t\tm_n = 0;\n\t\tm_tot = 0.0;\n\t}", "idx": 143}
{"project": "bowtie2", "commit_id": "230_bowtie2_2.5.1_bt2_dp.cpp_parseFuncType.cpp", "target": 0, "func": "static int parseFuncType(const std::string& otype) {\n\tstring type = otype;\n\tif(type == \"C\" || type == \"Constant\") {\n\t\treturn SIMPLE_FUNC_CONST;\n\t} else if(type == \"L\" || type == \"Linear\") {\n\t\treturn SIMPLE_FUNC_LINEAR;\n\t} else if(type == \"S\" || type == \"Sqrt\") {\n\t\treturn SIMPLE_FUNC_SQRT;\n\t} else if(type == \"G\" || type == \"Log\") {\n\t\treturn SIMPLE_FUNC_LOG;\n\t}\n\tstd::cerr << \"Error: Bad function type '\" << otype.c_str()\n\t          << \"'.  Should be C (constant), L (linear), \"\n\t          << \"S (square root) or G (natural log).\" << std::endl;\n\tthrow 1;\n}", "idx": 144}
{"project": "bowtie2", "commit_id": "231_bowtie2_2.5.1_bt2_dp.cpp_PARSE_FUNC.cpp", "target": 0, "func": "define PARSE_FUNC(fv) { \\\n\tif(args.size() >= 1) { \\\n\t\tfv.setType(parseFuncType(args[0])); \\\n\t} \\\n\tif(args.size() >= 2) { \\\n\t\tdouble co; \\\n\t\tistringstream tmpss(args[1]); \\\n\t\ttmpss >> co; \\\n\t\tfv.setConst(co); \\\n\t} \\\n\tif(args.size() >= 3) { \\\n\t\tdouble ce; \\\n\t\tistringstream tmpss(args[2]); \\\n\t\ttmpss >> ce; \\\n\t\tfv.setCoeff(ce); \\\n\t} \\\n\tif(args.size() >= 4) { \\\n\t\tdouble mn; \\\n\t\tistringstream tmpss(args[3]); \\\n\t\ttmpss >> mn; \\\n\t\tfv.setMin(mn); \\\n\t} \\\n\tif(args.size() >= 5) { \\\n\t\tdouble mx; \\\n\t\tistringstream tmpss(args[4]); \\\n\t\ttmpss >> mx; \\\n\t\tfv.setMin(mx); \\\n\t} \\\n}", "idx": 145}
{"project": "bowtie2", "commit_id": "232_bowtie2_2.5.1_bt2_dp.cpp_parseOptions.cpp", "target": 0, "func": "static void parseOptions(int argc, const char **argv) {\n\tint option_index = 0;\n\tint next_option;\n\twhile(true) {\n\t\tnext_option = getopt_long(\n\t\t\targc, const_cast<char**>(argv),\n\t\t\tshort_options, long_options, &option_index);\n\t\tconst char * arg = optarg;\n\t\tif(next_option == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\tparseOption(next_option, arg);\n\t}\n\t// If both -s and -u are used, we need to adjust qUpto accordingly\n\t// since it uses rdid to know if we've reached the -u limit (and\n\t// rdids are all shifted up by skipReads characters)\n\tif(qUpto + skipReads > qUpto) {\n\t\tqUpto += skipReads;\n\t}\n\tif(gGapBarrier < 1) {\n\t\tcerr << \"Warning: --gbar was set less than 1 (=\" << gGapBarrier\n\t\t     << \"); setting to 1 instead\" << endl;\n\t\tgGapBarrier = 1;\n\t}\n#ifndef NDEBUG\n\tif(!gQuiet) {\n\t\tcerr << \"Warning: Running in debug mode.  Please use debug mode only \"\n\t\t\t << \"for diagnosing errors, and not for typical use of Bowtie 2.\"\n\t\t\t << endl;\n\t}\n#endif\n}", "idx": 146}
{"project": "bowtie2", "commit_id": "233_bowtie2_2.5.1_bt2_dp.cpp_reset.cpp", "target": 0, "func": "void reset() {\n\t\tif(ih_.is_open()) {\n\t\t\tih_.close();\n\t\t}\n\t}", "idx": 147}
{"project": "bowtie2", "commit_id": "234_bowtie2_2.5.1_bt2_dp.cpp_init.cpp", "target": 0, "func": "void init(const string& fn) {\n\t\treset();\n\t\tfn_ = fn;\n\t\tih_.open(fn_.c_str());\n\t\tih_.sync_with_stdio(false);\n\t}", "idx": 148}
{"project": "bowtie2", "commit_id": "235_bowtie2_2.5.1_bt2_idx.h_init.cpp", "target": 0, "func": "void init(\n\t\tTIndexOffU len,\n\t\tint32_t lineRate,\n\t\tint32_t offRate,\n\t\tint32_t ftabChars,\n\t\tbool color,\n\t\tbool entireReverse)\n\t\t{\n\t\t\t_color = color;\n\t\t\t_entireReverse = entireReverse;\n\t\t\t_len = len;\n\t\t\t_bwtLen = _len + 1;\n\t\t\t_sz = (len+3)/4;\n\t\t\t_bwtSz = (len/4 + 1);\n\t\t\t_lineRate = lineRate;\n\t\t\t_origOffRate = offRate;\n\t\t\t_offRate = offRate;\n\t\t\t_offMask = OFF_MASK << _offRate;\n\t\t\t_ftabChars = ftabChars;\n\t\t\t_eftabLen = _ftabChars*2;\n\t\t\t_eftabSz = _eftabLen*OFF_SIZE;\n\t\t\t_ftabLen = (1 << (_ftabChars*2))+1;\n\t\t\t_ftabSz = _ftabLen*OFF_SIZE;\n\t\t\t_offsLen = (_bwtLen + (1 << _offRate) - 1) >> _offRate;\n\t\t\t_offsSz = (uint64_t)_offsLen*OFF_SIZE;\n\t\t\t_lineSz = 1 << _lineRate;\n\t\t\t_sideSz = _lineSz * 1 /* lines per side */;\n\t\t\t_sideBwtSz = _sideSz - OFF_SIZE*4;\n\t\t\t_sideBwtLen = _sideBwtSz*4;\n\t\t\t_numSides = (_bwtSz+(_sideBwtSz)-1)/(_sideBwtSz);\n\t\t\t_numLines = _numSides * 1 /* lines per side */;\n\t\t\t_ebwtTotLen = _numSides * _sideSz;\n\t\t\t_ebwtTotSz = _ebwtTotLen;\n\t\t\tassert(repOk());\n\t\t}", "idx": 149}
{"project": "bowtie2", "commit_id": "236_bowtie2_2.5.1_bt2_idx.h_setOffRate.cpp", "target": 0, "func": "void setOffRate(int __offRate) {\n\t\t_offRate = __offRate;\n\t\t_offMask = OFF_MASK << _offRate;\n\t\t_offsLen = (_bwtLen + (1 << _offRate) - 1) >> _offRate;\n\t\t_offsSz = (uint64_t)_offsLen * OFF_SIZE;\n\t}", "idx": 150}
{"project": "bowtie2", "commit_id": "237_bowtie2_2.5.1_bt2_idx.h_fileSize.cpp", "target": 0, "func": "static inline int64_t fileSize(const char* name) {\n\tstd::ifstream f;\n\tf.open(name, std::ios_base::binary | std::ios_base::in);\n\tif (!f.good() || f.eof() || !f.is_open()) { return 0; }\n\tf.seekg(0, std::ios_base::beg);\n\tstd::ifstream::pos_type begin_pos = f.tellg();\n\tf.seekg(0, std::ios_base::end);\n\treturn static_cast<int64_t>(f.tellg() - begin_pos);\n}", "idx": 151}
{"project": "bowtie2", "commit_id": "238_bowtie2_2.5.1_bt2_idx.h_initFromTopBot.cpp", "target": 0, "func": "static void initFromTopBot(\n\t\tTIndexOffU top,\n\t\tTIndexOffU bot,\n\t\tconst EbwtParams& ep,\n\t\tconst uint8_t* ebwt,\n\t\tSideLocus& ltop,\n\t\tSideLocus& lbot,\n\t\tbool prefetch=true)\n\t\t{\n\t\t\tconst TIndexOffU sideBwtLen = ep._sideBwtLen;\n\t\t\tassert_gt(bot, top);\n\t\t\tltop.initFromRow(top, ep, ebwt, prefetch);\n\t\t\tTIndexOffU spread = bot - top;\n\t\t\t// Many cache misses on the following lines\n\t\t\tconst TIndexOffU charOffSum = ltop._charOff + spread;\n\t\t\tif(charOffSum < sideBwtLen) {\n\t\t\t\tconst uint32_t bcharOff = (uint32_t) charOffSum;\n\t\t\t\tlbot._charOff = bcharOff;\n\t\t\t\tlbot._sideNum = ltop._sideNum;\n\t\t\t\tlbot._sideByteOff = ltop._sideByteOff;\n\t\t\t\tlbot._by = bcharOff >> 2;\n\t\t\t\tassert_lt(lbot._by, (int)ep._sideBwtSz);\n\t\t\t\tlbot._bp = bcharOff & 3;\n\t\t\t\t// no need for any prefetch, same _sideByteOff\n\t\t\t} else {\n\t\t\t\tlbot.initFromRow(bot, ep, ebwt, prefetch);\n\t\t\t}\n\t\t}", "idx": 152}
{"project": "bowtie2", "commit_id": "239_bowtie2_2.5.1_bt2_idx.h_prefetchFromTopBot.cpp", "target": 0, "func": "static void prefetchFromTopBot(\n\t\tTIndexOffU top,\n\t\tTIndexOffU bot,\n\t\tconst EbwtParams& ep,\n\t\tconst uint8_t* ebwt)\n\t\t{\n\t\t\tprefetchFromRow(top, ep, ebwt);\n\t\t\t// not trying to be smart... prefetches are cheap\n\t\t\tprefetchFromRow(bot, ep, ebwt);\n\t\t}", "idx": 153}
{"project": "bowtie2", "commit_id": "23_bowtie2_2.5.1_aligner_metrics.h_push.cpp", "target": 0, "func": "void push(float x) {\n\t\tm_n++;\n\t\tm_tot += x;\n\t\t// See Knuth TAOCP vol 2, 3rd edition, page 232\n\t\tif (m_n == 1) {\n\t\t\tm_oldM = m_newM = x;\n\t\t\tm_oldS = 0.0;\n\t\t} else {\n\t\t\tm_newM = m_oldM + (x - m_oldM)/m_n;\n\t\t\tm_newS = m_oldS + (x - m_oldM)*(x - m_newM);\n\t\t\t// set up for next iteration\n\t\t\tm_oldM = m_newM;\n\t\t\tm_oldS = m_newS;\n\t\t}\n\t}", "idx": 154}
{"project": "bowtie2", "commit_id": "240_bowtie2_2.5.1_bt2_idx.h_initFromRow.cpp", "target": 0, "func": "void initFromRow(TIndexOffU row,\n\t\t\tconst EbwtParams& ep,\n\t\t\tconst uint8_t* ebwt,\n\t\t\tbool prefetch=true) {\n\t\tconst int32_t sideSz     = ep._sideSz;\n\t\t// Side length is hard-coded for now; this allows the compiler\n\t\t// to do clever things to accelerate / and %.\n\t\tconst TIndexOffU sideNum  = row / (48*OFF_SIZE);\n\t\tassert_lt(sideNum, ep._numSides);\n\t\tconst int32_t charOff     = row % (48*OFF_SIZE);\n\t\t_sideNum                  = sideNum;\n\t\t_charOff                  = charOff;\n\t\tconst TIndexOffU sByteOff = sideNum * sideSz;\n\t\tif (prefetch) {\n\t\t\t__builtin_prefetch(ebwt + sByteOff);\n\t\t\t__builtin_prefetch(ebwt + sByteOff + 64); //64 byte cache lines\n#if (OFF_SIZE>4)\n\t\t\t__builtin_prefetch(ebwt + sByteOff + 2*64);\n#endif\n                }\n\n\t\t_sideByteOff              = sByteOff;\n\t\tassert_leq(row, ep._len);\n\t\tassert_leq(_sideByteOff + sideSz, ep._ebwtTotSz);\n\t\t// Tons of cache misses on the next line\n\t\t_by = charOff >> 2; // byte within side\n\t\tassert_lt(_by, (int)ep._sideBwtSz);\n\t\t_bp = charOff & 3;  // bit-pair within byte\n\t}", "idx": 155}
{"project": "bowtie2", "commit_id": "241_bowtie2_2.5.1_bt2_idx.h_prefetchFromRow.cpp", "target": 0, "func": "static void prefetchFromRow(TIndexOffU row, const EbwtParams& ep, const uint8_t* ebwt) {\n\t\tconst int32_t sideSz         = ep._sideSz;\n\t\t// Side length is hard-coded for now; this allows the compiler\n\t\t// to do clever things to accelerate / and %.\n\t\tconst TIndexOffU sideNum     = row / (48*OFF_SIZE);\n\t\tconst TIndexOffU sideByteOff = sideNum * sideSz;\n\t\t__builtin_prefetch(ebwt + sideByteOff);\n\t\t__builtin_prefetch(ebwt + sideByteOff + 64); //64 byte cache lines\n#if (OFF_SIZE>4)\n\t\t__builtin_prefetch(ebwt + sideByteOff + 2*64);\n#endif\n\t}", "idx": 156}
{"project": "bowtie2", "commit_id": "242_bowtie2_2.5.1_bt2_idx.h_nextSide.cpp", "target": 0, "func": "void nextSide(const EbwtParams& ep) {\n\t\tassert(valid());\n\t\t_sideByteOff += ep.sideSz();\n\t\t_sideNum++;\n\t\t_by = _bp = _charOff = 0;\n\t\tassert(valid());\n\t}", "idx": 157}
{"project": "bowtie2", "commit_id": "243_bowtie2_2.5.1_bt2_idx.h_invalidate.cpp", "target": 0, "func": "Make this look like an invalid SideLocus\n\tvoid invalidate() {\n\t\t_bp = -1;\n\t}", "idx": 158}
{"project": "bowtie2", "commit_id": "244_bowtie2_2.5.1_bt2_idx.h_pop64.cpp", "target": 0, "func": "inline static int pop64(uint64_t x) {\n\t\treturn __builtin_popcountll(x);\n\t}", "idx": 159}
{"project": "bowtie2", "commit_id": "245_bowtie2_2.5.1_bt2_idx.h_countInU64.cpp", "target": 0, "func": "endif\ninline static int countInU64(int c, uint64_t dw) {\n\tuint64_t c0 = c_table[c];\n\tuint64_t x0 = dw ^ c0;\n\tuint64_t x1 = (x0 >> 1);\n\tuint64_t x2 = x1 & (0x5555555555555555);\n\tuint64_t x3 = x0 & x2;\n#ifdef POPCNT_CAPABILITY\n\tuint64_t tmp = Operation().pop64(x3);\n#else\n\tuint64_t tmp = pop64(x3);\n#endif\n\treturn (int) tmp;\n}", "idx": 160}
{"project": "bowtie2", "commit_id": "246_bowtie2_2.5.1_bt2_idx.h_isPacked.cpp", "target": 0, "func": "Return true iff the Ebwt is packed\n\tbool isPacked() { return packed_; }", "idx": 161}
{"project": "bowtie2", "commit_id": "247_bowtie2_2.5.1_bt2_idx.h_joinedLen.cpp", "target": 0, "func": "TIndexOffU joinedLen(EList<RefRecord>& szs) {\n\t\tTIndexOffU ret = 0;\n\t\tfor(unsigned int i = 0; i < szs.size(); i++) {\n\t\t\tret += szs[i].len;\n\t\t}\n\t\treturn ret;\n\t}", "idx": 162}
{"project": "bowtie2", "commit_id": "248_bowtie2_2.5.1_bt2_idx.h_loadIntoMemory.cpp", "target": 0, "func": "void loadIntoMemory(\n\t\tint color,\n\t\tint needEntireReverse,\n\t\tbool loadSASamp,\n\t\tbool loadFtab,\n\t\tbool loadRstarts,\n\t\tbool loadNames,\n\t\tbool verbose)\n\t\t{\n\t\t\treadIntoMemory(\n\t\t\t\tcolor,       // expect index to be colorspace?\n\t\t\t\tneedEntireReverse, // require reverse index to be concatenated reference reversed\n\t\t\t\tloadSASamp,  // load the SA sample portion?\n\t\t\t\tloadFtab,    // load the ftab (_ftab[] and _eftab[])?\n\t\t\t\tloadRstarts, // load the r-starts (_rstarts[])?\n\t\t\t\tfalse,       // stop after loading the header portion?\n\t\t\t\tNULL,        // params\n\t\t\t\tfalse,       // mmSweep\n\t\t\t\tloadNames,   // loadNames\n\t\t\t\tverbose);    // startVerbose\n\t\t}", "idx": 163}
{"project": "bowtie2", "commit_id": "249_bowtie2_2.5.1_bt2_idx.h_evictFromMemory.cpp", "target": 0, "func": "void evictFromMemory() {\n\t\tassert(isInMemory());\n\t\t_fchr.free();\n\t\t_ftab.free();\n\t\t_eftab.free();\n\t\t_rstarts.free();\n\t\t_offs.free(); // might not be under control of APtrWrap\n\t\t_ebwt.free(); // might not be under control of APtrWrap\n\t\t// Keep plen; it's small and the client may want to seq it\n\t\t// even when the others are evicted.\n\t\t//_plen  = NULL;\n\t\t_zEbwtByteOff = OFF_MASK;\n\t\t_zEbwtBpOff = -1;\n\t}", "idx": 164}
{"project": "bowtie2", "commit_id": "24_bowtie2_2.5.1_aligner_metrics.h_printSummary.cpp", "target": 0, "func": "void printSummary() {\n\t\tif(!first_) {\n\t\t\tfinishRead();\n\t\t}\n\t\tcout << \"AlignerMetrics:\" << endl;\n\t\tcout << \"  # Reads:             \" << reads_ << endl;\n\t\tfloat hopct = (reads_ > 0) ? (((float)homoReads_)/((float)reads_)) : (0.0f);\n\t\thopct *= 100.0f;\n\t\tcout << \"  % homo-polymeric:    \" << (hopct) << endl;\n\t\tfloat lopct = (reads_ > 0) ? ((float)lowEntReads_/(float)(reads_)) : (0.0f);\n\t\tlopct *= 100.0f;\n\t\tcout << \"  % low-entropy:       \" << (lopct) << endl;\n\t\tfloat unpct = (reads_ > 0) ? ((float)unalignedReads_/(float)(reads_)) : (0.0f);\n\t\tunpct *= 100.0f;\n\t\tcout << \"  % unaligned:         \" << (unpct) << endl;\n\t\tfloat npct = (reads_ > 0) ? ((float)threeOrMoreNReads_/(float)(reads_)) : (0.0f);\n\t\tnpct *= 100.0f;\n\t\tcout << \"  % with 3 or more Ns: \" << (npct) << endl;\n\t\tcout << endl;\n\t\tcout << \"  Total BWT ops:    avg: \" << bwtOpsPerRead_.mean() << \", stddev: \" << bwtOpsPerRead_.stddev() << endl;\n\t\tcout << \"  Total Backtracks: avg: \" << backtracksPerRead_.mean() << \", stddev: \" << backtracksPerRead_.stddev() << endl;\n\t\ttime_t elapsed = timer_.elapsed();\n\t\tcout << \"  BWT ops per second:    \" << (bwtOpsPerRead_.tot()/elapsed) << endl;\n\t\tcout << \"  Backtracks per second: \" << (backtracksPerRead_.tot()/elapsed) << endl;\n\t\tcout << endl;\n\t\tcout << \"  Homo-poly:\" << endl;\n\t\tcout << \"    BWT ops:    avg: \" << bwtOpsPerHomoRead_.mean() << \", stddev: \" << bwtOpsPerHomoRead_.stddev() << endl;\n\t\tcout << \"    Backtracks: avg: \" << backtracksPerHomoRead_.mean() << \", stddev: \" << backtracksPerHomoRead_.stddev() << endl;\n\t\tcout << \"  Low-entropy:\" << endl;\n\t\tcout << \"    BWT ops:    avg: \" << bwtOpsPerLoEntRead_.mean() << \", stddev: \" << bwtOpsPerLoEntRead_.stddev() << endl;\n\t\tcout << \"    Backtracks: avg: \" << backtracksPerLoEntRead_.mean() << \", stddev: \" << backtracksPerLoEntRead_.stddev() << endl;\n\t\tcout << \"  High-entropy:\" << endl;\n\t\tcout << \"    BWT ops:    avg: \" << bwtOpsPerHiEntRead_.mean() << \", stddev: \" << bwtOpsPerHiEntRead_.stddev() << endl;\n\t\tcout << \"    Backtracks: avg: \" << backtracksPerHiEntRead_.mean() << \", stddev: \" << backtracksPerHiEntRead_.stddev() << endl;\n\t\tcout << endl;\n\t\tcout << \"  Unaligned:\" << endl;\n\t\tcout << \"    BWT ops:    avg: \" << bwtOpsPerUnalignedRead_.mean() << \", stddev: \" << bwtOpsPerUnalignedRead_.stddev() << endl;\n\t\tcout << \"    Backtracks: avg: \" << backtracksPerUnalignedRead_.mean() << \", stddev: \" << backtracksPerUnalignedRead_.stddev() << endl;\n\t\tcout << \"  Aligned:\" << endl;\n\t\tcout << \"    BWT ops:    avg: \" << bwtOpsPerAlignedRead_.mean() << \", stddev: \" << bwtOpsPerAlignedRead_.stddev() << endl;\n\t\tcout << \"    Backtracks: avg: \" << backtracksPerAlignedRead_.mean() << \", stddev: \" << backtracksPerAlignedRead_.stddev() << endl;\n\t\tcout << endl;\n\t\tcout << \"  0 Ns:\" << endl;\n\t\tcout << \"    BWT ops:    avg: \" << bwtOpsPer0nRead_.mean() << \", stddev: \" << bwtOpsPer0nRead_.stddev() << endl;\n\t\tcout << \"    Backtracks: avg: \" << backtracksPer0nRead_.mean() << \", stddev: \" << backtracksPer0nRead_.stddev() << endl;\n\t\tcout << \"  1 N:\" << endl;\n\t\tcout << \"    BWT ops:    avg: \" << bwtOpsPer1nRead_.mean() << \", stddev: \" << bwtOpsPer1nRead_.stddev() << endl;\n\t\tcout << \"    Backtracks: avg: \" << backtracksPer1nRead_.mean() << \", stddev: \" << backtracksPer1nRead_.stddev() << endl;\n\t\tcout << \"  2 Ns:\" << endl;\n\t\tcout << \"    BWT ops:    avg: \" << bwtOpsPer2nRead_.mean() << \", stddev: \" << bwtOpsPer2nRead_.stddev() << endl;\n\t\tcout << \"    Backtracks: avg: \" << backtracksPer2nRead_.mean() << \", stddev: \" << backtracksPer2nRead_.stddev() << endl;\n\t\tcout << \"  >2 Ns:\" << endl;\n\t\tcout << \"    BWT ops:    avg: \" << bwtOpsPer3orMoreNRead_.mean() << \", stddev: \" << bwtOpsPer3orMoreNRead_.stddev() << endl;\n\t\tcout << \"    Backtracks: avg: \" << backtracksPer3orMoreNRead_.mean() << \", stddev: \" << backtracksPer3orMoreNRead_.stddev() << endl;\n\t\tcout << endl;\n\t}", "idx": 165}
{"project": "bowtie2", "commit_id": "250_bowtie2_2.5.1_bt2_idx.h_ftabHi.cpp", "target": 0, "func": "static TIndexOffU ftabHi(\n\t\tconst TIndexOffU *ftab,\n\t\tconst TIndexOffU *eftab,\n\t\tTIndexOffU len,\n\t\tTIndexOffU ftabLen,\n\t\tTIndexOffU eftabLen,\n\t\tTIndexOffU i)\n\t\t{\n\t\t\tassert_lt(i, ftabLen);\n\t\t\tif(ftab[i] <= len) {\n\t\t\t\treturn ftab[i];\n\t\t\t} else {\n\t\t\t\tTIndexOffU efIdx = ftab[i] ^ OFF_MASK;\n\t\t\t\tassert_lt(efIdx*2+1, eftabLen);\n\t\t\t\treturn eftab[efIdx*2+1];\n\t\t\t}\n\t\t}", "idx": 166}
{"project": "bowtie2", "commit_id": "251_bowtie2_2.5.1_bt2_idx.h_ftabHiPrefetch.cpp", "target": 0, "func": "static void ftabHiPrefetch(\n\t\tconst TIndexOffU *ftab,\n\t\tTIndexOffU i)\n\t\t{\n\t\t\t__builtin_prefetch(&(ftab[i]));\n\t\t}", "idx": 167}
{"project": "bowtie2", "commit_id": "252_bowtie2_2.5.1_bt2_idx.h_ftabLo.cpp", "target": 0, "func": "static TIndexOffU ftabLo(\n\t\tconst TIndexOffU *ftab,\n\t\tconst TIndexOffU *eftab,\n\t\tTIndexOffU len,\n\t\tTIndexOffU ftabLen,\n\t\tTIndexOffU eftabLen,\n\t\tTIndexOffU i)\n\t\t{\n\t\t\tassert_lt(i, ftabLen);\n\t\t\tif(ftab[i] <= len) {\n\t\t\t\treturn ftab[i];\n\t\t\t} else {\n\t\t\t\tTIndexOffU efIdx = ftab[i] ^ OFF_MASK;\n\t\t\t\tassert_lt(efIdx*2+1, eftabLen);\n\t\t\t\treturn eftab[efIdx*2];\n\t\t\t}\n\t\t}", "idx": 168}
{"project": "bowtie2", "commit_id": "253_bowtie2_2.5.1_bt2_idx.h_ftabLoPrefetch.cpp", "target": 0, "func": "static void ftabLoPrefetch(\n\t\tconst TIndexOffU *ftab,\n\t\tTIndexOffU i)\n\t\t{\n\t\t\t__builtin_prefetch(&(ftab[i]));\n\t\t}", "idx": 169}
{"project": "bowtie2", "commit_id": "254_bowtie2_2.5.1_bt2_idx.h_postReadInit.cpp", "target": 0, "func": "void postReadInit(EbwtParams& eh) {\n\t\tTIndexOffU sideNum     = _zOff / eh._sideBwtLen;\n\t\tTIndexOffU sideCharOff = _zOff % eh._sideBwtLen;\n\t\tTIndexOffU sideByteOff = sideNum * eh._sideSz;\n\t\t_zEbwtByteOff = sideCharOff >> 2;\n\t\tassert_lt(_zEbwtByteOff, eh._sideBwtSz);\n\t\t_zEbwtBpOff = sideCharOff & 3;\n\t\tassert_lt(_zEbwtBpOff, 4);\n\t\t_zEbwtByteOff += sideByteOff;\n\t\tassert(repOk(eh)); // Ebwt should be fully initialized now\n\t}", "idx": 170}
{"project": "bowtie2", "commit_id": "255_bowtie2_2.5.1_bt2_idx.h_countInU64Ex.cpp", "target": 0, "func": "endif\n\tinline static void countInU64Ex(uint64_t dw, TIndexOffU* arrs) {\n\t\tuint64_t c0 = c_table[0];\n\t\tuint64_t x0 = dw ^ c0;\n\t\tuint64_t x1 = (x0 >> 1);\n\t\tuint64_t x2 = x1 & (0x5555555555555555llu);\n\t\tuint64_t x3 = x0 & x2;\n#ifdef POPCNT_CAPABILITY\n\t\tuint64_t tmp = Operation().pop64(x3);\n#else\n\t\tuint64_t tmp = pop64(x3);\n#endif\n\t\tarrs[0] += (uint32_t) tmp;\n\n\t\tc0 = c_table[1];\n\t\tx0 = dw ^ c0;\n\t\tx1 = (x0 >> 1);\n\t\tx2 = x1 & (0x5555555555555555llu);\n\t\tx3 = x0 & x2;\n#ifdef POPCNT_CAPABILITY\n\t\ttmp = Operation().pop64(x3);\n#else\n\t\ttmp = pop64(x3);\n#endif\n\t\tarrs[1] += (uint32_t) tmp;\n\n\t\tc0 = c_table[2];\n\t\tx0 = dw ^ c0;\n\t\tx1 = (x0 >> 1);\n\t\tx2 = x1 & (0x5555555555555555llu);\n\t\tx3 = x0 & x2;\n#ifdef POPCNT_CAPABILITY\n\t\ttmp = Operation().pop64(x3);\n#else\n\t\ttmp = pop64(x3);\n#endif\n\t\tarrs[2] += (uint32_t) tmp;\n\n\t\tc0 = c_table[3];\n\t\tx0 = dw ^ c0;\n\t\tx1 = (x0 >> 1);\n\t\tx2 = x1 & (0x5555555555555555llu);\n\t\tx3 = x0 & x2;\n#ifdef POPCNT_CAPABILITY\n\t\ttmp = Operation().pop64(x3);\n#else\n\t\ttmp = pop64(x3);\n#endif\n\t\tarrs[3] += (uint32_t) tmp;\n\t}", "idx": 171}
{"project": "bowtie2", "commit_id": "256_bowtie2_2.5.1_bt2_idx.h_is_read_err.cpp", "target": 0, "func": "inline bool is_read_err(int fdesc, ssize_t ret, size_t count){\n\tif (ret < 0) {\n\t\tstd::stringstream sstm;\n\t\tsstm << \"ERRNO: \" << errno << \" ERR Msg:\" << strerror(errno) << std::endl;\n\t\tgLastIOErrMsg = sstm.str();\n\t\treturn true;\n\t}\n\treturn false;\n}", "idx": 172}
{"project": "bowtie2", "commit_id": "257_bowtie2_2.5.1_bt2_idx.h_is_fread_err.cpp", "target": 0, "func": "inline bool is_fread_err(FILE* file_hd, size_t ret, size_t count){\n\tif (ferror(file_hd)) {\n\t\tgLastIOErrMsg = \"Error Reading File!\";\n\t\treturn true;\n\t}\n\treturn false;\n}", "idx": 173}
{"project": "bowtie2", "commit_id": "258_bowtie2_2.5.1_bt2_inspect.cpp_printUsage.cpp", "target": 0, "func": "static void printUsage(ostream& out) {\n\tout << \"Bowtie 2 version \" << string(BOWTIE2_VERSION).c_str() << \" by Ben Langmead (langmea@cs.jhu.edu, www.cs.jhu.edu/~langmea)\" << endl;\n\tout\n\t<< \"Usage: bowtie2-inspect [options]* <bt2_base>\" << endl\n\t<< \"  <bt2_base>         bt2 filename minus trailing .1.\" + gEbwt_ext + \"/.2.\" + gEbwt_ext << endl\n\t<< endl\n\t<< \"  By default, prints FASTA records of the indexed nucleotide sequences to\" << endl\n\t<< \"  standard out.  With -n, just prints names.  With -s, just prints a summary of\" << endl\n\t<< \"  the index parameters and sequences.\" << endl\n\t<< endl\n\t<< \"Options:\" << endl;\n\tif(wrapper == \"basic-0\") {\n\t\tout << \"  --large-index      force inspection of the 'large' index, even if a\" << endl\n\t\t    << \"                     'small' one is present.\" << endl\n\t\t    << \"  --debug            use the debug binary; slower, assertions enabled\" << endl\n\t\t    << \"  --sanitized        use sanitized binary; slower, uses ASan and/or UBSan\" << endl\n\t\t    << \"  --verbose          log the issued command\" << endl;\n\t}\n\tout << \"  -a/--across <int>  Number of characters across in FASTA output (default: 60)\" << endl\n\t    << \"  -n/--names         Print reference sequence names only\" << endl\n\t    << \"  -s/--summary       Print summary incl. ref names, lengths, index properties\" << endl\n\t    << \"  -o/--output        Save output to filename (default stdout)\" << endl\n\t    << \"  -v/--verbose       Verbose output (for debugging)\" << endl\n\t    << \"  -h/--help          print this and message quit\" << endl;\n\tif(wrapper.empty()) {\n\t\tcerr << endl\n\t\t     << \"*** Warning ***\" << endl\n\t\t     << \"'boowtie2-inspect' was run directly.  It is recommended \"\n\t\t     << \"to use the wrapper script instead.\"\n\t\t     << endl << endl;\n\t}\n}", "idx": 174}
{"project": "bowtie2", "commit_id": "259_bowtie2_2.5.1_bt2_inspect.cpp_parseInt.cpp", "target": 0, "func": "static int parseInt(int lower, const char *errmsg) {\n\tlong l;\n\tchar *endPtr= NULL;\n\tl = strtol(optarg, &endPtr, 10);\n\tif (endPtr != NULL) {\n\t\tif (l < lower) {\n\t\t\tcerr << errmsg << endl;\n\t\t\tprintUsage(cerr);\n\t\t\tthrow 1;\n\t\t}\n\t\treturn (int32_t)l;\n\t}\n\tcerr << errmsg << endl;\n\tprintUsage(cerr);\n\tthrow 1;\n\treturn -1;\n}", "idx": 175}
{"project": "bowtie2", "commit_id": "25_bowtie2_2.5.1_aligner_metrics.h_nextRead.cpp", "target": 0, "func": "void nextRead(const BTDnaString& read) {\n\t\tif(!first_) {\n\t\t\tfinishRead();\n\t\t}\n\t\tfirst_ = false;\n\t\t//float ent = entropyDna5(read);\n\t\tfloat ent = 0.0f;\n\t\tcurIsLowEntropy_ = (ent < 0.75f);\n\t\tcurIsHomoPoly_ = (ent < 0.001f);\n\t\tcurHadRanges_ = false;\n\t\tcurBwtOps_ = 0;\n\t\tcurBacktracks_ = 0;\n\t\t// Count Ns\n\t\tcurNumNs_ = 0;\n\t\tconst size_t len = read.length();\n\t\tfor(size_t i = 0; i < len; i++) {\n\t\t\tif((int)read[i] == 4) curNumNs_++;\n\t\t}\n\t}", "idx": 176}
{"project": "bowtie2", "commit_id": "260_bowtie2_2.5.1_bt2_inspect.cpp_parseOptions.cpp", "target": 0, "func": "static void parseOptions(int argc, char **argv) {\n\tint option_index = 0;\n\tint next_option;\n\tdo {\n\t\tnext_option = getopt_long(argc, argv, short_options, long_options, &option_index);\n\t\tswitch (next_option) {\n\t\t\tcase ARG_WRAPPER:\n\t\t\t\twrapper = optarg;\n\t\t\t\tbreak;\n\t\t\tcase ARG_USAGE:\n\t\t\tcase 'h':\n\t\t\t\tprintUsage(cout);\n\t\t\t\tthrow 0;\n\t\t\t\tbreak;\n\t\t\tcase 'v': verbose = true; break;\n\t\t\tcase ARG_VERSION: showVersion = true; break;\n\t\t\tcase 'e': refFromEbwt = true; break;\n\t\t\tcase 'n': names_only = true; break;\n\t\t\tcase 's': summarize_only = true; break;\n\t\t\tcase 'o': out_filename = optarg; break;\n\t\t\tcase 'a': across = parseInt(-1, \"-a/--across arg must be at least 1\"); break;\n\t\t\tcase -1: break; /* Done with options. */\n\t\t\tcase 0:\n\t\t\t\tif (long_options[option_index].flag != 0)\n\t\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintUsage(cerr);\n\t\t\t\tthrow 1;\n\t\t}\n\t} while(next_option != -1);\n}", "idx": 177}
{"project": "bowtie2", "commit_id": "261_bowtie2_2.5.1_bt2_inspect.cpp_print_fasta_record.cpp", "target": 0, "func": "static void print_fasta_record(\n\tostream& fout,\n\tconst string& defline,\n\tconst string& seq)\n{\n\tfout << \">\";\n\tfout << defline.c_str() << endl;\n\n\tif(across > 0) {\n\t\tsize_t i = 0;\n\t\twhile (i + across < seq.length())\n\t\t{\n\t\t\tfout << seq.substr(i, across).c_str() << endl;\n\t\t\ti += across;\n\t\t}\n\t\tif (i < seq.length())\n\t\t\tfout << seq.substr(i).c_str() << endl;\n\t} else {\n\t\tfout << seq.c_str() << endl;\n\t}\n}", "idx": 178}
{"project": "bowtie2", "commit_id": "262_bowtie2_2.5.1_bt2_inspect.cpp_print_ref_sequence.cpp", "target": 0, "func": "static void print_ref_sequence(\n\tostream& fout,\n\tBitPairReference& ref,\n\tconst string& name,\n\tsize_t refi,\n\tsize_t len)\n{\n\tbool newlines = across > 0;\n\tint myacross = across > 0 ? across : 60;\n\tsize_t incr = myacross * 1000;\n\tuint32_t *buf = new uint32_t[(incr + 128)/4];\n\tfout << \">\" << name.c_str() << \"\\n\";\n\tASSERT_ONLY(SStringExpandable<uint32_t> destU32);\n\tfor(size_t i = 0; i < len; i += incr) {\n\t\tsize_t amt = min(incr, len-i);\n\t\tassert_leq(amt, incr);\n\t\tint off = ref.getStretch(buf, refi, i, amt ASSERT_ONLY(, destU32));\n\t\tuint8_t *cb = ((uint8_t*)buf) + off;\n\t\tfor(size_t j = 0; j < amt; j++) {\n\t\t\tif(newlines && j > 0 && (j % myacross) == 0) fout << \"\\n\";\n\t\t\tassert_range(0, 4, (int)cb[j]);\n\t\t\tfout << \"ACGTN\"[(int)cb[j]];\n\t\t}\n\t\tfout << \"\\n\";\n\t}\n\tdelete [] buf;\n}", "idx": 179}
{"project": "bowtie2", "commit_id": "263_bowtie2_2.5.1_bt2_inspect.cpp_print_ref_sequences.cpp", "target": 0, "func": "static void print_ref_sequences(\n\tostream& fout,\n\tbool color,\n\tconst EList<string>& refnames,\n\tconst TIndexOffU* plen,\n\tconst string& adjustedEbwtFileBase)\n{\n\tBitPairReference ref(\n\t\tadjustedEbwtFileBase, // input basename\n\t\tcolor,                // true -> expect colorspace reference\n\t\tfalse,                // sanity-check reference\n\t\tNULL,                 // infiles\n\t\tNULL,                 // originals\n\t\tfalse,                // infiles are sequences\n\t\tfalse,                // memory-map\n\t\tfalse,                // use shared memory\n\t\tfalse,                // sweep mm-mapped ref\n\t\tverbose,              // be talkative\n\t\tverbose);             // be talkative at startup\n\tassert_eq(ref.numRefs(), refnames.size());\n\tfor(size_t i = 0; i < ref.numRefs(); i++) {\n\t\tprint_ref_sequence(\n\t\t\tfout,\n\t\t\tref,\n\t\t\trefnames[i],\n\t\t\ti,\n\t\t\tplen[i] + (color ? 1 : 0));\n\t}\n}", "idx": 180}
{"project": "bowtie2", "commit_id": "264_bowtie2_2.5.1_bt2_inspect.cpp_print_index_sequence_names.cpp", "target": 0, "func": "static void print_index_sequence_names(const string& fname, ostream& fout)\n{\n\tEList<string> p_refnames;\n\treadEbwtRefnames(fname, p_refnames);\n\tfor(size_t i = 0; i < p_refnames.size(); i++) {\n\t\tcout << p_refnames[i].c_str() << endl;\n\t}\n}", "idx": 181}
{"project": "bowtie2", "commit_id": "265_bowtie2_2.5.1_bt2_inspect.cpp_print_index_summary.cpp", "target": 0, "func": "static void print_index_summary(\n\tconst string& fname,\n\tostream& fout)\n{\n\tint32_t flags = Ebwt::readFlags(fname);\n\tint32_t flagsr = Ebwt::readFlags(fname + \".rev\");\n\tbool color = readEbwtColor(fname);\n\tbool entireReverse = readEntireReverse(fname + \".rev\");\n\tEbwt ebwt(\n\t\tfname,\n\t\tcolor,                // index is colorspace\n\t\t-1,                   // don't require entire reverse\n\t\ttrue,                 // index is for the forward direction\n\t\t-1,                   // offrate (-1 = index default)\n\t\t0,                    // offrate-plus (0 = index default)\n\t\tfalse,                // use memory-mapped IO\n\t\tfalse,                // use shared memory\n\t\tfalse,                // sweep memory-mapped memory\n\t\ttrue,                 // load names?\n\t\tfalse,                // load SA sample?\n\t\tfalse,                // load ftab?\n\t\tfalse,                // load rstarts?\n\t\tverbose,              // be talkative?\n\t\tverbose,              // be talkative at startup?\n\t\tfalse,                // pass up memory exceptions?\n\t\tfalse);               // sanity check?\n\tEList<string> p_refnames;\n\treadEbwtRefnames(fname, p_refnames);\n\tcout << \"Flags\" << '\\t' << (-flags) << endl;\n\tcout << \"Reverse flags\" << '\\t' << (-flagsr) << endl;\n\tcout << \"2.0-compatible\" << '\\t' << (entireReverse ? \"1\" : \"0\") << endl;\n\tcout << \"SA-Sample\" << \"\\t1 in \" << (1 << ebwt.eh().offRate()) << endl;\n\tcout << \"FTab-Chars\" << '\\t' << ebwt.eh().ftabChars() << endl;\n\tassert_eq(ebwt.nPat(), p_refnames.size());\n\tfor(size_t i = 0; i < p_refnames.size(); i++) {\n\t\tcout << \"Sequence-\" << (i+1)\n\t\t     << '\\t' << p_refnames[i].c_str()\n\t\t     << '\\t' << (ebwt.plen()[i] + (color ? 1 : 0))\n\t\t     << endl;\n\t}\n}", "idx": 182}
{"project": "bowtie2", "commit_id": "266_bowtie2_2.5.1_bt2_inspect.cpp_driver.cpp", "target": 0, "func": "static void driver(\n\tconst string& ebwtFileBase,\n\tconst string& query)\n{\n\tostream *fout = out_filename == \"\" ? &cout : new ofstream(out_filename);\n\tif (!fout->good()) {\n\t\tcerr << \"Unable to open \" << out_filename << \" for writing.\" << endl;\n\t\texit(1);\n\t}\n\tstring adjustedEbwtFileBase = adjustEbwtBase(argv0, ebwtFileBase, verbose);\n\tif (names_only) {\n\t\tprint_index_sequence_names(adjustedEbwtFileBase, *fout);\n\t} else if(summarize_only) {\n\t\tprint_index_summary(adjustedEbwtFileBase, *fout);\n\t} else {\n\t\t// Initialize Ebwt object\n\t\tbool color = readEbwtColor(adjustedEbwtFileBase);\n\t\tEbwt ebwt(\n\t\t\tadjustedEbwtFileBase,\n\t\t\tcolor,                // index is colorspace\n\t\t\t-1,                   // don't care about entire-reverse\n\t\t\ttrue,                 // index is for the forward direction\n\t\t\t-1,                   // offrate (-1 = index default)\n\t\t\t0,                    // offrate-plus (0 = index default)\n\t\t\tfalse,                // use memory-mapped IO\n\t\t\tfalse,                // use shared memory\n\t\t\tfalse,                // sweep memory-mapped memory\n\t\t\ttrue,                 // load names?\n\t\t\ttrue,                 // load SA sample?\n\t\t\ttrue,                 // load ftab?\n\t\t\ttrue,                 // load rstarts?\n\t\t\tverbose,              // be talkative?\n\t\t\tverbose,              // be talkative at startup?\n\t\t\tfalse,                // pass up memory exceptions?\n\t\t\tfalse);               // sanity check?\n\t\t// Load whole index into memory\n\t\tif(refFromEbwt) {\n\t\t\tebwt.loadIntoMemory(\n\t\t\t\t-1,     // color\n\t\t\t\t-1,     // need entire reverse\n\t\t\t\ttrue,   // load SA sample\n\t\t\t\ttrue,   // load ftab\n\t\t\t\ttrue,   // load rstarts\n\t\t\t\ttrue,   // load names\n\t\t\t\tfalse); // verbose\n\t\t\tprint_index_sequences<SString<char> >(cout, ebwt);\n\t\t} else {\n\t\t\tEList<string> refnames;\n\t\t\treadEbwtRefnames(adjustedEbwtFileBase, refnames);\n\t\t\tprint_ref_sequences(\n\t\t\t\t*fout,\n\t\t\t\treadEbwtColor(ebwtFileBase),\n\t\t\t\trefnames,\n\t\t\t\tebwt.plen(),\n\t\t\t\tadjustedEbwtFileBase);\n\t\t}\n\t\t// Evict any loaded indexes from memory\n\t\tif(ebwt.isInMemory()) {\n\t\t\tebwt.evictFromMemory();\n\t\t}\n\t\tif (fout != &cout) {\n\t\t\t((ofstream *)fout)->close();\n\t\t\tdelete fout;\n\t\t}\n\t}\n}", "idx": 183}
{"project": "bowtie2", "commit_id": "267_bowtie2_2.5.1_bt2_io.cpp_readEbwtRefnames.cpp", "target": 0, "func": "void\nreadEbwtRefnames(const string& instr, EList<string>& refnames) {\n    FILE* fin;\n\t// Initialize our primary and secondary input-stream fields\n    fin = fopen((instr + \".1.\" + gEbwt_ext).c_str(),\"rb\");\n\tif(fin == NULL) {\n\t\tthrow EbwtFileOpenException(\"Cannot open file \" + instr);\n\t}\n\tassert_eq(ftello(fin), 0);\n\treadEbwtRefnames(fin, refnames);\n    fclose(fin);\n}", "idx": 184}
{"project": "bowtie2", "commit_id": "268_bowtie2_2.5.1_bt2_io.cpp_readEbwtColor.cpp", "target": 0, "func": "bool\nreadEbwtColor(const string& instr) {\n\tint32_t flags = Ebwt::readFlags(instr);\n\tif(flags < 0 && (((-flags) & EBWT_COLOR) != 0)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "idx": 185}
{"project": "bowtie2", "commit_id": "269_bowtie2_2.5.1_bt2_io.cpp_readEntireReverse.cpp", "target": 0, "func": "bool\nreadEntireReverse(const string& instr) {\n\tint32_t flags = Ebwt::readFlags(instr);\n\tif(flags < 0 && (((-flags) & EBWT_ENTIRE_REV) != 0)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "idx": 186}
{"project": "bowtie2", "commit_id": "26_bowtie2_2.5.1_aligner_metrics.h_setReadHasRange.cpp", "target": 0, "func": "void setReadHasRange() {\n\t\tcurHadRanges_ = true;\n\t}", "idx": 187}
{"project": "bowtie2", "commit_id": "270_bowtie2_2.5.1_bt2_locks.h_pause.cpp", "target": 0, "func": "inline void pause() {\n\t\tif (count <= LOOPS_BEFORE_YIELD) {\n\t\t\tfor (int32_t i = 0; i < count; i++) {\n#ifdef __aarch64__\n\t\t\t\t__asm__ __volatile__(\"yield\" ::: \"memory\");\n#elif __ppc__\n\t\t\t\t__asm__ __volatile__(\"or 27,27,27\" ::: \"memory\");\n#elif __x86_64__\n\t\t\t\t__asm__ __volatile__(\"pause;\");\n#else\n\t\t\t\t// do nothing\n#endif\n\t\t\t}\n\t\t\tcount *= 2;\n\t\t} else {\n\t\t\tsched_yield();\n\t\t}\n\t}", "idx": 188}
{"project": "bowtie2", "commit_id": "271_bowtie2_2.5.1_bt2_locks.h_spin_while_eq.cpp", "target": 0, "func": "void spin_while_eq(const volatile std::atomic_bool& value, const volatile bool expected) {\n\t \tcpu_backoff backoff;\n\t \twhile (value.load(std::memory_order_acquire) == expected)\n\t \t\tbackoff.pause();\n\t}", "idx": 189}
{"project": "bowtie2", "commit_id": "272_bowtie2_2.5.1_bt2_search.cpp_set_format.cpp", "target": 0, "func": "static void set_format(int &current_format, file_format format) {\n\tif (current_format == UNKNOWN)\n\t\tcurrent_format = format;\n\telse {\n\t\tstd::cerr << file_format_names[current_format] << \" and \"\n\t\t\t  << file_format_names[format] << \" formats are \"\n\t\t\t  << \"mutually exclusive.\" << std::endl;\n\t\texit(1);\n\t}\n}", "idx": 190}
{"project": "bowtie2", "commit_id": "273_bowtie2_2.5.1_bt2_search.cpp_resetOptions.cpp", "target": 0, "func": "static void resetOptions() {\n\tmates1.clear();\n\tmates2.clear();\n\tmates12.clear();\n\tadjIdxBase\t    = \"\";\n\tgVerbose            = 0;\n\tstartVerbose\t    = 0;\n\tgQuiet\t\t    = false;\n\tsanityCheck\t    = 0;\t// enable expensive sanity checks\n\tformat\t\t    = UNKNOWN;\t// default read format is FASTQ\n\tinterleaved\t    = false;\t// reads are not interleaved by default\n\torigString\t    = \"\";\t// reference text, or filename(s)\n\tseed\t\t    = 0;\t// srandom() seed\n\ttiming\t\t    = 0;\t// whether to report basic timing data\n\tmetricsIval\t    = 1;\t// interval between alignment metrics messages (0 = no messages)\n\tmetricsFile         = \"\";\t// output file to put alignment metrics in\n\tmetricsStderr       = false;\t// print metrics to stderr (in addition to --metrics-file if it's specified\n\tmetricsPerRead      = false;\t// report a metrics tuple for every read?\n\tallHits\t\t    = false;\t// for multihits, report just one\n\tshowVersion\t    = false;\t// just print version and quit?\n\tipause\t\t    = 0;\t// pause before maching?\n\tqUpto               = 0xffffffffffffffff; // max # of queries to read\n\tgTrim5\t\t    = 0;\t// amount to trim from 5' end\n\tgTrim3\t\t    = 0;\t// amount to trim from 3' end\n\ttrimTo\t\t    = pair<short, size_t>(5, 0);\t// default: don't do any trimming\n\toffRate\t\t    = -1;\t// keep default offRate\n\tsolexaQuals\t    = false;\t// quality strings are solexa quals, not phred, and subtract 64 (not 33)\n\tphred64Quals\t    = false;\t// quality chars are phred, but must subtract 64 (not 33)\n\tintegerQuals\t    = false;\t// quality strings are space-separated strings of integers, not ASCII\n\tnthreads\t    = 1;\t// number of pthreads operating concurrently\n\tthread_ceiling\t    = 0;\t// max # threads user asked for\n\tthread_stealing_dir = \"\";\t// keep track of pids in this directory\n\tthread_stealing\t    = false;\t// true iff thread stealing is in use\n\tFNAME_SIZE\t    = 4096;\n\toutType\t\t    = OUTPUT_SAM;\t// style of output\n\tnoRefNames\t    = false;\t// true -> print reference indexes; not names\n\tkhits\t\t    = 1;\t// number of hits per read; >1 is much slower\n\tmhits\t\t    = 50;\t// stop after finding this many alignments+1\n\tpartitionSz\t    = 0;\t// output a partitioning key in first field\n\treadsPerBatch\t    = 16;\t// # reads to read from input file at once\n\tfileParallel\t    = false;\t// separate threads read separate input files in parallel\n\tuseShmem\t    = false;\t// use shared memory to hold the index\n\tuseMm\t\t    = false;\t// use memory-mapped files to hold the index\n\tmmSweep\t\t    = false;\t// sweep through memory-mapped files immediately after mapping\n\tgMinInsert\t    = 0;\t// minimum insert size\n\tgMaxInsert\t    = 500;\t// maximum insert size\n\tgMate1fw\t    = true;\t// -1 mate aligns in fw orientation on fw strand\n\tgMate2fw\t    = false;\t// -2 mate aligns in rc orientation on fw strand\n\tgFlippedMatesOK     = false;\t// allow mates to be in wrong order\n\tgDovetailMatesOK    = false;\t// allow one mate to extend off the end of the other\n\tgContainMatesOK     = true;\t// allow one mate to contain the other in PE alignment\n\tgOlapMatesOK        = true;\t// allow mates to overlap in PE alignment\n\tgExpandToFrag       = true;\t// incr max frag length to =larger mate len if necessary\n\tgReportDiscordant   = true;\t// find and report discordant paired-end alignments\n\tgReportMixed        = true;\t// find and report unpaired alignments for paired reads\n\n\tcacheLimit\t    = 5;\t// ranges w/ size > limit will be cached\n\tcacheSize\t    = 0;\t// # words per range cache\n\tskipReads\t    = 0;\t// # reads/read pairs to skip\n\tgNofw\t\t    = false;\t// don't align fw orientation of read\n\tgNorc\t\t    = false;\t// don't align rc orientation of read\n\tfastaContLen\t    = 0;\n\tfastaContFreq\t    = 0;\n\thadoopOut\t    = false;\t// print Hadoop status and summary messages\n\tfullRef\t\t    = false;\t// print entire reference name instead of just up to 1st space\n\tsamTruncQname       = true;\t// whether to truncate QNAME to 255 chars\n\tsamAppendComment    = false;\t// append FASTA/Q comment to SAM record\n\tsamOmitSecSeqQual   = false;\t// omit SEQ/QUAL for 2ndary alignments?\n\tsamNoUnal           = false;\t// omit SAM records for unaligned reads\n\tsamNoHead\t    = false;\t// don't print any header lines in SAM output\n\tsamNoSQ\t\t    = false;\t// don't print @SQ header lines\n\tsam_print_as        = true;\n\tsam_print_xs        = true;\n\tsam_print_xss       = false;\t// Xs:i and Ys:i\n\tsam_print_yn        = false;\t// YN:i and Yn:i\n\tsam_print_xn        = true;\n\tsam_print_x0        = true;\n\tsam_print_x1        = true;\n\tsam_print_xm        = true;\n\tsam_print_xo        = true;\n\tsam_print_xg        = true;\n\tsam_print_nm        = true;\n\tsam_print_md        = true;\n\tsam_print_yf        = true;\n\tsam_print_yi        = false;\n\tsam_print_ym        = false;\n\tsam_print_yp        = false;\n\tsam_print_yt        = true;\n\tsam_print_ys        = true;\n\tsam_print_zs        = false;\n\tsam_print_xr        = false;\n\tsam_print_xt        = false;\n\tsam_print_xd        = false;\n\tsam_print_xu        = false;\n\tsam_print_yl        = false;\n\tsam_print_ye        = false;\n\tsam_print_yu        = false;\n\tsam_print_xp        = false;\n\tsam_print_yr        = false;\n\tsam_print_zb        = false;\n\tsam_print_zr        = false;\n\tsam_print_zf        = false;\n\tsam_print_zm        = false;\n\tsam_print_zi        = false;\n\tsam_print_zp        = false;\n\tsam_print_zu        = false;\n\tsam_print_zt        = false;\n\tpreserve_tags       = false;\n\talign_paired_reads  = false;\n\tbwaSwLike           = false;\n\tgSeedLenIsSet\t    = false;\n\tbwaSwLikeC          = 5.5f;\n\tbwaSwLikeT          = 20.0f;\n\tgDefaultSeedLen\t    = DEFAULT_SEEDLEN;\n\tqcFilter            = false;\t// don't believe upstream qc by default\n\trgid\t\t    = \"\";\t// SAM outputs for @RG header line\n\trgs\t\t    = \"\";\t// SAM outputs for @RG header line\n\trgs_optflag\t    = \"\";\t// SAM optional flag to add corresponding to @RG ID\n\tmsample\t\t    = true;\n\tgGapBarrier\t    = 4;\t// disallow gaps within this many chars of either end of alignment\n\tqualities.clear();\n\tqualities1.clear();\n\tqualities2.clear();\n\tpolstr.clear();\n\tmsNoCache\t    = true;\t// true -> disable local cache\n\tbonusMatchType\t    = DEFAULT_MATCH_BONUS_TYPE;\n\tbonusMatch\t    = DEFAULT_MATCH_BONUS;\n\tpenMmcType\t    = DEFAULT_MM_PENALTY_TYPE;\n\tpenMmcMax\t    = DEFAULT_MM_PENALTY_MAX;\n\tpenMmcMin\t    = DEFAULT_MM_PENALTY_MIN;\n\tpenNType\t    = DEFAULT_N_PENALTY_TYPE;\n\tpenN\t\t    = DEFAULT_N_PENALTY;\n\tpenNCatPair\t    = DEFAULT_N_CAT_PAIR;\t// concatenate mates before N filtering?\n\tlocalAlign\t    = false;\t// do local alignment in DP steps\n\tnoisyHpolymer\t    = false;\n\tpenRdGapConst\t    = DEFAULT_READ_GAP_CONST;\n\tpenRfGapConst\t    = DEFAULT_REF_GAP_CONST;\n\tpenRdGapLinear\t    = DEFAULT_READ_GAP_LINEAR;\n\tpenRfGapLinear\t    = DEFAULT_REF_GAP_LINEAR;\n\tscoreMin.init  (SIMPLE_FUNC_LINEAR, DEFAULT_MIN_CONST,   DEFAULT_MIN_LINEAR);\n\tnCeil.init     (SIMPLE_FUNC_LINEAR, 0.0f, DMAX, 2.0f, 0.1f);\n\tmsIval.init    (SIMPLE_FUNC_LINEAR, 1.0f, DMAX, DEFAULT_IVAL_B, DEFAULT_IVAL_A);\n\tdescConsExp\t    = 2.0;\n\tdescPrioritizeRoots = false;\n\tdescLanding\t    = 20;\n\tdescentTotSz.init(SIMPLE_FUNC_LINEAR, 1024.0, DMAX, 0.0, 1024.0);\n\tdescentTotFmops.init(SIMPLE_FUNC_LINEAR, 100.0, DMAX, 0.0, 10.0);\n\tmultiseedMms\t    = DEFAULT_SEEDMMS;\n\tmultiseedLen\t    = gDefaultSeedLen;\n\tmultiseedOff\t    = 0;\n\tseedCacheLocalMB    = 32;\t// # MB to use for non-shared seed alignment cacheing\n\tseedCacheCurrentMB  = 20;\t// # MB to use for current-read seed hit cacheing\n\texactCacheCurrentMB = 20;\t// # MB to use for current-read seed hit cacheing\n\tmaxhalf\t\t    = 15;\t// max width on one side of DP table\n\tseedSumm\t    = false;\t// print summary information about seed hits, not alignments\n\tscUnMapped\t    = false;\t// consider soft clipped bases unmapped when calculating TLEN\n\txeq\t\t    = false;\t// use =/X instead of M in CIGAR string\n\tdoUngapped\t    = true;\t// do ungapped alignment\n\tmaxIters\t    = 400;\t// max iterations of extend loop\n\tmaxUg\t\t    = 300;\t// stop after this many ungap extends\n\tmaxDp\t\t    = 300;\t// stop after this many dp extends\n\tmaxItersIncr\t    = 20;\t// amt to add to maxIters for each -k > 1\n\tmaxEeStreak\t    = 15;\t// stop after this many end-to-end fails in a row\n\tmaxUgStreak\t    = 15;\t// stop after this many ungap fails in a row\n\tmaxDpStreak\t    = 15;\t// stop after this many dp fails in a row\n\tmaxStreakIncr\t    = 10;\t// amt to add to streak for each -k > 1\n\tmaxMateStreak\t    = 10;\t// in PE: abort seed range after N mate-find fails\n\tdoExtend\t    = true;\t// do seed extensions\n\tenable8\t\t    = true;\t// use 8-bit SSE where possible?\n\tcminlen\t\t    = 2000;\t// longer reads use checkpointing\n\tcpow2\t\t    = 4;\t// checkpoint interval log2\n\tdoTri\t\t    = false;\t// do triangular mini-fills?\n\tdefaultPreset\t    = \"sensitive%LOCAL%\";\t// default preset; applied immediately\n\textra_opts.clear();\n\textra_opts_cur\t    = 0;\n\tbt2index.clear();       // read Bowtie 2 index from files with this prefix\n\tignoreQuals\t    = false;\t// all mms incur same penalty, regardless of qual\n\twrapper.clear();        // type of wrapper script, so we can print correct usage\n\tqueries.clear();        // list of query files\n\toutfile.clear();        // write SAM output to this file\n\tmapqv\t\t    = 2;\t// MAPQ calculation version\n\ttighten\t\t    = 3;\t// -M tightening mode\n\tdoExactUpFront\t    = true;\t// do exact search up front if seeds seem good enough\n\tdo1mmUpFront\t    = true;\t// do 1mm search up front if seeds seem good enough\n\tseedBoostThresh\t    = 300;\t// if average non-zero position has more than this many elements\n\tnSeedRounds\t    = 2;\t// # rounds of seed searches to do for repetitive reads\n\tdo1mmMinLen\t    = 60;\t// length below which we disable 1mm search\n\treorder\t\t    = false;\t// reorder SAM records with -p > 1\n\tsampleFrac\t    = 1.1f;\t// align all reads\n\tarbitraryRandom\t    = false;\t// let pseudo-random seeds be a function of read properties\n\tbowtie2p5\t    = false;\n\tlogDps.clear();         // log seed-extend dynamic programming problems\n\tlogDpsOpp.clear();      // log mate-search dynamic programming problems\n#ifdef USE_SRA\n\tsra_accs.clear();\n#endif\n}", "idx": 191}
{"project": "bowtie2", "commit_id": "274_bowtie2_2.5.1_bt2_search.cpp_printUsage.cpp", "target": 0, "func": "static void printUsage(ostream& out) {\n\tout << \"Bowtie 2 version \" << string(BOWTIE2_VERSION).c_str() << \" by Ben Langmead (langmea@cs.jhu.edu, www.cs.jhu.edu/~langmea)\" << endl;\n\tstring tool_name = \"bowtie2-align\";\n\tif(wrapper == \"basic-0\") {\n\t\ttool_name = \"bowtie2\";\n\t}\n\tout << \"Usage: \" << endl\n#ifdef USE_SRA\n\t    << \"  \" << tool_name.c_str() << \" [options]* -x <bt2-idx> {-1 <m1> -2 <m2> | -U <r> | --interleaved <i> | --sra-acc <acc> | -b <bam>} [-S <sam>]\" << endl\n#else\n\t    << \"  \" << tool_name.c_str() << \" [options]* -x <bt2-idx> {-1 <m1> -2 <m2> | -U <r> | --interleaved <i> | -b <bam>} [-S <sam>]\" << endl\n#endif\n\t    << endl\n\t    <<     \"  <bt2-idx>  Index filename prefix (minus trailing .X.\" + gEbwt_ext + \").\" << endl\n\t    <<     \"             NOTE: Bowtie 1 and Bowtie 2 indexes are not compatible.\" << endl\n\t    <<     \"  <m1>       Files with #1 mates, paired with files in <m2>.\" << endl;\n\tif(wrapper == \"basic-0\") {\n\t\tout << \"             Could be gzip'ed (extension: .gz) or bzip2'ed (extension: .bz2).\" << endl;\n\t}\n\tout <<     \"  <m2>       Files with #2 mates, paired with files in <m1>.\" << endl;\n\tif(wrapper == \"basic-0\") {\n\t\tout << \"             Could be gzip'ed (extension: .gz) or bzip2'ed (extension: .bz2).\" << endl;\n\t}\n\tout <<     \"  <r>        Files with unpaired reads.\" << endl;\n\tif(wrapper == \"basic-0\") {\n\t\tout << \"             Could be gzip'ed (extension: .gz) or bzip2'ed (extension: .bz2).\" << endl;\n\t}\n\tout <<     \"  <i>        Files with interleaved paired-end FASTQ/FASTA reads\" << endl;\n\tif(wrapper == \"basic-0\") {\n\t\tout << \"             Could be gzip'ed (extension: .gz) or bzip2'ed (extension: .bz2).\" << endl;\n\t}\n#ifdef USE_SRA\n\tout <<     \"  <acc>      Files are SRA accessions. Accessions not found in local storage will\\n\"\n\t    <<     \"             be fetched from NCBI.\" << endl;\n#endif\n\tout <<     \"  <bam>      Files are unaligned BAM sorted by read name.\" << endl;\n\tout <<     \"  <sam>      File for SAM output (default: stdout)\" << endl\n\t    << endl\n\t    << \"  <m1>, <m2>, <r> can be comma-separated lists (no whitespace) and can be\" << endl\n\t    << \"  specified many times.  E.g. '-U file1.fq,file2.fq -U file3.fq'.\" << endl\n\t\t// Wrapper script should write <bam> line next\n\t    << endl\n\t    << \"Options (defaults in parentheses):\" << endl\n\t    << endl\n\t    << \" Input:\" << endl\n\t    << \"  -q                 query input files are FASTQ .fq/.fastq (default)\" << endl\n\t    << \"  --tab5             query input files are TAB5 .tab5\" << endl\n\t    << \"  --tab6             query input files are TAB6 .tab6\" << endl\n\t    << \"  --qseq             query input files are in Illumina's qseq format\" << endl\n\t    << \"  -f                 query input files are (multi-)FASTA .fa/.mfa\" << endl\n\t    << \"  -r                 query input files are raw one-sequence-per-line\" << endl\n\t    << \"  -F k:<int>,i:<int> query input files are continuous FASTA where reads\" << endl\n\t    << \"                     are substrings (k-mers) extracted from a FASTA file <s>\" << endl\n\t    << \"                     and aligned at offsets 1, 1+i, 1+2i ... end of reference\" << endl\n\t    << \"  -c                 <m1>, <m2>, <r> are sequences themselves, not files\" << endl\n\t    << \"  -s/--skip <int>    skip the first <int> reads/pairs in the input (none)\" << endl\n\t    << \"  -u/--upto <int>    stop after first <int> reads/pairs (no limit)\" << endl\n\t    << \"  -5/--trim5 <int>   trim <int> bases from 5'/left end of reads (0)\" << endl\n\t    << \"  -3/--trim3 <int>   trim <int> bases from 3'/right end of reads (0)\" << endl\n\t    << \"  --trim-to [3:|5:]<int> trim reads exceeding <int> bases from either 3' or 5' end\" << endl\n\t    << \"                     If the read end is not specified then it defaults to 3 (0)\" << endl\n\t    << \"  --phred33          qualities are Phred+33 (default)\" << endl\n\t    << \"  --phred64          qualities are Phred+64\" << endl\n\t    << \"  --int-quals        qualities encoded as space-delimited integers\" << endl\n\t    << endl\n\t    << \" Presets:                 Same as:\" << endl\n\t    << \"  For --end-to-end:\" << endl\n\t    << \"   --very-fast            -D 5 -R 1 -N 0 -L 22 -i S,0,2.50\" << endl\n\t    << \"   --fast                 -D 10 -R 2 -N 0 -L 22 -i S,0,2.50\" << endl\n\t    << \"   --sensitive            -D 15 -R 2 -N 0 -L 22 -i S,1,1.15 (default)\" << endl\n\t    << \"   --very-sensitive       -D 20 -R 3 -N 0 -L 20 -i S,1,0.50\" << endl\n\t    << endl\n\t    << \"  For --local:\" << endl\n\t    << \"   --very-fast-local      -D 5 -R 1 -N 0 -L 25 -i S,1,2.00\" << endl\n\t    << \"   --fast-local           -D 10 -R 2 -N 0 -L 22 -i S,1,1.75\" << endl\n\t    << \"   --sensitive-local      -D 15 -R 2 -N 0 -L 20 -i S,1,0.75 (default)\" << endl\n\t    << \"   --very-sensitive-local -D 20 -R 3 -N 0 -L 20 -i S,1,0.50\" << endl\n\t    << endl\n\t    << \" Alignment:\" << endl\n\t    << \"  -N <int>           max # mismatches in seed alignment; can be 0 or 1 (0)\" << endl\n\t    << \"  -L <int>           length of seed substrings; must be >3, <32 (22)\" << endl\n\t    << \"  -i <func>          interval between seed substrings w/r/t read len (S,1,1.15)\" << endl\n\t    << \"  --n-ceil <func>    func for max # non-A/C/G/Ts permitted in aln (L,0,0.15)\" << endl\n\t    << \"  --dpad <int>       include <int> extra ref chars on sides of DP table (15)\" << endl\n\t    << \"  --gbar <int>       disallow gaps within <int> nucs of read extremes (4)\" << endl\n\t    << \"  --ignore-quals     treat all quality values as 30 on Phred scale (off)\" << endl\n\t    << \"  --nofw             do not align forward (original) version of read (off)\" << endl\n\t    << \"  --norc             do not align reverse-complement version of read (off)\" << endl\n\t    << \"  --no-1mm-upfront   do not allow 1 mismatch alignments before attempting to\" << endl\n\t    << \"                     scan for the optimal seeded alignments\"\n\t    << endl\n\t    << \"  --end-to-end       entire read must align; no clipping (on)\" << endl\n\t    << \"   OR\" << endl\n\t    << \"  --local            local alignment; ends might be soft clipped (off)\" << endl\n\t    << endl\n\t    << \" Scoring:\" << endl\n\t    << \"  --ma <int>         match bonus (0 for --end-to-end, 2 for --local) \" << endl\n\t    << \"  --mp <int>         max penalty for mismatch; lower qual = lower penalty (6)\" << endl\n\t    << \"  --np <int>         penalty for non-A/C/G/Ts in read/ref (1)\" << endl\n\t    << \"  --rdg <int>,<int>  read gap open, extend penalties (5,3)\" << endl\n\t    << \"  --rfg <int>,<int>  reference gap open, extend penalties (5,3)\" << endl\n\t    << \"  --score-min <func> min acceptable alignment score w/r/t read length\" << endl\n\t    << \"                     (G,20,8 for local, L,-0.6,-0.6 for end-to-end)\" << endl\n\t    << endl\n\t    << \" Reporting:\" << endl\n\t    << \"  (default)          look for multiple alignments, report best, with MAPQ\" << endl\n\t    << \"   OR\" << endl\n\t    << \"  -k <int>           report up to <int> alns per read; MAPQ not meaningful\" << endl\n\t    << \"   OR\" << endl\n\t    << \"  -a/--all           report all alignments; very slow, MAPQ not meaningful\" << endl\n\t    << endl\n\t    << \" Effort:\" << endl\n\t    << \"  -D <int>           give up extending after <int> failed extends in a row (15)\" << endl\n\t    << \"  -R <int>           for reads w/ repetitive seeds, try <int> sets of seeds (2)\" << endl\n\t    << endl\n\t    << \" Paired-end:\" << endl\n\t    << \"  -I/--minins <int>  minimum fragment length (0)\" << endl\n\t    << \"  -X/--maxins <int>  maximum fragment length (500)\" << endl\n\t    << \"  --fr/--rf/--ff     -1, -2 mates align fw/rev, rev/fw, fw/fw (--fr)\" << endl\n\t    << \"  --no-mixed         suppress unpaired alignments for paired reads\" << endl\n\t    << \"  --no-discordant    suppress discordant alignments for paired reads\" << endl\n\t    << \"  --dovetail         concordant when mates extend past each other\" << endl\n\t    << \"  --no-contain       not concordant when one mate alignment contains other\" << endl\n\t    << \"  --no-overlap       not concordant when mates overlap at all\" << endl\n\t    << endl\n\t    << \" BAM:\" << endl\n\t    << \"  --align-paired-reads\" << endl\n\t    << \"                     Bowtie2 will, by default, attempt to align unpaired BAM reads.\" << endl\n\t    << \"                     Use this option to align paired-end reads instead.\" << endl\n\t    << \"  --preserve-tags    Preserve tags from the original BAM record by\" << endl\n\t    << \"                     appending them to the end of the corresponding SAM output.\" << endl\n\t    << endl\n\t    << \" Output:\" << endl;\n\t//if(wrapper == \"basic-0\") {\n\t//\tout << \"  --bam              output directly to BAM (by piping through 'samtools view')\" << endl;\n\t//}\n\tout << \"  -t/--time          print wall-clock time taken by search phases\" << endl;\n\tif(wrapper == \"basic-0\") {\n\t\tout << \"  --un <path>        write unpaired reads that didn't align to <path>\" << endl\n\t\t    << \"  --al <path>        write unpaired reads that aligned at least once to <path>\" << endl\n\t\t    << \"  --un-conc <path>   write pairs that didn't align concordantly to <path>\" << endl\n\t\t    << \"  --al-conc <path>   write pairs that aligned concordantly at least once to <path>\" << endl\n\t\t    << \"    (Note: for --un, --al, --un-conc, or --al-conc, add '-gz' to the option name, e.g.\" << endl\n\t\t    << \"    --un-gz <path>, to gzip compress output, or add '-bz2' to bzip2 compress output.)\" << endl;\n\t}\n\tout << \"  --quiet            print nothing to stderr except serious errors\" << endl\n\t\t//  << \"  --refidx           refer to ref. seqs by 0-based index rather than name\" << endl\n\t    << \"  --met-file <path>  send metrics to file at <path> (off)\" << endl\n\t    << \"  --met-stderr       send metrics to stderr (off)\" << endl\n\t    << \"  --met <int>        report internal counters & metrics every <int> secs (1)\" << endl\n\t\t// Following is supported in the wrapper instead\n\t    << \"  --no-unal          suppress SAM records for unaligned reads\" << endl\n\t    << \"  --no-head          suppress header lines, i.e. lines starting with @\" << endl\n\t    << \"  --no-sq            suppress @SQ header lines\" << endl\n\t    << \"  --rg-id <text>     set read group id, reflected in @RG line and RG:Z: opt field\" << endl\n\t    << \"  --rg <text>        add <text> (\\\"lab:value\\\") to @RG line of SAM header.\" << endl\n\t    << \"                     Note: @RG line only printed when --rg-id is set.\" << endl\n\t    << \"  --omit-sec-seq     put '*' in SEQ and QUAL fields for secondary alignments.\" << endl\n\t    << \"  --sam-no-qname-trunc\" << endl\n\t    << \"                     Suppress standard behavior of truncating readname at first whitespace \" << endl\n\t    << \"                     at the expense of generating non-standard SAM.\" << endl\n\t    << \"  --xeq              Use '='/'X', instead of 'M,' to specify matches/mismatches in SAM record.\" << endl\n\t    << \"  --soft-clipped-unmapped-tlen\" << endl\n\t    << \"                     Exclude soft-clipped bases when reporting TLEN\" << endl\n\t    << \"  --sam-append-comment\" << endl\n\t    << \"                     Append FASTA/FASTQ comment to SAM record\" << endl\n\t    << endl\n\t    << \" Performance:\" << endl\n\t\t//    << \"  -o/--offrate <int> override offrate of index; must be >= index's offrate\" << endl\n\t    << \"  -p/--threads <int> number of alignment threads to launch (1)\" << endl\n\t    << \"  --reorder          force SAM output order to match order of input reads\" << endl\n#ifdef BOWTIE_MM\n\t    << \"  --mm               use memory-mapped I/O for index; many 'bowtie's can share\" << endl\n#endif\n#ifdef BOWTIE_SHARED_MEM\n\t\t//<< \"  --shmem            use shared mem for index; many 'bowtie's can share\" << endl\n#endif\n\t    << endl\n\t    << \" Other:\" << endl\n\t    << \"  --qc-filter        filter out reads that are bad according to QSEQ filter\" << endl\n\t    << \"  --seed <int>       seed for random number generator (0)\" << endl\n\t    << \"  --non-deterministic\" << endl\n\t    << \"                     seed rand. gen. arbitrarily instead of using read attributes\" << endl\n\t\t//  << \"  --verbose          verbose output for debugging\" << endl\n\t    << \"  --version          print version information and quit\" << endl\n\t    << \"  -h/--help          print this usage message\" << endl;\n\tif(wrapper.empty()) {\n\t\tcerr << endl\n\t\t     << \"*** Warning ***\" << endl\n\t\t     << \"'bowtie2-align' was run directly.  It is recommended that you run the wrapper script 'bowtie2' instead.\" << endl\n\t\t     << endl;\n\t}\n}", "idx": 192}
{"project": "bowtie2", "commit_id": "275_bowtie2_2.5.1_bt2_search.cpp_parseInt.cpp", "target": 0, "func": "static int parseInt(int lower, const char *errmsg, const char *arg) {\n\treturn parseInt(lower, std::numeric_limits<int>::max(), errmsg, arg);\n}", "idx": 193}
{"project": "bowtie2", "commit_id": "276_bowtie2_2.5.1_bt2_search.cpp_parse.cpp", "target": 0, "func": "T parse(const char *s) {\n\tT tmp;\n\tstringstream ss(s);\n\tss >> tmp;\n\treturn tmp;\n}", "idx": 194}
{"project": "bowtie2", "commit_id": "277_bowtie2_2.5.1_bt2_search.cpp_parseTuple.cpp", "target": 0, "func": "void parseTuple(const char *str, char delim, EList<T>& ret) {\n\tstring s(str);\n\tEList<string> ss;\n\ttokenize(s, delim, ss);\n\tfor(size_t i = 0; i < ss.size(); i++) {\n\t\tret.push_back(parse<T>(ss[i].c_str()));\n\t}\n}", "idx": 195}
{"project": "bowtie2", "commit_id": "278_bowtie2_2.5.1_bt2_search.cpp_applyPreset.cpp", "target": 0, "func": "static string applyPreset(const string& sorig, Presets& presets) {\n\tstring s = sorig;\n\tsize_t found = s.find(\"%LOCAL%\");\n\tif(found != string::npos) {\n\t\ts.replace(found, strlen(\"%LOCAL%\"), localAlign ? \"-local\" : \"\");\n\t}\n\tif(gVerbose) {\n\t\tcerr << \"Applying preset: '\" << s.c_str() << \"' using preset menu '\"\n\t\t     << presets.name() << \"'\" << endl;\n\t}\n\tstring pol;\n\tpresets.apply(s, pol, extra_opts);\n\treturn pol;\n}", "idx": 196}
{"project": "bowtie2", "commit_id": "279_bowtie2_2.5.1_bt2_search.cpp_reset.cpp", "target": 0, "func": "void reset() {\n\t\tolm.reset();\n\t\tsdm.reset();\n\t\twlm.reset();\n\t\tswmSeed.reset();\n\t\tswmMate.reset();\n\t\trpm.reset();\n\t\tdpSse8Seed.reset();   // 8-bit SSE seed extensions\n\t\tdpSse8Mate.reset();   // 8-bit SSE mate finds\n\t\tdpSse16Seed.reset();  // 16-bit SSE seed extensions\n\t\tdpSse16Mate.reset();  // 16-bit SSE mate finds\n\t\tnbtfiltst = 0;\n\t\tnbtfiltsc = 0;\n\t\tnbtfiltdo = 0;\n\n\t\tolmu.reset();\n\t\tsdmu.reset();\n\t\twlmu.reset();\n\t\tswmuSeed.reset();\n\t\tswmuMate.reset();\n\t\trpmu.reset();\n\t\tdpSse8uSeed.reset();  // 8-bit SSE seed extensions\n\t\tdpSse8uMate.reset();  // 8-bit SSE mate finds\n\t\tdpSse16uSeed.reset(); // 16-bit SSE seed extensions\n\t\tdpSse16uMate.reset(); // 16-bit SSE mate finds\n\t\tnbtfiltst_u = 0;\n\t\tnbtfiltsc_u = 0;\n\t\tnbtfiltdo_u = 0;\n\t}", "idx": 197}
{"project": "bowtie2", "commit_id": "27_bowtie2_2.5.1_aligner_metrics.h_finishRead.cpp", "target": 0, "func": "void finishRead() {\n\t\treads_++;\n\t\tif(curIsHomoPoly_) homoReads_++;\n\t\telse if(curIsLowEntropy_) lowEntReads_++;\n\t\telse hiEntReads_++;\n\t\tif(curHadRanges_) alignedReads_++;\n\t\telse unalignedReads_++;\n\t\tbwtOpsPerRead_.push((float)curBwtOps_);\n\t\tbacktracksPerRead_.push((float)curBacktracks_);\n\t\t// Drill down by entropy\n\t\tif(curIsHomoPoly_) {\n\t\t\tbwtOpsPerHomoRead_.push((float)curBwtOps_);\n\t\t\tbacktracksPerHomoRead_.push((float)curBacktracks_);\n\t\t} else if(curIsLowEntropy_) {\n\t\t\tbwtOpsPerLoEntRead_.push((float)curBwtOps_);\n\t\t\tbacktracksPerLoEntRead_.push((float)curBacktracks_);\n\t\t} else {\n\t\t\tbwtOpsPerHiEntRead_.push((float)curBwtOps_);\n\t\t\tbacktracksPerHiEntRead_.push((float)curBacktracks_);\n\t\t}\n\t\t// Drill down by whether it aligned\n\t\tif(curHadRanges_) {\n\t\t\tbwtOpsPerAlignedRead_.push((float)curBwtOps_);\n\t\t\tbacktracksPerAlignedRead_.push((float)curBacktracks_);\n\t\t} else {\n\t\t\tbwtOpsPerUnalignedRead_.push((float)curBwtOps_);\n\t\t\tbacktracksPerUnalignedRead_.push((float)curBacktracks_);\n\t\t}\n\t\tif(curNumNs_ == 0) {\n\t\t\tlessThanThreeNRreads_++;\n\t\t\tbwtOpsPer0nRead_.push((float)curBwtOps_);\n\t\t\tbacktracksPer0nRead_.push((float)curBacktracks_);\n\t\t} else if(curNumNs_ == 1) {\n\t\t\tlessThanThreeNRreads_++;\n\t\t\tbwtOpsPer1nRead_.push((float)curBwtOps_);\n\t\t\tbacktracksPer1nRead_.push((float)curBacktracks_);\n\t\t} else if(curNumNs_ == 2) {\n\t\t\tlessThanThreeNRreads_++;\n\t\t\tbwtOpsPer2nRead_.push((float)curBwtOps_);\n\t\t\tbacktracksPer2nRead_.push((float)curBacktracks_);\n\t\t} else {\n\t\t\tthreeOrMoreNReads_++;\n\t\t\tbwtOpsPer3orMoreNRead_.push((float)curBwtOps_);\n\t\t\tbacktracksPer3orMoreNRead_.push((float)curBacktracks_);\n\t\t}\n\t}", "idx": 198}
{"project": "bowtie2", "commit_id": "280_bowtie2_2.5.1_bt2_search.cpp_merge.cpp", "target": 0, "func": "void merge(\n\t\tconst OuterLoopMetrics *ol,\n\t\tconst SeedSearchMetrics *sd,\n\t\tconst WalkMetrics *wl,\n\t\tconst SwMetrics *swSeed,\n\t\tconst SwMetrics *swMate,\n\t\tconst ReportingMetrics *rm,\n\t\tconst SSEMetrics *dpSse8Ex,\n\t\tconst SSEMetrics *dpSse8Ma,\n\t\tconst SSEMetrics *dpSse16Ex,\n\t\tconst SSEMetrics *dpSse16Ma,\n\t\tuint64_t nbtfiltst_,\n\t\tuint64_t nbtfiltsc_,\n\t\tuint64_t nbtfiltdo_)\n\t\t{\n\t\t\tThreadSafe ts(mutex_m);\n\t\t\tif(ol != NULL) {\n\t\t\t\tolmu.merge(*ol);\n\t\t\t}\n\t\t\tif(sd != NULL) {\n\t\t\t\tsdmu.merge(*sd);\n\t\t\t}\n\t\t\tif(wl != NULL) {\n\t\t\t\twlmu.merge(*wl);\n\t\t\t}\n\t\t\tif(swSeed != NULL) {\n\t\t\t\tswmuSeed.merge(*swSeed);\n\t\t\t}\n\t\t\tif(swMate != NULL) {\n\t\t\t\tswmuMate.merge(*swMate);\n\t\t\t}\n\t\t\tif(rm != NULL) {\n\t\t\t\trpmu.merge(*rm);\n\t\t\t}\n\t\t\tif(dpSse8Ex != NULL) {\n\t\t\t\tdpSse8uSeed.merge(*dpSse8Ex);\n\t\t\t}\n\t\t\tif(dpSse8Ma != NULL) {\n\t\t\t\tdpSse8uMate.merge(*dpSse8Ma);\n\t\t\t}\n\t\t\tif(dpSse16Ex != NULL) {\n\t\t\t\tdpSse16uSeed.merge(*dpSse16Ex);\n\t\t\t}\n\t\t\tif(dpSse16Ma != NULL) {\n\t\t\t\tdpSse16uMate.merge(*dpSse16Ma);\n\t\t\t}\n\t\t\tnbtfiltst_u += nbtfiltst_;\n\t\t\tnbtfiltsc_u += nbtfiltsc_;\n\t\t\tnbtfiltdo_u += nbtfiltdo_;\n\t\t}", "idx": 199}
{"project": "bowtie2", "commit_id": "281_bowtie2_2.5.1_bt2_search.cpp_mergeIncrementals.cpp", "target": 0, "func": "void mergeIncrementals() {\n\t\tolm.merge(olmu);\n\t\tsdm.merge(sdmu);\n\t\twlm.merge(wlmu);\n\t\tswmSeed.merge(swmuSeed);\n\t\tswmMate.merge(swmuMate);\n\t\tdpSse8Seed.merge(dpSse8uSeed);\n\t\tdpSse8Mate.merge(dpSse8uMate);\n\t\tdpSse16Seed.merge(dpSse16uSeed);\n\t\tdpSse16Mate.merge(dpSse16uMate);\n\t\tnbtfiltst_u += nbtfiltst;\n\t\tnbtfiltsc_u += nbtfiltsc;\n\t\tnbtfiltdo_u += nbtfiltdo;\n\n\t\tolmu.reset();\n\t\tsdmu.reset();\n\t\twlmu.reset();\n\t\tswmuSeed.reset();\n\t\tswmuMate.reset();\n\t\trpmu.reset();\n\t\tdpSse8uSeed.reset();\n\t\tdpSse8uMate.reset();\n\t\tdpSse16uSeed.reset();\n\t\tdpSse16uMate.reset();\n\t\tnbtfiltst_u = 0;\n\t\tnbtfiltsc_u = 0;\n\t\tnbtfiltdo_u = 0;\n\t}", "idx": 200}
{"project": "bowtie2", "commit_id": "282_bowtie2_2.5.1_bt2_search.cpp_printMmsSkipMsg.cpp", "target": 0, "func": "static inline void printMmsSkipMsg(\n\tconst PatternSourcePerThread& ps,\n\tbool paired,\n\tbool mate1,\n\tint seedmms)\n{\n\tostringstream os;\n\tif(paired) {\n\t\tos << \"Warning: skipping mate #\" << (mate1 ? '1' : '2')\n\t\t   << \" of read '\" << (mate1 ? ps.read_a().name : ps.read_b().name)\n\t\t   << \"' because length (\" << (mate1 ? ps.read_a().patFw.length() : ps.read_b().patFw.length())\n\t\t   << \") <= # seed mismatches (\" << seedmms << \")\" << endl;\n\t} else {\n\t\tos << \"Warning: skipping read '\" << (mate1 ? ps.read_a().name : ps.read_b().name)\n\t\t   << \"' because length (\" << (mate1 ? ps.read_a().patFw.length() : ps.read_b().patFw.length())\n\t\t   << \") <= # seed mismatches (\" << seedmms << \")\" << endl;\n\t}\n\tcerr << os.str().c_str();\n}", "idx": 201}
{"project": "bowtie2", "commit_id": "283_bowtie2_2.5.1_bt2_search.cpp_printLenSkipMsg.cpp", "target": 0, "func": "static inline void printLenSkipMsg(\n\tconst PatternSourcePerThread& ps,\n\tbool paired,\n\tbool mate1)\n{\n\tostringstream os;\n\tif(paired) {\n\t\tos << \"Warning: skipping mate #\" << (mate1 ? '1' : '2')\n\t\t   << \" of read '\" << (mate1 ? ps.read_a().name : ps.read_b().name)\n\t\t   << \"' because it was < 2 characters long\" << endl;\n\t} else {\n\t\tos << \"Warning: skipping read '\" << (mate1 ? ps.read_a().name : ps.read_b().name)\n\t\t   << \"' because it was < 2 characters long\" << endl;\n\t}\n\tcerr << os.str().c_str();\n}", "idx": 202}
{"project": "bowtie2", "commit_id": "284_bowtie2_2.5.1_bt2_search.cpp_printLocalScoreMsg.cpp", "target": 0, "func": "static inline void printLocalScoreMsg(\n\tconst PatternSourcePerThread& ps,\n\tbool paired,\n\tbool mate1)\n{\n\tostringstream os;\n\tif(paired) {\n\t\tos << \"Warning: minimum score function gave negative number in \"\n\t\t   << \"--local mode for mate #\" << (mate1 ? '1' : '2')\n\t\t   << \" of read '\" << (mate1 ? ps.read_a().name : ps.read_b().name)\n\t\t   << \"; setting to 0 instead\" << endl;\n\t} else {\n\t\tos << \"Warning: minimum score function gave negative number in \"\n\t\t   << \"--local mode for read '\" << (mate1 ? ps.read_a().name : ps.read_b().name)\n\t\t   << \"; setting to 0 instead\" << endl;\n\t}\n\tcerr << os.str().c_str();\n}", "idx": 203}
{"project": "bowtie2", "commit_id": "285_bowtie2_2.5.1_bt2_search.cpp_printEEScoreMsg.cpp", "target": 0, "func": "static inline void printEEScoreMsg(\n\tconst PatternSourcePerThread& ps,\n\tbool paired,\n\tbool mate1)\n{\n\tostringstream os;\n\tif(paired) {\n\t\tos << \"Warning: minimum score function gave positive number in \"\n\t\t   << \"--end-to-end mode for mate #\" << (mate1 ? '1' : '2')\n\t\t   << \" of read '\" << (mate1 ? ps.read_a().name : ps.read_b().name)\n\t\t   << \"; setting to 0 instead\" << endl;\n\t} else {\n\t\tos << \"Warning: minimum score function gave positive number in \"\n\t\t   << \"--end-to-end mode for read '\" << (mate1 ? ps.read_a().name : ps.read_b().name)\n\t\t   << \"; setting to 0 instead\" << endl;\n\t}\n\tcerr << os.str().c_str();\n}", "idx": 204}
{"project": "bowtie2", "commit_id": "286_bowtie2_2.5.1_bt2_search.cpp_MERGE_METRICS.cpp", "target": 0, "func": "define MERGE_METRICS(met) {\t\t\t\\\n\t\tmsink.mergeMetrics(rpm);\t\\\n\t\tmet.merge(\t\t\t\\\n\t\t\t&olm,\t\t\t\\\n\t\t\t&sdm,\t\t\t\\\n\t\t\t&wlm,\t\t\t\\\n\t\t\t&swmSeed,\t\t\\\n\t\t\t&swmMate,\t\t\\\n\t\t\t&rpm,\t\t\t\\\n\t\t\t&sseU8ExtendMet,\t\\\n\t\t\t&sseU8MateMet,\t\t\\\n\t\t\t&sseI16ExtendMet,\t\\\n\t\t\t&sseI16MateMet,\t\t\\\n\t\t\tnbtfiltst,\t\t\\\n\t\t\tnbtfiltsc,\t\t\\\n\t\t\tnbtfiltdo);\t\t\\\n\t\tolm.reset();\t\t\t\\\n\t\tsdm.reset();\t\t\t\\\n\t\twlm.reset();\t\t\t\\\n\t\tswmSeed.reset();\t\t\\\n\t\tswmMate.reset();\t\t\\\n\t\trpm.reset();\t\t\t\\\n\t\tsseU8ExtendMet.reset();\t\t\\\n\t\tsseU8MateMet.reset();\t\t\\\n\t\tsseI16ExtendMet.reset();\t\\\n\t\tsseI16MateMet.reset();\t\t\\\n\t}", "idx": 205}
{"project": "bowtie2", "commit_id": "287_bowtie2_2.5.1_bt2_search.cpp_MERGE_SW.cpp", "target": 0, "func": "define MERGE_SW(x) {\t\t\t\t\\\n\t\tx.merge(\t\t\t\\\n\t\t\tsseU8ExtendMet,\t\t\\\n\t\t\tsseU8MateMet,\t\t\\\n\t\t\tsseI16ExtendMet,\t\\\n\t\t\tsseI16MateMet,\t\t\\\n\t\t\tnbtfiltst,\t\t\\\n\t\t\tnbtfiltsc,\t\t\\\n\t\t\tnbtfiltdo);\t\t\\\n\t\tx.resetCounters();\t\t\\\n\t}", "idx": 206}
{"project": "bowtie2", "commit_id": "288_bowtie2_2.5.1_bt2_search.cpp_get_cpu_and_node.cpp", "target": 0, "func": "core\nvoid get_cpu_and_node(int& cpu, int& node) {\n\tunsigned long a,d,c;\n\t__asm__ volatile(\"rdtscp\" : \"=a\" (a), \"=d\" (d), \"=c\" (c));\n\tnode = (c & 0xFFF000)>>12;\n\tcpu = c & 0xFFF;\n}", "idx": 207}
{"project": "bowtie2", "commit_id": "289_bowtie2_2.5.1_bt2_search.cpp_errno_message.cpp", "target": 0, "func": "static void errno_message() {\n\tint errnum = errno;\n\tcerr << \"errno is \" << errnum << endl;\n\tperror(\"perror error: \");\n}", "idx": 208}
{"project": "bowtie2", "commit_id": "28_bowtie2_2.5.1_aligner_report.h_report.cpp", "target": 0, "func": "bool report(const AlignmentCacheIface& cache, const QVal& qv) {\n\t\treturn true; // don't retry\n\t}", "idx": 209}
{"project": "bowtie2", "commit_id": "290_bowtie2_2.5.1_bt2_search.cpp_del_pid.cpp", "target": 0, "func": "void del_pid(const char* dirname,int pid) {\n\tchar* fname = (char*)calloc(FNAME_SIZE, sizeof(char));\n\tif(fname == NULL) {\n\t\terrno_message();\n\t\tcerr << \"del_pid: could not allocate buffer\" << endl;\n\t\tthrow 1;\n\t}\n\tsnprintf(fname, FNAME_SIZE, \"%s/%d\", dirname, pid);\n\tif(unlink(fname) != 0) {\n\t\tif(errno != ENOENT) {\n\t\t\terrno_message();\n\t\t\tcerr << \"del_pid: could not delete PID file \" << fname << endl;\n\t\t\tfree(fname);\n\t\t\tthrow 1;\n\t\t} else {\n\t\t\t// Probably just a race between processes\n\t\t}\n\t}\n\tfree(fname);\n}", "idx": 210}
{"project": "bowtie2", "commit_id": "291_bowtie2_2.5.1_bt2_search.cpp_steal_threads.cpp", "target": 0, "func": "static void steal_threads(int pid, int orig_nthreads, EList<int>& tids, EList<T*>& threads)\n{\n\tint ncpu = thread_ceiling;\n\tif(thread_ceiling <= nthreads) {\n\t\treturn;\n\t}\n\tint num_pids = 0;\n\tint lowest_pid = read_dir(thread_stealing_dir.c_str(), &num_pids);\n\tif(lowest_pid != pid) {\n\t\treturn;\n\t}\n\tint in_use = ((num_pids-1) * orig_nthreads) + nthreads;\n\tif(in_use < ncpu) {\n\t\tnthreads++;\n\t\ttids.push_back(nthreads);\n\t\tthreads.push_back(new T(multiseedSearchWorker, (void*)&tids.back()));\n\t\tcerr << \"pid \" << pid << \" started new worker # \" << nthreads << endl;\n\t}\n}", "idx": 211}
{"project": "bowtie2", "commit_id": "292_bowtie2_2.5.1_bt2_search.cpp_thread_monitor.cpp", "target": 0, "func": "static void thread_monitor(int pid, int orig_threads, EList<int>& tids, EList<T*>& threads)\n{\n\tfor(int j = 0; j < 10; j++) {\n\t\tsleep(1);\n\t}\n\tint steal_ctr = 1;\n\twhile(thread_counter > 0) {\n\t\tsteal_threads(pid, orig_threads, tids, threads);\n\t\tsteal_ctr++;\n\t\tfor(int j = 0; j < 10; j++) {\n\t\t\tsleep(1);\n\t\t}\n\t}\n}", "idx": 212}
{"project": "bowtie2", "commit_id": "293_bowtie2_2.5.1_cpu_numa_info.cpp_get_cpu_and_node_.cpp", "target": 0, "func": "core\nvoid get_cpu_and_node_(int& cpu, int& node) {\n\tunsigned long a,d,c;\n\t__asm__ volatile(\"rdtscp\" : \"=a\" (a), \"=d\" (d), \"=c\" (c));\n\tnode = (c & 0xFFF000)>>12;\n\tcpu = c & 0xFFF;\n}", "idx": 213}
{"project": "bowtie2", "commit_id": "294_bowtie2_2.5.1_diff_sample.cpp_calcExhaustiveDC.cpp", "target": 0, "func": "Generated by calcExhaustiveDC()\n\t{1, 2, 3, 7, 21, 33, 37, 50, 0}", "idx": 214}
{"project": "bowtie2", "commit_id": "295_bowtie2_2.5.1_diff_sample.h_dcRepOk.cpp", "target": 0, "func": "static bool dcRepOk(T v, EList<T>& ds) {\n\t// diffs[] records all the differences observed\n\tAutoArray<bool> covered(v, EBWT_CAT);\n\tfor(T i = 1; i < v; i++) {\n\t\tcovered[i] = false;\n\t}\n\tfor(T di = T(); di < ds.size(); di++) {\n\t\tfor(T dj = di+1; dj < ds.size(); dj++) {\n\t\t\tassert_lt(ds[di], ds[dj]);\n\t\t\tT d1 = (ds[dj] - ds[di]);\n\t\t\tT d2 = (ds[di] + v - ds[dj]);\n\t\t\tassert_lt(d1, v);\n\t\t\tassert_lt(d2, v);\n\t\t\tcovered[d1] = true;\n\t\t\tcovered[d2] = true;\n\t\t}\n\t}\n\tbool ok = true;\n\tfor(T i = 1; i < v; i++) {\n\t\tif(covered[i] == false) {\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ok;\n}", "idx": 215}
{"project": "bowtie2", "commit_id": "296_bowtie2_2.5.1_diff_sample.h_increasing.cpp", "target": 0, "func": "static bool increasing(T* ts, size_t limit) {\n\tfor(size_t i = 0; i < limit-1; i++) {\n\t\tif(ts[i+1] <= ts[i]) return false;\n\t}\n\treturn true;\n}", "idx": 216}
{"project": "bowtie2", "commit_id": "297_bowtie2_2.5.1_diff_sample.h_hasDifference.cpp", "target": 0, "func": "static inline bool hasDifference(T *ds, T d, T v, T diff) {\n\t// diffs[] records all the differences observed\n\tfor(T di = T(); di < d; di++) {\n\t\tfor(T dj = di+1; dj < d; dj++) {\n\t\t\tassert_lt(ds[di], ds[dj]);\n\t\t\tT d1 = (ds[dj] - ds[di]);\n\t\t\tT d2 = (ds[di] + v - ds[dj]);\n\t\t\tassert_lt(d1, v);\n\t\t\tassert_lt(d2, v);\n\t\t\tif(d1 == diff || d2 == diff) return true;\n\t\t}\n\t}\n\treturn false;\n}", "idx": 217}
{"project": "bowtie2", "commit_id": "298_bowtie2_2.5.1_diff_sample.h_popCount.cpp", "target": 0, "func": "static unsigned int popCount(T i) {\n\tunsigned int cnt = 0;\n\tfor(size_t j = 0; j < sizeof(T)*8; j++) {\n\t\tif(i & 1) cnt++;\n\t\ti >>= 1;\n\t}\n\treturn cnt;\n}", "idx": 218}
{"project": "bowtie2", "commit_id": "299_bowtie2_2.5.1_diff_sample.h_myLog2.cpp", "target": 0, "func": "static unsigned int myLog2(T i) {\n\tassert_eq(1, popCount(i)); // must be power of 2\n\tfor(size_t j = 0; j < sizeof(T)*8; j++) {\n\t\tif(i & 1) return (int)j;\n\t\ti >>= 1;\n\t}\n\tassert(false);\n\treturn 0xffffffff;\n}", "idx": 219}
{"project": "bowtie2", "commit_id": "29_bowtie2_2.5.1_aligner_result.cpp_COPY_BUF.cpp", "target": 0, "func": "define COPY_BUF() { \\\n\tchar *bufc = buf; \\\n\twhile(*bufc != '\\0') { \\\n\t\t*occ = *bufc; \\\n\t\tocc++; \\\n\t\tbufc++; \\\n\t} \\\n}", "idx": 220}
{"project": "bowtie2", "commit_id": "2_bowtie2_2.5.1_aligner_bt.cpp_main.cpp", "target": 0, "func": "int main(int argc, char **argv) {\n\tsize_t off = 0;\n\tRandomSource rnd(77);\n\tBtBranchTracer tr;\n\tScoring sc = Scoring::base1();\n\tSwResult res;\n\ttr.init(\n\t\t\"ACGTACGT\", // in: read sequence\n\t\t\"IIIIIIII\", // in: quality sequence\n\t\t8,          // in: read sequence length\n\t\t\"ACGTACGT\", // in: reference sequence\n\t\t8,          // in: reference sequence length\n\t\t0,          // in: reference id\n\t\t0,          // in: reference offset\n\t\ttrue,       // in: orientation\n\t\tsc,         // in: scoring scheme\n\t\t0,          // in: N ceiling\n\t\t8,          // in: alignment score\n\t\t7,          // start in this row\n\t\t7,          // start in this column\n\t\trnd);       // random gen, to choose among equal paths\n\tsize_t nrej = 0;\n\ttr.nextAlignment(\n\t\tres,\n\t\toff,\n\t\tnrej,\n\t\trnd);\n}", "idx": 221}
{"project": "bowtie2", "commit_id": "300_bowtie2_2.5.1_diff_sample.h_simulateAllocs.cpp", "target": 0, "func": "static size_t simulateAllocs(const TStr& text, uint32_t v) {\n\t\tEList<uint32_t> ds(getDiffCover(v, false /*verbose*/, false /*sanity*/));\n\t\tsize_t len = text.length();\n\t\tsize_t sPrimeSz = (len / v) * ds.size();\n\t\t// sPrime, sPrimeOrder, _isaPrime all exist in memory at\n\t\t// once and that's the peak\n\t\tAutoArray<TIndexOffU> aa(sPrimeSz * 3 + (1024 * 1024 /*out of caution*/), EBWT_CAT);\n\t\treturn sPrimeSz * 4; // sPrime array\n\t}", "idx": 222}
{"project": "bowtie2", "commit_id": "301_bowtie2_2.5.1_diff_sample.h_print.cpp", "target": 0, "func": "void print(ostream& out) {\n\t\tfor(size_t i = 0; i < _text.length(); i++) {\n\t\t\tif(isCovered(i)) {\n\t\t\t\tout << rank(i);\n\t\t\t} else {\n\t\t\t\tout << \"-\";\n\t\t\t}\n\t\t\tif(i < _text.length()-1) {\n\t\t\t\tout << \",\";\n\t\t\t}\n\t\t}\n\t\tout << endl;\n\t}", "idx": 223}
{"project": "bowtie2", "commit_id": "302_bowtie2_2.5.1_diff_sample.h_suffixSameUpTo.cpp", "target": 0, "func": "static inline bool suffixSameUpTo(\n\tconst TStr& host,\n\tTIndexOffU suf1,\n\tTIndexOffU suf2,\n\tTIndexOffU v)\n{\n\tfor(TIndexOffU i = 0; i < v; i++) {\n\t\tbool endSuf1 = suf1+i >= host.length();\n\t\tbool endSuf2 = suf2+i >= host.length();\n\t\tif((endSuf1 && !endSuf2) || (!endSuf1 && endSuf2)) return false;\n\t\tif(endSuf1 && endSuf2) return true;\n\t\tif(host[suf1+i] != host[suf2+i]) return false;\n\t}\n\treturn true;\n}", "idx": 224}
{"project": "bowtie2", "commit_id": "303_bowtie2_2.5.1_dp_framer.cpp_main.cpp", "target": 0, "func": "int main(void) {\n\t\n\t///////////////////////////\n\t//\n\t// ANCHOR ON THE LEFT\n\t//\n\t///////////////////////////\n\n\t//    -------------\n\t//       o     o\n\t//        o     o\n\t//         o     o\n\t//          o     o\n\t//        <<<------->>>\n\t// 012345678901234567890\n\t// 0         1         2\n\ttestCaseFindMateAnchorLeft(\n\t\t\"FindMateAnchorLeft1\",\n\t\tfalse,            // trim to reference\n\t\t3,                // left offset of upper parallelogram extent\n\t\t15,               // right offset of upper parallelogram extent\n\t\t10,               // left offset of lower parallelogram extent\n\t\t16,               // right offset of lower parallelogram extent\n\t\t5,                // length of opposite mate\n\t\t30,               // length of reference sequence aligned to\n\t\t3,                // max # of read gaps permitted in opp mate alignment\n\t\t3,                // max # of ref gaps permitted in opp mate alignment\n\t\t13,               // expected width\n\t\t0,                // expected # bases trimmed from upstream end\n\t\t0,                // expected # bases trimmed from downstream end\n\t\t3,                // ref offset of upstream column\n\t\t19,               // ref offset of downstream column\n\t\t\"1111111111111\",  // expected starting bools\n\t\t\"0001111111000\"); // expected ending bools\n\n\t//        *******\n\t//     <<===-----\n\t//       o    o\n\t//        o    o\n\t//         o    o\n\t//          o    o\n\t//         <<=----->>\n\t//            *******\n\t// 012345678901234567890\n\t// 0         1         2\n\ttestCaseFindMateAnchorLeft(\n\t\t\"FindMateAnchorLeft2\",\n\t\tfalse,            // trim to reference\n\t\t9,                // left offset of left upper parallelogram extent\n\t\t14,               // right offset of left upper parallelogram extent\n\t\t10,               // left offset of left lower parallelogram extent\n\t\t15,               // right offset of left lower parallelogram extent\n\t\t5,                // length of opposite mate\n\t\t30,               // length of reference sequence aligned to\n\t\t2,                // max # of read gaps permitted in opp mate alignment\n\t\t2,                // max # of ref gaps permitted in opp mate alignment\n\t\t7,                // expected width\n\t\t3,                // expected # bases trimmed from upstream end\n\t\t0,                // expected # bases trimmed from downstream end\n\t\t7,                // ref offset of upstream column\n\t\t17,               // ref offset of downstream column\n\t\t\"0011111\",        // expected starting bools\n\t\t\"1111100\");       // expected ending bools\n\n\t//        *******\n\t//     <<===--->>\n\t//       o    o\n\t//        o    o\n\t//         o    o\n\t//          o    o\n\t//           o    o\n\t//         <<=----->>\n\t//            *******\n\t// 01234567890123456xxxx\n\t// 0         1         2\n\ttestCaseFindMateAnchorLeft(\n\t\t\"FindMateAnchorLeft3\",\n\t\ttrue,             // trim to reference\n\t\t9,                // left offset of left upper parallelogram extent\n\t\t14,               // right offset of left upper parallelogram extent\n\t\t10,               // left offset of left lower parallelogram extent\n\t\t15,               // right offset of left lower parallelogram extent\n\t\t5,                // length of opposite mate\n\t\t17,               // length of reference sequence aligned to\n\t\t2,                // max # of read gaps permitted in opp mate alignment\n\t\t2,                // max # of ref gaps permitted in opp mate alignment\n\t\t7,                // expected width\n\t\t3,                // expected # bases trimmed from upstream end\n\t\t0,                // expected # bases trimmed from downstream end\n\t\t7,                // ref offset of upstream column\n\t\t17,               // ref offset of downstream column\n\t\t\"0011111\",        // expected starting bools\n\t\t\"1111100\");       // expected ending bools\n\n\t//        ******\n\t//     <<===-----\n\t//       o    o\n\t//        o    o\n\t//         o    o\n\t//          o    o\n\t//         <<=----=>>\n\t//            ******\n\t// 012345678901234xxxxxx\n\t// 0         1         2\n\ttestCaseFindMateAnchorLeft(\n\t\t\"FindMateAnchorLeft4\",\n\t\ttrue,             // trim to reference\n\t\t9,                // left offset of left upper parallelogram extent\n\t\t14,               // right offset of left upper parallelogram extent\n\t\t10,               // left offset of left lower parallelogram extent\n\t\t15,               // right offset of left lower parallelogram extent\n\t\t5,                // length of opposite mate\n\t\t15,               // length of reference sequence aligned to\n\t\t2,                // max # of read gaps permitted in opp mate alignment\n\t\t2,                // max # of ref gaps permitted in opp mate alignment\n\t\t6,                // expected width\n\t\t3,                // expected # bases trimmed from upstream end\n\t\t1,                // expected # bases trimmed from downstream end\n\t\t7,                // ref offset of upstream column\n\t\t16,               // ref offset of downstream column\n\t\t\"001111\",         // expected starting bools\n\t\t\"111100\");        // expected ending bools\n\n\t// -1         0         2\n\t//  xxxxxxxxxx012345678xx\n\t//\n\t//           *******\n\t//        <<===-----\n\t//          o    o\n\t//           o    o\n\t//            o    o\n\t//             o    o\n\t//              o    o\n\t//            <<=----->>\n\t//               *******\n\t//                \n\t//  xxxxxxxxxx012345678xx\n\t// -1         0         2\n\ttestCaseFindMateAnchorLeft(\n\t\t\"FindMateAnchorLeft5\",\n\t\ttrue,             // trim to reference\n\t\t1,                // left offset of left upper parallelogram extent\n\t\t7,                // right offset of left upper parallelogram extent\n\t\t2,                // left offset of left lower parallelogram extent\n\t\t7,                // right offset of left lower parallelogram extent\n\t\t5,                // length of opposite mate\n\t\t9,                // length of reference sequence aligned to\n\t\t2,                // max # of read gaps permitted in opp mate alignment\n\t\t2,                // max # of ref gaps permitted in opp mate alignment\n\t\t7,                // expected width\n\t\t3,                // expected # bases trimmed from upstream end\n\t\t0,                // expected # bases trimmed from downstream end\n\t\t-1,               // ref offset of upstream column\n\t\t9,                // ref offset of downstream column\n\t\t\"0011111\",        // expected starting bools\n\t\t\"1111100\");       // expected ending bools\n\n\t//   <<<<==-===>>\n\t//       o    o\n\t//        o    o\n\t//         o    o\n\t//          o    o\n\t//       <<<<------>>\n\t//           ******\n\t// 012345678901234567890\n\t// 0         1         2\n\ttestCaseFindMateAnchorLeft(\n\t\t\"FindMateAnchorLeft6\",\n\t\tfalse,            // trim to reference\n\t\t8,                // left offset of left upper parallelogram extent\n\t\t8,                // right offset of left upper parallelogram extent\n\t\t10,               // left offset of left lower parallelogram extent\n\t\t15,               // right offset of left lower parallelogram extent\n\t\t5,                // length of opposite mate\n\t\t30,               // length of reference sequence aligned to\n\t\t4,                // max # of read gaps permitted in opp mate alignment\n\t\t2,                // max # of ref gaps permitted in opp mate alignment\n\t\t6,                // expected width\n\t\t4,                // expected # bases trimmed from upstream end\n\t\t2,                // expected # bases trimmed from downstream end\n\t\t6,                // ref offset of upstream column\n\t\t15,               // ref offset of downstream column\n\t\t\"001000\",         // expected starting bools\n\t\t\"111111\");        // expected ending bools\n\n\t///////////////////////////\n\t//\n\t// ANCHOR ON THE RIGHT\n\t//\n\t///////////////////////////\n\n\t//        <<<------->>>\n\t//           o     o\n\t//            o     o\n\t//             o     o\n\t//              o     o\n\t//            <<<------->>>\n\t// 012345678901234567890123456789\n\t// 0         1         2\n\ttestCaseFindMateAnchorRight(\n\t\t\"FindMateAnchorRight1\",\n\t\tfalse,            // trim to reference\n\t\t10,               // left offset of left upper parallelogram extent\n\t\t16,               // right offset of left upper parallelogram extent\n\t\t11,               // left offset of left lower parallelogram extent\n\t\t23,               // right offset of left lower parallelogram extent\n\t\t5,                // length of opposite mate\n\t\t30,               // length of reference sequence aligned to\n\t\t3,                // max # of read gaps permitted in opp mate alignment\n\t\t3,                // max # of ref gaps permitted in opp mate alignment\n\t\t13,               // expected width\n\t\t0,                // expected # bases trimmed from upstream end\n\t\t0,                // expected # bases trimmed from downstream end\n\t\t7,                // ref offset of upstream column\n\t\t23,               // ref offset of downstream column\n\t\t\"0001111111000\",  // expected starting bools\n\t\t\"1111111111111\"); // expected ending bools\n\n\t// 0         1         2\n\t// 012345678901234567890\n\t//        *******\n\t//     <<------>>\n\t//        o    o\n\t//         o    o\n\t//          o    o\n\t//           o    o\n\t//         <<===--->>\n\t//            *******\n\t// 012345678901234567890\n\t// 0         1         2\n\ttestCaseFindMateAnchorRight(\n\t\t\"FindMateAnchorRight2\",\n\t\tfalse,            // trim to reference\n\t\t6,                // left offset of left upper parallelogram extent\n\t\t11,               // right offset of left upper parallelogram extent\n\t\t13,               // left offset of left lower parallelogram extent\n\t\t18,               // right offset of left lower parallelogram extent\n\t\t5,                // length of opposite mate\n\t\t30,               // length of reference sequence aligned to\n\t\t2,                // max # of read gaps permitted in opp mate alignment\n\t\t2,                // max # of ref gaps permitted in opp mate alignment\n\t\t7,                // expected width\n\t\t3,                // expected # bases trimmed from upstream end\n\t\t0,                // expected # bases trimmed from downstream end\n\t\t7,                // ref offset of upstream column\n\t\t17,               // ref offset of downstream column\n\t\t\"1111100\",        // expected starting bools\n\t\t\"0011111\");       // expected ending bools\n\n\t// Reference trimming takes off the left_pad of the left mate\n\t//\n\t//             *******\n\t//          <<------>>\n\t//            o    o\n\t//             o    o\n\t//              o    o\n\t//               o    o\n\t//                o    o\n\t//              <<===--->>\n\t//                 *******\n\t//  0123456789012345678901234567890\n\t// -1         0         1         2\n\ttestCaseFindMateAnchorRight(\n\t\t\"FindMateAnchorRight3\",\n\t\ttrue,             // trim to reference\n\t\t0,                // left offset of left upper parallelogram extent\n\t\t5,                // right offset of left upper parallelogram extent\n\t\t7,                // left offset of left lower parallelogram extent\n\t\t11,               // right offset of left lower parallelogram extent\n\t\t5,                // length of opposite mate\n\t\t30,               // length of reference sequence aligned to\n\t\t2,                // max # of read gaps permitted in opp mate alignment\n\t\t2,                // max # of ref gaps permitted in opp mate alignment\n\t\t7,                // expected width\n\t\t3,                // expected # bases trimmed from upstream end\n\t\t0,                // expected # bases trimmed from downstream end\n\t\t1,                // ref offset of upstream column\n\t\t11,               // ref offset of downstream column\n\t\t\"1111100\",        // expected starting bools\n\t\t\"0011111\");       // expected ending bools\n\n\t// Reference trimming takes off the leftmost 5 positions of the left mate,\n\t// and takes 1 from the right mate\n\t//\n\t//            *****\n\t//       <<------>>\n\t//         o    o\n\t//          o    o\n\t//           o    o\n\t//            o    o\n\t//             o    o\n\t//           <<===--->>\n\t//                *****\n\t//  0987654321012345678901234567890\n\t// -1         0         1         2\n\ttestCaseFindMateAnchorRight(\n\t\t\"FindMateAnchorRight4\",\n\t\ttrue,             // trim to reference\n\t\t-3,               // left offset of left upper parallelogram extent\n\t\t2,                // right offset of left upper parallelogram extent\n\t\t4,                // left offset of left lower parallelogram extent\n\t\t10,               // right offset of left lower parallelogram extent\n\t\t5,                // length of opposite mate\n\t\t30,               // length of reference sequence aligned to\n\t\t2,                // max # of read gaps permitted in opp mate alignment\n\t\t2,                // max # of ref gaps permitted in opp mate alignment\n\t\t5,                // expected width\n\t\t5,                // expected # bases trimmed from upstream end\n\t\t0,                // expected # bases trimmed from downstream end\n\t\t0,                // ref offset of upstream column\n\t\t8,                // ref offset of downstream column\n\t\t\"11100\",          // expected starting bools\n\t\t\"11111\");         // expected ending bools\n\n\t// Reference trimming takes off the leftmost 5 positions of the left mate,\n\t// and takes 1 from the left of the right mate.  Also, it takes 2 from the\n\t// right of the right mate.\n\t//\n\t//            ***\n\t//       <<------>>\n\t//         o    o\n\t//          o    o\n\t//           o    o\n\t//            o    o\n\t//             o    o\n\t//           <<===--->>\n\t//                ***\n\t//  0987654321012345678901234567890\n\t// -1         0         1         2\n\ttestCaseFindMateAnchorRight(\n\t\t\"FindMateAnchorRight5\",\n\t\ttrue,             // trim to reference\n\t\t-3,               // left offset of left upper parallelogram extent\n\t\t2,                // right offset of left upper parallelogram extent\n\t\t4,                // left offset of left lower parallelogram extent\n\t\t10,               // right offset of left lower parallelogram extent\n\t\t5,                // length of opposite mate\n\t\t7,                // length of reference sequence aligned to\n\t\t2,                // max # of read gaps permitted in opp mate alignment\n\t\t2,                // max # of ref gaps permitted in opp mate alignment\n\t\t3,                // expected width\n\t\t5,                // expected # bases trimmed from upstream end\n\t\t2,                // expected # bases trimmed from downstream end\n\t\t0,                // ref offset of upstream column\n\t\t6,                // ref offset of downstream column\n\t\t\"111\",            // expected starting bools\n\t\t\"111\");           // expected ending bools\n\n\t//       ******\n\t//     <<------>>>>\n\t//        o    o\n\t//         o    o\n\t//          o    o\n\t//           o    o\n\t//         <<====-=>>>>\n\t//           ******\n\t// 012345678901234567890\n\t// 0         1         2\n\ttestCaseFindMateAnchorRight(\n\t\t\"FindMateAnchorRight6\",\n\t\tfalse,            // trim to reference\n\t\t6,                // left offset of left upper parallelogram extent\n\t\t11,               // right offset of left upper parallelogram extent\n\t\t14,               // left offset of left lower parallelogram extent\n\t\t14,               // right offset of left lower parallelogram extent\n\t\t5,                // length of opposite mate\n\t\t30,               // length of reference sequence aligned to\n\t\t4,                // max # of read gaps permitted in opp mate alignment\n\t\t2,                // max # of ref gaps permitted in opp mate alignment\n\t\t6,                // expected width\n\t\t2,                // expected # bases trimmed from upstream end\n\t\t4,                // expected # bases trimmed from downstream end\n\t\t6,                // ref offset of upstream column\n\t\t15,               // ref offset of downstream column\n\t\t\"111111\",         // expected starting bools\n\t\t\"000010\");        // expected ending bools\n\n\t//         ****\n\t//   <<<<==---->>\n\t//       o    o\n\t//        o    o\n\t//         o    o\n\t//          o    o\n\t//           o    o\n\t//       <<<<====-=>>\n\t//             ****\n\t// 012345678901234567890\n\t// 0         1         2\n\ttestCaseFindMateAnchorRight(\n\t\t\"FindMateAnchorRight7\",\n\t\tfalse,            // trim to reference\n\t\t6,                // left offset of left upper parallelogram extent\n\t\t11,               // right offset of left upper parallelogram extent\n\t\t14,               // left offset of left lower parallelogram extent\n\t\t14,               // right offset of left lower parallelogram extent\n\t\t5,                // length of opposite mate\n\t\t30,               // length of reference sequence aligned to\n\t\t2,                // max # of read gaps permitted in opp mate alignment\n\t\t4,                // max # of ref gaps permitted in opp mate alignment\n\t\t4,                // expected width\n\t\t6,                // expected # bases trimmed from upstream end\n\t\t2,                // expected # bases trimmed from downstream end\n\t\t8,                // ref offset of upstream column\n\t\t15,               // ref offset of downstream column\n\t\t\"1111\",           // expected starting bools\n\t\t\"0010\");          // expected ending bools\n\t\n\ttestCaseFindMateAnchorRight(\n\t\t\"FindMateAnchorRight8\",\n\t\ttrue,             // trim to reference\n\t\t-37,              // left offset of left upper parallelogram extent\n\t\t13,               // right offset of left upper parallelogram extent\n\t\t-37,              // left offset of left lower parallelogram extent\n\t\t52,               // right offset of left lower parallelogram extent\n\t\t10,               // length of opposite mate\n\t\t53,               // length of reference sequence aligned to\n\t\t0,                // max # of read gaps permitted in opp mate alignment\n\t\t0,                // max # of ref gaps permitted in opp mate alignment\n\t\t14,               // expected width\n\t\t37,               // expected # bases trimmed from upstream end\n\t\t0,                // expected # bases trimmed from downstream end\n\t\t0,                // ref offset of upstream column\n\t\t22,               // ref offset of downstream column\n\t\t\"11111111111111\", // expected starting bools\n\t\t\"11111111111111\");// expected ending bools\n}", "idx": 225}
{"project": "bowtie2", "commit_id": "304_bowtie2_2.5.1_dp_framer.h_initIval.cpp", "target": 0, "func": "void initIval(Interval& iv) {\n\t\tiv.setOff(refl_pretrim + (int64_t)corel);\n\t\tiv.setLen(corer - corel + 1);\n\t}", "idx": 226}
{"project": "bowtie2", "commit_id": "305_bowtie2_2.5.1_ds.cpp_main.cpp", "target": 0, "func": "int main(void) {\n\tcerr << \"Test EHeap 1...\";\n\t{\n\t\tEHeap<float> h;\n\t\th.insert(0.5f);  // 1\n\t\th.insert(0.6f);  // 2\n\t\th.insert(0.25f); // 3\n\t\th.insert(0.75f); // 4\n\t\th.insert(0.1f);  // 5\n\t\th.insert(0.9f);  // 6\n\t\th.insert(0.4f);  // 7\n\t\tassert_eq(7, h.size());\n\t\tif(h.pop() != 0.1f) {\n\t\t\tthrow 1;\n\t\t}\n\t\tassert_eq(6, h.size());\n\t\tif(h.pop() != 0.25f) {\n\t\t\tthrow 1;\n\t\t}\n\t\tassert_eq(5, h.size());\n\t\tif(h.pop() != 0.4f) {\n\t\t\tthrow 1;\n\t\t}\n\t\tassert_eq(4, h.size());\n\t\tif(h.pop() != 0.5f) {\n\t\t\tthrow 1;\n\t\t}\n\t\tassert_eq(3, h.size());\n\t\tif(h.pop() != 0.6f) {\n\t\t\tthrow 1;\n\t\t}\n\t\tassert_eq(2, h.size());\n\t\tif(h.pop() != 0.75f) {\n\t\t\tthrow 1;\n\t\t}\n\t\tassert_eq(1, h.size());\n\t\tif(h.pop() != 0.9f) {\n\t\t\tthrow 1;\n\t\t}\n\t\tassert_eq(0, h.size());\n\t\tassert(h.empty());\n\t}\n\tcerr << \"PASSED\" << endl;\n\n\tcerr << \"Test EHeap 2...\";\n\t{\n\t\tEHeap<size_t> h;\n\t\tRandomSource rnd(12);\n\t\tsize_t lim = 2000;\n\t\twhile(h.size() < lim) {\n\t\t\th.insert(rnd.nextU32());\n\t\t}\n\t\tsize_t last = std::numeric_limits<size_t>::max();\n\t\tbool first = true;\n\t\twhile(!h.empty()) {\n\t\t\tsize_t p = h.pop();\n\t\t\tassert(first || p >= last);\n\t\t\tlast = p;\n\t\t\tfirst = false;\n\t\t}\n\t}\n\tcerr << \"PASSED\" << endl;\n\n\tcerr << \"Test EBitList 1...\";\n\t{\n\t\tEBitList<128> l;\n\t\tassert_eq(0, l.size());\n\t\tassert_eq(std::numeric_limits<size_t>::max(), l.max());\n\n\t\tassert(!l.test(0));\n\t\tassert(!l.test(1));\n\t\tassert(!l.test(10));\n\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tl.set(10);\n\t\t\tassert(!l.test(0));\n\t\t\tassert(!l.test(1));\n\t\t\tassert(!l.test(9));\n\t\t\tassert(l.test(10));\n\t\t\tassert(!l.test(11));\n\t\t}\n\n\t\tassert_eq(10, l.max());\n\t\tl.clear();\n\t\tassert(!l.test(10));\n\t\tassert_eq(std::numeric_limits<size_t>::max(), l.max());\n\n\t\tRandomSource rnd(12);\n\t\tsize_t lim = 2000;\n\t\tfor(size_t i = 0; i < lim; i++) {\n\t\t\tuint32_t ri = rnd.nextU32() % 10000;\n\t\t\tl.set(ri);\n\t\t\tassert(l.test(ri));\n\t\t}\n\t}\n\tcerr << \"PASSED\" << endl;\n}", "idx": 227}
{"project": "bowtie2", "commit_id": "306_bowtie2_2.5.1_ds.h_total.cpp", "target": 0, "func": "uint64_t total(int cat) { return tots_[cat]; }", "idx": 228}
{"project": "bowtie2", "commit_id": "307_bowtie2_2.5.1_ds.h_peak.cpp", "target": 0, "func": "uint64_t peak(int cat) { return peaks_[cat]; }", "idx": 229}
{"project": "bowtie2", "commit_id": "308_bowtie2_2.5.1_ds.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\ti_ = len_ = 0;\n\t\tlist_ = NULL;\n\t}", "idx": 230}
{"project": "bowtie2", "commit_id": "309_bowtie2_2.5.1_ds.h_init.cpp", "target": 0, "func": "void init(\n\t\tconst T1& a_,\n\t\tconst T1& b_,\n\t\tconst T1& c_,\n\t\tconst T1& d_)\n\t{\n\t\ta = a_; b = b_; c = c_; d = d_;\n\t}", "idx": 231}
{"project": "bowtie2", "commit_id": "30_bowtie2_2.5.1_aligner_result.cpp_main.cpp", "target": 0, "func": "int main() {\n\tEList<char> op;\n\tEList<char> ch;\n\tEList<size_t> run;\n\t{\n\t\t// On top of each other, same length\n\t\tcerr << \"Test case 1, simple overlap 1 ... \";\n\t\tAlnRes res1;\n\t\tres1.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 0, true),\n\t\t\tfalse);\n\t\tAlnRes res2;\n\t\tres2.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 0, true),\n\t\t\tfalse);\n\t\tassert(res1.overlap(res2));\n\t\t\n\t\t// Try again, but using the redundant-alignment database\n\t\tRedundantAlns ra;\n\t\tra.reset();\n\t\tra.init(10);\n\t\tra.add(res1);\n\t\tassert(ra.overlap(res1));\n\t\tassert(ra.overlap(res2));\n\n\t\tchar buf1[1024];\n\t\tres1.printCigar(false, false, false, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"10M\"));\n\t\tres1.printCigar(false, false, true, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"10=\"));\n\n\t\tchar buf2[1024];\n\t\tres2.printCigar(false, false, false, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"10M\"));\n\t\tres2.printCigar(false, false, true, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"10=\"));\n\n\t\tchar buf3[1024];\n\t\tres1.printMD(false, false, op, ch, run, NULL, buf3);\n\t\tassert_eq(0, strcmp(buf3, \"10\"));\n\t\tres1.printMD(false, true, op, ch, run, NULL, buf3);\n\t\tassert_eq(0, strcmp(buf3, \"8\"));\n\n\t\tchar buf4[1024];\n\t\tres2.printMD(false, false, op, ch, run, NULL, buf4);\n\t\tassert_eq(0, strcmp(buf4, \"10\"));\n\t\tres2.printMD(false, true, op, ch, run, NULL, buf4);\n\t\tassert_eq(0, strcmp(buf4, \"8\"));\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\t// On top of each other, different lengths\n\t\tcerr << \"Test case 2, simple overlap 2 ... \";\n\t\tAlnRes res1;\n\t\tres1.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 0, true),\n\t\t\tfalse);\n\t\tAlnRes res2;\n\t\tres2.init(\n\t\t\t11,\n\t\t\tAlnScore(),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 0, true),\n\t\t\tfalse);\n\t\tassert(res1.overlap(res2));\n\n\t\t// Try again, but using the redundant-alignment database\n\t\tRedundantAlns ra;\n\t\tra.reset();\n\t\tra.init(11);\n\t\tra.add(res1);\n\t\tassert(ra.overlap(res1));\n\t\tassert(ra.overlap(res2));\n\n\t\tchar buf1[1024];\n\t\tres1.printCigar(false, false, false, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"10M\"));\n\t\tres1.printCigar(false, false, true, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"10=\"));\n\n\t\tchar buf2[1024];\n\t\tres2.printCigar(false, false, false, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"11M\"));\n\t\tres2.printCigar(false, false, true, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"11=\"));\n\n\t\tchar buf3[1024];\n\t\tres1.printMD(false, false, op, ch, run, NULL, buf3);\n\t\tassert_eq(0, strcmp(buf3, \"10\"));\n\t\tres1.printMD(false, true, op, ch, run, NULL, buf3);\n\t\tassert_eq(0, strcmp(buf3, \"8\"));\n\n\t\tchar buf4[1024];\n\t\tres2.printMD(false, false, op, ch, run, NULL, buf4);\n\t\tassert_eq(0, strcmp(buf4, \"11\"));\n\t\tres2.printMD(false, true, op, ch, run, NULL, buf4);\n\t\tassert_eq(0, strcmp(buf4, \"9\"));\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\t// Different references\n\t\tcerr << \"Test case 3, simple overlap 3 ... \";\n\t\tAlnRes res1;\n\t\tres1.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 1, true),\n\t\t\tfalse);\n\t\tAlnRes res2;\n\t\tres2.init(\n\t\t\t11,\n\t\t\tAlnScore(),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 0, true),\n\t\t\tfalse);\n\t\tassert(!res1.overlap(res2));\n\n\t\t// Try again, but using the redundant-alignment database\n\t\tRedundantAlns ra;\n\t\tra.reset();\n\t\tra.init(11);\n\t\tra.add(res1);\n\t\tassert(ra.overlap(res1));\n\t\tassert(!ra.overlap(res2));\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\t// Different references\n\t\tcerr << \"Test case 4, simple overlap 4 ... \";\n\t\tAlnRes res1;\n\t\tres1.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 0, true),\n\t\t\tfalse);\n\t\tAlnRes res2;\n\t\tres2.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(1, 0, true),\n\t\t\tfalse);\n\t\tassert(!res1.overlap(res2));\n\n\t\t// Try again, but using the redundant-alignment database\n\t\tRedundantAlns ra;\n\t\tra.reset();\n\t\tra.init(10);\n\t\tra.add(res1);\n\t\tassert(ra.overlap(res1));\n\t\tassert(!ra.overlap(res2));\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\t// Different strands\n\t\tcerr << \"Test case 5, simple overlap 5 ... \";\n\t\tAlnRes res1;\n\t\tres1.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 0, true),\n\t\t\tfalse);\n\t\tAlnRes res2;\n\t\tres2.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 0, false),\n\t\t\tfalse);\n\t\tassert(!res1.overlap(res2));\n\n\t\t// Try again, but using the redundant-alignment database\n\t\tRedundantAlns ra;\n\t\tra.reset();\n\t\tra.init(10);\n\t\tra.add(res1);\n\t\tassert(ra.overlap(res1));\n\t\tassert(!ra.overlap(res2));\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\t// Different strands\n\t\tcerr << \"Test case 6, simple overlap 6 ... \";\n\t\tEList<Edit> ned1(RES_CAT);\n\t\tned1.expand();\n\t\t// 1 step to the right in the middle of the alignment\n\t\tned1.back().init(5, 'A' /*chr*/, '-' /*qchr*/, EDIT_TYPE_READ_GAP);\n\t\tAlnRes res1;\n\t\tres1.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned1,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 5, false),\n\t\t\tfalse);\n\t\tAlnRes res2;\n\t\tres2.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 6, false),\n\t\t\tfalse);\n\t\tassert(res1.overlap(res2));\n\n\t\t// Try again, but using the redundant-alignment database\n\t\tRedundantAlns ra;\n\t\tra.reset();\n\t\tra.init(10);\n\t\tra.add(res1);\n\t\tassert(ra.overlap(res1));\n\t\tassert(ra.overlap(res2));\n\n\t\tchar buf1[1024];\n\t\tres1.printCigar(false, false, false, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5M1D5M\"));\n\t\tres1.printCigar(false, false, true, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5=1D5=\"));\n\n\t\tchar buf2[1024];\n\t\tres2.printCigar(false, false, false, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"10M\"));\n\t\tres2.printCigar(false, false, true, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"10=\"));\n\n\t\tchar buf3[1024];\n\t\tres1.printMD(false, false, op, ch, run, NULL, buf3);\n\t\tassert_eq(0, strcmp(buf3, \"5^A5\"));\n\t\tres1.printMD(false, true, op, ch, run, NULL, buf3);\n\t\tassert_eq(0, strcmp(buf3, \"4^A4\"));\n\n\t\tchar buf4[1024];\n\t\tres2.printMD(false, false, op, ch, run, NULL, buf4);\n\t\tassert_eq(0, strcmp(buf4, \"10\"));\n\t\tres2.printMD(false, true, op, ch, run, NULL, buf4);\n\t\tassert_eq(0, strcmp(buf4, \"8\"));\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\t// Different strands\n\t\tcerr << \"Test case 7, simple overlap 7 ... \";\n\t\tEList<Edit> ned1(RES_CAT);\n\t\t// 3 steps to the right in the middle of the alignment\n\t\tned1.push_back(Edit(5, 'A', '-', EDIT_TYPE_READ_GAP));\n\t\tned1.push_back(Edit(5, 'C', '-', EDIT_TYPE_READ_GAP));\n\t\tned1.push_back(Edit(5, 'G', '-', EDIT_TYPE_READ_GAP));\n\t\tAlnRes res1;\n\t\tres1.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned1,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 5, false),\n\t\t\tfalse);\n\t\tAlnRes res2;\n\t\tres2.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 6, false),\n\t\t\tfalse);\n\t\tassert(res1.overlap(res2));\n\n\t\t// Try again, but using the redundant-alignment database\n\t\tRedundantAlns ra;\n\t\tra.reset();\n\t\tra.init(10);\n\t\tra.add(res1);\n\t\tassert(ra.overlap(res1));\n\t\tassert(ra.overlap(res2));\n\n\t\tchar buf1[1024];\n\t\tres1.printCigar(false, false, false, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5M3D5M\"));\n\t\tres1.printCigar(false, false, true, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5=3D5=\"));\n\n\t\tchar buf2[1024];\n\t\tres2.printCigar(false, false, false, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"10M\"));\n\t\tres2.printCigar(false, false, true, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"10=\"));\n\n\t\tchar buf3[1024];\n\t\tres1.printMD(false, false, op, ch, run, NULL, buf3);\n\t\tassert_eq(0, strcmp(buf3, \"5^GCA5\"));\n\t\tres1.printMD(false, true, op, ch, run, NULL, buf3);\n\t\tassert_eq(0, strcmp(buf3, \"4^GCA4\"));\n\n\t\tchar buf4[1024];\n\t\tres2.printMD(false, false, op, ch, run, NULL, buf4);\n\t\tassert_eq(0, strcmp(buf4, \"10\"));\n\t\tres2.printMD(false, true, op, ch, run, NULL, buf4);\n\t\tassert_eq(0, strcmp(buf4, \"8\"));\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\t// Both with horizontal movements; overlap\n\t\tcerr << \"Test case 8, simple overlap 8 ... \";\n\t\tEList<Edit> ned1(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned1.push_back(Edit(5, 'A', '-', EDIT_TYPE_READ_GAP));\n\t\tned1.push_back(Edit(5, 'C', '-', EDIT_TYPE_READ_GAP));\n\t\tAlnRes res1;\n\t\tres1.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned1,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 5, false),\n\t\t\tfalse);\n\t\tEList<Edit> ned2(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned2.push_back(Edit(5, 'A', '-', EDIT_TYPE_READ_GAP));\n\t\tned2.push_back(Edit(5, 'C', '-', EDIT_TYPE_READ_GAP));\n\t\tAlnRes res2;\n\t\tres2.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned2,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 6, false),\n\t\t\tfalse);\n\t\tassert(res1.overlap(res2));\n\n\t\t// Try again, but using the redundant-alignment database\n\t\tRedundantAlns ra;\n\t\tra.reset();\n\t\tra.init(10);\n\t\tra.add(res1);\n\t\tassert(ra.overlap(res1));\n\t\tassert(ra.overlap(res2));\n\n\t\tchar buf1[1024];\n\t\tres1.printCigar(false, false, false, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5M2D5M\"));\n\t\tres1.printCigar(false, false, true, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5=2D5=\"));\n\n\t\tchar buf2[1024];\n\t\tres2.printCigar(false, false, false, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"5M2D5M\"));\n\t\tres2.printCigar(false, false, true, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"5=2D5=\"));\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\t// Both with horizontal movements; no overlap\n\t\tcerr << \"Test case 9, simple overlap 9 ... \";\n\t\tEList<Edit> ned1(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned1.push_back(Edit(6, 'A', '-', EDIT_TYPE_READ_GAP));\n\t\tned1.push_back(Edit(6, 'C', '-', EDIT_TYPE_READ_GAP));\n\t\tAlnRes res1;\n\t\tres1.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned1,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 5, true),\n\t\t\tfalse);\n\t\tEList<Edit> ned2(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned2.push_back(Edit(5, 'A', '-', EDIT_TYPE_READ_GAP));\n\t\tned2.push_back(Edit(5, 'C', '-', EDIT_TYPE_READ_GAP));\n\t\tAlnRes res2;\n\t\tres2.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned2,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 6, true),\n\t\t\tfalse);\n\t\tassert(!res1.overlap(res2));\n\n\t\t// Try again, but using the redundant-alignment database\n\t\tRedundantAlns ra;\n\t\tra.reset();\n\t\tra.init(10);\n\t\tra.add(res1);\n\t\tassert(ra.overlap(res1));\n\t\tassert(!ra.overlap(res2));\n\n\t\tchar buf1[1024];\n\t\tres1.printCigar(false, false, false, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"6M2D4M\"));\n\t\tres1.printCigar(false, false, true, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"6=2D4=\"));\n\n\t\tchar buf2[1024];\n\t\tres2.printCigar(false, false, false, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"5M2D5M\"));\n\t\tres2.printCigar(false, false, true, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"5=2D5=\"));\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\t// Both with horizontal movements; no overlap.  Reverse strand.\n\t\tcerr << \"Test case 10, simple overlap 10 ... \";\n\t\tEList<Edit> ned1(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned1.push_back(Edit(5, 'A', '-', EDIT_TYPE_READ_GAP));\n\t\tned1.push_back(Edit(5, 'C', '-', EDIT_TYPE_READ_GAP));\n\t\tAlnRes res1;\n\t\tres1.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned1,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 5, false),\n\t\t\tfalse);\n\t\tEList<Edit> ned2(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned2.push_back(Edit(6, 'A', '-', EDIT_TYPE_READ_GAP));\n\t\tned2.push_back(Edit(6, 'C', '-', EDIT_TYPE_READ_GAP));\n\t\tAlnRes res2;\n\t\tres2.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned2,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 6, false),\n\t\t\tfalse);\n\t\tassert(!res1.overlap(res2));\n\n\t\t// Try again, but using the redundant-alignment database\n\t\tRedundantAlns ra;\n\t\tra.reset();\n\t\tra.init(10);\n\t\tra.add(res1);\n\t\tassert(ra.overlap(res1));\n\t\tassert(!ra.overlap(res2));\n\n\t\tchar buf1[1024];\n\t\tres1.printCigar(false, false, false, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5M2D5M\"));\n\t\tres1.printCigar(false, false, true, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5=2D5=\"));\n\n\t\tchar buf2[1024];\n\t\tres2.printCigar(false, false, false, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"4M2D6M\"));\n\t\tres2.printCigar(false, false, true, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"4=2D6=\"));\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\t// Both with vertical movements; no overlap\n\t\tcerr << \"Test case 11, simple overlap 11 ... \";\n\t\tEList<Edit> ned1(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned1.push_back(Edit(5, '-', 'A', EDIT_TYPE_REF_GAP));\n\t\tned1.push_back(Edit(6, '-', 'C', EDIT_TYPE_REF_GAP));\n\t\tAlnRes res1;\n\t\tres1.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned1,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 5, true),\n\t\t\tfalse);\n\t\tEList<Edit> ned2(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned2.push_back(Edit(6, '-', 'A', EDIT_TYPE_REF_GAP));\n\t\tned2.push_back(Edit(7, '-', 'C', EDIT_TYPE_REF_GAP));\n\t\tAlnRes res2;\n\t\tres2.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned2,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 6, true),\n\t\t\tfalse);\n\t\tassert(!res1.overlap(res2));\n\n\t\t// Try again, but using the redundant-alignment database\n\t\tRedundantAlns ra;\n\t\tra.reset();\n\t\tra.init(10);\n\t\tra.add(res1);\n\t\tassert(ra.overlap(res1));\n\t\tassert(!ra.overlap(res2));\n\n\t\tchar buf1[1024];\n\t\tres1.printCigar(false, false, false, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5M2I3M\"));\n\t\tres1.printCigar(false, false, true, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5=2I3=\"));\n\n\t\tchar buf2[1024];\n\t\tres2.printCigar(false, false, false, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"6M2I2M\"));\n\t\tres2.printCigar(false, false, true, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"6=2I2=\"));\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\t// Both with vertical movements; no overlap\n\t\tcerr << \"Test case 12, simple overlap 12 ... \";\n\t\tEList<Edit> ned1(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned1.push_back(Edit(5, '-', 'A', EDIT_TYPE_REF_GAP));\n\t\tned1.push_back(Edit(6, '-', 'C', EDIT_TYPE_REF_GAP));\n\t\tAlnRes res1;\n\t\tres1.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned1,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 5, true),\n\t\t\tfalse);\n\t\tEList<Edit> ned2(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned2.push_back(Edit(5, '-', 'A', EDIT_TYPE_REF_GAP));\n\t\tned2.push_back(Edit(6, '-', 'C', EDIT_TYPE_REF_GAP));\n\t\tAlnRes res2;\n\t\tres2.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned2,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 6, true),\n\t\t\tfalse);\n\t\tassert(!res1.overlap(res2));\n\n\t\t// Try again, but using the redundant-alignment database\n\t\tRedundantAlns ra;\n\t\tra.reset();\n\t\tra.init(10);\n\t\tra.add(res1);\n\t\tassert(ra.overlap(res1));\n\t\tassert(!ra.overlap(res2));\n\n\t\tchar buf1[1024];\n\t\tres1.printCigar(false, false, false, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5M2I3M\"));\n\t\tres1.printCigar(false, false, true, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5=2I3=\"));\n\n\t\tchar buf2[1024];\n\t\tres2.printCigar(false, false, false, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"5M2I3M\"));\n\t\tres2.printCigar(false, false, true, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"5=2I3=\"));\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\t// Both with vertical movements; overlap\n\t\tcerr << \"Test case 13, simple overlap 13 ... \";\n\t\tEList<Edit> ned1(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned1.push_back(Edit(5, '-', 'A', EDIT_TYPE_REF_GAP));\n\t\tned1.push_back(Edit(6, '-', 'C', EDIT_TYPE_REF_GAP));\n\t\tAlnRes res1;\n\t\tres1.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned1,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 5, true),\n\t\t\tfalse);\n\t\tEList<Edit> ned2(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned2.push_back(Edit(4, '-', 'A', EDIT_TYPE_REF_GAP));\n\t\tned2.push_back(Edit(5, '-', 'C', EDIT_TYPE_REF_GAP));\n\t\tAlnRes res2;\n\t\tres2.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned2,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 6, true),\n\t\t\tfalse);\n\t\tassert(res1.overlap(res2));\n\n\t\t// Try again, but using the redundant-alignment database\n\t\tRedundantAlns ra;\n\t\tra.reset();\n\t\tra.init(10);\n\t\tra.add(res1);\n\t\tassert(ra.overlap(res1));\n\t\tassert(ra.overlap(res2));\n\n\t\tchar buf1[1024];\n\t\tres1.printCigar(false, false, false, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5M2I3M\"));\n\t\tres1.printCigar(false, false, true, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5=2I3=\"));\n\n\t\tchar buf2[1024];\n\t\tres2.printCigar(false, false, false, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"4M2I4M\"));\n\t\tres2.printCigar(false, false, true, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"4=2I4=\"));\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\t// Not even close\n\t\tcerr << \"Test case 14, simple overlap 14 ... \";\n\t\tEList<Edit> ned1(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned1.push_back(Edit(5, '-', 'A', EDIT_TYPE_REF_GAP));\n\t\tned1.push_back(Edit(6, '-', 'C', EDIT_TYPE_REF_GAP));\n\t\tAlnRes res1;\n\t\tres1.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned1,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 5, true),\n\t\t\tfalse);\n\t\tEList<Edit> ned2(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned2.push_back(Edit(4, '-', 'A', EDIT_TYPE_REF_GAP));\n\t\tned2.push_back(Edit(5, '-', 'C', EDIT_TYPE_REF_GAP));\n\t\tAlnRes res2;\n\t\tres2.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned2,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 400, true),\n\t\t\tfalse);\n\t\tassert(!res1.overlap(res2));\n\n\t\t// Try again, but using the redundant-alignment database\n\t\tRedundantAlns ra;\n\t\tra.reset();\n\t\tra.init(10);\n\t\tra.add(res1);\n\t\tassert(ra.overlap(res1));\n\t\tassert(!ra.overlap(res2));\n\t\t\n\t\tchar buf1[1024];\n\t\tres1.printCigar(false, false, false, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5M2I3M\"));\n\t\tres1.printCigar(false, false, true, op, run, NULL, buf1);\n\t\tassert_eq(0, strcmp(buf1, \"5=2I3=\"));\n\n\t\tchar buf2[1024];\n\t\tres2.printCigar(false, false, false, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"4M2I4M\"));\n\t\tres2.printCigar(false, false, true, op, run, NULL, buf2);\n\t\tassert_eq(0, strcmp(buf2, \"4=2I4=\"));\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\tcerr << \"Test case 15, CIGAR string with mismatches ... \";\n\t\tEList<Edit> ned(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned.push_back(Edit(0, 'C', 'A', EDIT_TYPE_MM));\n\t\tned.push_back(Edit(4, '-', 'C', EDIT_TYPE_REF_GAP));\n\t\tned.push_back(Edit(6, '-', 'C', EDIT_TYPE_REF_GAP));\n\t\tned.push_back(Edit(7, '-', 'C', EDIT_TYPE_REF_GAP));\n\t\tned.push_back(Edit(9, '-', 'A', EDIT_TYPE_READ_GAP));\n\t\tned.push_back(Edit(9, '-', 'A', EDIT_TYPE_READ_GAP));\n\t\tned.push_back(Edit(9, '-', 'A', EDIT_TYPE_READ_GAP));\n\t\tned.push_back(Edit(9, '-', 'A', EDIT_TYPE_READ_GAP));\n\t\tned.push_back(Edit(10, '-', 'A', EDIT_TYPE_MM));\n\t\tAlnRes res; res.init(\n\t\t\t11,\n\t\t\tAlnScore(),\n\t\t\t&ned,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, 44, true),\n\t\t\tfalse);\n\t\tchar buf[1024];\n\t\tres.printCigar(false, false, false, op, run, NULL, buf);\n\t\tassert_eq(0, strcmp(buf, \"4M1I1M2I1M4D2M\"));\n\t\tres.printCigar(false, false, true, op, run, NULL, buf);\n\t\tassert_eq(0, strcmp(buf, \"1X3=1I1=2I1=4D1=1X\"));\n\t\tcerr << \"PASSED\" << endl;\n\t}\n\n\t{\n\t\tcerr << \"Test case 17, Overhang ... \";\n\t\tEList<Edit> ned(RES_CAT);\n\t\t// 2 steps to the right in the middle of the alignment\n\t\tned.push_back(Edit(0, 'N', 'A', EDIT_TYPE_MM));\n\t\tned.push_back(Edit(5, 'C', 'A', EDIT_TYPE_MM));\n\t\tAlnRes res; res.init(\n\t\t\t10,\n\t\t\tAlnScore(),\n\t\t\t&ned,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tCoord(0, -1, true),\n\t\t\tfalse);\n\t\t\n\t\tchar buf[1024];\n\t\tres.printCigar(false, false, false, op, run, NULL, buf);\n\t\tassert_eq(0, strcmp(buf, \"10M\"));\n\t\tres.printCigar(false, false, true, op, run, NULL, buf);\n\t\tassert_eq(0, strcmp(buf, \"1X4=1X4=\"));\n\t\tres.printMD(false, false, op, ch, run, NULL, buf);\n\t\tassert_eq(0, strcmp(buf, \"0N4C4\"));\n\t\t\n\t\t#if 0\n\t\tAlnRes res2(res);\n\t\t// Now soft-clip away the overhang\n\t\tres2.clipOutside(\n\t\t\ttrue,  // soft clip\n\t\t\t0,     // ref begins\n\t\t\t40);   // ref ends (excl)\n\t\tres2.printCigar(false, false, false, op, run, NULL, buf);\n\t\tassert_eq(0, strcmp(buf, \"1S9M\"));\n\t\tres2.printCigar(false, false, true, op, run, NULL, buf);\n\t\tassert_eq(0, strcmp(buf, \"4=1X4=\"));\n\t\tres2.printMD(false, false, op, ch, run, NULL, buf);\n\t\tassert_eq(0, strcmp(buf, \"4C4\"));\n\n\t\tAlnRes res3 = res;\n\t\t// Now hard-clip away the overhang\n\t\tres3.clipOutside(\n\t\t\tfalse, // hard clip\n\t\t\t0,     // ref begins\n\t\t\t40);   // ref ends (excl)\n\t\tres3.printCigar(false, false, false, op, run, NULL, buf);\n\t\tassert_eq(0, strcmp(buf, \"9M\"));\n\t\tres3.printCigar(false, false, true, op, run, NULL, buf);\n\t\tassert_eq(0, strcmp(buf, \"4=1X4=\"));\n\t\tres3.printMD(false, false, op, ch, run, NULL, buf);\n\t\tassert_eq(0, strcmp(buf, \"4C4\"));\n\t\t#endif\n\n\t\tcerr << \"PASSED\" << endl;\n\t}\n}", "idx": 232}
{"project": "bowtie2", "commit_id": "310_bowtie2_2.5.1_ds.h_free.cpp", "target": 0, "func": "void free() {\n\t\t// Currently a no-op because the only freeing method supported\n\t\t// now is to clear the entire pool\n\t}", "idx": 233}
{"project": "bowtie2", "commit_id": "311_bowtie2_2.5.1_ds.h_xfer.cpp", "target": 0, "func": "void xfer(ELSet<T, S>& o) {\n\t\tassert_eq(cat_, o.cat());\n\t\tlist_ = o.list_; // list_ is an array of ESet<T>s\n\t\tsz_   = o.sz_;\n\t\tcur_  = o.cur_;\n\t\to.list_ = NULL;\n\t\to.sz_ = o.cur_ = 0;\n\t}", "idx": 234}
{"project": "bowtie2", "commit_id": "312_bowtie2_2.5.1_ds.h_ensure.cpp", "target": 0, "func": "bool ensure(Pool& p, size_t num) {\n\t\tassert(repOk());\n\t\tif(num == 0) return true;\n\t\t// Allocation of the first page\n\t\tif(pages_.size() == 0) {\n\t\t\tif(expand(p) == NULL) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tassert_eq(1, pages_.size());\n\t\t}\n\t\tsize_t cur = cur_;\n\t\tsize_t curPage = curPage_;\n\t\twhile(cur + num > PLIST_PER_PAGE) {\n\t\t\tassert_lt(curPage, pages_.size());\n\t\t\tif(curPage == pages_.size()-1 && expand(p) == NULL) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tnum -= (PLIST_PER_PAGE - cur);\n\t\t\tcur = 0;\n\t\t\tcurPage++;\n\t\t}\n\t\treturn true;\n\t}", "idx": 235}
{"project": "bowtie2", "commit_id": "313_bowtie2_2.5.1_ds.h_reserveExact.cpp", "target": 0, "func": "inline void reserveExact(size_t newsz) {\n\t\tif(list_ == NULL) lazyInitExact(newsz);\n\t\texpandCopyExact(newsz);\n\t}", "idx": 236}
{"project": "bowtie2", "commit_id": "314_bowtie2_2.5.1_ds.h_push_back.cpp", "target": 0, "func": "void push_back(const T& el) {\n\t\tif(list_ == NULL) lazyInit();\n\t\tif(cur_ == sz_) expandCopy(sz_+1);\n\t\tlist_[cur_++] = el;\n\t}", "idx": 237}
{"project": "bowtie2", "commit_id": "315_bowtie2_2.5.1_ds.h_expand.cpp", "target": 0, "func": "void expand() {\n\t\tif(list_ == NULL) lazyInit();\n\t\tif(cur_ == sz_) expandCopy(sz_+1);\n\t\tcur_++;\n\t}", "idx": 238}
{"project": "bowtie2", "commit_id": "316_bowtie2_2.5.1_ds.h_fill.cpp", "target": 0, "func": "void fill(const T& v) {\n\t\tfor(size_t i = 0; i < cur_; i++) {\n\t\t\tlist_[i] = v;\n\t\t}\n\t}", "idx": 239}
{"project": "bowtie2", "commit_id": "317_bowtie2_2.5.1_ds.h_fillZero.cpp", "target": 0, "func": "void fillZero() {\n\t\tmemset(list_, 0, sizeof(T) * cur_);\n\t}", "idx": 240}
{"project": "bowtie2", "commit_id": "318_bowtie2_2.5.1_ds.h_resizeNoCopy.cpp", "target": 0, "func": "void resizeNoCopy(size_t sz) {\n\t\tif(sz > 0 && list_ == NULL) lazyInit();\n\t\tif(sz <= cur_) {\n\t\t\tcur_ = sz;\n\t\t\treturn;\n\t\t}\n\t\tif(sz_ < sz) expandNoCopy(sz);\n\t\tcur_ = sz;\n\t}", "idx": 241}
{"project": "bowtie2", "commit_id": "319_bowtie2_2.5.1_ds.h_resize.cpp", "target": 0, "func": "void resize(size_t off) {\n\t\tif((size_t)(off >> 3) >= l_.size()) {\n\t\t\tsize_t oldsz = l_.size();\n\t\t\tl_.resize((off >> 3) + 1);\n\t\t\tfor(size_t i = oldsz; i < l_.size(); i++) {\n\t\t\t\tl_[i] = 0;\n\t\t\t}\n\t\t}\n\t}", "idx": 242}
{"project": "bowtie2", "commit_id": "31_bowtie2_2.5.1_aligner_result.h_AlnScore.cpp", "target": 0, "func": "inline AlnScore(TAlScore score, int basesAligned, int edits, TAlScore ns, TAlScore gaps) {\n\t\tscore_ = score;\n\t\tbasesAligned_ = basesAligned;\n\t\tedits_ = edits;\n\t\tns_ = ns;\n\t\tgaps_ = gaps;\n\t\tassert(valid());\n\t}", "idx": 243}
{"project": "bowtie2", "commit_id": "320_bowtie2_2.5.1_ds.h_resizeExact.cpp", "target": 0, "func": "void resizeExact(size_t sz) {\n\t\tif(sz > 0 && list_ == NULL) lazyInitExact(sz);\n\t\tif(sz <= cur_) {\n\t\t\tcur_ = sz;\n\t\t\treturn;\n\t\t}\n\t\tif(sz_ < sz) expandCopyExact(sz);\n\t\tcur_ = sz;\n\t}", "idx": 244}
{"project": "bowtie2", "commit_id": "321_bowtie2_2.5.1_ds.h_erase.cpp", "target": 0, "func": "void erase(size_t idx) {\n\t\tassert_lt(idx, cur_);\n\t\tfor(size_t i = idx; i < cur_-1; i++) {\n\t\t\tlist_[i] = list_[i+1];\n\t\t}\n\t\tcur_--;\n\t\tassert(sorted());\n\t}", "idx": 245}
{"project": "bowtie2", "commit_id": "322_bowtie2_2.5.1_ds.h_insert.cpp", "target": 0, "func": "void insert(T o) {\n\t\tsize_t pos = l_.size();\n\t\tl_.push_back(o);\n\t\twhile(pos > 0) {\n\t\t\tsize_t parent = (pos-1) >> 1;\n\t\t\tif(l_[pos] < l_[parent]) {\n\t\t\t\tT tmp(l_[pos]);\n\t\t\t\tl_[pos] = l_[parent];\n\t\t\t\tl_[parent] = tmp;\n\t\t\t\tpos = parent;\n\t\t\t} else break;\n\t\t}\n\t\tassert(repOk());\n\t}", "idx": 246}
{"project": "bowtie2", "commit_id": "323_bowtie2_2.5.1_ds.h_pop_back.cpp", "target": 0, "func": "void pop_back() {\n\t\tassert_gt(cur_, 0);\n\t\tcur_--;\n\t}", "idx": 247}
{"project": "bowtie2", "commit_id": "324_bowtie2_2.5.1_ds.h_clear.cpp", "target": 0, "func": "void clear() {\n\t\tcur_ = curPage_ = 0;\n\t\troot_ = NULL;\n\t\tkeys_ = 0;\n\t\tintenseRepOkCnt_ = 0;\n\t\tpages_.clear();\n\t}", "idx": 248}
{"project": "bowtie2", "commit_id": "325_bowtie2_2.5.1_ds.h_reverse.cpp", "target": 0, "func": "void reverse() {\n\t\tif(cur_ > 1) {\n\t\t\tsize_t n = cur_ >> 1;\n\t\t\tfor(size_t i = 0; i < n; i++) {\n\t\t\t\tT tmp = list_[i];\n\t\t\t\tlist_[i] = list_[cur_ - i - 1];\n\t\t\t\tlist_[cur_ - i - 1] = tmp;\n\t\t\t}\n\t\t}\n\t}", "idx": 249}
{"project": "bowtie2", "commit_id": "326_bowtie2_2.5.1_ds.h_sortPortion.cpp", "target": 0, "func": "void sortPortion(size_t begin, size_t num) {\n\t\tassert_leq(begin+num, cur_);\n\t\tif(num < 2) return;\n\t\tstd::stable_sort(list_ + begin, list_ + begin + num);\n\t}", "idx": 250}
{"project": "bowtie2", "commit_id": "327_bowtie2_2.5.1_ds.h_shufflePortion.cpp", "target": 0, "func": "void shufflePortion(size_t begin, size_t num, RandomSource& rnd) {\n\t\tassert_leq(begin+num, cur_);\n\t\tif(num < 2) return;\n\t\tsize_t left = num;\n\t\tfor(size_t i = begin; i < begin + num - 1; i++) {\n\t\t\tsize_t rndi = rnd.nextSizeT() % left;\n\t\t\tif(rndi > 0) {\n\t\t\t\tstd::swap(list_[i], list_[i + rndi]);\n\t\t\t}\n\t\t\tleft--;\n\t\t}\n\t}", "idx": 251}
{"project": "bowtie2", "commit_id": "328_bowtie2_2.5.1_ds.h_sort.cpp", "target": 0, "func": "void sort() {\n\t\tsortPortion(0, cur_);\n\t}", "idx": 252}
{"project": "bowtie2", "commit_id": "329_bowtie2_2.5.1_ds.h_remove.cpp", "target": 0, "func": "void remove(const K& el) {\n\t\tsize_t i;\n\t\tif(cur_ < 16) {\n\t\t\t// Linear scan\n\t\t\ti = scanLoBound(el);\n\t\t} else {\n\t\t\t// Binary search\n\t\t\ti = bsearchLoBound(el);\n\t\t}\n\t\tassert(i != cur_ && list_[i].first == el);\n\t\terase(i);\n\t}", "idx": 253}
{"project": "bowtie2", "commit_id": "32_bowtie2_2.5.1_aligner_result.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tbestUScore_.invalidate();\n\t\tbestP1Score_.invalidate();\n\t\tbestP2Score_.invalidate();\n\t\tbestCScore_.invalidate();\n\t\tbestUDist_.invalidate();\n\t\tbestP1Dist_.invalidate();\n\t\tbestP2Dist_.invalidate();\n\t\tbestCDist_.invalidate();\n\t\tbestUnchosenUScore_.invalidate();\n\t\tbestUnchosenP1Score_.invalidate();\n\t\tbestUnchosenP2Score_.invalidate();\n\t\tbestUnchosenCScore_.invalidate();\n\t\tbestUnchosenUDist_.invalidate();\n\t\tbestUnchosenP1Dist_.invalidate();\n\t\tbestUnchosenP2Dist_.invalidate();\n\t\tbestUnchosenCDist_.invalidate();\n\t\tother1_ = other2_ = 0;\n\t\tpaired_ = false;\n\t\texhausted1_ = exhausted2_ = false;\n\t\torefid_ = -1;\n\t\torefoff_ = -1;\n\t}", "idx": 254}
{"project": "bowtie2", "commit_id": "330_bowtie2_2.5.1_ds.h_ptr.cpp", "target": 0, "func": "T *ptr() { return list_; }", "idx": 255}
{"project": "bowtie2", "commit_id": "331_bowtie2_2.5.1_ds.h_setCat.cpp", "target": 0, "func": "void setCat(int cat) {\n\t\tassert_gt(cat, 0);\n\t\tcat_ = cat;\n\t\tif(cat_ != 0) {\n\t\t\tfor(size_t i = 0; i < sz_; i++) {\n\t\t\t\tassert(list_[i].null());\n\t\t\t\tlist_[i].setCat(cat_);\n\t\t\t}\n\t\t}\n\t}", "idx": 256}
{"project": "bowtie2", "commit_id": "332_bowtie2_2.5.1_ds.h_lazyInit.cpp", "target": 0, "func": "void lazyInit() {\n\t\tassert(list_ == NULL);\n\t\tlist_ = alloc(sz_);\n\t}", "idx": 257}
{"project": "bowtie2", "commit_id": "333_bowtie2_2.5.1_ds.h_lazyInitExact.cpp", "target": 0, "func": "void lazyInitExact(size_t sz) {\n\t\tassert_gt(sz, 0);\n\t\tassert(list_ == NULL);\n\t\tsz_ = sz;\n\t\tlist_ = alloc(sz);\n\t}", "idx": 258}
{"project": "bowtie2", "commit_id": "334_bowtie2_2.5.1_ds.h_alloc.cpp", "target": 0, "func": "size_t alloc() {\n\t\tl_.expand();\n\t\treturn l_.size()-1;\n\t}", "idx": 259}
{"project": "bowtie2", "commit_id": "335_bowtie2_2.5.1_ds.h_expandCopy.cpp", "target": 0, "func": "void expandCopy(size_t thresh) {\n\t\tif(thresh <= sz_) return;\n\t\tsize_t newsz = sz_ * 2;\n\t\twhile(newsz < thresh) newsz *= 2;\n\t\tstd::pair<K, V>* tmp = alloc(newsz);\n\t\tfor(size_t i = 0; i < cur_; i++) {\n\t\t\ttmp[i] = list_[i];\n\t\t}\n\t\tfree();\n\t\tlist_ = tmp;\n\t\tsz_ = newsz;\n\t}", "idx": 260}
{"project": "bowtie2", "commit_id": "336_bowtie2_2.5.1_ds.h_expandCopyExact.cpp", "target": 0, "func": "void expandCopyExact(size_t newsz) {\n\t\tif(newsz <= sz_) return;\n\t\tT* tmp = alloc(newsz);\n\t\tassert(tmp != NULL);\n\t\tsize_t cur = cur_;\n\t\tif(list_ != NULL) {\n \t\t\tfor(size_t i = 0; i < cur_; i++) {\n\t\t\t\t// Note: operator= is used\n\t\t\t\ttmp[i] = list_[i];\n\t\t\t}\n\t\t\tfree();\n\t\t}\n\t\tlist_ = tmp;\n\t\tsz_ = newsz;\n\t\tcur_ = cur;\n\t}", "idx": 261}
{"project": "bowtie2", "commit_id": "337_bowtie2_2.5.1_ds.h_expandNoCopy.cpp", "target": 0, "func": "void expandNoCopy(size_t thresh) {\n\t\tassert(list_ != NULL);\n\t\tif(thresh <= sz_) return;\n\t\tfree();\n\t\tsize_t newsz = (sz_ * 2)+1;\n\t\twhile(newsz < thresh) newsz *= 2;\n\t\tESet<T>* tmp = alloc(newsz);\n\t\tlist_ = tmp;\n\t\tsz_ = newsz;\n\t\tassert_gt(sz_, 0);\n\t}", "idx": 262}
{"project": "bowtie2", "commit_id": "338_bowtie2_2.5.1_ds.h_expandNoCopyExact.cpp", "target": 0, "func": "void expandNoCopyExact(size_t newsz) {\n\t\tassert(list_ != NULL);\n\t\tassert_gt(newsz, 0);\n\t\tfree();\n\t\tT* tmp = alloc(newsz);\n\t\tassert(tmp != NULL);\n\t\tlist_ = tmp;\n\t\tsz_ = newsz;\n\t\tassert_gt(sz_, 0);\n\t}", "idx": 263}
{"project": "bowtie2", "commit_id": "339_bowtie2_2.5.1_ds.h_pop.cpp", "target": 0, "func": "void pop() {\n\t\tl_.resize(l_.size()-1);\n\t}", "idx": 264}
{"project": "bowtie2", "commit_id": "33_bowtie2_2.5.1_aligner_result.h_INVALID.cpp", "target": 0, "func": "inline static AlnScore INVALID() {\n\t\tAlnScore s;\n\t\ts.invalidate();\n\t\tassert(!s.valid());\n\t\treturn s;\n\t}", "idx": 265}
{"project": "bowtie2", "commit_id": "340_bowtie2_2.5.1_ds.h_set.cpp", "target": 0, "func": "void set(size_t off) {\n\t\tresize(off);\n\t\tl_[off >> 3] |= (1 << (off & 7));\n\t\tif(off > max_ || max_ == std::numeric_limits<size_t>::max()) {\n\t\t\tmax_ = off;\n\t\t}\n\t}", "idx": 266}
{"project": "bowtie2", "commit_id": "341_bowtie2_2.5.1_ds.h_top.cpp", "target": 0, "func": "T top() {\n\t\tassert_gt(l_.size(), 0);\n\t\treturn l_[0];\n\t}", "idx": 267}
{"project": "bowtie2", "commit_id": "342_bowtie2_2.5.1_ds.h_add.cpp", "target": 0, "func": "bool add(Pool& p, const EList<T>& os) {\n\t\tif(!ensure(p, os.size())) return false;\n\t\tfor(size_t i = 0; i < os.size(); i++) {\n\t\t\tif(cur_ == PLIST_PER_PAGE) {\n\t\t\t\tcur_ = 0;\n\t\t\t\tcurPage_++;\n\t\t\t}\n\t\t\tassert_lt(curPage_, pages_.size());\n\t\t\tassert(repOk());\n\t\t\tassert_lt(cur_, PLIST_PER_PAGE);\n\t\t\tpages_[curPage_][cur_++] = os[i];\n\t\t}\n\t\treturn true;\n\t}", "idx": 268}
{"project": "bowtie2", "commit_id": "343_bowtie2_2.5.1_ds.h_copy.cpp", "target": 0, "func": "bool copy(\n\t\tPool& p,\n\t\tconst PList<T, S>& src,\n\t\tsize_t i,\n\t\tsize_t len)\n\t{\n\t\tif(!ensure(p, src.size())) return false;\n\t\tfor(size_t i = 0; i < src.size(); i++) {\n\t\t\tif(cur_ == PLIST_PER_PAGE) {\n\t\t\t\tcur_ = 0;\n\t\t\t\tcurPage_++;\n\t\t\t}\n\t\t\tassert_lt(curPage_, pages_.size());\n\t\t\tassert(repOk());\n\t\t\tassert_lt(cur_, PLIST_PER_PAGE);\n\t\t\tpages_[curPage_][cur_++] = src[i];\n\t\t}\n\t\treturn true;\n\t}", "idx": 269}
{"project": "bowtie2", "commit_id": "344_bowtie2_2.5.1_ds.h_addFill.cpp", "target": 0, "func": "bool addFill(Pool& p, size_t num, const T& o) {\n\t\tif(!ensure(p, num)) return false;\n\t\tfor(size_t i = 0; i < num; i++) {\n\t\t\tif(cur_ == PLIST_PER_PAGE) {\n\t\t\t\tcur_ = 0;\n\t\t\t\tcurPage_++;\n\t\t\t}\n\t\t\tassert_lt(curPage_, pages_.size());\n\t\t\tassert(repOk());\n\t\t\tassert_lt(cur_, PLIST_PER_PAGE);\n\t\t\tpages_[curPage_][cur_++] = o;\n\t\t}\n\t\treturn true;\n\t}", "idx": 270}
{"project": "bowtie2", "commit_id": "345_bowtie2_2.5.1_ds.h_setLength.cpp", "target": 0, "func": "void setLength(size_t nlen) {\n\t\tlen_ = (TIndexOffU)nlen;\n\t}", "idx": 271}
{"project": "bowtie2", "commit_id": "346_bowtie2_2.5.1_ds.h_grandparent.cpp", "target": 0, "func": "RedBlackNode *grandparent() {\n\t\treturn parent != NULL ? parent->parent : NULL;\n\t}", "idx": 272}
{"project": "bowtie2", "commit_id": "347_bowtie2_2.5.1_ds.h_uncle.cpp", "target": 0, "func": "RedBlackNode *uncle() {\n\t\tif(parent == NULL) return NULL; // no parent\n\t\tif(parent->parent == NULL) return NULL; // parent has no siblings\n\t\treturn (parent->parent->left == parent) ? parent->parent->right : parent->parent->left;\n\t}", "idx": 273}
{"project": "bowtie2", "commit_id": "348_bowtie2_2.5.1_ds.h_replaceChild.cpp", "target": 0, "func": "void replaceChild(RedBlackNode* ol, RedBlackNode* nw) {\n\t\tif(left == ol) {\n\t\t\tleft = nw;\n\t\t} else {\n\t\t\tassert(right == ol);\n\t\t\tright = nw;\n\t\t}\n\t}", "idx": 274}
{"project": "bowtie2", "commit_id": "349_bowtie2_2.5.1_ds.h_addNode.cpp", "target": 0, "func": "bool addNode(Pool& p, TNode*& node) {\n\t\tassert_leq(cur_, perPage_);\n\t\tassert(repOk());\n\t\tassert(this != NULL);\n\t\t// Allocation of the first page\n\t\tif(pages_.size() == 0) {\n\t\t\tif(addPage(p) == NULL) {\n\t\t\t\tnode = NULL;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tassert_eq(1, pages_.size());\n\t\t}\n\t\tif(cur_ == perPage_) {\n\t\t\tassert_lt(curPage_, pages_.size());\n\t\t\tif(curPage_ == pages_.size()-1 && addPage(p) == NULL) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcur_ = 0;\n\t\t\tcurPage_++;\n\t\t}\n\t\tassert_lt(cur_, perPage_);\n\t\tassert_lt(curPage_, pages_.size());\n\t\tnode = &pages_[curPage_][cur_];\n\t\tassert(node != NULL);\n\t\tcur_++;\n\t\treturn true;\n\t}", "idx": 275}
{"project": "bowtie2", "commit_id": "34_bowtie2_2.5.1_aligner_result.h_invalidate.cpp", "target": 0, "func": "inline void invalidate() {\n\t\tscore_ = MIN_I64;\n\t\tedits_ = basesAligned_ = std::numeric_limits<int>::min();\n\t\tns_ = gaps_ = 0;\n\t\tassert(!valid());\n\t}", "idx": 276}
{"project": "bowtie2", "commit_id": "350_bowtie2_2.5.1_ds.h_redBlackRepOk.cpp", "target": 0, "func": "bool redBlackRepOk(TNode* n) {\n\t\tif(n == NULL) return true;\n\t\tif(++intenseRepOkCnt_ < 500) return true;\n\t\tintenseRepOkCnt_ = 0;\n\t\tint minNodes = -1; // min # nodes along any n->leaf path\n\t\tint maxNodes = -1; // max # nodes along any n->leaf path\n\t\t// The number of black nodes along paths from n to leaf\n\t\t// (must be same for all paths)\n\t\tint blackConst = -1;\n\t\tsize_t nodesTot = 0;\n\t\tredBlackRepOk(\n\t\t\tn,\n\t\t\t1, /* 1 node so far */\n\t\t\tn->red ? 0 : 1, /* black nodes so far */\n\t\t\tblackConst,\n\t\t\tminNodes,\n\t\t\tmaxNodes,\n\t\t\tnodesTot);\n\t\tif(n == root_) {\n\t\t\tassert_eq(nodesTot, keys_);\n\t\t}\n\t\tassert_gt(minNodes, 0);\n\t\tassert_gt(maxNodes, 0);\n\t\tassert_leq(maxNodes, 2*minNodes);\n\t\treturn true;\n\t}", "idx": 277}
{"project": "bowtie2", "commit_id": "351_bowtie2_2.5.1_ds.h_leftRotate.cpp", "target": 0, "func": "void leftRotate(TNode* n) {\n\t\tTNode* r = n->right;\n\t\tassert(n->repOk());\n\t\tassert(r->repOk());\n\t\tn->right = r->left;\n\t\tif(n->right != NULL) {\n\t\t\tn->right->parent = n;\n\t\t\tassert(n->right->repOk());\n\t\t}\n\t\tr->parent = n->parent;\n\t\tn->parent = r;\n\t\tr->left = n;\n\t\tif(r->parent != NULL) {\n\t\t\tr->parent->replaceChild(n, r);\n\t\t}\n\t\tif(root_ == n) root_ = r;\n\t\tassert(!root_->red);\n\t\tassert(n->repOk());\n\t\tassert(r->repOk());\n\t}", "idx": 278}
{"project": "bowtie2", "commit_id": "352_bowtie2_2.5.1_ds.h_rightRotate.cpp", "target": 0, "func": "void rightRotate(TNode* n) {\n\t\tTNode* r = n->left;\n\t\tassert(n->repOk());\n\t\tassert(r->repOk());\n\t\tn->left = r->right;\n\t\tif(n->left != NULL) {\n\t\t\tn->left->parent = n;\n\t\t\tassert(n->left->repOk());\n\t\t}\n\t\tr->parent = n->parent;\n\t\tn->parent = r;\n\t\tr->right = n;\n\t\tif(r->parent != NULL) {\n\t\t\tr->parent->replaceChild(n, r);\n\t\t}\n\t\tif(root_ == n) root_ = r;\n\t\tassert(!root_->red);\n\t\tassert(n->repOk());\n\t\tassert(r->repOk());\n\t}", "idx": 279}
{"project": "bowtie2", "commit_id": "353_bowtie2_2.5.1_ds.h_toList.cpp", "target": 0, "func": "void toList(EList<T>& l) {\n\t\t// Add this and all subsequent elements\n\t\tDoublyLinkedList<T> *cur = this;\n\t\twhile(cur != NULL) {\n\t\t\tl.push_back(cur->payload);\n\t\t\tcur = cur->next;\n\t\t}\n\t\t// Add all previous elements\n\t\tcur = prev;\n\t\twhile(cur != NULL) {\n\t\t\tl.push_back(cur->payload);\n\t\t\tcur = cur->prev;\n\t\t}\n\t}", "idx": 280}
{"project": "bowtie2", "commit_id": "354_bowtie2_2.5.1_edit.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tpos = pos2 = std::numeric_limits<uint32_t>::max();\n\t\tchr = qchr = type = 0;\n\t}", "idx": 281}
{"project": "bowtie2", "commit_id": "355_bowtie2_2.5.1_edit.h_init.cpp", "target": 0, "func": "void init(\n\t\tuint32_t po,\n\t\tint ch,\n\t\tint qc,\n\t\tint ty,\n\t\tbool chrs = true)\n\t{\n\t\tchr = ch;\n\t\tqchr = qc;\n\t\ttype = ty;\n\t\tpos = po;\n\t\tif(qc == '-') {\n\t\t\t// Read gap\n\t\t\tpos2 = std::numeric_limits<uint32_t>::max() >> 1;\n\t\t} else {\n\t\t\tpos2 = std::numeric_limits<uint32_t>::max();\n\t\t}\n\t\tif(!chrs) {\n\t\t\tassert_range(0, 4, (int)chr);\n\t\t\tassert_range(0, 4, (int)qchr);\n\t\t\tchr = \"ACGTN\"[chr];\n\t\t\tqchr = \"ACGTN\"[qchr];\n\t\t}\n\t\tassert_in(chr, \"ACMGRSVTWYHKDBN-\");\n\t\tassert_in(qchr, \"ACGTN-\");\n\t\tassert(chr != qchr || chr == 'N');\n\t\tassert(inited());\n\t}", "idx": 282}
{"project": "bowtie2", "commit_id": "356_bowtie2_2.5.1_edit.h_numGaps.cpp", "target": 0, "func": "static size_t numGaps(const EList<Edit>& es) {\n\t\tsize_t gaps = 0;\n\t\tfor(size_t i = 0; i < es.size(); i++) {\n\t\t\tif(es[i].isGap()) gaps++;\n\t\t}\n\t\treturn gaps;\n\t}", "idx": 283}
{"project": "bowtie2", "commit_id": "357_bowtie2_2.5.1_edit.h_invertPoss.cpp", "target": 0, "func": "static void invertPoss(EList<Edit>& edits, size_t sz, bool sort = false) {\n\t\tinvertPoss(edits, sz, 0, edits.size(), sort);\n\t}", "idx": 284}
{"project": "bowtie2", "commit_id": "358_bowtie2_2.5.1_endian_swap.h_currentlyBigEndian.cpp", "target": 0, "func": "static inline bool currentlyBigEndian() {\n\tstatic uint8_t endianCheck[] = {1, 0, 0, 0};\n\treturn *((uint32_t*)endianCheck) != 1;\n}", "idx": 285}
{"project": "bowtie2", "commit_id": "359_bowtie2_2.5.1_endian_swap.h_endianSwapU16.cpp", "target": 0, "func": "static inline uint16_t endianSwapU16(uint16_t u) {\n\tuint16_t tmp = 0;\n\ttmp |= ((u >> 8) & (0xff << 0));\n\ttmp |= ((u << 8) & (0xff << 8));\n\treturn tmp;\n}", "idx": 286}
{"project": "bowtie2", "commit_id": "35_bowtie2_2.5.1_aligner_result.h_incNs.cpp", "target": 0, "func": "inline void incNs(int nceil) {\n\t\tif(++ns_ > nceil) {\n\t\t\tinvalidate();\n\t\t}\n\t\tassert_lt(ns_, 0x7fffffff);\n\t}", "idx": 287}
{"project": "bowtie2", "commit_id": "360_bowtie2_2.5.1_endian_swap.h_endianSwapU32.cpp", "target": 0, "func": "static inline uint32_t endianSwapU32(uint32_t u) {\n\tuint32_t tmp = 0;\n\ttmp |= ((u >> 24) & (0xff <<  0));\n\ttmp |= ((u >>  8) & (0xff <<  8));\n\ttmp |= ((u <<  8) & (0xff << 16));\n\ttmp |= ((u << 24) & (0xff << 24));\n\treturn tmp;\n}", "idx": 288}
{"project": "bowtie2", "commit_id": "361_bowtie2_2.5.1_endian_swap.h_endianSwapU64.cpp", "target": 0, "func": "static inline uint64_t endianSwapU64(uint64_t u) {\n\tuint64_t tmp = 0;\n\ttmp |= ((u >> 56) & (0xffull <<  0));\n\ttmp |= ((u >> 40) & (0xffull <<  8));\n\ttmp |= ((u >> 24) & (0xffull << 16));\n\ttmp |= ((u >>  8) & (0xffull << 24));\n\ttmp |= ((u <<  8) & (0xffull << 32));\n\ttmp |= ((u << 24) & (0xffull << 40));\n\ttmp |= ((u << 40) & (0xffull << 48));\n\ttmp |= ((u << 56) & (0xffull << 56));\n\treturn tmp;\n}", "idx": 289}
{"project": "bowtie2", "commit_id": "362_bowtie2_2.5.1_endian_swap.h_endianSwapI32.cpp", "target": 0, "func": "static inline int32_t endianSwapI32(int32_t i) {\n\tint32_t tmp = 0;\n\ttmp |= ((i >> 24) & (0xff <<  0));\n\ttmp |= ((i >>  8) & (0xff <<  8));\n\ttmp |= ((i <<  8) & (0xff << 16));\n\ttmp |= ((i << 24) & (0xff << 24));\n\treturn tmp;\n}", "idx": 290}
{"project": "bowtie2", "commit_id": "363_bowtie2_2.5.1_endian_swap.h_endianSwapI64.cpp", "target": 0, "func": "static inline int64_t endianSwapI64(int64_t u) {\n        int64_t tmp = 0;\n        tmp |= ((u >> 56) & (0xffull <<  0));\n        tmp |= ((u >> 40) & (0xffull <<  8));\n        tmp |= ((u >> 24) & (0xffull << 16));\n        tmp |= ((u >>  8) & (0xffull << 24));\n        tmp |= ((u <<  8) & (0xffull << 32));\n        tmp |= ((u << 24) & (0xffull << 40));\n        tmp |= ((u << 40) & (0xffull << 48));\n        tmp |= ((u << 56) & (0xffull << 56));\n        return tmp;\n}", "idx": 291}
{"project": "bowtie2", "commit_id": "364_bowtie2_2.5.1_endian_swap.h_endianizeU.cpp", "target": 0, "func": "static inline T endianizeU(T u, bool switchEndian) {\n\tif(!switchEndian) {\n\t\treturn u;\n\t}\n\tif(sizeof(T) == 4) {\n\t\treturn (T)endianSwapU32((uint32_t)u);\n\t} else if(sizeof(T) == 8) {\n\t\treturn (T)endianSwapU64((uint64_t)u);\n\t} else {\n\t\tassert(false);\n\t}\n}", "idx": 292}
{"project": "bowtie2", "commit_id": "365_bowtie2_2.5.1_endian_swap.h_endianizeI.cpp", "target": 0, "func": "static inline T endianizeI(T i, bool switchEndian) {\n\tif(!switchEndian) {\n\t\treturn i;\n\t}\n\tif(sizeof(T) == 4) {\n\t\treturn endianSwapI32((int32_t)i);\n\t} else if(sizeof(T) == 8) {\n\t\treturn endianSwapI64((int64_t)i);\n\t} else {\n\t\tassert(false);\n\t}\n}", "idx": 293}
{"project": "bowtie2", "commit_id": "366_bowtie2_2.5.1_fast_mutex.h_fast_mutex.cpp", "target": 0, "func": "else\n    fast_mutex()\n    {\n  #if defined(_TTHREAD_WIN32_)\n      InitializeCriticalSection(&mHandle);\n  #elif defined(_TTHREAD_POSIX_)\n      pthread_mutex_init(&mHandle, NULL);\n  #endif\n    }", "idx": 294}
{"project": "bowtie2", "commit_id": "367_bowtie2_2.5.1_fast_mutex.h_lock.cpp", "target": 0, "func": "see lock_guard\n    inline void lock()\n    {\n#if defined(_FAST_MUTEX_ASM_)\n      bool gotLock;\n      do {\n        gotLock = try_lock();\n        if(!gotLock)\n        {\n  #if defined(_TTHREAD_WIN32_)\n          Sleep(0);\n  #elif defined(_TTHREAD_POSIX_)\n          sched_yield();\n  #endif\n        }\n      } while(!gotLock);\n#else\n  #if defined(_TTHREAD_WIN32_)\n      EnterCriticalSection(&mHandle);\n  #elif defined(_TTHREAD_POSIX_)\n      pthread_mutex_lock(&mHandle);\n  #endif\n#endif\n    }", "idx": 295}
{"project": "bowtie2", "commit_id": "368_bowtie2_2.5.1_fast_mutex.h_try_lock.cpp", "target": 0, "func": "inline bool try_lock()\n    {\n#if defined(_FAST_MUTEX_ASM_)\n      int oldLock;\n  #if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))\n      asm volatile (\n        \"movl $1,%%eax\\n\\t\"\n        \"xchg %%eax,%0\\n\\t\"\n        \"movl %%eax,%1\\n\\t\"\n        : \"=m\" (mLock), \"=m\" (oldLock)\n        :\n        : \"%eax\", \"memory\"\n      );\n  #elif defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_X64))\n      int *ptrLock = &mLock;\n      __asm {\n        mov eax,1\n        mov ecx,ptrLock\n        xchg eax,[ecx]\n        mov oldLock,eax\n      }\n  #elif defined(__GNUC__) && (defined(__ppc__))\n      int newLock = 1;\n      asm volatile (\n        \"\\n1:\\n\\t\"\n        \"lwarx  %0,0,%1\\n\\t\"\n        \"cmpwi  0,%0,0\\n\\t\"\n        \"bne-   2f\\n\\t\"\n        \"stwcx. %2,0,%1\\n\\t\"\n        \"bne-   1b\\n\\t\"\n        \"isync\\n\"\n        \"2:\\n\\t\"\n        : \"=&r\" (oldLock)\n        : \"r\" (&mLock), \"r\" (newLock)\n        : \"cr0\", \"memory\"\n      );\n  #endif\n      return (oldLock == 0);\n#else\n  #if defined(_TTHREAD_WIN32_)\n      return TryEnterCriticalSection(&mHandle) ? true : false;\n  #elif defined(_TTHREAD_POSIX_)\n      return (pthread_mutex_trylock(&mHandle) == 0) ? true : false;\n  #endif\n#endif\n    }", "idx": 296}
{"project": "bowtie2", "commit_id": "369_bowtie2_2.5.1_fast_mutex.h_unlock.cpp", "target": 0, "func": "inline void unlock()\n    {\n#if defined(_FAST_MUTEX_ASM_)\n  #if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))\n      asm volatile (\n        \"movl $0,%%eax\\n\\t\"\n        \"xchg %%eax,%0\\n\\t\"\n        : \"=m\" (mLock)\n        :\n        : \"%eax\", \"memory\"\n      );\n  #elif defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_X64))\n      int *ptrLock = &mLock;\n      __asm {\n        mov eax,0\n        mov ecx,ptrLock\n        xchg eax,[ecx]\n      }\n  #elif defined(__GNUC__) && (defined(__ppc__))\n      asm volatile (\n        \"sync\\n\\t\"  // Replace with lwsync where possible?\n        : : : \"memory\"\n      );\n      mLock = 0;\n  #endif\n#else\n  #if defined(_TTHREAD_WIN32_)\n      LeaveCriticalSection(&mHandle);\n  #elif defined(_TTHREAD_POSIX_)\n      pthread_mutex_unlock(&mHandle);\n  #endif\n#endif\n    }", "idx": 297}
{"project": "bowtie2", "commit_id": "36_bowtie2_2.5.1_aligner_result.h_init.cpp", "target": 0, "func": "void init(\n\t\tTNumAlns other1,\n\t\tTNumAlns other2,\n\t\tbool     paired,\n\t\tbool     exhausted1,\n\t\tbool     exhausted2,\n\t\tTRefId   orefid,\n\t\tTRefOff  orefoff)\n\t{\n\t\tother1_        = other1;\n\t\tother2_        = other2;\n\t\tpaired_        = paired;\n\t\texhausted1_    = exhausted1;\n\t\texhausted2_    = exhausted2;\n\t\torefid_        = orefid;\n\t\torefoff_       = orefoff;\n\t\tassert(repOk());\n\t}", "idx": 298}
{"project": "bowtie2", "commit_id": "370_bowtie2_2.5.1_filebuf.h_isnewline.cpp", "target": 0, "func": "static inline bool isnewline(int c) {\n\treturn c == '\\r' || c == '\\n';\n}", "idx": 299}
{"project": "bowtie2", "commit_id": "371_bowtie2_2.5.1_filebuf.h_isspace_notnl.cpp", "target": 0, "func": "static inline bool isspace_notnl(int c) {\n\treturn isspace(c) && !isnewline(c);\n}", "idx": 300}
{"project": "bowtie2", "commit_id": "372_bowtie2_2.5.1_filebuf.h_FileBuf.cpp", "target": 0, "func": "endif\n\n\tFileBuf(std::ifstream *inf) {\n\t\tinit();\n\t\t_inf = inf;\n\t\tassert(_inf != NULL);\n\t}", "idx": 301}
{"project": "bowtie2", "commit_id": "373_bowtie2_2.5.1_filebuf.h_isOpen.cpp", "target": 0, "func": "bool isOpen() {\n\t\treturn _in != NULL || _inf != NULL || _ins != NULL;\n\t}", "idx": 302}
{"project": "bowtie2", "commit_id": "374_bowtie2_2.5.1_filebuf.h_close.cpp", "target": 0, "func": "void close() {\n\t\tif(closed_) return;\n\t\tif(cur_ > 0) flush();\n\t\tasyncData_.waitIdle();\n\t\tclosed_ = true;\n\t\tif(out_ != stdout) {\n\t\t\tfclose(out_);\n\t\t}\n\t}", "idx": 303}
{"project": "bowtie2", "commit_id": "375_bowtie2_2.5.1_filebuf.h_get.cpp", "target": 0, "func": "size_t get(char *buf, size_t len) {\n\t\tsize_t stored = 0;\n\t\tfor(size_t i = 0; i < len; i++) {\n\t\t\tint c = get();\n\t\t\tif(c == -1) return i;\n\t\t\tbuf[stored++] = (char)c;\n\t\t}\n\t\treturn len;\n\t}", "idx": 304}
{"project": "bowtie2", "commit_id": "376_bowtie2_2.5.1_filebuf.h_eof.cpp", "target": 0, "func": "bool eof() {\n\t\treturn (_cur == _buf_sz) && _done;\n\t}", "idx": 305}
{"project": "bowtie2", "commit_id": "377_bowtie2_2.5.1_filebuf.h_newFile.cpp", "target": 0, "func": "void newFile(std::istream *__ins) {\n\t\t_in = NULL;\n\t\t_zIn = NULL;\n\t\t_inf = NULL;\n\t\t_ins = __ins;\n#ifdef WITH_ZSTD\n\t\t_zstdIn = NULL;\n#endif\n\t\t_cur = BUF_SZ;\n\t\t_buf_sz = BUF_SZ;\n\t\t_done = false;\n\t}", "idx": 306}
{"project": "bowtie2", "commit_id": "378_bowtie2_2.5.1_filebuf.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tcur_ = 0;\n\t\tclosed_ = false;\n\t}", "idx": 307}
{"project": "bowtie2", "commit_id": "379_bowtie2_2.5.1_filebuf.h_getPastWhitespace.cpp", "target": 0, "func": "int getPastWhitespace() {\n\t\tint c;\n\t\twhile(isspace(c = get()) && c != -1);\n\t\treturn c;\n\t}", "idx": 308}
{"project": "bowtie2", "commit_id": "37_bowtie2_2.5.1_aligner_result.h_setPrimary.cpp", "target": 0, "func": "void setPrimary(bool primary) {\n\t\tprimary_ = primary;\n\t}", "idx": 309}
{"project": "bowtie2", "commit_id": "380_bowtie2_2.5.1_filebuf.h_getPastNewline.cpp", "target": 0, "func": "int getPastNewline() {\n\t\tint c = get();\n\t\twhile(!isnewline(c) && c != -1) c = get();\n\t\twhile(isnewline(c)) c = get();\n\t\tassert_neq(c, '\\r');\n\t\tassert_neq(c, '\\n');\n\t\treturn c;\n\t}", "idx": 310}
{"project": "bowtie2", "commit_id": "381_bowtie2_2.5.1_filebuf.h_peekPastNewline.cpp", "target": 0, "func": "int peekPastNewline() {\n\t\tint c = peek();\n\t\twhile(!isnewline(c) && c != -1) c = get();\n\t\twhile(isnewline(c)) c = get();\n\t\tassert_neq(c, '\\r');\n\t\tassert_neq(c, '\\n');\n\t\treturn c;\n\t}", "idx": 311}
{"project": "bowtie2", "commit_id": "382_bowtie2_2.5.1_filebuf.h_peekUptoNewline.cpp", "target": 0, "func": "int peekUptoNewline() {\n\t\tint c = peek();\n\t\twhile(!isnewline(c) && c != -1) {\n\t\t\tget(); c = peek();\n\t\t}\n\t\twhile(isnewline(c)) {\n\t\t\tget();\n\t\t\tc = peek();\n\t\t}\n\t\tassert_neq(c, '\\r');\n\t\tassert_neq(c, '\\n');\n\t\treturn c;\n\t}", "idx": 312}
{"project": "bowtie2", "commit_id": "383_bowtie2_2.5.1_filebuf.h_parseFastaRecord.cpp", "target": 0, "func": "void parseFastaRecord(\n\t\tTNameStr& name,\n\t\tTSeqStr&  seq,\n\t\tbool      gotCaret = false)\n\t{\n\t\tint c;\n\t\tif(!gotCaret) {\n\t\t\t// Skip over caret and non-newline whitespace\n\t\t\tc = peek();\n\t\t\twhile(isspace_notnl(c) || c == '>') { get(); c = peek(); }\n\t\t} else {\n\t\t\t// Skip over non-newline whitespace\n\t\t\tc = peek();\n\t\t\twhile(isspace_notnl(c)) { get(); c = peek(); }\n\t\t}\n\t\tsize_t namecur = 0, seqcur = 0;\n\t\t// c is the first character of the fasta name record, or is the first\n\t\t// newline character if the name record is empty\n\t\twhile(!isnewline(c) && c != -1) {\n\t\t\tname[namecur++] = c; get(); c = peek();\n\t\t}\n\t\t// sequence consists of all the non-whitespace characters between here\n\t\t// and the next caret\n\t\twhile(true) {\n\t\t\t// skip over whitespace\n\t\t\twhile(isspace(c)) { get(); c = peek(); }\n\t\t\t// if we see caret or EOF, break\n\t\t\tif(c == '>' || c == -1) break;\n\t\t\t// append and continue\n\t\t\tseq[seqcur++] = c;\n\t\t\tget(); c = peek();\n\t\t}\n\t}", "idx": 313}
{"project": "bowtie2", "commit_id": "384_bowtie2_2.5.1_filebuf.h_parseFastaRecordLength.cpp", "target": 0, "func": "void parseFastaRecordLength(\n\t\tsize_t&   nameLen,\n\t\tsize_t&   seqLen,\n\t\tbool      gotCaret = false)\n\t{\n\t\tint c;\n\t\tnameLen = seqLen = 0;\n\t\tif(!gotCaret) {\n\t\t\t// Skip over caret and non-newline whitespace\n\t\t\tc = peek();\n\t\t\twhile(isspace_notnl(c) || c == '>') { get(); c = peek(); }\n\t\t} else {\n\t\t\t// Skip over non-newline whitespace\n\t\t\tc = peek();\n\t\t\twhile(isspace_notnl(c)) { get(); c = peek(); }\n\t\t}\n\t\t// c is the first character of the fasta name record, or is the first\n\t\t// newline character if the name record is empty\n\t\twhile(!isnewline(c) && c != -1) {\n\t\t\tnameLen++; get(); c = peek();\n\t\t}\n\t\t// sequence consists of all the non-whitespace characters between here\n\t\t// and the next caret\n\t\twhile(true) {\n\t\t\t// skip over whitespace\n\t\t\twhile(isspace(c)) { get(); c = peek(); }\n\t\t\t// if we see caret or EOF, break\n\t\t\tif(c == '>' || c == -1) break;\n\t\t\t// append and continue\n\t\t\tseqLen++;\n\t\t\tget(); c = peek();\n\t\t}\n\t}", "idx": 314}
{"project": "bowtie2", "commit_id": "385_bowtie2_2.5.1_filebuf.h_resetLastN.cpp", "target": 0, "func": "void resetLastN() {\n\t\t_lastn_cur = 0;\n\t}", "idx": 315}
{"project": "bowtie2", "commit_id": "386_bowtie2_2.5.1_filebuf.h_copyLastN.cpp", "target": 0, "func": "size_t copyLastN(char *buf) {\n\t\tmemcpy(buf, _lastn_buf, _lastn_cur);\n\t\treturn _lastn_cur;\n\t}", "idx": 316}
{"project": "bowtie2", "commit_id": "387_bowtie2_2.5.1_filebuf.h_init.cpp", "target": 0, "func": "void init() {\n\t\t_in = NULL;\n\t\t_zIn = NULL;\n\t\t_inf = NULL;\n\t\t_ins = NULL;\n#ifdef WITH_ZSTD\n\t\t_zstdIn = NULL;\n#endif\n\t\t_cur = _buf_sz = BUF_SZ;\n\t\t_done = false;\n\t\t_lastn_cur = 0;\n\t\t// no need to clear _buf[]\n\t}", "idx": 317}
{"project": "bowtie2", "commit_id": "388_bowtie2_2.5.1_filebuf.h_setFile.cpp", "target": 0, "func": "void setFile(const char *out, bool binary = false) {\n\t\tassert(out != NULL);\n\t\tout_ = fopen(out, binary ? \"wb\" : \"w\");\n\t\tif(out_ == NULL) {\n\t\t\tstd::cerr << \"Error: Could not open alignment output file \" << out << std::endl;\n\t\t\tthrow 1;\n\t\t}\n\t\treset();\n\t}", "idx": 318}
{"project": "bowtie2", "commit_id": "389_bowtie2_2.5.1_filebuf.h_write.cpp", "target": 0, "func": "void write(char c) {\n\t\tassert(!closed_);\n\t\tif(cur_ == cap_) {\n\t\t\tif(flushBlocking() && (cap_<MAX_BUF_SZ)) {\n\t\t\t\t// minimize blocking, increase buffer instead\n\t\t\t\tincreaseBuffer(BUF_SZ);\n\t\t\t} else {\n\t\t\t\tflush();\n\t\t\t}\n\t\t}\n\t\tbuf_[cur_++] = c;\n\t}", "idx": 319}
{"project": "bowtie2", "commit_id": "38_bowtie2_2.5.1_aligner_result.h_reverseEdits.cpp", "target": 0, "func": "void reverseEdits() {\n\t\tned_.reverse();\n\t\taed_.reverse();\n\t}", "idx": 320}
{"project": "bowtie2", "commit_id": "390_bowtie2_2.5.1_filebuf.h_writeString.cpp", "target": 0, "func": "void writeString(const T& s) {\n\t\tassert(!closed_);\n\t\tsize_t slen = s.length();\n\t\tconst char *zbuf = s.toZBuf();\n\t\twriteChars(zbuf, slen);\n\t}", "idx": 321}
{"project": "bowtie2", "commit_id": "391_bowtie2_2.5.1_filebuf.h_writeChars.cpp", "target": 0, "func": "void writeChars(const char * s) {\n\t\twriteChars(s, strlen(s));\n\t}", "idx": 322}
{"project": "bowtie2", "commit_id": "392_bowtie2_2.5.1_filebuf.h_flush.cpp", "target": 0, "func": "void flush() {\n\t\t// there still could have been an outstanding async write\n\t\tasyncData_.waitIdle();\n\t\t// start the async write\n\t\tasyncData_.setBuf(buf_, cur_);\n\t\t// switch to the other buffer\n\t\tif(buf_==buf1_) {\n\t\t\tbuf_ = buf2_;\n\t\t\tcap_ = cap2_;\n\t\t} else {\n\t\t\tbuf_ = buf1_;\n\t\t\tcap_ = cap1_;\n\t\t}\n\t\tcur_ = 0;\n\t}", "idx": 323}
{"project": "bowtie2", "commit_id": "393_bowtie2_2.5.1_filebuf.h_name.cpp", "target": 0, "func": "const char *name() {\n\t\treturn name_;\n\t}", "idx": 324}
{"project": "bowtie2", "commit_id": "394_bowtie2_2.5.1_filebuf.h_resizeBufferNoCopy.cpp", "target": 0, "func": "increase the current buffer to at least len\n\tvoid resizeBufferNoCopy(size_t len) {\n\t\tassert_eq(cur_, 0);\n\t\t// round up to multiple of BUF_SZ\n\t\tconst size_t newCap = roundBufferSize(len);\n\t\tbool is1 = (buf_==buf1_);\n\t\tbuf_ = _resizeSpecificBufferNoCopy(newCap,\n\t\t\t\t\t\tis1 ? buf1_ : buf2_,\n\t\t\t\t\t\tis1 ? cap1_ : cap2_);\n\t\tcap_ = newCap;\n\t}", "idx": 325}
{"project": "bowtie2", "commit_id": "395_bowtie2_2.5.1_filebuf.h_resizeBuffer.cpp", "target": 0, "func": "copy over the content\n\tvoid resizeBuffer(size_t len) {\n\t\tif(cur_==0) {\n\t\t\t// nothing to copy, use the more efficient version\n\t\t\tresizeBufferNoCopy(len);\n\t\t\treturn;\n\t\t}\n\n\t\t// round up to multiple of BUF_SZ\n\t\tsize_t newCap = roundBufferSize(len);\n\t\tbool is1 = (buf_==buf1_);\n\t\tbuf_ = _resizeSpecificBufferCopy(newCap, cur_,\n\t\t\t\t\t\tis1 ? buf1_ : buf2_,\n\t\t\t\t\t\tis1 ? cap1_ : cap2_);\n\t\tcap_ = newCap;\n\t}", "idx": 326}
{"project": "bowtie2", "commit_id": "396_bowtie2_2.5.1_filebuf.h_increaseBuffer.cpp", "target": 0, "func": "copy over the content\n\tvoid increaseBuffer(size_t delta) {\n\t\tsize_t newCap = cap_+delta;\n\t\tresizeBuffer(newCap);\n\t}", "idx": 327}
{"project": "bowtie2", "commit_id": "397_bowtie2_2.5.1_filebuf.h_notifyAbort.cpp", "target": 0, "func": "void notifyAbort() {\n\t\t\t{\n\t\t\t\tstd::lock_guard<std::mutex> lk(m);\n\t\t\t\tabort = true;\n\t\t\t}\n\t\t\tcv.notify_all();\n\t\t}", "idx": 328}
{"project": "bowtie2", "commit_id": "398_bowtie2_2.5.1_filebuf.h_waitIdle.cpp", "target": 0, "func": "void waitIdle() {\n\t\t\tstd::unique_lock<std::mutex> lk(m);\n\t\t\twhile(buf!=NULL) cv.wait(lk);\n\t\t}", "idx": 329}
{"project": "bowtie2", "commit_id": "399_bowtie2_2.5.1_filebuf.h_setBuf.cpp", "target": 0, "func": "void setBuf(const char* _buf, size_t _cur) {\n\t\t\t{\n\t\t\t\tstd::lock_guard<std::mutex> lk(m);\n\t\t\t\tbuf = _buf;\n\t\t\t\tcur = _cur;\n\t\t\t}\n\t\t\tcv.notify_all();\n\t\t}", "idx": 330}
{"project": "bowtie2", "commit_id": "39_bowtie2_2.5.1_aligner_result.h_invertEdits.cpp", "target": 0, "func": "void invertEdits() {\n\t\tassert(shapeSet_);\n\t\tassert_gt(rdlen_, 0);\n\t\tassert_gt(rdrows_, 0);\n\t\tEdit::invertPoss(ned_, rdexrows_, false);\n\t\tEdit::invertPoss(aed_, rdexrows_, false);\n\t}", "idx": 331}
{"project": "bowtie2", "commit_id": "3_bowtie2_2.5.1_aligner_bt.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tparentId_ = 0;\n\t\tscore_st_ = score_en_ = len_ = row_ = col_ = 0;\n\t\tcurtailed_ = false;\n\t\te_.reset();\n\t}", "idx": 332}
{"project": "bowtie2", "commit_id": "400_bowtie2_2.5.1_filebuf.h_waitForBuf.cpp", "target": 0, "func": "returns abort\n\t\tbool waitForBuf() {\n\t\t\tstd::unique_lock<std::mutex> lk(m);\n\t\t\twhile((buf==NULL)&&(!abort)) cv.wait(lk);\n\t\t\treturn abort;\n\t\t}", "idx": 333}
{"project": "bowtie2", "commit_id": "401_bowtie2_2.5.1_filebuf.h_writeComplete.cpp", "target": 0, "func": "returns abort\n\t\tbool writeComplete() {\n\t\t\tbool ret;\n\t\t\t{\n\t\t\t\tstd::lock_guard<std::mutex> lk(m);\n\t\t\t\tbuf = NULL;\n\t\t\t\tret = abort;\n\t\t\t}\n\t\t\tcv.notify_all();\n\t\t\treturn ret;\n\t\t}", "idx": 334}
{"project": "bowtie2", "commit_id": "402_bowtie2_2.5.1_group_walk.h_init.cpp", "target": 0, "func": "void init(\n\t\tSARangeWithOffs<T>& sa,\n\t\tTIndexOffU oi,\n\t\tbool f,\n\t\tTIndexOffU r)\n\t{\n\t\tnrep_ = 0;\n\t\toffidx = oi;\n\t\tfw = f;\n\t\trange = r;\n\t\tlen = (TIndexOffU)sa.len;\n\t\treported_.resize(sa.offs.size());\n\t\treported_.fill(false);\n\t\tfmap.resize(sa.offs.size());\n\t\tfmap.fill(make_pair(OFF_MASK, OFF_MASK));\n\t}", "idx": 335}
{"project": "bowtie2", "commit_id": "403_bowtie2_2.5.1_group_walk.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\telt_ = rep_ = 0;\n\t\tASSERT_ONLY(inited_ = false);\n\t}", "idx": 336}
{"project": "bowtie2", "commit_id": "404_bowtie2_2.5.1_group_walk.h_merge.cpp", "target": 0, "func": "void merge(const WalkMetrics& m, bool getLock = false) {\n\t\tif(getLock) {\n\t\t\tThreadSafe ts(mutex_m);\n\t\t\tmergeImpl(m);\n\t\t} else {\n\t\t\tmergeImpl(m);\n\t\t}\n\t}", "idx": 337}
{"project": "bowtie2", "commit_id": "405_bowtie2_2.5.1_group_walk.h_mergeImpl.cpp", "target": 0, "func": "void mergeImpl(const WalkMetrics& m) {\n\t\tbwops += m.bwops;\n\t\tbranches += m.branches;\n\t\tresolves += m.resolves;\n\t\trefresolves += m.refresolves;\n\t\treports += m.reports;\n\t}", "idx": 338}
{"project": "bowtie2", "commit_id": "406_bowtie2_2.5.1_group_walk.h_repOkBasic.cpp", "target": 0, "func": "bool repOkBasic() {\n\t\tassert_geq(bot, top);\n\t\treturn true;\n\t}", "idx": 339}
{"project": "bowtie2", "commit_id": "407_bowtie2_2.5.1_group_walk.h_setReported.cpp", "target": 0, "func": "void setReported(size_t i) {\n\t\tassert(!reported_[i]);\n\t\tassert_lt(i, reported_.size());\n\t\treported_[i] = true;\n\t\tnrep_++;\n\t}", "idx": 340}
{"project": "bowtie2", "commit_id": "408_bowtie2_2.5.1_group_walk.h_off.cpp", "target": 0, "func": "TIndexOffU off(\n\t\tsize_t i,\n\t\tconst SARangeWithOffs<T>& sa)\n\t{\n\t\tassert_geq(i, mapi_);\n\t\tassert_lt(i, map_.size());\n\t\tassert_lt(map_[i], sa.offs.size());\n\t\treturn sa.offs.get(map_[i]);\n\t}", "idx": 341}
{"project": "bowtie2", "commit_id": "409_bowtie2_2.5.1_group_walk.h_setOff.cpp", "target": 0, "func": "void setOff(\n\t\tsize_t i,\n\t\tTIndexOffU off,\n\t\tSARangeWithOffs<T>& sa,\n\t\tWalkMetrics& met)\n\t{\n\t\tassert_lt(i + mapi_, map_.size());\n\t\tassert_lt(map_[i + mapi_], sa.offs.size());\n\t\tsize_t saoff = map_[i + mapi_];\n\t\tsa.offs[saoff] = off;\n\t\tassert_eq(off, sa.offs[saoff]);\n\t}", "idx": 342}
{"project": "bowtie2", "commit_id": "40_bowtie2_2.5.1_aligner_result.h_setScore.cpp", "target": 0, "func": "void setScore(AlnScore score) {\n\t\tscore_ = score;\n\t}", "idx": 343}
{"project": "bowtie2", "commit_id": "410_bowtie2_2.5.1_group_walk.h_initMap.cpp", "target": 0, "func": "void initMap(size_t newsz) {\n\t\tmapi_ = 0;\n\t\tmap_.resize(newsz);\n\t\tfor(size_t i = 0; i < newsz; i++) {\n\t\t\tmap_[i] = (TIndexOffU)i;\n\t\t}\n\t}", "idx": 344}
{"project": "bowtie2", "commit_id": "411_bowtie2_2.5.1_group_walk.h_resolveAll.cpp", "target": 0, "func": "void resolveAll(WalkMetrics& met, PerReadMetrics& prm) {\n\t\tWalkResult res; // ignore results for now\n\t\tfor(size_t i = 0; i < elt_; i++) {\n\t\t\tadvanceElement((TIndexOffU)i, res, met, prm);\n\t\t}\n\t}", "idx": 345}
{"project": "bowtie2", "commit_id": "412_bowtie2_2.5.1_ival_list.h_setUnsortedSize.cpp", "target": 0, "func": "void setUnsortedSize(size_t usz) {\n\t\tunsortedSz_ = usz;\n\t}", "idx": 346}
{"project": "bowtie2", "commit_id": "413_bowtie2_2.5.1_ival_list.h_add.cpp", "target": 0, "func": "void add(const Interval& i) {\n\t\tsize_t bin = i.ref() & ~(0xffffffff << NBIN);\n\t\tassert_lt(bin, bins_.size());\n\t\tbins_[bin].add(i);\n\t}", "idx": 347}
{"project": "bowtie2", "commit_id": "414_bowtie2_2.5.1_ival_list.h_flush.cpp", "target": 0, "func": "void flush() {\n\t\tfor(size_t i = 0; i < unsorted_.size(); i++) {\n\t\t\tsorted_.push_back(unsorted_[i]);\n\t\t}\n\t\tsorted_.sort();\n\t\tmerge();\n\t\tsortedLhs_.clear();\n\t\tfor(size_t i = 0; i < sorted_.size(); i++) {\n\t\t\tsortedLhs_.push_back(sorted_[i].upstream());\n\t\t}\n\t\tassert(sortedLhs_.sorted());\n\t\tunsorted_.clear();\n\t}", "idx": 348}
{"project": "bowtie2", "commit_id": "415_bowtie2_2.5.1_ival_list.h_reset.cpp", "target": 0, "func": "void reset() { clear(); }", "idx": 349}
{"project": "bowtie2", "commit_id": "416_bowtie2_2.5.1_ival_list.h_clear.cpp", "target": 0, "func": "void clear() {\n\t\tfor(size_t i = 0; i < bins_.size(); i++) {\n\t\t\tbins_[i].clear();\n\t\t}\n\t}", "idx": 350}
{"project": "bowtie2", "commit_id": "417_bowtie2_2.5.1_ival_list.h_merge.cpp", "target": 0, "func": "void merge() {\n\t\tsize_t nmerged = 0;\n\t\tfor(size_t i = 1; i < sorted_.size(); i++) {\n\t\t\tif(sorted_[i-1].downstream() >= sorted_[i].upstream()) {\n\t\t\t\tnmerged++;\n\t\t\t\tassert_leq(sorted_[i-1].upstream(), sorted_[i].upstream());\n\t\t\t\tCoord up = std::min(sorted_[i-1].upstream(), sorted_[i].upstream());\n\t\t\t\tCoord dn = std::max(sorted_[i-1].downstream(), sorted_[i].downstream());\n\t\t\t\tsorted_[i].setUpstream(up);\n\t\t\t\tsorted_[i].setLength(dn.off() - up.off());\n\t\t\t\tsorted_[i-1].reset();\n\t\t\t}\n\t\t}\n\t\tsorted_.sort();\n\t\tassert_lt(nmerged, sorted_.size());\n\t\tsorted_.resize(sorted_.size()-nmerged);\n#ifndef NDEBUG\n\t\tfor(size_t i = 0; i < sorted_.size(); i++) {\n\t\t\tassert(sorted_[i].inited());\n\t\t}\n#endif\n\t}", "idx": 351}
{"project": "bowtie2", "commit_id": "418_bowtie2_2.5.1_ls.h_update_group.cpp", "target": 0, "func": "inline void update_group(T *pl, T *pm) {\n\t   T g;\n\t   g=(T)(pm-I);                 /* group number.*/\n\t   V[*pl]=g;                    /* update group number of first position.*/\n\t   if (pl==pm)\n\t\t  *pl=-1;                   /* one element, sorted group.*/\n\t   else\n\t\t  do                        /* more than one element, unsorted group.*/\n\t\t\t V[*++pl]=g;            /* update group numbers.*/\n\t\t  while (pl<pm);\n\t}", "idx": 352}
{"project": "bowtie2", "commit_id": "419_bowtie2_2.5.1_ls.h_select_sort_split.cpp", "target": 0, "func": "inline void select_sort_split(T *p, T n) {\n\t   T *pa, *pb, *pi, *pn;\n\t   T f, v, tmp;\n\n\t   pa=p;                        /* pa is start of group being picked out.*/\n\t   pn=p+n-1;                    /* pn is last position of subarray.*/\n\t   while (pa<pn) {\n\t\t  for (pi=pb=pa+1, f=LS_KEY(pa); pi<=pn; ++pi)\n\t\t\t if ((v=LS_KEY(pi))<f) {\n\t\t\t\tf=v;                /* f is smallest key found.*/\n\t\t\t\tLS_SWAP(pi, pa);       /* place smallest element at beginning.*/\n\t\t\t\tpb=pa+1;            /* pb is position for elements equal to f.*/\n\t\t\t } else if (v==f) {     /* if equal to smallest key.*/\n\t\t\t\tLS_SWAP(pi, pb);       /* place next to other smallest elements.*/\n\t\t\t\t++pb;\n\t\t\t }\n\t\t  update_group(pa, pb-1);   /* update group values for new group.*/\n\t\t  pa=pb;                    /* continue sorting rest of the subarray.*/\n\t   }\n\t   if (pa==pn) {                /* check if last part is single element.*/\n\t\t  V[*pa]=(T)(pa-I);\n\t\t  *pa=-1;                   /* sorted group.*/\n\t   }\n\t}", "idx": 353}
{"project": "bowtie2", "commit_id": "41_bowtie2_2.5.1_aligner_result.h_setNucs.cpp", "target": 0, "func": "void setNucs(bool fw, int nup, int ndn) {\n\t\tnuc5p_ = fw ? nup : ndn;\n\t\tnuc3p_ = fw ? ndn : nup;\n\t}", "idx": 354}
{"project": "bowtie2", "commit_id": "420_bowtie2_2.5.1_ls.h_choose_pivot.cpp", "target": 0, "func": "inline T choose_pivot(T *p, T n) {\n\t   T *pl, *pm, *pn;\n\t   T s;\n\n\t   pm=p+(n>>1);                 /* small arrays, middle element.*/\n\t   if (n>7) {\n\t\t  pl=p;\n\t\t  pn=p+n-1;\n\t\t  if (n>40) {               /* big arrays, pseudomedian of 9.*/\n\t\t\t s=n>>3;\n\t\t\t pl=LS_SMED3(pl, pl+s, pl+s+s);\n\t\t\t pm=LS_SMED3(pm-s, pm, pm+s);\n\t\t\t pn=LS_SMED3(pn-s-s, pn-s, pn);\n\t\t  }\n\t\t  pm=LS_SMED3(pl, pm, pn);      /* midsize arrays, median of 3.*/\n\t   }\n\t   return LS_KEY(pm);\n\t}", "idx": 355}
{"project": "bowtie2", "commit_id": "421_bowtie2_2.5.1_ls.h_transform.cpp", "target": 0, "func": "inline T transform(T *x, T *p, T n, T k, T l, T q)\n\t{\n\t   T b, c, d, e, i, j, m, s;\n\t   T *pi, *pj;\n\n\t   for (s=0, i=k-l; i; i>>=1)\n\t\t  ++s;                      /* s is number of bits in old symbol.*/\n\t   e=std::numeric_limits<T>::max()>>s; /* e is for overflow checking.*/\n\t   for (b=d=r=0; r<n && d<=e && (c=d<<s|(k-l))<=q; ++r) {\n\t\t  b=b<<s|(x[r]-l+1);        /* b is start of x in chunk alphabet.*/\n\t\t  d=c;                      /* d is max symbol in chunk alphabet.*/\n\t   }\n\t   m=(((T)1)<<(r-1)*s)-1;            /* m masks off top old symbol from chunk.*/\n\t   x[n]=l-1;                    /* emulate zero terminator.*/\n\t   if (d<=n) {                  /* if bucketing possible, compact alphabet.*/\n\t\t  for (pi=p; pi<=p+d; ++pi)\n\t\t\t *pi=0;                 /* zero transformation table.*/\n\t\t  for (pi=x+r, c=b; pi<=x+n; ++pi) {\n\t\t\t p[c]=1;                /* mark used chunk symbol.*/\n\t\t\t c=(c&m)<<s|(*pi-l+1);  /* shift in next old symbol in chunk.*/\n\t\t  }\n\t\t  for (i=1; i<r; ++i) {     /* handle last r-1 positions.*/\n\t\t\t p[c]=1;                /* mark used chunk symbol.*/\n\t\t\t c=(c&m)<<s;            /* shift in next old symbol in chunk.*/\n\t\t  }\n\t\t  for (pi=p, j=1; pi<=p+d; ++pi)\n\t\t\t if (*pi)\n\t\t\t\t*pi=j++;            /* j is new alphabet size.*/\n\t\t  for (pi=x, pj=x+r, c=b; pj<=x+n; ++pi, ++pj) {\n\t\t\t *pi=p[c];              /* transform to new alphabet.*/\n\t\t\t c=(c&m)<<s|(*pj-l+1);  /* shift in next old symbol in chunk.*/\n\t\t  }\n\t\t  while (pi<x+n) {          /* handle last r-1 positions.*/\n\t\t\t *pi++=p[c];            /* transform to new alphabet.*/\n\t\t\t c=(c&m)<<s;            /* shift right-end zero in chunk.*/\n\t\t  }\n\t   } else {                     /* bucketing not possible, don't compact.*/\n\t\t  for (pi=x, pj=x+r, c=b; pj<=x+n; ++pi, ++pj) {\n\t\t\t *pi=c;                 /* transform to new alphabet.*/\n\t\t\t c=(c&m)<<s|(*pj-l+1);  /* shift in next old symbol in chunk.*/\n\t\t  }\n\t\t  while (pi<x+n) {          /* handle last r-1 positions.*/\n\t\t\t *pi++=c;               /* transform to new alphabet.*/\n\t\t\t c=(c&m)<<s;            /* shift right-end zero in chunk.*/\n\t\t  }\n\t\t  j=d+1;                    /* new alphabet size.*/\n\t   }\n\t   x[n]=0;                      /* end-of-string symbol is zero.*/\n\t   return j;                    /* return new alphabet size.*/\n\t}", "idx": 356}
{"project": "bowtie2", "commit_id": "422_bowtie2_2.5.1_mask.h_matchesEx.cpp", "target": 0, "func": "static inline int matchesEx(int i, int j) {\n\tif(j >= 16 || i > 3) {\n\t\t// read and/or ref was ambiguous\n\t\treturn -1;\n\t}\n\treturn (((1 << i) & j) != 0) ? 1 : 0;\n}", "idx": 357}
{"project": "bowtie2", "commit_id": "423_bowtie2_2.5.1_mask.h_matches.cpp", "target": 0, "func": "static inline bool matches(int i, int j) {\n\treturn ((1 << i) & j) != 0;\n}", "idx": 358}
{"project": "bowtie2", "commit_id": "424_bowtie2_2.5.1_mask.h_randFromMask.cpp", "target": 0, "func": "static inline int randFromMask(RandomSource& rnd, int mask) {\n\tassert_gt(mask, 0);\n\tif(alts5[mask] == 1) {\n\t\t// only one to pick from, pick it via lookup table\n\t\treturn firsts5[mask];\n\t}\n\tassert_gt(mask, 0);\n\tassert_lt(mask, 32);\n\tint r = rnd.nextU32() % alts5[mask];\n\tassert_geq(r, 0);\n\tassert_lt(r, alts5[mask]);\n\t// could do the following via lookup table too\n\tfor(int i = 0; i < 5; i++) {\n\t\tif((mask & (1 << i)) != 0) {\n\t\t\tif(r == 0) return i;\n\t\t\tr--;\n\t\t}\n\t}\n\tstd::cerr << \"Shouldn't get here\" << std::endl;\n\tthrow 1;\n\treturn -1;\n}", "idx": 359}
{"project": "bowtie2", "commit_id": "425_bowtie2_2.5.1_multikey_qsort.h_swap.cpp", "target": 0, "func": "static inline void swap(TVal* s, size_t slen, TPos a, TPos b) {\n\tassert_lt(a, slen);\n\tassert_lt(b, slen);\n\tswap(s[a], s[b]);\n}", "idx": 360}
{"project": "bowtie2", "commit_id": "426_bowtie2_2.5.1_multikey_qsort.h_SWAP.cpp", "target": 0, "func": "define SWAP(s, a, b) { \\\n\tassert_geq(a, begin); \\\n\tassert_geq(b, begin); \\\n\tassert_lt(a, end); \\\n\tassert_lt(b, end); \\\n\tswap(s, slen, a, b); \\\n}", "idx": 361}
{"project": "bowtie2", "commit_id": "427_bowtie2_2.5.1_multikey_qsort.h_SWAP2.cpp", "target": 0, "func": "define SWAP2(s, s2, a, b) { \\\n\tSWAP(s, a, b); \\\n\tswap(s2, slen, a, b); \\\n}", "idx": 362}
{"project": "bowtie2", "commit_id": "428_bowtie2_2.5.1_multikey_qsort.h_SWAP1.cpp", "target": 0, "func": "define SWAP1(s, s2, a, b) { \\\n\tSWAP(s, a, b); \\\n}", "idx": 363}
{"project": "bowtie2", "commit_id": "429_bowtie2_2.5.1_multikey_qsort.h_VECSWAP.cpp", "target": 0, "func": "define VECSWAP(s, i, j, n) { \\\n\tif(n > 0) { vecswap(s, slen, i, j, n, begin, end); } \\\n}", "idx": 364}
{"project": "bowtie2", "commit_id": "42_bowtie2_2.5.1_aligner_result.h_setParams.cpp", "target": 0, "func": "void setParams(\n\t\tint seedmms,\n\t\tint seedlen,\n\t\tint seedival,\n\t\tint64_t minsc)\n\t{\n\t\tseedmms_ = seedmms;\n\t\tseedlen_ = seedlen;\n\t\tseedival_ = seedival;\n\t\tminsc_ = minsc;\n\t}", "idx": 365}
{"project": "bowtie2", "commit_id": "430_bowtie2_2.5.1_multikey_qsort.h_VECSWAP2.cpp", "target": 0, "func": "define VECSWAP2(s, s2, i, j, n) { \\\n\tif(n > 0) { vecswap2(s, slen, s2, i, j, n, begin, end); } \\\n}", "idx": 366}
{"project": "bowtie2", "commit_id": "431_bowtie2_2.5.1_multikey_qsort.h_vecswap.cpp", "target": 0, "func": "static inline void vecswap(TVal *s, size_t slen, TPos i, TPos j, TPos n, TPos begin, TPos end) {\n\tassert_geq(i, begin);\n\tassert_geq(j, begin);\n\tassert_lt(i, end);\n\tassert_lt(j, end);\n\twhile(n-- > 0) {\n\t\tassert_geq(n, 0);\n\t\tTPos a = i+n;\n\t\tTPos b = j+n;\n\t\tassert_geq(a, begin);\n\t\tassert_geq(b, begin);\n\t\tassert_lt(a, end);\n\t\tassert_lt(b, end);\n\t\tswap(s, slen, a, b);\n\t}\n}", "idx": 367}
{"project": "bowtie2", "commit_id": "432_bowtie2_2.5.1_multikey_qsort.h_vecswap2.cpp", "target": 0, "func": "static inline void vecswap2(TVal* s, size_t slen, TVal* s2, TPos i, TPos j, TPos n, TPos begin, TPos end) {\n\tassert_geq(i, begin);\n\tassert_geq(j, begin);\n\tassert_lt(i, end);\n\tassert_lt(j, end);\n\twhile(n-- > 0) {\n\t\tassert_geq(n, 0);\n\t\tTPos a = i+n;\n\t\tTPos b = j+n;\n\t\tassert_geq(a, begin);\n\t\tassert_geq(b, begin);\n\t\tassert_lt(a, end);\n\t\tassert_lt(b, end);\n\t\tswap(s, slen, a, b);\n\t\tswap(s2, slen, a, b);\n\t}\n}", "idx": 368}
{"project": "bowtie2", "commit_id": "433_bowtie2_2.5.1_multikey_qsort.h_CHOOSE_AND_SWAP_RANDOM_PIVOT.cpp", "target": 0, "func": "define CHOOSE_AND_SWAP_RANDOM_PIVOT(sw, ch) {                            \\\n\t/* Note: rand() didn't really cut it here; it seemed to run out of */ \\\n\t/* randomness and, after a time, returned the same thing over and */  \\\n\t/* over again */                                                      \\\n\ta = (rand() % n) + begin; /* choose pivot between begin and end */  \\\n\tassert_lt(a, end); assert_geq(a, begin);                              \\\n\tsw(s, s2, begin, a); /* move pivot to beginning */                    \\\n}", "idx": 369}
{"project": "bowtie2", "commit_id": "434_bowtie2_2.5.1_multikey_qsort.h_CHOOSE_AND_SWAP_SMART_PIVOT.cpp", "target": 0, "func": "define CHOOSE_AND_SWAP_SMART_PIVOT(sw, ch) {                                    \\\n\ta = begin; /* choose first elt */                                            \\\n\t/* now try to find a better elt */                                           \\\n\tif(n >= 5) { /* n is the difference between begin and end */                 \\\n\t\tif     (ch(begin+1, depth) == 1 || ch(begin+1, depth) == 2) a = begin+1; \\\n\t\telse if(ch(begin+2, depth) == 1 || ch(begin+2, depth) == 2) a = begin+2; \\\n\t\telse if(ch(begin+3, depth) == 1 || ch(begin+3, depth) == 2) a = begin+3; \\\n\t\telse if(ch(begin+4, depth) == 1 || ch(begin+4, depth) == 2) a = begin+4; \\\n\t\tif(a != begin) sw(s, s2, begin, a); /* move pivot to beginning */        \\\n\t}                                                                            \\\n\t/* the element at [begin] now holds the pivot value */                       \\\n}", "idx": 370}
{"project": "bowtie2", "commit_id": "435_bowtie2_2.5.1_multikey_qsort.h_sanityCheckInputSufs.cpp", "target": 0, "func": "static inline void sanityCheckInputSufs(TIndexOffU *s, size_t slen) {\n\tassert_gt(slen, 0);\n\tfor(size_t i = 0; i < slen; i++) {\n\t\t// Actually, it's convenient to allow the caller to provide\n\t\t// suffix offsets thare are off the end of the host string.\n\t\t// See, e.g., build() in diff_sample.cpp.\n\t\t//assert_lt(s[i], length(host));\n\t\tfor(size_t j = i+1; j < slen; j++) {\n\t\t\tassert_neq(s[i], s[j]);\n\t\t}\n\t}\n}", "idx": 371}
{"project": "bowtie2", "commit_id": "436_bowtie2_2.5.1_multikey_qsort.h_MQS_RECURSE_SUF.cpp", "target": 0, "func": "define MQS_RECURSE_SUF(nbegin, nend, ndepth) { \\\n\t\tassert(nbegin > begin || nend < end || ndepth > depth); \\\n\t\tif(ndepth < upto) { /* don't exceed depth of 'upto' */ \\\n\t\t\tmkeyQSortSuf(host, hlen, s, slen, hi, nbegin, nend, ndepth, upto); \\\n\t\t} \\\n\t}", "idx": 372}
{"project": "bowtie2", "commit_id": "437_bowtie2_2.5.1_multikey_qsort.h_mkeyQSortSuf.cpp", "target": 0, "func": "void mkeyQSortSuf(\n\tconst T& host,\n\tTIndexOffU *s,\n\tsize_t slen,\n\tint hi,\n\tbool verbose = false,\n\tbool sanityCheck = false,\n\tsize_t upto = OFF_MASK)\n{\n\tsize_t hlen = host.length();\n\tassert_gt(slen, 0);\n\tif(sanityCheck) sanityCheckInputSufs(s, slen);\n\tmkeyQSortSuf(host, hlen, s, slen, hi, (size_t)0, slen, (size_t)0, upto);\n\tif(sanityCheck) sanityCheckOrderedSufs(host, hlen, s, slen, upto);\n}", "idx": 373}
{"project": "bowtie2", "commit_id": "438_bowtie2_2.5.1_multikey_qsort.h_mkeyQSortSuf2.cpp", "target": 0, "func": "void mkeyQSortSuf2(\n                   const T& host,\n                   TIndexOffU *s,\n                   size_t slen,\n                   TIndexOffU *s2,\n                   int hi,\n                   bool verbose = false,\n                   bool sanityCheck = false,\n                   size_t upto = OFF_MASK,\n                   EList<size_t>* boundaries = NULL)\n{\n    size_t hlen = host.length();\n    if(sanityCheck) sanityCheckInputSufs(s, slen);\n    TIndexOffU *sOrig = NULL;\n    if(sanityCheck) {\n        sOrig = new TIndexOffU[slen];\n        memcpy(sOrig, s, OFF_SIZE * slen);\n    }\n    mkeyQSortSuf2(host, hlen, s, slen, s2, hi, (size_t)0, slen, (size_t)0, upto, boundaries);\n    if(sanityCheck) {\n        sanityCheckOrderedSufs(host, hlen, s, slen, upto);\n        for(size_t i = 0; i < slen; i++) {\n            assert_eq(s[i], sOrig[s2[i]]);\n        }\n        delete[] sOrig;\n    }\n}", "idx": 374}
{"project": "bowtie2", "commit_id": "439_bowtie2_2.5.1_multikey_qsort.h_sufDcLt.cpp", "target": 0, "func": "inline\nbool sufDcLt(\n\tconst T1& host,\n\tconst T2& s1,\n\tconst T2& s2,\n\tconst DifferenceCoverSample<T1>& dc,\n\tbool sanityCheck = false)\n{\n\tsize_t diff = dc.tieBreakOff(s1, s2);\n\tASSERT_ONLY(size_t hlen = host.length());\n\tassert_lt(diff, dc.v());\n\tassert_lt(diff, hlen-s1);\n\tassert_lt(diff, hlen-s2);\n\tif(sanityCheck) {\n\t\tfor(size_t i = 0; i < diff; i++) {\n\t\t\tassert_eq(host[s1+i], host[s2+i]);\n\t\t}\n\t}\n\tbool ret = dc.breakTie(s1+diff, s2+diff) < 0;\n#ifndef NDEBUG\n\tif(sanityCheck && ret != sstr_suf_lt(host, s1, hlen, host, s2, hlen, false)) {\n\t\tassert(false);\n\t}\n#endif\n\treturn ret;\n}", "idx": 375}
{"project": "bowtie2", "commit_id": "43_bowtie2_2.5.1_aligner_result.h_setFragmentLength.cpp", "target": 0, "func": "int64_t setFragmentLength(const AlnRes& omate, const AlnFlags& flags) {\n\t\tCoord st, en;\n\t\tCoord ost, oen;\n\t\tassert_eq(refid(), omate.refid());\n\t\tgetExtendedCoords(st, en, flags);\n\t\tomate.getExtendedCoords(ost, oen, flags);\n\t\tbool imUpstream;\n\n\t\tif (st.off() == ost.off()) {\n\t\t\t// --ff case\n\t\t\tif (st.fw() && ost.fw() && readMate1()) {\n\t\t\t\timUpstream = true;\n\t\t\t} else if (st.fw() && !ost.fw()) {\n\t\t\t\timUpstream = true;\n\t\t\t} else {\n\t\t\t\timUpstream = false;\n\t\t\t}\n\t\t} else if (st.off() < ost.off()) {\n\t\t\timUpstream = true;\n\t\t} else {\n\t\t\timUpstream = false;\n\t\t}\n\n\t\tTRefOff up = std::min(st.off(), ost.off());\n\t\tTRefOff dn = std::max(en.off(), oen.off());\n\t\tassert_geq(dn, up);\n\t\tfraglen_ = 1 + dn - up;\n\t\tif(!imUpstream) {\n\t\t\tfraglen_ = -fraglen_;\n\t\t}\n\t\tfraglenSet_ = true;\n\t\treturn fraglen_;\n\t}", "idx": 376}
{"project": "bowtie2", "commit_id": "440_bowtie2_2.5.1_multikey_qsort.h_qsortSufDc.cpp", "target": 0, "func": "inline\nvoid qsortSufDc(\n\tconst T& host,\n\tsize_t hlen,\n\tTIndexOffU* s,\n\tsize_t slen,\n\tconst DifferenceCoverSample<T>& dc,\n\tsize_t begin,\n\tsize_t end,\n\tbool sanityCheck = false)\n{\n\tassert_leq(end, slen);\n\tassert_lt(begin, slen);\n\tassert_gt(end, begin);\n\tsize_t n = end - begin;\n\tif(n <= 1) return;                 // 1-element list already sorted\n\t// Note: rand() didn't really cut it here; it seemed to run out of\n\t// randomness and, after a time, returned the same thing over and\n\t// over again\n\tsize_t a = (rand() % n) + begin; // choose pivot between begin and end\n\tassert_lt(a, end);\n\tassert_geq(a, begin);\n\tSWAP(s, end-1, a); // move pivot to end\n\tsize_t cur = 0;\n\tfor(size_t i = begin; i < end-1; i++) {\n\t\tif(sufDcLt(host, s[i], s[end-1], dc, sanityCheck)) {\n\t\t\tif(sanityCheck)\n\t\t\t\tassert(dollarLt(suffix(host, s[i]), suffix(host, s[end-1])));\n\t\t\tassert_lt(begin + cur, end-1);\n\t\t\tSWAP(s, i, begin + cur);\n\t\t\tcur++;\n\t\t}\n\t}\n\t// Put pivot into place\n\tassert_lt(cur, end-begin);\n\tSWAP(s, end-1, begin+cur);\n\tif(begin+cur > begin) qsortSufDc(host, hlen, s, slen, dc, begin, begin+cur);\n\tif(end > begin+cur+1) qsortSufDc(host, hlen, s, slen, dc, begin+cur+1, end);\n}", "idx": 377}
{"project": "bowtie2", "commit_id": "441_bowtie2_2.5.1_multikey_qsort.h_mkeyQSortSufDcU8.cpp", "target": 0, "func": "void mkeyQSortSufDcU8(\n\tconst T1& host1,\n\tconst T2& host,\n\tsize_t hlen,\n\tTIndexOffU* s,\n\tsize_t slen,\n\tconst DifferenceCoverSample<T1>& dc,\n\tint hi,\n\tbool verbose = false,\n\tbool sanityCheck = false)\n{\n\tif(sanityCheck) sanityCheckInputSufs(s, slen);\n\tmkeyQSortSufDcU8(host1, host, hlen, s, slen, dc, hi, 0, slen, 0, sanityCheck);\n\tif(sanityCheck) sanityCheckOrderedSufs(host1, hlen, s, slen, OFF_MASK);\n}", "idx": 378}
{"project": "bowtie2", "commit_id": "442_bowtie2_2.5.1_multikey_qsort.h_sufDcLtU8.cpp", "target": 0, "func": "inline\nbool sufDcLtU8(\n\tconst T1& host1,\n\tconst T2& host,\n\tsize_t hlen,\n\tsize_t s1,\n\tsize_t s2,\n\tconst DifferenceCoverSample<T1>& dc,\n\tbool sanityCheck = false)\n{\n\thlen += 0;\n\tsize_t diff = dc.tieBreakOff((TIndexOffU)s1, (TIndexOffU)s2);\n\tassert_lt(diff, dc.v());\n\tassert_lt(diff, hlen-s1);\n\tassert_lt(diff, hlen-s2);\n\tif(sanityCheck) {\n\t\tfor(size_t i = 0; i < diff; i++) {\n\t\t\tassert_eq(host[s1+i], host1[s2+i]);\n\t\t}\n\t}\n\tbool ret = dc.breakTie((TIndexOffU)(s1+diff), (TIndexOffU)(s2+diff)) < 0;\n\t// Sanity-check return value using dollarLt\n#ifndef NDEBUG\n\tbool ret2 = sstr_suf_lt(host1, s1, hlen, host, s2, hlen, false);\n\tassert(!sanityCheck || ret == ret2);\n#endif\n\treturn ret;\n}", "idx": 379}
{"project": "bowtie2", "commit_id": "443_bowtie2_2.5.1_multikey_qsort.h_get_uint8.cpp", "target": 0, "func": "inline uint8_t get_uint8(const TStr& t, size_t off) {\n\treturn t[off];\n}", "idx": 380}
{"project": "bowtie2", "commit_id": "444_bowtie2_2.5.1_multikey_qsort.h_char_at_suf_u8.cpp", "target": 0, "func": "static inline int char_at_suf_u8(\n\tconst TStr& host,\n\tsize_t hlen,\n\tTIndexOffU* s,\n\tsize_t si,\n\tsize_t off,\n\tuint8_t hi)\n{\n\treturn ((off+s[si]) < hlen) ? get_uint8(host, off+s[si]) : (hi);\n}", "idx": 381}
{"project": "bowtie2", "commit_id": "445_bowtie2_2.5.1_multikey_qsort.h_MQS_RECURSE_SUF_DC_U8.cpp", "target": 0, "func": "define MQS_RECURSE_SUF_DC_U8(nbegin, nend, ndepth) { \\\n\t\tassert(nbegin > begin || nend < end || ndepth > depth); \\\n\t\tmkeyQSortSufDcU8(host1, host, hlen, s, slen, dc, hi, nbegin, nend, ndepth, sanityCheck); \\\n\t}", "idx": 382}
{"project": "bowtie2", "commit_id": "446_bowtie2_2.5.1_outq.cpp_main.cpp", "target": 0, "func": "int main(void) {\n\tcerr << \"Case 1 (one thread) ... \";\n\t{\n\t\tOutFileBuf ofb;\n\t\tOutputQueue oq(ofb, false);\n\t\tassert_eq(0, oq.numFlushed());\n\t\tassert_eq(0, oq.numStarted());\n\t\tassert_eq(0, oq.numFinished());\n\t\toq.beginRead(1);\n\t\tassert_eq(0, oq.numFlushed());\n\t\tassert_eq(1, oq.numStarted());\n\t\tassert_eq(0, oq.numFinished());\n\t\toq.beginRead(3);\n\t\tassert_eq(0, oq.numFlushed());\n\t\tassert_eq(2, oq.numStarted());\n\t\tassert_eq(0, oq.numFinished());\n\t\toq.beginRead(2);\n\t\tassert_eq(0, oq.numFlushed());\n\t\tassert_eq(3, oq.numStarted());\n\t\tassert_eq(0, oq.numFinished());\n\t\toq.flush();\n\t\tassert_eq(0, oq.numFlushed());\n\t\tassert_eq(3, oq.numStarted());\n\t\tassert_eq(0, oq.numFinished());\n\t\toq.beginRead(0);\n\t\tassert_eq(0, oq.numFlushed());\n\t\tassert_eq(4, oq.numStarted());\n\t\tassert_eq(0, oq.numFinished());\n\t\toq.flush();\n\t\tassert_eq(0, oq.numFlushed());\n\t\tassert_eq(4, oq.numStarted());\n\t\tassert_eq(0, oq.numFinished());\n\t\toq.finishRead(0);\n\t\tassert_eq(0, oq.numFlushed());\n\t\tassert_eq(4, oq.numStarted());\n\t\tassert_eq(1, oq.numFinished());\n\t\toq.flush();\n\t\tassert_eq(0, oq.numFlushed());\n\t\tassert_eq(4, oq.numStarted());\n\t\tassert_eq(1, oq.numFinished());\n\t\toq.flush(true);\n\t\tassert_eq(1, oq.numFlushed());\n\t\tassert_eq(4, oq.numStarted());\n\t\tassert_eq(1, oq.numFinished());\n\t\toq.finishRead(2);\n\t\tassert_eq(1, oq.numFlushed());\n\t\tassert_eq(4, oq.numStarted());\n\t\tassert_eq(2, oq.numFinished());\n\t\toq.flush(true);\n\t\tassert_eq(1, oq.numFlushed());\n\t\tassert_eq(4, oq.numStarted());\n\t\tassert_eq(2, oq.numFinished());\n\t\toq.finishRead(1);\n\t\tassert_eq(1, oq.numFlushed());\n\t\tassert_eq(4, oq.numStarted());\n\t\tassert_eq(3, oq.numFinished());\n\t\toq.flush(true);\n\t\tassert_eq(3, oq.numFlushed());\n\t\tassert_eq(4, oq.numStarted());\n\t\tassert_eq(3, oq.numFinished());\n\t}\n\tcerr << \"PASSED\" << endl;\n\n\tcerr << \"Case 2 (one thread) ... \";\n\t{\n\t\tOutFileBuf ofb;\n\t\tOutputQueue oq(ofb, false);\n\t\tBTString& buf1 = oq.beginRead(0);\n\t\tBTString& buf2 = oq.beginRead(1);\n\t\tBTString& buf3 = oq.beginRead(2);\n\t\tBTString& buf4 = oq.beginRead(3);\n\t\tBTString& buf5 = oq.beginRead(4);\n\t\tassert_eq(5, oq.numStarted());\n\t\tassert_eq(0, oq.numFinished());\n\t\tbuf1.install(\"A\\n\");\n\t\tbuf2.install(\"B\\n\");\n\t\tbuf3.install(\"C\\n\");\n\t\tbuf4.install(\"D\\n\");\n\t\tbuf5.install(\"E\\n\");\n\t\toq.finishRead(4);\n\t\toq.finishRead(1);\n\t\toq.finishRead(0);\n\t\toq.finishRead(2);\n\t\toq.finishRead(3);\n\t\toq.flush(true);\n\t\tassert_eq(5, oq.numFlushed());\n\t\tassert_eq(5, oq.numStarted());\n\t\tassert_eq(5, oq.numFinished());\n\t\tofb.flush();\n\t}\n\tcerr << \"PASSED\" << endl;\n\treturn 0;\n}", "idx": 383}
{"project": "bowtie2", "commit_id": "447_bowtie2_2.5.1_pat.cpp_genRandSeed.cpp", "target": 0, "func": "static uint32_t genRandSeed(\n\tconst BTDnaString& qry,\n\tconst BTString& qual,\n\tconst BTString& name,\n\tuint32_t seed)\n{\n\t// Calculate a per-read random seed based on a combination of\n\t// the read data (incl. sequence, name, quals) and the global\n\t// seed\n\tuint32_t rseed = (seed + 101) * 59 * 61 * 67 * 71 * 73 * 79 * 83;\n\tsize_t qlen = qry.length();\n\t// Throw all the characters of the read into the random seed\n\tfor(size_t i = 0; i < qlen; i++) {\n\t\tint p = (int)qry[i];\n\t\tassert_leq(p, 4);\n\t\tsize_t off = ((i & 15) << 1);\n\t\trseed ^= ((uint32_t)p << off);\n\t}\n\t// Throw all the quality values for the read into the random\n\t// seed\n\tfor(size_t i = 0; i < qlen; i++) {\n\t\tint p = (int)qual[i];\n\t\tassert_leq(p, 255);\n\t\tsize_t off = ((i & 3) << 3);\n\t\trseed ^= (p << off);\n\t}\n\t// Throw all the characters in the read name into the random\n\t// seed\n\tsize_t namelen = name.length();\n\tfor(size_t i = 0; i < namelen; i++) {\n\t\tint p = (int)name[i];\n\t\tif(p == '/') break;\n\t\tassert_leq(p, 255);\n\t\tsize_t off = ((i & 3) << 3);\n\t\trseed ^= (p << off);\n\t}\n\treturn rseed;\n}", "idx": 384}
{"project": "bowtie2", "commit_id": "448_bowtie2_2.5.1_pat.cpp_wrongQualityFormat.cpp", "target": 0, "func": "void wrongQualityFormat(const BTString& read_name) {\n\tcerr << \"Error: Encountered one or more spaces while parsing the quality \"\n\t\t << \"string for read \" << read_name << \".  If this is a FASTQ file \"\n\t\t << \"with integer (non-ASCII-encoded) qualities, try re-running with \"\n\t\t << \"the --integer-quals option.\" << endl;\n\tthrow 1;\n}", "idx": 385}
{"project": "bowtie2", "commit_id": "449_bowtie2_2.5.1_pat.cpp_tooFewQualities.cpp", "target": 0, "func": "void tooFewQualities(const BTString& read_name) {\n\tcerr << \"Error: Read \" << read_name << \" has more read characters than \"\n\t\t << \"quality values.\" << endl;\n\tthrow 1;\n}", "idx": 386}
{"project": "bowtie2", "commit_id": "44_bowtie2_2.5.1_aligner_result.h_setRefNs.cpp", "target": 0, "func": "void setRefNs(size_t refns) {\n\t\trefns_ = refns;\n\t}", "idx": 387}
{"project": "bowtie2", "commit_id": "450_bowtie2_2.5.1_pat.cpp_tooManyQualities.cpp", "target": 0, "func": "void tooManyQualities(const BTString& read_name) {\n\tcerr << \"Error: Read \" << read_name << \" has more quality values than read \"\n\t\t << \"characters.\" << endl;\n\tthrow 1;\n}", "idx": 388}
{"project": "bowtie2", "commit_id": "451_bowtie2_2.5.1_pat.h_reset.cpp", "target": 0, "func": "virtual void reset() {\n\t\tPatternSource::reset();\n\t\tsra_acc_cur_ = 0;\n\t\tif (read_iter_)\n\t\t\tdelete read_iter_;\n\t\topen();\n\t\tsra_acc_cur_++;\n\t}", "idx": 389}
{"project": "bowtie2", "commit_id": "452_bowtie2_2.5.1_pat.h_next.cpp", "target": 0, "func": "void next() {\n\t\tassert_lt(cur_buf_, bufa_.size());\n\t\tcur_buf_++;\n\t}", "idx": 390}
{"project": "bowtie2", "commit_id": "453_bowtie2_2.5.1_pat.h_init.cpp", "target": 0, "func": "void init() {\n\t\tcur_buf_ = 0;\n\t}", "idx": 391}
{"project": "bowtie2", "commit_id": "454_bowtie2_2.5.1_pat.h_setReadId.cpp", "target": 0, "func": "void setReadId(TReadId rdid) {\n\t\trdid_ = rdid;\n\t}", "idx": 392}
{"project": "bowtie2", "commit_id": "455_bowtie2_2.5.1_pat.h_resetForNextFile.cpp", "target": 0, "func": "virtual void resetForNextFile() {\n\t\tfirst_ = true;\n\t}", "idx": 393}
{"project": "bowtie2", "commit_id": "456_bowtie2_2.5.1_pat.h_getc_wrapper.cpp", "target": 0, "func": "int getc_wrapper() {\n\t\tint c;\n\n\t\tdo {\n\t\t\tif (compressionType_ == CompressionType::GZIP)\n\t\t\t\tc = gzgetc(zfp_);\n#ifdef WITH_ZSTD\n\t\t\telse if (compressionType_ == CompressionType::ZSTD)\n\t\t\t\tc = zstdGetc(zstdfp_);\n#endif\n\t\t\telse\n\t\t\t\tc = getc_unlocked(fp_);\n\t\t} while (c != EOF && c != '\\t' && c != '\\r' && c != '\\n' && !isprint(c));\n\n\t\treturn c;\n\t}", "idx": 394}
{"project": "bowtie2", "commit_id": "457_bowtie2_2.5.1_pat.h_ungetc_wrapper.cpp", "target": 0, "func": "int ungetc_wrapper(int c) {\n\t\tif (compressionType_ == CompressionType::GZIP)\n\t\t\treturn gzungetc(c, zfp_);\n#ifdef WITH_ZSTD\n\t\telse if (compressionType_ == CompressionType::ZSTD)\n\t\t\treturn zstdUngetc(c, zstdfp_);\n#endif\n\t\telse\n\t\t\treturn ungetc(c, fp_);\n\t}", "idx": 395}
{"project": "bowtie2", "commit_id": "458_bowtie2_2.5.1_pat.h_zread.cpp", "target": 0, "func": "int zread(voidp buf, unsigned len) {\n\t\tint r = gzread(zfp_, buf, len);\n\t\tif (r < 0) {\n\t\t\tconst char *err = gzerror(zfp_, NULL);\n\t\t\tif (err != NULL) {\n\t\t\t\tstd::cerr << err << std::endl;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}", "idx": 396}
{"project": "bowtie2", "commit_id": "459_bowtie2_2.5.1_pat.h_is_gzipped_file.cpp", "target": 0, "func": "bool is_gzipped_file(int fd) {\n\t\tif (fd == -1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tuint8_t byte1, byte2;\n\n\t\tssize_t r1 = read(fd, &byte1, sizeof(uint8_t));\n\t\tssize_t r2 = read(fd, &byte2, sizeof(uint8_t));\n\n\t\tlseek(fd, 0, SEEK_SET);\n                if (r1 == 0 || r2 == 0) {\n                        std::cerr << \"Unable to read file magic number\" << std::endl;\n                        return false;\n                }\n\n\t\tif (byte1 == 0x1f && byte2 == 0x8b) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}", "idx": 397}
{"project": "bowtie2", "commit_id": "45_bowtie2_2.5.1_aligner_result.h_calcRefExtent.cpp", "target": 0, "func": "void calcRefExtent() {\n\t\tassert_gt(rdextent_, 0);\n\t\trfextent_ = rdextent_;\n\t\tfor(size_t i = 0; i < ned_.size(); i++) {\n\t\t\tif(ned_[i].isRefGap()) rfextent_--;\n\t\t\tif(ned_[i].isReadGap()) rfextent_++;\n\t\t}\n\t}", "idx": 398}
{"project": "bowtie2", "commit_id": "460_bowtie2_2.5.1_pat.h_is_zstd_file.cpp", "target": 0, "func": "ifdef WITH_ZSTD\n\tbool is_zstd_file(int fd) {\n\t\tif (fd == -1)\n\t\t\treturn false;\n\n\t\tunsigned magic;\n\n                if (read(fd, &magic, sizeof(unsigned)) != sizeof(unsigned)) {\n\t\t\tstd::cerr << \"is_zstd_file: unable to read magic number\" << std::endl;\n\t\t\treturn false;\n                }\n\t\tlseek(fd, 0, SEEK_SET);\n\n                return magic == 0xfd2fb528;\n\t}", "idx": 399}
{"project": "bowtie2", "commit_id": "461_bowtie2_2.5.1_pat.h_skipToNextFastaRecord.cpp", "target": 0, "func": "static int skipToNextFastaRecord(FileBuf& in) {\n\t\tint c;\n\t\twhile((c = in.get()) != '>') {\n\t\t\tif(in.eof()) return -1;\n\t\t}\n\t\treturn c;\n\t}", "idx": 400}
{"project": "bowtie2", "commit_id": "462_bowtie2_2.5.1_pat.h_parse.cpp", "target": 0, "func": "bool parse(Read& ra, Read& rb) {\n\t\treturn composer_.parse(ra, rb, buf_.rdid());\n\t}", "idx": 401}
{"project": "bowtie2", "commit_id": "463_bowtie2_2.5.1_pat.h_nextReadPair.cpp", "target": 0, "func": "if none in the queue\n\tReadElement nextReadPair() {\n\t\treturn psq_ready_.pop();\n\t}", "idx": 402}
{"project": "bowtie2", "commit_id": "464_bowtie2_2.5.1_pat.h_returnUnready.cpp", "target": 0, "func": "void returnUnready(ReadElement& re) {\n\t\treturnUnready(re.ps);\n\t}", "idx": 403}
{"project": "bowtie2", "commit_id": "465_bowtie2_2.5.1_pat.h_empty.cpp", "target": 0, "func": "bool empty() {\n\t\t\tbool ret = false;\n\t\t\t{\n\t\t\t\tstd::unique_lock<std::mutex> lk(m_);\n\t\t\t\tret = q_.empty();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}", "idx": 404}
{"project": "bowtie2", "commit_id": "466_bowtie2_2.5.1_pat.h_push.cpp", "target": 0, "func": "void push(T& ps) {\n\t\t\t{\n\t\t\t\tstd::unique_lock<std::mutex> lk(m_);\n\t\t\t\tq_.push(ps);\n\t\t\t}\n\t\t\tcv_.notify_all();\n\t\t}", "idx": 405}
{"project": "bowtie2", "commit_id": "467_bowtie2_2.5.1_pat.h_pop.cpp", "target": 0, "func": "if none in the queue\n\t\tT pop() {\n\t\t\tT ret;\n\t\t\t{\n\t\t\t\tstd::unique_lock<std::mutex> lk(m_);\n\t\t\t\twhile (q_.empty()) cv_.wait(lk);\n\t\t\t\tret = q_.front();\n\t\t\t\tq_.pop();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}", "idx": 406}
{"project": "bowtie2", "commit_id": "468_bowtie2_2.5.1_pat.h_readAsync.cpp", "target": 0, "func": "static void readAsync(PatternSourceReadAheadFactory *obj) {\n\t\tLockedREQueue &psq_ready = obj->psq_ready_;\n\t\tLockedPSQueue &psq_idle = obj->psq_idle_;\n                while(true) {\n\t\t\tReadElement re;\n\t\t\tre.ps = psq_idle.pop();\n\t\t\tif (re.ps==NULL) break; // the destructor added this in the queue\n\n\t\t\tif (re.ps->nextReadPairReady()) {\n\t\t\t\t// Should never get in here, but just in case\n\t\t\t\tre.readResult = make_pair(true, false);\n\t\t\t} else {\n\t\t\t\tre.readResult = re.ps->nextReadPair();\n\t\t\t}\n\t\t\tpsq_ready.push(re);\n                }\n\t}", "idx": 407}
{"project": "bowtie2", "commit_id": "469_bowtie2_2.5.1_pe.cpp_testCaseClassify.cpp", "target": 0, "func": "void testCaseClassify(\n\tconst string& name,\n\tint      pol,\n\tsize_t   maxfrag,\n\tsize_t   minfrag,\n\tbool     local,\n\tbool     flip,\n\tbool     dove,\n\tbool     cont,\n\tbool     olap,\n\tbool     expand,\n\tint64_t  off1,\n\tsize_t   len1,\n\tbool     fw1,\n\tint64_t  off2,\n\tsize_t   len2,\n\tbool     fw2,\n\tint      expect_class)\n{\n\tPairedEndPolicy pepol(\n\t\tpol,\n\t\tmaxfrag,\n\t\tminfrag,\n\t\tlocal,\n\t\tflip,\n\t\tdove,\n\t\tcont,\n\t\tolap,\n\t\texpand);\n\tint ret = pepol.peClassifyPair(\n\t\toff1,   // offset of mate 1\n\t\tlen1,   // length of mate 1\n\t\tfw1,    // whether mate 1 aligned to Watson\n\t\toff2,   // offset of mate 2\n\t\tlen2,   // length of mate 2\n\t\tfw2);   // whether mate 2 aligned to Watson\n\tassert_eq(expect_class, ret);\n\tcout << \"peClassifyPair: \" << name << \"...PASSED\" << endl;\n}", "idx": 408}
{"project": "bowtie2", "commit_id": "46_bowtie2_2.5.1_aligner_result.h_AlnSetSumm.cpp", "target": 0, "func": "explicit AlnSetSumm(\n\t\tTNumAlns other1,\n\t\tTNumAlns other2,\n\t\tbool     paired,\n\t\tbool     exhausted1,\n\t\tbool     exhausted2,\n\t\tTRefId   orefid,\n\t\tTRefOff  orefoff)\n\t{\n\t\tinit(\n\t\t\tother1,\n\t\t\tother2,\n\t\t\tpaired,\n\t\t\texhausted1,\n\t\t\texhausted2,\n\t\t\torefid,\n\t\t\torefoff);\n\t}", "idx": 409}
{"project": "bowtie2", "commit_id": "470_bowtie2_2.5.1_pe.cpp_testCaseOtherMate.cpp", "target": 0, "func": "void testCaseOtherMate(\n\tconst string& name,\n\tint      pol,\n\tsize_t   maxfrag,\n\tsize_t   minfrag,\n\tbool     local,\n\tbool     flip,\n\tbool     dove,\n\tbool     cont,\n\tbool     olap,\n\tbool     expand,\n\tbool     is1,\n\tbool     fw,\n\tint64_t  off,\n\tint64_t  maxalcols,\n\tsize_t   reflen,\n\tsize_t   len1,\n\tsize_t   len2,\n\tbool     expect_ret,\n\tbool     expect_oleft,\n\tint64_t  expect_oll,\n\tint64_t  expect_olr,\n\tint64_t  expect_orl,\n\tint64_t  expect_orr,\n\tbool     expect_ofw)\n{\n\tPairedEndPolicy pepol(\n\t\tpol,\n\t\tmaxfrag,\n\t\tminfrag,\n\t\tlocal,\n\t\tflip,\n\t\tdove,\n\t\tcont,\n\t\tolap,\n\t\texpand);\n\tint64_t oll = 0, olr = 0;\n\tint64_t orl = 0, orr = 0;\n\tbool oleft = false, ofw = false;\n\tbool ret = pepol.otherMate(\n\t\tis1,\n\t\tfw,\n\t\toff,\n\t\tmaxalcols,\n\t\treflen,\n\t\tlen1,\n\t\tlen2,\n\t\toleft,\n\t\toll,\n\t\tolr,\n\t\torl,\n\t\torr,\n\t\tofw);\n\tassert(ret == expect_ret);\n\tif(ret) {\n\t\tassert_eq(expect_oleft, oleft);\n\t\tassert_eq(expect_oll, oll);\n\t\tassert_eq(expect_olr, olr);\n\t\tassert_eq(expect_orl, orl);\n\t\tassert_eq(expect_orr, orr);\n\t\tassert_eq(expect_ofw, ofw);\n\t}\n\tcout << \"otherMate: \" << name << \"...PASSED\" << endl;\n}", "idx": 410}
{"project": "bowtie2", "commit_id": "471_bowtie2_2.5.1_pe.cpp_main.cpp", "target": 0, "func": "int main(int argc, char **argv) {\n\n\t// Set of 8 cases where we look for the opposite mate to the right\n\t// of the anchor mate, with various combinations of policies and\n\t// anchor-mate orientations.\n\n\t// |--------|\n\t//           |--------|\n\t//           ^110     ^119\n\t// |------------------|\n\t//      min frag\n\t//                     |--------|\n\t//                     ^120     ^129\n\t// |----------------------------|\n\t//           max frag\n\t// ^\n\t// 100\n\n\t{\n\tint  policies[] = { PE_POLICY_FF, PE_POLICY_RR, PE_POLICY_FR, PE_POLICY_RF, PE_POLICY_FF, PE_POLICY_RR, PE_POLICY_FR, PE_POLICY_RF };\n\tbool is1[]      = { true,  true,   true,  true, false, false, false, false };\n\tbool fw[]       = { true,  false,  true, false, false,  true,  true, false };\n\tbool oleft[]    = { false, false, false, false, false, false, false, false };\n\tbool ofw[]      = { true,  false, false,  true, false,  true, false,  true };\n\n\tfor(int i = 0; i < 8; i++) {\n\t\tostringstream oss;\n\t\toss << \"Simple\";\n\t\toss << i;\n\t\ttestCaseOtherMate(\n\t\t\toss.str(),\n\t\t\tpolicies[i],  // policy\n\t\t\t30,           // maxfrag\n\t\t\t20,           // minfrag\n\t\t\tfalse,        // local\n\t\t\ttrue,         // flipping OK\n\t\t\ttrue,         // dovetail OK\n\t\t\ttrue,         // containment OK\n\t\t\ttrue,         // overlap OK\n\t\t\ttrue,         // expand-to-fit\n\t\t\tis1[i],       // mate 1 is anchor\n\t\t\tfw[i],        // anchor aligned to Watson\n\t\t\t100,          // anchor's offset into ref\n\t\t\t-1,           // max # alignment cols\n\t\t\t200,          // ref length\n\t\t\t10,           // mate 1 length\n\t\t\t10,           // mate 2 length\n\t\t\ttrue,         // expected return val from otherMate\n\t\t\toleft[i],     // wheter to look for opposite to left\n\t\t\t80,           // expected leftmost pos for opp mate LHS\n\t\t\t129,          // expected rightmost pos for opp mate LHS\n\t\t\t119,          // expected leftmost pos for opp mate RHS\n\t\t\t129,          // expected rightmost pos for opp mate RHS\n\t\t\tofw[i]);      // expected orientation in which opposite mate must align\n\t}\n\t}\n\n\t// Set of 8 cases where we look for the opposite mate to the left\n\t// of the anchor mate, with various combinations of policies and\n\t// anchor-mate orientations.\n\n\t// |--------|\n\t// ^100     ^109\n\t//           |--------|\n\t//           ^110     ^119\n\t//           |------------------|\n\t//                 min frag\n\t//                     |-Anchor-|\n\t//                     ^120     ^129\n\t// |----------------------------|\n\t//           max frag\n\t// ^\n\t// 100\n\n\t{\n\tint  policies[] = { PE_POLICY_FF, PE_POLICY_RR, PE_POLICY_FR, PE_POLICY_RF, PE_POLICY_FF, PE_POLICY_RR, PE_POLICY_FR, PE_POLICY_RF };\n\tbool is1[]      = { false, false, false, false,  true,  true,  true,  true };\n\tbool fw[]       = {  true, false, false,  true, false,  true, false,  true };\n\tbool oleft[]    = {  true,  true,  true,  true,  true,  true,  true,  true };\n\tbool ofw[]      = {  true, false,  true, false, false,  true,  true, false };\n\t\n\tfor(int i = 0; i < 8; i++) {\n\t\tostringstream oss;\n\t\toss << \"Simple\";\n\t\toss << (i+8);\n\t\ttestCaseOtherMate(\n\t\t\toss.str(),\n\t\t\tpolicies[i],  // policy\n\t\t\t30,           // maxfrag\n\t\t\t20,           // minfrag\n\t\t\tfalse,        // local\n\t\t\ttrue,         // flipping OK\n\t\t\ttrue,         // dovetail OK\n\t\t\ttrue,         // containment OK\n\t\t\ttrue,         // overlap OK\n\t\t\ttrue,         // expand-to-fit\n\t\t\tis1[i],       // mate 1 is anchor\n\t\t\tfw[i],        // anchor aligned to Watson\n\t\t\t120,          // anchor's offset into ref\n\t\t\t-1,           // max # alignment cols\n\t\t\t200,          // ref length\n\t\t\t10,           // mate 1 length\n\t\t\t10,           // mate 2 length\n\t\t\ttrue,         // expected return val from otherMate\n\t\t\toleft[i],     // wheter to look for opposite to left\n\t\t\t100,          // expected leftmost pos for opp mate LHS\n\t\t\t110,          // expected rightmost pos for opp mate LHS\n\t\t\t100,          // expected leftmost pos for opp mate RHS\n\t\t\t149,          // expected rightmost pos for opp mate RHS\n\t\t\tofw[i]);      // expected orientation in which opposite mate must align\n\t}\n\t}\n\n\t// Case where min frag == max frag and opposite is to the right\n\n\t// |----------------------------|\n\t//      min frag\n\t//                     |--------|\n\t//                     ^120     ^129\n\t// |----------------------------|\n\t//           max frag\n\t// ^\n\t// 100\n\ttestCaseOtherMate(\n\t\t\"MinFragEqMax1\",\n\t\tPE_POLICY_FR, // policy\n\t\t30,           // maxfrag\n\t\t30,           // minfrag\n\t\tfalse,        // local\n\t\ttrue,         // flipping OK\n\t\ttrue,         // dovetail OK\n\t\ttrue,         // containment OK\n\t\ttrue,         // overlap OK\n\t\ttrue,         // expand-to-fit\n\t\tfalse,        // mate 1 is anchor\n\t\tfalse,        // anchor aligned to Watson\n\t\t120,          // anchor's offset into ref\n\t\t-1,           // max # alignment cols\n\t\t200,          // ref length\n\t\t10,           // mate 1 length\n\t\t10,           // mate 2 length\n\t\ttrue,         // expected return val from otherMate\n\t\ttrue,         // wheter to look for opposite to left\n\t\t100,          // expected leftmost pos for opp mate LHS\n\t\t100,          // expected rightmost pos for opp mate LHS\n\t\t100,          // expected leftmost pos for opp mate RHS\n\t\t149,          // expected rightmost pos for opp mate RHS\n\t\ttrue);        // expected orientation in which opposite mate must align\n\n\t// Case where min frag == max frag and opposite is to the right\n\n\t// |----------------------------|\n\t//      min frag                ^129\n\t// |--------|\n\t// ^100     ^109\n\t// |----------------------------|\n\t//           max frag\n\ttestCaseOtherMate(\n\t\t\"MinFragEqMax2\",\n\t\tPE_POLICY_FR, // policy\n\t\t30,           // maxfrag\n\t\t30,           // minfrag\n\t\tfalse,        // local\n\t\ttrue,         // flipping OK\n\t\ttrue,         // dovetail OK\n\t\ttrue,         // containment OK\n\t\ttrue,         // overlap OK\n\t\ttrue,         // expand-to-fit\n\t\ttrue,         // mate 1 is anchor\n\t\ttrue,         // anchor aligned to Watson\n\t\t100,          // anchor's offset into ref\n\t\t-1,           // max # alignment cols\n\t\t200,          // ref length\n\t\t10,           // mate 1 length\n\t\t10,           // mate 2 length\n\t\ttrue,         // expected return val from otherMate\n\t\tfalse,        // wheter to look for opposite to left\n\t\t80,           // expected leftmost pos for opp mate LHS\n\t\t129,          // expected rightmost pos for opp mate LHS\n\t\t129,          // expected leftmost pos for opp mate RHS\n\t\t129,          // expected rightmost pos for opp mate RHS\n\t\tfalse);       // expected orientation in which opposite mate must align\n\n\ttestCaseOtherMate(\n\t\t\"MinFragEqMax4NoDove1\",\n\t\tPE_POLICY_FR, // policy\n\t\t30,           // maxfrag\n\t\t25,           // minfrag\n\t\tfalse,        // local\n\t\ttrue,         // flipping OK\n\t\tfalse,        // dovetail OK\n\t\ttrue,         // containment OK\n\t\ttrue,         // overlap OK\n\t\ttrue,         // expand-to-fit\n\t\ttrue,         // mate 1 is anchor\n\t\ttrue,         // anchor aligned to Watson\n\t\t100,          // anchor's offset into ref\n\t\t-1,           // max # alignment cols\n\t\t200,          // ref length\n\t\t10,           // mate 1 length\n\t\t10,           // mate 2 length\n\t\ttrue,         // expected return val from otherMate\n\t\tfalse,        // wheter to look for opposite to left\n\t\t100,          // expected leftmost pos for opp mate LHS\n\t\t129,          // expected rightmost pos for opp mate LHS\n\t\t124,          // expected leftmost pos for opp mate RHS\n\t\t129,          // expected rightmost pos for opp mate RHS\n\t\tfalse);       // expected orientation in which opposite mate must align\n\n\ttestCaseOtherMate(\n\t\t\"MinFragEqMax4NoCont1\",\n\t\tPE_POLICY_FR, // policy\n\t\t30,           // maxfrag\n\t\t25,           // minfrag\n\t\tfalse,        // local\n\t\ttrue,         // flipping OK\n\t\tfalse,        // dovetail OK\n\t\tfalse,        // containment OK\n\t\ttrue,         // overlap OK\n\t\ttrue,         // expand-to-fit\n\t\ttrue,         // mate 1 is anchor\n\t\ttrue,         // anchor aligned to Watson\n\t\t100,          // anchor's offset into ref\n\t\t-1,           // max # alignment cols\n\t\t200,          // ref length\n\t\t10,           // mate 1 length\n\t\t10,           // mate 2 length\n\t\ttrue,         // expected return val from otherMate\n\t\tfalse,        // wheter to look for opposite to left\n\t\t100,          // expected leftmost pos for opp mate LHS\n\t\t129,          // expected rightmost pos for opp mate LHS\n\t\t124,          // expected leftmost pos for opp mate RHS\n\t\t129,          // expected rightmost pos for opp mate RHS\n\t\tfalse);       // expected orientation in which opposite mate must align\n\n\ttestCaseOtherMate(\n\t\t\"MinFragEqMax4NoOlap1\",\n\t\tPE_POLICY_FR, // policy\n\t\t30,           // maxfrag\n\t\t25,           // minfrag\n\t\tfalse,        // local\n\t\ttrue,         // flipping OK\n\t\tfalse,        // dovetail OK\n\t\tfalse,        // containment OK\n\t\tfalse,        // overlap OK\n\t\ttrue,         // expand-to-fit\n\t\ttrue,         // mate 1 is anchor\n\t\ttrue,         // anchor aligned to Watson\n\t\t100,          // anchor's offset into ref\n\t\t-1,           // max # alignment cols\n\t\t200,          // ref length\n\t\t10,           // mate 1 length\n\t\t10,           // mate 2 length\n\t\ttrue,         // expected return val from otherMate\n\t\tfalse,        // wheter to look for opposite to left\n\t\t110,          // expected leftmost pos for opp mate LHS\n\t\t129,          // expected rightmost pos for opp mate LHS\n\t\t124,          // expected leftmost pos for opp mate RHS\n\t\t129,          // expected rightmost pos for opp mate RHS\n\t\tfalse);       // expected orientation in which opposite mate must align\n\n\ttestCaseOtherMate(\n\t\t\"MinFragEqMax4NoDove2\",\n\t\tPE_POLICY_FR, // policy\n\t\t30,           // maxfrag\n\t\t25,           // minfrag\n\t\tfalse,        // local\n\t\ttrue,         // flipping OK\n\t\tfalse,        // dovetail OK\n\t\ttrue,         // containment OK\n\t\ttrue,         // overlap OK\n\t\ttrue,         // expand-to-fit\n\t\tfalse,        // mate 1 is anchor\n\t\tfalse,        // anchor aligned to Watson\n\t\t120,          // anchor's offset into ref\n\t\t-1,           // max # alignment cols\n\t\t200,          // ref length\n\t\t10,           // mate 1 length\n\t\t10,           // mate 2 length\n\t\ttrue,         // expected return val from otherMate\n\t\ttrue,         // whether to look for opposite to left\n\t\t100,          // expected leftmost pos for opp mate LHS\n\t\t105,          // expected rightmost pos for opp mate LHS\n\t\t100,          // expected leftmost pos for opp mate RHS\n\t\t129,          // expected rightmost pos for opp mate RHS\n\t\ttrue);        // expected orientation in which opposite mate must align\n\n\ttestCaseOtherMate(\n\t\t\"MinFragEqMax4NoOlap2\",\n\t\tPE_POLICY_FR, // policy\n\t\t30,           // maxfrag\n\t\t25,           // minfrag\n\t\tfalse,        // local\n\t\ttrue,         // flipping OK\n\t\tfalse,        // dovetail OK\n\t\tfalse,        // containment OK\n\t\tfalse,        // overlap OK\n\t\ttrue,         // expand-to-fit\n\t\tfalse,        // mate 1 is anchor\n\t\tfalse,        // anchor aligned to Watson\n\t\t120,          // anchor's offset into ref\n\t\t-1,           // max # alignment cols\n\t\t200,          // ref length\n\t\t10,           // mate 1 length\n\t\t10,           // mate 2 length\n\t\ttrue,         // expected return val from otherMate\n\t\ttrue,         // whether to look for opposite to left\n\t\t100,          // expected leftmost pos for opp mate LHS\n\t\t105,          // expected rightmost pos for opp mate LHS\n\t\t100,          // expected leftmost pos for opp mate RHS\n\t\t119,          // expected rightmost pos for opp mate RHS\n\t\ttrue);        // expected orientation in which opposite mate must align\n\n\t{\n\tint olls[] = { 110 };\n\tint olrs[] = { 299 };\n\tint orls[] = { 149 };\n\tint orrs[] = { 299 };\n\tfor(int i = 0; i < 1; i++) {\n\t\tostringstream oss;\n\t\toss << \"Overhang1_\";\n\t\toss << (i+1);\n\t\ttestCaseOtherMate(\n\t\t\toss.str(),\n\t\t\tPE_POLICY_FR, // policy\n\t\t\t200,          // maxfrag\n\t\t\t50,           // minfrag\n\t\t\tfalse,        // local\n\t\t\ttrue,         // flipping OK\n\t\t\ttrue,         // dovetail OK\n\t\t\ttrue,         // containment OK\n\t\t\tfalse,        // overlap OK\n\t\t\ttrue,         // expand-to-fit\n\t\t\ttrue,         // mate 1 is anchor\n\t\t\ttrue,         // anchor aligned to Watson\n\t\t\t100,          // anchor's offset into ref\n\t\t\t-1,           // max # alignment cols\n\t\t\t200,          // ref length\n\t\t\t10,           // mate 1 length\n\t\t\t10,           // mate 2 length\n\t\t\ttrue,         // expected return val from otherMate\n\t\t\tfalse,        // whether to look for opposite to left\n\t\t\tolls[i],      // expected leftmost pos for opp mate LHS\n\t\t\tolrs[i],      // expected rightmost pos for opp mate LHS\n\t\t\torls[i],      // expected leftmost pos for opp mate RHS\n\t\t\torrs[i],      // expected rightmost pos for opp mate RHS\n\t\t\tfalse);       // expected orientation in which opposite mate must align\n\t}\n\t}\n\n\t{\n\tint olls[] = { -100 };\n\tint olrs[] = {   50 };\n\tint orls[] = { -100 };\n\tint orrs[] = {   89 };\n\tfor(int i = 0; i < 1; i++) {\n\t\tostringstream oss;\n\t\toss << \"Overhang2_\";\n\t\toss << (i+1);\n\t\ttestCaseOtherMate(\n\t\t\toss.str(),\n\t\t\tPE_POLICY_FR, // policy\n\t\t\t200,          // maxfrag\n\t\t\t50,           // minfrag\n\t\t\tfalse,        // local\n\t\t\ttrue,         // flipping OK\n\t\t\ttrue,         // dovetail OK\n\t\t\ttrue,         // containment OK\n\t\t\tfalse,        // overlap OK\n\t\t\ttrue,         // expand-to-fit\n\t\t\ttrue,         // mate 1 is anchor\n\t\t\tfalse,        // anchor aligned to Watson\n\t\t\t90,           // anchor's offset into ref\n\t\t\t-1,           // max # alignment cols\n\t\t\t200,          // ref length\n\t\t\t10,           // mate 1 length\n\t\t\t10,           // mate 2 length\n\t\t\ttrue,         // expected return val from otherMate\n\t\t\ttrue,         // whether to look for opposite to left\n\t\t\tolls[i],      // expected leftmost pos for opp mate LHS\n\t\t\tolrs[i],      // expected rightmost pos for opp mate LHS\n\t\t\torls[i],      // expected leftmost pos for opp mate RHS\n\t\t\torrs[i],      // expected rightmost pos for opp mate RHS\n\t\t\ttrue);        // expected orientation in which opposite mate must align\n\t}\n\t}\n\n\t{\n\tint mate2offs[] = {           150,            149,            149,            100,              99,           299,              1,            250,            250 };\n\tint mate2lens[] = {            50,             50,             51,            100,             101,             1,             50,             50,             51 };\n\tint peExpects[] = { PE_ALS_NORMAL, PE_ALS_DISCORD, PE_ALS_OVERLAP, PE_ALS_CONTAIN, PE_ALS_DOVETAIL, PE_ALS_NORMAL, PE_ALS_DISCORD,  PE_ALS_NORMAL, PE_ALS_DISCORD };\n\n\tfor(int i = 0; i < 9; i++) {\n\t\tostringstream oss;\n\t\toss << \"Simple1_\";\n\t\toss << (i);\n\t\ttestCaseClassify(\n\t\t\toss.str(),\n\t\t\tPE_POLICY_FR, // policy\n\t\t\t200,          // maxfrag\n\t\t\t100,          // minfrag\n\t\t\tfalse,        // local\n\t\t\ttrue,         // flipping OK\n\t\t\ttrue,         // dovetail OK\n\t\t\ttrue,         // containment OK\n\t\t\ttrue,         // overlap OK\n\t\t\ttrue,         // expand-to-fit\n\t\t\t100,          // offset of mate 1\n\t\t\t50,           // length of mate 1\n\t\t\ttrue,         // whether mate 1 aligned to Watson\n\t\t\tmate2offs[i], // offset of mate 2\n\t\t\tmate2lens[i], // length of mate 2\n\t\t\tfalse,        // whether mate 2 aligned to Watson\n\t\t\tpeExpects[i]);// expectation for PE_ALS flag returned\n\t}\n\t}\n\n\t{\n\tint mate1offs[] = {           200,            201,            200,            200,             200,           100,            400,            100,             99 };\n\tint mate1lens[] = {            50,             49,             51,            100,             101,             1,             50,             50,             51 };\n\tint peExpects[] = { PE_ALS_NORMAL, PE_ALS_DISCORD, PE_ALS_OVERLAP, PE_ALS_CONTAIN, PE_ALS_DOVETAIL, PE_ALS_NORMAL, PE_ALS_DISCORD,  PE_ALS_NORMAL, PE_ALS_DISCORD };\n\n\tfor(int i = 0; i < 9; i++) {\n\t\tostringstream oss;\n\t\toss << \"Simple2_\";\n\t\toss << (i);\n\t\ttestCaseClassify(\n\t\t\toss.str(),\n\t\t\tPE_POLICY_FR, // policy\n\t\t\t200,          // maxfrag\n\t\t\t100,          // minfrag\n\t\t\tfalse,        // local\n\t\t\ttrue,         // flipping OK\n\t\t\ttrue,         // dovetail OK\n\t\t\ttrue,         // containment OK\n\t\t\ttrue,         // overlap OK\n\t\t\ttrue,         // expand-to-fit\n\t\t\tmate1offs[i], // offset of mate 1\n\t\t\tmate1lens[i], // length of mate 1\n\t\t\ttrue,         // whether mate 1 aligned to Watson\n\t\t\t250,          // offset of mate 2\n\t\t\t50,           // length of mate 2\n\t\t\tfalse,        // whether mate 2 aligned to Watson\n\t\t\tpeExpects[i]);// expectation for PE_ALS flag returned\n\t}\n\t}\n\n\ttestCaseOtherMate(\n\t\t\"Regression1\",\n\t\tPE_POLICY_FF, // policy\n\t\t50,           // maxfrag\n\t\t0,            // minfrag\n\t\tfalse,        // local\n\t\ttrue,         // flipping OK\n\t\ttrue,         // dovetail OK\n\t\ttrue,         // containment OK\n\t\ttrue,         // overlap OK\n\t\ttrue,         // expand-to-fit\n\t\ttrue,         // mate 1 is anchor\n\t\tfalse,        // anchor aligned to Watson\n\t\t3,            // anchor's offset into ref\n\t\t-1,           // max # alignment cols\n\t\t53,           // ref length\n\t\t10,           // mate 1 length\n\t\t10,           // mate 2 length\n\t\ttrue,         // expected return val from otherMate\n\t\ttrue,         // whether to look for opposite to left\n\t\t-37,          // expected leftmost pos for opp mate LHS\n\t\t13,           // expected rightmost pos for opp mate LHS\n\t\t-37,          // expected leftmost pos for opp mate RHS\n\t\t52,           // expected rightmost pos for opp mate RHS\n\t\tfalse);       // expected orientation in which opposite mate must align\n}", "idx": 411}
{"project": "bowtie2", "commit_id": "472_bowtie2_2.5.1_pe.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tinit(-1, 0xffffffff, 0xffffffff, false, false, false, false, false, false);\n\t}", "idx": 412}
{"project": "bowtie2", "commit_id": "473_bowtie2_2.5.1_pe.h_init.cpp", "target": 0, "func": "void init(\n\t\tint pol,\n\t\tsize_t maxfrag,\n\t\tsize_t minfrag,\n\t\tbool local,\n\t\tbool flippingOk,\n\t\tbool dovetailOk,\n\t\tbool containOk,\n\t\tbool olapOk,\n\t\tbool expandToFit)\n\t{\n\t\tpol_         = pol;\n\t\tmaxfrag_     = maxfrag;\n\t\tminfrag_     = minfrag;\n\t\tlocal_       = local;\n\t\tflippingOk_  = flippingOk;\n\t\tdovetailOk_  = dovetailOk;\n\t\tcontainOk_   = containOk;\n\t\tolapOk_      = olapOk;\n\t\texpandToFit_ = expandToFit;\n\t}", "idx": 413}
{"project": "bowtie2", "commit_id": "474_bowtie2_2.5.1_processor_support.h_POPCNTenabled.cpp", "target": 0, "func": "bool POPCNTenabled()\n    {\n    // from: Intel\u00ae 64 and IA-32 Architectures Software Developer\u2019s Manual, 325462-036US,March 2013\n    //Before an application attempts to use the POPCNT instruction, it must check that the\n    //processor supports SSE4.2\n    //\"(if CPUID.01H:ECX.SSE4_2[bit 20] = 1) and POPCNT (if CPUID.01H:ECX.POPCNT[bit 23] = 1)\"\n    //\n    // see p.272 of http://download.intel.com/products/processor/manual/253667.pdf available at\n    // http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html\n    // Also http://en.wikipedia.org/wiki/SSE4 talks about available on Intel & AMD processors\n\n    regs_t regs;\n\n    try {\n#if ( defined(USING_INTEL_COMPILER) || defined(USING_MSC_COMPILER) )\n        __cpuid((int *) &regs,0); // test if __cpuid() works, if not catch the exception\n        __cpuid((int *) &regs,0x1); // POPCNT bit is bit 23 in ECX\n#elif defined(USING_GCC_COMPILER)\n        __get_cpuid(0x1, &regs.EAX, &regs.EBX, &regs.ECX, &regs.EDX);\n#else\n        std::cerr << \"ERROR: please define __cpuid() for this build.\\n\";\n        assert(0);\n#endif\n        if( !( (regs.ECX & BIT(20)) && (regs.ECX & BIT(23)) ) ) return false;\n    }\n    catch (int e) {\n        return false;\n    }\n    return true;\n    }", "idx": 414}
{"project": "bowtie2", "commit_id": "475_bowtie2_2.5.1_qual.h_phredcToPhredq.cpp", "target": 0, "func": "encoded ASCII character into a Phred quality\nstatic inline uint8_t phredcToPhredq(char c) {\n\treturn ((uint8_t)c >= 33 ? ((uint8_t)c - 33) : 0);\n}", "idx": 415}
{"project": "bowtie2", "commit_id": "476_bowtie2_2.5.1_qual.h_solexaToPhred.cpp", "target": 0, "func": "static inline uint8_t solexaToPhred(int sol) {\n\tassert_lt(sol, 256);\n\tif(sol < -10) return 0;\n\treturn solToPhred[sol+10];\n}", "idx": 416}
{"project": "bowtie2", "commit_id": "477_bowtie2_2.5.1_qual.h_mmPenalty.cpp", "target": 0, "func": "static inline uint8_t mmPenalty(bool maq, uint8_t qual) {\n\tif(maq) {\n\t\treturn MaqPhredPenalty::mmPenalty(qual);\n\t} else {\n\t\treturn SimplePhredPenalty::mmPenalty(qual);\n\t}\n}", "idx": 417}
{"project": "bowtie2", "commit_id": "478_bowtie2_2.5.1_qual.h_delPenalty.cpp", "target": 0, "func": "static inline uint8_t delPenalty(bool maq, uint8_t qual) {\n\tif(maq) {\n\t\treturn MaqPhredPenalty::delPenalty(qual);\n\t} else {\n\t\treturn SimplePhredPenalty::delPenalty(qual);\n\t}\n}", "idx": 418}
{"project": "bowtie2", "commit_id": "479_bowtie2_2.5.1_qual.h_insPenalty.cpp", "target": 0, "func": "static inline uint8_t insPenalty(bool maq, uint8_t qual_left, uint8_t qual_right) {\n\tif(maq) {\n\t\treturn MaqPhredPenalty::insPenalty(qual_left, qual_right);\n\t} else {\n\t\treturn SimplePhredPenalty::insPenalty(qual_left, qual_right);\n\t}\n}", "idx": 419}
{"project": "bowtie2", "commit_id": "47_bowtie2_2.5.1_aligner_result.h_setBest.cpp", "target": 0, "func": "void setBest(\n\t\tAlnScore bestUScore,\n\t\tAlnScore bestUDist,\n\t\tAlnScore bestP1Score,\n\t\tAlnScore bestP1Dist,\n\t\tAlnScore bestP2Score,\n\t\tAlnScore bestP2Dist,\n\t\tAlnScore bestCScore,\n\t\tAlnScore bestCDist,\n\t\tAlnScore bestUnchosenUScore,\n\t\tAlnScore bestUnchosenUDist,\n\t\tAlnScore bestUnchosenP1Score,\n\t\tAlnScore bestUnchosenP1Dist,\n\t\tAlnScore bestUnchosenP2Score,\n\t\tAlnScore bestUnchosenP2Dist,\n\t\tAlnScore bestUnchosenCScore,\n\t\tAlnScore bestUnchosenCDist)\n\t{\n\t\tassert(bestUScore.valid() == bestUDist.valid());\n\t\tassert(bestP1Score.valid() == bestP1Dist.valid());\n\t\tassert(bestP2Score.valid() == bestP2Dist.valid());\n\t\tassert(bestCScore.valid() == bestCDist.valid());\n\t\tassert(bestUnchosenUScore.valid() == bestUnchosenUDist.valid());\n\t\tassert(bestUnchosenP1Score.valid() == bestUnchosenP1Dist.valid());\n\t\tassert(bestUnchosenP2Score.valid() == bestUnchosenP2Dist.valid());\n\t\tassert(bestUnchosenCScore.valid() == bestUnchosenCDist.valid());\n\t\tbestUScore_ = bestUScore;\n\t\tbestUDist_ = bestUDist;\n\t\tbestP1Score_ = bestP1Score;\n\t\tbestP1Dist_ = bestP1Dist;\n\t\tbestP2Score_ = bestP2Score;\n\t\tbestP2Dist_ = bestP2Dist;\n\t\tbestCScore_ = bestCScore;\n\t\tbestCDist_ = bestCDist;\n\t\tbestUnchosenUScore_ = bestUnchosenUScore;\n\t\tbestUnchosenUDist_ = bestUnchosenUDist;\n\t\tbestUnchosenP1Score_ = bestUnchosenP1Score;\n\t\tbestUnchosenP1Dist_ = bestUnchosenP1Dist;\n\t\tbestUnchosenP2Score_ = bestUnchosenP2Score;\n\t\tbestUnchosenP2Dist_ = bestUnchosenP2Dist;\n\t\tbestUnchosenCScore_ = bestUnchosenCScore;\n\t\tbestUnchosenCDist_ = bestUnchosenCDist;\n\t}", "idx": 420}
{"project": "bowtie2", "commit_id": "480_bowtie2_2.5.1_qual.h_charToPhred33.cpp", "target": 0, "func": "inline static char charToPhred33(char c, bool solQuals, bool phred64Quals) {\n\tusing namespace std;\n\tif(c == ' ') {\n\t\tstd::cerr << \"Saw a space but expected an ASCII-encoded quality value.\" << endl\n\t\t          << \"Are quality values formatted as integers?  If so, try --integer-quals.\" << endl;\n\t\tthrow 1;\n\t}\n\tif (solQuals) {\n\t\t// Convert solexa-scaled chars to phred\n\t\t// http://maq.sourceforge.net/fastq.shtml\n\t\tchar cc = solexaToPhred((int)c - 64) + 33;\n\t\tif (cc < 33) {\n\t\t\tstd::cerr << \"Saw ASCII character \"\n\t\t\t          << ((int)c)\n\t\t\t          << \" but expected 64-based Solexa qual (converts to \" << (int)cc << \").\" << endl\n\t\t\t          << \"Try not specifying --solexa-quals.\" << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\tc = cc;\n\t}\n\telse if(phred64Quals) {\n\t\tif (c < 64) {\n\t\t\tcerr << \"Saw ASCII character \"\n\t\t\t     << ((int)c)\n\t\t\t     << \" but expected 64-based Phred qual.\" << endl\n\t\t\t     << \"Try not specifying --solexa1.3-quals/--phred64-quals.\" << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\t// Convert to 33-based phred\n\t\tc -= (64-33);\n\t}\n\telse {\n\t\t// Keep the phred quality\n\t\tif (c < 33) {\n\t\t\tcerr << \"Saw ASCII character \"\n\t\t\t     << ((int)c)\n\t\t\t     << \" but expected 33-based Phred qual.\" << endl;\n\t\t\tthrow 1;\n\t\t}\n\t}\n\treturn c;\n}", "idx": 421}
{"project": "bowtie2", "commit_id": "481_bowtie2_2.5.1_qual.h_intToPhred33.cpp", "target": 0, "func": "inline static char intToPhred33(int iQ, bool solQuals) {\n\tusing namespace std;\n\tint pQ;\n\tif (solQuals) {\n\t\t// Convert from solexa quality to phred\n\t\t// quality and translate to ASCII\n\t\t// http://maq.sourceforge.net/qual.shtml\n\t\tpQ = solexaToPhred((int)iQ) + 33;\n\t} else {\n\t\t// Keep the phred quality and translate\n\t\t// to ASCII\n\t\tpQ = (iQ <= 93 ? iQ : 93) + 33;\n\t}\n\tif (pQ < 33) {\n\t\tcerr << \"Saw negative Phred quality \" << ((int)pQ-33) << \".\" << endl;\n\t\tthrow 1;\n\t}\n\tassert_geq(pQ, 0);\n\treturn (int)pQ;\n}", "idx": 422}
{"project": "bowtie2", "commit_id": "482_bowtie2_2.5.1_qual.h_roundPenalty.cpp", "target": 0, "func": "inline static uint8_t roundPenalty(uint8_t p) {\n\tif(gNoMaqRound) return p;\n\treturn qualRounds[p];\n}", "idx": 423}
{"project": "bowtie2", "commit_id": "483_bowtie2_2.5.1_qual.h_penaltiesAt.cpp", "target": 0, "func": "inline static uint8_t penaltiesAt(size_t off, uint8_t *q,\n                                  int alts,\n                                  const BTString&    qual,\n                                  const BTDnaString *altQry,\n                                  const BTString    *altQual)\n{\n\tuint8_t primQ = qual[off]; // qual of primary call\n\tuint8_t bestPenalty = roundPenalty(phredcToPhredq(primQ));\n\t// By default, any mismatch incurs a penalty equal to the quality\n\t// of the called base\n\tq[0] = q[1] = q[2] = q[3] = bestPenalty;\n\tfor(int i = 0; i < alts; i++) {\n\t\tuint8_t altQ = altQual[i][off]; // qual of alt call\n\t\tif(altQ == 33) break; // no alt call\n\t\tassert_leq(altQ, primQ);\n\t\tuint8_t pen = roundPenalty(primQ - altQ);\n\t\tif(pen < bestPenalty) {\n\t\t\tbestPenalty = pen;\n\t\t}\n\t\t// Get the base\n\t\tint altC = (int)altQry[i][off];\n\t\tassert_lt(altC, 4);\n\t\tq[altC] = pen;\n\t}\n\t// Return the best penalty so that the caller can evaluate whether\n\t// any of the penalties are within-budget\n\treturn bestPenalty;\n}", "idx": 424}
{"project": "bowtie2", "commit_id": "484_bowtie2_2.5.1_qual.h_loPenaltyAt.cpp", "target": 0, "func": "inline static uint8_t loPenaltyAt(size_t off, int alts,\n                                  const BTString&    qual,\n                                  const BTString    *altQual)\n{\n\tuint8_t primQ = qual[off]; // qual of primary call\n\tuint8_t bestPenalty = roundPenalty(phredcToPhredq(primQ));\n\tfor(int i = 0; i < alts; i++) {\n\t\tuint8_t altQ = altQual[i][off]; // qual of alt call\n\t\tif(altQ == 33) break; // no more alt calls at this position\n\t\tassert_leq(altQ, primQ);\n\t\tuint8_t pen = roundPenalty(primQ - altQ);\n\t\tif(pen < bestPenalty) {\n\t\t\tbestPenalty = pen;\n\t\t}\n\t}\n\treturn bestPenalty;\n}", "idx": 425}
{"project": "bowtie2", "commit_id": "485_bowtie2_2.5.1_random_source.h_init.cpp", "target": 0, "func": "void init(uint32_t seed = 0) {\n\t\tlast = seed;\n\t\tinited_ = true;\n\t\tlastOff = 30;\n\t}", "idx": 426}
{"project": "bowtie2", "commit_id": "486_bowtie2_2.5.1_random_source.h_nextU32.cpp", "target": 0, "func": "inline uint32_t nextU32() {\n\t\tassert(inited_);\n\t\tif(p_ == n) {\n\t\t\tgen_state(); // new state vector needed\n\t\t}\n\t\t// gen_state() is split off to be non-inline, because it is only called once\n\t\t// in every 624 calls and otherwise irand() would become too big to get inlined\n\t\tuint32_t x = state_[p_++];\n\t\tx ^= (x >> 11);\n\t\tx ^= (x << 7) & 0x9D2C5680UL;\n\t\tx ^= (x << 15) & 0xEFC60000UL;\n\t\tx ^= (x >> 18);\n\t\treturn x;\n\t}", "idx": 427}
{"project": "bowtie2", "commit_id": "487_bowtie2_2.5.1_random_source.h_nextU64.cpp", "target": 0, "func": "uint64_t nextU64() {\n\t\tassert(inited_);\n\t\tuint64_t first = nextU32();\n\t\tfirst = first << 32;\n\t\tuint64_t second = nextU32();\n\t\treturn first | second;\n\t}", "idx": 428}
{"project": "bowtie2", "commit_id": "488_bowtie2_2.5.1_random_source.h_nextSizeT.cpp", "target": 0, "func": "size_t nextSizeT() {\n\t\tif(sizeof(size_t) == 4) {\n\t\t\treturn nextU32();\n\t\t} else {\n\t\t\treturn nextU64();\n\t\t}\n\t}", "idx": 429}
{"project": "bowtie2", "commit_id": "489_bowtie2_2.5.1_random_source.h_nextU32Range.cpp", "target": 0, "func": "uint32_t nextU32Range(uint32_t lo, uint32_t hi) {\n\t\tuint32_t ret = lo;\n\t\tif(hi > lo) {\n\t\t\tret += (nextU32() % (hi-lo+1));\n\t\t}\n\t\treturn ret;\n\t}", "idx": 430}
{"project": "bowtie2", "commit_id": "48_bowtie2_2.5.1_aligner_seed.cpp_exactSweepStep.cpp", "target": 0, "func": "inline bool exactSweepStep(\n\tconst Ebwt&        ebwt,    // BWT index\n\tconst TIndexOffU   top, \n\tconst TIndexOffU   bot,\n\tconst size_t       mineMax, // don't care about edit bounds > this\n\tSideLocus         &tloc, \n\tSideLocus         &bloc,\n\tsize_t            &mineCnt, // minimum # edits\n\tsize_t            &nedit,\n\tbool              &done\n\t)\n{\n\tif(bot <= top) {\n\t\tnedit++;\n\t\tif(nedit >= mineMax) {\n\t\t\tmineCnt = nedit;\n\t\t\tdone = true;\n\t\t}\n\t\treturn true;\n\t}\n\tINIT_LOCS(top, bot, tloc, bloc, ebwt);\n\treturn false;\n}", "idx": 431}
{"project": "bowtie2", "commit_id": "490_bowtie2_2.5.1_random_source.h_nextU2.cpp", "target": 0, "func": "uint32_t nextU2() {\n\t\tassert(inited_);\n\t\tif(lastOff > 30) {\n\t\t\tnextU32();\n\t\t}\n\t\tuint32_t ret = (last >> lastOff) & 3;\n\t\tlastOff += 2;\n\t\treturn ret;\n\t}", "idx": 432}
{"project": "bowtie2", "commit_id": "491_bowtie2_2.5.1_random_source.h_nextBool.cpp", "target": 0, "func": "bool nextBool() {\n\t\treturn (nextU32() & 1) == 0;\n\t}", "idx": 433}
{"project": "bowtie2", "commit_id": "492_bowtie2_2.5.1_random_source.h_nextFromProbs.cpp", "target": 0, "func": "uint32_t nextFromProbs(\n\t\tconst float* weights,\n\t\tsize_t numWeights)\n\t{\n\t\tfloat f = nextFloat();\n\t\tfloat tot = 0.0f; // total weight seen so far\n\t\tfor(uint32_t i = 0; i < numWeights; i++) {\n\t\t\ttot += weights[i];\n\t\t\tif(f < tot) return i;\n\t\t}\n\t\treturn (uint32_t)(numWeights-1);\n\t}", "idx": 434}
{"project": "bowtie2", "commit_id": "493_bowtie2_2.5.1_random_source.h_nextFloat.cpp", "target": 0, "func": "float nextFloat() {\n\t\tassert(inited_);\n\t\treturn (float)nextU32() / (float)0xffffffff;\n\t}", "idx": 435}
{"project": "bowtie2", "commit_id": "494_bowtie2_2.5.1_random_source.h_RandomSource.cpp", "target": 0, "func": "bit ints as seed\n\tRandomSource(const uint32_t* array, int size) {\n\t\tinit(array, size);\n\t}", "idx": 436}
{"project": "bowtie2", "commit_id": "495_bowtie2_2.5.1_random_source.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tstate_[0] = 0;\n\t\tp_ = 0;\n\t\tinited_ = false;\n\t}", "idx": 437}
{"project": "bowtie2", "commit_id": "496_bowtie2_2.5.1_random_source.h_twiddle.cpp", "target": 0, "func": "private functions used to generate the pseudo random numbers\n\tuint32_t twiddle(uint32_t u, uint32_t v) {\n\t\treturn (((u & 0x80000000UL) | (v & 0x7FFFFFFFUL)) >> 1) ^ ((v & 1UL) ? 0x9908B0DFUL : 0x0UL);\n\t}", "idx": 438}
{"project": "bowtie2", "commit_id": "497_bowtie2_2.5.1_random_util.h_init.cpp", "target": 0, "func": "void init(size_t n, bool withoutReplacement) {\n\t\tsz_ = n_ = n;\n\t\tconverted_ = false;\n\t\tswaplist_ = n < SWAPLIST_THRESH || withoutReplacement;\n\t\tcur_ = 0;\n\t\tlist_.clear();\n\t\tseen_.clear();\n\t\tthresh_ = std::max(CONVERSION_THRESH, (size_t)(CONVERSION_FRAC * n));\n\t}", "idx": 439}
{"project": "bowtie2", "commit_id": "498_bowtie2_2.5.1_random_util.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tsz_ = n_ = cur_ = 0; swaplist_ = converted_ = false;\n\t\tlist_.clear(); seen_.clear();\n\t\tthresh_ = 0;\n\t}", "idx": 440}
{"project": "bowtie2", "commit_id": "499_bowtie2_2.5.1_random_util.h_setDone.cpp", "target": 0, "func": "void setDone() { assert(inited()); cur_ = n_; }", "idx": 441}
{"project": "bowtie2", "commit_id": "49_bowtie2_2.5.1_aligner_seed.cpp_index.cpp", "target": 0, "func": "mirror index (BWT')\n\t{\n\t\toff = _off;\n\t\tltr = off > 0;\n\t\tt[0] = t[1] = t[2] = t[3] = b[0] = b[1] = b[2] = b[3] = 0;\n\t\toff = abs(off)-1;\n\t\tif(ltr) {\n\t\t\tebwt = ebwtBw_;\n\t\t\ttp[0] = tp[1] = tp[2] = tp[3] = bwt.topf;\n\t\t\tbp[0] = bp[1] = bp[2] = bp[3] = bwt.botf;\n\t\t\ttf = tp; tb = t;\n\t\t\tbf = bp; bb = b;\n\t\t\tntop = bwt.topb;\n\t\t} else {\n\t\t\tebwt = ebwtFw_;\n\t\t\ttp[0] = tp[1] = tp[2] = tp[3] = bwt.topb;\n\t\t\tbp[0] = bp[1] = bp[2] = bp[3] = bwt.botb;\n\t\t\ttf = t; tb = tp;\n\t\t\tbf = b; bb = bp;\n\t\t\tntop = bwt.topf;\n\t\t}\n\t\tassert(ebwt != NULL);\n\t}", "idx": 442}
{"project": "bowtie2", "commit_id": "4_bowtie2_2.5.1_aligner_bt.h_add.cpp", "target": 0, "func": "void add(size_t id) {\n\t\tassert(!bs_[id].isSolution(prob_));\n\t\tunsorted_.push_back(make_pair(bs_[id].score_st_, id));\n\t}", "idx": 443}
{"project": "bowtie2", "commit_id": "500_bowtie2_2.5.1_read.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tnExIters =\n\t\tnExDps   = nExDpSuccs   = nExDpFails   =\n\t\tnMateDps = nMateDpSuccs = nMateDpFails =\n\t\tnExUgs   = nExUgSuccs   = nExUgFails   =\n\t\tnMateUgs = nMateUgSuccs = nMateUgFails =\n\t\tnExEes   = nExEeSuccs   = nExEeFails   =\n\t\tnRedundants =\n\t\tnEeFmops = nSdFmops = nExFmops =\n\t\tnDpFail = nDpFailStreak = nDpLastSucc =\n\t\tnUgFail = nUgFailStreak = nUgLastSucc =\n\t\tnEeFail = nEeFailStreak = nEeLastSucc =\n\t\tnFilt = 0;\n\t\tnFtabs = 0;\n\t\tnRedSkip = 0;\n\t\tnRedFail = 0;\n\t\tnRedIns = 0;\n\t\tdoFmString = false;\n\t\tnSeedRanges = nSeedElts = 0;\n\t\tnSeedRangesFw = nSeedEltsFw = 0;\n\t\tnSeedRangesRc = nSeedEltsRc = 0;\n\t\tseedMedian = seedMean = 0;\n\t\tbestLtMinscMate1 =\n\t\tbestLtMinscMate2 = std::numeric_limits<TAlScore>::min();\n\t\tseedPctUnique = seedPctRep = seedsPerNuc = seedHitAvg = 0.0f;\n\t\tfmString.reset();\n\t}", "idx": 444}
{"project": "bowtie2", "commit_id": "501_bowtie2_2.5.1_read.h_finalize.cpp", "target": 0, "func": "void finalize() {\n\t\tfor(size_t i = 0; i < patFw.length(); i++) {\n\t\t\tif((int)patFw[i] > 3) {\n\t\t\t\tns_++;\n\t\t\t}\n\t\t}\n\t\tconstructRevComps();\n\t\tconstructReverses();\n\t}", "idx": 445}
{"project": "bowtie2", "commit_id": "502_bowtie2_2.5.1_read.h_init.cpp", "target": 0, "func": "void init(\n\t\tconst char *nm,\n\t\tconst char *seq,\n\t\tconst char *ql)\n\t{\n\t\treset();\n\t\tpatFw.installChars(seq);\n\t\tqual.install(ql);\n\t\tfor(size_t i = 0; i < patFw.length(); i++) {\n\t\t\tif((int)patFw[i] > 3) {\n\t\t\t\tns_++;\n\t\t\t}\n\t\t}\n\t\tconstructRevComps();\n\t\tconstructReverses();\n\t\tif(nm != NULL) name.install(nm);\n\t}", "idx": 446}
{"project": "bowtie2", "commit_id": "503_bowtie2_2.5.1_read.h_constructRevComps.cpp", "target": 0, "func": "void constructRevComps() {\n\t\tpatRc.installReverseComp(patFw);\n\t}", "idx": 447}
{"project": "bowtie2", "commit_id": "504_bowtie2_2.5.1_read.h_constructReverses.cpp", "target": 0, "func": "void constructReverses() {\n\t\tpatFwRev.installReverse(patFw);\n\t\tpatRcRev.installReverse(patRc);\n\t\tqualRev.installReverse(qual);\n\t}", "idx": 448}
{"project": "bowtie2", "commit_id": "505_bowtie2_2.5.1_read.h_fixMateName.cpp", "target": 0, "func": "void fixMateName(int i) {\n\t\tassert(i == 1 || i == 2);\n\t\tsize_t namelen = name.length();\n\t\tbool append = false;\n\t\tif(namelen < 2) {\n\t\t\t// Name is too short to possibly have /1 or /2 on the end\n\t\t\tappend = true;\n\t\t} else {\n\t\t\tif(i == 1) {\n\t\t\t\t// append = true iff mate name does not already end in /1\n\t\t\t\tappend =\n\t\t\t\t\tname[namelen-2] != '/' ||\n\t\t\t\t\tname[namelen-1] != '1';\n\t\t\t} else {\n\t\t\t\t// append = true iff mate name does not already end in /2\n\t\t\t\tappend =\n\t\t\t\t\tname[namelen-2] != '/' ||\n\t\t\t\t\tname[namelen-1] != '2';\n\t\t\t}\n\t\t}\n\t\tif(append) {\n\t\t\tname.append('/');\n\t\t\tname.append(\"012\"[i]);\n\t\t}\n\t}", "idx": 449}
{"project": "bowtie2", "commit_id": "506_bowtie2_2.5.1_read.h_same.cpp", "target": 0, "func": "static bool same(\n\t\tconst BTDnaString& seq1,\n\t\tconst BTString&    qual1,\n\t\tconst BTDnaString& seq2,\n\t\tconst BTString&    qual2,\n\t\tbool qualitiesMatter)\n\t{\n\t\tif(seq1.length() != seq2.length()) {\n\t\t\treturn false;\n\t\t}\n\t\tfor(size_t i = 0; i < seq1.length(); i++) {\n\t\t\tif(seq1[i] != seq2[i]) return false;\n\t\t}\n\t\tif(qualitiesMatter) {\n\t\t\tif(qual1.length() != qual2.length()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor(size_t i = 0; i < qual1.length(); i++) {\n\t\t\t\tif(qual1[i] != qual2[i]) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "idx": 450}
{"project": "bowtie2", "commit_id": "507_bowtie2_2.5.1_read.h_add.cpp", "target": 0, "func": "void add(bool alignment, TAlScore pen, size_t nops) {\n\t\tif(ops.empty() || ops.back().pen != pen) {\n\t\t\tops.expand();\n\t\t\tops.back().alignment = alignment;\n\t\t\tops.back().pen = pen;\n\t\t\tops.back().n = 0;\n\t\t}\n\t\tops.back().n++;\n\t}", "idx": 451}
{"project": "bowtie2", "commit_id": "508_bowtie2_2.5.1_ref_coord.h_init.cpp", "target": 0, "func": "void init(TRefId rf, TRefOff of, bool fw, TRefOff len) {\n\t\tupstream_.init(rf, of, fw);\n\t\tlen_ = len;\n\t}", "idx": 452}
{"project": "bowtie2", "commit_id": "509_bowtie2_2.5.1_ref_coord.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tupstream_.reset();\n\t\tlen_ = 0;\n\t}", "idx": 453}
{"project": "bowtie2", "commit_id": "50_bowtie2_2.5.1_aligner_seed.cpp_initLastTot.cpp", "target": 0, "func": "noop in production code\n\tvoid initLastTot(TIndexOffU tot) {}", "idx": 454}
{"project": "bowtie2", "commit_id": "510_bowtie2_2.5.1_ref_coord.h_setRef.cpp", "target": 0, "func": "inline void setRef(TRefId  id)  { ref_ = id;  }", "idx": 455}
{"project": "bowtie2", "commit_id": "511_bowtie2_2.5.1_ref_coord.h_setOff.cpp", "target": 0, "func": "void setOff(TRefOff of) {\n\t\tupstream_.setOff(of);\n\t}", "idx": 456}
{"project": "bowtie2", "commit_id": "512_bowtie2_2.5.1_ref_coord.h_adjustOff.cpp", "target": 0, "func": "endif\n\n\tinline void adjustOff(TRefOff off) { upstream_.adjustOff(off); }", "idx": 457}
{"project": "bowtie2", "commit_id": "513_bowtie2_2.5.1_ref_coord.h_Interval.cpp", "target": 0, "func": "explicit Interval(TRefId rf, TRefOff of, bool fw, TRefOff len) {\n\t\tinit(rf, of, fw, len);\n\t}", "idx": 458}
{"project": "bowtie2", "commit_id": "514_bowtie2_2.5.1_ref_coord.h_setLen.cpp", "target": 0, "func": "void setLen(TRefOff len) {\n\t\tlen_ = len;\n\t}", "idx": 459}
{"project": "bowtie2", "commit_id": "515_bowtie2_2.5.1_ref_coord.h_setUpstream.cpp", "target": 0, "func": "void setUpstream(const Coord& c) {\n\t\tupstream_ = c;\n\t}", "idx": 460}
{"project": "bowtie2", "commit_id": "516_bowtie2_2.5.1_ref_coord.h_setLength.cpp", "target": 0, "func": "void setLength(TRefOff l) {\n\t\tlen_ = l;\n\t}", "idx": 461}
{"project": "bowtie2", "commit_id": "517_bowtie2_2.5.1_ref_read.cpp_printRecords.cpp", "target": 0, "func": "static void\nprintRecords(ostream& os, const EList<RefRecord>& l) {\n\tfor(size_t i = 0; i < l.size(); i++) {\n\t\tos << l[i].first << \", \" << l[i].off << \", \" << l[i].len << endl;\n\t}\n}", "idx": 462}
{"project": "bowtie2", "commit_id": "518_bowtie2_2.5.1_ref_read.h_throw.cpp", "target": 0, "func": "const throw() {\n\t\treturn msg.c_str();\n\t}", "idx": 463}
{"project": "bowtie2", "commit_id": "519_bowtie2_2.5.1_ref_read.h_write.cpp", "target": 0, "func": "void write(std::ostream& out, bool be) {\n\t\twriteU<TIndexOffU>(out, off, be);\n\t\twriteU<TIndexOffU>(out, len, be);\n\t\tout.put(first ? 1 : 0);\n\t}", "idx": 464}
{"project": "bowtie2", "commit_id": "51_bowtie2_2.5.1_aligner_seed.cpp_assertLeqAndSetLastTot.cpp", "target": 0, "func": "void assertLeqAndSetLastTot(TIndexOffU tot) {}", "idx": 465}
{"project": "bowtie2", "commit_id": "520_bowtie2_2.5.1_sam.cpp_WRITE_SEP.cpp", "target": 0, "func": "define WRITE_SEP() { \\\n\tif(!first) o.append('\\t'); \\\n\tfirst = false; \\\n}", "idx": 466}
{"project": "bowtie2", "commit_id": "521_bowtie2_2.5.1_sam.h_readTagVal.cpp", "target": 0, "func": "static void readTagVal(BTString& o, const char *data, size_t &offset, size_t count) {\n\t\tstd::vector<T> val(count);\n\t\tsize_t i = 0;\n\n\t\tmemcpy(val.data(), data + offset, sizeof(T) * count);\n\t\tdo {\n\t\t\tstd::string str = std::to_string(val[i]);\n\t\t\to.append(str.c_str(), str.length());\n\t\t\tif (i < (count - 1))\n\t\t\t\to.append(\",\");\n\t\t} while (++i < count);\n\t\toffset += sizeof(T) * count;\n\t}", "idx": 467}
{"project": "bowtie2", "commit_id": "522_bowtie2_2.5.1_scoring.cpp_main.cpp", "target": 0, "func": "ifdef SCORING_MAIN\n\nint main() {\n\t{\n\t\tcout << \"Case 1: Simple 1 ... \";\n\t\tScoring sc = Scoring::base1();\n\t\tassert_eq(COST_MODEL_CONSTANT, sc.matchType);\n\t\t\n\t\tassert_eq(0, sc.maxRefGaps(0, 10));  // 10 - 1 - 15 = -6\n\t\tassert_eq(0, sc.maxRefGaps(0, 11));  // 11 - 1 - 15 = -5\n\t\tassert_eq(0, sc.maxRefGaps(0, 12));  // 12 - 1 - 15 = -4\n\t\tassert_eq(0, sc.maxRefGaps(0, 13));  // 13 - 1 - 15 = -3\n\t\tassert_eq(0, sc.maxRefGaps(0, 14));  // 14 - 1 - 15 = -2\n\t\tassert_eq(0, sc.maxRefGaps(0, 15));  // 15 - 1 - 15 = -1\n\t\tassert_eq(1, sc.maxRefGaps(0, 16));  // 16 - 1 - 15 =  0\n\t\tassert_eq(1, sc.maxRefGaps(0, 17));  // 17 - 2 - 19 = -4\n\t\tassert_eq(1, sc.maxRefGaps(0, 18));  // 18 - 2 - 19 = -3\n\t\tassert_eq(1, sc.maxRefGaps(0, 19));  // 19 - 2 - 19 = -2\n\t\tassert_eq(1, sc.maxRefGaps(0, 20));  // 20 - 2 - 19 = -1\n\t\tassert_eq(2, sc.maxRefGaps(0, 21));  // 21 - 2 - 19 =  0\n\t\t\n\t\tassert_eq(0, sc.maxReadGaps(0, 10));   // 10 - 0 - 15 = -5\n\t\tassert_eq(0, sc.maxReadGaps(0, 11));   // 11 - 0 - 15 = -4\n\t\tassert_eq(0, sc.maxReadGaps(0, 12));   // 12 - 0 - 15 = -3\n\t\tassert_eq(0, sc.maxReadGaps(0, 13));   // 13 - 0 - 15 = -2\n\t\tassert_eq(0, sc.maxReadGaps(0, 14));   // 14 - 0 - 15 = -1\n\t\tassert_eq(1, sc.maxReadGaps(0, 15));   // 15 - 0 - 15 =  0\n\t\tassert_eq(1, sc.maxReadGaps(0, 16));   // 16 - 0 - 19 = -3\n\t\tassert_eq(1, sc.maxReadGaps(0, 17));   // 17 - 0 - 19 = -2\n\t\tassert_eq(1, sc.maxReadGaps(0, 18));   // 18 - 0 - 19 = -1\n\t\tassert_eq(2, sc.maxReadGaps(0, 19));   // 19 - 0 - 19 =  0\n\t\tassert_eq(2, sc.maxReadGaps(0, 20));   // 20 - 0 - 23 = -3\n\t\tassert_eq(2, sc.maxReadGaps(0, 21));   // 21 - 0 - 23 = -2\n\t\t\n\t\t// N ceiling: const=2, linear=0.1\n\t\tassert_eq(1, sc.nCeil(1));\n\t\tassert_eq(2, sc.nCeil(3));\n\t\tassert_eq(2, sc.nCeil(5));\n\t\tassert_eq(2, sc.nCeil(7));\n\t\tassert_eq(2, sc.nCeil(9));\n\t\tassert_eq(3, sc.nCeil(10));\n\t\tfor(int i = 0; i < 30; i++) {\n\t\t\tassert_eq(3, sc.n(i));\n\t\t\tassert_eq(3, sc.mm(i));\n\t\t}\n\t\tassert_eq(5, sc.gapbar);\n\t\tcout << \"PASSED\" << endl;\n\t}\n\t{\n\t\tcout << \"Case 2: Simple 2 ... \";\n\t\tScoring sc(\n\t\t\t4,               // reward for a match\n\t\t\tCOST_MODEL_QUAL, // how to penalize mismatches\n\t\t\t0,               // constant if mm pelanty is a constant\n\t\t\t-3.0f,           // constant coeff for minimum score\n\t\t\t-3.0f,           // linear coeff for minimum score\n\t\t\tDEFAULT_FLOOR_CONST,  // constant coeff for score floor\n\t\t\tDEFAULT_FLOOR_LINEAR, // linear coeff for score floor\n\t\t\t3.0f,            // max # ref Ns allowed in alignment; const coeff\n\t\t\t0.4f,            // max # ref Ns allowed in alignment; linear coeff\n\t\t\tCOST_MODEL_QUAL, // how to penalize Ns in the read\n\t\t\t0,               // constant if N pelanty is a constant\n\t\t\ttrue,            // whether to concatenate mates before N filtering\n\t\t\t25,              // constant coeff for cost of gap in the read\n\t\t\t25,              // constant coeff for cost of gap in the ref\n\t\t\t10,              // coeff of linear term for cost of gap in read\n\t\t\t10,              // coeff of linear term for cost of gap in ref\n\t\t\t5,               // 5 rows @ top/bot diagonal-entrance-only\n\t\t\t-1,              // no restriction on row\n\t\t\tfalse            // score prioritized over row\n\t\t);\n\n\t\tassert_eq(COST_MODEL_CONSTANT, sc.matchType);\n\t\tassert_eq(4, sc.matchConst);\n\t\tassert_eq(COST_MODEL_QUAL, sc.mmcostType);\n\t\tassert_eq(COST_MODEL_QUAL, sc.npenType);\n\t\t\n\t\tassert_eq(0, sc.maxRefGaps(0, 8));  // 32 - 4 - 35 = -7\n\t\tassert_eq(0, sc.maxRefGaps(0, 9));  // 36 - 4 - 35 = -3\n\t\tassert_eq(1, sc.maxRefGaps(0, 10)); // 40 - 4 - 35 =  1\n\t\tassert_eq(1, sc.maxRefGaps(0, 11)); // 44 - 8 - 45 = -9\n\t\tassert_eq(1, sc.maxRefGaps(0, 12)); // 48 - 8 - 45 = -5\n\t\tassert_eq(1, sc.maxRefGaps(0, 13)); // 52 - 8 - 45 = -1\n\t\tassert_eq(2, sc.maxRefGaps(0, 14)); // 56 - 8 - 45 =  3\n\t\t\n\t\tassert_eq(0, sc.maxReadGaps(0, 8));   // 32 - 0 - 35 = -3\n\t\tassert_eq(1, sc.maxReadGaps(0, 9));   // 36 - 0 - 35 =  1\n\t\tassert_eq(1, sc.maxReadGaps(0, 10));  // 40 - 0 - 45 = -5\n\t\tassert_eq(1, sc.maxReadGaps(0, 11));  // 44 - 0 - 45 = -1\n\t\tassert_eq(2, sc.maxReadGaps(0, 12));  // 48 - 0 - 45 =  3\n\t\tassert_eq(2, sc.maxReadGaps(0, 13));  // 52 - 0 - 55 = -3\n\t\tassert_eq(3, sc.maxReadGaps(0, 14));  // 56 - 0 - 55 =  1\n\n\t\t// N ceiling: const=3, linear=0.4\n\t\tassert_eq(1, sc.nCeil(1));\n\t\tassert_eq(2, sc.nCeil(2));\n\t\tassert_eq(3, sc.nCeil(3));\n\t\tassert_eq(4, sc.nCeil(4));\n\t\tassert_eq(5, sc.nCeil(5));\n\t\tassert_eq(5, sc.nCeil(6));\n\t\tassert_eq(5, sc.nCeil(7));\n\t\tassert_eq(6, sc.nCeil(8));\n\t\tassert_eq(6, sc.nCeil(9));\n\n\t\tfor(int i = 0; i < 256; i++) {\n\t\t\tassert_eq(i, sc.n(i));\n\t\t\tassert_eq(i, sc.mm(i));\n\t\t}\n\n\t\tassert_eq(5, sc.gapbar);\n\n\t\tcout << \"PASSED\" << endl;\n\t}\n}", "idx": 468}
{"project": "bowtie2", "commit_id": "523_bowtie2_2.5.1_scoring.h_setMatchBonus.cpp", "target": 0, "func": "void setMatchBonus(int bonus) {\n\t\tmatchType  = COST_MODEL_CONSTANT;\n\t\tmatchConst = bonus;\n\t\tinitPens<float>(matchBonuses, matchType, matchConst, matchConst);\n\t\tassert(repOk());\n\t}", "idx": 469}
{"project": "bowtie2", "commit_id": "524_bowtie2_2.5.1_scoring.h_setMmPen.cpp", "target": 0, "func": "void setMmPen(int mmType_, int mmpMax_, int mmpMin_) {\n\t\tmmcostType = mmType_;\n\t\tmmpMax     = mmpMax_;\n\t\tmmpMin     = mmpMin_;\n\t\tinitPens<int>(mmpens, mmcostType, mmpMin, mmpMax);\n\t}", "idx": 470}
{"project": "bowtie2", "commit_id": "525_bowtie2_2.5.1_scoring.h_setNPen.cpp", "target": 0, "func": "void setNPen(int nType, int n) {\n\t\tnpenType     = nType;\n\t\tnpen         = n;\n\t\tinitPens<int>(npens, npenType, npen, npen);\n\t}", "idx": 471}
{"project": "bowtie2", "commit_id": "526_bowtie2_2.5.1_scoring.h_linearFunc.cpp", "target": 0, "func": "static float linearFunc(int64_t x, float cnst, float lin) {\n\t\treturn (float)((double)cnst + ((double)lin * x));\n\t}", "idx": 472}
{"project": "bowtie2", "commit_id": "527_bowtie2_2.5.1_scoring.h_base1.cpp", "target": 0, "func": "map from N qualities to penalty\n\n\tstatic Scoring base1() {\n\t\tconst double DMAX = std::numeric_limits<double>::max();\n\t\tSimpleFunc scoreMin(SIMPLE_FUNC_LINEAR, 0.0f, DMAX, 37.0f, 0.3f);\n\t\tSimpleFunc nCeil(SIMPLE_FUNC_LINEAR, 0.0f, DMAX, 2.0f, 0.1f);\n\t\treturn Scoring(\n\t\t\t1,                       // reward for a match\n\t\t\tCOST_MODEL_CONSTANT,     // how to penalize mismatches\n\t\t\t3,                       // max mismatch pelanty\n\t\t\t3,                       // min mismatch pelanty\n\t\t\tscoreMin,                // score min: 37 + 0.3x\n\t\t\tnCeil,                   // n ceiling: 2 + 0.1x\n\t\t\tCOST_MODEL_CONSTANT,     // how to penalize Ns in the read\n\t\t\t3,                       // constant if N pelanty is a constant\n\t\t\tfalse,                   // concatenate mates before N filtering?\n\t\t\t11,                      // constant coeff for gap in read\n\t\t\t11,                      // constant coeff for gap in ref\n\t\t\t4,                       // linear coeff for gap in read\n\t\t\t4,                       // linear coeff for gap in ref\n\t\t\t5);                      // 5 rows @ top/bot diagonal-entrance-only\n\t}", "idx": 473}
{"project": "bowtie2", "commit_id": "528_bowtie2_2.5.1_shmem.cpp_notifySharedMem.cpp", "target": 0, "func": "void notifySharedMem(void *mem, size_t len) {\n\t((volatile uint32_t*)((char*)mem + len))[0] = SHMEM_INIT;\n}", "idx": 474}
{"project": "bowtie2", "commit_id": "529_bowtie2_2.5.1_shmem.cpp_waitSharedMem.cpp", "target": 0, "func": "void waitSharedMem(void *mem, size_t len) {\n\twhile(((volatile uint32_t*)((char*)mem + len))[0] != SHMEM_INIT) {\n\t\tsleep(1);\n\t}\n}", "idx": 475}
{"project": "bowtie2", "commit_id": "52_bowtie2_2.5.1_aligner_seed.cpp_parseInt.cpp", "target": 0, "func": "static int parseInt(const char *errmsg, const char *arg) {\n\tlong l;\n\tchar *endPtr = NULL;\n\tl = strtol(arg, &endPtr, 10);\n\tif (endPtr != NULL) {\n\t\treturn (int32_t)l;\n\t}\n\tcerr << errmsg << endl;\n\tthrow 1;\n\treturn -1;\n}", "idx": 476}
{"project": "bowtie2", "commit_id": "530_bowtie2_2.5.1_simple_func.h_init.cpp", "target": 0, "func": "void init(int type, double C, double L) {\n\t\ttype_ = type; C_ = C; L_ = L;\n\t\tI_ = -std::numeric_limits<double>::max();\n\t\tX_ = std::numeric_limits<double>::max();\n\t}", "idx": 477}
{"project": "bowtie2", "commit_id": "531_bowtie2_2.5.1_simple_func.h_setType.cpp", "target": 0, "func": "void setType (int type ) { type_ = type; }", "idx": 478}
{"project": "bowtie2", "commit_id": "532_bowtie2_2.5.1_simple_func.h_setMin.cpp", "target": 0, "func": "void setMin  (double mn) { I_ = mn; }", "idx": 479}
{"project": "bowtie2", "commit_id": "533_bowtie2_2.5.1_simple_func.h_setMax.cpp", "target": 0, "func": "void setMax  (double mx) { X_ = mx; }", "idx": 480}
{"project": "bowtie2", "commit_id": "534_bowtie2_2.5.1_simple_func.h_setConst.cpp", "target": 0, "func": "void setConst(double co) { C_ = co; }", "idx": 481}
{"project": "bowtie2", "commit_id": "535_bowtie2_2.5.1_simple_func.h_setCoeff.cpp", "target": 0, "func": "void setCoeff(double ce) { L_ = ce; }", "idx": 482}
{"project": "bowtie2", "commit_id": "536_bowtie2_2.5.1_simple_func.h_mult.cpp", "target": 0, "func": "void mult(double x) {\n\t\tif(I_ < std::numeric_limits<double>::max()) {\n\t\t\tI_ *= x; X_ *= x; C_ *= x; L_ *= x;\n\t\t}\n\t}", "idx": 483}
{"project": "bowtie2", "commit_id": "537_bowtie2_2.5.1_simple_func.h_reset.cpp", "target": 0, "func": "void reset() { type_ = 0; }", "idx": 484}
{"project": "bowtie2", "commit_id": "538_bowtie2_2.5.1_sse_util.h_ensure.cpp", "target": 0, "func": "inline void ensure(size_t thresh) {\n\t\tif(list_ == NULL) lazyInit();\n\t\texpandCopy(cur_ + thresh);\n\t}", "idx": 485}
{"project": "bowtie2", "commit_id": "539_bowtie2_2.5.1_sse_util.h_reserveExact.cpp", "target": 0, "func": "inline void reserveExact(size_t newsz) {\n\t\tif(list_ == NULL) lazyInitExact(newsz);\n\t\texpandCopyExact(newsz);\n\t}", "idx": 486}
{"project": "bowtie2", "commit_id": "53_bowtie2_2.5.1_aligner_seed.cpp_printUsage.cpp", "target": 0, "func": "static void printUsage(ostream& os) {\n\tos << \"Usage: ac [options]* <index> <patterns>\" << endl;\n\tos << \"Options:\" << endl;\n\tos << \"  --mm                memory-mapped mode\" << endl;\n\tos << \"  --shmem             shared memory mode\" << endl;\n\tos << \"  --nofw              don't align forward-oriented read\" << endl;\n\tos << \"  --norc              don't align reverse-complemented read\" << endl;\n\tos << \"  -t/--timing         show timing information\" << endl;\n\tos << \"  -v/--verbose        talkative mode\" << endl;\n}", "idx": 487}
{"project": "bowtie2", "commit_id": "540_bowtie2_2.5.1_sse_util.h_resize.cpp", "target": 0, "func": "void resize(size_t sz) {\n\t\tif(sz > 0 && list_ == NULL) lazyInit();\n\t\tif(sz <= cur_) {\n\t\t\tcur_ = sz;\n\t\t\treturn;\n\t\t}\n\t\tif(sz_ < sz) {\n\t\t\texpandCopy(sz);\n\t\t}\n\t\tcur_ = sz;\n\t}", "idx": 488}
{"project": "bowtie2", "commit_id": "541_bowtie2_2.5.1_sse_util.h_zero.cpp", "target": 0, "func": "void zero() {\n\t\tif(cur_ > 0) {\n\t\t\tmemset(list_, 0, cur_ * sizeof(SSERegI));\n\t\t}\n\t}", "idx": 489}
{"project": "bowtie2", "commit_id": "542_bowtie2_2.5.1_sse_util.h_resizeNoCopy.cpp", "target": 0, "func": "void resizeNoCopy(size_t sz) {\n\t\tif(sz > 0 && list_ == NULL) lazyInit();\n\t\tif(sz <= cur_) {\n\t\t\tcur_ = sz;\n\t\t\treturn;\n\t\t}\n\t\tif(sz_ < sz) {\n\t\t\texpandNoCopy(sz);\n\t\t}\n\t\tcur_ = sz;\n\t}", "idx": 490}
{"project": "bowtie2", "commit_id": "543_bowtie2_2.5.1_sse_util.h_resizeExact.cpp", "target": 0, "func": "void resizeExact(size_t sz) {\n\t\tif(sz > 0 && list_ == NULL) lazyInitExact(sz);\n\t\tif(sz <= cur_) {\n\t\t\tcur_ = sz;\n\t\t\treturn;\n\t\t}\n\t\tif(sz_ < sz) expandCopyExact(sz);\n\t\tcur_ = sz;\n\t}", "idx": 491}
{"project": "bowtie2", "commit_id": "544_bowtie2_2.5.1_sse_util.h_clear.cpp", "target": 0, "func": "void clear() {\n\t\tcur_ = 0; // re-use stack memory\n\t\t// Don't clear heap; re-use it\n\t}", "idx": 492}
{"project": "bowtie2", "commit_id": "545_bowtie2_2.5.1_sse_util.h_ptr.cpp", "target": 0, "func": "SSERegI *ptr() { return list_; }", "idx": 493}
{"project": "bowtie2", "commit_id": "546_bowtie2_2.5.1_sse_util.h_lazyInit.cpp", "target": 0, "func": "void lazyInit() {\n\t\tassert(list_ == NULL);\n\t\tlist_ = alloc(sz_);\n\t}", "idx": 494}
{"project": "bowtie2", "commit_id": "547_bowtie2_2.5.1_sse_util.h_lazyInitExact.cpp", "target": 0, "func": "void lazyInitExact(size_t sz) {\n\t\tassert_gt(sz, 0);\n\t\tassert(list_ == NULL);\n\t\tsz_ = sz;\n\t\tlist_ = alloc(sz);\n\t}", "idx": 495}
{"project": "bowtie2", "commit_id": "548_bowtie2_2.5.1_sse_util.h_alloc.cpp", "target": 0, "func": "SSERegI *alloc(size_t sz) {\n\t\tSSERegI* last_alloc_;\n\t\ttry {\n\t\t\tlast_alloc_ = new SSERegI[sz + 2];\n\t\t} catch(std::bad_alloc& e) {\n\t\t\tstd::cerr << \"Error: Out of memory allocating \" << sz << \" SSERegI's for DP matrix: '\" << e.what() << \"'\" << std::endl;\n\t\t\tthrow e;\n\t\t}\n                this->last_alloc_ = last_alloc_;\n\t\tSSERegI* tmp = last_alloc_;\n\t\tsize_t tmpint = (size_t)tmp;\n\t\t// Align it!\n\t\tconst size_t alignmask = NBYTES_PER_REG-1;\n\t\tif((tmpint & alignmask) != 0) {\n\t\t\ttmpint += alignmask;\n\t\t\ttmpint &= (~alignmask);\n\t\t\ttmp = reinterpret_cast<SSERegI*>(tmpint);\n\t\t}\n\t\tassert_eq(0, (tmpint & alignmask)); // should be NBYTES_PER_REG-byte aligned\n\t\tassert(tmp != NULL);\n#ifdef USE_MEM_TALLY\n\t\tgMemTally.add(cat_, sz);\n#endif\n\t\treturn tmp;\n\t}", "idx": 496}
{"project": "bowtie2", "commit_id": "549_bowtie2_2.5.1_sse_util.h_free.cpp", "target": 0, "func": "void free() {\n\t\tif(list_ != NULL) {\n\t\t\tdelete[] last_alloc_;\n#ifdef USE_MEM_TALLY\n\t\t\tgMemTally.del(cat_, sz_);\n#endif\n\t\t\tlist_ = NULL;\n\t\t\tsz_ = cur_ = 0;\n\t\t}\n\t}", "idx": 497}
{"project": "bowtie2", "commit_id": "54_bowtie2_2.5.1_aligner_seed.h_init.cpp", "target": 0, "func": "void init(\n\t\tTIndexOffU top_,\n\t\tTIndexOffU bot_,\n\t\tconst Edit* e1_,\n\t\tconst Edit* e2_,\n\t\tbool fw_,\n\t\tint64_t score_)\n\t{\n\t\ttop = top_; bot = bot_;\n\t\tif(e1_ != NULL) {\n\t\t\te1 = *e1_;\n\t\t} else {\n\t\t\te1.reset();\n\t\t}\n\t\tif(e2_ != NULL) {\n\t\t\te2 = *e2_;\n\t\t} else {\n\t\t\te2.reset();\n\t\t}\n\t\tfw = fw_;\n\t\tscore = score_;\n\t}", "idx": 498}
{"project": "bowtie2", "commit_id": "550_bowtie2_2.5.1_sse_util.h_expandCopy.cpp", "target": 0, "func": "void expandCopy(size_t thresh) {\n\t\tif(thresh <= sz_) return;\n\t\tsize_t newsz = (sz_ * 2)+1;\n\t\twhile(newsz < thresh) newsz *= 2;\n\t\texpandCopyExact(newsz);\n\t}", "idx": 499}
{"project": "bowtie2", "commit_id": "551_bowtie2_2.5.1_sse_util.h_expandCopyExact.cpp", "target": 0, "func": "void expandCopyExact(size_t newsz) {\n\t\tif(newsz <= sz_) return;\n                SSERegI* prev_last_alloc = last_alloc_;\n\t\tSSERegI* tmp = alloc(newsz);\n\t\tassert(tmp != NULL);\n\t\tsize_t cur = cur_;\n\t\tif(list_ != NULL) {\n \t\t\tfor(size_t i = 0; i < cur_; i++) {\n\t\t\t\t// Note: operator= is used\n\t\t\t\ttmp[i] = list_[i];\n\t\t\t}\n                        SSERegI* current_last_alloc = last_alloc_;\n                        last_alloc_ = prev_last_alloc;\n\t\t\tfree();\n                        last_alloc_ = current_last_alloc;\n\t\t}\n\t\tlist_ = tmp;\n\t\tsz_ = newsz;\n\t\tcur_ = cur;\n\t}", "idx": 500}
{"project": "bowtie2", "commit_id": "552_bowtie2_2.5.1_sse_util.h_expandNoCopy.cpp", "target": 0, "func": "void expandNoCopy(size_t thresh) {\n\t\tassert(list_ != NULL);\n\t\tif(thresh <= sz_) return;\n\t\tsize_t newsz = (sz_ * 2)+1;\n\t\twhile(newsz < thresh) newsz *= 2;\n\t\texpandNoCopyExact(newsz);\n\t}", "idx": 501}
{"project": "bowtie2", "commit_id": "553_bowtie2_2.5.1_sse_util.h_expandNoCopyExact.cpp", "target": 0, "func": "void expandNoCopyExact(size_t newsz) {\n\t\tassert(list_ != NULL);\n\t\tassert_gt(newsz, 0);\n\t\tfree();\n\t\tSSERegI* tmp = alloc(newsz);\n\t\tassert(tmp != NULL);\n\t\tlist_ = tmp;\n\t\tsz_ = newsz;\n\t\tassert_gt(sz_, 0);\n\t}", "idx": 502}
{"project": "bowtie2", "commit_id": "554_bowtie2_2.5.1_sse_util.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tperpow2_ = per_ = lomask_ = nrow_ = ncol_ = 0;\n\t\tlocal_ = false;\n\t\tniter_ = ndiag_ = locol_ = hicol_ = 0;\n\t\tperf_ = 0;\n\t\tfirstCommit_ = true;\n\t\tis8_ = debug_ = false;\n\t}", "idx": 503}
{"project": "bowtie2", "commit_id": "555_bowtie2_2.5.1_sse_wrap.h_sse_max_score_i16.cpp", "target": 0, "func": "define sse_max_score_i16(inval, outval) { \\\n\t\tSSERegI vlmax = inval; \\\n\t\tSSERegI vltmp = sse_srli_siall(vlmax, 8); \\\n\t\tvlmax = sse_max_epi16(vlmax, vltmp); \\\n\t\tvltmp = sse_srli_siall(vlmax, 4); \\\n\t\tvlmax = sse_max_epi16(vlmax, vltmp); \\\n\t\tvltmp = sse_srli_siall(vlmax, 2); \\\n\t\tvlmax = sse_max_epi16(vlmax, vltmp); \\\n\t\toutval = sse_extract_epi16(vlmax, 0); \\\n}", "idx": 504}
{"project": "bowtie2", "commit_id": "556_bowtie2_2.5.1_sse_wrap.h_sse_max_score_u8.cpp", "target": 0, "func": "define sse_max_score_u8(inval, outval) { \\\n\t\tSSERegI vlmax = inval; \\\n\t\tSSERegI vltmp = sse_srli_siall(vlmax, 8); \\\n\t\tvlmax = sse_max_epu8(vlmax, vltmp); \\\n\t\tvltmp = sse_srli_siall(vlmax, 4); \\\n\t\tvlmax = sse_max_epu8(vlmax, vltmp); \\\n\t\tvltmp = sse_srli_siall(vlmax, 2); \\\n\t\tvlmax = sse_max_epu8(vlmax, vltmp); \\\n\t\tvltmp = sse_srli_siall(vlmax, 1); \\\n\t\tvlmax = sse_max_epu8(vlmax, vltmp); \\\n\t\toutval = sse_extract_epi16(vlmax, 0); \\\n\t\toutval = outval & 0x00ff; \\\n}", "idx": 505}
{"project": "bowtie2", "commit_id": "557_bowtie2_2.5.1_sse_wrap.h_sse_fill_i16_opt.cpp", "target": 0, "func": "define sse_fill_i16_opt(inval, outval) { \\\n\tif (inval==0xffff) outval = sse_cmpeq_epi16(outval, outval); \\\n\telse if (inval==0) outval = sse_xor_siall(outval, outval); \\\n\telse sse_fill_i16(inval, outval); \\\n}", "idx": 506}
{"project": "bowtie2", "commit_id": "558_bowtie2_2.5.1_sse_wrap.h_sse_fill_u8.cpp", "target": 0, "func": "define sse_fill_u8(inval, outval) {\\\n\tint invalloc = inval; \\\n\tint dup = (invalloc << 8) | (invalloc & 0x00ff); \\\n\tsse_fill_i16(dup, outval); \\\n}", "idx": 507}
{"project": "bowtie2", "commit_id": "559_bowtie2_2.5.1_sse_wrap.h_sse_fill_u8_opt.cpp", "target": 0, "func": "define sse_fill_u8_opt(inval, outval) {\\\n\tif (inval==0xff) outval = sse_cmpeq_epi16(outval, outval); \\\n\telse if (inval==0) outval = sse_xor_siall(outval, outval); \\\n\telse sse_fill_u8(inval, outval); \\\n}", "idx": 508}
{"project": "bowtie2", "commit_id": "55_bowtie2_2.5.1_aligner_seed.h_chargeMismatch.cpp", "target": 0, "func": "void chargeMismatch(int q, const Scoring& cm) {\n\t\tassert(instantiated);\n\t\tif(mms == 0) { assert_gt(edits, 0); edits--; }\n\t\telse mms--;\n\t\tpenalty -= cm.mm(q);\n\t\tassert_geq(mms, 0);\n\t\tassert_geq(edits, 0);\n\t\tassert_geq(penalty, 0);\n\t}", "idx": 509}
{"project": "bowtie2", "commit_id": "560_bowtie2_2.5.1_sse_wrap.h_sse_set_low_i16.cpp", "target": 0, "func": "define sse_set_low_i16(inval, outval) { \\\n\toutval = sse_setzero_siall(); \\\n\toutval = sse_insert_epi16(outval, inval, 0); \\\n}", "idx": 510}
{"project": "bowtie2", "commit_id": "561_bowtie2_2.5.1_sse_wrap.h_sse_set_low_u8.cpp", "target": 0, "func": "define sse_set_low_u8(inval, outval) { \\\n\toutval = sse_setzero_siall(); \\\n\toutval = sse_insert_epi16(outval, inval, 0); \\\n}", "idx": 511}
{"project": "bowtie2", "commit_id": "562_bowtie2_2.5.1_sstring.h_sstr_len.cpp", "target": 0, "func": "static inline size_t sstr_len(const unsigned char *s) {\n\t\treturn strlen((const char *)s);\n\t}", "idx": 512}
{"project": "bowtie2", "commit_id": "563_bowtie2_2.5.1_sstring.h_sstr_eq.cpp", "target": 0, "func": "static inline bool sstr_eq(const T1& s1, const T2& s2) {\n\tsize_t len1 = Class_sstr_len<T1>::sstr_len(s1);\n\tsize_t len2 = Class_sstr_len<T2>::sstr_len(s2);\n\tif(len1 != len2) return false;\n\tfor(size_t i = 0; i < len1; i++) {\n\t\tif(s1[i] != s2[i]) return false;\n\t}\n\treturn true;\n}", "idx": 513}
{"project": "bowtie2", "commit_id": "564_bowtie2_2.5.1_sstring.h_sstr_neq.cpp", "target": 0, "func": "static inline bool sstr_neq(const T1& s1, const T2& s2) {\n\treturn !sstr_eq(s1, s2);\n}", "idx": 514}
{"project": "bowtie2", "commit_id": "565_bowtie2_2.5.1_sstring.h_sstr_suf_upto_eq.cpp", "target": 0, "func": "static inline bool sstr_suf_upto_eq(\n\tconst T1& s1, size_t suf1,\n\tconst T2& s2, size_t suf2,\n\tsize_t upto,\n\tbool endlt = true)\n{\n\tassert_leq(suf1, Class_sstr_len<T1>::sstr_len(s1));\n\tassert_leq(suf2, Class_sstr_len<T2>::sstr_len(s2));\n\tsize_t len1 = Class_sstr_len<T1>::sstr_len(s1) - suf1;\n\tsize_t len2 = Class_sstr_len<T2>::sstr_len(s2) - suf2;\n\tif(len1 > upto) len1 = upto;\n\tif(len2 > upto) len2 = upto;\n\tif(len1 != len2) return false;\n\tfor(size_t i = 0; i < len1; i++) {\n\t\tif(s1[suf1+i] != s2[suf2+i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "idx": 515}
{"project": "bowtie2", "commit_id": "566_bowtie2_2.5.1_sstring.h_sstr_suf_upto_neq.cpp", "target": 0, "func": "static inline bool sstr_suf_upto_neq(\n\tconst T1& s1, size_t suf1,\n\tconst T2& s2, size_t suf2,\n\tsize_t upto,\n\tbool endlt = true)\n{\n\treturn !sstr_suf_upto_eq(s1, suf1, s2, suf2, upto, endlt);\n}", "idx": 516}
{"project": "bowtie2", "commit_id": "567_bowtie2_2.5.1_sstring.h_sstr_lt.cpp", "target": 0, "func": "static inline bool sstr_lt(const T1& s1, const T2& s2, bool endlt = true) {\n\tsize_t len1 = Class_sstr_len<T1>::sstr_len(s1);\n\tsize_t len2 = Class_sstr_len<T2>::sstr_len(s2);\n\tsize_t minlen = (len1 < len2 ? len1 : len2);\n\tfor(size_t i = 0; i < minlen; i++) {\n\t\tif(s1[i] < s2[i]) {\n\t\t\treturn true;\n\t\t} else if(s1[i] > s2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(len1 == len2) return false;\n\treturn (len1 < len2) == endlt;\n}", "idx": 517}
{"project": "bowtie2", "commit_id": "568_bowtie2_2.5.1_sstring.h_sstr_suf_lt.cpp", "target": 0, "func": "static inline bool sstr_suf_lt(\n\tconst T1& s1, size_t suf1, size_t len1,\n\tconst T2& s2, size_t suf2, size_t len2,\n\tbool endlt = true)\n{\n\tassert_leq(suf1, len1);\n\tassert_leq(suf2, len2);\n\tsize_t left1 = len1 - suf1;\n\tsize_t left2 = len2 - suf2;\n\tsize_t minleft = (left1 < left2 ? left1 : left2);\n\tfor(size_t i = 0; i < minleft; i++) {\n\t\tif(s1[suf1+i] < s2[suf2+i]) {\n\t\t\treturn true;\n\t\t} else if(s1[suf1+i] > s2[suf2+i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(left1 == left2) return false;\n\treturn (left1 < left2) == endlt;\n}", "idx": 518}
{"project": "bowtie2", "commit_id": "569_bowtie2_2.5.1_sstring.h_sstr_suf_upto_lt.cpp", "target": 0, "func": "static inline bool sstr_suf_upto_lt(\n\tconst T1& s1, size_t suf1,\n\tconst T2& s2, size_t suf2,\n\tsize_t upto,\n\tbool endlt = true)\n{\n\tassert_leq(suf1, Class_sstr_len<T1>::sstr_len(s1));\n\tassert_leq(suf2, Class_sstr_len<T2>::sstr_len(s2));\n\tsize_t len1 = Class_sstr_len<T1>::sstr_len(s1) - suf1;\n\tsize_t len2 = Class_sstr_len<T2>::sstr_len(s2) - suf2;\n\tif(len1 > upto) len1 = upto;\n\tif(len2 > upto) len2 = upto;\n\tsize_t minlen = (len1 < len2 ? len1 : len2);\n\tfor(size_t i = 0; i < minlen; i++) {\n\t\tif(s1[suf1+i] < s2[suf2+i]) {\n\t\t\treturn true;\n\t\t} else if(s1[suf1+i] > s2[suf2+i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(len1 == len2) return false;\n\treturn (len1 < len2) == endlt;\n}", "idx": 519}
{"project": "bowtie2", "commit_id": "56_bowtie2_2.5.1_aligner_seed.h_chargeN.cpp", "target": 0, "func": "void chargeN(int q, const Scoring& cm) {\n\t\tassert(instantiated);\n\t\tif(mms == 0) { assert_gt(edits, 0); edits--; }\n\t\telse mms--;\n\t\tpenalty -= cm.n(q);\n\t\tassert_geq(mms, 0);\n\t\tassert_geq(edits, 0);\n\t\tassert_geq(penalty, 0);\n\t}", "idx": 520}
{"project": "bowtie2", "commit_id": "570_bowtie2_2.5.1_sstring.h_sstr_pre_lt.cpp", "target": 0, "func": "static inline bool sstr_pre_lt(\n\tconst T1& s1, size_t pre1,\n\tconst T2& s2, size_t pre2,\n\tbool endlt = true)\n{\n\tassert_leq(pre1, Class_sstr_len<T1>::sstr_len(s1));\n\tassert_leq(pre2, Class_sstr_len<T2>::sstr_len(s2));\n\tsize_t len1 = pre1;\n\tsize_t len2 = pre2;\n\tsize_t minlen = (len1 < len2 ? len1 : len2);\n\tfor(size_t i = 0; i < minlen; i++) {\n\t\tif(s1[i] < s2[i]) {\n\t\t\treturn true;\n\t\t} else if(s1[i] > s2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(len1 == len2) return false;\n\treturn (len1 < len2) == endlt;\n}", "idx": 521}
{"project": "bowtie2", "commit_id": "571_bowtie2_2.5.1_sstring.h_sstr_leq.cpp", "target": 0, "func": "static inline bool sstr_leq(const T1& s1, const T2& s2, bool endlt = true) {\n\tsize_t len1 = Class_sstr_len<T1>::sstr_len(s1);\n\tsize_t len2 = Class_sstr_len<T2>::sstr_len(s2);\n\tsize_t minlen = (len1 < len2 ? len1 : len2);\n\tfor(size_t i = 0; i < minlen; i++) {\n\t\tif(s1[i] < s2[i]) {\n\t\t\treturn true;\n\t\t} else if(s1[i] > s2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(len1 == len2) return true;\n\treturn (len1 < len2) == endlt;\n}", "idx": 522}
{"project": "bowtie2", "commit_id": "572_bowtie2_2.5.1_sstring.h_sstr_suf_leq.cpp", "target": 0, "func": "static inline bool sstr_suf_leq(\n\tconst T1& s1, size_t suf1,\n\tconst T2& s2, size_t suf2,\n\tbool endlt = true)\n{\n\tassert_leq(suf1, Class_sstr_len<T1>::sstr_len(s1));\n\tassert_leq(suf2, Class_sstr_len<T2>::sstr_len(s2));\n\tsize_t len1 = Class_sstr_len<T1>::sstr_len(s1) - suf1;\n\tsize_t len2 = Class_sstr_len<T2>::sstr_len(s2) - suf2;\n\tsize_t minlen = (len1 < len2 ? len1 : len2);\n\tfor(size_t i = 0; i < minlen; i++) {\n\t\tif(s1[suf1+i] < s2[suf2+i]) {\n\t\t\treturn true;\n\t\t} else if(s1[suf1+i] > s2[suf2+i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(len1 == len2) return true;\n\treturn (len1 < len2) == endlt;\n}", "idx": 523}
{"project": "bowtie2", "commit_id": "573_bowtie2_2.5.1_sstring.h_sstr_pre_leq.cpp", "target": 0, "func": "static inline bool sstr_pre_leq(\n\tconst T1& s1, size_t pre1,\n\tconst T2& s2, size_t pre2,\n\tbool endlt = true)\n{\n\tassert_leq(pre1, Class_sstr_len<T1>::sstr_len(s1));\n\tassert_leq(pre2, Class_sstr_len<T2>::sstr_len(s2));\n\tsize_t len1 = pre1;\n\tsize_t len2 = pre2;\n\tsize_t minlen = (len1 < len2 ? len1 : len2);\n\tfor(size_t i = 0; i < minlen; i++) {\n\t\tif(s1[i] < s2[i]) {\n\t\t\treturn true;\n\t\t} else if(s1[i] > s2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(len1 == len2) return true;\n\treturn (len1 < len2) == endlt;\n}", "idx": 524}
{"project": "bowtie2", "commit_id": "574_bowtie2_2.5.1_sstring.h_sstr_gt.cpp", "target": 0, "func": "static inline bool sstr_gt(const T1& s1, const T2& s2, bool endlt = true) {\n\tsize_t len1 = Class_sstr_len<T1>::sstr_len(s1);\n\tsize_t len2 = Class_sstr_len<T2>::sstr_len(s2);\n\tsize_t minlen = (len1 < len2 ? len1 : len2);\n\tfor(size_t i = 0; i < minlen; i++) {\n\t\tif(s1[i] > s2[i]) {\n\t\t\treturn true;\n\t\t} else if(s1[i] < s2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(len1 == len2) return false;\n\treturn (len1 > len2) == endlt;\n}", "idx": 525}
{"project": "bowtie2", "commit_id": "575_bowtie2_2.5.1_sstring.h_sstr_suf_gt.cpp", "target": 0, "func": "static inline bool sstr_suf_gt(\n\tconst T1& s1, size_t suf1,\n\tconst T2& s2, size_t suf2,\n\tbool endlt = true)\n{\n\tassert_leq(suf1, Class_sstr_len<T1>::sstr_len(s1));\n\tassert_leq(suf2, Class_sstr_len<T2>::sstr_len(s2));\n\tsize_t len1 = Class_sstr_len<T1>::sstr_len(s1) - suf1;\n\tsize_t len2 = Class_sstr_len<T2>::sstr_len(s2) - suf2;\n\tsize_t minlen = (len1 < len2 ? len1 : len2);\n\tfor(size_t i = 0; i < minlen; i++) {\n\t\tif(s1[suf1+i] > s2[suf2+i]) {\n\t\t\treturn true;\n\t\t} else if(s1[suf1+i] < s2[suf2+i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(len1 == len2) return false;\n\treturn (len1 > len2) == endlt;\n}", "idx": 526}
{"project": "bowtie2", "commit_id": "576_bowtie2_2.5.1_sstring.h_sstr_pre_gt.cpp", "target": 0, "func": "static inline bool sstr_pre_gt(\n\tconst T1& s1, size_t pre1,\n\tconst T2& s2, size_t pre2,\n\tbool endlt = true)\n{\n\tassert_leq(pre1, Class_sstr_len<T1>::sstr_len(s1));\n\tassert_leq(pre2, Class_sstr_len<T2>::sstr_len(s2));\n\tsize_t len1 = pre1;\n\tsize_t len2 = pre2;\n\tsize_t minlen = (len1 < len2 ? len1 : len2);\n\tfor(size_t i = 0; i < minlen; i++) {\n\t\tif(s1[i] > s2[i]) {\n\t\t\treturn true;\n\t\t} else if(s1[i] < s2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(len1 == len2) return false;\n\treturn (len1 > len2) == endlt;\n}", "idx": 527}
{"project": "bowtie2", "commit_id": "577_bowtie2_2.5.1_sstring.h_sstr_geq.cpp", "target": 0, "func": "static inline bool sstr_geq(const T1& s1, const T2& s2, bool endlt = true) {\n\tsize_t len1 = Class_sstr_len<T1>::sstr_len(s1);\n\tsize_t len2 = Class_sstr_len<T2>::sstr_len(s2);\n\tsize_t minlen = (len1 < len2 ? len1 : len2);\n\tfor(size_t i = 0; i < minlen; i++) {\n\t\tif(s1[i] > s2[i]) {\n\t\t\treturn true;\n\t\t} else if(s1[i] < s2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(len1 == len2) return true;\n\treturn (len1 > len2) == endlt;\n}", "idx": 528}
{"project": "bowtie2", "commit_id": "578_bowtie2_2.5.1_sstring.h_sstr_suf_geq.cpp", "target": 0, "func": "static inline bool sstr_suf_geq(\n\tconst T1& s1, size_t suf1,\n\tconst T2& s2, size_t suf2,\n\tbool endlt = true)\n{\n\tassert_leq(suf1, Class_sstr_len<T1>::sstr_len(s1));\n\tassert_leq(suf2, Class_sstr_len<T2>::sstr_len(s2));\n\tsize_t len1 = Class_sstr_len<T1>::sstr_len(s1) - suf1;\n\tsize_t len2 = Class_sstr_len<T2>::sstr_len(s2) - suf2;\n\tsize_t minlen = (len1 < len2 ? len1 : len2);\n\tfor(size_t i = 0; i < minlen; i++) {\n\t\tif(s1[suf1+i] > s2[suf2+i]) {\n\t\t\treturn true;\n\t\t} else if(s1[suf1+i] < s2[suf2+i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(len1 == len2) return true;\n\treturn (len1 > len2) == endlt;\n}", "idx": 529}
{"project": "bowtie2", "commit_id": "579_bowtie2_2.5.1_sstring.h_sstr_pre_geq.cpp", "target": 0, "func": "static inline bool sstr_pre_geq(\n\tconst T1& s1, size_t pre1,\n\tconst T2& s2, size_t pre2,\n\tbool endlt = true)\n{\n\tassert_leq(pre1, Class_sstr_len<T1>::sstr_len(s1));\n\tassert_leq(pre2, Class_sstr_len<T2>::sstr_len(s2));\n\tsize_t len1 = pre1;\n\tsize_t len2 = pre2;\n\tsize_t minlen = (len1 < len2 ? len1 : len2);\n\tfor(size_t i = 0; i < minlen; i++) {\n\t\tif(s1[i] > s2[i]) {\n\t\t\treturn true;\n\t\t} else if(s1[i] < s2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(len1 == len2) return true;\n\treturn (len1 > len2) == endlt;\n}", "idx": 530}
{"project": "bowtie2", "commit_id": "57_bowtie2_2.5.1_aligner_seed.h_chargeDelete.cpp", "target": 0, "func": "void chargeDelete(int ex, const Scoring& cm) {\n\t\tassert(instantiated);\n\t\tdels--;\n\t\tedits--;\n\t\tpenalty -= cm.del(ex);\n\t\tassert_geq(dels, 0);\n\t\tassert_geq(edits, 0);\n\t\tassert_geq(penalty, 0);\n\t}", "idx": 531}
{"project": "bowtie2", "commit_id": "580_bowtie2_2.5.1_sstring.h_resize.cpp", "target": 0, "func": "void resize(size_t len, const T& el) {\n\t\tassert_lt(len, S);\n\t\tif(len > len_) {\n\t\t\tfor(size_t i = len_; i < len; i++) {\n\t\t\t\tcs_[i] = el;\n\t\t\t}\n\t\t}\n\t\tlen_ = len;\n\t}", "idx": 532}
{"project": "bowtie2", "commit_id": "581_bowtie2_2.5.1_sstring.h_set.cpp", "target": 0, "func": "void set(int c, size_t idx) {\n\t\tassert_lt(idx, this->len_);\n\t\tassert_range(c, 0, 15);\n\t\tthis->cs_[idx] = c;\n\t}", "idx": 533}
{"project": "bowtie2", "commit_id": "582_bowtie2_2.5.1_sstring.h_install.cpp", "target": 0, "func": "virtual void install(const char* b, size_t sz) {\n\t\twhile(this->sz_ < sz) {\n\t\t\tthis->expandNoCopy((sz + S) * M);\n\t\t}\n\t\tmemcpy(this->cs_, b, sz);\n#ifndef NDEBUG\n\t\tfor(size_t i = 0; i < sz; i++) {\n\t\t\tassert_range((int)this->cs_[i], 0, 15);\n\t\t}\n#endif\n\t\tthis->len_ = sz;\n\t}", "idx": 534}
{"project": "bowtie2", "commit_id": "583_bowtie2_2.5.1_sstring.h_installReverse.cpp", "target": 0, "func": "void installReverse(const SStringFixed<T, S>& b) {\n\t\tassert_leq(b.len_, S);\n\t\tfor(size_t i = 0; i < b.len_; i++) {\n\t\t\tcs_[i] = b.cs_[b.len_ - i - 1];\n\t\t}\n\t\tlen_ = b.len_;\n\t}", "idx": 535}
{"project": "bowtie2", "commit_id": "584_bowtie2_2.5.1_sstring.h_reverse.cpp", "target": 0, "func": "void reverse() {\n\t\tfor(size_t i = 0; i < (len_ >> 1); i++) {\n\t\t\tT tmp = get(i);\n\t\t\tset(get(len_-i-1), i);\n\t\t\tset(tmp, len_-i-1);\n\t\t}\n\t}", "idx": 536}
{"project": "bowtie2", "commit_id": "585_bowtie2_2.5.1_sstring.h_reverseWindow.cpp", "target": 0, "func": "void reverseWindow(size_t off, size_t len) {\n\t\tassert_leq(off, len_);\n\t\tassert_leq(off + len, len_);\n\t\tsize_t mid = len >> 1;\n\t\tfor(size_t i = 0; i < mid; i++) {\n\t\t\tT tmp = get(off+i);\n\t\t\tset(get(off+len-i-1), off+i);\n\t\t\tset(tmp, off+len-i-1);\n\t\t}\n\t}", "idx": 537}
{"project": "bowtie2", "commit_id": "586_bowtie2_2.5.1_sstring.h_fill.cpp", "target": 0, "func": "void fill(const T& el) {\n\t\tfill(len_, el);\n\t}", "idx": 538}
{"project": "bowtie2", "commit_id": "587_bowtie2_2.5.1_sstring.h_clear.cpp", "target": 0, "func": "void clear() { len_ = 0; }", "idx": 539}
{"project": "bowtie2", "commit_id": "588_bowtie2_2.5.1_sstring.h_setChar.cpp", "target": 0, "func": "void setChar(char c, size_t idx) {\n\t\tassert_lt(idx, this->len_);\n\t\tassert_in(toupper(c), iupacs);\n\t\tthis->cs_[idx] = asc2dnamask[(int)c];\n\t}", "idx": 540}
{"project": "bowtie2", "commit_id": "589_bowtie2_2.5.1_sstring.h_setColor.cpp", "target": 0, "func": "void setColor(int c, size_t idx) {\n\t\tassert_in(toupper(c), \"0123\");\n\t\tint co = asc2col[c];\n\t\tset(co, idx);\n\t}", "idx": 541}
{"project": "bowtie2", "commit_id": "58_bowtie2_2.5.1_aligner_seed.h_chargeInsert.cpp", "target": 0, "func": "void chargeInsert(int ex, const Scoring& cm) {\n\t\tassert(instantiated);\n\t\tins--;\n\t\tedits--;\n\t\tpenalty -= cm.ins(ex);\n\t\tassert_geq(ins, 0);\n\t\tassert_geq(edits, 0);\n\t\tassert_geq(penalty, 0);\n\t}", "idx": 542}
{"project": "bowtie2", "commit_id": "590_bowtie2_2.5.1_sstring.h_setWord.cpp", "target": 0, "func": "void setWord(uint32_t w, size_t i) {\n\t\tassert_lt(i, nwords());\n\t\tcs_[i] = w;\n\t}", "idx": 543}
{"project": "bowtie2", "commit_id": "591_bowtie2_2.5.1_sstring.h_installChars.cpp", "target": 0, "func": "virtual void installChars(const std::basic_string<char>& str) {\n\t\tinstallChars(str.c_str(), str.length());\n\t}", "idx": 544}
{"project": "bowtie2", "commit_id": "592_bowtie2_2.5.1_sstring.h_installColors.cpp", "target": 0, "func": "virtual void installColors(const std::basic_string<char>& str) {\n\t\tinstallColors(str.c_str(), str.length());\n\t}", "idx": 545}
{"project": "bowtie2", "commit_id": "593_bowtie2_2.5.1_sstring.h_installReverseChars.cpp", "target": 0, "func": "void installReverseChars(const char* b) {\n\t\tinstallReverseChars(b, strlen(b));\n\t}", "idx": 546}
{"project": "bowtie2", "commit_id": "594_bowtie2_2.5.1_sstring.h_installReverseColors.cpp", "target": 0, "func": "void installReverseColors(const char* b) {\n\t\tinstallReverseColors(b, strlen(b));\n\t}", "idx": 547}
{"project": "bowtie2", "commit_id": "595_bowtie2_2.5.1_sstring.h_insert.cpp", "target": 0, "func": "void insert(const T& c, size_t idx) {\n\t\tassert_lt(len_, S);\n\t\tassert_lt(idx, len_);\n\t\t// Move everyone down by 1\n\t\tfor(int i = len_; i > idx; i--) {\n\t\t\tcs_[i] = cs_[i-1];\n\t\t}\n\t\tcs_[idx] = c;\n\t\tlen_++;\n\t}", "idx": 548}
{"project": "bowtie2", "commit_id": "596_bowtie2_2.5.1_sstring.h_append.cpp", "target": 0, "func": "void append(const char& c) {\n\t\twhile(this->sz_ < this->len_+1) {\n\t\t\tthis->expandNoCopy((this->len_ + 1 + S) * M);\n\t\t}\n\t\tassert_range((int)c, 0, 15);\n\t\tthis->cs_[this->len_++] = c;\n\t}", "idx": 549}
{"project": "bowtie2", "commit_id": "597_bowtie2_2.5.1_sstring.h_remove.cpp", "target": 0, "func": "void remove(size_t idx) {\n\t\tassert_lt(idx, len_);\n\t\tassert_gt(len_, 0);\n\t\tfor(size_t i = idx; i < len_-1; i++) {\n\t\t\tcs_[i] = cs_[i+1];\n\t\t}\n\t\tlen_--;\n\t}", "idx": 550}
{"project": "bowtie2", "commit_id": "598_bowtie2_2.5.1_sstring.h_trimBegin.cpp", "target": 0, "func": "void trimBegin(size_t len) {\n\t\tassert_leq(len, len_);\n\t\tif(len == len_) {\n\t\t\tlen_ = 0; return;\n\t\t}\n\t\tfor(size_t i = 0; i < len_-len; i++) {\n\t\t\tcs_[i] = cs_[i+len];\n\t\t}\n\t\tlen_ -= len;\n\t}", "idx": 551}
{"project": "bowtie2", "commit_id": "599_bowtie2_2.5.1_sstring.h_trimEnd.cpp", "target": 0, "func": "void trimEnd(size_t len) {\n\t\tif(len >= len_) len_ = 0;\n\t\telse len_ -= len;\n\t}", "idx": 552}
{"project": "bowtie2", "commit_id": "59_bowtie2_2.5.1_aligner_seed.h_instantiate.cpp", "target": 0, "func": "void instantiate(size_t rdlen) {\n\t\tassert(!instantiated);\n\t\tif(penFunc.initialized()) {\n\t\t\tpenalty = Constraint::instantiate(rdlen, penFunc);\n\t\t}\n\t\tinstantiated = true;\n\t}", "idx": 553}
{"project": "bowtie2", "commit_id": "5_bowtie2_2.5.1_aligner_bt.h_addSolution.cpp", "target": 0, "func": "void addSolution(size_t id) {\n\t\tassert(bs_[id].isSolution(prob_));\n\t\tsolutions_.push_back(id);\n\t}", "idx": 554}
{"project": "bowtie2", "commit_id": "600_bowtie2_2.5.1_sstring.h_expandCopy.cpp", "target": 0, "func": "void expandCopy(size_t sz) {\n\t\tif(sz_ >= sz) return; // done!\n\t\tT *tmp  = new T[sz + 1];\n\t\tchar *ptmp = new char[sz + 1];\n\t\tif(cs_ != NULL) {\n\t\t\tmemcpy(tmp, cs_, sizeof(T)*len_);\n\t\t\tdelete[] cs_;\n\t\t}\n\t\tif(printcs_ != NULL) {\n\t\t\tmemcpy(ptmp, printcs_, sizeof(char)*len_);\n\t\t\tdelete[] printcs_;\n\t\t}\n\t\tcs_ = tmp;\n\t\tprintcs_ = ptmp;\n\t\tsz_ = sz;\n\t}", "idx": 555}
{"project": "bowtie2", "commit_id": "601_bowtie2_2.5.1_sstring.h_expandNoCopy.cpp", "target": 0, "func": "void expandNoCopy(size_t sz) {\n\t\tif(sz_ >= sz) return; // done!\n\t\tif(cs_      != NULL) delete[] cs_;\n\t\tif(printcs_ != NULL) delete[] printcs_;\n\t\tcs_ = new T[sz + 1];\n\t\tprintcs_ = new char[sz + 1];\n\t\tsz_ = sz;\n\t}", "idx": 556}
{"project": "bowtie2", "commit_id": "602_bowtie2_2.5.1_sstring.h_SStringFixed.cpp", "target": 0, "func": "explicit SStringFixed(const T* b) {\n\t\tinstall(b, strlen(b));\n\t}", "idx": 557}
{"project": "bowtie2", "commit_id": "603_bowtie2_2.5.1_sstring.h_installReverseComp.cpp", "target": 0, "func": "void installReverseComp(const SDnaMaskString<S, M>& b) {\n\t\twhile(this->sz_ < b.len_) {\n\t\t\tthis->expandNoCopy((b.len_ + S) * M);\n\t\t}\n\t\tfor(size_t i = 0; i < b.len_; i++) {\n\t\t\tthis->cs_[i] = maskcomp[(int)b.cs_[b.len_-i-1]];\n\t\t}\n\t\tthis->len_ = b.len_;\n\t}", "idx": 558}
{"project": "bowtie2", "commit_id": "604_bowtie2_2.5.1_sstring.h_reverseComp.cpp", "target": 0, "func": "void reverseComp() {\n\t\tfor(size_t i = 0; i < (this->len_ >> 1); i++) {\n\t\t\tchar tmp1 = maskcomp[(int)this->cs_[i]];\n\t\t\tchar tmp2 = maskcomp[(int)this->cs_[this->len_-i-1]];\n\t\t\tthis->cs_[i] = tmp2;\n\t\t\tthis->cs_[this->len_-i-1] = tmp1;\n\t\t}\n\t\t// Do middle element iff there are an odd number\n\t\tif((this->len_ & 1) != 0) {\n\t\t\tchar tmp = this->cs_[this->len_ >> 1];\n\t\t\ttmp = maskcomp[(int)tmp];\n\t\t\tthis->cs_[this->len_ >> 1] = tmp;\n\t\t}\n\t}", "idx": 559}
{"project": "bowtie2", "commit_id": "605_bowtie2_2.5.1_sstring.h_appendChar.cpp", "target": 0, "func": "void appendChar(char c) {\n\t\twhile(this->sz_ < this->len_+1) {\n\t\t\texpandNoCopy((this->len_ + 1 + S) * M);\n\t\t}\n\t\tassert_in(toupper(c), iupacs);\n\t\tthis->cs_[this->len_++] = asc2dnamask[(int)c];\n\t}", "idx": 560}
{"project": "bowtie2", "commit_id": "606_bowtie2_2.5.1_str_util.h_hash_string.cpp", "target": 0, "func": "static inline int\nhash_string(const std::string& s) {\n\tint ret = 0;\n\tint a = 63689;\n\tint b = 378551;\n\tfor(size_t i = 0; i < s.length(); i++) {\n\t\tret = (ret * a) + (int)s[i];\n\t\tif(a == 0) {\n\t\t\ta += b;\n\t\t} else {\n\t\t\ta *= b;\n\t\t}\n\t\tif(a == 0) {\n\t\t\ta += b;\n\t\t}\n\t}\n\treturn ret;\n}", "idx": 561}
{"project": "bowtie2", "commit_id": "607_bowtie2_2.5.1_str_util.h_hash_str.cpp", "target": 0, "func": "static inline uint32_t hash_str(const char *str) {\n\tint c;\n\tconst uint32_t FNV_PRIME = 0x010000193;\n\tuint32_t hash = 0x811C9Dc5;\n\n\n\twhile ((c = *str++) != '\\0')\n\t\thash = (hash ^ c) * FNV_PRIME;\n\treturn hash;\n}", "idx": 562}
{"project": "bowtie2", "commit_id": "608_bowtie2_2.5.1_threading.h_mutex_.cpp", "target": 0, "func": "endif\n\t\tmutex_(mutex) {\n#if NO_SPINLOCK && WITH_QUEUELOCK\n\t\tmutex_.lock(node_);\n#else\n\t\tmutex_.lock();\n#endif\n\n\t}", "idx": 563}
{"project": "bowtie2", "commit_id": "609_bowtie2_2.5.1_threading.h_on_scheduler_entry.cpp", "target": 0, "func": "void on_scheduler_entry( bool ) {\n    if ( !mask ) return;\n\n    const size_t size = CPU_ALLOC_SIZE( ncpus );\n    const int num_cpus = CPU_COUNT_S( size, mask );\n    int thr_idx =\n//cwilks: we're one interface version lower than what\n//is required for task arena (7000 vs. 7001)\n#if USE_TASK_ARENA_CURRENT_SLOT\n        tbb::task_arena::current_slot();\n#else\n        thread_index++;\n#endif\n#if __MIC__\n    thr_idx += 1; // To avoid logical thread zero for the master thread on Intel(R) Xeon Phi(tm)\n#endif\n    thr_idx %= num_cpus; // To limit unique number in [0; num_cpus-1] range\n\n        // Place threads with specified step\n        int cpu_idx = 0;\n        for ( int i = 0, offset = 0; i<thr_idx; ++i ) {\n            cpu_idx += pinning_step;\n            if ( cpu_idx >= num_cpus )\n                cpu_idx = ++offset;\n        }\n\n        // Find index of 'cpu_idx'-th bit equal to 1\n        int mapped_idx = -1;\n        while ( cpu_idx >= 0 ) {\n            if ( CPU_ISSET_S( ++mapped_idx, size, mask ) )\n                --cpu_idx;\n        }\n\n        cpu_set_t *target_mask = CPU_ALLOC( ncpus );\n        CPU_ZERO_S( size, target_mask );\n        CPU_SET_S( mapped_idx, size, target_mask );\n        const int err = sched_setaffinity( 0, size, target_mask );\n\n        //std::cout << \"Just set affinity for thread \" << thr_idx << \"\\n\";\n        if ( err ) {\n            std::cout << \"Failed to set thread affinity!n\";\n            exit( EXIT_FAILURE );\n        }\n#if LOG_PINNING\n        else {\n            std::stringstream ss;\n            ss << \"Set thread affinity: Thread \" << thr_idx << \": CPU \" << mapped_idx << std::endl;\n            std::cerr << ss.str();\n        }\n#endif\n        CPU_FREE( target_mask );\n    }", "idx": 564}
{"project": "bowtie2", "commit_id": "60_bowtie2_2.5.1_aligner_seed.h_Seed.cpp", "target": 0, "func": "for the overall alignment\n\n\tSeed() { init(0, 0, NULL); }", "idx": 565}
{"project": "bowtie2", "commit_id": "610_bowtie2_2.5.1_threading.h_on_scheduler_exit.cpp", "target": 0, "func": "void on_scheduler_exit( bool ) { --num_threads; }", "idx": 566}
{"project": "bowtie2", "commit_id": "611_bowtie2_2.5.1_threading.h_get_concurrency.cpp", "target": 0, "func": "int get_concurrency() { return num_threads; }", "idx": 567}
{"project": "bowtie2", "commit_id": "612_bowtie2_2.5.1_threadpool.h_push.cpp", "target": 0, "func": "void push(T &&new_value) {\n\t\tstd::lock_guard<std::mutex> lk(mut);\n\t\tdata_queue.emplace(new_value);\n\t}", "idx": 568}
{"project": "bowtie2", "commit_id": "613_bowtie2_2.5.1_threadpool.h_try_pop.cpp", "target": 0, "func": "bool try_pop(T& value) {\n\t\tstd::lock_guard<std::mutex> lk(mut);\n\t\tif (data_queue.empty())\n\t\t\treturn false;\n\t\tvalue = std::move(data_queue.front());\n\t\tdata_queue.pop();\n\t\treturn true;\n\t}", "idx": 569}
{"project": "bowtie2", "commit_id": "614_bowtie2_2.5.1_threadpool.h_size.cpp", "target": 0, "func": "int size() {\n                return nthreads;\n        }", "idx": 570}
{"project": "bowtie2", "commit_id": "615_bowtie2_2.5.1_threadpool.h_thread_id_to_int.cpp", "target": 0, "func": "int thread_id_to_int(std::thread::id id) {\n                return thread_id[id];\n        }", "idx": 571}
{"project": "bowtie2", "commit_id": "616_bowtie2_2.5.1_threadpool.h_parallel_for.cpp", "target": 0, "func": "void parallel_for(T start, T end, T stride, Function &&f) {\n                T range = end - start;\n                T block_size = range / (nthreads);\n                T block_start = start;\n                T block_end = block_start + block_size;\n                if (block_size == 0)\n                        block_end = end;\n                std::vector<std::future<void>> res;\n                while (block_start < end) {\n                        res.emplace_back(submit(f, block_start, block_end, stride));\n                        block_start = block_end;\n                        block_end = block_end + block_size;\n                        if (block_end >= end)\n                                block_end = end;\n                }\n                for (size_t i = 0; i < res.size(); i++)\n                        res[i].get();\n        }", "idx": 572}
{"project": "bowtie2", "commit_id": "617_bowtie2_2.5.1_timer.h_timeval_subtract.cpp", "target": 0, "func": "static inline bool timeval_subtract(timeval& result, const timeval& xin, const timeval& yin) {\n\t/* Perform the carry for the later subtraction by updating y. */\n\ttimeval x = xin;\n\ttimeval y = yin;\n\tif (x.tv_usec < y.tv_usec) {\n\t\tint nsec = (y.tv_usec - x.tv_usec) / 1000000 + 1;\n\t\ty.tv_usec -= 1000000 * nsec;\n\t\ty.tv_sec += nsec;\n\t}\n\tif (x.tv_usec - y.tv_usec > 1000000) {\n\t\tint nsec = (x.tv_usec - y.tv_usec) / 1000000;\n\t\ty.tv_usec += 1000000 * nsec;\n\t\ty.tv_sec -= nsec;\n\t}\n\n\t/* Compute the time remaining to wait. tv_usec is certainly positive. */\n\tresult.tv_sec = x.tv_sec - y.tv_sec;\n\tresult.tv_usec = x.tv_usec - y.tv_usec;\n\n\t/* Return 1 if result is negative. */\n\treturn x.tv_sec < y.tv_sec;\n}", "idx": 573}
{"project": "bowtie2", "commit_id": "618_bowtie2_2.5.1_timer.h_write.cpp", "target": 0, "func": "void write(ostream& out) {\n\t\ttime_t passed = elapsed();\n\t\t// Print the message supplied at construction time followed\n\t\t// by time elapsed formatted HH:MM:SS\n\t\ttime_t hours   = (passed / 60) / 60;\n\t\ttime_t minutes = (passed / 60) % 60;\n\t\ttime_t seconds = (passed % 60);\n\t\tstd::ostringstream oss;\n\t\toss << _msg << setfill ('0') << setw (2) << hours << \":\"\n\t\t\t<< setfill ('0') << setw (2) << minutes << \":\"\n\t\t\t<< setfill ('0') << setw (2) << seconds << endl;\n\t\tout << oss.str().c_str();\n\t}", "idx": 574}
{"project": "bowtie2", "commit_id": "619_bowtie2_2.5.1_timer.h_logTime.cpp", "target": 0, "func": "USE_FINE_TIMER\n\nstatic inline void logTime(std::ostream& os, bool nl = true) {\n\tstruct tm *current;\n\ttime_t now;\n\ttime(&now);\n\tcurrent = localtime(&now);\n\tstd::ostringstream oss;\n\toss << setfill('0') << setw(2)\n\t    << current->tm_hour << \":\"\n\t    << setfill('0') << setw(2)\n\t    << current->tm_min << \":\"\n\t    << setfill('0') << setw(2)\n\t    << current->tm_sec;\n\tif(nl) oss << std::endl;\n\tos << oss.str().c_str();\n}", "idx": 575}
{"project": "bowtie2", "commit_id": "61_bowtie2_2.5.1_aligner_seed.h_acceptable.cpp", "target": 0, "func": "bool acceptable() {\n\t\tassert(overall != NULL);\n\t\treturn zones[0].acceptable() &&\n\t\t       zones[1].acceptable() &&\n\t\t       zones[2].acceptable() &&\n\t\t       overall->acceptable();\n\t}", "idx": 576}
{"project": "bowtie2", "commit_id": "620_bowtie2_2.5.1_tokenize.h_tokenize.cpp", "target": 1, "func": "static inline void tokenize(const std::string& s, char delim, T& ss) {\n\tstd::string token;\n\tstd::istringstream iss(s);\n\twhile(getline(iss, token, delim)) {\n\t\tss.push_back(token);\n\t}\n}", "idx": 577}
{"project": "bowtie2", "commit_id": "621_bowtie2_2.5.1_unique.h_bestIsUnique.cpp", "target": 0, "func": "static bool bestIsUnique(\n\t\tconst AlnSetSumm& s,\n\t\tconst AlnFlags& flags,\n\t\tbool mate1,\n\t\tsize_t rdlen,\n\t\tsize_t ordlen,\n\t\tchar *inps)\n\t{\n\t\tassert(!s.empty());\n\t\treturn !VALID_AL_SCORE(s.bestUnchosenScore(mate1));\n\t}", "idx": 578}
{"project": "bowtie2", "commit_id": "622_bowtie2_2.5.1_unique.h_new_mapq.cpp", "target": 0, "func": "static inline Mapq *new_mapq(\n\tint version,\n\tconst SimpleFunc& scoreMin,\n\tconst Scoring& sc)\n{\n\tif(version == 3) {\n\t\treturn new BowtieMapq3(scoreMin, sc);\n\t} else if(version == 2) {\n\t\treturn new BowtieMapq2(scoreMin, sc);\n\t} else {\n\t\treturn new BowtieMapq(scoreMin, sc);\n\t}\n}", "idx": 579}
{"project": "bowtie2", "commit_id": "623_bowtie2_2.5.1_word_io.h_writeU.cpp", "target": 0, "func": "static inline void writeU(std::ostream& out, T x) {\n\tout.write((const char*)&x, sizeof(T));\n}", "idx": 580}
{"project": "bowtie2", "commit_id": "624_bowtie2_2.5.1_word_io.h_writeI.cpp", "target": 0, "func": "static inline void writeI(std::ostream& out, T x) {\n\tout.write((const char*)&x, sizeof(T));\n}", "idx": 581}
{"project": "bowtie2", "commit_id": "625_bowtie2_2.5.1_word_io.h_readU.cpp", "target": 0, "func": "static inline T readU(FILE* in, bool swap) {\n\tT x;\n\tif(fread((void *)&x, sizeof(T), 1, in) != 1) {\n\t\tperror(\"readU\");\n\t\texit(1);\n\t}\n\tif(swap) {\n\t\tif(sizeof(T) == 4) {\n\t\t\treturn endianSwapU32(x);\n\t\t} else if(sizeof(T) == 8) {\n\t\t\treturn endianSwapU64(x);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t} else {\n\t\treturn x;\n\t}\n}", "idx": 582}
{"project": "bowtie2", "commit_id": "626_bowtie2_2.5.1_word_io.h_readI.cpp", "target": 0, "func": "static inline T readI(FILE* in, bool swap) {\n\tT x;\n\tif(fread((void *)&x, sizeof(T), 1, in) != 1) {\n\t\tperror(\"readI\");\n\t\texit(1);\n\t}\n\tif(swap) {\n\t\tif(sizeof(T) == 4) {\n\t\t\treturn endianSwapI32(x);\n\t\t} else if(sizeof(T) == 8) {\n\t\t\treturn endianSwapI64(x);\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t} else {\n\t\treturn x;\n\t}\n}", "idx": 583}
{"project": "bowtie2", "commit_id": "627_bowtie2_2.5.1_zstd_decompress.cpp_zstdStrmInit.cpp", "target": 0, "func": "zstdStrm *zstdStrmInit()\n{\n\tzstdStrm *s;\n\n\tif ((s = (zstdStrm *)malloc(sizeof(zstdStrm))) == NULL)\n                return NULL;\n        s->back  = EOF;\n        s->i_len = ZSTD_DStreamInSize();\n        s->o_len = 0;\n        s->i_pos = 0;\n        s->o_pos = 0;\n        s->i_buf = NULL;\n        if ((s->i_buf = malloc(s->i_len)) == NULL) {\n\t\tzstdClose(s);\n                return NULL;\n        }\n\tif ((s->o_buf = malloc(ZSTD_DStreamOutSize())) == NULL) {\n\t\tzstdClose(s);\n                return NULL;\n        }\n\n        if ((s->strm = ZSTD_createDCtx()) == NULL) {\n                zstdClose(s);\n                return NULL;\n        }\n\n        return s;\n}", "idx": 584}
{"project": "bowtie2", "commit_id": "628_bowtie2_2.5.1_zstd_decompress.cpp_zstdOpen.cpp", "target": 0, "func": "zstdStrm *zstdOpen(const char *fn) {\n        FILE *fp;\n        zstdStrm *s;\n\n\ts = zstdStrmInit();\n\tif (s == NULL)\n\t\treturn NULL;\n        fp = fopen(fn, \"rb\");\n        if (fp == NULL) {\n\t\tzstdClose(s);\n\t\treturn NULL;\n        }\n        s->fp = fp;\n\n        return s;\n}", "idx": 585}
{"project": "bowtie2", "commit_id": "629_bowtie2_2.5.1_zstd_decompress.cpp_zstdFdOpen.cpp", "target": 0, "func": "zstdStrm *zstdFdOpen(int fd) {\n\tFILE *fp;\n\tzstdStrm *s;\n\n\tif (fd == -1)\n\t\treturn NULL;\n\ts = zstdStrmInit();\n\tif (s == NULL)\n\t\treturn NULL;\n\tfp = fdopen(fd, \"rb\");\n        if (fp == NULL) {\n\t\tzstdClose(s);\n\t\treturn NULL;\n        }\n        s->fp = fp;\n\n\treturn s;\n}", "idx": 586}
{"project": "bowtie2", "commit_id": "62_bowtie2_2.5.1_aligner_seed.h_mmSeeds.cpp", "target": 0, "func": "static void mmSeeds(\n\t\tint mms,\n\t\tint ln,\n\t\tEList<Seed>& pols,\n\t\tConstraint& oall)\n\t{\n\t\tif(mms == 0) {\n\t\t\tzeroMmSeeds(ln, pols, oall);\n\t\t} else if(mms == 1) {\n\t\t\toneMmSeeds(ln, pols, oall);\n\t\t} else if(mms == 2) {\n\t\t\ttwoMmSeeds(ln, pols, oall);\n\t\t} else throw 1;\n\t}", "idx": 587}
{"project": "bowtie2", "commit_id": "630_bowtie2_2.5.1_zstd_decompress.cpp_zstdDecompress.cpp", "target": 0, "func": "int zstdDecompress(zstdStrm *s)\n{\n        int ret;\n        ZSTD_inBuffer in = { s->i_buf, s->i_len, s->i_pos };\n\tZSTD_outBuffer out = { s->o_buf, s->o_len, s->o_pos };\n\n\tret = ZSTD_decompressStream(s->strm, &out, &in);\n\ts->i_pos = in.pos;\n\ts->o_pos = out.pos;\n\n        return ret;\n}", "idx": 588}
{"project": "bowtie2", "commit_id": "631_bowtie2_2.5.1_zstd_decompress.cpp_zstdUngetc.cpp", "target": 0, "func": "int zstdUngetc(int c, zstdStrm *s)\n{\n        if (s == NULL || c == EOF || s->back != EOF)\n                return EOF;\n        s->o_pos--;\n        s->back = c;\n\n        return c;\n}", "idx": 589}
{"project": "bowtie2", "commit_id": "632_bowtie2_2.5.1_zstd_decompress.cpp_zstdGetc.cpp", "target": 0, "func": "int zstdGetc(zstdStrm *s)\n{\n        int ret;\n\n\n\tif (s->o_len == 0) {\n\t\tret = zstdRead(s, s->o_buf, ZSTD_DStreamOutSize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ts->o_len = s->o_pos;\n\t\ts->o_pos = 0;\n\t}\n\ts->o_len--;\n\treturn ((char *)s->o_buf)[s->o_pos++];\n}", "idx": 590}
{"project": "bowtie2", "commit_id": "633_bowtie2_2.5.1_zstd_decompress.cpp_zstdClose.cpp", "target": 1, "func": "int zstdClose(zstdStrm *s)\n{\n        if (s == NULL)\n                return -1;\n        if (s->fp != NULL)\n                fclose(s->fp);\n        if (s->i_buf != NULL)\n                free(s->i_buf);\n        if (s->o_buf != NULL)\n                free(s->o_buf);\n        if (s->strm != NULL)\n\t\tZSTD_freeDStream(s->strm);\n\tbzero(s, sizeof(zstdStrm));\n\tfree(s);\n\n        return 0;\n}", "idx": 591}
{"project": "bowtie2", "commit_id": "634_bowtie2_2.5.1_zstd_decompress.cpp_zstdRewind.cpp", "target": 0, "func": "int zstdRewind(zstdStrm *s)\n{\n        if (s == NULL)\n                return -1;\n        s->back = EOF;\n        s->i_len = 0;\n        s->i_pos = 0;\n        ZSTD_DCtx_reset(s->strm, ZSTD_reset_session_only);\n        return fseek(s->fp, 0, SEEK_SET);\n}", "idx": 592}
{"project": "bowtie2", "commit_id": "635_bowtie2_2.5.1_cpuid.h___get_cpuid_max.cpp", "target": 0, "func": "static __inline unsigned int\n__get_cpuid_max (unsigned int __ext, unsigned int *__sig)\n{\n  unsigned int __eax, __ebx, __ecx, __edx;\n\n#ifndef __x86_64__\n#if __GNUC__ >= 3\n  /* See if we can use cpuid.  On AMD64 we always can.  */\n  __asm__ (\"pushf{l|d}\\n\\t\"\n\t   \"pushf{l|d}\\n\\t\"\n\t   \"pop{l}\\t%0\\n\\t\"\n\t   \"mov{l}\\t{%0, %1|%1, %0}\\n\\t\"\n\t   \"xor{l}\\t{%2, %0|%0, %2}\\n\\t\"\n\t   \"push{l}\\t%0\\n\\t\"\n\t   \"popf{l|d}\\n\\t\"\n\t   \"pushf{l|d}\\n\\t\"\n\t   \"pop{l}\\t%0\\n\\t\"\n\t   \"popf{l|d}\\n\\t\"\n\t   : \"=&r\" (__eax), \"=&r\" (__ebx)\n\t   : \"i\" (0x00200000));\n#else\n/* Host GCCs older than 3.0 weren't supporting Intel asm syntax\n   nor alternatives in i386 code.  */\n  __asm__ (\"pushfl\\n\\t\"\n\t   \"pushfl\\n\\t\"\n\t   \"popl\\t%0\\n\\t\"\n\t   \"movl\\t%0, %1\\n\\t\"\n\t   \"xorl\\t%2, %0\\n\\t\"\n\t   \"pushl\\t%0\\n\\t\"\n\t   \"popfl\\n\\t\"\n\t   \"pushfl\\n\\t\"\n\t   \"popl\\t%0\\n\\t\"\n\t   \"popfl\\n\\t\"\n\t   : \"=&r\" (__eax), \"=&r\" (__ebx)\n\t   : \"i\" (0x00200000));\n#endif\n\n  if (!((__eax ^ __ebx) & 0x00200000))\n    return 0;\n#endif\n\n  /* Host supports cpuid.  Return highest supported cpuid input value.  */\n  __cpuid (__ext, __eax, __ebx, __ecx, __edx);\n\n  if (__sig)\n    *__sig = __ebx;\n\n  return __eax;\n}", "idx": 593}
{"project": "bowtie2", "commit_id": "636_bowtie2_2.5.1_cpuid.h___get_cpuid.cpp", "target": 0, "func": "static __inline int\n__get_cpuid (unsigned int __level,\n\t     unsigned int *__eax, unsigned int *__ebx,\n\t     unsigned int *__ecx, unsigned int *__edx)\n{\n  unsigned int __ext = __level & 0x80000000;\n\n  if (__get_cpuid_max (__ext, 0) < __level)\n    return 0;\n\n  __cpuid (__level, *__eax, *__ebx, *__ecx, *__edx);\n  return 1;\n}", "idx": 594}
{"project": "bowtie2", "commit_id": "637_bowtie2_2.5.1_bt2_search.cpp_multiseedSearchWorker.cpp", "target": 1, "func": "static void multiseedSearchWorker(void *vp) {\n\t//int tid = *((int*)vp);\n\tthread_tracking_pair *p = (thread_tracking_pair*) vp;\n\tint tid = p->tid;\n\tassert(multiseed_ebwtFw != NULL);\n\tassert(multiseedMms == 0 || multiseed_ebwtBw != NULL);\n\tPatternSourceReadAheadFactory& readahead_factory =  *multiseed_readahead_factory;\n\tconst Ebwt&             ebwtFw   = *multiseed_ebwtFw;\n\tconst Ebwt*             ebwtBw   = multiseed_ebwtBw;\n\tconst Scoring&          sc       = *multiseed_sc;\n\tconst BitPairReference& ref      = *multiseed_refs;\n\tAlnSink&                msink    = *multiseed_msink;\n\tOutFileBuf*             metricsOfb = multiseed_metricsOfb;\n\n\t{\n#ifdef PER_THREAD_TIMING\n\t\tuint64_t ncpu_changeovers = 0;\n\t\tuint64_t nnuma_changeovers = 0;\n\n\t\tint current_cpu = 0, current_node = 0;\n\t\tget_cpu_and_node(current_cpu, current_node);\n\n\t\tstd::stringstream ss;\n\t\tstd::string msg;\n\t\tss << \"thread: \" << tid << \" time: \";\n\t\tmsg = ss.str();\n\t\tTimer timer(std::cout, msg.c_str());\n#endif\n\n\t\t// Sinks: these are so that we can print tables encoding counts for\n\t\t// events of interest on a per-read, per-seed, per-join, or per-SW\n\t\t// level.  These in turn can be used to diagnose performance\n\t\t// problems, or generally characterize performance.\n\n\t\t//const BitPairReference& refs   = *multiseed_refs;\n\n\t\t// Thread-local cache for seed alignments\n\t\tPtrWrap<AlignmentCache> scLocal;\n\t\tif(!msNoCache) {\n\t\t\tscLocal.init(new AlignmentCache(seedCacheLocalMB * 1024 * 1024, false));\n\t\t}\n\t\tAlignmentCache scCurrent(seedCacheCurrentMB * 1024 * 1024, false);\n\t\t// Thread-local cache for current seed alignments\n\n\t\t// Interfaces for alignment and seed caches\n\t\tAlignmentCacheIface ca(\n\t\t\t&scCurrent,\n\t\t\tscLocal.get(),\n\t\t\tmsNoCache ? NULL : multiseed_ca);\n\n\t\t// Instantiate an object for holding reporting-related parameters.\n\t\tReportingParams rp(\n\t\t\t(allHits ? std::numeric_limits<THitInt>::max() : khits), // -k\n\t\t\tmhits,             // -m/-M\n\t\t\t0,                 // penalty gap (not used now)\n\t\t\tmsample,           // true -> -M was specified, otherwise assume -m\n\t\t\tgReportDiscordant, // report discordang paired-end alignments?\n\t\t\tgReportMixed);     // report unpaired alignments for paired reads?\n\n\t\t// Instantiate a mapping quality calculator\n\t\tunique_ptr<Mapq> bmapq(new_mapq(mapqv, scoreMin, sc));\n\n\t\t// Make a per-thread wrapper for the global MHitSink object.\n\t\tAlnSinkWrap msinkwrap(\n\t\t\tmsink,         // global sink\n\t\t\trp,            // reporting parameters\n\t\t\t*bmapq,        // MAPQ calculator\n\t\t\t(size_t)tid);  // thread id\n\n\t\t// Write dynamic-programming problem descriptions here\n\t\tofstream *dpLog = NULL, *dpLogOpp = NULL;\n\t\tif(!logDps.empty()) {\n\t\t\tdpLog = new ofstream(logDps.c_str(), ofstream::out);\n\t\t\tdpLog->sync_with_stdio(false);\n\t\t}\n\t\tif(!logDpsOpp.empty()) {\n\t\t\tdpLogOpp = new ofstream(logDpsOpp.c_str(), ofstream::out);\n\t\t\tdpLogOpp->sync_with_stdio(false);\n\t\t}\n\n\t\tSeedAligner al;\n\t\tSwDriver sd(exactCacheCurrentMB * 1024 * 1024);\n\t\tSwAligner sw(dpLog), osw(dpLogOpp);\n\t\tSeedResults shs[2];\n\t\tOuterLoopMetrics olm;\n\t\tSeedSearchMetrics sdm;\n\t\tWalkMetrics wlm;\n\t\tSwMetrics swmSeed, swmMate;\n\t\tReportingMetrics rpm;\n\t\tRandomSource rnd, rndArb;\n\t\tSSEMetrics sseU8ExtendMet;\n\t\tSSEMetrics sseU8MateMet;\n\t\tSSEMetrics sseI16ExtendMet;\n\t\tSSEMetrics sseI16MateMet;\n\t\tuint64_t nbtfiltst = 0; // TODO: find a new home for these\n\t\tuint64_t nbtfiltsc = 0; // TODO: find a new home for these\n\t\tuint64_t nbtfiltdo = 0; // TODO: find a new home for these\n\n\t\tASSERT_ONLY(BTDnaString tmp);\n\n\t\tint pepolFlag;\n\t\tif(gMate1fw && gMate2fw) {\n\t\t\tpepolFlag = PE_POLICY_FF;\n\t\t} else if(gMate1fw && !gMate2fw) {\n\t\t\tpepolFlag = PE_POLICY_FR;\n\t\t} else if(!gMate1fw && gMate2fw) {\n\t\t\tpepolFlag = PE_POLICY_RF;\n\t\t} else {\n\t\t\tpepolFlag = PE_POLICY_RR;\n\t\t}\n\t\tassert_geq(gMaxInsert, gMinInsert);\n\t\tassert_geq(gMinInsert, 0);\n\t\tPairedEndPolicy pepol(\n\t\t\tpepolFlag,\n\t\t\tgMaxInsert,\n\t\t\tgMinInsert,\n\t\t\tlocalAlign,\n\t\t\tgFlippedMatesOK,\n\t\t\tgDovetailMatesOK,\n\t\t\tgContainMatesOK,\n\t\t\tgOlapMatesOK,\n\t\t\tgExpandToFrag);\n\n\t\tPerfMetrics metricsPt; // per-thread metrics object; for read-level metrics\n\t\tBTString nametmp;\n\t\tEList<Seed> seeds1, seeds2;\n\t\tEList<Seed> *seeds[2] = { &seeds1, &seeds2 };\n\n\t\tPerReadMetrics prm;\n\n\t\t// Used by thread with threadid == 1 to measure time elapsed\n\t\ttime_t iTime = time(0);\n\n\t\t// Keep track of whether last search was exhaustive for mates 1 and 2\n\t\tbool exhaustive[2] = { false, false };\n\t\t// Keep track of whether mates 1/2 were filtered out last time through\n\t\tbool filt[2]    = { true, true };\n\t\t// Keep track of whether mates 1/2 were filtered out due Ns last time\n\t\tbool nfilt[2]   = { true, true };\n\t\t// Keep track of whether mates 1/2 were filtered out due to not having\n\t\t// enough characters to rise about the score threshold.\n\t\tbool scfilt[2]  = { true, true };\n\t\t// Keep track of whether mates 1/2 were filtered out due to not having\n\t\t// more characters than the number of mismatches permitted in a seed.\n\t\tbool lenfilt[2] = { true, true };\n\t\t// Keep track of whether mates 1/2 were filtered out by upstream qc\n\t\tbool qcfilt[2]  = { true, true };\n\n\t\trndArb.init((uint32_t)time(0));\n\t\tint mergei = 0;\n\t\tint mergeival = 16;\n\t\tbool done = false;\n\t\twhile(!done) {\n\t\t   PatternSourceReadAhead psrah(readahead_factory);\n\t\t   PatternSourcePerThread* const ps = psrah.ptr();\n\t\t   bool firstPS = true;\n                   do {\n\t\t\tpair<bool, bool> ret = firstPS ? \n\t\t\t\t\t\tpsrah.readResult() : // nextReadPair was already called in the psrah constructor\n\t\t\t\t\t\tps->nextReadPair();\n\t\t\tfirstPS = false;\n\t\t\tbool success = ret.first;\n\t\t\tdone = ret.second;\n\t\t\tif(!success && done) {\n\t\t\t\tbreak;\n\t\t\t} else if(!success) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tTReadId rdid = ps->read_a().rdid;\n\t\t\tbool sample = true;\n\t\t\tif(arbitraryRandom) {\n\t\t\t\tps->read_a().seed = rndArb.nextU32();\n\t\t\t\tps->read_b().seed = rndArb.nextU32();\n\t\t\t}\n\t\t\tif(sampleFrac < 1.0f) {\n\t\t\t\trnd.init(ROTL(ps->read_a().seed, 2));\n\t\t\t\tsample = rnd.nextFloat() < sampleFrac;\n\t\t\t}\n\t\t\tif(rdid >= skipReads && rdid < qUpto && sample) {\n\t\t\t\t// Align this read/pair\n\t\t\t\tbool retry = true;\n\t\t\t\t//\n\t\t\t\t// Check if there is metrics reporting for us to do.\n\t\t\t\t//\n\t\t\t\tif(metricsIval > 0 &&\n\t\t\t\t   (metricsOfb != NULL || metricsStderr) &&\n\t\t\t\t   !metricsPerRead &&\n\t\t\t\t   ++mergei == mergeival)\n\t\t\t\t{\n\t\t\t\t\t// Do a periodic merge.  Update global metrics, in a\n\t\t\t\t\t// synchronized manner if needed.\n\t\t\t\t\tMERGE_METRICS(metrics);\n\t\t\t\t\tmergei = 0;\n\t\t\t\t\t// Check if a progress message should be printed\n\t\t\t\t\tif(tid == 0) {\n\t\t\t\t\t\t// Only thread 1 prints progress messages\n\t\t\t\t\t\ttime_t curTime = time(0);\n\t\t\t\t\t\tif(curTime - iTime >= metricsIval) {\n\t\t\t\t\t\t\tmetrics.reportInterval(metricsOfb, metricsStderr, false, NULL);\n\t\t\t\t\t\t\tiTime = curTime;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprm.reset(); // per-read metrics\n\t\t\t\tprm.doFmString = false;\n\t\t\t\tif(sam_print_xt) {\n\t\t\t\t\tgettimeofday(&prm.tv_beg, &prm.tz_beg);\n\t\t\t\t}\n#ifdef PER_THREAD_TIMING\n\t\t\t\tint cpu = 0, node = 0;\n\t\t\t\tget_cpu_and_node(cpu, node);\n\t\t\t\tif(cpu != current_cpu) {\n\t\t\t\t\tncpu_changeovers++;\n\t\t\t\t\tcurrent_cpu = cpu;\n\t\t\t\t}\n\t\t\t\tif(node != current_node) {\n\t\t\t\t\tnnuma_changeovers++;\n\t\t\t\t\tcurrent_node = node;\n\t\t\t\t}\n#endif\n\t\t\t\t// Try to align this read\n\t\t\t\twhile(retry) {\n\t\t\t\t\tretry = false;\n\t\t\t\t\tca.nextRead(); // clear the cache\n\t\t\t\t\tolm.reads++;\n\t\t\t\t\tassert(!ca.aligning());\n\t\t\t\t\tbool paired = !ps->read_b().empty();\n\t\t\t\t\tconst size_t rdlen1 = ps->read_a().length();\n\t\t\t\t\tconst size_t rdlen2 = paired ? ps->read_b().length() : 0;\n\t\t\t\t\tolm.bases += (rdlen1 + rdlen2);\n\t\t\t\t\tmsinkwrap.nextRead(\n\t\t\t\t\t\t&ps->read_a(),\n\t\t\t\t\t\tpaired ? &ps->read_b() : NULL,\n\t\t\t\t\t\trdid,\n\t\t\t\t\t\tsc.qualitiesMatter());\n\t\t\t\t\tassert(msinkwrap.inited());\n\t\t\t\t\tsize_t rdlens[2] = { rdlen1, rdlen2 };\n\t\t\t\t\tsize_t rdrows[2] = { rdlen1, rdlen2 };\n\t\t\t\t\t// Calculate the minimum valid score threshold for the read\n\t\t\t\t\tTAlScore minsc[2];\n\t\t\t\t\tminsc[0] = minsc[1] = std::numeric_limits<TAlScore>::max();\n\t\t\t\t\tif(bwaSwLike) {\n\t\t\t\t\t\t// From BWA-SW manual: \"Given an l-long query, the\n\t\t\t\t\t\t// threshold for a hit to be retained is\n\t\t\t\t\t\t// a*max{T,c*log(l)}.\"  We try to recreate that here.\n\t\t\t\t\t\tfloat a = (float)sc.match(30);\n\t\t\t\t\t\tfloat T = bwaSwLikeT, c = bwaSwLikeC;\n\t\t\t\t\t\tminsc[0] = (TAlScore)max<float>(a*T, a*c*log(rdlens[0]));\n\t\t\t\t\t\tif(paired) {\n\t\t\t\t\t\t\tminsc[1] = (TAlScore)max<float>(a*T, a*c*log(rdlens[1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tminsc[0] = scoreMin.f<TAlScore>(rdlens[0]);\n\t\t\t\t\t\tif(paired) minsc[1] = scoreMin.f<TAlScore>(rdlens[1]);\n\t\t\t\t\t\tif(localAlign) {\n\t\t\t\t\t\t\tif(minsc[0] < 0) {\n\t\t\t\t\t\t\t\tif(!gQuiet) printLocalScoreMsg(*ps, paired, true);\n\t\t\t\t\t\t\t\tminsc[0] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(paired && minsc[1] < 0) {\n\t\t\t\t\t\t\t\tif(!gQuiet) printLocalScoreMsg(*ps, paired, false);\n\t\t\t\t\t\t\t\tminsc[1] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(minsc[0] > 0) {\n\t\t\t\t\t\t\t\tif(!gQuiet) printEEScoreMsg(*ps, paired, true);\n\t\t\t\t\t\t\t\tminsc[0] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(paired && minsc[1] > 0) {\n\t\t\t\t\t\t\t\tif(!gQuiet) printEEScoreMsg(*ps, paired, false);\n\t\t\t\t\t\t\t\tminsc[1] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// N filter; does the read have too many Ns?\n\t\t\t\t\tsize_t readns[2] = {0, 0};\n\t\t\t\t\tsc.nFilterPair(\n\t\t\t\t\t\t&ps->read_a().patFw,\n\t\t\t\t\t\tpaired ? &ps->read_b().patFw : NULL,\n\t\t\t\t\t\treadns[0],\n\t\t\t\t\t\treadns[1],\n\t\t\t\t\t\tnfilt[0],\n\t\t\t\t\t\tnfilt[1]);\n\t\t\t\t\t// Score filter; does the read enough character to rise above\n\t\t\t\t\t// the score threshold?\n\t\t\t\t\tscfilt[0] = sc.scoreFilter(minsc[0], rdlens[0]);\n\t\t\t\t\tscfilt[1] = sc.scoreFilter(minsc[1], rdlens[1]);\n\t\t\t\t\tlenfilt[0] = lenfilt[1] = true;\n\t\t\t\t\tif(rdlens[0] <= (size_t)multiseedMms || rdlens[0] < 2) {\n\t\t\t\t\t\tif(!gQuiet) printMmsSkipMsg(*ps, paired, true, multiseedMms);\n\t\t\t\t\t\tlenfilt[0] = false;\n\t\t\t\t\t}\n\t\t\t\t\tif((rdlens[1] <= (size_t)multiseedMms || rdlens[1] < 2) && paired) {\n\t\t\t\t\t\tif(!gQuiet) printMmsSkipMsg(*ps, paired, false, multiseedMms);\n\t\t\t\t\t\tlenfilt[1] = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(rdlens[0] < 2) {\n\t\t\t\t\t\tif(!gQuiet) printLenSkipMsg(*ps, paired, true);\n\t\t\t\t\t\tlenfilt[0] = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(rdlens[1] < 2 && paired) {\n\t\t\t\t\t\tif(!gQuiet) printLenSkipMsg(*ps, paired, false);\n\t\t\t\t\t\tlenfilt[1] = false;\n\t\t\t\t\t}\n\t\t\t\t\tqcfilt[0] = qcfilt[1] = true;\n\t\t\t\t\tif(qcFilter) {\n\t\t\t\t\t\tqcfilt[0] = (ps->read_a().filter != '0');\n\t\t\t\t\t\tqcfilt[1] = (ps->read_b().filter != '0');\n\t\t\t\t\t}\n\t\t\t\t\tfilt[0] = (nfilt[0] && scfilt[0] && lenfilt[0] && qcfilt[0]);\n\t\t\t\t\tfilt[1] = (nfilt[1] && scfilt[1] && lenfilt[1] && qcfilt[1]);\n\t\t\t\t\tprm.nFilt += (filt[0] ? 0 : 1) + (filt[1] ? 0 : 1);\n\t\t\t\t\tRead* rds[2] = { &ps->read_a(), &ps->read_b() };\n\t\t\t\t\t// For each mate...\n\t\t\t\t\tassert(msinkwrap.empty());\n\t\t\t\t\tsd.nextRead(paired, rdrows[0], rdrows[1]); // SwDriver\n\t\t\t\t\tsize_t minedfw[2] = { 0, 0 };\n\t\t\t\t\tsize_t minedrc[2] = { 0, 0 };\n\t\t\t\t\t// Calcualte nofw / no rc\n\t\t\t\t\tbool nofw[2] = { false, false };\n\t\t\t\t\tbool norc[2] = { false, false };\n\t\t\t\t\tnofw[0] = paired ? (gMate1fw ? gNofw : gNorc) : gNofw;\n\t\t\t\t\tnorc[0] = paired ? (gMate1fw ? gNorc : gNofw) : gNorc;\n\t\t\t\t\tnofw[1] = paired ? (gMate2fw ? gNofw : gNorc) : gNofw;\n\t\t\t\t\tnorc[1] = paired ? (gMate2fw ? gNorc : gNofw) : gNorc;\n\t\t\t\t\t// Calculate nceil\n\t\t\t\t\tint nceil[2] = { 0, 0 };\n\t\t\t\t\tnceil[0] = nCeil.f<int>((double)rdlens[0]);\n\t\t\t\t\tnceil[0] = min(nceil[0], (int)rdlens[0]);\n\t\t\t\t\tif(paired) {\n\t\t\t\t\t\tnceil[1] = nCeil.f<int>((double)rdlens[1]);\n\t\t\t\t\t\tnceil[1] = min(nceil[1], (int)rdlens[1]);\n\t\t\t\t\t}\n\t\t\t\t\texhaustive[0] = exhaustive[1] = false;\n\t\t\t\t\tsize_t matemap[2] = { 0, 1 };\n\t\t\t\t\tbool pairPostFilt = filt[0] && filt[1];\n\t\t\t\t\tif(pairPostFilt) {\n\t\t\t\t\t\trnd.init(ps->read_a().seed ^ ps->read_b().seed);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trnd.init(ps->read_a().seed);\n\t\t\t\t\t}\n\t\t\t\t\t// Calculate interval length for both mates\n\t\t\t\t\tint interval[2] = { 0, 0 };\n\t\t\t\t\tfor(size_t mate = 0; mate < (paired ? 2:1); mate++) {\n\t\t\t\t\t\tinterval[mate] = msIval.f<int>((double)rdlens[mate]);\n\t\t\t\t\t\tif(filt[0] && filt[1]) {\n\t\t\t\t\t\t\t// Boost interval length by 20% for paired-end reads\n\t\t\t\t\t\t\tinterval[mate] = (int)(interval[mate] * 1.2 + 0.5);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinterval[mate] = max(interval[mate], 1);\n\t\t\t\t\t}\n\t\t\t\t\t// Calculate streak length\n\t\t\t\t\tsize_t streak[2]    = { maxDpStreak,   maxDpStreak };\n\t\t\t\t\tsize_t mtStreak[2]  = { maxMateStreak, maxMateStreak };\n\t\t\t\t\tsize_t mxDp[2]      = { maxDp,         maxDp       };\n\t\t\t\t\tsize_t mxUg[2]      = { maxUg,         maxUg       };\n\t\t\t\t\tsize_t mxIter[2]    = { maxIters,      maxIters    };\n\t\t\t\t\tif(allHits) {\n\t\t\t\t\t\tstreak[0]   = streak[1]   = std::numeric_limits<size_t>::max();\n\t\t\t\t\t\tmtStreak[0] = mtStreak[1] = std::numeric_limits<size_t>::max();\n\t\t\t\t\t\tmxDp[0]     = mxDp[1]     = std::numeric_limits<size_t>::max();\n\t\t\t\t\t\tmxUg[0]     = mxUg[1]     = std::numeric_limits<size_t>::max();\n\t\t\t\t\t\tmxIter[0]   = mxIter[1]   = std::numeric_limits<size_t>::max();\n\t\t\t\t\t} else if(khits > 1) {\n\t\t\t\t\t\tfor(size_t mate = 0; mate < 2; mate++) {\n\t\t\t\t\t\t\tstreak[mate]   += (khits-1) * maxStreakIncr;\n\t\t\t\t\t\t\tmtStreak[mate] += (khits-1) * maxStreakIncr;\n\t\t\t\t\t\t\tmxDp[mate]     += (khits-1) * maxItersIncr;\n\t\t\t\t\t\t\tmxUg[mate]     += (khits-1) * maxItersIncr;\n\t\t\t\t\t\t\tmxIter[mate]   += (khits-1) * maxItersIncr;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(filt[0] && filt[1]) {\n\t\t\t\t\t\tstreak[0] = (size_t)ceil((double)streak[0] / 2.0);\n\t\t\t\t\t\tstreak[1] = (size_t)ceil((double)streak[1] / 2.0);\n\t\t\t\t\t\tassert_gt(streak[1], 0);\n\t\t\t\t\t}\n\t\t\t\t\tprm.maxDPFails = streak[0];\n\t\t\t\t\tassert_gt(streak[0], 0);\n\t\t\t\t\t// Calculate # seed rounds for each mate\n\t\t\t\t\tsize_t nrounds[2] = { nSeedRounds, nSeedRounds };\n\t\t\t\t\tif(filt[0] && filt[1]) {\n\t\t\t\t\t\tnrounds[0] = (size_t)ceil((double)nrounds[0] / 2.0);\n\t\t\t\t\t\tnrounds[1] = (size_t)ceil((double)nrounds[1] / 2.0);\n\t\t\t\t\t\tassert_gt(nrounds[1], 0);\n\t\t\t\t\t}\n\t\t\t\t\tassert_gt(nrounds[0], 0);\n\t\t\t\t\t// Increment counters according to what got filtered\n\t\t\t\t\tfor(size_t mate = 0; mate < (paired ? 2:1); mate++) {\n\t\t\t\t\t\tif(!filt[mate]) {\n\t\t\t\t\t\t\t// Mate was rejected by N filter\n\t\t\t\t\t\t\tolm.freads++;               // reads filtered out\n\t\t\t\t\t\t\tolm.fbases += rdlens[mate]; // bases filtered out\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tshs[mate].clear();\n\t\t\t\t\t\t\tshs[mate].nextRead(mate == 0 ? ps->read_a() : ps->read_b());\n\t\t\t\t\t\t\tassert(shs[mate].empty());\n\t\t\t\t\t\t\tolm.ureads++;               // reads passing filter\n\t\t\t\t\t\t\tolm.ubases += rdlens[mate]; // bases passing filter\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsize_t eePeEeltLimit = std::numeric_limits<size_t>::max();\n\t\t\t\t\t// Whether we're done with mate1 / mate2\n\t\t\t\t\tbool done[2] = { !filt[0], !filt[1] };\n\t\t\t\t\tsize_t nelt[2] = {0, 0};\n\n\t\t\t\t\t// Find end-to-end exact alignments for each read\n\t\t\t\t\tif(doExactUpFront) {\n\t\t\t\t\t\tfor(size_t matei = 0; matei < (paired ? 2:1); matei++) {\n\t\t\t\t\t\t\tsize_t mate = matemap[matei];\n\t\t\t\t\t\t\tif(!filt[mate] || done[mate] || msinkwrap.state().doneWithMate(mate == 0)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tswmSeed.exatts++;\n\t\t\t\t\t\t\tnelt[mate] = al.exactSweep(\n\t\t\t\t\t\t\t\tebwtFw,        // index\n\t\t\t\t\t\t\t\t*rds[mate],    // read\n\t\t\t\t\t\t\t\tsc,            // scoring scheme\n\t\t\t\t\t\t\t\tnofw[mate],    // nofw?\n\t\t\t\t\t\t\t\tnorc[mate],    // norc?\n\t\t\t\t\t\t\t\t2,             // max # edits we care about\n\t\t\t\t\t\t\t\tminedfw[mate], // minimum # edits for fw mate\n\t\t\t\t\t\t\t\tminedrc[mate], // minimum # edits for rc mate\n\t\t\t\t\t\t\t\ttrue,          // report 0mm hits\n\t\t\t\t\t\t\t\tshs[mate],     // put end-to-end results here\n\t\t\t\t\t\t\t\tsdm);          // metrics\n\t\t\t\t\t\t\tsize_t bestmin = min(minedfw[mate], minedrc[mate]);\n\t\t\t\t\t\t\tif(bestmin == 0) {\n\t\t\t\t\t\t\t\tsdm.bestmin0++;\n\t\t\t\t\t\t\t} else if(bestmin == 1) {\n\t\t\t\t\t\t\t\tsdm.bestmin1++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tassert_eq(2, bestmin);\n\t\t\t\t\t\t\t\tsdm.bestmin2++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatemap[0] = 0; matemap[1] = 1;\n\t\t\t\t\t\tif(nelt[0] > 0 && nelt[1] > 0 && nelt[0] > nelt[1]) {\n\t\t\t\t\t\t\t// Do the mate with fewer exact hits first\n\t\t\t\t\t\t\t// TODO: Consider mates & orientations separately?\n\t\t\t\t\t\t\tmatemap[0] = 1; matemap[1] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(size_t matei = 0; matei < (seedSumm ? 0:2); matei++) {\n\t\t\t\t\t\t\tsize_t mate = matemap[matei];\n\t\t\t\t\t\t\tif(nelt[mate] == 0 || nelt[mate] > eePeEeltLimit) {\n\t\t\t\t\t\t\t\tshs[mate].clearExactE2eHits();\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(msinkwrap.state().doneWithMate(mate == 0)) {\n\t\t\t\t\t\t\t\tshs[mate].clearExactE2eHits();\n\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tassert(filt[mate]);\n\t\t\t\t\t\t\tassert(matei == 0 || paired);\n\t\t\t\t\t\t\tassert(!msinkwrap.maxed());\n\t\t\t\t\t\t\tassert(msinkwrap.repOk());\n\t\t\t\t\t\t\tint ret = 0;\n\t\t\t\t\t\t\tif(paired) {\n\t\t\t\t\t\t\t\t// Paired-end dynamic programming driver\n\t\t\t\t\t\t\t\tret = sd.extendSeedsPaired(\n\t\t\t\t\t\t\t\t\t*rds[mate],     // mate to align as anchor\n\t\t\t\t\t\t\t\t\t*rds[mate ^ 1], // mate to align as opp.\n\t\t\t\t\t\t\t\t\tmate == 0,      // anchor is mate 1?\n\t\t\t\t\t\t\t\t\t!filt[mate ^ 1],// opposite mate filtered out?\n\t\t\t\t\t\t\t\t\tshs[mate],      // seed hits for anchor\n\t\t\t\t\t\t\t\t\tebwtFw,         // bowtie index\n\t\t\t\t\t\t\t\t\tebwtBw,         // rev bowtie index\n\t\t\t\t\t\t\t\t\tref,            // packed reference strings\n\t\t\t\t\t\t\t\t\tsw,             // dyn prog aligner, anchor\n\t\t\t\t\t\t\t\t\tosw,            // dyn prog aligner, opposite\n\t\t\t\t\t\t\t\t\tsc,             // scoring scheme\n\t\t\t\t\t\t\t\t\tpepol,          // paired-end policy\n\t\t\t\t\t\t\t\t\t-1,             // # mms allowed in a seed\n\t\t\t\t\t\t\t\t\t0,              // length of a seed\n\t\t\t\t\t\t\t\t\t0,              // interval between seeds\n\t\t\t\t\t\t\t\t\tminsc[mate],    // min score for anchor\n\t\t\t\t\t\t\t\t\tminsc[mate^1],  // min score for opp.\n\t\t\t\t\t\t\t\t\tnceil[mate],    // N ceil for anchor\n\t\t\t\t\t\t\t\t\tnceil[mate^1],  // N ceil for opp.\n\t\t\t\t\t\t\t\t\tnofw[mate],     // don't align forward read\n\t\t\t\t\t\t\t\t\tnorc[mate],     // don't align revcomp read\n\t\t\t\t\t\t\t\t\tmaxhalf,        // max width on one DP side\n\t\t\t\t\t\t\t\t\tdoUngapped,     // do ungapped alignment\n\t\t\t\t\t\t\t\t\tmxIter[mate],   // max extend loop iters\n\t\t\t\t\t\t\t\t\tmxUg[mate],     // max # ungapped extends\n\t\t\t\t\t\t\t\t\tmxDp[mate],     // max # DPs\n\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many end-to-end fails\n\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many ungap fails\n\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many dp fails\n\t\t\t\t\t\t\t\t\tmtStreak[mate], // max mate fails per seed range\n\t\t\t\t\t\t\t\t\tdoExtend,       // extend seed hits\n\t\t\t\t\t\t\t\t\tenable8,        // use 8-bit SSE where possible\n\t\t\t\t\t\t\t\t\tcminlen,        // checkpoint if read is longer\n\t\t\t\t\t\t\t\t\tcpow2,          // checkpointer interval, log2\n\t\t\t\t\t\t\t\t\tdoTri,          // triangular mini-fills?\n\t\t\t\t\t\t\t\t\ttighten,        // -M score tightening mode\n\t\t\t\t\t\t\t\t\tca,             // seed alignment cache\n\t\t\t\t\t\t\t\t\trnd,            // pseudo-random source\n\t\t\t\t\t\t\t\t\twlm,            // group walk left metrics\n\t\t\t\t\t\t\t\t\tswmSeed,        // DP metrics, seed extend\n\t\t\t\t\t\t\t\t\tswmMate,        // DP metrics, mate finding\n\t\t\t\t\t\t\t\t\tprm,            // per-read metrics\n\t\t\t\t\t\t\t\t\t&msinkwrap,     // for organizing hits\n\t\t\t\t\t\t\t\t\ttrue,           // seek mate immediately\n\t\t\t\t\t\t\t\t\ttrue,           // report hits once found\n\t\t\t\t\t\t\t\t\tgReportDiscordant,// look for discordant alns?\n\t\t\t\t\t\t\t\t\tgReportMixed,   // look for unpaired alns?\n\t\t\t\t\t\t\t\t\texhaustive[mate]);\n\t\t\t\t\t\t\t\t// Might be done, but just with this mate\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Unpaired dynamic programming driver\n\t\t\t\t\t\t\t\tret = sd.extendSeeds(\n\t\t\t\t\t\t\t\t\t*rds[mate],     // read\n\t\t\t\t\t\t\t\t\tmate == 0,      // mate #1?\n\t\t\t\t\t\t\t\t\tshs[mate],      // seed hits\n\t\t\t\t\t\t\t\t\tebwtFw,         // bowtie index\n\t\t\t\t\t\t\t\t\tebwtBw,         // rev bowtie index\n\t\t\t\t\t\t\t\t\tref,            // packed reference strings\n\t\t\t\t\t\t\t\t\tsw,             // dynamic prog aligner\n\t\t\t\t\t\t\t\t\tsc,             // scoring scheme\n\t\t\t\t\t\t\t\t\t-1,             // # mms allowed in a seed\n\t\t\t\t\t\t\t\t\t0,              // length of a seed\n\t\t\t\t\t\t\t\t\t0,              // interval between seeds\n\t\t\t\t\t\t\t\t\tminsc[mate],    // minimum score for valid\n\t\t\t\t\t\t\t\t\tnceil[mate],    // N ceil for anchor\n\t\t\t\t\t\t\t\t\tmaxhalf,        // max width on one DP side\n\t\t\t\t\t\t\t\t\tdoUngapped,     // do ungapped alignment\n\t\t\t\t\t\t\t\t\tmxIter[mate],   // max extend loop iters\n\t\t\t\t\t\t\t\t\tmxUg[mate],     // max # ungapped extends\n\t\t\t\t\t\t\t\t\tmxDp[mate],     // max # DPs\n\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many end-to-end fails\n\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many ungap fails\n\t\t\t\t\t\t\t\t\tdoExtend,       // extend seed hits\n\t\t\t\t\t\t\t\t\tenable8,        // use 8-bit SSE where possible\n\t\t\t\t\t\t\t\t\tcminlen,        // checkpoint if read is longer\n\t\t\t\t\t\t\t\t\tcpow2,          // checkpointer interval, log2\n\t\t\t\t\t\t\t\t\tdoTri,          // triangular mini-fills\n\t\t\t\t\t\t\t\t\ttighten,        // -M score tightening mode\n\t\t\t\t\t\t\t\t\tca,             // seed alignment cache\n\t\t\t\t\t\t\t\t\trnd,            // pseudo-random source\n\t\t\t\t\t\t\t\t\twlm,            // group walk left metrics\n\t\t\t\t\t\t\t\t\tswmSeed,        // DP metrics, seed extend\n\t\t\t\t\t\t\t\t\tprm,            // per-read metrics\n\t\t\t\t\t\t\t\t\t&msinkwrap,     // for organizing hits\n\t\t\t\t\t\t\t\t\ttrue,           // report hits once found\n\t\t\t\t\t\t\t\t\texhaustive[mate]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tassert_gt(ret, 0);\n\t\t\t\t\t\t\tMERGE_SW(sw);\n\t\t\t\t\t\t\tMERGE_SW(osw);\n\t\t\t\t\t\t\t// Clear out the exact hits so that we don't try to\n\t\t\t\t\t\t\t// extend them again later!\n\t\t\t\t\t\t\tshs[mate].clearExactE2eHits();\n\t\t\t\t\t\t\tif(ret == EXTEND_EXHAUSTED_CANDIDATES) {\n\t\t\t\t\t\t\t\t// Not done yet\n\t\t\t\t\t\t\t} else if(ret == EXTEND_POLICY_FULFILLED) {\n\t\t\t\t\t\t\t\t// Policy is satisfied for this mate at least\n\t\t\t\t\t\t\t\tif(msinkwrap.state().doneWithMate(mate == 0)) {\n\t\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(msinkwrap.state().doneWithMate(mate == 1)) {\n\t\t\t\t\t\t\t\t\tdone[mate^1] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if(ret == EXTEND_PERFECT_SCORE) {\n\t\t\t\t\t\t\t\t// We exhausted this mode at least\n\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t} else if(ret == EXTEND_EXCEEDED_HARD_LIMIT) {\n\t\t\t\t\t\t\t\t// We exceeded a per-read limit\n\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t} else if(ret == EXTEND_EXCEEDED_SOFT_LIMIT) {\n\t\t\t\t\t\t\t\t// Not done yet\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tcerr << \"Bad return value: \" << ret << endl;\n\t\t\t\t\t\t\t\tthrow 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!done[mate]) {\n\t\t\t\t\t\t\t\tTAlScore perfectScore = sc.perfectScore(rdlens[mate]);\n\t\t\t\t\t\t\t\tif(!done[mate] && minsc[mate] == perfectScore) {\n\t\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// 1-mismatch\n\t\t\t\t\tif(do1mmUpFront && !seedSumm) {\n\t\t\t\t\t\tfor(size_t matei = 0; matei < (paired ? 2:1); matei++) {\n\t\t\t\t\t\t\tsize_t mate = matemap[matei];\n\t\t\t\t\t\t\tif(!filt[mate] || done[mate] || nelt[mate] > eePeEeltLimit) {\n\t\t\t\t\t\t\t\t// Done with this mate\n\t\t\t\t\t\t\t\tshs[mate].clear1mmE2eHits();\n\t\t\t\t\t\t\t\tnelt[mate] = 0;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnelt[mate] = 0;\n\t\t\t\t\t\t\tassert(!msinkwrap.maxed());\n\t\t\t\t\t\t\tassert(msinkwrap.repOk());\n\t\t\t\t\t\t\t//rnd.init(ROTL(rds[mate]->seed, 10));\n\t\t\t\t\t\t\tassert(shs[mate].empty());\n\t\t\t\t\t\t\tassert(shs[mate].repOk(&ca.current()));\n\t\t\t\t\t\t\tbool yfw = minedfw[mate] <= 1 && !nofw[mate];\n\t\t\t\t\t\t\tbool yrc = minedrc[mate] <= 1 && !norc[mate];\n\t\t\t\t\t\t\tif(yfw || yrc) {\n\t\t\t\t\t\t\t\t// Clear out the exact hits\n\t\t\t\t\t\t\t\tswmSeed.mm1atts++;\n\t\t\t\t\t\t\t\tal.oneMmSearch(\n\t\t\t\t\t\t\t\t\t&ebwtFw,        // BWT index\n\t\t\t\t\t\t\t\t\tebwtBw,         // BWT' index\n\t\t\t\t\t\t\t\t\t*rds[mate],     // read\n\t\t\t\t\t\t\t\t\tsc,             // scoring scheme\n\t\t\t\t\t\t\t\t\tminsc[mate],    // minimum score\n\t\t\t\t\t\t\t\t\t!yfw,           // don't align forward read\n\t\t\t\t\t\t\t\t\t!yrc,           // don't align revcomp read\n\t\t\t\t\t\t\t\t\tlocalAlign,     // must be legal local alns?\n\t\t\t\t\t\t\t\t\tfalse,          // do exact match\n\t\t\t\t\t\t\t\t\ttrue,           // do 1mm\n\t\t\t\t\t\t\t\t\tshs[mate],      // seed hits (hits installed here)\n\t\t\t\t\t\t\t\t\tsdm);           // metrics\n\t\t\t\t\t\t\t\tnelt[mate] = shs[mate].num1mmE2eHits();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Possibly reorder the mates\n\t\t\t\t\t\tmatemap[0] = 0; matemap[1] = 1;\n\t\t\t\t\t\tif(nelt[0] > 0 && nelt[1] > 0 && nelt[0] > nelt[1]) {\n\t\t\t\t\t\t\t// Do the mate with fewer exact hits first\n\t\t\t\t\t\t\t// TODO: Consider mates & orientations separately?\n\t\t\t\t\t\t\tmatemap[0] = 1; matemap[1] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(size_t matei = 0; matei < (seedSumm ? 0:2); matei++) {\n\t\t\t\t\t\t\tsize_t mate = matemap[matei];\n\t\t\t\t\t\t\tif(nelt[mate] == 0 || nelt[mate] > eePeEeltLimit) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(msinkwrap.state().doneWithMate(mate == 0)) {\n\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint ret = 0;\n\t\t\t\t\t\t\tif(paired) {\n\t\t\t\t\t\t\t\t// Paired-end dynamic programming driver\n\t\t\t\t\t\t\t\tret = sd.extendSeedsPaired(\n\t\t\t\t\t\t\t\t\t*rds[mate],     // mate to align as anchor\n\t\t\t\t\t\t\t\t\t*rds[mate ^ 1], // mate to align as opp.\n\t\t\t\t\t\t\t\t\tmate == 0,      // anchor is mate 1?\n\t\t\t\t\t\t\t\t\t!filt[mate ^ 1],// opposite mate filtered out?\n\t\t\t\t\t\t\t\t\tshs[mate],      // seed hits for anchor\n\t\t\t\t\t\t\t\t\tebwtFw,         // bowtie index\n\t\t\t\t\t\t\t\t\tebwtBw,         // rev bowtie index\n\t\t\t\t\t\t\t\t\tref,            // packed reference strings\n\t\t\t\t\t\t\t\t\tsw,             // dyn prog aligner, anchor\n\t\t\t\t\t\t\t\t\tosw,            // dyn prog aligner, opposite\n\t\t\t\t\t\t\t\t\tsc,             // scoring scheme\n\t\t\t\t\t\t\t\t\tpepol,          // paired-end policy\n\t\t\t\t\t\t\t\t\t-1,             // # mms allowed in a seed\n\t\t\t\t\t\t\t\t\t0,              // length of a seed\n\t\t\t\t\t\t\t\t\t0,              // interval between seeds\n\t\t\t\t\t\t\t\t\tminsc[mate],    // min score for anchor\n\t\t\t\t\t\t\t\t\tminsc[mate^1],  // min score for opp.\n\t\t\t\t\t\t\t\t\tnceil[mate],    // N ceil for anchor\n\t\t\t\t\t\t\t\t\tnceil[mate^1],  // N ceil for opp.\n\t\t\t\t\t\t\t\t\tnofw[mate],     // don't align forward read\n\t\t\t\t\t\t\t\t\tnorc[mate],     // don't align revcomp read\n\t\t\t\t\t\t\t\t\tmaxhalf,        // max width on one DP side\n\t\t\t\t\t\t\t\t\tdoUngapped,     // do ungapped alignment\n\t\t\t\t\t\t\t\t\tmxIter[mate],   // max extend loop iters\n\t\t\t\t\t\t\t\t\tmxUg[mate],     // max # ungapped extends\n\t\t\t\t\t\t\t\t\tmxDp[mate],     // max # DPs\n\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many end-to-end fails\n\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many ungap fails\n\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many dp fails\n\t\t\t\t\t\t\t\t\tmtStreak[mate], // max mate fails per seed range\n\t\t\t\t\t\t\t\t\tdoExtend,       // extend seed hits\n\t\t\t\t\t\t\t\t\tenable8,        // use 8-bit SSE where possible\n\t\t\t\t\t\t\t\t\tcminlen,        // checkpoint if read is longer\n\t\t\t\t\t\t\t\t\tcpow2,          // checkpointer interval, log2\n\t\t\t\t\t\t\t\t\tdoTri,          // triangular mini-fills?\n\t\t\t\t\t\t\t\t\ttighten,        // -M score tightening mode\n\t\t\t\t\t\t\t\t\tca,             // seed alignment cache\n\t\t\t\t\t\t\t\t\trnd,            // pseudo-random source\n\t\t\t\t\t\t\t\t\twlm,            // group walk left metrics\n\t\t\t\t\t\t\t\t\tswmSeed,        // DP metrics, seed extend\n\t\t\t\t\t\t\t\t\tswmMate,        // DP metrics, mate finding\n\t\t\t\t\t\t\t\t\tprm,            // per-read metrics\n\t\t\t\t\t\t\t\t\t&msinkwrap,     // for organizing hits\n\t\t\t\t\t\t\t\t\ttrue,           // seek mate immediately\n\t\t\t\t\t\t\t\t\ttrue,           // report hits once found\n\t\t\t\t\t\t\t\t\tgReportDiscordant,// look for discordant alns?\n\t\t\t\t\t\t\t\t\tgReportMixed,   // look for unpaired alns?\n\t\t\t\t\t\t\t\t\texhaustive[mate]);\n\t\t\t\t\t\t\t\t// Might be done, but just with this mate\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Unpaired dynamic programming driver\n\t\t\t\t\t\t\t\tret = sd.extendSeeds(\n\t\t\t\t\t\t\t\t\t*rds[mate],     // read\n\t\t\t\t\t\t\t\t\tmate == 0,      // mate #1?\n\t\t\t\t\t\t\t\t\tshs[mate],      // seed hits\n\t\t\t\t\t\t\t\t\tebwtFw,         // bowtie index\n\t\t\t\t\t\t\t\t\tebwtBw,         // rev bowtie index\n\t\t\t\t\t\t\t\t\tref,            // packed reference strings\n\t\t\t\t\t\t\t\t\tsw,             // dynamic prog aligner\n\t\t\t\t\t\t\t\t\tsc,             // scoring scheme\n\t\t\t\t\t\t\t\t\t-1,             // # mms allowed in a seed\n\t\t\t\t\t\t\t\t\t0,              // length of a seed\n\t\t\t\t\t\t\t\t\t0,              // interval between seeds\n\t\t\t\t\t\t\t\t\tminsc[mate],    // minimum score for valid\n\t\t\t\t\t\t\t\t\tnceil[mate],    // N ceil for anchor\n\t\t\t\t\t\t\t\t\tmaxhalf,        // max width on one DP side\n\t\t\t\t\t\t\t\t\tdoUngapped,     // do ungapped alignment\n\t\t\t\t\t\t\t\t\tmxIter[mate],   // max extend loop iters\n\t\t\t\t\t\t\t\t\tmxUg[mate],     // max # ungapped extends\n\t\t\t\t\t\t\t\t\tmxDp[mate],     // max # DPs\n\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many end-to-end fails\n\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many ungap fails\n\t\t\t\t\t\t\t\t\tdoExtend,       // extend seed hits\n\t\t\t\t\t\t\t\t\tenable8,        // use 8-bit SSE where possible\n\t\t\t\t\t\t\t\t\tcminlen,        // checkpoint if read is longer\n\t\t\t\t\t\t\t\t\tcpow2,          // checkpointer interval, log2\n\t\t\t\t\t\t\t\t\tdoTri,          // triangular mini-fills?\n\t\t\t\t\t\t\t\t\ttighten,        // -M score tightening mode\n\t\t\t\t\t\t\t\t\tca,             // seed alignment cache\n\t\t\t\t\t\t\t\t\trnd,            // pseudo-random source\n\t\t\t\t\t\t\t\t\twlm,            // group walk left metrics\n\t\t\t\t\t\t\t\t\tswmSeed,        // DP metrics, seed extend\n\t\t\t\t\t\t\t\t\tprm,            // per-read metrics\n\t\t\t\t\t\t\t\t\t&msinkwrap,     // for organizing hits\n\t\t\t\t\t\t\t\t\ttrue,           // report hits once found\n\t\t\t\t\t\t\t\t\texhaustive[mate]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tassert_gt(ret, 0);\n\t\t\t\t\t\t\tMERGE_SW(sw);\n\t\t\t\t\t\t\tMERGE_SW(osw);\n\t\t\t\t\t\t\t// Clear out the 1mm hits so that we don't try to\n\t\t\t\t\t\t\t// extend them again later!\n\t\t\t\t\t\t\tshs[mate].clear1mmE2eHits();\n\t\t\t\t\t\t\tif(ret == EXTEND_EXHAUSTED_CANDIDATES) {\n\t\t\t\t\t\t\t\t// Not done yet\n\t\t\t\t\t\t\t} else if(ret == EXTEND_POLICY_FULFILLED) {\n\t\t\t\t\t\t\t\t// Policy is satisfied for this mate at least\n\t\t\t\t\t\t\t\tif(msinkwrap.state().doneWithMate(mate == 0)) {\n\t\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(msinkwrap.state().doneWithMate(mate == 1)) {\n\t\t\t\t\t\t\t\t\tdone[mate^1] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if(ret == EXTEND_PERFECT_SCORE) {\n\t\t\t\t\t\t\t\t// We exhausted this mode at least\n\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t} else if(ret == EXTEND_EXCEEDED_HARD_LIMIT) {\n\t\t\t\t\t\t\t\t// We exceeded a per-read limit\n\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t} else if(ret == EXTEND_EXCEEDED_SOFT_LIMIT) {\n\t\t\t\t\t\t\t\t// Not done yet\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tcerr << \"Bad return value: \" << ret << endl;\n\t\t\t\t\t\t\t\tthrow 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!done[mate]) {\n\t\t\t\t\t\t\t\tTAlScore perfectScore = sc.perfectScore(rdlens[mate]);\n\t\t\t\t\t\t\t\tif(!done[mate] && minsc[mate] == perfectScore) {\n\t\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint seedlens[2] = { multiseedLen, multiseedLen };\n\t\t\t\t\tnrounds[0] = min<size_t>(nrounds[0], interval[0]);\n\t\t\t\t\tnrounds[1] = min<size_t>(nrounds[1], interval[1]);\n\t\t\t\t\tConstraint gc = Constraint::penaltyFuncBased(scoreMin);\n\t\t\t\t\tsize_t seedsTried = 0;\n\t\t\t\t\tsize_t seedsTriedMS[] = {0, 0, 0, 0};\n\t\t\t\t\tsize_t nUniqueSeeds = 0, nRepeatSeeds = 0, seedHitTot = 0;\n\t\t\t\t\tsize_t nUniqueSeedsMS[] = {0, 0, 0, 0};\n\t\t\t\t\tsize_t nRepeatSeedsMS[] = {0, 0, 0, 0};\n\t\t\t\t\tsize_t seedHitTotMS[] = {0, 0, 0, 0};\n\t\t\t\t\tfor(size_t roundi = 0; roundi < nSeedRounds; roundi++) {\n\t\t\t\t\t\tca.nextRead(); // Clear cache in preparation for new search\n\t\t\t\t\t\tshs[0].clearSeeds();\n\t\t\t\t\t\tshs[1].clearSeeds();\n\t\t\t\t\t\tassert(shs[0].empty());\n\t\t\t\t\t\tassert(shs[1].empty());\n\t\t\t\t\t\tassert(shs[0].repOk(&ca.current()));\n\t\t\t\t\t\tassert(shs[1].repOk(&ca.current()));\n\t\t\t\t\t\t//if(roundi > 0) {\n\t\t\t\t\t\t//\tif(seedlens[0] > 8) seedlens[0]--;\n\t\t\t\t\t\t//\tif(seedlens[1] > 8) seedlens[1]--;\n\t\t\t\t\t\t//}\n\t\t\t\t\t\tfor(size_t matei = 0; matei < (paired ? 2:1); matei++) {\n\t\t\t\t\t\t\tsize_t mate = matemap[matei];\n\t\t\t\t\t\t\tif(done[mate] || msinkwrap.state().doneWithMate(mate == 0)) {\n\t\t\t\t\t\t\t\t// Done with this mate\n\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(roundi >= nrounds[mate]) {\n\t\t\t\t\t\t\t\t// Not doing this round for this mate\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Figure out the seed offset\n\t\t\t\t\t\t\tif(interval[mate] <= (int)roundi) {\n\t\t\t\t\t\t\t\t// Can't do this round, seeds already packed as\n\t\t\t\t\t\t\t\t// tight as possible\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsize_t offset = (interval[mate] * roundi) / nrounds[mate];\n\t\t\t\t\t\t\tassert(roundi == 0 || offset > 0);\n\t\t\t\t\t\t\tassert(!msinkwrap.maxed());\n\t\t\t\t\t\t\tassert(msinkwrap.repOk());\n\t\t\t\t\t\t\t//rnd.init(ROTL(rds[mate]->seed, 10));\n\t\t\t\t\t\t\tassert(shs[mate].repOk(&ca.current()));\n\t\t\t\t\t\t\tswmSeed.sdatts++;\n\t\t\t\t\t\t\t// Set up seeds\n\t\t\t\t\t\t\tseeds[mate]->clear();\n\t\t\t\t\t\t\tSeed::mmSeeds(\n\t\t\t\t\t\t\t\tmultiseedMms,    // max # mms per seed\n\t\t\t\t\t\t\t\tseedlens[mate],  // length of a multiseed seed\n\t\t\t\t\t\t\t\t*seeds[mate],    // seeds\n\t\t\t\t\t\t\t\tgc);             // global constraint\n\t\t\t\t\t\t\t// Check whether the offset would drive the first seed\n\t\t\t\t\t\t\t// off the end\n\t\t\t\t\t\t\tif(offset > 0 && (*seeds[mate])[0].len + offset > rds[mate]->length()) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Instantiate the seeds\n\t\t\t\t\t\t\tstd::pair<int, int> instFw, instRc;\n\t\t\t\t\t\t\tstd::pair<int, int> inst = al.instantiateSeeds(\n\t\t\t\t\t\t\t\t*seeds[mate],   // search seeds\n\t\t\t\t\t\t\t\toffset,         // offset to begin extracting\n\t\t\t\t\t\t\t\tinterval[mate], // interval between seeds\n\t\t\t\t\t\t\t\t*rds[mate],     // read to align\n\t\t\t\t\t\t\t\tsc,             // scoring scheme\n\t\t\t\t\t\t\t\tnofw[mate],     // don't align forward read\n\t\t\t\t\t\t\t\tnorc[mate],     // don't align revcomp read\n\t\t\t\t\t\t\t\tca,             // holds some seed hits from previous reads\n\t\t\t\t\t\t\t\tshs[mate],      // holds all the seed hits\n\t\t\t\t\t\t\t\tsdm,            // metrics\n\t\t\t\t\t\t\t\tinstFw,\n\t\t\t\t\t\t\t\tinstRc);\n\t\t\t\t\t\t\tassert(shs[mate].repOk(&ca.current()));\n\t\t\t\t\t\t\tif(inst.first + inst.second == 0) {\n\t\t\t\t\t\t\t\t// No seed hits!  Done with this mate.\n\t\t\t\t\t\t\t\tassert(shs[mate].empty());\n\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tseedsTried += (inst.first + inst.second);\n\t\t\t\t\t\t\tseedsTriedMS[mate * 2 + 0] = instFw.first + instFw.second;\n\t\t\t\t\t\t\tseedsTriedMS[mate * 2 + 1] = instRc.first + instRc.second;\n\t\t\t\t\t\t\t// Align seeds\n\t\t\t\t\t\t\tal.searchAllSeeds(\n\t\t\t\t\t\t\t\t*seeds[mate],     // search seeds\n\t\t\t\t\t\t\t\t&ebwtFw,          // BWT index\n\t\t\t\t\t\t\t\tebwtBw,           // BWT' index\n\t\t\t\t\t\t\t\t*rds[mate],       // read\n\t\t\t\t\t\t\t\tsc,               // scoring scheme\n\t\t\t\t\t\t\t\tca,               // alignment cache\n\t\t\t\t\t\t\t\tshs[mate],        // store seed hits here\n\t\t\t\t\t\t\t\tsdm,              // metrics\n\t\t\t\t\t\t\t\tprm);             // per-read metrics\n\t\t\t\t\t\t\tassert(shs[mate].repOk(&ca.current()));\n\t\t\t\t\t\t\tif(shs[mate].empty()) {\n\t\t\t\t\t\t\t\t// No seed alignments!  Done with this mate.\n\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// shs contain what we need to know to update our seed\n\t\t\t\t\t\t// summaries for this seeding\n\t\t\t\t\t\tfor(size_t mate = 0; mate < 2; mate++) {\n\t\t\t\t\t\t\tif(!shs[mate].empty()) {\n\t\t\t\t\t\t\t\tnUniqueSeeds += shs[mate].numUniqueSeeds();\n\t\t\t\t\t\t\t\tnUniqueSeedsMS[mate * 2 + 0] += shs[mate].numUniqueSeedsStrand(true);\n\t\t\t\t\t\t\t\tnUniqueSeedsMS[mate * 2 + 1] += shs[mate].numUniqueSeedsStrand(false);\n\t\t\t\t\t\t\t\tnRepeatSeeds += shs[mate].numRepeatSeeds();\n\t\t\t\t\t\t\t\tnRepeatSeedsMS[mate * 2 + 0] += shs[mate].numRepeatSeedsStrand(true);\n\t\t\t\t\t\t\t\tnRepeatSeedsMS[mate * 2 + 1] += shs[mate].numRepeatSeedsStrand(false);\n\t\t\t\t\t\t\t\tseedHitTot += shs[mate].numElts();\n\t\t\t\t\t\t\t\tseedHitTotMS[mate * 2 + 0] += shs[mate].numEltsFw();\n\t\t\t\t\t\t\t\tseedHitTotMS[mate * 2 + 1] += shs[mate].numEltsRc();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble uniqFactor[2] = { 0.0f, 0.0f };\n\t\t\t\t\t\tfor(size_t i = 0; i < 2; i++) {\n\t\t\t\t\t\t\tif(!shs[i].empty()) {\n\t\t\t\t\t\t\t\tswmSeed.sdsucc++;\n\t\t\t\t\t\t\t\tuniqFactor[i] = shs[i].uniquenessFactor();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Possibly reorder the mates\n\t\t\t\t\t\tmatemap[0] = 0; matemap[1] = 1;\n\t\t\t\t\t\tif(!shs[0].empty() && !shs[1].empty() && uniqFactor[1] > uniqFactor[0]) {\n\t\t\t\t\t\t\t// Do the mate with fewer exact hits first\n\t\t\t\t\t\t\t// TODO: Consider mates & orientations separately?\n\t\t\t\t\t\t\tmatemap[0] = 1; matemap[1] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(size_t matei = 0; matei < (paired ? 2:1); matei++) {\n\t\t\t\t\t\t\tsize_t mate = matemap[matei];\n\t\t\t\t\t\t\tif(done[mate] || msinkwrap.state().doneWithMate(mate == 0)) {\n\t\t\t\t\t\t\t\t// Done with this mate\n\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tassert(!msinkwrap.maxed());\n\t\t\t\t\t\t\tassert(msinkwrap.repOk());\n\t\t\t\t\t\t\t//rnd.init(ROTL(rds[mate]->seed, 10));\n\t\t\t\t\t\t\tassert(shs[mate].repOk(&ca.current()));\n\t\t\t\t\t\t\tif(!seedSumm) {\n\t\t\t\t\t\t\t\t// If there aren't any seed hits...\n\t\t\t\t\t\t\t\tif(shs[mate].empty()) {\n\t\t\t\t\t\t\t\t\tcontinue; // on to the next mate\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Sort seed hits into ranks\n\t\t\t\t\t\t\t\tshs[mate].rankSeedHits(rnd, msinkwrap.allHits());\n\t\t\t\t\t\t\t\tint ret = 0;\n\t\t\t\t\t\t\t\tif(paired) {\n\t\t\t\t\t\t\t\t\t// Paired-end dynamic programming driver\n\t\t\t\t\t\t\t\t\tret = sd.extendSeedsPaired(\n\t\t\t\t\t\t\t\t\t\t*rds[mate],     // mate to align as anchor\n\t\t\t\t\t\t\t\t\t\t*rds[mate ^ 1], // mate to align as opp.\n\t\t\t\t\t\t\t\t\t\tmate == 0,      // anchor is mate 1?\n\t\t\t\t\t\t\t\t\t\t!filt[mate ^ 1],// opposite mate filtered out?\n\t\t\t\t\t\t\t\t\t\tshs[mate],      // seed hits for anchor\n\t\t\t\t\t\t\t\t\t\tebwtFw,         // bowtie index\n\t\t\t\t\t\t\t\t\t\tebwtBw,         // rev bowtie index\n\t\t\t\t\t\t\t\t\t\tref,            // packed reference strings\n\t\t\t\t\t\t\t\t\t\tsw,             // dyn prog aligner, anchor\n\t\t\t\t\t\t\t\t\t\tosw,            // dyn prog aligner, opposite\n\t\t\t\t\t\t\t\t\t\tsc,             // scoring scheme\n\t\t\t\t\t\t\t\t\t\tpepol,          // paired-end policy\n\t\t\t\t\t\t\t\t\t\tmultiseedMms,   // # mms allowed in a seed\n\t\t\t\t\t\t\t\t\t\tseedlens[mate], // length of a seed\n\t\t\t\t\t\t\t\t\t\tinterval[mate], // interval between seeds\n\t\t\t\t\t\t\t\t\t\tminsc[mate],    // min score for anchor\n\t\t\t\t\t\t\t\t\t\tminsc[mate^1],  // min score for opp.\n\t\t\t\t\t\t\t\t\t\tnceil[mate],    // N ceil for anchor\n\t\t\t\t\t\t\t\t\t\tnceil[mate^1],  // N ceil for opp.\n\t\t\t\t\t\t\t\t\t\tnofw[mate],     // don't align forward read\n\t\t\t\t\t\t\t\t\t\tnorc[mate],     // don't align revcomp read\n\t\t\t\t\t\t\t\t\t\tmaxhalf,        // max width on one DP side\n\t\t\t\t\t\t\t\t\t\tdoUngapped,     // do ungapped alignment\n\t\t\t\t\t\t\t\t\t\tmxIter[mate],   // max extend loop iters\n\t\t\t\t\t\t\t\t\t\tmxUg[mate],     // max # ungapped extends\n\t\t\t\t\t\t\t\t\t\tmxDp[mate],     // max # DPs\n\t\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many end-to-end fails\n\t\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many ungap fails\n\t\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many dp fails\n\t\t\t\t\t\t\t\t\t\tmtStreak[mate], // max mate fails per seed range\n\t\t\t\t\t\t\t\t\t\tdoExtend,       // extend seed hits\n\t\t\t\t\t\t\t\t\t\tenable8,        // use 8-bit SSE where possible\n\t\t\t\t\t\t\t\t\t\tcminlen,        // checkpoint if read is longer\n\t\t\t\t\t\t\t\t\t\tcpow2,          // checkpointer interval, log2\n\t\t\t\t\t\t\t\t\t\tdoTri,          // triangular mini-fills?\n\t\t\t\t\t\t\t\t\t\ttighten,        // -M score tightening mode\n\t\t\t\t\t\t\t\t\t\tca,             // seed alignment cache\n\t\t\t\t\t\t\t\t\t\trnd,            // pseudo-random source\n\t\t\t\t\t\t\t\t\t\twlm,            // group walk left metrics\n\t\t\t\t\t\t\t\t\t\tswmSeed,        // DP metrics, seed extend\n\t\t\t\t\t\t\t\t\t\tswmMate,        // DP metrics, mate finding\n\t\t\t\t\t\t\t\t\t\tprm,            // per-read metrics\n\t\t\t\t\t\t\t\t\t\t&msinkwrap,     // for organizing hits\n\t\t\t\t\t\t\t\t\t\ttrue,           // seek mate immediately\n\t\t\t\t\t\t\t\t\t\ttrue,           // report hits once found\n\t\t\t\t\t\t\t\t\t\tgReportDiscordant,// look for discordant alns?\n\t\t\t\t\t\t\t\t\t\tgReportMixed,   // look for unpaired alns?\n\t\t\t\t\t\t\t\t\t\texhaustive[mate]);\n\t\t\t\t\t\t\t\t\t// Might be done, but just with this mate\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Unpaired dynamic programming driver\n\t\t\t\t\t\t\t\t\tret = sd.extendSeeds(\n\t\t\t\t\t\t\t\t\t\t*rds[mate],     // read\n\t\t\t\t\t\t\t\t\t\tmate == 0,      // mate #1?\n\t\t\t\t\t\t\t\t\t\tshs[mate],      // seed hits\n\t\t\t\t\t\t\t\t\t\tebwtFw,         // bowtie index\n\t\t\t\t\t\t\t\t\t\tebwtBw,         // rev bowtie index\n\t\t\t\t\t\t\t\t\t\tref,            // packed reference strings\n\t\t\t\t\t\t\t\t\t\tsw,             // dynamic prog aligner\n\t\t\t\t\t\t\t\t\t\tsc,             // scoring scheme\n\t\t\t\t\t\t\t\t\t\tmultiseedMms,   // # mms allowed in a seed\n\t\t\t\t\t\t\t\t\t\tseedlens[mate], // length of a seed\n\t\t\t\t\t\t\t\t\t\tinterval[mate], // interval between seeds\n\t\t\t\t\t\t\t\t\t\tminsc[mate],    // minimum score for valid\n\t\t\t\t\t\t\t\t\t\tnceil[mate],    // N ceil for anchor\n\t\t\t\t\t\t\t\t\t\tmaxhalf,        // max width on one DP side\n\t\t\t\t\t\t\t\t\t\tdoUngapped,     // do ungapped alignment\n\t\t\t\t\t\t\t\t\t\tmxIter[mate],   // max extend loop iters\n\t\t\t\t\t\t\t\t\t\tmxUg[mate],     // max # ungapped extends\n\t\t\t\t\t\t\t\t\t\tmxDp[mate],     // max # DPs\n\t\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many end-to-end fails\n\t\t\t\t\t\t\t\t\t\tstreak[mate],   // stop after streak of this many ungap fails\n\t\t\t\t\t\t\t\t\t\tdoExtend,       // extend seed hits\n\t\t\t\t\t\t\t\t\t\tenable8,        // use 8-bit SSE where possible\n\t\t\t\t\t\t\t\t\t\tcminlen,        // checkpoint if read is longer\n\t\t\t\t\t\t\t\t\t\tcpow2,          // checkpointer interval, log2\n\t\t\t\t\t\t\t\t\t\tdoTri,          // triangular mini-fills?\n\t\t\t\t\t\t\t\t\t\ttighten,        // -M score tightening mode\n\t\t\t\t\t\t\t\t\t\tca,             // seed alignment cache\n\t\t\t\t\t\t\t\t\t\trnd,            // pseudo-random source\n\t\t\t\t\t\t\t\t\t\twlm,            // group walk left metrics\n\t\t\t\t\t\t\t\t\t\tswmSeed,        // DP metrics, seed extend\n\t\t\t\t\t\t\t\t\t\tprm,            // per-read metrics\n\t\t\t\t\t\t\t\t\t\t&msinkwrap,     // for organizing hits\n\t\t\t\t\t\t\t\t\t\ttrue,           // report hits once found\n\t\t\t\t\t\t\t\t\t\texhaustive[mate]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tassert_gt(ret, 0);\n\t\t\t\t\t\t\t\tMERGE_SW(sw);\n\t\t\t\t\t\t\t\tMERGE_SW(osw);\n\t\t\t\t\t\t\t\tif(ret == EXTEND_EXHAUSTED_CANDIDATES) {\n\t\t\t\t\t\t\t\t\t// Not done yet\n\t\t\t\t\t\t\t\t} else if(ret == EXTEND_POLICY_FULFILLED) {\n\t\t\t\t\t\t\t\t\t// Policy is satisfied for this mate at least\n\t\t\t\t\t\t\t\t\tif(msinkwrap.state().doneWithMate(mate == 0)) {\n\t\t\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(msinkwrap.state().doneWithMate(mate == 1)) {\n\t\t\t\t\t\t\t\t\t\tdone[mate^1] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if(ret == EXTEND_PERFECT_SCORE) {\n\t\t\t\t\t\t\t\t\t// We exhausted this made at least\n\t\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t\t} else if(ret == EXTEND_EXCEEDED_HARD_LIMIT) {\n\t\t\t\t\t\t\t\t\t// We exceeded a per-read limit\n\t\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t\t} else if(ret == EXTEND_EXCEEDED_SOFT_LIMIT) {\n\t\t\t\t\t\t\t\t\t// Not done yet\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\tcerr << \"Bad return value: \" << ret << endl;\n\t\t\t\t\t\t\t\t\tthrow 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} // if(!seedSumm)\n\t\t\t\t\t\t} // for(size_t matei = 0; matei < 2; matei++)\n\n\t\t\t\t\t\t// We don't necessarily have to continue investigating both\n\t\t\t\t\t\t// mates.  We continue on a mate only if its average\n\t\t\t\t\t\t// interval length is high (> 1000)\n\t\t\t\t\t\tfor(size_t mate = 0; mate < 2; mate++) {\n\t\t\t\t\t\t\tif(!done[mate] && shs[mate].averageHitsPerSeed() < seedBoostThresh) {\n\t\t\t\t\t\t\t\tdone[mate] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} // end loop over reseeding rounds\n\t\t\t\t\tif(seedsTried > 0) {\n\t\t\t\t\t\tprm.seedPctUnique = (float)nUniqueSeeds / seedsTried;\n\t\t\t\t\t\tprm.seedPctRep = (float)nRepeatSeeds / seedsTried;\n\t\t\t\t\t\tprm.seedHitAvg = (float)seedHitTot / seedsTried;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprm.seedPctUnique = -1.0f;\n\t\t\t\t\t\tprm.seedPctRep = -1.0f;\n\t\t\t\t\t\tprm.seedHitAvg = -1.0f;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\t\tif(seedsTriedMS[i] > 0) {\n\t\t\t\t\t\t\tprm.seedPctUniqueMS[i] = (float)nUniqueSeedsMS[i] / seedsTriedMS[i];\n\t\t\t\t\t\t\tprm.seedPctRepMS[i] = (float)nRepeatSeedsMS[i] / seedsTriedMS[i];\n\t\t\t\t\t\t\tprm.seedHitAvgMS[i] = (float)seedHitTotMS[i] / seedsTriedMS[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprm.seedPctUniqueMS[i] = -1.0f;\n\t\t\t\t\t\t\tprm.seedPctRepMS[i] = -1.0f;\n\t\t\t\t\t\t\tprm.seedHitAvgMS[i] = -1.0f;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsize_t totnucs = 0;\n\t\t\t\t\tfor(size_t mate = 0; mate < (paired ? 2:1); mate++) {\n\t\t\t\t\t\tif(filt[mate]) {\n\t\t\t\t\t\t\tsize_t len = rdlens[mate];\n\t\t\t\t\t\t\tif(!nofw[mate] && !norc[mate]) {\n\t\t\t\t\t\t\t\tlen *= 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttotnucs += len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprm.seedsPerNuc = totnucs > 0 ? ((float)seedsTried / totnucs) : -1;\n\t\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\t\tprm.seedsPerNucMS[i] = totnucs > 0 ? ((float)seedsTriedMS[i] / totnucs) : -1;\n\t\t\t\t\t}\n\t\t\t\t\tfor(size_t i = 0; i < 2; i++) {\n\t\t\t\t\t\tassert_leq(prm.nExIters, mxIter[i]);\n\t\t\t\t\t\tassert_leq(prm.nExDps,   mxDp[i]);\n\t\t\t\t\t\tassert_leq(prm.nMateDps, mxDp[i]);\n\t\t\t\t\t\tassert_leq(prm.nExUgs,   mxUg[i]);\n\t\t\t\t\t\tassert_leq(prm.nMateUgs, mxUg[i]);\n\t\t\t\t\t\tassert_leq(prm.nDpFail,  streak[i]);\n\t\t\t\t\t\tassert_leq(prm.nUgFail,  streak[i]);\n\t\t\t\t\t\tassert_leq(prm.nEeFail,  streak[i]);\n\t\t\t\t\t}\n\n\t\t\t\t// Commit and report paired-end/unpaired alignments\n\t\t\t\t//uint32_t sd = rds[0]->seed ^ rds[1]->seed;\n\t\t\t\t//rnd.init(ROTL(sd, 20));\n\t\t\t\tmsinkwrap.finishRead(\n\t\t\t\t\t&shs[0],              // seed results for mate 1\n\t\t\t\t\t&shs[1],              // seed results for mate 2\n\t\t\t\t\texhaustive[0],        // exhausted seed hits for mate 1?\n\t\t\t\t\texhaustive[1],        // exhausted seed hits for mate 2?\n\t\t\t\t\tnfilt[0],\n\t\t\t\t\tnfilt[1],\n\t\t\t\t\tscfilt[0],\n\t\t\t\t\tscfilt[1],\n\t\t\t\t\tlenfilt[0],\n\t\t\t\t\tlenfilt[1],\n\t\t\t\t\tqcfilt[0],\n\t\t\t\t\tqcfilt[1],\n\t\t\t\t\trnd,                  // pseudo-random generator\n\t\t\t\t\trpm,                  // reporting metrics\n\t\t\t\t\tprm,                  // per-read metrics\n\t\t\t\t\tsc,                   // scoring scheme\n\t\t\t\t\t!seedSumm,            // suppress seed summaries?\n\t\t\t\t\tseedSumm,             // suppress alignments?\n\t\t\t\t\tscUnMapped,           // Consider soft-clipped bases unmapped when calculating TLEN\n\t\t\t\t\txeq);\n\t\t\t\tassert(!retry || msinkwrap.empty());\n\t\t\t} // while(retry)\n\t\t} // if(rdid >= skipReads && rdid < qUpto)\n\t\telse if(rdid >= qUpto) {\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\t}\n\t\tif(metricsPerRead) {\n\t\t\tMERGE_METRICS(metricsPt);\n\t\t\tnametmp = ps->read_a().name;\n\t\t\tmetricsPt.reportInterval(\n\t\t\t\tmetricsOfb, metricsStderr, true, &nametmp);\n\t\t\tmetricsPt.reset();\n\t\t}\n\t   } while (ps->nextReadPairReady()); // must read the whole cached buffer\n\t} // while(true)\n\n\t\t// One last metrics merge\n\t\tMERGE_METRICS(metrics);\n\n\t\tif(dpLog    != NULL) dpLog->close();\n\t\tif(dpLogOpp != NULL) dpLogOpp->close();\n\n#ifdef PER_THREAD_TIMING\n\t\tss.str(\"\");\n\t\tss.clear();\n\t\tss << \"thread: \" << tid << \" cpu_changeovers: \" << ncpu_changeovers << std::endl\n\t\t   << \"thread: \" << tid << \" node_changeovers: \" << nnuma_changeovers << std::endl;\n\t\tstd::cout << ss.str();\n#endif\n\t}\n\tp->done->fetch_add(1);\n\n\treturn;\n}", "idx": 595}
{"project": "bowtie2", "commit_id": "638_bowtie2_2.5.1_bt2_search.cpp_multiseedSearchWorker_2p5.cpp", "target": 1, "func": "static void multiseedSearchWorker_2p5(void *vp) {\n\t//int tid = *((int*)vp);\n\tthread_tracking_pair *p = (thread_tracking_pair*) vp;\n\tint tid = p->tid;\n\tassert(multiseed_ebwtFw != NULL);\n\tassert(multiseedMms == 0 || multiseed_ebwtBw != NULL);\n\tPatternSourceReadAheadFactory& readahead_factory =  *multiseed_readahead_factory;\n\tconst Ebwt&             ebwtFw   = *multiseed_ebwtFw;\n\tconst Ebwt&             ebwtBw   = *multiseed_ebwtBw;\n\tconst Scoring&          sc       = *multiseed_sc;\n\tconst BitPairReference& ref      = *multiseed_refs;\n\tAlnSink&                msink    = *multiseed_msink;\n\tOutFileBuf*             metricsOfb = multiseed_metricsOfb;\n\n\t// Sinks: these are so that we can print tables encoding counts for\n\t// events of interest on a per-read, per-seed, per-join, or per-SW\n\t// level.  These in turn can be used to diagnose performance\n\t// problems, or generally characterize performance.\n\n\tThreadCounter tc;\n\n\t// Instantiate an object for holding reporting-related parameters.\n\tReportingParams rp(\n\t\t(allHits ? std::numeric_limits<THitInt>::max() : khits), // -k\n\t\tmhits,             // -m/-M\n\t\t0,                 // penalty gap (not used now)\n\t\tmsample,           // true -> -M was specified, otherwise assume -m\n\t\tgReportDiscordant, // report discordang paired-end alignments?\n\t\tgReportMixed);     // report unpaired alignments for paired reads?\n\n\t// Instantiate a mapping quality calculator\n\tunique_ptr<Mapq> bmapq(new_mapq(mapqv, scoreMin, sc));\n\n\t// Make a per-thread wrapper for the global MHitSink object.\n\tAlnSinkWrap msinkwrap(\n\t\tmsink,         // global sink\n\t\trp,            // reporting parameters\n\t\t*bmapq,        // MAPQ calculator\n\t\t(size_t)tid);  // thread id\n\n\tOuterLoopMetrics olm;\n\tSeedSearchMetrics sdm;\n\tWalkMetrics wlm;\n\tSwMetrics swmSeed, swmMate;\n\tDescentMetrics descm;\n\tReportingMetrics rpm;\n\tRandomSource rnd, rndArb;\n\tSSEMetrics sseU8ExtendMet;\n\tSSEMetrics sseU8MateMet;\n\tSSEMetrics sseI16ExtendMet;\n\tSSEMetrics sseI16MateMet;\n\tuint64_t nbtfiltst = 0; // TODO: find a new home for these\n\tuint64_t nbtfiltsc = 0; // TODO: find a new home for these\n\tuint64_t nbtfiltdo = 0; // TODO: find a new home for these\n\n\tASSERT_ONLY(BTDnaString tmp);\n\n\tint pepolFlag;\n\tif(gMate1fw && gMate2fw) {\n\t\tpepolFlag = PE_POLICY_FF;\n\t} else if(gMate1fw && !gMate2fw) {\n\t\tpepolFlag = PE_POLICY_FR;\n\t} else if(!gMate1fw && gMate2fw) {\n\t\tpepolFlag = PE_POLICY_RF;\n\t} else {\n\t\tpepolFlag = PE_POLICY_RR;\n\t}\n\tassert_geq(gMaxInsert, gMinInsert);\n\tassert_geq(gMinInsert, 0);\n\tPairedEndPolicy pepol(\n\t\tpepolFlag,\n\t\tgMaxInsert,\n\t\tgMinInsert,\n\t\tlocalAlign,\n\t\tgFlippedMatesOK,\n\t\tgDovetailMatesOK,\n\t\tgContainMatesOK,\n\t\tgOlapMatesOK,\n\t\tgExpandToFrag);\n\n\tAlignerDriver ald(\n\t\tdescConsExp,         // exponent for interpolating maximum penalty\n\t\tdescPrioritizeRoots, // whether to select roots with scores and weights\n\t\tmsIval,              // interval length, as function of read length\n\t\tdescLanding,         // landing length\n\t\tgVerbose,            // verbose?\n\t\tdescentTotSz,        // limit on total bytes of best-first search data\n\t\tdescentTotFmops);    // limit on total number of FM index ops in BFS\n\n\tPerfMetrics metricsPt; // per-thread metrics object; for read-level metrics\n\tBTString nametmp;\n\n\tPerReadMetrics prm;\n\n\t// Used by thread with threadid == 1 to measure time elapsed\n\ttime_t iTime = time(0);\n\n\t// Keep track of whether last search was exhaustive for mates 1 and 2\n\tbool exhaustive[2] = { false, false };\n\t// Keep track of whether mates 1/2 were filtered out last time through\n\tbool filt[2]    = { true, true };\n\t// Keep track of whether mates 1/2 were filtered out due Ns last time\n\tbool nfilt[2]   = { true, true };\n\t// Keep track of whether mates 1/2 were filtered out due to not having\n\t// enough characters to rise about the score threshold.\n\tbool scfilt[2]  = { true, true };\n\t// Keep track of whether mates 1/2 were filtered out due to not having\n\t// more characters than the number of mismatches permitted in a seed.\n\tbool lenfilt[2] = { true, true };\n\t// Keep track of whether mates 1/2 were filtered out by upstream qc\n\tbool qcfilt[2]  = { true, true };\n\n\trndArb.init((uint32_t)time(0));\n\tint mergei = 0;\n\tint mergeival = 16;\n\twhile(true) {\n\t   PatternSourceReadAhead psrah(readahead_factory);\n\t   PatternSourcePerThread* const ps = psrah.ptr();\n\t   do {\n\t\tpair<bool, bool> ret = ps->nextReadPair();\n\t\tbool success = ret.first;\n\t\tbool done = ret.second;\n\t\tif(!success && done) {\n\t\t\tbreak;\n\t\t} else if(!success) {\n\t\t\tcontinue;\n\t\t}\n\t\tTReadId rdid = ps->read_a().rdid;\n\t\tbool sample = true;\n\t\tif(arbitraryRandom) {\n\t\t\tps->read_a().seed = rndArb.nextU32();\n\t\t\tps->read_b().seed = rndArb.nextU32();\n\t\t}\n\t\tif(sampleFrac < 1.0f) {\n\t\t\trnd.init(ROTL(ps->read_a().seed, 2));\n\t\t\tsample = rnd.nextFloat() < sampleFrac;\n\t\t}\n\t\tif(rdid >= skipReads && rdid < qUpto && sample) {\n\t\t\t//\n\t\t\t// Check if there is metrics reporting for us to do.\n\t\t\t//\n\t\t\tif(metricsIval > 0 &&\n\t\t\t   (metricsOfb != NULL || metricsStderr) &&\n\t\t\t   !metricsPerRead &&\n\t\t\t   ++mergei == mergeival)\n\t\t\t{\n\t\t\t\t// Do a periodic merge.  Update global metrics, in a\n\t\t\t\t// synchronized manner if needed.\n\t\t\t\tMERGE_METRICS(metrics);\n\t\t\t\tmergei = 0;\n\t\t\t\t// Check if a progress message should be printed\n\t\t\t\tif(tid == 0) {\n\t\t\t\t\t// Only thread 1 prints progress messages\n\t\t\t\t\ttime_t curTime = time(0);\n\t\t\t\t\tif(curTime - iTime >= metricsIval) {\n\t\t\t\t\t\tmetrics.reportInterval(metricsOfb, metricsStderr, false, NULL);\n\t\t\t\t\t\tiTime = curTime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprm.reset(); // per-read metrics\n\t\t\tprm.doFmString = sam_print_zm;\n\t\t\t// If we're reporting how long each read takes, get the initial time\n\t\t\t// measurement here\n\t\t\tif(sam_print_xt) {\n\t\t\t\tgettimeofday(&prm.tv_beg, &prm.tz_beg);\n\t\t\t}\n\t\t\t// Try to align this read\n\t\t\tolm.reads++;\n\t\t\tbool paired = !ps->read_b().empty();\n\t\t\tconst size_t rdlen1 = ps->read_a().length();\n\t\t\tconst size_t rdlen2 = paired ? ps->read_b().length() : 0;\n\t\t\tolm.bases += (rdlen1 + rdlen2);\n\t\t\t// Check if read is identical to previous read\n\t\t\trnd.init(ROTL(ps->read_a().seed, 5));\n\t\t\tmsinkwrap.nextRead(\n\t\t\t\t&ps->read_a(),\n\t\t\t\tpaired ? &ps->read_b() : NULL,\n\t\t\t\trdid,\n\t\t\t\tsc.qualitiesMatter());\n\t\t\tassert(msinkwrap.inited());\n\t\t\tsize_t rdlens[2] = { rdlen1, rdlen2 };\n\t\t\t// Calculate the minimum valid score threshold for the read\n\t\t\tTAlScore minsc[2], maxpen[2];\n\t\t\tminsc[0] = minsc[1] = std::numeric_limits<TAlScore>::max();\n\t\t\tsetupMinScores(*ps, paired, localAlign, sc, rdlens, minsc, maxpen);\n\t\t\t// N filter; does the read have too many Ns?\n\t\t\tsize_t readns[2] = {0, 0};\n\t\t\tsc.nFilterPair(\n\t\t\t\t&ps->read_a().patFw,\n\t\t\t\tpaired ? &ps->read_b().patFw : NULL,\n\t\t\t\treadns[0],\n\t\t\t\treadns[1],\n\t\t\t\tnfilt[0],\n\t\t\t\tnfilt[1]);\n\t\t\t// Score filter; does the read enough character to rise above\n\t\t\t// the score threshold?\n\t\t\tscfilt[0] = sc.scoreFilter(minsc[0], rdlens[0]);\n\t\t\tscfilt[1] = sc.scoreFilter(minsc[1], rdlens[1]);\n\t\t\tlenfilt[0] = lenfilt[1] = true;\n\t\t\tif(rdlens[0] <= (size_t)multiseedMms || rdlens[0] < 2) {\n\t\t\t\tif(!gQuiet) printMmsSkipMsg(*ps, paired, true, multiseedMms);\n\t\t\t\tlenfilt[0] = false;\n\t\t\t}\n\t\t\tif((rdlens[1] <= (size_t)multiseedMms || rdlens[1] < 2) && paired) {\n\t\t\t\tif(!gQuiet) printMmsSkipMsg(*ps, paired, false, multiseedMms);\n\t\t\t\tlenfilt[1] = false;\n\t\t\t}\n\t\t\tif(rdlens[0] < 2) {\n\t\t\t\tif(!gQuiet) printLenSkipMsg(*ps, paired, true);\n\t\t\t\tlenfilt[0] = false;\n\t\t\t}\n\t\t\tif(rdlens[1] < 2 && paired) {\n\t\t\t\tif(!gQuiet) printLenSkipMsg(*ps, paired, false);\n\t\t\t\tlenfilt[1] = false;\n\t\t\t}\n\t\t\tqcfilt[0] = qcfilt[1] = true;\n\t\t\tif(qcFilter) {\n\t\t\t\tqcfilt[0] = (ps->read_a().filter != '0');\n\t\t\t\tqcfilt[1] = (ps->read_b().filter != '0');\n\t\t\t}\n\t\t\tfilt[0] = (nfilt[0] && scfilt[0] && lenfilt[0] && qcfilt[0]);\n\t\t\tfilt[1] = (nfilt[1] && scfilt[1] && lenfilt[1] && qcfilt[1]);\n\t\t\tprm.nFilt += (filt[0] ? 0 : 1) + (filt[1] ? 0 : 1);\n\t\t\tRead* rds[2] = { &ps->read_a(), &ps->read_b() };\n\t\t\tassert(msinkwrap.empty());\n\t\t\t// Calcualte nofw / no rc\n\t\t\tbool nofw[2] = { false, false };\n\t\t\tbool norc[2] = { false, false };\n\t\t\tnofw[0] = paired ? (gMate1fw ? gNofw : gNorc) : gNofw;\n\t\t\tnorc[0] = paired ? (gMate1fw ? gNorc : gNofw) : gNorc;\n\t\t\tnofw[1] = paired ? (gMate2fw ? gNofw : gNorc) : gNofw;\n\t\t\tnorc[1] = paired ? (gMate2fw ? gNorc : gNofw) : gNorc;\n\t\t\t// Calculate nceil\n\t\t\tint nceil[2] = { 0, 0 };\n\t\t\tnceil[0] = nCeil.f<int>((double)rdlens[0]);\n\t\t\tnceil[0] = min(nceil[0], (int)rdlens[0]);\n\t\t\tif(paired) {\n\t\t\t\tnceil[1] = nCeil.f<int>((double)rdlens[1]);\n\t\t\t\tnceil[1] = min(nceil[1], (int)rdlens[1]);\n\t\t\t}\n\t\t\texhaustive[0] = exhaustive[1] = false;\n\t\t\tbool pairPostFilt = filt[0] && filt[1];\n\t\t\tif(pairPostFilt) {\n\t\t\t\trnd.init(ROTL((rds[0]->seed ^ rds[1]->seed), 10));\n\t\t\t}\n\t\t\t// Calculate streak length\n\t\t\tsize_t streak[2]    = { maxDpStreak,   maxDpStreak };\n\t\t\tsize_t mtStreak[2]  = { maxMateStreak, maxMateStreak };\n\t\t\tsize_t mxDp[2]      = { maxDp,         maxDp       };\n\t\t\tsize_t mxUg[2]      = { maxUg,         maxUg       };\n\t\t\tsize_t mxIter[2]    = { maxIters,      maxIters    };\n\t\t\tif(allHits) {\n\t\t\t\tstreak[0]   = streak[1]   = std::numeric_limits<size_t>::max();\n\t\t\t\tmtStreak[0] = mtStreak[1] = std::numeric_limits<size_t>::max();\n\t\t\t\tmxDp[0]     = mxDp[1]     = std::numeric_limits<size_t>::max();\n\t\t\t\tmxUg[0]     = mxUg[1]     = std::numeric_limits<size_t>::max();\n\t\t\t\tmxIter[0]   = mxIter[1]   = std::numeric_limits<size_t>::max();\n\t\t\t} else if(khits > 1) {\n\t\t\t\tfor(size_t mate = 0; mate < 2; mate++) {\n\t\t\t\t\tstreak[mate]   += (khits-1) * maxStreakIncr;\n\t\t\t\t\tmtStreak[mate] += (khits-1) * maxStreakIncr;\n\t\t\t\t\tmxDp[mate]     += (khits-1) * maxItersIncr;\n\t\t\t\t\tmxUg[mate]     += (khits-1) * maxItersIncr;\n\t\t\t\t\tmxIter[mate]   += (khits-1) * maxItersIncr;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If paired-end and neither mate filtered...\n\t\t\tif(filt[0] && filt[1]) {\n\t\t\t\t// Reduce streaks for either mate\n\t\t\t\tstreak[0] = (size_t)ceil((double)streak[0] / 2.0);\n\t\t\t\tstreak[1] = (size_t)ceil((double)streak[1] / 2.0);\n\t\t\t\tassert_gt(streak[1], 0);\n\t\t\t}\n\t\t\tassert_gt(streak[0], 0);\n\t\t\tprm.maxDPFails = streak[0];\n\t\t\t// Increment counters according to what got filtered\n\t\t\tfor(size_t mate = 0; mate < (paired ? 2:1); mate++) {\n\t\t\t\tif(!filt[mate]) {\n\t\t\t\t\t// Mate was rejected by N filter\n\t\t\t\t\tolm.freads++;               // reads filtered out\n\t\t\t\t\tolm.fbases += rdlens[mate]; // bases filtered out\n\t\t\t\t} else {\n\t\t\t\t\tolm.ureads++;               // reads passing filter\n\t\t\t\t\tolm.ubases += rdlens[mate]; // bases passing filter\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(filt[0]) {\n\t\t\t\tald.initRead(ps->read_a(), nofw[0], norc[0], minsc[0], maxpen[0], filt[1] ? &ps->read_b() : NULL);\n\t\t\t} else if(filt[1]) {\n\t\t\t\tald.initRead(ps->read_b(), nofw[1], norc[1], minsc[1], maxpen[1], NULL);\n\t\t\t}\n\t\t\tif(filt[0] || filt[1]) {\n\t\t\t\tald.go(sc, ebwtFw, ebwtBw, ref, descm, wlm, prm, rnd, msinkwrap);\n\t\t\t}\n\t\t\t// Commit and report paired-end/unpaired alignments\n\t\t\tuint32_t sd = rds[0]->seed ^ rds[1]->seed;\n\t\t\trnd.init(ROTL(sd, 20));\n\t\t\tmsinkwrap.finishRead(\n\t\t\t\tNULL,                 // seed results for mate 1\n\t\t\t\tNULL,                 // seed results for mate 2\n\t\t\t\texhaustive[0],        // exhausted seed results for 1?\n\t\t\t\texhaustive[1],        // exhausted seed results for 2?\n\t\t\t\tnfilt[0],\n\t\t\t\tnfilt[1],\n\t\t\t\tscfilt[0],\n\t\t\t\tscfilt[1],\n\t\t\t\tlenfilt[0],\n\t\t\t\tlenfilt[1],\n\t\t\t\tqcfilt[0],\n\t\t\t\tqcfilt[1],\n\t\t\t\trnd,                  // pseudo-random generator\n\t\t\t\trpm,                  // reporting metrics\n\t\t\t\tprm,                  // per-read metrics\n\t\t\t\tsc,                   // scoring scheme\n\t\t\t\t!seedSumm,            // suppress seed summaries?\n\t\t\t\tseedSumm,             // suppress alignments?\n\t\t\t\tscUnMapped,           // Consider soft-clipped bases unmapped when calculating TLEN\n\t\t\t\txeq);\n\t\t} // if(rdid >= skipReads && rdid < qUpto)\n\t\telse if(rdid >= qUpto) {\n\t\t\tbreak;\n\t\t}\n\t\tif(metricsPerRead) {\n\t\t\tMERGE_METRICS(metricsPt);\n\t\t\tnametmp = ps->read_a().name;\n\t\t\tmetricsPt.reportInterval(\n\t\t\t\tmetricsOfb, metricsStderr, true, &nametmp);\n\t\t\tmetricsPt.reset();\n\t\t}\n\t   } while (ps->nextReadPairReady()); // must read the whole cached buffer\n\t} // while(true)\n\n\t// One last metrics merge\n\tMERGE_METRICS(metrics);\n\tp->done->fetch_add(1);\n\n\treturn;\n}", "idx": 596}
{"project": "bowtie2", "commit_id": "639_bowtie2_2.5.1_bt2_search.cpp_multiseedSearch.cpp", "target": 1, "func": "static void multiseedSearch(\n\tScoring& sc,\n\tconst PatternParams& pp,\n\tPatternComposer& patsrc,      // pattern source\n\tAlnSink& msink,               // hit sink\n\tEbwt& ebwtFw,                 // index of original text\n\tEbwt* ebwtBw,                 // index of mirror text\n\tOutFileBuf *metricsOfb)\n{\n\tmultiseed_msink  = &msink;\n\tmultiseed_ebwtFw = &ebwtFw;\n\tmultiseed_ebwtBw = ebwtBw;\n\tmultiseed_sc     = &sc;\n\tmultiseed_metricsOfb      = metricsOfb;\n\tTimer *_t = new Timer(cerr, \"Time loading reference: \", timing);\n\tunique_ptr<BitPairReference> refs(\n\t\tnew BitPairReference(\n\t\t\tadjIdxBase,\n\t\t\tfalse,\n\t\t\tsanityCheck,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\tfalse,\n\t\t\tuseMm,\n\t\t\tuseShmem,\n\t\t\tmmSweep,\n\t\t\tgVerbose,\n\t\t\tstartVerbose)\n\t\t);\n\tdelete _t;\n\tif(!refs->loaded()) throw 1;\n\tmultiseed_refs = refs.get();\n#ifndef _WIN32\n\tsigset_t set;\n\tsigemptyset(&set);\n\tsigaddset(&set, SIGPIPE);\n\tpthread_sigmask(SIG_BLOCK, &set, NULL);\n#endif\n\tEList<int> tids;\n\tEList<std::thread*> threads(nthreads);\n\tEList<thread_tracking_pair> tps;\n\ttps.resize(std::max(nthreads, thread_ceiling));\n\tthreads.reserveExact(std::max(nthreads, thread_ceiling));\n\ttids.reserveExact(std::max(nthreads, thread_ceiling));\n\t{\n\t\t// Load the other half of the index into memory\n\t\tassert(!ebwtFw.isInMemory());\n\t\tTimer _t(cerr, \"Time loading forward index: \", timing);\n\t\tebwtFw.loadIntoMemory(\n\t\t\t0,  // colorspace?\n\t\t\t-1, // not the reverse index\n\t\t\ttrue,         // load SA samp? (yes, need forward index's SA samp)\n\t\t\ttrue,         // load ftab (in forward index)\n\t\t\ttrue,         // load rstarts (in forward index)\n\t\t\t!noRefNames,  // load names?\n\t\t\tstartVerbose);\n\t}\n\tif(multiseedMms > 0 || do1mmUpFront) {\n\t\t// Load the other half of the index into memory\n\t\tassert(!ebwtBw->isInMemory());\n\t\tTimer _t(cerr, \"Time loading mirror index: \", timing);\n\t\tebwtBw->loadIntoMemory(\n\t\t\t0, // colorspace?\n\t\t\t// It's bidirectional search, so we need the reverse to be\n\t\t\t// constructed as the reverse of the concatenated strings.\n\t\t\t1,\n\t\t\tfalse,        // don't load SA samp in reverse index\n\t\t\ttrue,         // yes, need ftab in reverse index\n\t\t\tfalse,        // don't load rstarts in reverse index\n\t\t\t!noRefNames,  // load names?\n\t\t\tstartVerbose);\n\t}\n\n\t// Important: Need at least nthreads+1 elements, more is OK\n\tPatternSourceReadAheadFactory readahead_factory(patsrc,pp,2*nthreads+1);\n\tmultiseed_readahead_factory = &readahead_factory;\n\n\t// Start the metrics thread\n\n\tstd::atomic<int> all_threads_done;\n\tall_threads_done = 0;\n\t{\n\t\tTimer _t(cerr, \"Multiseed full-index search: \", timing);\n\n#ifndef _WIN32\n\t\tint pid = 0;\n\t\tif(thread_stealing) {\n\t\t\tpid = getpid();\n\t\t\twrite_pid(thread_stealing_dir.c_str(), pid);\n\t\t\tthread_counter = 0;\n\t\t}\n#endif\n\n\t\tfor(int i = 0; i < nthreads; i++) {\n\t\t\ttids.push_back(i);\n\t\t\ttps[i].tid = i;\n\t\t\ttps[i].done = &all_threads_done;\n\n\t\t\tif(bowtie2p5) {\n\t\t\t\tthreads.push_back(new std::thread(multiseedSearchWorker_2p5, (void*)&tps[i]));\n\t\t\t} else {\n\t\t\t\tthreads.push_back(new std::thread(multiseedSearchWorker, (void*)&tps[i]));\n\t\t\t}\n\t\t\tthreads[i]->detach();\n\t\t\tSLEEP(10);\n\t\t}\n\n#ifndef _WIN32\n\t\tif(thread_stealing) {\n\t\t\tint orig_threads = nthreads;\n\t\t\tthread_monitor(pid, orig_threads, tids, threads);\n\t\t}\n#endif\n\n\t\twhile(all_threads_done < nthreads) {\n\t\t\tSLEEP(10);\n\t\t}\n\t\tfor (int i = 0; i < nthreads; ++i) {\n\t\t\tdelete threads[i];\n\t\t}\n\n#ifndef _WIN32\n\t\tif(thread_stealing) {\n\t\t\tdel_pid(thread_stealing_dir.c_str(), pid);\n\t\t}\n#endif\n\t}\n\tif(!metricsPerRead && (metricsOfb != NULL || metricsStderr)) {\n\t\tmetrics.reportInterval(metricsOfb, metricsStderr, true, NULL);\n\t}\n}", "idx": 597}
{"project": "bowtie2", "commit_id": "63_bowtie2_2.5.1_aligner_seed.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\tseedsearch =\n\t\tnrange =\n\t\tnelt =\n\t\tpossearch =\n\t\tintrahit =\n\t\tinterhit =\n\t\tfilteredseed =\n\t\tooms =\n\t\tbwops =\n\t\tbweds =\n\t\tbestmin0 =\n\t\tbestmin1 =\n\t\tbestmin2 = 0;\n\t}", "idx": 598}
{"project": "bowtie2", "commit_id": "640_bowtie2_2.5.1_bt2_search.cpp_parseOption.cpp", "target": 1, "func": "static void parseOption(int next_option, const char *arg) {\n\tswitch (next_option) {\n\tcase ARG_TEST_25: bowtie2p5 = true; break;\n\tcase ARG_DESC_KB: descentTotSz = SimpleFunc::parse(arg, 0.0, 1024.0, 1024.0, DMAX); break;\n\tcase ARG_DESC_FMOPS: descentTotFmops = SimpleFunc::parse(arg, 0.0, 10.0, 100.0, DMAX); break;\n\tcase ARG_LOG_DP: logDps = arg; break;\n\tcase ARG_LOG_DP_OPP: logDpsOpp = arg; break;\n\tcase ARG_DESC_LANDING: {\n\t\tdescLanding = parse<int>(arg);\n\t\tif(descLanding < 1) {\n\t\t\tcerr << \"Error: --desc-landing must be greater than or equal to 1\" << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARG_DESC_EXP: {\n\t\tdescConsExp = parse<double>(arg);\n\t\tif(descConsExp < 0.0) {\n\t\t\tcerr << \"Error: --desc-exp must be greater than or equal to 0\" << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARG_DESC_PRIORITIZE: descPrioritizeRoots = true; break;\n\tcase '1': tokenize(arg, \",\", mates1); break;\n\tcase '2': tokenize(arg, \",\", mates2); break;\n\tcase ARG_ONETWO: tokenize(arg, \",\", mates12); set_format(format, TAB_MATE5); break;\n\tcase ARG_TAB5:   tokenize(arg, \",\", mates12); set_format(format, TAB_MATE5); break;\n\tcase ARG_TAB6:   tokenize(arg, \",\", mates12); set_format(format, TAB_MATE6); break;\n\tcase ARG_INTERLEAVED: {\n\t\ttokenize(arg, \",\", mates12);\n\t\tinterleaved = true;\n\t\tbreak;\n\t}\n\tcase 'b': {\n\t\tset_format(format, BAM);\n\t\tsaw_bam = true;\n\t\tbreak;\n\t}\n\tcase 'f': set_format(format, FASTA); break;\n\tcase 'F': {\n\t\tset_format(format, FASTA_CONT);\n\t\tpair<uint32_t, uint32_t> p = parsePair<uint32_t>(arg, ',');\n\t\tfastaContLen = p.first;\n\t\tfastaContFreq = p.second;\n\t\tbreak;\n\t}\n\tcase ARG_BWA_SW_LIKE: {\n\t\tbwaSwLikeC = 5.5f;\n\t\tbwaSwLikeT = 30;\n\t\tbwaSwLike = true;\n\t\tlocalAlign = true;\n\t\t// -a INT   Score of a match [1]\n\t\t// -b INT   Mismatch penalty [3]\n\t\t// -q INT   Gap open penalty [5]\n\t\t// -r INT   Gap extension penalty. The penalty for a contiguous\n\t\t//          gap of size k is q+k*r. [2]\n\t\tpolstr += \";MA=1;MMP=C3;RDG=5,2;RFG=5,2\";\n\t\tbreak;\n\t}\n\tcase 'q': set_format(format, FASTQ); break;\n\tcase 'r': set_format(format, RAW); break;\n\tcase 'c': set_format(format, CMDLINE); break;\n\tcase ARG_QSEQ: set_format(format, QSEQ); break;\n\tcase 'I':\n\t\tgMinInsert = parseInt(0, \"-I arg must be positive\", arg);\n\t\tbreak;\n\tcase 'X':\n\t\tgMaxInsert = parseInt(1, \"-X arg must be at least 1\", arg);\n\t\tbreak;\n\tcase ARG_NO_DISCORDANT: gReportDiscordant = false; break;\n\tcase ARG_NO_MIXED: gReportMixed = false; break;\n\tcase 's':\n\t\tskipReads = (uint32_t)parseInt(0, \"-s arg must be positive\", arg);\n\t\tbreak;\n\tcase ARG_FF: gMate1fw = true;  gMate2fw = true;  break;\n\tcase ARG_RF: gMate1fw = false; gMate2fw = true;  break;\n\tcase ARG_FR: gMate1fw = true;  gMate2fw = false; break;\n\tcase ARG_SHMEM: useShmem = true; break;\n\tcase ARG_SEED_SUMM: seedSumm = true; break;\n\tcase ARG_SC_UNMAPPED: scUnMapped = true; break;\n\tcase ARG_XEQ: xeq = true; break;\n\tcase ARG_PRESERVE_TAGS: {\n\t\tpreserve_tags = true;\n\t\tsaw_preserve_tags = true;\n\t\tbreak;\n\t}\n\tcase ARG_ALIGN_PAIRED_READS: {\n\t\talign_paired_reads = true;\n\t\tsaw_align_paired_reads = true;\n\t\tbreak;\n\t}\n\tcase ARG_MM: {\n#ifdef BOWTIE_MM\n\t\tuseMm = true;\n\t\tbreak;\n#else\n\t\tcerr << \"Memory-mapped I/O mode is disabled because bowtie was not compiled with\" << endl\n\t\t     << \"BOWTIE_MM defined.  Memory-mapped I/O is not supported under Windows.  If you\" << endl\n\t\t     << \"would like to use memory-mapped I/O on a platform that supports it, please\" << endl\n\t\t     << \"refrain from specifying BOWTIE_MM=0 when compiling Bowtie.\" << endl;\n\t\tthrow 1;\n#endif\n\t}\n\tcase ARG_MMSWEEP: mmSweep = true; break;\n\tcase ARG_HADOOPOUT: hadoopOut = true; break;\n\tcase ARG_SOLEXA_QUALS: solexaQuals = true; break;\n\tcase ARG_INTEGER_QUALS: integerQuals = true; break;\n\tcase ARG_PHRED64: phred64Quals = true; break;\n\tcase ARG_PHRED33: solexaQuals = false; phred64Quals = false; break;\n\tcase ARG_OVERHANG: gReportOverhangs = true; break;\n\tcase ARG_NO_CACHE: msNoCache = true; break;\n\tcase ARG_USE_CACHE: msNoCache = false; break;\n\tcase ARG_LOCAL_SEED_CACHE_SZ:\n\t\tseedCacheLocalMB = (uint32_t)parseInt(1, \"--local-seed-cache-sz arg must be at least 1\", arg);\n\t\tbreak;\n\tcase ARG_CURRENT_SEED_CACHE_SZ:\n\t\tseedCacheCurrentMB = (uint32_t)parseInt(1, \"--seed-cache-sz arg must be at least 1\", arg);\n\t\tbreak;\n\tcase ARG_REFIDX: noRefNames = true; break;\n\tcase ARG_FULLREF: fullRef = true; break;\n\tcase ARG_GAP_BAR:\n\t\tgGapBarrier = parseInt(1, \"--gbar must be no less than 1\", arg);\n\t\tbreak;\n\tcase ARG_SEED:\n\t\tseed = parseInt(0, \"--seed arg must be at least 0\", arg);\n\t\tbreak;\n\tcase ARG_NON_DETERMINISTIC:\n\t\tarbitraryRandom = true;\n\t\tbreak;\n\tcase 'u':\n\t\tqUpto = (uint32_t)parseInt(1, \"-u/--qupto arg must be at least 1\", arg);\n\t\tbreak;\n\tcase 'Q':\n\t\ttokenize(arg, \",\", qualities);\n\t\tintegerQuals = true;\n\t\tbreak;\n\tcase ARG_QUALS1:\n\t\ttokenize(arg, \",\", qualities1);\n\t\tintegerQuals = true;\n\t\tbreak;\n\tcase ARG_QUALS2:\n\t\ttokenize(arg, \",\", qualities2);\n\t\tintegerQuals = true;\n\t\tbreak;\n\tcase ARG_CACHE_LIM:\n\t\tcacheLimit = (uint32_t)parseInt(1, \"--cachelim arg must be at least 1\", arg);\n\t\tbreak;\n\tcase ARG_CACHE_SZ:\n\t\tcacheSize = (uint32_t)parseInt(1, \"--cachesz arg must be at least 1\", arg);\n\t\tcacheSize *= (1024 * 1024); // convert from MB to B\n\t\tbreak;\n\tcase ARG_WRAPPER: wrapper = arg; break;\n\tcase 'p':\n\t\tnthreads = parseInt(1, \"-p/--threads arg must be at least 1\", arg);\n\t\tbreak;\n\tcase ARG_THREAD_CEILING:\n\t\tthread_ceiling = parseInt(0, \"--thread-ceiling must be at least 0\", arg);\n\t\tbreak;\n\tcase ARG_THREAD_PIDDIR:\n\t\tthread_stealing_dir = arg;\n\t\tbreak;\n\tcase ARG_FILEPAR:\n\t\tfileParallel = true;\n\t\tbreak;\n\tcase '3': gTrim3 = parseInt(0, \"-3/--trim3 arg must be at least 0\", arg); break;\n\tcase '5': gTrim5 = parseInt(0, \"-5/--trim5 arg must be at least 0\", arg); break;\n\tcase ARG_TRIM_TO: {\n\t\tif (strlen(arg) > 1 && arg[1] != ':') {\n\t\t\ttrimTo.first = 3;\n\t\t\ttrimTo.second = parseInt(0, \"--trim-to: the number of bases to trim must be at least 0\", arg);\n\t\t\tbreak;\n\t\t}\n\t\tpair<int, int> res = parsePair<int>(arg, ':');\n\t\tif (res.first != 3 && res.first != 5) {\n\t\t\tcerr << \"--trim-to: trim position must be either 3 or 5\" << endl;\n\t\t\tprintUsage(cerr);\n\t\t\tthrow 1;\n\t\t}\n\t\tif(res.second < 0) {\n\t\t\tcerr << \"--trim-to: the number bases to trim must be at least 0\" << endl;\n\t\t\tprintUsage(cerr);\n\t\t\tthrow 1;\n\t\t}\n\t\ttrimTo = static_cast<pair<short, size_t> >(res);\n\t\tbreak;\n\t}\n\tcase 'h': printUsage(cout); throw 0; break;\n\tcase ARG_USAGE: printUsage(cout); throw 0; break;\n\t\t//\n\t\t// NOTE that unlike in Bowtie 1, -M, -a and -k are mutually\n\t\t// exclusive here.\n\t\t//\n\tcase 'M': {\n\t\tmsample = true;\n\t\tmhits = parse<uint32_t>(arg);\n\t\tif(saw_a || saw_k) {\n\t\t\tcerr << \"Warning: -M, -k and -a are mutually exclusive. \"\n\t\t\t     << \"-M will override\" << endl;\n\t\t\tkhits = 1;\n\t\t}\n\t\tassert_eq(1, khits);\n\t\tsaw_M = true;\n\t\tcerr << \"Warning: -M is deprecated.  Use -D and -R to adjust \" <<\n\t\t\t\"effort instead.\" << endl;\n\t\tbreak;\n\t}\n\tcase ARG_EXTEND_ITERS: {\n\t\tmaxIters = parse<size_t>(arg);\n\t\tbreak;\n\t}\n\tcase ARG_NO_EXTEND: {\n\t\tdoExtend = false;\n\t\tbreak;\n\t}\n\tcase 'R': { polstr += \";ROUNDS=\"; polstr += arg; break; }\n\tcase 'D': { polstr += \";DPS=\";    polstr += arg; break; }\n\tcase ARG_DP_MATE_STREAK_THRESH: {\n\t\tmaxMateStreak = parse<size_t>(arg);\n\t\tbreak;\n\t}\n\tcase ARG_DP_FAIL_STREAK_THRESH: {\n\t\tmaxDpStreak = parse<size_t>(arg);\n\t\tbreak;\n\t}\n\tcase ARG_EE_FAIL_STREAK_THRESH: {\n\t\tmaxEeStreak = parse<size_t>(arg);\n\t\tbreak;\n\t}\n\tcase ARG_UG_FAIL_STREAK_THRESH: {\n\t\tmaxUgStreak = parse<size_t>(arg);\n\t\tbreak;\n\t}\n\tcase ARG_DP_FAIL_THRESH: {\n\t\tmaxDp = parse<size_t>(arg);\n\t\tbreak;\n\t}\n\tcase ARG_UG_FAIL_THRESH: {\n\t\tmaxUg = parse<size_t>(arg);\n\t\tbreak;\n\t}\n\tcase ARG_SEED_BOOST_THRESH: {\n\t\tseedBoostThresh = parse<size_t>(arg);\n\t\tbreak;\n\t}\n\tcase 'a': {\n\t\tmsample = false;\n\t\tallHits = true;\n\t\tmhits = 0; // disable -M\n\t\tif(saw_M || saw_k) {\n\t\t\tcerr << \"Warning: -M, -k and -a are mutually exclusive. \"\n\t\t\t     << \"-a will override\" << endl;\n\t\t}\n\t\tsaw_a = true;\n\t\tbreak;\n\t}\n\tcase 'k': {\n\t\tmsample = false;\n\t\tkhits = (uint32_t)parseInt(1, \"-k arg must be at least 1\", arg);\n\t\tmhits = 0; // disable -M\n\t\tif(saw_M || saw_a) {\n\t\t\tcerr << \"Warning: -M, -k and -a are mutually exclusive. \"\n\t\t\t     << \"-k will override\" << endl;\n\t\t}\n\t\tsaw_k = true;\n\t\tbreak;\n\t}\n\tcase ARG_VERBOSE: gVerbose = 1; break;\n\tcase ARG_STARTVERBOSE: startVerbose = true; break;\n\tcase ARG_QUIET: gQuiet = true; break;\n\tcase ARG_SANITY: sanityCheck = true; break;\n\tcase 't': timing = true; break;\n\tcase ARG_METRIC_IVAL: {\n\t\tmetricsIval = parseInt(1, \"--metrics arg must be at least 1\", arg);\n\t\tbreak;\n\t}\n\tcase ARG_METRIC_FILE: metricsFile = arg; break;\n\tcase ARG_METRIC_STDERR: metricsStderr = true; break;\n\tcase ARG_METRIC_PER_READ: metricsPerRead = true; break;\n\tcase ARG_NO_FW: gNofw = true; break;\n\tcase ARG_NO_RC: gNorc = true; break;\n\tcase ARG_SAM_NO_QNAME_TRUNC: samTruncQname = false; break;\n\tcase ARG_SAM_APPEND_COMMENT: samAppendComment = true; break;\n\tcase ARG_SAM_OMIT_SEC_SEQ: samOmitSecSeqQual = true; break;\n\tcase ARG_SAM_NO_UNAL: samNoUnal = true; break;\n\tcase ARG_SAM_NOHEAD: samNoHead = true; break;\n\tcase ARG_SAM_NOSQ: samNoSQ = true; break;\n\tcase ARG_SAM_PRINT_YI: sam_print_yi = true; break;\n\tcase ARG_REORDER: reorder = true; break;\n\tcase ARG_MAPQ_EX: {\n\t\tsam_print_zt = true;\n\t\tbreak;\n\t}\n\tcase ARG_SHOW_RAND_SEED: {\n\t\tsam_print_zs = true;\n\t\tbreak;\n\t}\n\tcase ARG_SAMPLE:\n\t\tsampleFrac = parse<float>(arg);\n\t\tbreak;\n\tcase ARG_CP_MIN:\n\t\tcminlen = parse<size_t>(arg);\n\t\tbreak;\n\tcase ARG_CP_IVAL:\n\t\tcpow2 = parse<size_t>(arg);\n\t\tbreak;\n\tcase ARG_TRI:\n\t\tdoTri = true;\n\t\tbreak;\n\tcase ARG_READ_PASSTHRU: {\n\t\tsam_print_xr = true;\n\t\tbreak;\n\t}\n\tcase ARG_READ_TIMES: {\n\t\tsam_print_xt = true;\n\t\tsam_print_xd = true;\n\t\tsam_print_xu = true;\n\t\tsam_print_yl = true;\n\t\tsam_print_ye = true;\n\t\tsam_print_yu = true;\n\t\tsam_print_yr = true;\n\t\tsam_print_zb = true;\n\t\tsam_print_zr = true;\n\t\tsam_print_zf = true;\n\t\tsam_print_zm = true;\n\t\tsam_print_zi = true;\n\t\tbreak;\n\t}\n\tcase ARG_SAM_RG: {\n\t\tstring argstr = arg;\n\t\tif(argstr.substr(0, 3) == \"ID:\") {\n\t\t\trgid = \"\\t\";\n\t\t\trgid += argstr;\n\t\t\trgs_optflag = \"RG:Z:\" + argstr.substr(3);\n\t\t} else {\n\t\t\trgs += '\\t';\n\t\t\trgs += argstr;\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARG_SAM_RGID: {\n\t\tstring argstr = arg;\n\t\trgid = \"\\t\";\n\t\trgid = \"\\tID:\" + argstr;\n\t\trgs_optflag = \"RG:Z:\" + argstr;\n\t\tbreak;\n\t}\n\tcase ARG_PARTITION: partitionSz = parse<int>(arg); break;\n\tcase ARG_READS_PER_BATCH:\n\t\treadsPerBatch = parseInt(1, \"--reads-per-batch arg must be at least 1\", arg);\n\t\tbreak;\n\tcase ARG_DPAD:\n\t\tmaxhalf = parseInt(0, \"--dpad must be no less than 0\", arg);\n\t\tbreak;\n\tcase ARG_ORIG:\n\t\tif(arg == NULL || strlen(arg) == 0) {\n\t\t\tcerr << \"--orig arg must be followed by a string\" << endl;\n\t\t\tprintUsage(cerr);\n\t\t\tthrow 1;\n\t\t}\n\t\torigString = arg;\n\t\tbreak;\n\tcase ARG_LOCAL: {\n\t\tlocalAlign = true;\n\t\tgDefaultSeedLen = DEFAULT_LOCAL_SEEDLEN;\n\t\tbreak;\n\t}\n\tcase ARG_END_TO_END: localAlign = false; break;\n\tcase ARG_SSE8: enable8 = true; break;\n\tcase ARG_SSE8_NO: enable8 = false; break;\n\tcase ARG_UNGAPPED: doUngapped = true; break;\n\tcase ARG_UNGAPPED_NO: doUngapped = false; break;\n\tcase ARG_NO_DOVETAIL: gDovetailMatesOK = false; break;\n\tcase ARG_NO_CONTAIN:  gContainMatesOK  = false; break;\n\tcase ARG_NO_OVERLAP:  gOlapMatesOK     = false; break;\n\tcase ARG_DOVETAIL:    gDovetailMatesOK = true;  break;\n\tcase ARG_CONTAIN:     gContainMatesOK  = true;  break;\n\tcase ARG_OVERLAP:     gOlapMatesOK     = true;  break;\n\tcase ARG_QC_FILTER: qcFilter = true; break;\n\tcase ARG_IGNORE_QUALS: ignoreQuals = true; break;\n\tcase ARG_MAPQ_V: mapqv = parse<int>(arg); break;\n\tcase ARG_TIGHTEN: tighten = parse<int>(arg); break;\n\tcase ARG_EXACT_UPFRONT:    doExactUpFront = true; break;\n\tcase ARG_1MM_UPFRONT:      do1mmUpFront   = true; break;\n\tcase ARG_EXACT_UPFRONT_NO: doExactUpFront = false; break;\n\tcase ARG_1MM_UPFRONT_NO:   do1mmUpFront   = false; break;\n\tcase ARG_1MM_MINLEN:       do1mmMinLen = parse<size_t>(arg); break;\n\tcase ARG_NOISY_HPOLY: noisyHpolymer = true; break;\n\tcase 'x': bt2index = arg; break;\n\tcase ARG_PRESET_VERY_FAST_LOCAL: localAlign = true;\n\tcase ARG_PRESET_VERY_FAST: {\n\t\tpresetList.push_back(\"very-fast%LOCAL%\"); break;\n\t}\n\tcase ARG_PRESET_FAST_LOCAL: localAlign = true;\n\tcase ARG_PRESET_FAST: {\n\t\tpresetList.push_back(\"fast%LOCAL%\"); break;\n\t}\n\tcase ARG_PRESET_SENSITIVE_LOCAL: localAlign = true;\n\tcase ARG_PRESET_SENSITIVE: {\n\t\tpresetList.push_back(\"sensitive%LOCAL%\"); break;\n\t}\n\tcase ARG_PRESET_VERY_SENSITIVE_LOCAL: localAlign = true;\n\tcase ARG_PRESET_VERY_SENSITIVE: {\n\t\tpresetList.push_back(\"very-sensitive%LOCAL%\"); break;\n\t}\n\tcase 'P': { presetList.push_back(arg); break; }\n\tcase ARG_ALIGN_POLICY: {\n\t\tif(strlen(arg) > 0) {\n\t\t\tpolstr += \";\"; polstr += arg;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 'N': {\n\t\tint64_t len = parse<size_t>(arg);\n\t\tif (len < 0 || len > 1) {\n\t\t\tcerr << \"Error: -N argument must be within the interval [0,1]; was \" << arg << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\tpolstr += \";SEED=\";\n\t\tpolstr += arg;\n\t\tbreak;\n\t}\n\tcase 'L': {\n\t\tint64_t len = parse<size_t>(arg);\n\t\tif(len < 1 || len > 32) {\n\t\t\tcerr << \"Error: -L argument must be within the interval [1,32]; was \" << arg << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\tpolstr += \";SEEDLEN=\";\n\t\tpolstr += arg;\n\t\tbreak;\n\t}\n\tcase 'O':\n\t\tmultiseedOff = parse<size_t>(arg);\n\t\tbreak;\n\tcase 'i': {\n\t\tEList<string> args;\n\t\ttokenize(arg, \",\", args);\n\t\tif(args.size() > 3 || args.size() == 0) {\n\t\t\tcerr << \"Error: expected 3 or fewer comma-separated \"\n\t\t\t     << \"arguments to -i option, got \"\n\t\t\t     << args.size() << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\t// Interval-settings arguments\n\t\tpolstr += (\";IVAL=\" + args[0]); // Function type\n\t\tif(args.size() > 1) {\n\t\t\tpolstr += (\",\" + args[1]);  // Constant term\n\t\t}\n\t\tif(args.size() > 2) {\n\t\t\tpolstr += (\",\" + args[2]);  // Coefficient\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARG_MULTISEED_IVAL: {\n\t\tpolstr += \";\";\n\t\t// Split argument by comma\n\t\tEList<string> args;\n\t\ttokenize(arg, \",\", args);\n\t\tif(args.size() > 5 || args.size() == 0) {\n\t\t\tcerr << \"Error: expected 5 or fewer comma-separated \"\n\t\t\t     << \"arguments to --multiseed option, got \"\n\t\t\t     << args.size() << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\t// Seed mm and length arguments\n\t\tpolstr += \"SEED=\";\n\t\tpolstr += (args[0]); // # mismatches\n\t\tif(args.size() >  1) polstr += (\";SEEDLEN=\" + args[1]); // length\n\t\tif(args.size() >  2) polstr += (\";IVAL=\" + args[2]); // Func type\n\t\tif(args.size() >  3) polstr += (\",\" + args[ 3]); // Constant term\n\t\tif(args.size() >  4) polstr += (\",\" + args[ 4]); // Coefficient\n\t\tbreak;\n\t}\n\tcase ARG_N_CEIL: {\n\t\t// Split argument by comma\n\t\tEList<string> args;\n\t\ttokenize(arg, \",\", args);\n\t\tif(args.size() > 3) {\n\t\t\tcerr << \"Error: expected 3 or fewer comma-separated \"\n\t\t\t     << \"arguments to --n-ceil option, got \"\n\t\t\t     << args.size() << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\tif(args.size() == 0) {\n\t\t\tcerr << \"Error: expected at least one argument to --n-ceil option\" << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\tpolstr += \";NCEIL=\";\n\t\tif(args.size() == 3) {\n\t\t\tpolstr += (args[0] + \",\" + args[1] + \",\" + args[2]);\n\t\t} else {\n\t\t\tpolstr += (\"L,\" + args[0]);\n\t\t\tif(args.size() > 1) {\n\t\t\t\tpolstr += (\",\" + (args[1]));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARG_SCORE_MA:  polstr += \";MA=\";    polstr += arg; break;\n\tcase ARG_SCORE_MMP: {\n\t\tEList<string> args;\n\t\ttokenize(arg, \",\", args);\n\t\tif(args.size() > 2 || args.size() == 0) {\n\t\t\tcerr << \"Error: expected 1 or 2 comma-separated \"\n\t\t\t     << \"arguments to --mmp option, got \" << args.size() << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\tif(args.size() >= 1) {\n\t\t\tpolstr += \";MMP=Q,\";\n\t\t\tpolstr += args[0];\n\t\t\tif(args.size() >= 2) {\n\t\t\t\tpolstr += \",\";\n\t\t\t\tpolstr += args[1];\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARG_SCORE_NP:  polstr += \";NP=C\";   polstr += arg; break;\n\tcase ARG_SCORE_RDG: polstr += \";RDG=\";   polstr += arg; break;\n\tcase ARG_SCORE_RFG: polstr += \";RFG=\";   polstr += arg; break;\n\tcase ARG_SCORE_MIN: {\n\t\tpolstr += \";\";\n\t\tEList<string> args;\n\t\ttokenize(arg, \",\", args);\n\t\tif(args.size() > 3 || args.size() == 0) {\n\t\t\tcerr << \"Error: expected 3 or fewer comma-separated \"\n\t\t\t     << \"arguments to --n-ceil option, got \"\n\t\t\t     << args.size() << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\tpolstr += (\"MIN=\" + args[0]);\n\t\tif(args.size() > 1) {\n\t\t\tpolstr += (\",\" + args[1]);\n\t\t}\n\t\tif(args.size() > 2) {\n\t\t\tpolstr += (\",\" + args[2]);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARG_DESC: printArgDesc(cout); throw 0;\n\tcase 'S': outfile = arg; break;\n\tcase 'U': {\n\t\tEList<string> args;\n\t\ttokenize(arg, \",\", args);\n\t\tfor(size_t i = 0; i < args.size(); i++) {\n\t\t\tqueries.push_back(args[i]);\n\t\t}\n\t\tbreak;\n\t}\n#ifdef USE_SRA\n        case ARG_SRA_ACC: {\n\t\ttokenize(arg, \",\", sra_accs);\n\t\tset_format(format, SRA_FASTA);\n\t\tbreak;\n        }\n#endif\n        case ARG_VERSION: showVersion = 1; break;\n\tdefault:\n\t\tprintUsage(cerr);\n\t\tthrow 1;\n\t}\n}", "idx": 599}
{"project": "bowtie2", "commit_id": "641_bowtie2_2.5.1_bt2_search.cpp_driver.cpp", "target": 1, "func": "static void driver(\n\tconst char * type,\n\tconst string& bt2indexBase,\n\tconst string& outfile)\n{\n\tif(gVerbose || startVerbose)  {\n\t\tcerr << \"Entered driver(): \"; logTime(cerr, true);\n\t}\n\t// Vector of the reference sequences; used for sanity-checking\n\tEList<SString<char> > names, os;\n\tEList<size_t> nameLens, seqLens;\n\t// Read reference sequences from the command-line or from a FASTA file\n\tif(!origString.empty()) {\n\t\t// Read fasta file(s)\n\t\tEList<string> origFiles;\n\t\ttokenize(origString, \",\", origFiles);\n\t\tparseFastas(origFiles, names, nameLens, os, seqLens);\n\t}\n\tPatternParams pp(\n\t\tformat,        // file format\n\t\tinterleaved,   // some or all of the reads are interleaved\n\t\tfileParallel,  // true -> wrap files with separate PairedPatternSources\n\t\tseed,          // pseudo-random seed\n\t\treadsPerBatch, // # reads in a light parsing batch\n\t\tsolexaQuals,   // true -> qualities are on solexa64 scale\n\t\tphred64Quals,  // true -> qualities are on phred64 scale\n\t\tintegerQuals,  // true -> qualities are space-separated numbers\n\t\tgTrim5,        // amt to hard clip from 5' end\n\t\tgTrim3,        // amt to hard clip from 3' end\n\t\ttrimTo,        // trim reads exceeding given length from either 3' or 5'-end\n\t\tfastaContLen,  // length of sampled reads for FastaContinuous...\n\t\tfastaContFreq, // frequency of sampled reads for FastaContinuous...\n\t\tskipReads,     // skip the first 'skip' patterns\n\t\tqUpto,         // max number of queries to read\n\t\tnthreads,      //number of threads for locking\n\t\toutType != OUTPUT_SAM, // whether to fix mate names\n\t\tpreserve_tags, // keep existing tags when aligning BAM files\n\t\talign_paired_reads // Align only the paired reads in BAM file\n\t\t);\n\tif(gVerbose || startVerbose) {\n\t\tcerr << \"Creating PatternSource: \"; logTime(cerr, true);\n\t}\n\tPatternComposer *patsrc = PatternComposer::setupPatternComposer(\n\t\tqueries,     // singles, from argv\n\t\tmates1,      // mate1's, from -1 arg\n\t\tmates2,      // mate2's, from -2 arg\n\t\tmates12,     // both mates on each line, from --12 arg\n\t\tqualities,   // qualities associated with singles\n\t\tqualities1,  // qualities associated with m1\n\t\tqualities2,  // qualities associated with m2\n#ifdef USE_SRA\n\t\tsra_accs,    // SRA accessions\n#endif\n\t\tpp,          // read read-in parameters\n\t\tgVerbose || startVerbose); // be talkative\n\t// Open hit output file\n\tif(gVerbose || startVerbose) {\n\t\tcerr << \"Opening hit output file: \"; logTime(cerr, true);\n\t}\n\tOutFileBuf *fout;\n\tif(!outfile.empty()) {\n\t\tfout = new OutFileBuf(outfile.c_str(), false);\n\t} else {\n\t\tfout = new OutFileBuf();\n\t}\n\t// Initialize Ebwt object and read in header\n\tif(gVerbose || startVerbose) {\n\t\tcerr << \"About to initialize fw Ebwt: \"; logTime(cerr, true);\n\t}\n\tadjIdxBase = adjustEbwtBase(argv0, bt2indexBase, gVerbose);\n\tEbwt ebwt(\n\t\tadjIdxBase,\n\t\t0,        // index is colorspace\n\t\t-1,       // fw index\n\t\ttrue,     // index is for the forward direction\n\t\t/* overriding: */ offRate,\n\t\t0, // amount to add to index offrate or <= 0 to do nothing\n\t\tuseMm,    // whether to use memory-mapped files\n\t\tuseShmem, // whether to use shared memory\n\t\tmmSweep,  // sweep memory-mapped files\n\t\t!noRefNames, // load names?\n\t\ttrue,        // load SA sample?\n\t\ttrue,        // load ftab?\n\t\ttrue,        // load rstarts?\n\t\tgVerbose, // whether to be talkative\n\t\tstartVerbose, // talkative during initialization\n\t\tfalse /*passMemExc*/,\n\t\tsanityCheck);\n\n\tif(sanityCheck && !os.empty()) {\n\t\t// Sanity check number of patterns and pattern lengths in Ebwt\n\t\t// against original strings\n\t\tassert_eq(os.size(), ebwt.nPat());\n\t\tfor(size_t i = 0; i < os.size(); i++) {\n\t\t\tassert_eq(os[i].length(), ebwt.plen()[i]);\n\t\t}\n\t}\n\t// Sanity-check the restored version of the Ebwt\n\tif(sanityCheck && !os.empty()) {\n\t\tebwt.loadIntoMemory(\n\t\t\t0,\n\t\t\t-1, // fw index\n\t\t\ttrue, // load SA sample\n\t\t\ttrue, // load ftab\n\t\t\ttrue, // load rstarts\n\t\t\t!noRefNames,\n\t\t\tstartVerbose);\n\t\tebwt.checkOrigs(os, false, false);\n\t\tebwt.evictFromMemory();\n\t}\n\tOutputQueue oq(\n\t\t*fout,                           // out file buffer\n\t\treorder && (nthreads > 1 || thread_stealing), // whether to reorder\n\t\tnthreads,                        // # threads\n\t\tnthreads > 1 || thread_stealing, // whether to be thread-safe\n\t\treadsPerBatch,                   // size of output buffer of reads\n\t\tskipReads);                      // first read will have this rdid\n\t{\n\t\tTimer _t(cerr, \"Time searching: \", timing);\n\t\t// Set up pexnalities\n\t\tif(bonusMatch > 0 && !localAlign) {\n\t\t\tcerr << \"Warning: Match bonus always = 0 in --end-to-end mode; ignoring user setting\" << endl;\n\t\t\tbonusMatch = 0;\n\t\t}\n\t\tScoring sc(\n\t\t\tbonusMatch,     // constant reward for match\n\t\t\tpenMmcType,     // how to penalize mismatches\n\t\t\tpenMmcMax,      // max mm pelanty\n\t\t\tpenMmcMin,      // min mm pelanty\n\t\t\tscoreMin,       // min score as function of read len\n\t\t\tnCeil,          // max # Ns as function of read len\n\t\t\tpenNType,       // how to penalize Ns in the read\n\t\t\tpenN,           // constant if N pelanty is a constant\n\t\t\tpenNCatPair,    // whether to concat mates before N filtering\n\t\t\tpenRdGapConst,  // constant coeff for read gap cost\n\t\t\tpenRfGapConst,  // constant coeff for ref gap cost\n\t\t\tpenRdGapLinear, // linear coeff for read gap cost\n\t\t\tpenRfGapLinear, // linear coeff for ref gap cost\n\t\t\tgGapBarrier);   // # rows at top/bot only entered diagonally\n\t\tEList<size_t> reflens;\n\t\tfor(size_t i = 0; i < ebwt.nPat(); i++) {\n\t\t\treflens.push_back(ebwt.plen()[i]);\n\t\t}\n\t\tEList<string> refnames;\n\t\treadEbwtRefnames(adjIdxBase, refnames);\n\t\tSamConfig samc(\n\t\t\trefnames,               // reference sequence names\n\t\t\treflens,                // reference sequence lengths\n\t\t\tsamTruncQname,          // whether to truncate QNAME to 255 chars\n\t\t\tsamAppendComment,\t// append FASTA/FASTQ comment to SAM record\n\t\t\tsamOmitSecSeqQual,      // omit SEQ/QUAL for 2ndary alignments?\n\t\t\tsamNoUnal,              // omit unaligned-read records?\n\t\t\tstring(\"bowtie2\"),      // program id\n\t\t\tstring(\"bowtie2\"),      // program name\n\t\t\tstring(BOWTIE2_VERSION), // program version\n\t\t\targstr,                 // command-line\n\t\t\trgs_optflag,            // read-group string\n\t\t\tsam_print_as,\n\t\t\tsam_print_xs,\n\t\t\tsam_print_xss,\n\t\t\tsam_print_yn,\n\t\t\tsam_print_xn,\n\t\t\tsam_print_x0,\n\t\t\tsam_print_x1,\n\t\t\tsam_print_xm,\n\t\t\tsam_print_xo,\n\t\t\tsam_print_xg,\n\t\t\tsam_print_nm,\n\t\t\tsam_print_md,\n\t\t\tsam_print_yf,\n\t\t\tsam_print_yi,\n\t\t\tsam_print_ym,\n\t\t\tsam_print_yp,\n\t\t\tsam_print_yt,\n\t\t\tsam_print_ys,\n\t\t\tsam_print_zs,\n\t\t\tsam_print_xr,\n\t\t\tsam_print_xt,\n\t\t\tsam_print_xd,\n\t\t\tsam_print_xu,\n\t\t\tsam_print_yl,\n\t\t\tsam_print_ye,\n\t\t\tsam_print_yu,\n\t\t\tsam_print_xp,\n\t\t\tsam_print_yr,\n\t\t\tsam_print_zb,\n\t\t\tsam_print_zr,\n\t\t\tsam_print_zf,\n\t\t\tsam_print_zm,\n\t\t\tsam_print_zi,\n\t\t\tsam_print_zp,\n\t\t\tsam_print_zu,\n\t\t\tsam_print_zt);\n\t\t// Set up hit sink; if sanityCheck && !os.empty() is true,\n\t\t// then instruct the sink to \"retain\" hits in a vector in\n\t\t// memory so that we can easily sanity check them later on\n\t\tAlnSink *mssink = NULL;\n\t\tswitch(outType) {\n\t\tcase OUTPUT_SAM: {\n\t\t\tmssink = new AlnSinkSam(\n\t\t\t\toq,           // output queue\n\t\t\t\tsamc,         // settings & routines for SAM output\n\t\t\t\trefnames,     // reference names\n\t\t\t\tgQuiet);      // don't print alignment summary at end\n\t\t\tif(!samNoHead) {\n\t\t\t\tbool printHd = true, printSq = true;\n\t\t\t\tBTString buf;\n\t\t\t\tsamc.printHeader(buf, rgid, rgs, printHd, !samNoSQ, printSq);\n\t\t\t\tfout->writeString(buf);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tcerr << \"Invalid output type: \" << outType << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\tif(gVerbose || startVerbose) {\n\t\t\tcerr << \"Dispatching to search driver: \"; logTime(cerr, true);\n\t\t}\n\t\t// Set up global constraint\n\t\tOutFileBuf *metricsOfb = NULL;\n\t\tif(!metricsFile.empty() && metricsIval > 0) {\n\t\t\tmetricsOfb = new OutFileBuf(metricsFile);\n\t\t}\n\t\t// Do the search for all input reads\n\t\tassert(patsrc != NULL);\n\t\tassert(mssink != NULL);\n                if(multiseedMms > 0 || do1mmUpFront) {\n\t\t\tif(gVerbose || startVerbose) {\n\t\t\t\tcerr << \"About to initialize rev Ebwt: \"; logTime(cerr, true);\n\t\t\t}\n\n\t\t\t// We need the mirror index if mismatches are allowed\n\t\t\tEbwt ebwtBw = Ebwt(\n\t\t\t\tadjIdxBase + \".rev\",\n\t\t\t\t0,       // index is colorspace\n\t\t\t\t1,       // TODO: maybe not\n\t\t\t\tfalse, // index is for the reverse direction\n\t\t\t\t/* overriding: */ offRate,\n\t\t\t\t0, // amount to add to index offrate or <= 0 to do nothing\n\t\t\t\tuseMm,    // whether to use memory-mapped files\n\t\t\t\tuseShmem, // whether to use shared memory\n\t\t\t\tmmSweep,  // sweep memory-mapped files\n\t\t\t\t!noRefNames, // load names?\n\t\t\t\ttrue,        // load SA sample?\n\t\t\t\ttrue,        // load ftab?\n\t\t\t\ttrue,        // load rstarts?\n\t\t\t\tgVerbose,    // whether to be talkative\n\t\t\t\tstartVerbose, // talkative during initialization\n\t\t\t\tfalse /*passMemExc*/,\n\t\t\t\tsanityCheck);\n\n\t\t\tmultiseedSearch(\n\t\t\t\tsc,      // scoring scheme\n\t\t\t\tpp,      // pattern params\n\t\t\t\t*patsrc, // pattern source\n\t\t\t\t*mssink, // hit sink\n\t\t\t\tebwt,    // BWT\n\t\t\t\t&ebwtBw, // BWT'\n\t\t\t\tmetricsOfb);\n                } else {\n\t\t\tmultiseedSearch(\n\t\t\t\tsc,      // scoring scheme\n\t\t\t\tpp,      // pattern params\n\t\t\t\t*patsrc, // pattern source\n\t\t\t\t*mssink, // hit sink\n\t\t\t\tebwt,    // BWT\n\t\t\t\tNULL,    // BWT'\n\t\t\t\tmetricsOfb);\n\t\t}\n\n\t\t// Evict any loaded indexes from memory\n\t\tif(ebwt.isInMemory()) {\n\t\t\tebwt.evictFromMemory();\n\t\t}\n\n\t\tif(!gQuiet && !seedSumm) {\n\t\t\tsize_t repThresh = mhits;\n\t\t\tif(repThresh == 0) {\n\t\t\t\trepThresh = std::numeric_limits<size_t>::max();\n\t\t\t}\n\t\t\tmssink->finish(\n\t\t\t\trepThresh,\n\t\t\t\tgReportDiscordant,\n\t\t\t\tgReportMixed,\n\t\t\t\thadoopOut);\n\t\t}\n\t\toq.flush(true);\n\t\tassert_eq(oq.numStarted(), oq.numFinished());\n\t\tassert_eq(oq.numStarted(), oq.numFlushed());\n\t\tdelete patsrc;\n\t\tdelete mssink;\n\t\tdelete metricsOfb;\n\t\tif(fout != NULL) {\n\t\t\tdelete fout;\n\t\t}\n\t}\n}", "idx": 600}
{"project": "bowtie2", "commit_id": "642_bowtie2_2.5.1_pat.cpp_FastaPatternSourcenextBatchFromFile.cpp", "target": 1, "func": "pair<bool, int> FastaPatternSource::nextBatchFromFile(\n\tPerThreadReadBuf& pt,\n\tbool batch_a, unsigned readi)\n{\n\tint c;\n\tEList<Read>* readbuf = batch_a ? &pt.bufa_ : &pt.bufb_;\n\tif(first_) {\n\t\tc = getc_wrapper();\n\t\tif (c == EOF) {\n\t\t\treturn make_pair(true, 0);\n\t\t}\n\t\twhile(c == '\\r' || c == '\\n') {\n\t\t\tc = getc_wrapper();\n\t\t}\n\t\tif(c != '>') {\n\t\t\tcerr << \"Error: reads file does not look like a FASTA file\" << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\tfirst_ = false;\n\t}\n\tbool done = false;\n\t// Read until we run out of input or until we've filled the buffer\n\twhile (readi < pt.max_buf_ && !done) {\n\t\tRead::TBuf& buf = (*readbuf)[readi].readOrigBuf;\n\t\tbuf.clear();\n\t\tbuf.append('>');\n\t\twhile(true) {\n\t\t\tc = getc_wrapper();\n\t\t\tif(c < 0 || c == '>') {\n\t\t\t\tdone = c < 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf.append(c);\n\t\t}\n\t\tif (interleaved_) {\n\t\t\t// alternate between read buffers\n\t\t\tbatch_a = !batch_a;\n\t\t\treadbuf = batch_a ? &pt.bufa_ : &pt.bufb_;\n\t\t\t// increment read counter after each pair gets read\n\t\t\treadi = batch_a ? readi+1 : readi;\n\t\t} else {\n\t\t\treadi++;\n\t\t}\n\n\t}\n\t// Immediate EOF case\n\tif(done && (*readbuf)[readi-1].readOrigBuf.length() == 1) {\n\t\treadi--;\n\t}\n\treturn make_pair(done, readi);\n}", "idx": 601}
{"project": "bowtie2", "commit_id": "643_bowtie2_2.5.1_pat.cpp_FastqPatternSourcenextBatchFromFile.cpp", "target": 1, "func": "pair<bool, int> FastqPatternSource::nextBatchFromFile(\n\tPerThreadReadBuf& pt,\n\tbool batch_a, unsigned readi)\n{\n\tint c = -1;\n\tEList<Read>* readbuf = batch_a ? &pt.bufa_ : &pt.bufb_;\n\tif(first_) {\n\t\tc = getc_wrapper();\n\t\tif (c == EOF) {\n\t\t\treturn make_pair(true, 0);\n\t\t}\n\t\twhile(c == '\\r' || c == '\\n') {\n\t\t\tc = getc_wrapper();\n\t\t}\n\t\tif(c != '@') {\n\t\t\tcerr << \"Error: reads file does not look like a FASTQ file\" << endl;\n\t\t\tthrow 1;\n\t\t}\n\t\tfirst_ = false;\n\t\t(*readbuf)[readi].readOrigBuf.append('@');\n\t}\n\n\tbool done = false, aborted = false;\n\t// Read until we run out of input or until we've filled the buffer\n\twhile (readi < pt.max_buf_ && !done) {\n\t\tRead::TBuf& buf = (*readbuf)[readi].readOrigBuf;\n\t\tint newlines = 4;\n\t\twhile(newlines) {\n\t\t\tc = getc_wrapper();\n\t\t\tdone = c < 0;\n\t\t\tif(c == '\\n' || (done && newlines == 1)) {\n\t\t\t\t// Saw newline, or EOF that we're\n\t\t\t\t// interpreting as final newline\n\t\t\t\tnewlines--;\n\t\t\t\tc = '\\n';\n\t\t\t} else if(done) {\n\t\t\t\t// account for newline at the end of the file\n\t\t\t\tif (newlines == 4) {\n\t\t\t\t\tnewlines = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taborted = true; // Unexpected EOF\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf.append(c);\n\t\t}\n\t\tif (c > 0) {\n\t\t\tif (interleaved_) {\n\t\t\t\t// alternate between read buffers\n\t\t\t\tbatch_a = !batch_a;\n\t\t\t\treadbuf = batch_a ? &pt.bufa_ : &pt.bufb_;\n\t\t\t\t// increment read counter after each pair gets read\n\t\t\t\treadi = batch_a ? readi+1 : readi;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treadi++;\n\t\t\t}\n\t\t}\n\t}\n\tif(aborted) {\n\t\treadi--;\n\t}\n\treturn make_pair(done, readi);\n}", "idx": 602}
{"project": "bowtie2", "commit_id": "644_bowtie2_2.5.1_pat.cpp_CFilePatternSourceopen.cpp", "target": 1, "func": "void CFilePatternSource::open() {\n\tif(is_open_) {\n\t\tis_open_ = false;\n\t\tswitch (compressionType_) {\n\t\tcase CompressionType::GZIP:\n\t\t\tgzclose(zfp_);\n\t\t\tzfp_ = NULL;\n\t\t\tbreak;\n#ifdef WITH_ZSTD\n\t\tcase CompressionType::ZSTD:\n\t\t\tzstdClose(zstdfp_);\n\t\t\tzstdfp_ = NULL;\n\t\t\tbreak;\n#endif\n\t\tcase CompressionType::NONE:\n\t\t\tfclose(fp_);\n\t\t\tfp_ = NULL;\n\t\t}\n\t}\n\twhile(filecur_ < infiles_.size()) {\n\t\tif(infiles_[filecur_] == \"-\") {\n\t\t\tint fd = dup(fileno(stdin));\n\t\t\tif (pp_.format == BAM) {\n\t\t\t\tcompressionType_ = CompressionType::NONE;\n\t\t\t\tfp_ = fdopen(fd, \"rb\");\n\t\t\t} else {\n\t\t\t\t// always assume that data from stdin is compressed\n\t\t\t\tcompressionType_ = CompressionType::GZIP;\n\t\t\t\tzfp_ = gzdopen(fd, \"rb\");\n\n\t\t\t\tif (zfp_ == NULL) {\n\t\t\t\t\tclose(fd);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char* filename = infiles_[filecur_].c_str();\n\n\t\t\tint fd = ::open(filename, O_RDONLY);\n\t\t\tbool is_fifo = false;\n\n#ifndef _WIN32\n\t\t\tstruct stat st;\n\t\t\tif (fstat(fd, &st) != 0) {\n\t\t\t\tperror(\"stat\");\n\t\t\t}\n\n\t\t\tis_fifo = S_ISFIFO(st.st_mode) != 0;\n#endif\n#define CHECK_ERROR(exp) ((exp) == NULL) ? true : false\n\n\t\t\tbool err = false;\n                        if (pp_.format == BAM) {\n\t\t\t\terr = CHECK_ERROR(fp_ = fdopen(fd, \"rb\"));\n\t\t\t\tcompressionType_ = CompressionType::NONE;\n                        } else if (is_fifo) {\n\t\t\t\terr = CHECK_ERROR(zfp_ = gzdopen(fd, \"rb\"));\n\t\t\t\tcompressionType_ = CompressionType::GZIP;\n                        } else if (is_gzipped_file(fd)) {\n\t\t\t\terr = CHECK_ERROR(zfp_ = gzdopen(fd, \"rb\"));\n\t\t\t\tcompressionType_ = CompressionType::GZIP;\n#ifdef WITH_ZSTD\n                        } else if (is_zstd_file(fd)) {\n\t\t\t\terr = CHECK_ERROR(zstdfp_ = zstdFdOpen(fd));\n\t\t\t\tcompressionType_ = CompressionType::ZSTD;\n#endif\n                        } else {\n\t\t\t\terr = CHECK_ERROR(fp_ = fdopen(fd, \"r\"));\n\t\t\t\tcompressionType_ = CompressionType::NONE;\n                        }\n\n\t\t\tif(err) {\n\t\t\t\tif (fd != -1) {\n\t\t\t\t\tclose(fd);\n\t\t\t\t}\n\n\t\t\t\tif(!errs_[filecur_]) {\n\t\t\t\t\tcerr << \"Warning: Could not open read file \\\"\"\n\t\t\t\t\t     << filename\n\t\t\t\t\t     << \"\\\" for reading; skipping...\" << endl;\n\t\t\t\t\terrs_[filecur_] = true;\n\t\t\t\t}\n\t\t\t\tfilecur_++;\n\t\t\t\tcompressionType_ = CompressionType::NONE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tis_open_ = true;\n\t\tif (compressionType_ == CompressionType::GZIP) {\n#if ZLIB_VERNUM < 0x1235\n\t\t\tcerr << \"Warning: gzbuffer added in zlib v1.2.3.5. Unable to change \"\n\t\t\t\t\"buffer size from default of 8192.\" << endl;\n#else\n\t\t\tgzbuffer(zfp_, 128*1024);\n#endif\n\t\t}\n\t\telse if (compressionType_ == CompressionType::NONE) {\n\t\t\tsetvbuf(fp_, buf_, _IOFBF, 64*1024);\n\t\t}\n\t\treturn;\n\t}\n\tcerr << \"Error: No input read files were valid\" << endl;\n\texit(1);\n\treturn;\n}", "idx": 603}
{"project": "bowtie2", "commit_id": "645_bowtie2_2.5.1_pat.cpp_BAMPatternSourcedecompress_bgzf_block.cpp", "target": 1, "func": "int BAMPatternSource::decompress_bgzf_block(uint8_t *dst, size_t dst_len, uint8_t *src, size_t src_len) {\n\tstream.zalloc = Z_NULL;\n\tstream.zfree = Z_NULL;\n\tstream.opaque = Z_NULL;\n\n\tstream.avail_in = src_len;\n\tstream.next_in = src;\n\tstream.avail_out = dst_len;\n\tstream.next_out = dst;\n\n\tint ret  = inflateInit2(&stream, -8);\n\tif (ret != Z_OK) {\n\t\treturn ret;\n\t}\n\n\tret = inflate(&stream, Z_FINISH);\n\tif (ret != Z_STREAM_END) {\n\t\treturn ret;\n\t}\n\n\treturn inflateReset(&stream);\n}", "idx": 604}
{"project": "bowtie2", "commit_id": "646_bowtie2_2.5.1_pat.cpp_DualPatternComposernextBatch.cpp", "target": 1, "func": "pair<bool, int> DualPatternComposer::nextBatch(PerThreadReadBuf& pt) {\n\t// 'cur' indexes the current pair of PatternSources\n\tsize_t cur = cur_;\n\twhile(cur < srca_->size()) {\n\t\tif((*srcb_)[cur] == NULL) {\n\t\t\t// Patterns from srca_ are unpaired\n\t\t\tpair<bool, int> res = (*srca_)[cur]->nextBatch(\n\t\t\t\tpt,\n\t\t\t\ttrue,  // batch A (or pairs)\n\t\t\t\tlock_); // grab lock below\n\t\t\tif(res.second == 0 && cur < srca_->size() - 1) {\n\t\t\t\tThreadSafe ts(mutex_m);\n\t\t\t\tif(cur + 1 > cur_) cur_++;\n\t\t\t\tcur = cur_; // Move on to next PatternSource\n\t\t\t\tcontinue; // on to next pair of PatternSources\n\t\t\t}\n\t\t\treturn make_pair(res.first && cur == srca_->size() - 1, res.second);\n\t\t} else {\n\t\t\tpair<bool, int> resa, resb;\n\t\t\t// Lock to ensure that this thread gets parallel reads\n\t\t\t// in the two mate files\n\t\t\t{\n\t\t\t\tThreadSafe ts(mutex_m);\n\t\t\t\tresa = (*srca_)[cur]->nextBatch(\n\t\t\t\t\tpt,\n\t\t\t\t\ttrue,   // batch A\n\t\t\t\t\tfalse); // don't grab lock below\n\t\t\t\tresb = (*srcb_)[cur]->nextBatch(\n\t\t\t\t\tpt,\n\t\t\t\t\tfalse,  // batch B\n\t\t\t\t\tfalse); // don't grab lock below\n\t\t\t\tassert_eq((*srca_)[cur]->readCount(),\n\t\t\t\t          (*srcb_)[cur]->readCount());\n\t\t\t}\n\t\t\tif(resa.second < resb.second) {\n\t\t\t\tcerr << \"Error, fewer reads in file specified with -1 \"\n\t\t\t\t     << \"than in file specified with -2\" << endl;\n\t\t\t\tthrow 1;\n\t\t\t} else if(resa.second == 0 && resb.second == 0) {\n\t\t\t\tThreadSafe ts(mutex_m);\n\t\t\t\tif(cur + 1 > cur_) {\n\t\t\t\t\tcur_++;\n\t\t\t\t}\n\t\t\t\tcur = cur_; // Move on to next PatternSource\n\t\t\t\tcontinue; // on to next pair of PatternSources\n\t\t\t} else if(resb.second < resa.second) {\n\t\t\t\tcerr << \"Error, fewer reads in file specified with -2 \"\n\t\t\t\t     << \"than in file specified with -1\" << endl;\n\t\t\t\tthrow 1;\n\t\t\t}\n\t\t\tassert_eq(resa.first, resb.first);\n\t\t\tassert_eq(resa.second, resb.second);\n\t\t\treturn make_pair(resa.first && cur == srca_->size() - 1, resa.second);\n\t\t}\n\t}\n\tassert_leq(cur, srca_->size());\n\treturn make_pair(true, 0);\n}", "idx": 605}
{"project": "bowtie2", "commit_id": "647_bowtie2_2.5.1_filebuf.h_writeAsync.cpp", "target": 1, "func": "static void writeAsync(AsyncData *asyncDataPtr) {\n\tAsyncData &asyncData = *asyncDataPtr;\n\tbool abort = false;\n\twhile(!abort) {\n\t\tabort = asyncData.waitForBuf();\n\t\tif(abort) break;\n\t\tif(asyncData.cur != fwrite((const void *)asyncData.buf, 1, asyncData.cur, asyncData.out)) {\n\t\t\tif (errno == EPIPE) {\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t}\n\t\t\tstd::cerr << \"Error while flushing and closing output\" << std::endl;\n\t\t\tthrow 1;\n\t\t}\n\t\tabort = asyncData.writeComplete();\n\t}\n\n}", "idx": 606}
{"project": "bowtie2", "commit_id": "648_bowtie2_2.5.1_aln_sink.cpp_AlnSinkWrapfinishRead.cpp", "target": 1, "func": "void AlnSinkWrap::finishRead(\n\tconst SeedResults *sr1,         // seed alignment results for mate 1\n\tconst SeedResults *sr2,         // seed alignment results for mate 2\n\tbool               exhaust1,    // mate 1 exhausted?\n\tbool               exhaust2,    // mate 2 exhausted?\n\tbool               nfilt1,      // mate 1 N-filtered?\n\tbool               nfilt2,      // mate 2 N-filtered?\n\tbool               scfilt1,     // mate 1 score-filtered?\n\tbool               scfilt2,     // mate 2 score-filtered?\n\tbool               lenfilt1,    // mate 1 length-filtered?\n\tbool               lenfilt2,    // mate 2 length-filtered?\n\tbool               qcfilt1,     // mate 1 qc-filtered?\n\tbool               qcfilt2,     // mate 2 qc-filtered?\n\tRandomSource&      rnd,         // pseudo-random generator\n\tReportingMetrics&  met,         // reporting metrics\n\tconst PerReadMetrics& prm,      // per-read metrics\n\tconst Scoring& sc,              // scoring scheme\n\tbool suppressSeedSummary,       // = true\n\tbool suppressAlignments,        // = false\n\tbool scUnMapped,                // = false\n\tbool xeq)                       // = false\n{\n\tobuf_.clear();\n\tOutputQueueMark qqm(g_.outq(), obuf_, rdid_, threadid_);\n\tassert(init_);\n\tif(!suppressSeedSummary) {\n\t\tif(sr1 != NULL) {\n\t\t\tassert(rd1_ != NULL);\n\t\t\t// Mate exists and has non-empty SeedResults\n\t\t\tg_.reportSeedSummary(obuf_, *rd1_, rdid_, threadid_, *sr1, true);\n\t\t} else if(rd1_ != NULL) {\n\t\t\t// Mate exists but has NULL SeedResults\n\t\t\tg_.reportEmptySeedSummary(obuf_, *rd1_, rdid_, true);\n\t\t}\n\t\tif(sr2 != NULL) {\n\t\t\tassert(rd2_ != NULL);\n\t\t\t// Mate exists and has non-empty SeedResults\n\t\t\tg_.reportSeedSummary(obuf_, *rd2_, rdid_, threadid_, *sr2, true);\n\t\t} else if(rd2_ != NULL) {\n\t\t\t// Mate exists but has NULL SeedResults\n\t\t\tg_.reportEmptySeedSummary(obuf_, *rd2_, rdid_, true);\n\t\t}\n\t}\n\tif(!suppressAlignments) {\n\t\t// Ask the ReportingState what to report\n\t\tst_.finish();\n\t\tuint64_t nconcord = 0, ndiscord = 0, nunpair1 = 0, nunpair2 = 0;\n\t\tbool pairMax = false, unpair1Max = false, unpair2Max = false;\n\t\tst_.getReport(\n\t\t\tnconcord,\n\t\t\tndiscord,\n\t\t\tnunpair1,\n\t\t\tnunpair2,\n\t\t\tpairMax,\n\t\t\tunpair1Max,\n\t\t\tunpair2Max);\n\t\tassert_leq(nconcord, rs1_.size());\n\t\tassert_leq(nunpair1, rs1u_.size());\n\t\tassert_leq(nunpair2, rs2u_.size());\n\t\tassert_leq(ndiscord, 1);\n\t\tassert_gt(rp_.khits, 0);\n\t\tassert_gt(rp_.mhits, 0);\n\t\tassert(!pairMax    || rs1_.size()  >= (uint64_t)rp_.mhits);\n\t\tassert(!unpair1Max || rs1u_.size() >= (uint64_t)rp_.mhits);\n\t\tassert(!unpair2Max || rs2u_.size() >= (uint64_t)rp_.mhits);\n\t\tmet.nread++;\n\t\tif(readIsPair()) {\n\t\t\tmet.npaired++;\n\t\t} else {\n\t\t\tmet.nunpaired++;\n\t\t}\n\t\t// Report concordant paired-end alignments if possible\n\t\tif(nconcord > 0) {\n\t\t\tAlnSetSumm concordSumm(\n\t\t\t\trd1_, rd2_, &rs1_, &rs2_, &rs1u_, &rs2u_,\n\t\t\t\texhaust1, exhaust2, -1, -1);\n\t\t\t// Sort by score then pick from low to high\n\t\t\tAlnScore bestUScore, bestP1Score, bestP2Score, bestCScore;\n\t\t\tAlnScore bestUDist, bestP1Dist, bestP2Dist, bestCDist;\n\t\t\tAlnScore bestUnchosenUScore, bestUnchosenP1Score, bestUnchosenP2Score, bestUnchosenCScore;\n\t\t\tAlnScore bestUnchosenUDist, bestUnchosenP1Dist, bestUnchosenP2Dist, bestUnchosenCDist;\n\t\t\t// TODO: should probably package these variables up so it's not\n\t\t\t// such a pain to pass them around\n\t\t\tsize_t off = selectByScore(\n\t\t\t\t&rs1_, &rs2_,\n\t\t\t\tnconcord, select1_,\n\t\t\t\t&rs1u_, &rs2u_,\n\t\t\t\tbestUScore,\n\t\t\t\tbestUDist,\n\t\t\t\tbestP1Score,\n\t\t\t\tbestP1Dist,\n\t\t\t\tbestP2Score,\n\t\t\t\tbestP2Dist,\n\t\t\t\tbestCScore,\n\t\t\t\tbestCDist,\n\t\t\t\tbestUnchosenUScore,\n\t\t\t\tbestUnchosenUDist,\n\t\t\t\tbestUnchosenP1Score,\n\t\t\t\tbestUnchosenP1Dist,\n\t\t\t\tbestUnchosenP2Score,\n\t\t\t\tbestUnchosenP2Dist,\n\t\t\t\tbestUnchosenCScore,\n\t\t\t\tbestUnchosenCDist,\n\t\t\t\trnd);\n\t\t\tconcordSumm.setBest(\n\t\t\t\tbestUScore,\n\t\t\t\tbestUDist,\n\t\t\t\tbestP1Score,\n\t\t\t\tbestP1Dist,\n\t\t\t\tbestP2Score,\n\t\t\t\tbestP2Dist,\n\t\t\t\tbestCScore,\n\t\t\t\tbestCDist,\n\t\t\t\tbestUnchosenUScore,\n\t\t\t\tbestUnchosenUDist,\n\t\t\t\tbestUnchosenP1Score,\n\t\t\t\tbestUnchosenP1Dist,\n\t\t\t\tbestUnchosenP2Score,\n\t\t\t\tbestUnchosenP2Dist,\n\t\t\t\tbestUnchosenCScore,\n\t\t\t\tbestUnchosenCDist);\n\t\t\tassert(concordSumm.bestScore(true).valid());\n\t\t\tassert(concordSumm.bestScore(false).valid());\n\t\t\tassert_lt(off, rs1_.size());\n\t\t\tconst AlnRes *rs1 = &rs1_[off];\n\t\t\tconst AlnRes *rs2 = &rs2_[off];\n\t\t\tAlnFlags flags1(\n\t\t\t\tALN_FLAG_PAIR_CONCORD_MATE1,\n\t\t\t\tst_.params().mhitsSet(),\n\t\t\t\tunpair1Max,\n\t\t\t\tpairMax,\n\t\t\t\tnfilt1,\n\t\t\t\tscfilt1,\n\t\t\t\tlenfilt1,\n\t\t\t\tqcfilt1,\n\t\t\t\tst_.params().mixed,\n\t\t\t\ttrue,       // primary\n\t\t\t\ttrue,       // opp aligned\n\t\t\t\trs2->fw(),  // opp fw\n\t\t\t\tscUnMapped,\n\t\t\t\txeq);\n\t\t\tAlnFlags flags2(\n\t\t\t\tALN_FLAG_PAIR_CONCORD_MATE2,\n\t\t\t\tst_.params().mhitsSet(),\n\t\t\t\tunpair2Max,\n\t\t\t\tpairMax,\n\t\t\t\tnfilt2,\n\t\t\t\tscfilt2,\n\t\t\t\tlenfilt2,\n\t\t\t\tqcfilt2,\n\t\t\t\tst_.params().mixed,\n\t\t\t\tfalse,      // primary\n\t\t\t\ttrue,       // opp aligned\n\t\t\t\trs1->fw(),  // opp fw\n\t\t\t\tscUnMapped,\n\t\t\t\txeq);\n\t\t\t// Issue: we only set the flags once, but some of the flags might\n\t\t\t// vary from pair to pair among the pairs we're reporting.  For\n\t\t\t// instance, whether the a given mate aligns to the forward strand.\n\t\t\tSeedAlSumm ssm1, ssm2;\n\t\t\tsr1->toSeedAlSumm(ssm1);\n\t\t\tsr2->toSeedAlSumm(ssm2);\n\t\t\tfor(size_t i = 0; i < rs1_.size(); i++) {\n\t\t\t\trs1_[i].setMateParams(ALN_RES_TYPE_MATE1, &rs2_[i], flags1);\n\t\t\t\trs2_[i].setMateParams(ALN_RES_TYPE_MATE2, &rs1_[i], flags2);\n\t\t\t\tassert_eq(abs(rs1_[i].fragmentLength()), abs(rs2_[i].fragmentLength()));\n\t\t\t}\n\t\t\tassert(!select1_.empty());\n\t\t\tg_.reportHits(\n\t\t\t\tobuf_,\n\t\t\t\tstaln_,\n\t\t\t\tthreadid_,\n\t\t\t\trd1_,\n\t\t\t\trd2_,\n\t\t\t\trdid_,\n\t\t\t\tselect1_,\n\t\t\t\tNULL,\n\t\t\t\t&rs1_,\n\t\t\t\t&rs2_,\n\t\t\t\tpairMax,\n\t\t\t\tconcordSumm,\n\t\t\t\tssm1,\n\t\t\t\tssm2,\n\t\t\t\t&flags1,\n\t\t\t\t&flags2,\n\t\t\t\tprm,\n\t\t\t\tmapq_,\n\t\t\t\tsc,\n\t\t\t\tfalse);\n\t\t\tif(pairMax) {\n\t\t\t\tmet.nconcord_rep++;\n\t\t\t} else {\n\t\t\t\tmet.nconcord_uni++;\n\t\t\t\tassert(!rs1_.empty());\n\t\t\t\tAlnScore sc1 = concordSumm.bestUnchosenP1Score();\n\t\t\t\tAlnScore sc2 = concordSumm.bestUnchosenP2Score();\n\t\t\t\tif(!sc1.valid() && !sc2.valid()) {\n\t\t\t\t\tmet.nconcord_uni1++;\n\t\t\t\t} else {\n\t\t\t\t\tmet.nconcord_uni2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinit_ = false;\n\t\t\t//g_.outq().finishRead(obuf_, rdid_, threadid_);\n\t\t\treturn;\n\t\t}\n\t\t// Report disconcordant paired-end alignments if possible\n\t\telse if(ndiscord > 0) {\n\t\t\tASSERT_ONLY(bool ret =) prepareDiscordants();\n\t\t\tassert(ret);\n\t\t\tassert_eq(1, rs1_.size());\n\t\t\tassert_eq(1, rs2_.size());\n\t\t\tAlnSetSumm discordSumm(\n\t\t\t\trd1_, rd2_, &rs1_, &rs2_, &rs1u_, &rs2u_,\n\t\t\t\texhaust1, exhaust2, -1, -1);\n\t\t\tconst AlnRes *rs1 = &rs1_[0];\n\t\t\tconst AlnRes *rs2 = &rs2_[0];\n\t\t\tAlnFlags flags1(\n\t\t\t\tALN_FLAG_PAIR_DISCORD_MATE1,\n\t\t\t\tst_.params().mhitsSet(),\n\t\t\t\tfalse,\n\t\t\t\tpairMax,\n\t\t\t\tnfilt1,\n\t\t\t\tscfilt1,\n\t\t\t\tlenfilt1,\n\t\t\t\tqcfilt1,\n\t\t\t\tst_.params().mixed,\n\t\t\t\ttrue,       // primary\n\t\t\t\ttrue,       // opp aligned\n\t\t\t\trs2->fw(),  // opp fw\n\t\t\t\tscUnMapped,\n\t\t\t\txeq);\n\t\t\tAlnFlags flags2(\n\t\t\t\tALN_FLAG_PAIR_DISCORD_MATE2,\n\t\t\t\tst_.params().mhitsSet(),\n\t\t\t\tfalse,\n\t\t\t\tpairMax,\n\t\t\t\tnfilt2,\n\t\t\t\tscfilt2,\n\t\t\t\tlenfilt2,\n\t\t\t\tqcfilt2,\n\t\t\t\tst_.params().mixed,\n\t\t\t\tfalse,      // primary\n\t\t\t\ttrue,       // opp aligned\n\t\t\t\trs1->fw(),  // opp fw\n\t\t\t\tscUnMapped,\n\t\t\t\txeq);\n\t\t\tSeedAlSumm ssm1, ssm2;\n\t\t\tsr1->toSeedAlSumm(ssm1);\n\t\t\tsr2->toSeedAlSumm(ssm2);\n\t\t\tfor(size_t i = 0; i < rs1_.size(); i++) {\n\t\t\t\trs1_[i].setMateParams(ALN_RES_TYPE_MATE1, &rs2_[i], flags1);\n\t\t\t\trs2_[i].setMateParams(ALN_RES_TYPE_MATE2, &rs1_[i], flags2);\n\t\t\t\tassert(rs1_[i].isFraglenSet() == rs2_[i].isFraglenSet());\n\t\t\t\tassert(!rs1_[i].isFraglenSet() || abs(rs1_[i].fragmentLength()) == abs(rs2_[i].fragmentLength()));\n\t\t\t}\n\t\t\tAlnScore bestUScore, bestP1Score, bestP2Score, bestCScore;\n\t\t\tAlnScore bestUDist, bestP1Dist, bestP2Dist, bestCDist;\n\t\t\tAlnScore bestUnchosenUScore, bestUnchosenP1Score, bestUnchosenP2Score, bestUnchosenCScore;\n\t\t\tAlnScore bestUnchosenUDist, bestUnchosenP1Dist, bestUnchosenP2Dist, bestUnchosenCDist;\n\t\t\tASSERT_ONLY(size_t off =) selectByScore(\n\t\t\t\t&rs1_, &rs2_,\n\t\t\t\tndiscord, select1_,\n\t\t\t\t&rs1u_, &rs2u_,\n\t\t\t\tbestUScore,\n\t\t\t\tbestUDist,\n\t\t\t\tbestP1Score,\n\t\t\t\tbestP1Dist,\n\t\t\t\tbestP2Score,\n\t\t\t\tbestP2Dist,\n\t\t\t\tbestCScore,\n\t\t\t\tbestCDist,\n\t\t\t\tbestUnchosenUScore,\n\t\t\t\tbestUnchosenUDist,\n\t\t\t\tbestUnchosenP1Score,\n\t\t\t\tbestUnchosenP1Dist,\n\t\t\t\tbestUnchosenP2Score,\n\t\t\t\tbestUnchosenP2Dist,\n\t\t\t\tbestUnchosenCScore,\n\t\t\t\tbestUnchosenCDist,\n\t\t\t\trnd);\n\t\t\tdiscordSumm.setBest(\n\t\t\t\tbestUScore,\n\t\t\t\tbestUDist,\n\t\t\t\tbestP1Score,\n\t\t\t\tbestP1Dist,\n\t\t\t\tbestP2Score,\n\t\t\t\tbestP2Dist,\n\t\t\t\tbestCScore,\n\t\t\t\tbestCDist,\n\t\t\t\tbestUnchosenUScore,\n\t\t\t\tbestUnchosenUDist,\n\t\t\t\tbestUnchosenP1Score,\n\t\t\t\tbestUnchosenP1Dist,\n\t\t\t\tbestUnchosenP2Score,\n\t\t\t\tbestUnchosenP2Dist,\n\t\t\t\tbestUnchosenCScore,\n\t\t\t\tbestUnchosenCDist);\n\t\t\tassert_eq(0, off);\n\t\t\tassert(!select1_.empty());\n\t\t\tg_.reportHits(\n\t\t\t\tobuf_,\n\t\t\t\tstaln_,\n\t\t\t\tthreadid_,\n\t\t\t\trd1_,\n\t\t\t\trd2_,\n\t\t\t\trdid_,\n\t\t\t\tselect1_,\n\t\t\t\tNULL,\n\t\t\t\t&rs1_,\n\t\t\t\t&rs2_,\n\t\t\t\tpairMax,\n\t\t\t\tdiscordSumm,\n\t\t\t\tssm1,\n\t\t\t\tssm2,\n\t\t\t\t&flags1,\n\t\t\t\t&flags2,\n\t\t\t\tprm,\n\t\t\t\tmapq_,\n\t\t\t\tsc,\n\t\t\t\tfalse);\n\t\t\tmet.nconcord_0++;\n\t\t\tmet.ndiscord++;\n\t\t\tinit_ = false;\n\t\t\t//g_.outq().finishRead(obuf_, rdid_, threadid_);\n\t\t\treturn;\n\t\t}\n\t\t// If we're at this point, at least one mate failed to align.\n\t\t// BTL: That's not true.  It could be that there are no concordant\n\t\t// alignments but both mates have unpaired alignments, with one of\n\t\t// the mates having more than one.\n\t\t//assert(nunpair1 == 0 || nunpair2 == 0);\n\t\tassert(!pairMax);\n\n\t\t// Update counters given that one mate didn't align\n\t\tif(readIsPair()) {\n\t\t\tmet.nconcord_0++;\n\t\t}\n\t\tif(rd1_ != NULL) {\n\t\t\tif(nunpair1 > 0) {\n\t\t\t\t// Update counters\n\t\t\t\tif(readIsPair()) {\n\t\t\t\t\tif(unpair1Max) met.nunp_0_rep++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tmet.nunp_0_uni++;\n\t\t\t\t\t\tassert(!rs1u_.empty());\n\t\t\t\t\t\tif(rs1u_.size() == 1) {\n\t\t\t\t\t\t\tmet.nunp_0_uni1++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmet.nunp_0_uni2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(unpair1Max) met.nunp_rep++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tmet.nunp_uni++;\n\t\t\t\t\t\tassert(!rs1u_.empty());\n\t\t\t\t\t\tif(rs1u_.size() == 1) {\n\t\t\t\t\t\t\tmet.nunp_uni1++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmet.nunp_uni2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(unpair1Max) {\n\t\t\t\t// Update counters\n\t\t\t\tif(readIsPair())   met.nunp_0_rep++;\n\t\t\t\telse               met.nunp_rep++;\n\t\t\t} else {\n\t\t\t\t// Update counters\n\t\t\t\tif(readIsPair())   met.nunp_0_0++;\n\t\t\t\telse               met.nunp_0++;\n\t\t\t}\n\t\t}\n\t\tif(rd2_ != NULL) {\n\t\t\tif(nunpair2 > 0) {\n\t\t\t\t// Update counters\n\t\t\t\tif(readIsPair()) {\n\t\t\t\t\tif(unpair2Max) met.nunp_0_rep++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tassert(!rs2u_.empty());\n\t\t\t\t\t\tmet.nunp_0_uni++;\n\t\t\t\t\t\tif(rs2u_.size() == 1) {\n\t\t\t\t\t\t\tmet.nunp_0_uni1++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmet.nunp_0_uni2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(unpair2Max) met.nunp_rep++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tassert(!rs2u_.empty());\n\t\t\t\t\t\tmet.nunp_uni++;\n\t\t\t\t\t\tif(rs2u_.size() == 1) {\n\t\t\t\t\t\t\tmet.nunp_uni1++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmet.nunp_uni2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(unpair2Max) {\n\t\t\t\t// Update counters\n\t\t\t\tif(readIsPair())   met.nunp_0_rep++;\n\t\t\t\telse               met.nunp_rep++;\n\t\t\t} else {\n\t\t\t\t// Update counters\n\t\t\t\tif(readIsPair())   met.nunp_0_0++;\n\t\t\t\telse               met.nunp_0++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tconst AlnRes *repRs1 = NULL, *repRs2 = NULL;\n\t\tAlnSetSumm summ1, summ2;\n\t\tAlnFlags flags1, flags2;\n\t\tTRefId refid = -1; TRefOff refoff = -1;\n\t\tbool rep1 = rd1_ != NULL && nunpair1 > 0;\n\t\tbool rep2 = rd2_ != NULL && nunpair2 > 0;\n\n\t\t// This is the preliminary if statement for mate 1 - here we're\n\t\t// gathering some preliminary information, making it possible to call\n\t\t// g_.reportHits(...) with information about both mates potentially\n\t\tif(rep1) {\n\t\t\t// Mate 1 aligned at least once\n\t\t\tsumm1.init(\n\t\t\t\trd1_, NULL, NULL, NULL, &rs1u_, NULL,\n\t\t\t\texhaust1, exhaust2, -1, -1);\n\t\t\t// Sort by score then pick from low to high\n\t\t\tAlnScore bestUScore, bestP1Score, bestP2Score, bestCScore;\n\t\t\tAlnScore bestUDist, bestP1Dist, bestP2Dist, bestCDist;\n\t\t\tAlnScore bestUnchosenUScore, bestUnchosenP1Score, bestUnchosenP2Score, bestUnchosenCScore;\n\t\t\tAlnScore bestUnchosenUDist, bestUnchosenP1Dist, bestUnchosenP2Dist, bestUnchosenCDist;\n\t\t\tsize_t off = selectByScore(\n\t\t\t\t&rs1u_, NULL, nunpair1, select1_, NULL, NULL,\n\t\t\t\tbestUScore,\n\t\t\t\tbestUDist,\n\t\t\t\tbestP1Score,\n\t\t\t\tbestP1Dist,\n\t\t\t\tbestP2Score,\n\t\t\t\tbestP2Dist,\n\t\t\t\tbestCScore,\n\t\t\t\tbestCDist,\n\t\t\t\tbestUnchosenUScore,\n\t\t\t\tbestUnchosenUDist,\n\t\t\t\tbestUnchosenP1Score,\n\t\t\t\tbestUnchosenP1Dist,\n\t\t\t\tbestUnchosenP2Score,\n\t\t\t\tbestUnchosenP2Dist,\n\t\t\t\tbestUnchosenCScore,\n\t\t\t\tbestUnchosenCDist,\n\t\t\t\trnd);\n\t\t\tsumm1.setBest(\n\t\t\t\tbestUScore,\n\t\t\t\tbestUDist,\n\t\t\t\tbestP1Score,\n\t\t\t\tbestP1Dist,\n\t\t\t\tbestP2Score,\n\t\t\t\tbestP2Dist,\n\t\t\t\tbestCScore,\n\t\t\t\tbestCDist,\n\t\t\t\tbestUnchosenUScore,\n\t\t\t\tbestUnchosenUDist,\n\t\t\t\tbestUnchosenP1Score,\n\t\t\t\tbestUnchosenP1Dist,\n\t\t\t\tbestUnchosenP2Score,\n\t\t\t\tbestUnchosenP2Dist,\n\t\t\t\tbestUnchosenCScore,\n\t\t\t\tbestUnchosenCDist);\n\t\t\trepRs1 = &rs1u_[off];\n\t\t} else if(rd1_ != NULL) {\n\t\t\t// Mate 1 failed to align - don't do anything yet.  First we want\n\t\t\t// to collect information on mate 2 in case that factors into the\n\t\t\t// summary\n\t\t\tassert(!unpair1Max);\n\t\t}\n\t\t\n\t\tif(rep2) {\n\t\t\tsumm2.init(\n\t\t\t\tNULL, rd2_, NULL, NULL, NULL, &rs2u_,\n\t\t\t\texhaust1, exhaust2, -1, -1);\n\t\t\t// Sort by score then pick from low to high\n\t\t\tAlnScore bestUScore, bestP1Score, bestP2Score, bestCScore;\n\t\t\tAlnScore bestUDist, bestP1Dist, bestP2Dist, bestCDist;\n\t\t\tAlnScore bestUnchosenUScore, bestUnchosenP1Score, bestUnchosenP2Score, bestUnchosenCScore;\n\t\t\tAlnScore bestUnchosenUDist, bestUnchosenP1Dist, bestUnchosenP2Dist, bestUnchosenCDist;\n\t\t\tsize_t off = selectByScore(\n\t\t\t\t&rs2u_, NULL, nunpair2, select2_, NULL, NULL,\n\t\t\t\tbestUScore,\n\t\t\t\tbestUDist,\n\t\t\t\tbestP1Score,\n\t\t\t\tbestP1Dist,\n\t\t\t\tbestP2Score,\n\t\t\t\tbestP2Dist,\n\t\t\t\tbestCScore,\n\t\t\t\tbestCDist,\n\t\t\t\tbestUnchosenUScore,\n\t\t\t\tbestUnchosenUDist,\n\t\t\t\tbestUnchosenP1Score,\n\t\t\t\tbestUnchosenP1Dist,\n\t\t\t\tbestUnchosenP2Score,\n\t\t\t\tbestUnchosenP2Dist,\n\t\t\t\tbestUnchosenCScore,\n\t\t\t\tbestUnchosenCDist,\n\t\t\t\trnd);\n\t\t\tsumm2.setBest(\n\t\t\t\tbestUScore,\n\t\t\t\tbestUDist,\n\t\t\t\tbestP1Score,\n\t\t\t\tbestP1Dist,\n\t\t\t\tbestP2Score,\n\t\t\t\tbestP2Dist,\n\t\t\t\tbestCScore,\n\t\t\t\tbestCDist,\n\t\t\t\tbestUnchosenUScore,\n\t\t\t\tbestUnchosenUDist,\n\t\t\t\tbestUnchosenP1Score,\n\t\t\t\tbestUnchosenP1Dist,\n\t\t\t\tbestUnchosenP2Score,\n\t\t\t\tbestUnchosenP2Dist,\n\t\t\t\tbestUnchosenCScore,\n\t\t\t\tbestUnchosenCDist);\n\t\t\trepRs2 = &rs2u_[off];\n\t\t} else if(rd2_ != NULL) {\n\t\t\t// Mate 2 failed to align - don't do anything yet.  First we want\n\t\t\t// to collect information on mate 1 in case that factors into the\n\t\t\t// summary\n\t\t\tassert(!unpair2Max);\n\t\t}\n\n\t\t// Now set up flags\n\t\tif(rep1) {\n\t\t\t// Initialize flags.  Note: We want to have information about how\n\t\t\t// the other mate aligned (if it did) at this point\n\t\t\tflags1.init(\n\t\t\t\treadIsPair() ?\n\t\t\t\t\tALN_FLAG_PAIR_UNPAIRED_MATE1 :\n\t\t\t\t\tALN_FLAG_PAIR_UNPAIRED,\n\t\t\t\tst_.params().mhitsSet(),\n\t\t\t\tunpair1Max,\n\t\t\t\tpairMax,\n\t\t\t\tnfilt1,\n\t\t\t\tscfilt1,\n\t\t\t\tlenfilt1,\n\t\t\t\tqcfilt1,\n\t\t\t\tst_.params().mixed,\n\t\t\t\ttrue,   // primary\n\t\t\t\trepRs2 != NULL,                    // opp aligned\n\t\t\t\trepRs2 == NULL || repRs2->fw(),    // opp fw\n\t\t\t\tscUnMapped,\n\t\t\t\txeq);\n\t\t\tfor(size_t i = 0; i < rs1u_.size(); i++) {\n\t\t\t\trs1u_[i].setMateParams(ALN_RES_TYPE_UNPAIRED_MATE1, NULL, flags1);\n\t\t\t}\n\t\t}\n\t\tif(rep2) {\n\t\t\t// Initialize flags.  Note: We want to have information about how\n\t\t\t// the other mate aligned (if it did) at this point\n\t\t\tflags2.init(\n\t\t\t\treadIsPair() ?\n\t\t\t\t\tALN_FLAG_PAIR_UNPAIRED_MATE2 :\n\t\t\t\t\tALN_FLAG_PAIR_UNPAIRED,\n\t\t\t\tst_.params().mhitsSet(),\n\t\t\t\tunpair2Max,\n\t\t\t\tpairMax,\n\t\t\t\tnfilt2,\n\t\t\t\tscfilt2,\n\t\t\t\tlenfilt2,\n\t\t\t\tqcfilt2,\n\t\t\t\tst_.params().mixed,\n\t\t\t\ttrue,   // primary\n\t\t\t\trepRs1 != NULL,                  // opp aligned\n\t\t\t\trepRs1 == NULL || repRs1->fw(),  // opp fw\n\t\t\t\tscUnMapped,\n\t\t\t\txeq);\n\t\t\tfor(size_t i = 0; i < rs2u_.size(); i++) {\n\t\t\t\trs2u_[i].setMateParams(ALN_RES_TYPE_UNPAIRED_MATE2, NULL, flags2);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Now report mate 1\n\t\tif(rep1) {\n\t\t\tSeedAlSumm ssm1, ssm2;\n\t\t\tif(sr1 != NULL) sr1->toSeedAlSumm(ssm1);\n\t\t\tif(sr2 != NULL) sr2->toSeedAlSumm(ssm2);\n\t\t\tassert(!select1_.empty());\n\t\t\tg_.reportHits(\n\t\t\t\tobuf_,\n\t\t\t\tstaln_,\n\t\t\t\tthreadid_,\n\t\t\t\trd1_,\n\t\t\t\trepRs2 != NULL ? rd2_ : NULL,\n\t\t\t\trdid_,\n\t\t\t\tselect1_,\n\t\t\t\trepRs2 != NULL ? &select2_ : NULL,\n\t\t\t\t&rs1u_,\n\t\t\t\trepRs2 != NULL ? &rs2u_ : NULL,\n\t\t\t\tunpair1Max,\n\t\t\t\tsumm1,\n\t\t\t\tssm1,\n\t\t\t\tssm2,\n\t\t\t\t&flags1,\n\t\t\t\trepRs2 != NULL ? &flags2 : NULL,\n\t\t\t\tprm,\n\t\t\t\tmapq_,\n\t\t\t\tsc,\n\t\t\t\tfalse);\n\t\t\tassert_lt(select1_[0], rs1u_.size());\n\t\t\trefid = rs1u_[select1_[0]].refid();\n\t\t\trefoff = rs1u_[select1_[0]].refoff();\n\t\t}\n\t\t\n\t\t// Now report mate 2\n\t\t//if(rep2 && !rep1) {\n\t\tif(rep2) {\n\t\t\tSeedAlSumm ssm1, ssm2;\n\t\t\tif(sr1 != NULL) sr1->toSeedAlSumm(ssm1);\n\t\t\tif(sr2 != NULL) sr2->toSeedAlSumm(ssm2);\n\t\t\tassert(!select2_.empty());\n\t\t\tg_.reportHits(\n\t\t\t\tobuf_,\n\t\t\t\tstaln_,\n\t\t\t\tthreadid_,\n\t\t\t\trd2_,\n\t\t\t\trepRs1 != NULL ? rd1_ : NULL,\n\t\t\t\trdid_,\n\t\t\t\tselect2_,\n\t\t\t\trepRs1 != NULL ? &select1_ : NULL,\n\t\t\t\t&rs2u_,\n\t\t\t\trepRs1 != NULL ? &rs1u_ : NULL,\n\t\t\t\tunpair2Max,\n\t\t\t\tsumm2,\n\t\t\t\tssm1,\n\t\t\t\tssm2,\n\t\t\t\t&flags2,\n\t\t\t\trepRs1 != NULL ? &flags1 : NULL,\n\t\t\t\tprm,\n\t\t\t\tmapq_,\n\t\t\t\tsc,\n\t\t\t\tfalse);\n\t\t\tassert_lt(select2_[0], rs2u_.size());\n\t\t\trefid = rs2u_[select2_[0]].refid();\n\t\t\trefoff = rs2u_[select2_[0]].refoff();\n\t\t}\n\t\t\n\t\tif(rd1_ != NULL && nunpair1 == 0) {\n\t\t\tif(nunpair2 > 0) {\n\t\t\t\tassert_neq(-1, refid);\n\t\t\t\tsumm1.init(\n\t\t\t\t\trd1_, NULL, NULL, NULL, NULL, NULL,\n\t\t\t\t\texhaust1, exhaust2, refid, refoff);\n\t\t\t} else {\n\t\t\t\tsumm1.init(\n\t\t\t\t\trd1_, NULL, NULL, NULL, NULL, NULL,\n\t\t\t\t\texhaust1, exhaust2, -1, -1);\n\t\t\t}\n\t\t\tSeedAlSumm ssm1, ssm2;\n\t\t\tif(sr1 != NULL) sr1->toSeedAlSumm(ssm1);\n\t\t\tif(sr2 != NULL) sr2->toSeedAlSumm(ssm2);\n\t\t\tflags1.init(\n\t\t\t\treadIsPair() ?\n\t\t\t\t\tALN_FLAG_PAIR_UNPAIRED_MATE1 :\n\t\t\t\t\tALN_FLAG_PAIR_UNPAIRED,\n\t\t\t\tst_.params().mhitsSet(),\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\tnfilt1,\n\t\t\t\tscfilt1,\n\t\t\t\tlenfilt1,\n\t\t\t\tqcfilt1,\n\t\t\t\tst_.params().mixed,\n\t\t\t\ttrue,           // primary\n\t\t\t\trepRs2 != NULL, // opp aligned\n\t\t\t\t(repRs2 != NULL) ? repRs2->fw() : false, // opp fw\n\t\t\t\tscUnMapped,\n\t\t\t\txeq);\n\t\t\tg_.reportUnaligned(\n\t\t\t\tobuf_,      // string to write output to\n\t\t\t\tstaln_,\n\t\t\t\tthreadid_,\n\t\t\t\trd1_,    // read 1\n\t\t\t\tNULL,    // read 2\n\t\t\t\trdid_,   // read id\n\t\t\t\tsumm1,   // summ\n\t\t\t\tssm1,    // \n\t\t\t\tssm2,\n\t\t\t\t&flags1, // flags 1\n\t\t\t\tNULL,    // flags 2\n\t\t\t\tprm,     // per-read metrics\n\t\t\t\tmapq_,   // MAPQ calculator\n\t\t\t\tsc,      // scoring scheme\n\t\t\t\ttrue);   // get lock?\n\t\t}\n\t\tif(rd2_ != NULL && nunpair2 == 0) {\n\t\t\tif(nunpair1 > 0) {\n\t\t\t\tassert_neq(-1, refid);\n\t\t\t\tsumm2.init(\n\t\t\t\t\tNULL, rd2_, NULL, NULL, NULL, NULL,\n\t\t\t\t\texhaust1, exhaust2, refid, refoff);\n\t\t\t} else {\n\t\t\t\tsumm2.init(\n\t\t\t\t\tNULL, rd2_, NULL, NULL, NULL, NULL,\n\t\t\t\t\texhaust1, exhaust2, -1, -1);\n\t\t\t}\n\t\t\tSeedAlSumm ssm1, ssm2;\n\t\t\tif(sr1 != NULL) sr1->toSeedAlSumm(ssm1);\n\t\t\tif(sr2 != NULL) sr2->toSeedAlSumm(ssm2);\n\t\t\tflags2.init(\n\t\t\t\treadIsPair() ?\n\t\t\t\t\tALN_FLAG_PAIR_UNPAIRED_MATE2 :\n\t\t\t\t\tALN_FLAG_PAIR_UNPAIRED,\n\t\t\t\tst_.params().mhitsSet(),\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\tnfilt2,\n\t\t\t\tscfilt2,\n\t\t\t\tlenfilt2,\n\t\t\t\tqcfilt2,\n\t\t\t\tst_.params().mixed,\n\t\t\t\ttrue,           // primary\n\t\t\t\trepRs1 != NULL, // opp aligned\n\t\t\t\t(repRs1 != NULL) ? repRs1->fw() : false, // opp fw\n\t\t\t\tscUnMapped,\n\t\t\t\txeq);\n\t\t\tg_.reportUnaligned(\n\t\t\t\tobuf_,      // string to write output to\n\t\t\t\tstaln_,\n\t\t\t\tthreadid_,\n\t\t\t\trd2_,    // read 1\n\t\t\t\tNULL,    // read 2\n\t\t\t\trdid_,   // read id\n\t\t\t\tsumm2,   // summ\n\t\t\t\tssm1,\n\t\t\t\tssm2,\n\t\t\t\t&flags2, // flags 1\n\t\t\t\tNULL,    // flags 2\n\t\t\t\tprm,     // per-read metrics\n\t\t\t\tmapq_,   // MAPQ calculator\n\t\t\t\tsc,      // scoring scheme\n\t\t\t\ttrue);   // get lock?\n\t\t}\n\t} // if(suppress alignments)\n\tinit_ = false;\n\treturn;\n}", "idx": 607}
{"project": "bowtie2", "commit_id": "64_bowtie2_2.5.1_aligner_seed.h_nextRead.cpp", "target": 0, "func": "void nextRead(const Read& read) {\n\t\tread_ = &read;\n\t}", "idx": 608}
{"project": "bowtie2", "commit_id": "65_bowtie2_2.5.1_aligner_seed.h_clearSeeds.cpp", "target": 0, "func": "void clearSeeds() {\n\t\tsortedFw_.clear();\n\t\tsortedRc_.clear();\n\t\trankOffs_.clear();\n\t\trankFws_.clear();\n\t\toffIdx2off_.clear();\n\t\thitsFw_.clear();\n\t\thitsRc_.clear();\n\t\tisFw_.clear();\n\t\tisRc_.clear();\n\t\tseqFw_.clear();\n\t\tseqRc_.clear();\n\t\tnonzTot_ = 0;\n\t\tuniTot_ = uniTotS_[0] = uniTotS_[1] = 0;\n\t\trepTot_ = repTotS_[0] = repTotS_[1] = 0;\n\t\tnonzFw_ = 0;\n\t\tnonzRc_ = 0;\n\t\tnumOffs_ = 0;\n\t\tnumRanges_ = 0;\n\t\tnumElts_ = 0;\n\t\tnumRangesFw_ = 0;\n\t\tnumEltsFw_ = 0;\n\t\tnumRangesRc_ = 0;\n\t\tnumEltsRc_ = 0;\n\t}", "idx": 609}
{"project": "bowtie2", "commit_id": "66_bowtie2_2.5.1_aligner_seed.h_clear.cpp", "target": 0, "func": "void clear() { cacheVec.clear(); }", "idx": 610}
{"project": "bowtie2", "commit_id": "67_bowtie2_2.5.1_aligner_seed.h_add1mmEe.cpp", "target": 0, "func": "void add1mmEe(\n\t\tTIndexOffU top,\n\t\tTIndexOffU bot,\n\t\tconst Edit* e1,\n\t\tconst Edit* e2,\n\t\tbool fw,\n\t\tint64_t score)\n\t{\n\t\tmm1Hit_.expand();\n\t\tmm1Hit_.back().init(top, bot, e1, e2, fw, score);\n\t\tmm1Elt_ += (bot - top);\n\t}", "idx": 611}
{"project": "bowtie2", "commit_id": "68_bowtie2_2.5.1_aligner_seed.h_addExactEeFw.cpp", "target": 0, "func": "void addExactEeFw(\n\t\tTIndexOffU top,\n\t\tTIndexOffU bot,\n\t\tconst Edit* e1,\n\t\tconst Edit* e2,\n\t\tbool fw,\n\t\tint64_t score)\n\t{\n\t\texactFwHit_.init(top, bot, e1, e2, fw, score);\n\t}", "idx": 612}
{"project": "bowtie2", "commit_id": "69_bowtie2_2.5.1_aligner_seed.h_addExactEeRc.cpp", "target": 0, "func": "void addExactEeRc(\n\t\tTIndexOffU top,\n\t\tTIndexOffU bot,\n\t\tconst Edit* e1,\n\t\tconst Edit* e2,\n\t\tbool fw,\n\t\tint64_t score)\n\t{\n\t\texactRcHit_.init(top, bot, e1, e2, fw, score);\n\t}", "idx": 613}
{"project": "bowtie2", "commit_id": "6_bowtie2_2.5.1_aligner_bt.h_best.cpp", "target": 0, "func": "size_t best(RandomSource& rnd) {\n\t\tassert(!empty());\n\t\tflushUnsorted();\n\t\tassert_gt(sortedSel_ ? sorted1_.size() : sorted2_.size(), cur_);\n\t\t// Perhaps shuffle everyone who's tied for first?\n\t\tsize_t id = sortedSel_ ? sorted1_[cur_] : sorted2_[cur_];\n\t\tcur_++;\n\t\treturn id;\n\t}", "idx": 614}
{"project": "bowtie2", "commit_id": "70_bowtie2_2.5.1_aligner_seed.h_clearExactE2eHits.cpp", "target": 0, "func": "void clearExactE2eHits() {\n\t\texactFwHit_.reset();\n\t\texactRcHit_.reset();\n\t}", "idx": 615}
{"project": "bowtie2", "commit_id": "71_bowtie2_2.5.1_aligner_seed.h_clear1mmE2eHits.cpp", "target": 0, "func": "void clear1mmE2eHits() {\n\t\tmm1Hit_.clear();     // 1-mismatch end-to-end hits\n\t\tmm1Elt_ = 0;         // number of 1-mismatch hit rows\n\t\tmm1Sorted_ = false;  // true iff we've sorted the mm1Hit_ list\n\t}", "idx": 616}
{"project": "bowtie2", "commit_id": "72_bowtie2_2.5.1_aligner_seed.h_merge.cpp", "target": 0, "func": "void merge(const SeedSearchMetrics& m, bool getLock = false) {\n\t\tseedsearch   += m.seedsearch;\n\t\tnrange       += m.nrange;\n\t\tnelt         += m.nelt;\n\t\tpossearch    += m.possearch;\n\t\tintrahit     += m.intrahit;\n\t\tinterhit     += m.interhit;\n\t\tfilteredseed += m.filteredseed;\n\t\tooms         += m.ooms;\n\t\tbwops        += m.bwops;\n\t\tbweds        += m.bweds;\n\t\tbestmin0     += m.bestmin0;\n\t\tbestmin1     += m.bestmin1;\n\t\tbestmin2     += m.bestmin2;\n\t}", "idx": 617}
{"project": "bowtie2", "commit_id": "73_bowtie2_2.5.1_aligner_seed.h_beginAlign.cpp", "target": 0, "func": "int beginAlign(AlignmentCacheIface& cache) \n\t{ \n\t\tint ret = cache.beginAlign(seq, qual, qv);\n\t\tif (ret>=0) {\n\t\t\tcachep = &cache;\n\t\t}\n\t\treturn ret;\n\t}", "idx": 618}
{"project": "bowtie2", "commit_id": "74_bowtie2_2.5.1_aligner_seed.h_addAllCached.cpp", "target": 0, "func": "bool addAllCached(bool getLock = true)\n\t{\n\t\tif (!aligning()) return false;\n\t\tconst size_t nEls = cachedEls.size();\n\t\tbool success = true;\n\t\tfor(size_t i=0; i<nEls; i++) {\n\t\t\tAddEl &el = cachedEls[i];\n\t\t\tsuccess &= cachep->addOnTheFly(el.sak, el.topf, el.botf, el.topb, el.botb, getLock);\n\t\t}\n\t\tcachedEls.clear();\n\t\treturn success;\n\t}", "idx": 619}
{"project": "bowtie2", "commit_id": "75_bowtie2_2.5.1_aligner_seed.h_finishAlign.cpp", "target": 0, "func": "void finishAlign(bool getLock = true) \n\t{ \n\t\tassert(cachep!=NULL);\n\t\tqv = cachep->finishAlign(getLock); \n\t\tcachep = NULL;\n\t}", "idx": 620}
{"project": "bowtie2", "commit_id": "76_bowtie2_2.5.1_aligner_seed.h_emplace_back.cpp", "target": 0, "func": "void emplace_back( \n\t\tconst BTDnaString& seq,  // sequence of current seed\n\t\tconst BTString& qual,    // quality string for current seed\n\t\tint seedoffidx,          // seed index\n\t\tbool fw                  // is it fw?\n\t\t)\n\t{\n\t\tcacheVec.emplace_back(seq, qual, seedoffidx, fw);\n\t}", "idx": 621}
{"project": "bowtie2", "commit_id": "77_bowtie2_2.5.1_aligner_seed.h_reserve.cpp", "target": 0, "func": "vector\n\tvoid reserve(size_t new_cap) { cacheVec.reserve(new_cap); }", "idx": 622}
{"project": "bowtie2", "commit_id": "78_bowtie2_2.5.1_aligner_seed.h_pop_back.cpp", "target": 0, "func": "void pop_back() { cacheVec.pop_back(); }", "idx": 623}
{"project": "bowtie2", "commit_id": "79_bowtie2_2.5.1_aligner_seed.h_INIT_LOCS.cpp", "target": 0, "func": "define INIT_LOCS(top, bot, tloc, bloc, e) { \\\n\tif(bot - top == 1) { \\\n\t\ttloc.initFromRow(top, (e).eh(), (e).ebwt()); \\\n\t\tbloc.invalidate(); \\\n\t} else { \\\n\t\tSideLocus::initFromTopBot(top, bot, (e).eh(), (e).ebwt(), tloc, bloc); \\\n\t\tassert(bloc.valid()); \\\n\t} \\\n}", "idx": 624}
{"project": "bowtie2", "commit_id": "7_bowtie2_2.5.1_aligner_cache.cpp_printUsage.cpp", "target": 0, "func": "static void printUsage(ostream& os) {\n\tos << \"Usage: bowtie2-cache [options]*\" << endl;\n\tos << \"Options:\" << endl;\n\tos << \"  --tests       run unit tests\" << endl;\n\tos << \"  -v/--verbose  talkative mode\" << endl;\n}", "idx": 625}
{"project": "bowtie2", "commit_id": "80_bowtie2_2.5.1_aligner_seed.h_SANITY_CHECK_4TUP.cpp", "target": 0, "func": "define SANITY_CHECK_4TUP(t, b, tp, bp) { \\\n\tASSERT_ONLY(TIndexOffU tot = (b[0]-t[0])+(b[1]-t[1])+(b[2]-t[2])+(b[3]-t[3])); \\\n\tASSERT_ONLY(TIndexOffU totp = (bp[0]-tp[0])+(bp[1]-tp[1])+(bp[2]-tp[2])+(bp[3]-tp[3])); \\\n\tassert_eq(tot, totp); \\\n}", "idx": 626}
{"project": "bowtie2", "commit_id": "81_bowtie2_2.5.1_aligner_seed2.h_reset.cpp", "target": 0, "func": "void reset() {\n\t\theap_.clear();\n\t\toffs_.clear();\n\t\tsas_.clear();\n\t\tgws_.clear();\n\t}", "idx": 627}
{"project": "bowtie2", "commit_id": "82_bowtie2_2.5.1_aligner_seed2.h_init.cpp", "target": 0, "func": "void init(\n\t\tconst Read& q,\n\t\tconst DescentAlignmentSink& sink,\n\t\tconst Ebwt& ebwtFw,         // forward Bowtie index for walking left\n\t\tconst BitPairReference& ref,// bitpair-encoded reference\n\t\tRandomSource& rnd,          // pseudo-random generator for sampling rows\n\t\tWalkMetrics& met)\n\t{\n\t\t// We're going to sample from space of *alignments*, not ranges.  So\n\t\t// when we extract a sample, we'll have to do a little extra work to\n\t\t// convert it to a <range, offset> coordinate.\n\t\trnd_.init(\n\t\t\tsink.nelt(), // # elements to choose from\n\t\t\ttrue);       // without replacement\n\t\toffs_.resize(sink.nelt());\n\t\toffs_.fill(std::numeric_limits<TIndexOffU>::max());\n\t\tsas_.resize(sink.nrange());\n\t\tgws_.resize(sink.nrange());\n\t\tsize_t ei = 0;\n\t\tfor(size_t i = 0; i < sas_.size(); i++) {\n\t\t\tsize_t en = sink[i].botf - sink[i].topf;\n\t\t\tsas_[i].init(sink[i].topf, EListSlice<TIndexOffU, 16>(offs_, ei, en));\n\t\t\tgws_[i].init(ebwtFw, ref, sas_[i], rnd, met);\n\t\t\tei += en;\n\t\t}\n\t}", "idx": 628}
{"project": "bowtie2", "commit_id": "83_bowtie2_2.5.1_aligner_seed2.h_clear.cpp", "target": 0, "func": "void clear() {\n\t\tbest1.reset();\n\t\tbest2.reset();\n\t\tbest3.reset();\n\t\tbest4.reset();\n\t\tbest5.reset();\n\t}", "idx": 629}
{"project": "bowtie2", "commit_id": "84_bowtie2_2.5.1_aligner_seed2.h_check.cpp", "target": 0, "func": "bool check(\n\t\tbool fw,\n\t\tbool l2r,\n\t\tTReadOff al5pi,\n\t\tTReadOff al5pf,\n\t\tsize_t rflen,\n\t\tTIndexOffU topf,\n\t\tTIndexOffU botf,\n\t\tTScore pen)\n\t{\n\t\tassert(inited_);\n\t\tassert(topf > 0 || botf > 0);\n\t\tDescentRedundancyKey k(al5pf, rflen, topf, botf);\n\t\tsize_t i = std::numeric_limits<size_t>::max();\n\t\tsize_t mask = topf & PART_MASK;\n\t\tEMap<DescentRedundancyKey, TScore>& map =\n\t\t\t(fw ? (l2r ? maplist_fl_[mask][al5pi] : maplist_fr_[mask][al5pi]) :\n\t\t\t      (l2r ? maplist_rl_[mask][al5pi] : maplist_rr_[mask][al5pi]));\n\t\tsize_t key = (topf & 255) | ((botf & 255) << 8);\n\t\tif(bits_.test(key) && map.containsEx(k, i)) {\n\t\t\t// Already contains the key\n\t\t\tassert_lt(i, map.size());\n\t\t\tassert_geq(pen, map[i].second);\n\t\t\treturn false;\n\t\t}\n\t\tassert(!map.containsEx(k, i));\n\t\tsize_t oldsz = map.totalSizeBytes();\n\t\tsize_t oldcap = map.totalCapacityBytes();\n\t\tmap.insert(make_pair(k, pen));\n\t\tbits_.set(key);\n\t\ttotsz_ += (map.totalSizeBytes() - oldsz);\n\t\ttotcap_ += (map.totalCapacityBytes() - oldcap);\n\t\treturn true;\n\t}", "idx": 630}
{"project": "bowtie2", "commit_id": "85_bowtie2_2.5.1_aligner_seed2.h_contains.cpp", "target": 0, "func": "bool contains(\n\t\tbool fw,\n\t\tbool l2r,\n\t\tTReadOff al5pi,\n\t\tTReadOff al5pf,\n\t\tsize_t rflen,\n\t\tTIndexOffU topf,\n\t\tTIndexOffU botf,\n\t\tTScore pen)\n\t{\n\t\tassert(inited_);\n\t\tsize_t key = (topf & 255) | ((botf & 255) << 8);\n\t\tif(!bits_.test(key)) {\n\t\t\treturn false;\n\t\t}\n\t\tDescentRedundancyKey k(al5pf, rflen, topf, botf);\n\t\tsize_t mask = topf & PART_MASK;\n\t\tEMap<DescentRedundancyKey, TScore>& map =\n\t\t\t(fw ? (l2r ? maplist_fl_[mask][al5pi] : maplist_fr_[mask][al5pi]) :\n\t\t\t      (l2r ? maplist_rl_[mask][al5pi] : maplist_rr_[mask][al5pi]));\n\t\treturn map.contains(k);\n\t}", "idx": 631}
{"project": "bowtie2", "commit_id": "86_bowtie2_2.5.1_aligner_seed2.h_mmExplore.cpp", "target": 0, "func": "bool mmExplore(int c) {\n\t\tassert_range(0, 3, c);\n\t\tif(c == 0) {\n\t\t\treturn mm_a;\n\t\t} else if(c == 1) {\n\t\t\treturn mm_c;\n\t\t} else if(c == 2) {\n\t\t\treturn mm_g;\n\t\t} else {\n\t\t\treturn mm_t;\n\t\t}\n\t}", "idx": 632}
{"project": "bowtie2", "commit_id": "87_bowtie2_2.5.1_aligner_seed2.h_mmSet.cpp", "target": 0, "func": "bool mmSet(int c) {\n\t\tassert_range(0, 3, c);\n\t\tif(c == 0) {\n\t\t\tbool ret = mm_a; mm_a = 0; return ret;\n\t\t} else if(c == 1) {\n\t\t\tbool ret = mm_c; mm_c = 0; return ret;\n\t\t} else if(c == 2) {\n\t\t\tbool ret = mm_g; mm_g = 0; return ret;\n\t\t} else {\n\t\t\tbool ret = mm_t; mm_t = 0; return ret;\n\t\t}\n\t}", "idx": 633}
{"project": "bowtie2", "commit_id": "88_bowtie2_2.5.1_aligner_seed2.h_rdgExplore.cpp", "target": 0, "func": "bool rdgExplore(int c) {\n\t\tassert_range(0, 3, c);\n\t\tif(c == 0) {\n\t\t\treturn rdg_a;\n\t\t} else if(c == 1) {\n\t\t\treturn rdg_c;\n\t\t} else if(c == 2) {\n\t\t\treturn rdg_g;\n\t\t} else {\n\t\t\treturn rdg_t;\n\t\t}\n\t}", "idx": 634}
{"project": "bowtie2", "commit_id": "89_bowtie2_2.5.1_aligner_seed2.h_rdgSet.cpp", "target": 0, "func": "bool rdgSet(int c) {\n\t\tassert_range(0, 3, c);\n\t\tif(c == 0) {\n\t\t\tbool ret = rdg_a; rdg_a = 0; return ret;\n\t\t} else if(c == 1) {\n\t\t\tbool ret = rdg_c; rdg_c = 0; return ret;\n\t\t} else if(c == 2) {\n\t\t\tbool ret = rdg_g; rdg_g = 0; return ret;\n\t\t} else {\n\t\t\tbool ret = rdg_t; rdg_t = 0; return ret;\n\t\t}\n\t}", "idx": 635}
{"project": "bowtie2", "commit_id": "8_bowtie2_2.5.1_aligner_cache.cpp_add.cpp", "target": 0, "func": "static void add(\n\tRedBlack<QKey, QVal>& t,\n\tPool& p,\n\tconst char *dna)\n{\n\tQKey qk;\n\tqk.init(BTDnaString(dna, true));\n\tt.add(p, qk, NULL);\n}", "idx": 636}
{"project": "bowtie2", "commit_id": "90_bowtie2_2.5.1_aligner_seed2.h_rfgExplore.cpp", "target": 0, "func": "bool rfgExplore() {\n\t\treturn rfg;\n\t}", "idx": 637}
{"project": "bowtie2", "commit_id": "91_bowtie2_2.5.1_aligner_seed2.h_rfgSet.cpp", "target": 0, "func": "bool rfgSet() {\n\t\tbool ret = rfg; rfg = 0; return ret;\n\t}", "idx": 638}
{"project": "bowtie2", "commit_id": "92_bowtie2_2.5.1_aligner_seed2.h_updateFlags.cpp", "target": 0, "func": "void updateFlags(EFactory<DescentPos>& pf) {\n        if(inited()) {\n            if(e.isReadGap()) {\n                assert_neq('-', e.chr);\n                pf[posFlag].flags.rdgSet(asc2dna[e.chr]);\n            } else if(e.isRefGap()) {\n                pf[posFlag].flags.rfgSet();\n            } else {\n                assert_neq('-', e.chr);\n                pf[posFlag].flags.mmSet(asc2dna[e.chr]);\n            }\n        }\n    }", "idx": 639}
{"project": "bowtie2", "commit_id": "93_bowtie2_2.5.1_aligner_seed2.h_rotate.cpp", "target": 0, "func": "DescentEdge rotate() {\n\t\tDescentEdge tmp = best1;\n        assert(!(best2 < tmp));\n\t\tbest1 = best2;\n        assert(!(best3 < best2));\n\t\tbest2 = best3;\n        assert(!(best4 < best3));\n\t\tbest3 = best4;\n        assert(!(best5 < best4));\n\t\tbest4 = best5;\n\t\tbest5.reset();\n\t\treturn tmp;\n\t}", "idx": 640}
{"project": "bowtie2", "commit_id": "94_bowtie2_2.5.1_aligner_seed2.h_update.cpp", "target": 0, "func": "void update(DescentEdge e) {\n\t\tif(!best1.inited()) {\n\t\t\tbest1 = e;\n\t\t} else if(e < best1) {\n\t\t\tbest5 = best4;\n\t\t\tbest4 = best3;\n\t\t\tbest3 = best2;\n\t\t\tbest2 = best1;\n\t\t\tbest1 = e;\n\t\t} else if(!best2.inited()) {\n\t\t\tbest2 = e;\n\t\t} else if(e < best2) {\n\t\t\tbest5 = best4;\n\t\t\tbest4 = best3;\n\t\t\tbest3 = best2;\n\t\t\tbest2 = e;\n\t\t} else if(!best3.inited()) {\n\t\t\tbest3 = e;\n\t\t} else if(e < best3) {\n\t\t\tbest5 = best4;\n\t\t\tbest4 = best3;\n\t\t\tbest3 = e;\n\t\t} else if(!best4.inited()) {\n\t\t\tbest4 = e;\n\t\t} else if(e < best4) {\n\t\t\tbest5 = best4;\n\t\t\tbest4 = e;\n\t\t}  else if(!best5.inited() || e < best5) {\n\t\t\tbest5 = e;\n\t\t}\n\t}", "idx": 641}
{"project": "bowtie2", "commit_id": "95_bowtie2_2.5.1_aligner_seed2.h_collectEdits.cpp", "target": 0, "func": "void collectEdits(\n\t\tEList<Edit>& edits,\n\t\tconst Edit *e,\n\t\tEFactory<Descent>& df)\n\t{\n\t\t// Take just the portion of the read that has aligned up until this\n\t\t// point\n\t\tsize_t nuninited = 0;\n\t\tsize_t ei = edits.size();\n\t\tsize_t en = 0;\n\t\tif(e != NULL && e->inited()) {\n\t\t\tedits.push_back(*e);\n\t\t\ten++;\n\t\t}\n\t\tsize_t cur = descid_;\n\t\twhile(cur != std::numeric_limits<TDescentId>::max()) {\n\t\t\tif(!df[cur].edit().inited()) {\n\t\t\t\tnuninited++;\n\t\t\t\tassert_leq(nuninited, 2);\n\t\t\t} else {\n\t\t\t\tedits.push_back(df[cur].edit());\n\t\t\t\ten++;\n\t\t\t}\n\t\t\tcur = df[cur].parent();\n\t\t}\n\t\t// Sort just the edits we just added\n\t\tedits.sortPortion(ei, en);\n\t}", "idx": 642}
{"project": "bowtie2", "commit_id": "96_bowtie2_2.5.1_aligner_seed2.h_advanceStratum.cpp", "target": 0, "func": "void advanceStratum() {\n\t\tassert_gt(nelt_, 0);\n\t\tedits_.clear();\n\t\tals_.clear();\n\t\t// Don't reset lhs_ or rhs_\n\t\tnelt_ = 0;\n\t\tbestPen_ = worstPen_ = std::numeric_limits<TAlScore>::max();\n\t}", "idx": 643}
{"project": "bowtie2", "commit_id": "97_bowtie2_2.5.1_aligner_seed2.h_initRead.cpp", "target": 0, "func": "void initRead(\n\t\tconst Read& q,\n\t\tbool nofw,\n\t\tbool norc,\n\t\tTAlScore minsc,\n\t\tTAlScore maxpen,\n\t\tconst Read* qmate = NULL,\n\t\tDescentRootSelector *sel = NULL)\n\t{\n\t\treset();\n\t\tq_ = q;           // copy the read itself\n\t\tminsc_ = minsc;   // minimum score\n\t\tmaxpen_ = maxpen; // maximum penalty\n\t\tif(sel != NULL) {\n\t\t\tsel->select(  // Select search roots\n\t\t\t\tq_,       // in: read\n\t\t\t\tqmate,    // in: opposite mate, if paired\n\t\t\t\tnofw,     // in: true -> don't put roots on fw read\n\t\t\t\tnorc,     // in: true -> don't put roots on rc read\n\t\t\t\tconfs_,   // out: search configs for each root\n\t\t\t\troots_);  // out: roots\n\t\t\t//printRoots(std::cerr);\n\t\t}\n\t\tre_.init(q.length()); // initialize redundancy checker\n\t}", "idx": 644}
{"project": "bowtie2", "commit_id": "98_bowtie2_2.5.1_aligner_seed2.h_addRoot.cpp", "target": 0, "func": "void addRoot(\n        const DescentConfig& conf,\n        TReadOff off,\n        bool l2r,\n        bool fw,\n\t\tsize_t landing,\n        float pri)\n    {\n        confs_.push_back(conf);\n\t\tassert_lt(off, q_.length());\n\t\tif(l2r && off == q_.length()-1) {\n\t\t\tl2r = !l2r;\n\t\t} else if(!l2r && off == 0) {\n\t\t\tl2r = !l2r;\n\t\t}\n\t\troots_.push_back(DescentRoot(off, l2r, fw, landing, q_.length(), pri));\n\t}", "idx": 645}
{"project": "bowtie2", "commit_id": "99_bowtie2_2.5.1_aligner_seed2.h_clearRoots.cpp", "target": 0, "func": "void clearRoots() {\n\t\tconfs_.clear();\n\t\troots_.clear();\n\t}", "idx": 646}
{"project": "bowtie2", "commit_id": "9_bowtie2_2.5.1_aligner_cache.h_toString.cpp", "target": 0, "func": "void toString(BTDnaString& s) {\n\t\ts.resize(len);\n\t\tuint64_t sq = seq;\n\t\tfor(int i = (len)-1; i >= 0; i--) {\n\t\t\ts.set((uint32_t)(sq & 3), i);\n\t\t\tsq >>= 2;\n\t\t}\n\t}", "idx": 647}

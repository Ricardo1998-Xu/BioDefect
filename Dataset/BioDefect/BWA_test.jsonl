{"project": "BWA", "commit_id": "100_BWA_0.7.17_bwt.c_bwt_sa.c", "target": 0, "func": "bwtint_t bwt_sa(const bwt_t *bwt, bwtint_t k)\n{\n\tbwtint_t sa = 0, mask = bwt->sa_intv - 1;\n\twhile (k & mask) {\n\t\t++sa;\n\t\tk = bwt_invPsi(bwt, k);\n\t}\n\t/* without setting bwt->sa[0] = -1, the following line should be\n\t   changed to (sa + bwt->sa[k/bwt->sa_intv]) % (bwt->seq_len + 1) */\n\treturn sa + bwt->sa[k/bwt->sa_intv];\n}", "idx": 0}
{"project": "BWA", "commit_id": "101_BWA_0.7.17_bwt.c___occ_aux.c", "target": 0, "func": "static inline int __occ_aux(uint64_t y, int c)\n{\n\t// reduce nucleotide counting to bits counting\n\ty = ((c&2)? y : ~y) >> 1 & ((c&1)? y : ~y) & 0x5555555555555555ull;\n\t// count the number of 1s in y\n\ty = (y & 0x3333333333333333ull) + (y >> 2 & 0x3333333333333333ull);\n\treturn ((y + (y >> 4)) & 0xf0f0f0f0f0f0f0full) * 0x101010101010101ull >> 56;\n}", "idx": 1}
{"project": "BWA", "commit_id": "102_BWA_0.7.17_bwt.c_bwt_occ.c", "target": 0, "func": "bwtint_t bwt_occ(const bwt_t *bwt, bwtint_t k, ubyte_t c)\n{\n\tbwtint_t n;\n\tuint32_t *p, *end;\n\n\tif (k == bwt->seq_len) return bwt->L2[c+1] - bwt->L2[c];\n\tif (k == (bwtint_t)(-1)) return 0;\n\tk -= (k >= bwt->primary); // because $ is not in bwt\n\n\t// retrieve Occ at k/OCC_INTERVAL\n\tn = ((bwtint_t*)(p = bwt_occ_intv(bwt, k)))[c];\n\tp += sizeof(bwtint_t); // jump to the start of the first BWT cell\n\n\t// calculate Occ up to the last k/32\n\tend = p + (((k>>5) - ((k&~OCC_INTV_MASK)>>5))<<1);\n\tfor (; p < end; p += 2) n += __occ_aux((uint64_t)p[0]<<32 | p[1], c);\n\n\t// calculate Occ\n\tn += __occ_aux(((uint64_t)p[0]<<32 | p[1]) & ~((1ull<<((~k&31)<<1)) - 1), c);\n\tif (c == 0) n -= ~k&31; // corrected for the masked bits\n\n\treturn n;\n}", "idx": 2}
{"project": "BWA", "commit_id": "103_BWA_0.7.17_bwt.c_bwt_2occ.c", "target": 0, "func": "void bwt_2occ(const bwt_t *bwt, bwtint_t k, bwtint_t l, ubyte_t c, bwtint_t *ok, bwtint_t *ol)\n{\n\tbwtint_t _k, _l;\n\t_k = (k >= bwt->primary)? k-1 : k;\n\t_l = (l >= bwt->primary)? l-1 : l;\n\tif (_l/OCC_INTERVAL != _k/OCC_INTERVAL || k == (bwtint_t)(-1) || l == (bwtint_t)(-1)) {\n\t\t*ok = bwt_occ(bwt, k, c);\n\t\t*ol = bwt_occ(bwt, l, c);\n\t} else {\n\t\tbwtint_t m, n, i, j;\n\t\tuint32_t *p;\n\t\tif (k >= bwt->primary) --k;\n\t\tif (l >= bwt->primary) --l;\n\t\tn = ((bwtint_t*)(p = bwt_occ_intv(bwt, k)))[c];\n\t\tp += sizeof(bwtint_t);\n\t\t// calculate *ok\n\t\tj = k >> 5 << 5;\n\t\tfor (i = k/OCC_INTERVAL*OCC_INTERVAL; i < j; i += 32, p += 2)\n\t\t\tn += __occ_aux((uint64_t)p[0]<<32 | p[1], c);\n\t\tm = n;\n\t\tn += __occ_aux(((uint64_t)p[0]<<32 | p[1]) & ~((1ull<<((~k&31)<<1)) - 1), c);\n\t\tif (c == 0) n -= ~k&31; // corrected for the masked bits\n\t\t*ok = n;\n\t\t// calculate *ol\n\t\tj = l >> 5 << 5;\n\t\tfor (; i < j; i += 32, p += 2)\n\t\t\tm += __occ_aux((uint64_t)p[0]<<32 | p[1], c);\n\t\tm += __occ_aux(((uint64_t)p[0]<<32 | p[1]) & ~((1ull<<((~l&31)<<1)) - 1), c);\n\t\tif (c == 0) m -= ~l&31; // corrected for the masked bits\n\t\t*ol = m;\n\t}\n}", "idx": 3}
{"project": "BWA", "commit_id": "104_BWA_0.7.17_bwt.c_bwt_occ4.c", "target": 0, "func": "void bwt_occ4(const bwt_t *bwt, bwtint_t k, bwtint_t cnt[4])\n{\n\tbwtint_t x;\n\tuint32_t *p, tmp, *end;\n\tif (k == (bwtint_t)(-1)) {\n\t\tmemset(cnt, 0, 4 * sizeof(bwtint_t));\n\t\treturn;\n\t}\n\tk -= (k >= bwt->primary); // because $ is not in bwt\n\tp = bwt_occ_intv(bwt, k);\n\tmemcpy(cnt, p, 4 * sizeof(bwtint_t));\n\tp += sizeof(bwtint_t); // sizeof(bwtint_t) = 4*(sizeof(bwtint_t)/sizeof(uint32_t))\n\tend = p + ((k>>4) - ((k&~OCC_INTV_MASK)>>4)); // this is the end point of the following loop\n\tfor (x = 0; p < end; ++p) x += __occ_aux4(bwt, *p);\n\ttmp = *p & ~((1U<<((~k&15)<<1)) - 1);\n\tx += __occ_aux4(bwt, tmp) - (~k&15);\n\tcnt[0] += x&0xff; cnt[1] += x>>8&0xff; cnt[2] += x>>16&0xff; cnt[3] += x>>24;\n}", "idx": 4}
{"project": "BWA", "commit_id": "105_BWA_0.7.17_bwt.c_bwt_2occ4.c", "target": 0, "func": "void bwt_2occ4(const bwt_t *bwt, bwtint_t k, bwtint_t l, bwtint_t cntk[4], bwtint_t cntl[4])\n{\n\tbwtint_t _k, _l;\n\t_k = k - (k >= bwt->primary);\n\t_l = l - (l >= bwt->primary);\n\tif (_l>>OCC_INTV_SHIFT != _k>>OCC_INTV_SHIFT || k == (bwtint_t)(-1) || l == (bwtint_t)(-1)) {\n\t\tbwt_occ4(bwt, k, cntk);\n\t\tbwt_occ4(bwt, l, cntl);\n\t} else {\n\t\tbwtint_t x, y;\n\t\tuint32_t *p, tmp, *endk, *endl;\n\t\tk -= (k >= bwt->primary); // because $ is not in bwt\n\t\tl -= (l >= bwt->primary);\n\t\tp = bwt_occ_intv(bwt, k);\n\t\tmemcpy(cntk, p, 4 * sizeof(bwtint_t));\n\t\tp += sizeof(bwtint_t); // sizeof(bwtint_t) = 4*(sizeof(bwtint_t)/sizeof(uint32_t))\n\t\t// prepare cntk[]\n\t\tendk = p + ((k>>4) - ((k&~OCC_INTV_MASK)>>4));\n\t\tendl = p + ((l>>4) - ((l&~OCC_INTV_MASK)>>4));\n\t\tfor (x = 0; p < endk; ++p) x += __occ_aux4(bwt, *p);\n\t\ty = x;\n\t\ttmp = *p & ~((1U<<((~k&15)<<1)) - 1);\n\t\tx += __occ_aux4(bwt, tmp) - (~k&15);\n\t\t// calculate cntl[] and finalize cntk[]\n\t\tfor (; p < endl; ++p) y += __occ_aux4(bwt, *p);\n\t\ttmp = *p & ~((1U<<((~l&15)<<1)) - 1);\n\t\ty += __occ_aux4(bwt, tmp) - (~l&15);\n\t\tmemcpy(cntl, cntk, 4 * sizeof(bwtint_t));\n\t\tcntk[0] += x&0xff; cntk[1] += x>>8&0xff; cntk[2] += x>>16&0xff; cntk[3] += x>>24;\n\t\tcntl[0] += y&0xff; cntl[1] += y>>8&0xff; cntl[2] += y>>16&0xff; cntl[3] += y>>24;\n\t}\n}", "idx": 5}
{"project": "BWA", "commit_id": "106_BWA_0.7.17_bwt.c_bwt_match_exact.c", "target": 0, "func": "int bwt_match_exact(const bwt_t *bwt, int len, const ubyte_t *str, bwtint_t *sa_begin, bwtint_t *sa_end)\n{\n\tbwtint_t k, l, ok, ol;\n\tint i;\n\tk = 0; l = bwt->seq_len;\n\tfor (i = len - 1; i >= 0; --i) {\n\t\tubyte_t c = str[i];\n\t\tif (c > 3) return 0; // no match\n\t\tbwt_2occ(bwt, k - 1, l, c, &ok, &ol);\n\t\tk = bwt->L2[c] + ok + 1;\n\t\tl = bwt->L2[c] + ol;\n\t\tif (k > l) break; // no match\n\t}\n\tif (k > l) return 0; // no match\n\tif (sa_begin) *sa_begin = k;\n\tif (sa_end)   *sa_end = l;\n\treturn l - k + 1;\n}", "idx": 6}
{"project": "BWA", "commit_id": "107_BWA_0.7.17_bwt.c_bwt_match_exact_alt.c", "target": 0, "func": "int bwt_match_exact_alt(const bwt_t *bwt, int len, const ubyte_t *str, bwtint_t *k0, bwtint_t *l0)\n{\n\tint i;\n\tbwtint_t k, l, ok, ol;\n\tk = *k0; l = *l0;\n\tfor (i = len - 1; i >= 0; --i) {\n\t\tubyte_t c = str[i];\n\t\tif (c > 3) return 0; // there is an N here. no match\n\t\tbwt_2occ(bwt, k - 1, l, c, &ok, &ol);\n\t\tk = bwt->L2[c] + ok + 1;\n\t\tl = bwt->L2[c] + ol;\n\t\tif (k > l) return 0; // no match\n\t}\n\t*k0 = k; *l0 = l;\n\treturn l - k + 1;\n}", "idx": 7}
{"project": "BWA", "commit_id": "108_BWA_0.7.17_bwt.c_bwt_extend.c", "target": 0, "func": "void bwt_extend(const bwt_t *bwt, const bwtintv_t *ik, bwtintv_t ok[4], int is_back)\n{\n\tbwtint_t tk[4], tl[4];\n\tint i;\n\tbwt_2occ4(bwt, ik->x[!is_back] - 1, ik->x[!is_back] - 1 + ik->x[2], tk, tl);\n\tfor (i = 0; i != 4; ++i) {\n\t\tok[i].x[!is_back] = bwt->L2[i] + 1 + tk[i];\n\t\tok[i].x[2] = tl[i] - tk[i];\n\t}\n\tok[3].x[is_back] = ik->x[is_back] + (ik->x[!is_back] <= bwt->primary && ik->x[!is_back] + ik->x[2] - 1 >= bwt->primary);\n\tok[2].x[is_back] = ok[3].x[is_back] + ok[3].x[2];\n\tok[1].x[is_back] = ok[2].x[is_back] + ok[2].x[2];\n\tok[0].x[is_back] = ok[1].x[is_back] + ok[1].x[2];\n}", "idx": 8}
{"project": "BWA", "commit_id": "109_BWA_0.7.17_bwt.c_bwt_reverse_intvs.c", "target": 0, "func": "static void bwt_reverse_intvs(bwtintv_v *p)\n{\n\tif (p->n > 1) {\n\t\tint j;\n\t\tfor (j = 0; j < p->n>>1; ++j) {\n\t\t\tbwtintv_t tmp = p->a[p->n - 1 - j];\n\t\t\tp->a[p->n - 1 - j] = p->a[j];\n\t\t\tp->a[j] = tmp;\n\t\t}\n\t}\n}", "idx": 9}
{"project": "BWA", "commit_id": "10_BWA_0.7.17_bamlite.c_bam_header_read.c", "target": 0, "func": "bam_header_t *bam_header_read(bamFile fp)\n{\n\tbam_header_t *header;\n\tchar buf[4];\n\tint magic_len;\n\tint32_t i = 1, name_len;\n\t// read \"BAM1\"\n\tmagic_len = bam_read(fp, buf, 4);\n\tif (magic_len != 4 || strncmp(buf, \"BAM\\001\", 4) != 0) {\n\t\tfprintf(stderr, \"[bam_header_read] invalid BAM binary header (this is not a BAM file).\\n\");\n\t\treturn NULL;\n\t}\n\theader = bam_header_init();\n\t// read plain text and the number of reference sequences\n\tif (bam_read(fp, &header->l_text, 4) != 4) goto fail; \n\tif (bam_is_be) bam_swap_endian_4p(&header->l_text);\n\theader->text = (char*)calloc(header->l_text + 1, 1);\n\tif (bam_read(fp, header->text, header->l_text) != header->l_text) goto fail;\n\tif (bam_read(fp, &header->n_targets, 4) != 4) goto fail;\n\tif (bam_is_be) bam_swap_endian_4p(&header->n_targets);\n\t// read reference sequence names and lengths\n\theader->target_name = (char**)calloc(header->n_targets, sizeof(char*));\n\theader->target_len = (uint32_t*)calloc(header->n_targets, 4);\n\tfor (i = 0; i != header->n_targets; ++i) {\n\t\tif (bam_read(fp, &name_len, 4) != 4) goto fail;\n\t\tif (bam_is_be) bam_swap_endian_4p(&name_len);\n\t\theader->target_name[i] = (char*)calloc(name_len, 1);\n\t\tif (bam_read(fp, header->target_name[i], name_len) != name_len) {\n\t\t\tgoto fail;\n\t\t}\n\t\tif (bam_read(fp, &header->target_len[i], 4) != 4) goto fail;\n\t\tif (bam_is_be) bam_swap_endian_4p(&header->target_len[i]);\n\t}\n\treturn header;\n fail:\n\tbam_header_destroy(header);\n\treturn NULL;\n}", "idx": 10}
{"project": "BWA", "commit_id": "110_BWA_0.7.17_bwt.c_bwt_smem1.c", "target": 0, "func": "int bwt_smem1(const bwt_t *bwt, int len, const uint8_t *q, int x, int min_intv, bwtintv_v *mem, bwtintv_v *tmpvec[2])\n{\n\treturn bwt_smem1a(bwt, len, q, x, min_intv, 0, mem, tmpvec);\n}", "idx": 11}
{"project": "BWA", "commit_id": "111_BWA_0.7.17_bwt.c_bwt_dump_bwt.c", "target": 0, "func": "void bwt_dump_bwt(const char *fn, const bwt_t *bwt)\n{\n\tFILE *fp;\n\tfp = xopen(fn, \"wb\");\n\terr_fwrite(&bwt->primary, sizeof(bwtint_t), 1, fp);\n\terr_fwrite(bwt->L2+1, sizeof(bwtint_t), 4, fp);\n\terr_fwrite(bwt->bwt, 4, bwt->bwt_size, fp);\n\terr_fflush(fp);\n\terr_fclose(fp);\n}", "idx": 12}
{"project": "BWA", "commit_id": "112_BWA_0.7.17_bwt.c_bwt_dump_sa.c", "target": 0, "func": "void bwt_dump_sa(const char *fn, const bwt_t *bwt)\n{\n\tFILE *fp;\n\tfp = xopen(fn, \"wb\");\n\terr_fwrite(&bwt->primary, sizeof(bwtint_t), 1, fp);\n\terr_fwrite(bwt->L2+1, sizeof(bwtint_t), 4, fp);\n\terr_fwrite(&bwt->sa_intv, sizeof(bwtint_t), 1, fp);\n\terr_fwrite(&bwt->seq_len, sizeof(bwtint_t), 1, fp);\n\terr_fwrite(bwt->sa + 1, sizeof(bwtint_t), bwt->n_sa - 1, fp);\n\terr_fflush(fp);\n\terr_fclose(fp);\n}", "idx": 13}
{"project": "BWA", "commit_id": "113_BWA_0.7.17_bwt.c_fread_fix.c", "target": 0, "func": "static bwtint_t fread_fix(FILE *fp, bwtint_t size, void *a)\n{ // Mac/Darwin has a bug when reading data longer than 2GB. This function fixes this issue by reading data in small chunks\n\tconst int bufsize = 0x1000000; // 16M block\n\tbwtint_t offset = 0;\n\twhile (size) {\n\t\tint x = bufsize < size? bufsize : size;\n\t\tif ((x = err_fread_noeof(a + offset, 1, x, fp)) == 0) break;\n\t\tsize -= x; offset += x;\n\t}\n\treturn offset;\n}", "idx": 14}
{"project": "BWA", "commit_id": "114_BWA_0.7.17_bwt.c_bwt_restore_sa.c", "target": 0, "func": "void bwt_restore_sa(const char *fn, bwt_t *bwt)\n{\n\tchar skipped[256];\n\tFILE *fp;\n\tbwtint_t primary;\n\n\tfp = xopen(fn, \"rb\");\n\terr_fread_noeof(&primary, sizeof(bwtint_t), 1, fp);\n\txassert(primary == bwt->primary, \"SA-BWT inconsistency: primary is not the same.\");\n\terr_fread_noeof(skipped, sizeof(bwtint_t), 4, fp); // skip\n\terr_fread_noeof(&bwt->sa_intv, sizeof(bwtint_t), 1, fp);\n\terr_fread_noeof(&primary, sizeof(bwtint_t), 1, fp);\n\txassert(primary == bwt->seq_len, \"SA-BWT inconsistency: seq_len is not the same.\");\n\n\tbwt->n_sa = (bwt->seq_len + bwt->sa_intv) / bwt->sa_intv;\n\tbwt->sa = (bwtint_t*)calloc(bwt->n_sa, sizeof(bwtint_t));\n\tbwt->sa[0] = -1;\n\n\tfread_fix(fp, sizeof(bwtint_t) * (bwt->n_sa - 1), bwt->sa + 1);\n\terr_fclose(fp);\n}", "idx": 15}
{"project": "BWA", "commit_id": "115_BWA_0.7.17_bwt.c_bwt_restore_bwt.c", "target": 0, "func": "bwt_t *bwt_restore_bwt(const char *fn)\n{\n\tbwt_t *bwt;\n\tFILE *fp;\n\n\tbwt = (bwt_t*)calloc(1, sizeof(bwt_t));\n\tfp = xopen(fn, \"rb\");\n\terr_fseek(fp, 0, SEEK_END);\n\tbwt->bwt_size = (err_ftell(fp) - sizeof(bwtint_t) * 5) >> 2;\n\tbwt->bwt = (uint32_t*)calloc(bwt->bwt_size, 4);\n\terr_fseek(fp, 0, SEEK_SET);\n\terr_fread_noeof(&bwt->primary, sizeof(bwtint_t), 1, fp);\n\terr_fread_noeof(bwt->L2+1, sizeof(bwtint_t), 4, fp);\n\tfread_fix(fp, bwt->bwt_size<<2, bwt->bwt);\n\tbwt->seq_len = bwt->L2[4];\n\terr_fclose(fp);\n\tbwt_gen_cnt_table(bwt);\n\n\treturn bwt;\n}", "idx": 16}
{"project": "BWA", "commit_id": "116_BWA_0.7.17_bwt.c_bwt_destroy.c", "target": 0, "func": "void bwt_destroy(bwt_t *bwt)\n{\n\tif (bwt == 0) return;\n\tfree(bwt->sa); free(bwt->bwt);\n\tfree(bwt);\n}", "idx": 17}
{"project": "BWA", "commit_id": "117_BWA_0.7.17_bwtaln.c_gap_init_opt.c", "target": 0, "func": "gap_opt_t *gap_init_opt()\n{\n\tgap_opt_t *o;\n\to = (gap_opt_t*)calloc(1, sizeof(gap_opt_t));\n\t/* IMPORTANT: s_mm*10 should be about the average base error\n\t   rate. Voilating this requirement will break pairing! */\n\to->s_mm = 3; o->s_gapo = 11; o->s_gape = 4;\n\to->max_diff = -1; o->max_gapo = 1; o->max_gape = 6;\n\to->indel_end_skip = 5; o->max_del_occ = 10; o->max_entries = 2000000;\n\to->mode = BWA_MODE_GAPE | BWA_MODE_COMPREAD;\n\to->seed_len = 32; o->max_seed_diff = 2;\n\to->fnr = 0.04;\n\to->n_threads = 1;\n\to->max_top2 = 30;\n\to->trim_qual = 0;\n\treturn o;\n}", "idx": 18}
{"project": "BWA", "commit_id": "118_BWA_0.7.17_bwtaln.c_bwa_cal_maxdiff.c", "target": 0, "func": "int bwa_cal_maxdiff(int l, double err, double thres)\n{\n\tdouble elambda = exp(-l * err);\n\tdouble sum, y = 1.0;\n\tint k, x = 1;\n\tfor (k = 1, sum = elambda; k < 1000; ++k) {\n\t\ty *= l * err;\n\t\tx *= k;\n\t\tsum += elambda * y / x;\n\t\tif (1.0 - sum < thres) return k;\n\t}\n\treturn 2;\n}", "idx": 19}
{"project": "BWA", "commit_id": "119_BWA_0.7.17_bwtaln.c_bwt_cal_width.c", "target": 0, "func": "width must be filled as zero\nint bwt_cal_width(const bwt_t *bwt, int len, const ubyte_t *str, bwt_width_t *width)\n{\n\tbwtint_t k, l, ok, ol;\n\tint i, bid;\n\tbid = 0;\n\tk = 0; l = bwt->seq_len;\n\tfor (i = 0; i < len; ++i) {\n\t\tubyte_t c = str[i];\n\t\tif (c < 4) {\n\t\t\tbwt_2occ(bwt, k - 1, l, c, &ok, &ol);\n\t\t\tk = bwt->L2[c] + ok + 1;\n\t\t\tl = bwt->L2[c] + ol;\n\t\t}\n\t\tif (k > l || c > 3) { // then restart\n\t\t\tk = 0;\n\t\t\tl = bwt->seq_len;\n\t\t\t++bid;\n\t\t}\n\t\twidth[i].w = l - k + 1;\n\t\twidth[i].bid = bid;\n\t}\n\twidth[len].w = 0;\n\twidth[len].bid = ++bid;\n\treturn bid;\n}", "idx": 20}
{"project": "BWA", "commit_id": "11_BWA_0.7.17_bamlite.c_swap_endian_data.c", "target": 0, "func": "static void swap_endian_data(const bam1_core_t *c, int data_len, uint8_t *data)\n{\n\tuint8_t *s;\n\tuint32_t i, *cigar = (uint32_t*)(data + c->l_qname);\n\ts = data + c->n_cigar*4 + c->l_qname + c->l_qseq + (c->l_qseq + 1)/2;\n\tfor (i = 0; i < c->n_cigar; ++i) bam_swap_endian_4p(&cigar[i]);\n\twhile (s < data + data_len) {\n\t\tuint8_t type;\n\t\ts += 2; // skip key\n\t\ttype = toupper(*s); ++s; // skip type\n\t\tif (type == 'C' || type == 'A') ++s;\n\t\telse if (type == 'S') { bam_swap_endian_2p(s); s += 2; }\n\t\telse if (type == 'I' || type == 'F') { bam_swap_endian_4p(s); s += 4; }\n\t\telse if (type == 'D') { bam_swap_endian_8p(s); s += 8; }\n\t\telse if (type == 'Z' || type == 'H') { while (*s) ++s; ++s; }\n\t}\n}", "idx": 21}
{"project": "BWA", "commit_id": "120_BWA_0.7.17_bwtaln.c_bwa_cal_sa_reg_gap.c", "target": 0, "func": "void bwa_cal_sa_reg_gap(int tid, bwt_t *const bwt, int n_seqs, bwa_seq_t *seqs, const gap_opt_t *opt)\n{\n\tint i, j, max_l = 0, max_len;\n\tgap_stack_t *stack;\n\tbwt_width_t *w, *seed_w;\n\tgap_opt_t local_opt = *opt;\n\n\t// initiate priority stack\n\tfor (i = max_len = 0; i != n_seqs; ++i)\n\t\tif (seqs[i].len > max_len) max_len = seqs[i].len;\n\tif (opt->fnr > 0.0) local_opt.max_diff = bwa_cal_maxdiff(max_len, BWA_AVG_ERR, opt->fnr);\n\tif (local_opt.max_diff < local_opt.max_gapo) local_opt.max_gapo = local_opt.max_diff;\n\tstack = gap_init_stack(local_opt.max_diff, local_opt.max_gapo, local_opt.max_gape, &local_opt);\n\n\tseed_w = (bwt_width_t*)calloc(opt->seed_len+1, sizeof(bwt_width_t));\n\tw = 0;\n\tfor (i = 0; i != n_seqs; ++i) {\n\t\tbwa_seq_t *p = seqs + i;\n#ifdef HAVE_PTHREAD\n\t\tif (i % opt->n_threads != tid) continue;\n#endif\n\t\tp->sa = 0; p->type = BWA_TYPE_NO_MATCH; p->c1 = p->c2 = 0; p->n_aln = 0; p->aln = 0;\n\t\tif (max_l < p->len) {\n\t\t\tmax_l = p->len;\n\t\t\tw = (bwt_width_t*)realloc(w, (max_l + 1) * sizeof(bwt_width_t));\n\t\t\tmemset(w, 0, (max_l + 1) * sizeof(bwt_width_t));\n\t\t}\n\t\tbwt_cal_width(bwt, p->len, p->seq, w);\n\t\tif (opt->fnr > 0.0) local_opt.max_diff = bwa_cal_maxdiff(p->len, BWA_AVG_ERR, opt->fnr);\n\t\tlocal_opt.seed_len = opt->seed_len < p->len? opt->seed_len : 0x7fffffff;\n\t\tif (p->len > opt->seed_len)\n\t\t\tbwt_cal_width(bwt, opt->seed_len, p->seq + (p->len - opt->seed_len), seed_w);\n\t\t// core function\n\t\tfor (j = 0; j < p->len; ++j) // we need to complement\n\t\t\tp->seq[j] = p->seq[j] > 3? 4 : 3 - p->seq[j];\n\t\tp->aln = bwt_match_gap(bwt, p->len, p->seq, w, p->len <= opt->seed_len? 0 : seed_w, &local_opt, &p->n_aln, stack);\n\t\t//fprintf(stderr, \"mm=%lld,ins=%lld,del=%lld,gapo=%lld\\n\", p->aln->n_mm, p->aln->n_ins, p->aln->n_del, p->aln->n_gapo);\n\t\t// clean up the unused data in the record\n\t\tfree(p->name); free(p->seq); free(p->rseq); free(p->qual);\n\t\tp->name = 0; p->seq = p->rseq = p->qual = 0;\n\t}\n\tfree(seed_w); free(w);\n\tgap_destroy_stack(stack);\n}", "idx": 22}
{"project": "BWA", "commit_id": "121_BWA_0.7.17_bwtaln.c_worker.c", "target": 0, "func": "static void *worker(void *data)\n{\n\tthread_aux_t *d = (thread_aux_t*)data;\n\tbwa_cal_sa_reg_gap(d->tid, d->bwt, d->n_seqs, d->seqs, d->opt);\n\treturn 0;\n}", "idx": 23}
{"project": "BWA", "commit_id": "122_BWA_0.7.17_bwtaln.c_bwa_open_reads.c", "target": 0, "func": "bwa_seqio_t *bwa_open_reads(int mode, const char *fn_fa)\n{\n\tbwa_seqio_t *ks;\n\tif (mode & BWA_MODE_BAM) { // open BAM\n\t\tint which = 0;\n\t\tif (mode & BWA_MODE_BAM_SE) which |= 4;\n\t\tif (mode & BWA_MODE_BAM_READ1) which |= 1;\n\t\tif (mode & BWA_MODE_BAM_READ2) which |= 2;\n\t\tif (which == 0) which = 7; // then read all reads\n\t\tks = bwa_bam_open(fn_fa, which);\n\t} else ks = bwa_seq_open(fn_fa);\n\treturn ks;\n}", "idx": 24}
{"project": "BWA", "commit_id": "123_BWA_0.7.17_bwtaln.c_bwa_aln.c", "target": 0, "func": "int bwa_aln(int argc, char *argv[])\n{\n\tint c, opte = -1;\n\tgap_opt_t *opt;\n\tchar *prefix;\n\n\topt = gap_init_opt();\n\twhile ((c = getopt(argc, argv, \"n:o:e:i:d:l:k:LR:m:t:NM:O:E:q:f:b012IYB:\")) >= 0) {\n\t\tswitch (c) {\n\t\tcase 'n':\n\t\t\tif (strstr(optarg, \".\")) opt->fnr = atof(optarg), opt->max_diff = -1;\n\t\t\telse opt->max_diff = atoi(optarg), opt->fnr = -1.0;\n\t\t\tbreak;\n\t\tcase 'o': opt->max_gapo = atoi(optarg); break;\n\t\tcase 'e': opte = atoi(optarg); break;\n\t\tcase 'M': opt->s_mm = atoi(optarg); break;\n\t\tcase 'O': opt->s_gapo = atoi(optarg); break;\n\t\tcase 'E': opt->s_gape = atoi(optarg); break;\n\t\tcase 'd': opt->max_del_occ = atoi(optarg); break;\n\t\tcase 'i': opt->indel_end_skip = atoi(optarg); break;\n\t\tcase 'l': opt->seed_len = atoi(optarg); break;\n\t\tcase 'k': opt->max_seed_diff = atoi(optarg); break;\n\t\tcase 'm': opt->max_entries = atoi(optarg); break;\n\t\tcase 't': opt->n_threads = atoi(optarg); break;\n\t\tcase 'L': opt->mode |= BWA_MODE_LOGGAP; break;\n\t\tcase 'R': opt->max_top2 = atoi(optarg); break;\n\t\tcase 'q': opt->trim_qual = atoi(optarg); break;\n\t\tcase 'N': opt->mode |= BWA_MODE_NONSTOP; opt->max_top2 = 0x7fffffff; break;\n\t\tcase 'f': xreopen(optarg, \"wb\", stdout); break;\n\t\tcase 'b': opt->mode |= BWA_MODE_BAM; break;\n\t\tcase '0': opt->mode |= BWA_MODE_BAM_SE; break;\n\t\tcase '1': opt->mode |= BWA_MODE_BAM_READ1; break;\n\t\tcase '2': opt->mode |= BWA_MODE_BAM_READ2; break;\n\t\tcase 'I': opt->mode |= BWA_MODE_IL13; break;\n\t\tcase 'Y': opt->mode |= BWA_MODE_CFY; break;\n\t\tcase 'B': opt->mode |= atoi(optarg) << 24; break;\n\t\tdefault: return 1;\n\t\t}\n\t}\n\tif (opte > 0) {\n\t\topt->max_gape = opte;\n\t\topt->mode &= ~BWA_MODE_GAPE;\n\t}\n\n\tif (optind + 2 > argc) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Usage:   bwa aln [options] <prefix> <in.fq>\\n\\n\");\n\t\tfprintf(stderr, \"Options: -n NUM    max #diff (int) or missing prob under %.2f err rate (float) [%.2f]\\n\",\n\t\t\t\tBWA_AVG_ERR, opt->fnr);\n\t\tfprintf(stderr, \"         -o INT    maximum number or fraction of gap opens [%d]\\n\", opt->max_gapo);\n\t\tfprintf(stderr, \"         -e INT    maximum number of gap extensions, -1 for disabling long gaps [-1]\\n\");\n\t\tfprintf(stderr, \"         -i INT    do not put an indel within INT bp towards the ends [%d]\\n\", opt->indel_end_skip);\n\t\tfprintf(stderr, \"         -d INT    maximum occurrences for extending a long deletion [%d]\\n\", opt->max_del_occ);\n\t\tfprintf(stderr, \"         -l INT    seed length [%d]\\n\", opt->seed_len);\n\t\tfprintf(stderr, \"         -k INT    maximum differences in the seed [%d]\\n\", opt->max_seed_diff);\n\t\tfprintf(stderr, \"         -m INT    maximum entries in the queue [%d]\\n\", opt->max_entries);\n\t\tfprintf(stderr, \"         -t INT    number of threads [%d]\\n\", opt->n_threads);\n\t\tfprintf(stderr, \"         -M INT    mismatch penalty [%d]\\n\", opt->s_mm);\n\t\tfprintf(stderr, \"         -O INT    gap open penalty [%d]\\n\", opt->s_gapo);\n\t\tfprintf(stderr, \"         -E INT    gap extension penalty [%d]\\n\", opt->s_gape);\n\t\tfprintf(stderr, \"         -R INT    stop searching when there are >INT equally best hits [%d]\\n\", opt->max_top2);\n\t\tfprintf(stderr, \"         -q INT    quality threshold for read trimming down to %dbp [%d]\\n\", BWA_MIN_RDLEN, opt->trim_qual);\n        fprintf(stderr, \"         -f FILE   file to write output to instead of stdout\\n\");\n\t\tfprintf(stderr, \"         -B INT    length of barcode\\n\");\n\t\tfprintf(stderr, \"         -L        log-scaled gap penalty for long deletions\\n\");\n\t\tfprintf(stderr, \"         -N        non-iterative mode: search for all n-difference hits (slooow)\\n\");\n\t\tfprintf(stderr, \"         -I        the input is in the Illumina 1.3+ FASTQ-like format\\n\");\n\t\tfprintf(stderr, \"         -b        the input read file is in the BAM format\\n\");\n\t\tfprintf(stderr, \"         -0        use single-end reads only (effective with -b)\\n\");\n\t\tfprintf(stderr, \"         -1        use the 1st read in a pair (effective with -b)\\n\");\n\t\tfprintf(stderr, \"         -2        use the 2nd read in a pair (effective with -b)\\n\");\n\t\tfprintf(stderr, \"         -Y        filter Casava-filtered sequences\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn 1;\n\t}\n\tif (opt->fnr > 0.0) {\n\t\tint i, k;\n\t\tfor (i = 17, k = 0; i <= 250; ++i) {\n\t\t\tint l = bwa_cal_maxdiff(i, BWA_AVG_ERR, opt->fnr);\n\t\t\tif (l != k) fprintf(stderr, \"[bwa_aln] %dbp reads: max_diff = %d\\n\", i, l);\n\t\t\tk = l;\n\t\t}\n\t}\n\tif ((prefix = bwa_idx_infer_prefix(argv[optind])) == 0) {\n\t\tfprintf(stderr, \"[%s] fail to locate the index\\n\", __func__);\n\t\tfree(opt);\n\t\treturn 1;\n\t}\n\tbwa_aln_core(prefix, argv[optind+1], opt);\n\tfree(opt); free(prefix);\n\treturn 0;\n}", "idx": 25}
{"project": "BWA", "commit_id": "124_BWA_0.7.17_bwtgap.c_gap_init_stack2.c", "target": 0, "func": "gap_stack_t *gap_init_stack2(int max_score)\n{\n\tgap_stack_t *stack;\n\tstack = (gap_stack_t*)calloc(1, sizeof(gap_stack_t));\n\tstack->n_stacks = max_score;\n\tstack->stacks = (gap_stack1_t*)calloc(stack->n_stacks, sizeof(gap_stack1_t));\n\treturn stack;\n}", "idx": 26}
{"project": "BWA", "commit_id": "125_BWA_0.7.17_bwtgap.c_gap_init_stack.c", "target": 0, "func": "gap_stack_t *gap_init_stack(int max_mm, int max_gapo, int max_gape, const gap_opt_t *opt)\n{\n\treturn gap_init_stack2(aln_score(max_mm+1, max_gapo+1, max_gape+1, opt));\n}", "idx": 27}
{"project": "BWA", "commit_id": "126_BWA_0.7.17_bwtgap.c_gap_destroy_stack.c", "target": 0, "func": "void gap_destroy_stack(gap_stack_t *stack)\n{\n\tint i;\n\tfor (i = 0; i != stack->n_stacks; ++i) free(stack->stacks[i].stack);\n\tfree(stack->stacks);\n\tfree(stack);\n}", "idx": 28}
{"project": "BWA", "commit_id": "127_BWA_0.7.17_bwtgap.c_gap_reset_stack.c", "target": 0, "func": "static void gap_reset_stack(gap_stack_t *stack)\n{\n\tint i;\n\tfor (i = 0; i != stack->n_stacks; ++i)\n\t\tstack->stacks[i].n_entries = 0;\n\tstack->best = stack->n_stacks;\n\tstack->n_entries = 0;\n}", "idx": 29}
{"project": "BWA", "commit_id": "128_BWA_0.7.17_bwtgap.c_gap_push.c", "target": 0, "func": "static inline void gap_push(gap_stack_t *stack, int i, bwtint_t k, bwtint_t l, int n_mm, int n_gapo, int n_gape, int n_ins, int n_del,\n\t\t\t\t\t\t\tint state, int is_diff, const gap_opt_t *opt)\n{\n\tint score;\n\tgap_entry_t *p;\n\tgap_stack1_t *q;\n\tscore = aln_score(n_mm, n_gapo, n_gape, opt);\n\tq = stack->stacks + score;\n\tif (q->n_entries == q->m_entries) {\n\t\tq->m_entries = q->m_entries? q->m_entries<<1 : 4;\n\t\tq->stack = (gap_entry_t*)realloc(q->stack, sizeof(gap_entry_t) * q->m_entries);\n\t}\n\tp = q->stack + q->n_entries;\n\tp->info = (uint32_t)score<<21 | i; p->k = k; p->l = l;\n\tp->n_mm = n_mm; p->n_gapo = n_gapo; p->n_gape = n_gape;\n\tp->n_ins = n_ins; p->n_del = n_del;\n\tp->state = state; \n\tp->last_diff_pos = is_diff? i : 0;\n\t++(q->n_entries);\n\t++(stack->n_entries);\n\tif (stack->best > score) stack->best = score;\n}", "idx": 30}
{"project": "BWA", "commit_id": "129_BWA_0.7.17_bwtgap.c_gap_pop.c", "target": 0, "func": "static inline void gap_pop(gap_stack_t *stack, gap_entry_t *e)\n{\n\tgap_stack1_t *q;\n\tq = stack->stacks + stack->best;\n\t*e = q->stack[q->n_entries - 1];\n\t--(q->n_entries);\n\t--(stack->n_entries);\n\tif (q->n_entries == 0 && stack->n_entries) { // reset best\n\t\tint i;\n\t\tfor (i = stack->best + 1; i < stack->n_stacks; ++i)\n\t\t\tif (stack->stacks[i].n_entries != 0) break;\n\t\tstack->best = i;\n\t} else if (stack->n_entries == 0) stack->best = stack->n_stacks;\n}", "idx": 31}
{"project": "BWA", "commit_id": "12_BWA_0.7.17_bamlite.c_bam_read1.c", "target": 0, "func": "int bam_read1(bamFile fp, bam1_t *b)\n{\n\tbam1_core_t *c = &b->core;\n\tint32_t block_len, ret, i;\n\tuint32_t x[8];\n\n\tif ((ret = bam_read(fp, &block_len, 4)) != 4) {\n\t\tif (ret == 0) return -1; // normal end-of-file\n\t\telse return -2; // truncated\n\t}\n\tif (bam_read(fp, x, sizeof(bam1_core_t)) != sizeof(bam1_core_t)) return -3;\n\tif (bam_is_be) {\n\t\tbam_swap_endian_4p(&block_len);\n\t\tfor (i = 0; i < 8; ++i) bam_swap_endian_4p(x + i);\n\t}\n\tc->tid = x[0]; c->pos = x[1];\n\tc->bin = x[2]>>16; c->qual = x[2]>>8&0xff; c->l_qname = x[2]&0xff;\n\tc->flag = x[3]>>16; c->n_cigar = x[3]&0xffff;\n\tc->l_qseq = x[4];\n\tc->mtid = x[5]; c->mpos = x[6]; c->isize = x[7];\n\tb->data_len = block_len - sizeof(bam1_core_t);\n\tif (b->m_data < b->data_len) {\n\t\tb->m_data = b->data_len;\n\t\tkroundup32(b->m_data);\n\t\tb->data = (uint8_t*)realloc(b->data, b->m_data);\n\t}\n\tif (bam_read(fp, b->data, b->data_len) != b->data_len) return -4;\n\tb->l_aux = b->data_len - c->n_cigar * 4 - c->l_qname - c->l_qseq - (c->l_qseq+1)/2;\n\tif (bam_is_be) swap_endian_data(c, b->data_len, b->data);\n\treturn 4 + block_len;\n}", "idx": 32}
{"project": "BWA", "commit_id": "130_BWA_0.7.17_bwtgap.c_gap_shadow.c", "target": 0, "func": "static inline void gap_shadow(int x, int len, bwtint_t max, int last_diff_pos, bwt_width_t *w)\n{\n\tint i, j;\n\tfor (i = j = 0; i < last_diff_pos; ++i) {\n\t\tif (w[i].w > x) w[i].w -= x;\n\t\telse if (w[i].w == x) {\n\t\t\tw[i].bid = 1;\n\t\t\tw[i].w = max - (++j);\n\t\t} // else should not happen\n\t}\n}", "idx": 33}
{"project": "BWA", "commit_id": "131_BWA_0.7.17_bwtgap.c_int_log2.c", "target": 0, "func": "static inline int int_log2(uint32_t v)\n{\n\tint c = 0;\n\tif (v & 0xffff0000u) { v >>= 16; c |= 16; }\n\tif (v & 0xff00) { v >>= 8; c |= 8; }\n\tif (v & 0xf0) { v >>= 4; c |= 4; }\n\tif (v & 0xc) { v >>= 2; c |= 2; }\n\tif (v & 0x2) c |= 1;\n\treturn c;\n}", "idx": 34}
{"project": "BWA", "commit_id": "132_BWA_0.7.17_bwtindex.c_bwa_seq_len.c", "target": 0, "func": "int64_t bwa_seq_len(const char *fn_pac)\n{\n\tFILE *fp;\n\tint64_t pac_len;\n\tubyte_t c;\n\tfp = xopen(fn_pac, \"rb\");\n\terr_fseek(fp, -1, SEEK_END);\n\tpac_len = err_ftell(fp);\n\terr_fread_noeof(&c, 1, 1, fp);\n\terr_fclose(fp);\n\treturn (pac_len - 1) * 4 + (int)c;\n}", "idx": 35}
{"project": "BWA", "commit_id": "133_BWA_0.7.17_bwtindex.c_bwt_bwtupdate_core.c", "target": 0, "func": "void bwt_bwtupdate_core(bwt_t *bwt)\n{\n\tbwtint_t i, k, c[4], n_occ;\n\tuint32_t *buf;\n\n\tn_occ = (bwt->seq_len + OCC_INTERVAL - 1) / OCC_INTERVAL + 1;\n\tbwt->bwt_size += n_occ * sizeof(bwtint_t); // the new size\n\tbuf = (uint32_t*)calloc(bwt->bwt_size, 4); // will be the new bwt\n\tc[0] = c[1] = c[2] = c[3] = 0;\n\tfor (i = k = 0; i < bwt->seq_len; ++i) {\n\t\tif (i % OCC_INTERVAL == 0) {\n\t\t\tmemcpy(buf + k, c, sizeof(bwtint_t) * 4);\n\t\t\tk += sizeof(bwtint_t); // in fact: sizeof(bwtint_t)=4*(sizeof(bwtint_t)/4)\n\t\t}\n\t\tif (i % 16 == 0) buf[k++] = bwt->bwt[i/16]; // 16 == sizeof(uint32_t)/2\n\t\t++c[bwt_B00(bwt, i)];\n\t}\n\t// the last element\n\tmemcpy(buf + k, c, sizeof(bwtint_t) * 4);\n\txassert(k + sizeof(bwtint_t) == bwt->bwt_size, \"inconsistent bwt_size\");\n\t// update bwt\n\tfree(bwt->bwt); bwt->bwt = buf;\n}", "idx": 36}
{"project": "BWA", "commit_id": "134_BWA_0.7.17_bwtindex.c_bwa_idx_build.c", "target": 0, "func": "int bwa_idx_build(const char *fa, const char *prefix, int algo_type, int block_size)\n{\n\textern void bwa_pac_rev_core(const char *fn, const char *fn_rev);\n\n\tchar *str, *str2, *str3;\n\tclock_t t;\n\tint64_t l_pac;\n\n\tstr  = (char*)calloc(strlen(prefix) + 10, 1);\n\tstr2 = (char*)calloc(strlen(prefix) + 10, 1);\n\tstr3 = (char*)calloc(strlen(prefix) + 10, 1);\n\n\t{ // nucleotide indexing\n\t\tgzFile fp = xzopen(fa, \"r\");\n\t\tt = clock();\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"[bwa_index] Pack FASTA... \");\n\t\tl_pac = bns_fasta2bntseq(fp, prefix, 0);\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC);\n\t\terr_gzclose(fp);\n\t}\n\tif (algo_type == 0) algo_type = l_pac > 50000000? 2 : 3; // set the algorithm for generating BWT\n\t{\n\t\tstrcpy(str, prefix); strcat(str, \".pac\");\n\t\tstrcpy(str2, prefix); strcat(str2, \".bwt\");\n\t\tt = clock();\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"[bwa_index] Construct BWT for the packed sequence...\\n\");\n\t\tif (algo_type == 2) bwt_bwtgen2(str, str2, block_size);\n\t\telse if (algo_type == 1 || algo_type == 3) {\n\t\t\tbwt_t *bwt;\n\t\t\tbwt = bwt_pac2bwt(str, algo_type == 3);\n\t\t\tbwt_dump_bwt(str2, bwt);\n\t\t\tbwt_destroy(bwt);\n\t\t}\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"[bwa_index] %.2f seconds elapse.\\n\", (float)(clock() - t) / CLOCKS_PER_SEC);\n\t}\n\t{\n\t\tbwt_t *bwt;\n\t\tstrcpy(str, prefix); strcat(str, \".bwt\");\n\t\tt = clock();\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"[bwa_index] Update BWT... \");\n\t\tbwt = bwt_restore_bwt(str);\n\t\tbwt_bwtupdate_core(bwt);\n\t\tbwt_dump_bwt(str, bwt);\n\t\tbwt_destroy(bwt);\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC);\n\t}\n\t{\n\t\tgzFile fp = xzopen(fa, \"r\");\n\t\tt = clock();\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"[bwa_index] Pack forward-only FASTA... \");\n\t\tl_pac = bns_fasta2bntseq(fp, prefix, 1);\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC);\n\t\terr_gzclose(fp);\n\t}\n\t{\n\t\tbwt_t *bwt;\n\t\tstrcpy(str, prefix); strcat(str, \".bwt\");\n\t\tstrcpy(str3, prefix); strcat(str3, \".sa\");\n\t\tt = clock();\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"[bwa_index] Construct SA from BWT and Occ... \");\n\t\tbwt = bwt_restore_bwt(str);\n\t\tbwt_cal_sa(bwt, 32);\n\t\tbwt_dump_sa(str3, bwt);\n\t\tbwt_destroy(bwt);\n\t\tif (bwa_verbose >= 3) fprintf(stderr, \"%.2f sec\\n\", (float)(clock() - t) / CLOCKS_PER_SEC);\n\t}\n\tfree(str3); free(str2); free(str);\n\treturn 0;\n}", "idx": 37}
{"project": "BWA", "commit_id": "135_BWA_0.7.17_bwtsw2_aux.c_bsw2_init_opt.c", "target": 0, "func": "bsw2opt_t *bsw2_init_opt()\n{\n\tbsw2opt_t *o = (bsw2opt_t*)calloc(1, sizeof(bsw2opt_t));\n\to->a = 1; o->b = 3; o->q = 5; o->r = 2; o->t = 30;\n\to->bw = 50;\n\to->max_ins = 20000;\n\to->z = 1; o->is = 3; o->t_seeds = 5; o->hard_clip = 0; o->skip_sw = 0;\n\to->mask_level = 0.50f; o->coef = 5.5f;\n\to->qr = o->q + o->r; o->n_threads = 1; o->chunk_size = 10000000;\n\to->max_chain_gap = 10000;\n\to->cpy_cmt = 0;\n\treturn o;\n}", "idx": 38}
{"project": "BWA", "commit_id": "136_BWA_0.7.17_bwtsw2_aux.c_bsw2_destroy.c", "target": 0, "func": "void bsw2_destroy(bwtsw2_t *b)\n{\n\tint i;\n\tif (b == 0) return;\n\tif (b->aux)\n\t\tfor (i = 0; i < b->n; ++i) free(b->aux[i].cigar);\n\tfree(b->aux); free(b->hits);\n\tfree(b);\n}", "idx": 39}
{"project": "BWA", "commit_id": "137_BWA_0.7.17_bwtsw2_aux.c_bsw2_dup_no_cigar.c", "target": 0, "func": "bwtsw2_t *bsw2_dup_no_cigar(const bwtsw2_t *b)\n{\n\tbwtsw2_t *p;\n\tp = calloc(1, sizeof(bwtsw2_t));\n\tp->max = p->n = b->n;\n\tif (b->n) {\n\t\tkroundup32(p->max);\n\t\tp->hits = calloc(p->max, sizeof(bsw2hit_t));\n\t\tmemcpy(p->hits, b->hits, p->n * sizeof(bsw2hit_t));\n\t}\n\treturn p;\n}", "idx": 40}
{"project": "BWA", "commit_id": "138_BWA_0.7.17_bwtsw2_aux.c_bsw2_extend_rght.c", "target": 0, "func": "void bsw2_extend_rght(const bsw2opt_t *opt, bwtsw2_t *b, uint8_t *query, int lq, uint8_t *pac, bwtint_t l_pac, uint8_t *_mem)\n{\n\tint i;\n\tbwtint_t k;\n\tuint8_t *target;\n\tint8_t mat[25];\n\n\tbwa_fill_scmat(opt->a, opt->b, mat);\n\ttarget = calloc(((lq + 1) / 2 * opt->a + opt->r) / opt->r + lq, 1);\n\tfor (i = 0; i < b->n; ++i) {\n\t\tbsw2hit_t *p = b->hits + i;\n\t\tint lt = ((lq - p->beg + 1) / 2 * opt->a + opt->r) / opt->r + lq;\n\t\tint j, score, qle, tle;\n\t\tif (p->l) continue;\n\t\tfor (k = p->k, j = 0; k < p->k + lt && k < l_pac; ++k)\n\t\t\ttarget[j++] = pac[k>>2] >> (~k&3)*2 & 0x3;\n\t\tlt = j;\n\t\tscore = ksw_extend(lq - p->beg, &query[p->beg], lt, target, 5, mat, opt->q, opt->r, opt->bw, 0, -1, 1, &qle, &tle, 0, 0, 0) - 1;\n//\t\tif (score < p->G) fprintf(stderr, \"[bsw2_extend_hits] %d < %d\\n\", score, p->G);\n\t\tif (score >= p->G) {\n\t\t\tp->G = score;\n\t\t\tp->len = tle;\n\t\t\tp->end = p->beg + qle;\n\t\t}\n\t}\n\tfree(target);\n}", "idx": 41}
{"project": "BWA", "commit_id": "139_BWA_0.7.17_bwtsw2_aux.c_bsw2_debug_hits.c", "target": 0, "func": "void bsw2_debug_hits(const bwtsw2_t *b)\n{\n\tint i;\n\tprintf(\"# raw hits: %d\\n\", b->n);\n\tfor (i = 0; i < b->n; ++i) {\n\t\tbsw2hit_t *p = b->hits + i;\n\t\tif (p->G > 0)\n\t\t\tprintf(\"G=%d, G2=%d, len=%d, [%d,%d), k=%lu, l=%lu, #seeds=%d, is_rev=%d\\n\", p->G, p->G2, p->len, p->beg, p->end, (long)p->k, (long)p->l, p->n_seeds, p->is_rev);\n\t}\n}", "idx": 42}
{"project": "BWA", "commit_id": "13_BWA_0.7.17_bamlite.c_bamlite_gzopen.c", "target": 0, "func": "gzread and gzclose that print up error messages\n\ngzFile bamlite_gzopen(const char *fn, const char *mode) {\n\tgzFile fp;\n\tif (strcmp(fn, \"-\") == 0) {\n\t\tfp = gzdopen(fileno((strstr(mode, \"r\"))? stdin : stdout), mode);\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Couldn't open %s : %s\",\n\t\t\t\t\t(strstr(mode, \"r\"))? \"stdin\" : \"stdout\",\n\t\t\t\t\tstrerror(errno));\n\t\t}\n\t\treturn fp;\n\t}\n\tif ((fp = gzopen(fn, mode)) == 0) {\n\t\tfprintf(stderr, \"Couldn't open %s : %s\\n\", fn,\n\t\t\t\terrno ? strerror(errno) : \"Out of memory\");\n\t}\n\treturn fp;\n}", "idx": 43}
{"project": "BWA", "commit_id": "140_BWA_0.7.17_bwtsw2_aux.c_merge_hits.c", "target": 0, "func": "static void merge_hits(bwtsw2_t *b[2], int l, int is_reverse)\n{\n\tint i;\n\tif (b[0]->n + b[1]->n > b[0]->max) {\n\t\tb[0]->max = b[0]->n + b[1]->n;\n\t\tb[0]->hits = realloc(b[0]->hits, b[0]->max * sizeof(bsw2hit_t));\n\t}\n\tfor (i = 0; i < b[1]->n; ++i) {\n\t\tbsw2hit_t *p = b[0]->hits + b[0]->n + i;\n\t\t*p = b[1]->hits[i];\n\t\tif (is_reverse) {\n\t\t\tint x = p->beg;\n\t\t\tp->beg = l - p->end;\n\t\t\tp->end = l - x;\n\t\t\tp->flag |= 0x10;\n\t\t}\n\t}\n\tb[0]->n += b[1]->n;\n\tbsw2_destroy(b[1]);\n\tb[1] = 0;\n}", "idx": 44}
{"project": "BWA", "commit_id": "141_BWA_0.7.17_bwtsw2_aux.c_write_aux.c", "target": 0, "func": "static void write_aux(const bsw2opt_t *opt, const bntseq_t *bns, int qlen, uint8_t *seq[2], const uint8_t *pac, bwtsw2_t *b, const char *name)\n{\n\tint i;\n\t// allocate for b->aux\n\tif (b->n<<1 < b->max) {\n\t\tb->max = b->n;\n\t\tkroundup32(b->max);\n\t\tb->hits = realloc(b->hits, b->max * sizeof(bsw2hit_t));\n\t}\n\tb->aux = calloc(b->n, sizeof(bsw2aux_t));\n\t// generate CIGAR\n\tgen_cigar(opt, qlen, seq, bns->l_pac, pac, b, name);\n\t// fix CIGAR, generate mapQ, and write chromosomal position\n\tfor (i = 0; i < b->n; ++i) {\n\t\tbsw2hit_t *p = &b->hits[i];\n\t\tbsw2aux_t *q = &b->aux[i];\n\t\tq->flag = p->flag & 0xfe;\n\t\tq->isize = 0;\n\t\tif (p->l == 0) { // unique hit\n\t\t\tfloat c = 1.0;\n\t\t\tint subo;\n\t\t\t// fix out-of-boundary CIGAR\n\t\t\tq->n_cigar = fix_cigar(bns, p, q->n_cigar, q->cigar);\n\t\t\t// compute mapQ\n\t\t\tsubo = p->G2 > opt->t? p->G2 : opt->t;\n\t\t\tif (p->flag>>16 == 1 || p->flag>>16 == 2) c *= .5;\n\t\t\tif (p->n_seeds < 2) c *= .2;\n\t\t\tq->qual = (int)(c * (p->G - subo) * (250.0 / p->G + 0.03 / opt->a) + .499);\n\t\t\tif (q->qual > 250) q->qual = 250;\n\t\t\tif (q->qual < 0) q->qual = 0;\n\t\t\tif (p->flag&1) q->qual = 0; // this is a random hit\n\t\t\tq->pqual = q->qual; // set the paired qual as qual\n\t\t\t// get the chromosomal position\n\t\t\tq->nn = bns_cnt_ambi(bns, p->k, p->len, &q->chr);\n\t\t\tq->pos = p->k - bns->anns[q->chr].offset;\n\t\t} else q->qual = 0, q->n_cigar = 0, q->chr = q->pos = -1, q->nn = 0;\n\t}\n}", "idx": 45}
{"project": "BWA", "commit_id": "142_BWA_0.7.17_bwtsw2_aux.c_update_opt.c", "target": 0, "func": "static void update_opt(bsw2opt_t *dst, const bsw2opt_t *src, int qlen)\n{\n\tdouble ll = log(qlen);\n\tint i, k;\n\t*dst = *src;\n\tif (dst->t < ll * dst->coef) dst->t = (int)(ll * dst->coef + .499);\n\t// set band width: the query length sets a boundary on the maximum band width\n\tk = (qlen * dst->a - 2 * dst->q) / (2 * dst->r + dst->a);\n\ti = (qlen * dst->a - dst->a - dst->t) / dst->r;\n\tif (k > i) k = i;\n\tif (k < 1) k = 1; // I do not know if k==0 causes troubles\n\tdst->bw = src->bw < k? src->bw : k;\n}", "idx": 46}
{"project": "BWA", "commit_id": "143_BWA_0.7.17_bwtsw2_aux.c_worker.c", "target": 0, "func": "static void *worker(void *data)\n{\n\tthread_aux_t *p = (thread_aux_t*)data;\n\tbsw2_aln_core(p->_seq, p->_opt, p->bns, p->pac, p->target, p->is_pe);\n\treturn 0;\n}", "idx": 47}
{"project": "BWA", "commit_id": "144_BWA_0.7.17_bwtsw2_aux.c_process_seqs.c", "target": 0, "func": "static void process_seqs(bsw2seq_t *_seq, const bsw2opt_t *opt, const bntseq_t *bns, uint8_t *pac, const bwt_t *target, int is_pe)\n{\n\tint i;\n\tis_pe = is_pe? 1 : 0;\n\n#ifdef HAVE_PTHREAD\n\tif (opt->n_threads <= 1) {\n\t\tbsw2_aln_core(_seq, opt, bns, pac, target, is_pe);\n\t} else {\n\t\tpthread_t *tid;\n\t\tpthread_attr_t attr;\n\t\tthread_aux_t *data;\n\t\tint j;\n\t\tpthread_attr_init(&attr);\n\t\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\t\tdata = (thread_aux_t*)calloc(opt->n_threads, sizeof(thread_aux_t));\n\t\ttid = (pthread_t*)calloc(opt->n_threads, sizeof(pthread_t));\n\t\tfor (j = 0; j < opt->n_threads; ++j) {\n\t\t\tthread_aux_t *p = data + j;\n\t\t\tp->tid = j; p->_opt = opt; p->bns = bns; p->is_pe = is_pe;\n\t\t\tp->pac = pac; p->target = target;\n\t\t\tp->_seq = calloc(1, sizeof(bsw2seq_t));\n\t\t\tp->_seq->max = (_seq->n + opt->n_threads - 1) / opt->n_threads + 1;\n\t\t\tp->_seq->n = 0;\n\t\t\tp->_seq->seq = calloc(p->_seq->max, sizeof(bsw2seq1_t));\n\t\t}\n\t\tfor (i = 0; i < _seq->n; ++i) { // assign sequences to each thread\n\t\t\tbsw2seq_t *p = data[(i>>is_pe)%opt->n_threads]._seq;\n\t\t\tp->seq[p->n++] = _seq->seq[i];\n\t\t}\n\t\tfor (j = 0; j < opt->n_threads; ++j) pthread_create(&tid[j], &attr, worker, &data[j]);\n\t\tfor (j = 0; j < opt->n_threads; ++j) pthread_join(tid[j], 0);\n\t\tfor (j = 0; j < opt->n_threads; ++j) data[j]._seq->n = 0;\n\t\tfor (i = 0; i < _seq->n; ++i) { // copy the result from each thread back\n\t\t\tbsw2seq_t *p = data[(i>>is_pe)%opt->n_threads]._seq;\n\t\t\t_seq->seq[i] = p->seq[p->n++];\n\t\t}\n\t\tfor (j = 0; j < opt->n_threads; ++j) {\n\t\t\tthread_aux_t *p = data + j;\n\t\t\tfree(p->_seq->seq);\n\t\t\tfree(p->_seq);\n\t\t}\n\t\tfree(data); free(tid);\n\t}\n#else\n\tbsw2_aln_core(_seq, opt, bns, pac, target, is_pe);\n#endif\n\n\t// print and reset\n\tfor (i = 0; i < _seq->n; ++i) {\n\t\tbsw2seq1_t *p = _seq->seq + i;\n\t\tif (p->sam) err_printf(\"%s\", p->sam);\n\t\tfree(p->name); free(p->seq); free(p->qual); free(p->sam);\n\t\tp->tid = -1; p->l = 0;\n\t\tp->name = p->seq = p->qual = p->sam = 0;\n\t}\n\terr_fflush(stdout);\n\t_seq->n = 0;\n}", "idx": 48}
{"project": "BWA", "commit_id": "145_BWA_0.7.17_bwtsw2_aux.c_bsw2_aln.c", "target": 0, "func": "void bsw2_aln(const bsw2opt_t *opt, const bntseq_t *bns, bwt_t * const target, const char *fn, const char *fn2)\n{\n\tgzFile fp, fp2;\n\tkseq_t *ks, *ks2;\n\tint l, is_pe = 0, i, n;\n\tuint8_t *pac;\n\tbsw2seq_t *_seq;\n\tbseq1_t *bseq;\n\n\tpac = calloc(bns->l_pac/4+1, 1);\n\tfor (l = 0; l < bns->n_seqs; ++l)\n\t\terr_printf(\"@SQ\\tSN:%s\\tLN:%d\\n\", bns->anns[l].name, bns->anns[l].len);\n\terr_fread_noeof(pac, 1, bns->l_pac/4+1, bns->fp_pac);\n\tfp = xzopen(fn, \"r\");\n\tks = kseq_init(fp);\n\t_seq = calloc(1, sizeof(bsw2seq_t));\n\tif (fn2) {\n\t\tfp2 = xzopen(fn2, \"r\");\n\t\tks2 = kseq_init(fp2);\n\t\tis_pe = 1;\n\t} else fp2 = 0, ks2 = 0, is_pe = 0;\n\twhile ((bseq = bseq_read(opt->chunk_size * opt->n_threads, &n, ks, ks2)) != 0) {\n\t\tint size = 0;\n\t\tif (n > _seq->max) {\n\t\t\t_seq->max = n;\n\t\t\tkroundup32(_seq->max);\n\t\t\t_seq->seq = realloc(_seq->seq, _seq->max * sizeof(bsw2seq1_t));\n\t\t}\n\t\t_seq->n = n;\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tbseq1_t *b = &bseq[i];\n\t\t\tbsw2seq1_t *p = &_seq->seq[i];\n\t\t\tp->tid = -1; p->l = b->l_seq;\n\t\t\tp->name = b->name; p->seq = b->seq; p->qual = b->qual; p->comment = b->comment; p->sam = 0;\n\t\t\tsize += p->l;\n\t\t}\n\t\tfprintf(stderr, \"[bsw2_aln] read %d sequences/pairs (%d bp) ...\\n\", n, size);\n\t\tfree(bseq);\n\t\tprocess_seqs(_seq, opt, bns, pac, target, is_pe);\n\t}\n\t// free\n\tfree(pac);\n\tfree(_seq->seq); free(_seq);\n\tkseq_destroy(ks);\n\terr_gzclose(fp);\n\tif (fn2) {\n\t\tkseq_destroy(ks2);\n\t\terr_gzclose(fp2);\n\t}\n}", "idx": 49}
{"project": "BWA", "commit_id": "146_BWA_0.7.17_bwtsw2_core.c_stack_destroy.c", "target": 0, "func": "static void stack_destroy(bsw2stack_t *s) { mp_destroy(s->pool); kv_destroy(s->stack0); kv_destroy(s->pending); free(s); }", "idx": 50}
{"project": "BWA", "commit_id": "147_BWA_0.7.17_bwtsw2_core.c_stack_push0.c", "target": 0, "func": "inline static void stack_push0(bsw2stack_t *s, bsw2entry_p e) { kv_push(bsw2entry_p, s->stack0, e); }", "idx": 51}
{"project": "BWA", "commit_id": "148_BWA_0.7.17_bwtsw2_core.c_stack_pop.c", "target": 0, "func": "inline static bsw2entry_p stack_pop(bsw2stack_t *s)\n{\n\tassert(!(kv_size(s->stack0) == 0 && s->n_pending != 0));\n\treturn kv_pop(s->stack0);\n}", "idx": 52}
{"project": "BWA", "commit_id": "149_BWA_0.7.17_bwtsw2_core.c_mp_alloc.c", "target": 0, "func": "inline static bsw2entry_p mp_alloc(mempool_t *mp)\n{\n\t++mp->cnt;\n\tif (kv_size(mp->pool) == 0) return (bsw2entry_t*)calloc(1, sizeof(bsw2entry_t));\n\telse return kv_pop(mp->pool);\n}", "idx": 53}
{"project": "BWA", "commit_id": "14_BWA_0.7.17_bamlite.c_bamlite_gzread.c", "target": 0, "func": "int bamlite_gzread(gzFile file, void *ptr, unsigned int len) {\n\tint ret = gzread(file, ptr, len);\n\t\n\tif (ret < 0) {\n\t\tint errnum = 0;\n\t\tconst char *msg = gzerror(file, &errnum);\n\t\tfprintf(stderr, \"gzread error: %s\\n\",\n\t\t\t\tZ_ERRNO == errnum ? strerror(errno) : msg);\n\t}\n\treturn ret;\n}", "idx": 54}
{"project": "BWA", "commit_id": "150_BWA_0.7.17_bwtsw2_core.c_mp_free.c", "target": 0, "func": "inline static void mp_free(mempool_t *mp, bsw2entry_p e)\n{\n\t--mp->cnt; e->n = 0;\n\tkv_push(bsw2entry_p, mp->pool, e);\n}", "idx": 55}
{"project": "BWA", "commit_id": "151_BWA_0.7.17_bwtsw2_core.c_mp_destroy.c", "target": 0, "func": "static void mp_destroy(struct __mempool_t *mp)\n{\n\tint i;\n\tfor (i = 0; i != kv_size(mp->pool); ++i) {\n\t\tfree(kv_A(mp->pool, i)->array);\n\t\tfree(kv_A(mp->pool, i));\n\t}\n\tkv_destroy(mp->pool);\n\tfree(mp);\n}", "idx": 56}
{"project": "BWA", "commit_id": "152_BWA_0.7.17_bwtsw2_core.c_cut_tail.c", "target": 0, "func": "static void cut_tail(bsw2entry_t *u, int T, bsw2entry_t *aux)\n{\n\tint i, *a, n, x;\n\tif (u->n <= T) return;\n\tif (aux->max < u->n) {\n\t\taux->max = u->n;\n\t\taux->array = (bsw2cell_t*)realloc(aux->array, aux->max * sizeof(bsw2cell_t));\n\t}\n\ta = (int*)aux->array;\n\tfor (i = n = 0; i != u->n; ++i)\n\t\tif (u->array[i].ql && u->array[i].G > 0)\n\t\t\ta[n++] = -u->array[i].G;\n\tif (n <= T) return;\n\tx = -ks_ksmall(int, n, a, T);\n\tn = 0;\n\tfor (i = 0; i < u->n; ++i) {\n\t\tbsw2cell_t *p = u->array + i;\n\t\tif (p->G == x) ++n;\n\t\tif (p->G < x || (p->G == x && n >= T)) {\n\t\t\tp->qk = p->ql = 0; p->G = 0;\n\t\t\tif (p->ppos >= 0) u->array[p->ppos].cpos[p->pj] = -1;\n\t\t}\n\t}\n}", "idx": 57}
{"project": "BWA", "commit_id": "153_BWA_0.7.17_bwtsw2_core.c_merge_entry.c", "target": 0, "func": "static void merge_entry(const bsw2opt_t * __restrict opt, bsw2entry_t *u, bsw2entry_t *v, bwtsw2_t *b)\n{\n\tint i;\n\tif (u->n + v->n >= u->max) {\n\t\tu->max = u->n + v->n;\n\t\tu->array = (bsw2cell_t*)realloc(u->array, u->max * sizeof(bsw2cell_t));\n\t}\n\tfor (i = 0; i != v->n; ++i) {\n\t\tbsw2cell_t *p = v->array + i;\n\t\tif (p->ppos >= 0) p->ppos += u->n;\n\t\tif (p->cpos[0] >= 0) p->cpos[0] += u->n;\n\t\tif (p->cpos[1] >= 0) p->cpos[1] += u->n;\n\t\tif (p->cpos[2] >= 0) p->cpos[2] += u->n;\n\t\tif (p->cpos[3] >= 0) p->cpos[3] += u->n;\n\t}\n\tmemcpy(u->array + u->n, v->array, v->n * sizeof(bsw2cell_t));\n\tu->n += v->n;\n}", "idx": 58}
{"project": "BWA", "commit_id": "154_BWA_0.7.17_bwtsw2_core.c_push_array_p.c", "target": 0, "func": "static inline bsw2cell_t *push_array_p(bsw2entry_t *e)\n{\n\tif (e->n == e->max) {\n\t\te->max = e->max? e->max<<1 : 256;\n\t\te->array = (bsw2cell_t*)realloc(e->array, sizeof(bsw2cell_t) * e->max);\n\t}\n\treturn e->array + e->n;\n}", "idx": 59}
{"project": "BWA", "commit_id": "155_BWA_0.7.17_bwtsw2_core.c_time_elapse.c", "target": 0, "func": "static inline double time_elapse(const struct rusage *curr, const struct rusage *last)\n{\n\tlong t1 = (curr->ru_utime.tv_sec - last->ru_utime.tv_sec) + (curr->ru_stime.tv_sec - last->ru_stime.tv_sec);\n\tlong t2 = (curr->ru_utime.tv_usec - last->ru_utime.tv_usec) + (curr->ru_stime.tv_usec - last->ru_stime.tv_usec);\n\treturn (double)t1 + t2 * 1e-6;\n}", "idx": 60}
{"project": "BWA", "commit_id": "156_BWA_0.7.17_bwtsw2_core.c_bsw2_global_init.c", "target": 0, "func": "bsw2global_t *bsw2_global_init()\n{\n\tbsw2global_t *pool;\n\tbsw2stack_t *stack;\n\tpool = calloc(1, sizeof(bsw2global_t));\n\tstack = calloc(1, sizeof(bsw2stack_t));\n\tstack->pool = (mempool_t*)calloc(1, sizeof(mempool_t));\n\tpool->stack = (void*)stack;\n\treturn pool;\n}", "idx": 61}
{"project": "BWA", "commit_id": "157_BWA_0.7.17_bwtsw2_core.c_bsw2_global_destroy.c", "target": 0, "func": "void bsw2_global_destroy(bsw2global_t *pool)\n{\n\tstack_destroy((bsw2stack_t*)pool->stack);\n\tfree(pool->aln_mem);\n\tfree(pool);\n}", "idx": 62}
{"project": "BWA", "commit_id": "158_BWA_0.7.17_bwtsw2_core.c_fill_cell.c", "target": 0, "func": "static inline int fill_cell(const bsw2opt_t *o, int match_score, bsw2cell_t *c[4])\n{\n\tint G = c[3]? c[3]->G + match_score : MINUS_INF;\n\tif (c[1]) {\n\t\tc[0]->I = c[1]->I > c[1]->G - o->q? c[1]->I - o->r : c[1]->G - o->qr;\n\t\tif (c[0]->I > G) G = c[0]->I;\n\t} else c[0]->I = MINUS_INF;\n\tif (c[2]) {\n\t\tc[0]->D = c[2]->D > c[2]->G - o->q? c[2]->D - o->r : c[2]->G - o->qr;\n\t\tif (c[0]->D > G) G = c[0]->D;\n\t} else c[0]->D = MINUS_INF;\n\treturn(c[0]->G = G);\n}", "idx": 63}
{"project": "BWA", "commit_id": "159_BWA_0.7.17_bwtsw2_core.c_init_bwtsw2.c", "target": 0, "func": "static void init_bwtsw2(const bwtl_t *target, const bwt_t *query, bsw2stack_t *s)\n{\n\tbsw2entry_t *u;\n\tbsw2cell_t *x;\n\n\tu = mp_alloc(s->pool);\n\tu->tk = 0; u->tl = target->seq_len;\n\tx = push_array_p(u);\n\t*x = g_default_cell;\n\tx->G = 0; x->qk = 0; x->ql = query->seq_len;\n\tu->n++;\n\tstack_push0(s, u);\n}", "idx": 64}
{"project": "BWA", "commit_id": "15_BWA_0.7.17_bamlite.c_bamlite_gzclose.c", "target": 0, "func": "int bamlite_gzclose(gzFile file) {\n\tint ret = gzclose(file);\n\tif (Z_OK != ret) {\n\t\tfprintf(stderr, \"gzclose error: %s\\n\",\n\t\t\t\t\t\t  Z_ERRNO == ret ? strerror(errno) : zError(ret));\n\t}\n\t\n\treturn ret;\n}", "idx": 65}
{"project": "BWA", "commit_id": "160_BWA_0.7.17_bwtsw2_main.c_bwa_bwtsw2.c", "target": 0, "func": "int bwa_bwtsw2(int argc, char *argv[])\n{\n\tbsw2opt_t *opt;\n\tbwaidx_t *idx;\n\tint c;\n\n\topt = bsw2_init_opt();\n\tsrand48(11);\n\twhile ((c = getopt(argc, argv, \"q:r:a:b:t:T:w:d:z:m:s:c:N:Hf:MI:SG:C\")) >= 0) {\n\t\tswitch (c) {\n\t\tcase 'q': opt->q = atoi(optarg); break;\n\t\tcase 'r': opt->r = atoi(optarg); break;\n\t\tcase 'a': opt->a = atoi(optarg); break;\n\t\tcase 'b': opt->b = atoi(optarg); break;\n\t\tcase 'w': opt->bw = atoi(optarg); break;\n\t\tcase 'T': opt->t = atoi(optarg); break;\n\t\tcase 't': opt->n_threads = atoi(optarg); break;\n\t\tcase 'z': opt->z = atoi(optarg); break;\n\t\tcase 's': opt->is = atoi(optarg); break;\n\t\tcase 'm': opt->mask_level = atof(optarg); break;\n\t\tcase 'c': opt->coef = atof(optarg); break;\n\t\tcase 'N': opt->t_seeds = atoi(optarg); break;\n\t\tcase 'M': opt->multi_2nd = 1; break;\n\t\tcase 'H': opt->hard_clip = 1; break;\n\t\tcase 'f': xreopen(optarg, \"w\", stdout); break;\n\t\tcase 'I': opt->max_ins = atoi(optarg); break;\n\t\tcase 'S': opt->skip_sw = 1; break;\n\t\tcase 'C': opt->cpy_cmt = 1; break;\n\t\tcase 'G': opt->max_chain_gap = atoi(optarg); break;\n\t\tdefault: return 1;\n\t\t}\n\t}\n\topt->qr = opt->q + opt->r;\n\n\tif (optind + 2 > argc) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Usage:   bwa bwasw [options] <target.prefix> <query.fa> [query2.fa]\\n\\n\");\n\t\tfprintf(stderr, \"Options: -a INT   score for a match [%d]\\n\", opt->a);\n\t\tfprintf(stderr, \"         -b INT   mismatch penalty [%d]\\n\", opt->b);\n\t\tfprintf(stderr, \"         -q INT   gap open penalty [%d]\\n\", opt->q);\n\t\tfprintf(stderr, \"         -r INT   gap extension penalty [%d]\\n\", opt->r);\n\t\tfprintf(stderr, \"         -w INT   band width [%d]\\n\", opt->bw);\n\t\tfprintf(stderr, \"         -m FLOAT mask level [%.2f]\\n\", opt->mask_level);\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"         -t INT   number of threads [%d]\\n\", opt->n_threads);\n\t\tfprintf(stderr, \"         -f FILE  file to output results to instead of stdout\\n\");\n\t\tfprintf(stderr, \"         -H       in SAM output, use hard clipping instead of soft clipping\\n\");\n\t\tfprintf(stderr, \"         -C       copy FASTA/Q comment to SAM output\\n\");\n\t\tfprintf(stderr, \"         -M       mark multi-part alignments as secondary\\n\");\n\t\tfprintf(stderr, \"         -S       skip Smith-Waterman read pairing\\n\");\n\t\tfprintf(stderr, \"         -I INT   ignore pairs with insert >=INT for inferring the size distr [%d]\\n\", opt->max_ins);\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"         -T INT   score threshold divided by a [%d]\\n\", opt->t);\n\t\tfprintf(stderr, \"         -c FLOAT coefficient of length-threshold adjustment [%.1f]\\n\", opt->coef);\n\t\tfprintf(stderr, \"         -z INT   Z-best [%d]\\n\", opt->z);\n\t\tfprintf(stderr, \"         -s INT   maximum seeding interval size [%d]\\n\", opt->is);\n\t\tfprintf(stderr, \"         -N INT   # seeds to trigger rev aln; 2*INT is also the chaining threshold [%d]\\n\", opt->t_seeds);\n\t\tfprintf(stderr, \"         -G INT   maximum gap size during chaining [%d]\\n\", opt->max_chain_gap);\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Note: For long Illumina, 454 and Sanger reads, assembly contigs, fosmids and\\n\");\n\t\tfprintf(stderr, \"      BACs, the default setting usually works well. For the current PacBio\\n\");\n\t\tfprintf(stderr, \"      reads (end of 2010), '-b5 -q2 -r1 -z10' is recommended. One may also\\n\");\n\t\tfprintf(stderr, \"      increase '-z' for better sensitivity.\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\n\t\treturn 1;\n\t}\n\n\t// adjust opt for opt->a\n\topt->t *= opt->a;\n\topt->coef *= opt->a;\n\n\tif ((idx = bwa_idx_load(argv[optind], BWA_IDX_BWT|BWA_IDX_BNS)) == 0) return 1;\n\tbsw2_aln(opt, idx->bns, idx->bwt, argv[optind+1], optind+2 < argc? argv[optind+2] : 0);\n\tbwa_idx_destroy(idx);\n\tfree(opt);\n\t\n\treturn 0;\n}", "idx": 66}
{"project": "BWA", "commit_id": "161_BWA_0.7.17_bwtsw2_pair.c_bsw2_stat.c", "target": 0, "func": "bsw2pestat_t bsw2_stat(int n, bwtsw2_t **buf, kstring_t *msg, int max_ins)\n{\n\tint i, k, x, p25, p50, p75, tmp, max_len = 0;\n\tuint64_t *isize;\n\tbsw2pestat_t r;\n\n\tmemset(&r, 0, sizeof(bsw2pestat_t));\n\tisize = calloc(n, 8);\n\tfor (i = k = 0; i < n; i += 2) {\n\t\tbsw2hit_t *t[2];\n\t\tint l;\n\t\tif (buf[i] == 0 || buf[i]->n != 1 || buf[i+1]->n != 1) continue; // more than 1 hits\n\t\tt[0] = &buf[i]->hits[0]; t[1] = &buf[i+1]->hits[0];\n\t\tif (t[0]->G2 > 0.8 * t[0]->G) continue; // the best hit is not good enough\n\t\tif (t[1]->G2 > 0.8 * t[1]->G) continue; // the best hit is not good enough\n\t\tl = t[0]->k > t[1]->k? t[0]->k - t[1]->k + t[1]->len : t[1]->k - t[0]->k + t[0]->len;\n\t\tif (l >= max_ins) continue; // skip pairs with excessively large insert\n\t\tmax_len = max_len > t[0]->end - t[0]->beg? max_len : t[0]->end - t[0]->beg;\n\t\tmax_len = max_len > t[1]->end - t[1]->beg? max_len : t[1]->end - t[1]->beg;\n\t\tisize[k++] = l;\n\t}\n\tks_introsort_64(k, isize);\n\tp25 = isize[(int)(.25 * k + .499)];\n\tp50 = isize[(int)(.50 * k + .499)];\n\tp75 = isize[(int)(.75 * k + .499)];\n\tksprintf(msg, \"[%s] infer the insert size distribution from %d high-quality pairs.\\n\", __func__, k);\n\tif (k < 8) {\n\t\tksprintf(msg, \"[%s] fail to infer the insert size distribution: too few good pairs.\\n\", __func__);\n\t\tfree(isize);\n\t\tr.failed = 1;\n\t\treturn r;\n\t}\n\ttmp    = (int)(p25 - OUTLIER_BOUND * (p75 - p25) + .499);\n\tr.low  = tmp > max_len? tmp : max_len;\n\tif (r.low < 1) r.low = 1;\n\tr.high = (int)(p75 + OUTLIER_BOUND * (p75 - p25) + .499);\n\tif (r.low > r.high) {\n\t\tksprintf(msg, \"[%s] fail to infer the insert size distribution: upper bound is smaller than max read length.\\n\", __func__);\n\t\tfree(isize);\n\t\tr.failed = 1;\n\t\treturn r;\n\t}\n\tksprintf(msg, \"[%s] (25, 50, 75) percentile: (%d, %d, %d)\\n\", __func__, p25, p50, p75);\n\tksprintf(msg, \"[%s] low and high boundaries for computing mean and std.dev: (%d, %d)\\n\", __func__, r.low, r.high);\n\tfor (i = x = 0, r.avg = 0; i < k; ++i)\n\t\tif (isize[i] >= r.low && isize[i] <= r.high)\n\t\t\tr.avg += isize[i], ++x;\n\tif (x == 0) {\n\t\tksprintf(msg, \"[%s] fail to infer the insert size distribution: no pairs within boundaries.\\n\", __func__);\n\t\tfree(isize);\n\t\tr.failed = 1;\n\t\treturn r;\n\t}\n\tr.avg /= x;\n\tfor (i = 0, r.std = 0; i < k; ++i)\n\t\tif (isize[i] >= r.low && isize[i] <= r.high)\n\t\t\tr.std += (isize[i] - r.avg) * (isize[i] - r.avg);\n\tr.std = sqrt(r.std / x);\n\tksprintf(msg, \"[%s] mean and std.dev: (%.2f, %.2f)\\n\", __func__, r.avg, r.std);\n\ttmp  = (int)(p25 - 3. * (p75 - p25) + .499);\n\tr.low  = tmp > max_len? tmp : max_len;\n\tif (r.low < 1) r.low = 1;\n\tr.high = (int)(p75 + 3. * (p75 - p25) + .499);\n\tif (r.low > r.avg - MAX_STDDEV * r.std) r.low = (int)(r.avg - MAX_STDDEV * r.std + .499);\n\tr.low = tmp > max_len? tmp : max_len;\n\tif (r.high < r.avg + MAX_STDDEV * r.std) r.high = (int)(r.avg + MAX_STDDEV * r.std + .499);\n\tksprintf(msg, \"[%s] low and high boundaries for proper pairs: (%d, %d)\\n\", __func__, r.low, r.high);\n\tfree(isize);\n\treturn r;\n}", "idx": 67}
{"project": "BWA", "commit_id": "162_BWA_0.7.17_bwtsw2_pair.c_bsw2_pair1.c", "target": 0, "func": "void bsw2_pair1(const bsw2opt_t *opt, int64_t l_pac, const uint8_t *pac, const bsw2pestat_t *st, const bsw2hit_t *h, int l_mseq, const char *mseq, bsw2hit_t *a, int8_t g_mat[25])\n{\n\textern void seq_reverse(int len, ubyte_t *seq, int is_comp);\n\tint64_t k, beg, end;\n\tuint8_t *seq, *ref;\n\tint i;\n\t// compute the region start and end\n\ta->n_seeds = 1; a->flag |= BSW2_FLAG_MATESW; // before calling this routine, *a has been cleared with memset(0); the flag is set with 1<<6/7\n\tif (h->is_rev == 0) {\n\t\tbeg = (int64_t)(h->k + st->avg - EXT_STDDEV * st->std - l_mseq + .499);\n\t\tif (beg < h->k) beg = h->k;\n\t\tend = (int64_t)(h->k + st->avg + EXT_STDDEV * st->std + .499);\n\t\ta->is_rev = 1; a->flag |= 16;\n\t} else {\n\t\tbeg = (int64_t)(h->k + h->end - h->beg - st->avg - EXT_STDDEV * st->std + .499);\n\t\tend = (int64_t)(h->k + h->end - h->beg - st->avg + EXT_STDDEV * st->std + l_mseq + .499);\n\t\tif (end > h->k + (h->end - h->beg)) end = h->k + (h->end - h->beg);\n\t\ta->is_rev = 0;\n\t}\n\tif (beg < 1) beg = 1;\n\tif (end > l_pac) end = l_pac;\n\tif (end - beg < l_mseq) return;\n\t// generate the sequence\n\tseq = malloc(l_mseq + (end - beg));\n\tref = seq + l_mseq;\n\tfor (k = beg; k < end; ++k)\n\t\tref[k - beg] = pac[k>>2] >> ((~k&3)<<1) & 0x3;\n\tif (h->is_rev == 0) {\n\t\tfor (i = 0; i < l_mseq; ++i) { // on the reverse strand\n\t\t\tint c = nst_nt4_table[(int)mseq[i]];\n\t\t\tseq[l_mseq - 1 - i] = c > 3? 4 : 3 - c;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < l_mseq; ++i) // on the forward strand\n\t\t\tseq[i] = nst_nt4_table[(int)mseq[i]];\n\t}\n\t{\n\t\tint flag = KSW_XSUBO | KSW_XSTART | (l_mseq * g_mat[0] < 250? KSW_XBYTE : 0) | opt->t;\n\t\tkswr_t aln;\n\t\taln = ksw_align(l_mseq, seq, end - beg, ref, 5, g_mat, opt->q, opt->r, flag, 0);\n\t\ta->G = aln.score;\n\t\ta->G2 = aln.score2;\n\t\tif (a->G < opt->t) a->G = 0;\n\t\tif (a->G2 < opt->t) a->G2 = 0;\n\t\tif (a->G2) a->flag |= BSW2_FLAG_TANDEM;\n\t\ta->k = beg + aln.tb;\n\t\ta->len = aln.te - aln.tb + 1;\n\t\ta->beg = aln.qb;\n\t\ta->end = aln.qe + 1;\n\t\t/*\n\t\tprintf(\"[Q] \"); for (i = 0; i < l_mseq; ++i) putchar(\"ACGTN\"[(int)seq[i]]); putchar('\\n');\n\t\tprintf(\"[R] \"); for (i = 0; i < end - beg; ++i) putchar(\"ACGTN\"[(int)ref[i]]); putchar('\\n');\n\t\tprintf(\"G=%d,G2=%d,beg=%d,end=%d,k=%lld,len=%d\\n\", a->G, a->G2, a->beg, a->end, a->k, a->len);\n\t\t*/\n\t}\n\tif (a->is_rev) i = a->beg, a->beg = l_mseq - a->end, a->end = l_mseq - i;\n\tfree(seq);\n}", "idx": 68}
{"project": "BWA", "commit_id": "163_BWA_0.7.17_bwt_gen.c_TextLengthFromBytePacked.c", "target": 0, "func": "static bgint_t TextLengthFromBytePacked(bgint_t bytePackedLength, unsigned int bitPerChar,\n\t\t\t\t\t\t\t\t\t\t\t unsigned int lastByteLength)\n{\n\treturn (bytePackedLength - 1) * (BITS_IN_BYTE / bitPerChar) + lastByteLength;\n}", "idx": 69}
{"project": "BWA", "commit_id": "164_BWA_0.7.17_bwt_gen.c_initializeVAL.c", "target": 0, "func": "static void initializeVAL(unsigned int *startAddr, const bgint_t length, const unsigned int initValue)\n{\n\tbgint_t i;\n\tfor (i=0; i<length; i++) startAddr[i] = initValue;\n}", "idx": 70}
{"project": "BWA", "commit_id": "165_BWA_0.7.17_bwt_gen.c_initializeVAL_bg.c", "target": 0, "func": "static void initializeVAL_bg(bgint_t *startAddr, const bgint_t length, const bgint_t initValue)\n{\n\tbgint_t i;\n\tfor (i=0; i<length; i++) startAddr[i] = initValue;\n}", "idx": 71}
{"project": "BWA", "commit_id": "166_BWA_0.7.17_bwt_gen.c_GenerateDNAOccCountTable.c", "target": 0, "func": "static void GenerateDNAOccCountTable(unsigned int *dnaDecodeTable)\n{\n\tunsigned int i, j, c, t;\n\n\tfor (i=0; i<DNA_OCC_CNT_TABLE_SIZE_IN_WORD; i++) {\n\t\tdnaDecodeTable[i] = 0;\n\t\tc = i;\n\t\tfor (j=0; j<8; j++) {\n\t\t\tt = c & 0x00000003;\n\t\t\tdnaDecodeTable[i] += 1 << (t * 8);\n\t\t\tc >>= 2;\n\t\t}\n\t}\n\n}", "idx": 72}
{"project": "BWA", "commit_id": "167_BWA_0.7.17_bwt_gen.c_BWTOccValueMajorSizeInWord.c", "target": 0, "func": "static bgint_t BWTOccValueMajorSizeInWord(const bgint_t numChar)\n{\n\tbgint_t numOfOccValue;\n\tunsigned numOfOccIntervalPerMajor;\n\tnumOfOccValue = (numChar + OCC_INTERVAL - 1) / OCC_INTERVAL + 1; // Value at both end for bi-directional encoding\n\tnumOfOccIntervalPerMajor = OCC_INTERVAL_MAJOR / OCC_INTERVAL;\n\treturn (numOfOccValue + numOfOccIntervalPerMajor - 1) / numOfOccIntervalPerMajor * ALPHABET_SIZE;\n}", "idx": 73}
{"project": "BWA", "commit_id": "168_BWA_0.7.17_bwt_gen.c_BWTOccValueMinorSizeInWord.c", "target": 0, "func": "static bgint_t BWTOccValueMinorSizeInWord(const bgint_t numChar)\n{\n\tbgint_t numOfOccValue;\n\tnumOfOccValue = (numChar + OCC_INTERVAL - 1) / OCC_INTERVAL + 1;\t\t// Value at both end for bi-directional encoding\n\treturn (numOfOccValue + OCC_VALUE_PER_WORD - 1) / OCC_VALUE_PER_WORD * ALPHABET_SIZE;\n}", "idx": 74}
{"project": "BWA", "commit_id": "169_BWA_0.7.17_bwt_gen.c_BWTResidentSizeInWord.c", "target": 0, "func": "static bgint_t BWTResidentSizeInWord(const bgint_t numChar) {\n\n\tbgint_t numCharRoundUpToOccInterval;\n\n\t// The $ in BWT at the position of inverseSa0 is not encoded\n\tnumCharRoundUpToOccInterval = (numChar + OCC_INTERVAL - 1) / OCC_INTERVAL * OCC_INTERVAL;\n\n\treturn (numCharRoundUpToOccInterval + CHAR_PER_WORD - 1) / CHAR_PER_WORD;\n\n}", "idx": 75}
{"project": "BWA", "commit_id": "16_BWA_0.7.17_bntseq.c_bns_dump.c", "target": 0, "func": "void bns_dump(const bntseq_t *bns, const char *prefix)\n{\n\tchar str[1024];\n\tFILE *fp;\n\tint i;\n\t{ // dump .ann\n\t\tstrcpy(str, prefix); strcat(str, \".ann\");\n\t\tfp = xopen(str, \"w\");\n\t\terr_fprintf(fp, \"%lld %d %u\\n\", (long long)bns->l_pac, bns->n_seqs, bns->seed);\n\t\tfor (i = 0; i != bns->n_seqs; ++i) {\n\t\t\tbntann1_t *p = bns->anns + i;\n\t\t\terr_fprintf(fp, \"%d %s\", p->gi, p->name);\n\t\t\tif (p->anno[0]) err_fprintf(fp, \" %s\\n\", p->anno);\n\t\t\telse err_fprintf(fp, \"\\n\");\n\t\t\terr_fprintf(fp, \"%lld %d %d\\n\", (long long)p->offset, p->len, p->n_ambs);\n\t\t}\n\t\terr_fflush(fp);\n\t\terr_fclose(fp);\n\t}\n\t{ // dump .amb\n\t\tstrcpy(str, prefix); strcat(str, \".amb\");\n\t\tfp = xopen(str, \"w\");\n\t\terr_fprintf(fp, \"%lld %d %u\\n\", (long long)bns->l_pac, bns->n_seqs, bns->n_holes);\n\t\tfor (i = 0; i != bns->n_holes; ++i) {\n\t\t\tbntamb1_t *p = bns->ambs + i;\n\t\t\terr_fprintf(fp, \"%lld %d %c\\n\", (long long)p->offset, p->len, p->amb);\n\t\t}\n\t\terr_fflush(fp);\n\t\terr_fclose(fp);\n\t}\n}", "idx": 76}
{"project": "BWA", "commit_id": "170_BWA_0.7.17_bwt_gen.c_BWTIncSetBuildSizeAndTextAddr.c", "target": 0, "func": "static void BWTIncSetBuildSizeAndTextAddr(BWTInc *bwtInc)\n{\n\tbgint_t maxBuildSize;\n\n\tif (bwtInc->bwt->textLength == 0) {\n\t\t// initial build\n\t\t// Minus 2 because n+1 entries of seq and rank needed for n char\n\t\tmaxBuildSize = (bwtInc->availableWord - (2 + OCC_INTERVAL / CHAR_PER_WORD) * (sizeof(bgint_t) / 4))\n\t\t\t\t\t\t\t/ (2 * CHAR_PER_WORD + 1) * CHAR_PER_WORD / (sizeof(bgint_t) / 4);\n\t\tif (bwtInc->initialMaxBuildSize > 0) {\n\t\t\tbwtInc->buildSize = min(bwtInc->initialMaxBuildSize, maxBuildSize);\n\t\t} else {\n\t\t\tbwtInc->buildSize = maxBuildSize;\n\t\t}\n\t} else {\n\t\t// Minus 3 because n+1 entries of sorted rank, seq and rank needed for n char\n\t\t// Minus numberOfIterationDone because bwt slightly shift to left in each iteration\n\t\tmaxBuildSize = (bwtInc->availableWord - bwtInc->bwt->bwtSizeInWord - bwtInc->bwt->occSizeInWord\n\t\t\t\t\t\t\t - (3 + bwtInc->numberOfIterationDone * OCC_INTERVAL / BIT_PER_CHAR) * (sizeof(bgint_t) / 4)) \n\t\t\t\t\t\t\t / 3 / (sizeof(bgint_t) / 4);\n\t\tif (maxBuildSize < CHAR_PER_WORD) {\n\t\t\tfprintf(stderr, \"BWTIncSetBuildSizeAndTextAddr(): Not enough space allocated to continue construction!\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (bwtInc->incMaxBuildSize > 0) {\n            bwtInc->buildSize = min(bwtInc->incMaxBuildSize, maxBuildSize);\n\t\t} else {\n\t\t\tbwtInc->buildSize = maxBuildSize;\n\t\t}\n\t\tif (bwtInc->buildSize < CHAR_PER_WORD)\n\t\t\tbwtInc->buildSize = CHAR_PER_WORD;\n\t}\n\n\tif (bwtInc->buildSize < CHAR_PER_WORD) {\n\t\tfprintf(stderr, \"BWTIncSetBuildSizeAndTextAddr(): Not enough space allocated to continue construction!\\n\");\n\t\texit(1);\n\t}\n\n\tbwtInc->buildSize = bwtInc->buildSize / CHAR_PER_WORD * CHAR_PER_WORD;\n\n\tbwtInc->packedText = bwtInc->workingMemory + 2 * (bwtInc->buildSize + 1) * (sizeof(bgint_t) / 4);\n\tbwtInc->textBuffer = (unsigned char*)(bwtInc->workingMemory + (bwtInc->buildSize + 1) * (sizeof(bgint_t) / 4));\n}", "idx": 77}
{"project": "BWA", "commit_id": "171_BWA_0.7.17_bwt_gen.c_leadingZero.c", "target": 0, "func": "unsigned int leadingZero(const unsigned int input)\n{\n\tunsigned int l;\n\tconst static unsigned int leadingZero8bit[256] = {8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\n\t\t\t\t\t\t\t\t\t\t\t 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n\t\t\t\t\t\t\t\t\t\t\t 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n\t\t\t\t\t\t\t\t\t\t\t 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n\t\t\t\t\t\t\t\t\t\t\t 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t\t\t\t\t\t\t\t\t 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t\t\t\t\t\t\t\t\t 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t\t\t\t\t\t\t\t\t 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n\n\tif (input & 0xFFFF0000) {\n\t\tif (input & 0xFF000000) {\n\t\t\tl = leadingZero8bit[input >> 24];\n\t\t} else {\n\t\t\tl = 8 + leadingZero8bit[input >> 16];\n\t\t}\n\t} else {\n\t\tif (input & 0x0000FF00) {\n\t\t\tl = 16 + leadingZero8bit[input >> 8];\n\t\t} else {\n\t\t\tl = 24 + leadingZero8bit[input];\n\t\t}\n\t}\n\treturn l;\n\n}", "idx": 78}
{"project": "BWA", "commit_id": "172_BWA_0.7.17_bwt_gen.c_ceilLog2.c", "target": 0, "func": "static unsigned int ceilLog2(const unsigned int input)\n{\n\tif (input <= 1) return 0;\n\treturn BITS_IN_WORD - leadingZero(input - 1);\n\n}", "idx": 79}
{"project": "BWA", "commit_id": "173_BWA_0.7.17_bwt_gen.c_BitPerBytePackedChar.c", "target": 0, "func": "static unsigned int BitPerBytePackedChar(const unsigned int alphabetSize)\n{\n\tunsigned int bitPerChar;\n\tbitPerChar = ceilLog2(alphabetSize);\n\t// Return the largest number of bit that does not affect packing efficiency\n\tif (BITS_IN_BYTE / (BITS_IN_BYTE / bitPerChar) > bitPerChar)\n\t\tbitPerChar = BITS_IN_BYTE / (BITS_IN_BYTE / bitPerChar);\n\treturn bitPerChar;\n}", "idx": 80}
{"project": "BWA", "commit_id": "174_BWA_0.7.17_bwt_gen.c_BitPerWordPackedChar.c", "target": 0, "func": "static unsigned int BitPerWordPackedChar(const unsigned int alphabetSize)\n{\n\treturn ceilLog2(alphabetSize);\n}", "idx": 81}
{"project": "BWA", "commit_id": "175_BWA_0.7.17_bwt_gen.c_BWTCreate.c", "target": 0, "func": "BWT *BWTCreate(const bgint_t textLength, unsigned int *decodeTable)\n{\n\tBWT *bwt;\n\n\tbwt = (BWT*)calloc(1, sizeof(BWT));\n\n\tbwt->textLength = 0;\n\n\tbwt->cumulativeFreq = (bgint_t*)calloc((ALPHABET_SIZE + 1), sizeof(bgint_t));\n\tinitializeVAL_bg(bwt->cumulativeFreq, ALPHABET_SIZE + 1, 0);\n\n\tbwt->bwtSizeInWord = 0;\n\n\t// Generate decode tables\n\tif (decodeTable == NULL) {\n\t\tbwt->decodeTable = (unsigned*)calloc(DNA_OCC_CNT_TABLE_SIZE_IN_WORD, sizeof(unsigned int));\n\t\tGenerateDNAOccCountTable(bwt->decodeTable);\n\t} else {\n\t\t// FIXME Prevent BWTFree() from freeing decodeTable in this case\n\t\tbwt->decodeTable = decodeTable;\n\t}\n\n\tbwt->occMajorSizeInWord = BWTOccValueMajorSizeInWord(textLength);\n\tbwt->occValueMajor = (bgint_t*)calloc(bwt->occMajorSizeInWord, sizeof(bgint_t));\n\n\tbwt->occSizeInWord = 0;\n\tbwt->occValue = NULL;\n\n\treturn bwt;\n}", "idx": 82}
{"project": "BWA", "commit_id": "176_BWA_0.7.17_bwt_gen.c_BWTIncCreate.c", "target": 0, "func": "BWTInc *BWTIncCreate(const bgint_t textLength, unsigned int initialMaxBuildSize, unsigned int incMaxBuildSize)\n{\n\tBWTInc *bwtInc;\n\tunsigned int i, n_iter;\n\n\tif (textLength < incMaxBuildSize) incMaxBuildSize = textLength;\n\tif (textLength < initialMaxBuildSize) initialMaxBuildSize = textLength;\n\n\tbwtInc = (BWTInc*)calloc(1, sizeof(BWTInc));\n\tbwtInc->numberOfIterationDone = 0;\n\tbwtInc->bwt = BWTCreate(textLength, NULL);\n\tbwtInc->initialMaxBuildSize = initialMaxBuildSize;\n\tbwtInc->incMaxBuildSize = incMaxBuildSize;\n\tbwtInc->cumulativeCountInCurrentBuild = (bgint_t*)calloc((ALPHABET_SIZE + 1), sizeof(bgint_t));\n\tinitializeVAL_bg(bwtInc->cumulativeCountInCurrentBuild, ALPHABET_SIZE + 1, 0);\n\n\t// Build frequently accessed data\n\tbwtInc->packedShift = (unsigned*)calloc(CHAR_PER_WORD, sizeof(unsigned int));\n\tfor (i=0; i<CHAR_PER_WORD; i++)\n\t\tbwtInc->packedShift[i] = BITS_IN_WORD - (i+1) * BIT_PER_CHAR;\n\n\tn_iter = (textLength - initialMaxBuildSize) / incMaxBuildSize + 1;\n\tbwtInc->availableWord = BWTResidentSizeInWord(textLength) + BWTOccValueMinorSizeInWord(textLength) // minimal memory requirement\n\t\t+ OCC_INTERVAL / BIT_PER_CHAR * n_iter * 2 * (sizeof(bgint_t) / 4) // buffer at the end of occ array \n\t\t+ incMaxBuildSize/5 * 3 * (sizeof(bgint_t) / 4); // space for the 3 temporary arrays in each iteration\n\tif (bwtInc->availableWord < MIN_AVAILABLE_WORD) bwtInc->availableWord = MIN_AVAILABLE_WORD; // lh3: otherwise segfaul when availableWord is too small\n\tfprintf(stderr, \"[%s] textLength=%ld, availableWord=%ld\\n\", __func__, (long)textLength, (long)bwtInc->availableWord);\n\tbwtInc->workingMemory = (unsigned*)calloc(bwtInc->availableWord, BYTES_IN_WORD);\n\n\treturn bwtInc;\n}", "idx": 83}
{"project": "BWA", "commit_id": "177_BWA_0.7.17_bwt_gen.c_BWTIncPutPackedTextToRank.c", "target": 0, "func": "static void BWTIncPutPackedTextToRank(const unsigned int *packedText, bgint_t* __restrict rank,\n\t\t\t\t\t\t\t\t\t  bgint_t* __restrict cumulativeCount, const bgint_t numChar)\n{\n\tbgint_t i;\n\tunsigned int j;\n\tunsigned int c, t;\n\tunsigned int packedMask;\n\tbgint_t rankIndex;\n\tbgint_t lastWord;\n\tunsigned int numCharInLastWord;\n\n\tlastWord = (numChar - 1) / CHAR_PER_WORD;\n\tnumCharInLastWord = numChar - lastWord * CHAR_PER_WORD;\n\n\tpackedMask = ALL_ONE_MASK >> (BITS_IN_WORD - BIT_PER_CHAR);\n\trankIndex = numChar - 1;\n\n\tt = packedText[lastWord] >> (BITS_IN_WORD - numCharInLastWord * BIT_PER_CHAR);\n\tfor (i=0; i<numCharInLastWord; i++) {\n\t\tc = t & packedMask;\n\t\tcumulativeCount[c+1]++;\n\t\trank[rankIndex] = c;\n\t\trankIndex--;\n\t\tt >>= BIT_PER_CHAR;\n\t}\n\n\tfor (i=lastWord; i--;) {\t// loop from lastWord - 1 to 0\n\t\tt = packedText[i];\n\t\tfor (j=0; j<CHAR_PER_WORD; j++) {\n\t\t\tc = t & packedMask;\n\t\t\tcumulativeCount[c+1]++;\n\t\t\trank[rankIndex] = c;\n\t\t\trankIndex--;\n\t\t\tt >>= BIT_PER_CHAR;\n\t\t}\n\t}\n\n\t// Convert occurrence to cumulativeCount\n\tcumulativeCount[2] += cumulativeCount[1];\n\tcumulativeCount[3] += cumulativeCount[2];\n\tcumulativeCount[4] += cumulativeCount[3];\n}", "idx": 84}
{"project": "BWA", "commit_id": "178_BWA_0.7.17_bwt_gen.c_BWTOccValueExplicit.c", "target": 0, "func": "static inline bgint_t BWTOccValueExplicit(const BWT *bwt, const bgint_t occIndexExplicit,\n\t\t\t\t\t\t\t\t\t\t\t   const unsigned int character)\n{\n\tbgint_t occIndexMajor;\n\n\toccIndexMajor = occIndexExplicit * OCC_INTERVAL / OCC_INTERVAL_MAJOR;\n\n\tif (occIndexExplicit % OCC_VALUE_PER_WORD == 0) {\n\t\treturn bwt->occValueMajor[occIndexMajor * ALPHABET_SIZE + character] +\n\t\t\t   (bwt->occValue[occIndexExplicit / OCC_VALUE_PER_WORD * ALPHABET_SIZE + character] >> 16);\n\n\t} else {\n\t\treturn bwt->occValueMajor[occIndexMajor * ALPHABET_SIZE + character] +\n\t\t\t   (bwt->occValue[occIndexExplicit / OCC_VALUE_PER_WORD * ALPHABET_SIZE + character] & 0x0000FFFF);\n\t}\n}", "idx": 85}
{"project": "BWA", "commit_id": "179_BWA_0.7.17_bwt_gen.c_ForwardDNAOccCount.c", "target": 0, "func": "static unsigned int ForwardDNAOccCount(const unsigned int*  dna, const unsigned int index, const unsigned int character,\n\t\t\t\t\t\t\t\t\t   const unsigned int*  dnaDecodeTable)\n{\n\tstatic const unsigned int truncateRightMask[16] = { 0x00000000, 0xC0000000, 0xF0000000, 0xFC000000,\n\t\t\t\t\t\t\t\t\t\t\t   0xFF000000, 0xFFC00000, 0xFFF00000, 0xFFFC0000,\n\t\t\t\t\t\t\t\t\t\t\t   0xFFFF0000, 0xFFFFC000, 0xFFFFF000, 0xFFFFFC00,\n\t\t\t\t\t\t\t\t\t\t\t   0xFFFFFF00, 0xFFFFFFC0, 0xFFFFFFF0, 0xFFFFFFFC };\n\n\tunsigned int wordToCount, charToCount;\n\tunsigned int i, c;\n\tunsigned int sum = 0;\n\n\twordToCount = index / 16;\n\tcharToCount = index - wordToCount * 16;\n\n\tfor (i=0; i<wordToCount; i++) {\n\t\tsum += dnaDecodeTable[dna[i] >> 16];\n\t\tsum += dnaDecodeTable[dna[i] & 0x0000FFFF];\n\t}\n\n\tif (charToCount > 0) {\n\t\tc = dna[i] & truncateRightMask[charToCount];\t// increase count of 'a' by 16 - c;\n\t\tsum += dnaDecodeTable[c >> 16];\n\t\tsum += dnaDecodeTable[c & 0xFFFF];\n\t\tsum += charToCount - 16;\t// decrease count of 'a' by 16 - positionToProcess\n\t}\n\n\treturn (sum >> (character * 8)) & 0x000000FF;\n\n}", "idx": 86}
{"project": "BWA", "commit_id": "17_BWA_0.7.17_bntseq.c_bns_destroy.c", "target": 0, "func": "void bns_destroy(bntseq_t *bns)\n{\n\tif (bns == 0) return;\n\telse {\n\t\tint i;\n\t\tif (bns->fp_pac) err_fclose(bns->fp_pac);\n\t\tfree(bns->ambs);\n\t\tfor (i = 0; i < bns->n_seqs; ++i) {\n\t\t\tfree(bns->anns[i].name);\n\t\t\tfree(bns->anns[i].anno);\n\t\t}\n\t\tfree(bns->anns);\n\t\tfree(bns);\n\t}\n}", "idx": 87}
{"project": "BWA", "commit_id": "180_BWA_0.7.17_bwt_gen.c_BackwardDNAOccCount.c", "target": 0, "func": "static unsigned int BackwardDNAOccCount(const unsigned int*  dna, const unsigned int index, const unsigned int character,\n\t\t\t\t\t\t\t\t\t\tconst unsigned int*  dnaDecodeTable)\n{\n\tstatic const unsigned int truncateLeftMask[16] =  { 0x00000000, 0x00000003, 0x0000000F, 0x0000003F,\n\t\t\t\t\t\t\t\t\t\t\t   0x000000FF, 0x000003FF, 0x00000FFF, 0x00003FFF,\n\t\t\t\t\t\t\t\t\t\t\t   0x0000FFFF, 0x0003FFFF, 0x000FFFFF, 0x003FFFFF,\n\t\t\t\t\t\t\t\t\t\t\t   0x00FFFFFF, 0x03FFFFFF, 0x0FFFFFFF, 0x3FFFFFFF };\n\n\tunsigned int wordToCount, charToCount;\n\tunsigned int i, c;\n\tunsigned int sum = 0;\n\n\twordToCount = index / 16;\n\tcharToCount = index - wordToCount * 16;\n\n\tdna -= wordToCount + 1;\n\n\tif (charToCount > 0) {\n\t\tc = *dna & truncateLeftMask[charToCount];\t// increase count of 'a' by 16 - c;\n\t\tsum += dnaDecodeTable[c >> 16];\n\t\tsum += dnaDecodeTable[c & 0xFFFF];\n\t\tsum += charToCount - 16;\t// decrease count of 'a' by 16 - positionToProcess\n\t}\n\t\n\tfor (i=0; i<wordToCount; i++) {\n\t\tdna++;\n\t\tsum += dnaDecodeTable[*dna >> 16];\n\t\tsum += dnaDecodeTable[*dna & 0x0000FFFF];\n\t}\n\n\treturn (sum >> (character * 8)) & 0x000000FF;\n\n}", "idx": 88}
{"project": "BWA", "commit_id": "181_BWA_0.7.17_bwt_gen.c_BWTOccValue.c", "target": 0, "func": "bgint_t BWTOccValue(const BWT *bwt, bgint_t index, const unsigned int character)\n{\n\tbgint_t occValue;\n\tbgint_t occExplicitIndex, occIndex;\n\n\t// $ is supposed to be positioned at inverseSa0 but it is not encoded\n\t// therefore index is subtracted by 1 for adjustment\n\tif (index > bwt->inverseSa0)\n\t\tindex--;\n\n\toccExplicitIndex = (index + OCC_INTERVAL / 2 - 1) / OCC_INTERVAL;\t// Bidirectional encoding\n\toccIndex = occExplicitIndex * OCC_INTERVAL;\n\toccValue = BWTOccValueExplicit(bwt, occExplicitIndex, character);\n\n\tif (occIndex == index)\n\t\treturn occValue;\n\n\tif (occIndex < index) {\n\t\treturn occValue + ForwardDNAOccCount(bwt->bwtCode + occIndex / CHAR_PER_WORD, index - occIndex, character, bwt->decodeTable);\n\t} else {\n\t\treturn occValue - BackwardDNAOccCount(bwt->bwtCode + occIndex / CHAR_PER_WORD, occIndex - index, character, bwt->decodeTable);\n\t}\n}", "idx": 89}
{"project": "BWA", "commit_id": "182_BWA_0.7.17_bwt_gen.c_BWTIncBuildBwt.c", "target": 0, "func": "static void BWTIncBuildBwt(unsigned int* insertBwt, const bgint_t *relativeRank, const bgint_t numChar,\n\t\t\t\t\t\t   const bgint_t *cumulativeCount)\n{\n\tunsigned int c;\n\tbgint_t i;\n\tbgint_t previousRank, currentRank;\n\n\tpreviousRank = relativeRank[0];\n\n\tfor (i=1; i<=numChar; i++) {\n\t\tcurrentRank = relativeRank[i];\n\t\tc = (previousRank >= cumulativeCount[1]) + (previousRank >= cumulativeCount[2])\n\t\t\t\t\t\t\t\t\t\t\t  \t + (previousRank >= cumulativeCount[3]);\n\t\tinsertBwt[currentRank] = c;\n\t\tpreviousRank = currentRank;\n\t}\n}", "idx": 90}
{"project": "BWA", "commit_id": "183_BWA_0.7.17_bwt_gen.c_while.c", "target": 0, "func": "copy from insertBwt\n\twhile (iIndex <= numInsertBwt) {\n\t\tif (sortedRank[iIndex] != 0) {\n\t\t\tmergedBwt[mWord] |= insertBwt[iIndex] << (BITS_IN_WORD - (mChar + 1) * BIT_PER_CHAR);\n\t\t\tmIndex++;\n\t\t\tmChar++;\n\t\t\tif (mChar == CHAR_PER_WORD) {\n\t\t\t\tmChar = 0;\n\t\t\t\tmWord++;\n\t\t\t\tmergedBwt[mWord] = 0;\t// no need to worry about crossing mergedBwt boundary\n\t\t\t}\n\t\t}\n\t\tiIndex++;\n\t}", "idx": 91}
{"project": "BWA", "commit_id": "184_BWA_0.7.17_bwt_gen.c_BWTClearTrailingBwtCode.c", "target": 0, "func": "void BWTClearTrailingBwtCode(BWT *bwt)\n{\n\tbgint_t bwtResidentSizeInWord;\n\tbgint_t wordIndex, offset;\n\tbgint_t i;\n\n\tbwtResidentSizeInWord = BWTResidentSizeInWord(bwt->textLength);\n\n\twordIndex = bwt->textLength / CHAR_PER_WORD;\n\toffset = (bwt->textLength - wordIndex * CHAR_PER_WORD) * BIT_PER_CHAR;\n\tif (offset > 0) {\n\t\tbwt->bwtCode[wordIndex] = truncateRight(bwt->bwtCode[wordIndex], BITS_IN_WORD - offset);\n\t} else {\n\t\tif (wordIndex < bwtResidentSizeInWord) {\n\t\t\tbwt->bwtCode[wordIndex] = 0;\n\t\t}\n\t}\n\n\tfor (i=wordIndex+1; i<bwtResidentSizeInWord; i++) {\n\t\tbwt->bwtCode[i] = 0;\n\t}\n}", "idx": 92}
{"project": "BWA", "commit_id": "185_BWA_0.7.17_bwt_gen.c_BWTIncConstructFromPacked.c", "target": 0, "func": "BWTInc *BWTIncConstructFromPacked(const char *inputFileName, bgint_t initialMaxBuildSize, bgint_t incMaxBuildSize)\n{\n\n\tFILE *packedFile;\n\tbgint_t packedFileLen;\n\tbgint_t totalTextLength;\n\tbgint_t textToLoad, textSizeInByte;\n\tbgint_t processedTextLength;\n\tunsigned char lastByteLength;\n\n\tBWTInc *bwtInc;\n\n\tpackedFile = (FILE*)fopen(inputFileName, \"rb\");\n\n\tif (packedFile == NULL) {\n\t\tfprintf(stderr, \"BWTIncConstructFromPacked() : Cannot open %s : %s\\n\",\n\t\t\t\tinputFileName, strerror(errno));\n\t\texit(1);\n\t}\n\n\tif (fseek(packedFile, -1, SEEK_END) != 0) {\n\t\tfprintf(stderr, \"BWTIncConstructFromPacked() : Can't seek on %s : %s\\n\",\n\t\t\t\tinputFileName, strerror(errno));\n\t\texit(1);\n\t}\n\tpackedFileLen = ftell(packedFile);\n\tif (packedFileLen == -1) {\n\t\tfprintf(stderr, \"BWTIncConstructFromPacked() : Can't ftell on %s : %s\\n\",\n\t\t\t\tinputFileName, strerror(errno));\n\t\texit(1);\n\t}\n\tif (fread(&lastByteLength, sizeof(unsigned char), 1, packedFile) != 1) {\n\t\tfprintf(stderr,\n\t\t\t\t\"BWTIncConstructFromPacked() : Can't read from %s : %s\\n\",\n\t\t\t\tinputFileName,\n\t\t\t\tferror(packedFile)? strerror(errno) : \"Unexpected end of file\");\n\t\texit(1);\n\t}\n\ttotalTextLength = TextLengthFromBytePacked(packedFileLen, BIT_PER_CHAR, lastByteLength);\n\n\tbwtInc = BWTIncCreate(totalTextLength, initialMaxBuildSize, incMaxBuildSize);\n\n\tBWTIncSetBuildSizeAndTextAddr(bwtInc);\n\n\tif (bwtInc->buildSize > totalTextLength) {\n\t\ttextToLoad = totalTextLength;\n\t} else {\n\t\ttextToLoad = totalTextLength - ((totalTextLength - bwtInc->buildSize + CHAR_PER_WORD - 1) / CHAR_PER_WORD * CHAR_PER_WORD);\n\t}\n\ttextSizeInByte = textToLoad / CHAR_PER_BYTE;\t// excluded the odd byte\n\n\tif (fseek(packedFile, -((long)textSizeInByte + 2), SEEK_CUR) != 0) {\n\t\tfprintf(stderr, \"BWTIncConstructFromPacked() : Can't seek on %s : %s\\n\",\n\t\t\t\tinputFileName, strerror(errno));\n\t\texit(1);\n\t}\n\tif (fread(bwtInc->textBuffer, sizeof(unsigned char), textSizeInByte + 1, packedFile) != textSizeInByte + 1) {\n\t\tfprintf(stderr,\n\t\t\t\t\"BWTIncConstructFromPacked() : Can't read from %s : %s\\n\",\n\t\t\t\tinputFileName,\n\t\t\t\tferror(packedFile)? strerror(errno) : \"Unexpected end of file\");\n\t\texit(1);\n\t}\n\tif (fseek(packedFile, -((long)textSizeInByte + 1), SEEK_CUR) != 0) {\n\t\tfprintf(stderr, \"BWTIncConstructFromPacked() : Can't seek on %s : %s\\n\",\n\t\t\t\tinputFileName, strerror(errno));\n\t\texit(1);\n\t}\n\n\tConvertBytePackedToWordPacked(bwtInc->textBuffer, bwtInc->packedText, ALPHABET_SIZE, textToLoad);\n\tBWTIncConstruct(bwtInc, textToLoad);\n\n\tprocessedTextLength = textToLoad;\n\n\twhile (processedTextLength < totalTextLength) {\n\t\ttextToLoad = bwtInc->buildSize / CHAR_PER_WORD * CHAR_PER_WORD;\n\t\tif (textToLoad > totalTextLength - processedTextLength) {\n\t\t\ttextToLoad = totalTextLength - processedTextLength;\n\t\t}\n\t\ttextSizeInByte = textToLoad / CHAR_PER_BYTE;\n\t\tif (fseek(packedFile, -((long)textSizeInByte), SEEK_CUR) != 0) {\n\t\t\tfprintf(stderr, \"BWTIncConstructFromPacked() : Can't seek on %s : %s\\n\",\n\t\t\t\t\tinputFileName, strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tif (fread(bwtInc->textBuffer, sizeof(unsigned char), textSizeInByte, packedFile) != textSizeInByte) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"BWTIncConstructFromPacked() : Can't read from %s : %s\\n\",\n\t\t\t\tinputFileName,\n\t\t\t\tferror(packedFile)? strerror(errno) : \"Unexpected end of file\");\n\t\t\texit(1);\n\t\t}\n\t\tif (fseek(packedFile, -((long)textSizeInByte), SEEK_CUR) != 0) {\n\t\t\tfprintf(stderr, \"BWTIncConstructFromPacked() : Can't seek on %s : %s\\n\",\n\t\t\t\t\tinputFileName, strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tConvertBytePackedToWordPacked(bwtInc->textBuffer, bwtInc->packedText, ALPHABET_SIZE, textToLoad);\n\t\tBWTIncConstruct(bwtInc, textToLoad);\n\t\tprocessedTextLength += textToLoad;\n\t\tif (bwtInc->numberOfIterationDone % 10 == 0) {\n\t\t\tfprintf(stderr, \"[BWTIncConstructFromPacked] %lu iterations done. %lu characters processed.\\n\",\n\t\t\t\t\t(long)bwtInc->numberOfIterationDone, (long)processedTextLength);\n\t\t}\n\t}\n\n\tfclose(packedFile);\n\treturn bwtInc;\n}", "idx": 93}
{"project": "BWA", "commit_id": "186_BWA_0.7.17_bwt_gen.c_BWTIncFree.c", "target": 0, "func": "void BWTIncFree(BWTInc *bwtInc)\n{\n\tif (bwtInc == 0) return;\n\tfree(bwtInc->bwt->cumulativeFreq);\n\tfree(bwtInc->bwt->occValueMajor);\n\tfree(bwtInc->bwt->decodeTable);\n\tfree(bwtInc->bwt);\n\tfree(bwtInc->workingMemory);\n\tfree(bwtInc->cumulativeCountInCurrentBuild);\n\tfree(bwtInc->packedShift);\n\tfree(bwtInc);\n}", "idx": 94}
{"project": "BWA", "commit_id": "187_BWA_0.7.17_bwt_gen.c_BWTFileSizeInWord.c", "target": 0, "func": "static bgint_t BWTFileSizeInWord(const bgint_t numChar)\n{\n\t// The $ in BWT at the position of inverseSa0 is not encoded\n\treturn (numChar + CHAR_PER_WORD - 1) / CHAR_PER_WORD;\n}", "idx": 95}
{"project": "BWA", "commit_id": "188_BWA_0.7.17_bwt_gen.c_BWTSaveBwtCodeAndOcc.c", "target": 0, "func": "void BWTSaveBwtCodeAndOcc(const BWT *bwt, const char *bwtFileName, const char *occValueFileName)\n{\n\tFILE *bwtFile;\n/*\tFILE *occValueFile; */\n\tbgint_t bwtLength;\n\n\tbwtFile = (FILE*)fopen(bwtFileName, \"wb\");\n\tif (bwtFile == NULL) {\n\t\tfprintf(stderr,\n\t\t\t\t\"BWTSaveBwtCodeAndOcc(): Cannot open %s for writing: %s\\n\",\n\t\t\t\tbwtFileName, strerror(errno));\n\t\texit(1);\n\t}\n\n\tbwtLength = BWTFileSizeInWord(bwt->textLength);\n\n\tif (fwrite(&bwt->inverseSa0, sizeof(bgint_t), 1, bwtFile) != 1\n\t\t|| fwrite(bwt->cumulativeFreq + 1,\n\t\t\t\t  sizeof(bgint_t), ALPHABET_SIZE, bwtFile) != ALPHABET_SIZE\n\t\t|| fwrite(bwt->bwtCode,\n\t\t\t\t  sizeof(unsigned int), bwtLength, bwtFile) != bwtLength) {\n\t\tfprintf(stderr, \"BWTSaveBwtCodeAndOcc(): Error writing to %s : %s\\n\",\n\t\t\t\tbwtFileName, strerror(errno));\n\t\texit(1);\n\t}\n\tif (fclose(bwtFile) != 0) {\n\t\tfprintf(stderr, \"BWTSaveBwtCodeAndOcc(): Error on closing %s : %s\\n\",\n\t\t\t\tbwtFileName, strerror(errno));\n\t\texit(1);\n\t}\n}", "idx": 96}
{"project": "BWA", "commit_id": "189_BWA_0.7.17_bwt_gen.c_bwt_bwtgen2.c", "target": 0, "func": "void bwt_bwtgen2(const char *fn_pac, const char *fn_bwt, int block_size)\n{\n\tBWTInc *bwtInc;\n\tbwtInc = BWTIncConstructFromPacked(fn_pac, block_size, block_size);\n\tfprintf(stderr, \"[bwt_gen] Finished constructing BWT in %u iterations.\\n\", bwtInc->numberOfIterationDone);\n\tBWTSaveBwtCodeAndOcc(bwtInc->bwt, fn_bwt, 0);\n\tBWTIncFree(bwtInc);\n}", "idx": 97}
{"project": "BWA", "commit_id": "18_BWA_0.7.17_bntseq.c_bns_fasta2bntseq.c", "target": 0, "func": "int64_t bns_fasta2bntseq(gzFile fp_fa, const char *prefix, int for_only)\n{\n\textern void seq_reverse(int len, ubyte_t *seq, int is_comp); // in bwaseqio.c\n\tkseq_t *seq;\n\tchar name[1024];\n\tbntseq_t *bns;\n\tuint8_t *pac = 0;\n\tint32_t m_seqs, m_holes;\n\tint64_t ret = -1, m_pac, l;\n\tbntamb1_t *q;\n\tFILE *fp;\n\n\t// initialization\n\tseq = kseq_init(fp_fa);\n\tbns = (bntseq_t*)calloc(1, sizeof(bntseq_t));\n\tbns->seed = 11; // fixed seed for random generator\n\tsrand48(bns->seed);\n\tm_seqs = m_holes = 8; m_pac = 0x10000;\n\tbns->anns = (bntann1_t*)calloc(m_seqs, sizeof(bntann1_t));\n\tbns->ambs = (bntamb1_t*)calloc(m_holes, sizeof(bntamb1_t));\n\tpac = calloc(m_pac/4, 1);\n\tq = bns->ambs;\n\tstrcpy(name, prefix); strcat(name, \".pac\");\n\tfp = xopen(name, \"wb\");\n\t// read sequences\n\twhile (kseq_read(seq) >= 0) pac = add1(seq, bns, pac, &m_pac, &m_seqs, &m_holes, &q);\n\tif (!for_only) { // add the reverse complemented sequence\n\t\tint64_t ll_pac = (bns->l_pac * 2 + 3) / 4 * 4;\n\t\tif (ll_pac > m_pac) pac = realloc(pac, ll_pac/4);\n\t\tmemset(pac + (bns->l_pac+3)/4, 0, (ll_pac - (bns->l_pac+3)/4*4) / 4);\n\t\tfor (l = bns->l_pac - 1; l >= 0; --l, ++bns->l_pac)\n\t\t\t_set_pac(pac, bns->l_pac, 3-_get_pac(pac, l));\n\t}\n\tret = bns->l_pac;\n\t{ // finalize .pac file\n\t\tubyte_t ct;\n\t\terr_fwrite(pac, 1, (bns->l_pac>>2) + ((bns->l_pac&3) == 0? 0 : 1), fp);\n\t\t// the following codes make the pac file size always (l_pac/4+1+1)\n\t\tif (bns->l_pac % 4 == 0) {\n\t\t\tct = 0;\n\t\t\terr_fwrite(&ct, 1, 1, fp);\n\t\t}\n\t\tct = bns->l_pac % 4;\n\t\terr_fwrite(&ct, 1, 1, fp);\n\t\t// close .pac file\n\t\terr_fflush(fp);\n\t\terr_fclose(fp);\n\t}\n\tbns_dump(bns, prefix);\n\tbns_destroy(bns);\n\tkseq_destroy(seq);\n\tfree(pac);\n\treturn ret;\n}", "idx": 98}
{"project": "BWA", "commit_id": "190_BWA_0.7.17_bwt_gen.c_bwt_bwtgen.c", "target": 0, "func": "void bwt_bwtgen(const char *fn_pac, const char *fn_bwt)\n{\n\tbwt_bwtgen2(fn_pac, fn_bwt, 10000000);\n}", "idx": 99}
{"project": "BWA", "commit_id": "191_BWA_0.7.17_bwt_gen.c_bwt_bwtgen_main.c", "target": 0, "func": "int bwt_bwtgen_main(int argc, char *argv[])\n{\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: bwtgen <in.pac> <out.bwt>\\n\");\n\t\treturn 1;\n\t}\n\tbwt_bwtgen(argv[1], argv[2]);\n\treturn 0;\n}", "idx": 100}
{"project": "BWA", "commit_id": "192_BWA_0.7.17_bwt_gen.c_main.c", "target": 0, "func": "int main(int argc, char *argv[])\n{\n\treturn bwt_bwtgen_main(argc, argv);\n}", "idx": 101}
{"project": "BWA", "commit_id": "193_BWA_0.7.17_bwt_lite.c_bwtl_seq2bwtl.c", "target": 0, "func": "bwtl_t *bwtl_seq2bwtl(int len, const uint8_t *seq)\n{\n\tbwtl_t *b;\n\tint i;\n\tb = (bwtl_t*)calloc(1, sizeof(bwtl_t));\n\tb->seq_len = len;\n\n\t{ // calculate b->bwt\n\t\tuint8_t *s;\n\t\tb->sa = (uint32_t*)calloc(len + 1, 4);\n\t\tis_sa(seq, (int*)b->sa, len);\n\t\ts = (uint8_t*)calloc(len + 1, 1);\n\t\tfor (i = 0; i <= len; ++i) {\n\t\t\tif (b->sa[i] == 0) b->primary = i;\n\t\t\telse s[i] = seq[b->sa[i] - 1];\n\t\t}\n\t\tfor (i = b->primary; i < len; ++i) s[i] = s[i + 1];\n\t\tb->bwt_size = (len + 15) / 16;\n\t\tb->bwt = (uint32_t*)calloc(b->bwt_size, 4);\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tb->bwt[i>>4] |= s[i] << ((15 - (i&15)) << 1);\n\t\tfree(s);\n\t}\n\t{ // calculate b->occ\n\t\tuint32_t c[4];\n\t\tb->n_occ = (len + 15) / 16 * 4;\n\t\tb->occ = (uint32_t*)calloc(b->n_occ, 4);\n\t\tmemset(c, 0, 16);\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tif (i % 16 == 0)\n\t\t\t\tmemcpy(b->occ + (i/16) * 4, c, 16);\n\t\t\t++c[bwtl_B0(b, i)];\n\t\t}\n\t\tmemcpy(b->L2+1, c, 16);\n\t\tfor (i = 2; i < 5; ++i) b->L2[i] += b->L2[i-1];\n\t}\n\t{ // generate cnt_table\n\t\tfor (i = 0; i != 256; ++i) {\n\t\t\tuint32_t j, x = 0;\n\t\t\tfor (j = 0; j != 4; ++j)\n\t\t\t\tx |= (((i&3) == j) + ((i>>2&3) == j) + ((i>>4&3) == j) + (i>>6 == j)) << (j<<3);\n\t\t\tb->cnt_table[i] = x;\n\t\t}\n\t}\n\treturn b;\n}", "idx": 102}
{"project": "BWA", "commit_id": "194_BWA_0.7.17_bwt_lite.c_bwtl_occ.c", "target": 0, "func": "uint32_t bwtl_occ(const bwtl_t *bwt, uint32_t k, uint8_t c)\n{\n\tuint32_t n, b;\n\tif (k == bwt->seq_len) return bwt->L2[c+1] - bwt->L2[c];\n\tif (k == (uint32_t)(-1)) return 0;\n\tif (k >= bwt->primary) --k; // because $ is not in bwt\n\tn = bwt->occ[k/16<<2|c];\n\tb = bwt->bwt[k/16] & ~((1U<<((15-(k&15))<<1)) - 1);\n\tn += (bwt->cnt_table[b&0xff] + bwt->cnt_table[b>>8&0xff]\n\t\t  + bwt->cnt_table[b>>16&0xff] + bwt->cnt_table[b>>24]) >> (c<<3) & 0xff;\n\tif (c == 0) n -= 15 - (k&15); // corrected for the masked bits\n\treturn n;\n}", "idx": 103}
{"project": "BWA", "commit_id": "195_BWA_0.7.17_bwt_lite.c_bwtl_occ4.c", "target": 0, "func": "void bwtl_occ4(const bwtl_t *bwt, uint32_t k, uint32_t cnt[4])\n{\n\tuint32_t x, b;\n\tif (k == (uint32_t)(-1)) {\n\t\tmemset(cnt, 0, 16);\n\t\treturn;\n\t}\n\tif (k >= bwt->primary) --k; // because $ is not in bwt\n\tmemcpy(cnt, bwt->occ + (k>>4<<2), 16);\n\tb = bwt->bwt[k>>4] & ~((1U<<((~k&15)<<1)) - 1);\n\tx = bwt->cnt_table[b&0xff] + bwt->cnt_table[b>>8&0xff]\n\t\t+ bwt->cnt_table[b>>16&0xff] + bwt->cnt_table[b>>24];\n\tx -= 15 - (k&15);\n\tcnt[0] += x&0xff; cnt[1] += x>>8&0xff; cnt[2] += x>>16&0xff; cnt[3] += x>>24;\n}", "idx": 104}
{"project": "BWA", "commit_id": "196_BWA_0.7.17_bwt_lite.c_bwtl_2occ4.c", "target": 0, "func": "void bwtl_2occ4(const bwtl_t *bwt, uint32_t k, uint32_t l, uint32_t cntk[4], uint32_t cntl[4])\n{\n\tbwtl_occ4(bwt, k, cntk);\n\tbwtl_occ4(bwt, l, cntl);\n}", "idx": 105}
{"project": "BWA", "commit_id": "197_BWA_0.7.17_bwt_lite.c_bwtl_destroy.c", "target": 0, "func": "void bwtl_destroy(bwtl_t *bwt)\n{\n\tif (bwt) {\n\t\tfree(bwt->occ); free(bwt->bwt); free(bwt->sa);\n\t\tfree(bwt);\n\t}\n}", "idx": 106}
{"project": "BWA", "commit_id": "198_BWA_0.7.17_example.c_main.c", "target": 0, "func": "int main(int argc, char *argv[])\n{\n\tbwaidx_t *idx;\n\tgzFile fp;\n\tkseq_t *ks;\n\tmem_opt_t *opt;\n\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: bwamem-lite <idx.base> <reads.fq>\\n\");\n\t\treturn 1;\n\t}\n\n\tidx = bwa_idx_load(argv[1], BWA_IDX_ALL); // load the BWA index\n\tif (NULL == idx) {\n\t\tfprintf(stderr, \"Index load failed.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tfp = strcmp(argv[2], \"-\")? gzopen(argv[2], \"r\") : gzdopen(fileno(stdin), \"r\");\n\tif (NULL == fp) {\n\t\tfprintf(stderr, \"Couldn't open %s : %s\\n\",\n\t\t\t\tstrcmp(argv[2], \"-\") ? argv[2] : \"stdin\",\n\t\t\t\terrno ? strerror(errno) : \"Out of memory\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tks = kseq_init(fp); // initialize the FASTA/Q parser\n\topt = mem_opt_init(); // initialize the BWA-MEM parameters to the default values\n\n\twhile (kseq_read(ks) >= 0) { // read one sequence\n\t\tmem_alnreg_v ar;\n\t\tint i, k;\n\t\tar = mem_align1(opt, idx->bwt, idx->bns, idx->pac, ks->seq.l, ks->seq.s); // get all the hits\n\t\tfor (i = 0; i < ar.n; ++i) { // traverse each hit\n\t\t\tmem_aln_t a;\n\t\t\tif (ar.a[i].secondary >= 0) continue; // skip secondary alignments\n\t\t\ta = mem_reg2aln(opt, idx->bns, idx->pac, ks->seq.l, ks->seq.s, &ar.a[i]); // get forward-strand position and CIGAR\n\t\t\t// print alignment\n\t\t\tprintf(\"%s\\t%c\\t%s\\t%ld\\t%d\\t\", ks->name.s, \"+-\"[a.is_rev], idx->bns->anns[a.rid].name, (long)a.pos, a.mapq);\n\t\t\tfor (k = 0; k < a.n_cigar; ++k) // print CIGAR\n\t\t\t\tprintf(\"%d%c\", a.cigar[k]>>4, \"MIDSH\"[a.cigar[k]&0xf]);\n\t\t\tprintf(\"\\t%d\\n\", a.NM); // print edit distance\n\t\t\tfree(a.cigar); // don't forget to deallocate CIGAR\n\t\t}\n\t\tfree(ar.a); // and deallocate the hit list\n\t}\n\n\tfree(opt);\n\tkseq_destroy(ks);\n\tgzclose(fp);\n\tbwa_idx_destroy(idx);\n\treturn 0;\n}", "idx": 107}
{"project": "BWA", "commit_id": "199_BWA_0.7.17_fastmap.c_update_a.c", "target": 0, "func": "static void update_a(mem_opt_t *opt, const mem_opt_t *opt0)\n{\n\tif (opt0->a) { // matching score is changed\n\t\tif (!opt0->b) opt->b *= opt->a;\n\t\tif (!opt0->T) opt->T *= opt->a;\n\t\tif (!opt0->o_del) opt->o_del *= opt->a;\n\t\tif (!opt0->e_del) opt->e_del *= opt->a;\n\t\tif (!opt0->o_ins) opt->o_ins *= opt->a;\n\t\tif (!opt0->e_ins) opt->e_ins *= opt->a;\n\t\tif (!opt0->zdrop) opt->zdrop *= opt->a;\n\t\tif (!opt0->pen_clip5) opt->pen_clip5 *= opt->a;\n\t\tif (!opt0->pen_clip3) opt->pen_clip3 *= opt->a;\n\t\tif (!opt0->pen_unpaired) opt->pen_unpaired *= opt->a;\n\t}\n}", "idx": 108}
{"project": "BWA", "commit_id": "19_BWA_0.7.17_bntseq.c_bwa_fa2pac.c", "target": 0, "func": "int bwa_fa2pac(int argc, char *argv[])\n{\n\tint c, for_only = 0;\n\tgzFile fp;\n\twhile ((c = getopt(argc, argv, \"f\")) >= 0) {\n\t\tswitch (c) {\n\t\t\tcase 'f': for_only = 1; break;\n\t\t}\n\t}\n\tif (argc == optind) {\n\t\tfprintf(stderr, \"Usage: bwa fa2pac [-f] <in.fasta> [<out.prefix>]\\n\");\n\t\treturn 1;\n\t}\n\tfp = xzopen(argv[optind], \"r\");\n\tbns_fasta2bntseq(fp, (optind+1 < argc)? argv[optind+1] : argv[optind], for_only);\n\terr_gzclose(fp);\n\treturn 0;\n}", "idx": 109}
{"project": "BWA", "commit_id": "1_BWA_0.7.17_bamlite.c_bam_is_big_endian.c", "target": 0, "func": "static inline int bam_is_big_endian()\n{\n\tlong one= 1;\n\treturn !(*((char *)(&one)));\n}", "idx": 110}
{"project": "BWA", "commit_id": "200_BWA_0.7.17_is.c_getCounts.c", "target": 0, "func": "static void getCounts(const unsigned char *T, int *C, int n, int k, int cs)\n{\n\tint i;\n\tfor (i = 0; i < k; ++i) C[i] = 0;\n\tfor (i = 0; i < n; ++i) ++C[chr(i)];\n}", "idx": 111}
{"project": "BWA", "commit_id": "201_BWA_0.7.17_is.c_getBuckets.c", "target": 0, "func": "static void getBuckets(const int *C, int *B, int k, int end)\n{\n\tint i, sum = 0;\n\tif (end) {\n\t\tfor (i = 0; i < k; ++i) {\n\t\t\tsum += C[i];\n\t\t\tB[i] = sum;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < k; ++i) {\n\t\t\tsum += C[i];\n\t\t\tB[i] = sum - C[i];\n\t\t}\n\t}\n}", "idx": 112}
{"project": "BWA", "commit_id": "202_BWA_0.7.17_is.c_sais_main.c", "target": 0, "func": "static int sais_main(const unsigned char *T, int *SA, int fs, int n, int k, int cs)\n{\n\tint *C, *B, *RA;\n\tint  i, j, c, m, p, q, plen, qlen, name;\n\tint  c0, c1;\n\tint  diff;\n\n\t/* stage 1: reduce the problem by at least 1/2 sort all the\n\t * S-substrings */\n\tif (k <= fs) {\n\t\tC = SA + n;\n\t\tB = (k <= (fs - k)) ? C + k : C;\n\t} else if ((C = B = (int *) malloc(k * sizeof(int))) == NULL) return -2;\n\tgetCounts(T, C, n, k, cs);\n\tgetBuckets(C, B, k, 1);\t/* find ends of buckets */\n\tfor (i = 0; i < n; ++i) SA[i] = 0;\n\tfor (i = n - 2, c = 0, c1 = chr(n - 1); 0 <= i; --i, c1 = c0) {\n\t\tif ((c0 = chr(i)) < (c1 + c)) c = 1;\n\t\telse if (c != 0) SA[--B[c1]] = i + 1, c = 0;\n\t}\n\tinduceSA(T, SA, C, B, n, k, cs);\n\tif (fs < k) free(C);\n\t/* compact all the sorted substrings into the first m items of SA\n\t * 2*m must be not larger than n (proveable) */\n\tfor (i = 0, m = 0; i < n; ++i) {\n\t\tp = SA[i];\n\t\tif ((0 < p) && (chr(p - 1) > (c0 = chr(p)))) {\n\t\t\tfor (j = p + 1; (j < n) && (c0 == (c1 = chr(j))); ++j);\n\t\t\tif ((j < n) && (c0 < c1)) SA[m++] = p;\n\t\t}\n\t}\n\tfor (i = m; i < n; ++i) SA[i] = 0;\t/* init the name array buffer */\n\t/* store the length of all substrings */\n\tfor (i = n - 2, j = n, c = 0, c1 = chr(n - 1); 0 <= i; --i, c1 = c0) {\n\t\tif ((c0 = chr(i)) < (c1 + c)) c = 1;\n\t\telse if (c != 0) {\n\t\t\tSA[m + ((i + 1) >> 1)] = j - i - 1;\n\t\t\tj = i + 1;\n\t\t\tc = 0;\n\t\t}\n\t}\n\t/* find the lexicographic names of all substrings */\n\tfor (i = 0, name = 0, q = n, qlen = 0; i < m; ++i) {\n\t\tp = SA[i], plen = SA[m + (p >> 1)], diff = 1;\n\t\tif (plen == qlen) {\n\t\t\tfor (j = 0; (j < plen) && (chr(p + j) == chr(q + j)); j++);\n\t\t\tif (j == plen) diff = 0;\n\t\t}\n\t\tif (diff != 0) ++name, q = p, qlen = plen;\n\t\tSA[m + (p >> 1)] = name;\n\t}\n\n\t/* stage 2: solve the reduced problem recurse if names are not yet\n\t * unique */\n\tif (name < m) {\n\t\tRA = SA + n + fs - m;\n\t\tfor (i = n - 1, j = m - 1; m <= i; --i) {\n\t\t\tif (SA[i] != 0) RA[j--] = SA[i] - 1;\n\t\t}\n\t\tif (sais_main((unsigned char *) RA, SA, fs + n - m * 2, m, name, sizeof(int)) != 0) return -2;\n\t\tfor (i = n - 2, j = m - 1, c = 0, c1 = chr(n - 1); 0 <= i; --i, c1 = c0) {\n\t\t\tif ((c0 = chr(i)) < (c1 + c)) c = 1;\n\t\t\telse if (c != 0) RA[j--] = i + 1, c = 0; /* get p1 */\n\t\t}\n\t\tfor (i = 0; i < m; ++i) SA[i] = RA[SA[i]]; /* get index */\n\t}\n\t/* stage 3: induce the result for the original problem */\n\tif (k <= fs) {\n\t\tC = SA + n;\n\t\tB = (k <= (fs - k)) ? C + k : C;\n\t} else if ((C = B = (int *) malloc(k * sizeof(int))) == NULL) return -2;\n\t/* put all left-most S characters into their buckets */\n\tgetCounts(T, C, n, k, cs);\n\tgetBuckets(C, B, k, 1);\t/* find ends of buckets */\n\tfor (i = m; i < n; ++i) SA[i] = 0; /* init SA[m..n-1] */\n\tfor (i = m - 1; 0 <= i; --i) {\n\t\tj = SA[i], SA[i] = 0;\n\t\tSA[--B[chr(j)]] = j;\n\t}\n\tinduceSA(T, SA, C, B, n, k, cs);\n\tif (fs < k) free(C);\n\treturn 0;\n}", "idx": 113}
{"project": "BWA", "commit_id": "203_BWA_0.7.17_is.c_is_sa.c", "target": 0, "func": "int is_sa(const ubyte_t *T, int *SA, int n)\n{\n\tif ((T == NULL) || (SA == NULL) || (n < 0)) return -1;\n\tSA[0] = n;\n\tif (n <= 1) {\n\t\tif (n == 1) SA[1] = 0;\n\t\treturn 0;\n\t}\n\treturn sais_main(T, SA+1, 0, n, 256, 1);\n}", "idx": 114}
{"project": "BWA", "commit_id": "204_BWA_0.7.17_is.c_is_bwt.c", "target": 0, "func": "int is_bwt(ubyte_t *T, int n)\n{\n\tint *SA, i, primary = 0;\n\tSA = (int*)calloc(n+1, sizeof(int));\n\n\tif (is_sa(T, SA, n)) return -1;\n\n\tfor (i = 0; i <= n; ++i) {\n\t\tif (SA[i] == 0) primary = i;\n\t\telse SA[i] = T[SA[i] - 1];\n\t}\n\tfor (i = 0; i < primary; ++i) T[i] = SA[i];\n\tfor (; i < n; ++i) T[i] = SA[i + 1];\n\tfree(SA);\n\treturn primary;\n}", "idx": 115}
{"project": "BWA", "commit_id": "205_BWA_0.7.17_kopen.c_socket_wait.c", "target": 0, "func": "static int socket_wait(int fd, int is_read)\n{\n\tfd_set fds, *fdr = 0, *fdw = 0;\n\tstruct timeval tv;\n\tint ret;\n\ttv.tv_sec = 5; tv.tv_usec = 0; // 5 seconds time out\n\tFD_ZERO(&fds);\n\tFD_SET(fd, &fds);\n\tif (is_read) fdr = &fds;\n\telse fdw = &fds;\n\tret = select(fd+1, fdr, fdw, 0, &tv);\n\tif (ret == -1) perror(\"select\");\n\treturn ret;\n}", "idx": 116}
{"project": "BWA", "commit_id": "206_BWA_0.7.17_kopen.c_socket_connect.c", "target": 0, "func": "static int socket_connect(const char *host, const char *port)\n{\n#define __err_connect(func) do { perror(func); freeaddrinfo(res); return -1; } while (0)\n\n\tint on = 1, fd;\n\tstruct linger lng = { 0, 0 };\n\tstruct addrinfo hints, *res = 0;\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\tif (getaddrinfo(host, port, &hints, &res) != 0) __err_connect(\"getaddrinfo\");\n\tif ((fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol)) == -1) __err_connect(\"socket\");\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) __err_connect(\"setsockopt\");\n\tif (setsockopt(fd, SOL_SOCKET, SO_LINGER, &lng, sizeof(lng)) == -1) __err_connect(\"setsockopt\");\n\tif (connect(fd, res->ai_addr, res->ai_addrlen) != 0) __err_connect(\"connect\");\n\tfreeaddrinfo(res);\n\treturn fd;\n#undef __err_connect\n}", "idx": 117}
{"project": "BWA", "commit_id": "207_BWA_0.7.17_kopen.c_write_bytes.c", "target": 0, "func": "static int write_bytes(int fd, const char *buf, size_t len)\n{\n\tssize_t bytes;\n\tdo {\n\t\tbytes = write(fd, buf, len);\n\t\tif (bytes >= 0) {\n\t\t\tlen -= bytes;\n\t\t} else if (errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR) {\n\t\t\treturn -1;\n\t\t}\n\t} while (len > 0);\n\n\treturn 0;\n}", "idx": 118}
{"project": "BWA", "commit_id": "208_BWA_0.7.17_kopen.c_http_open.c", "target": 0, "func": "static int http_open(const char *fn)\n{\n\tchar *p, *proxy, *q, *http_host, *host, *port, *path, *buf;\n\tint fd, ret, l;\n\tssize_t bytes = 0, bufsz = 0x10000;\n\n\t/* parse URL; adapted from khttp_parse_url() in knetfile.c */\n\tif (strstr(fn, \"http://\") != fn) return 0;\n\t// set ->http_host\n\tfor (p = (char*)fn + 7; *p && *p != '/'; ++p);\n\tl = p - fn - 7;\n\thttp_host = calloc(l + 1, 1);\n\tstrncpy(http_host, fn + 7, l);\n\thttp_host[l] = 0;\n\tfor (q = http_host; *q && *q != ':'; ++q);\n\tif (*q == ':') *q++ = 0;\n\t// get http_proxy\n\tproxy = getenv(\"http_proxy\");\n\t// set host, port and path\n\tif (proxy == 0) {\n\t\thost = strdup(http_host); // when there is no proxy, server name is identical to http_host name.\n\t\tport = strdup(*q? q : \"80\");\n\t\tpath = strdup(*p? p : \"/\");\n\t} else {\n\t\thost = (strstr(proxy, \"http://\") == proxy)? strdup(proxy + 7) : strdup(proxy);\n\t\tfor (q = host; *q && *q != ':'; ++q);\n\t\tif (*q == ':') *q++ = 0; \n\t\tport = strdup(*q? q : \"80\");\n\t\tpath = strdup(fn);\n\t}\n\n\t/* connect; adapted from khttp_connect() in knetfile.c */\n\tl = 0;\n\tfd = socket_connect(host, port);\n\tbuf = calloc(bufsz, 1); // FIXME: I am lazy... But in principle, 64KB should be large enough.\n\tl += snprintf(buf + l, bufsz, \"GET %s HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n\",\n\t\t\t\t path, http_host);\n\tif (write_bytes(fd, buf, l) != 0) {\n\t\tclose(fd);\n\t\tfd = -1;\n\t\tgoto out;\n\t}\n\tl = 0;\n retry:\n\twhile (l < bufsz && (bytes = read(fd, buf + l, 1)) > 0) { // read HTTP header; FIXME: bad efficiency\n\t\tif (buf[l] == '\\n' && l >= 3)\n\t\t\tif (strncmp(buf + l - 3, \"\\r\\n\\r\\n\", 4) == 0) break;\n\t\t++l;\n\t}\n\tif (bytes < 0 && (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)) goto retry;\n\n\tbuf[l] = 0;\n\tif (bytes < 0 || l < 14) { // prematured header\n\t\tclose(fd);\n\t\tfd = -1;\n\t\tgoto out;\n\t}\n\tret = strtol(buf + 8, &p, 0); // HTTP return code\n\tif (ret != 200) {\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n out:\n\tfree(buf); free(http_host); free(host); free(port); free(path);\n\treturn fd;\n}", "idx": 119}
{"project": "BWA", "commit_id": "209_BWA_0.7.17_kopen.c_kftp_get_response.c", "target": 0, "func": "static int kftp_get_response(ftpaux_t *aux)\n{\n\tunsigned char c;\n\tint n = 0;\n\tchar *p;\n\tif (socket_wait(aux->ctrl_fd, 1) <= 0) return 0;\n\twhile (read(aux->ctrl_fd, &c, 1)) { // FIXME: this is *VERY BAD* for unbuffered I/O\n\t\tif (n >= aux->max_response) {\n\t\t\taux->max_response = aux->max_response? aux->max_response<<1 : 256;\n\t\t\taux->response = realloc(aux->response, aux->max_response);\n\t\t}\n\t\taux->response[n++] = c;\n\t\tif (c == '\\n') {\n\t\t\tif (n >= 4 && isdigit(aux->response[0]) && isdigit(aux->response[1]) && isdigit(aux->response[2])\n\t\t\t\t&& aux->response[3] != '-') break;\n\t\t\tn = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif (n < 2) return -1;\n\taux->response[n-2] = 0;\n\treturn strtol(aux->response, &p, 0);\n}", "idx": 120}
{"project": "BWA", "commit_id": "20_BWA_0.7.17_bntseq.c_bns_pos2rid.c", "target": 0, "func": "int bns_pos2rid(const bntseq_t *bns, int64_t pos_f)\n{\n\tint left, mid, right;\n\tif (pos_f >= bns->l_pac) return -1;\n\tleft = 0; mid = 0; right = bns->n_seqs;\n\twhile (left < right) { // binary search\n\t\tmid = (left + right) >> 1;\n\t\tif (pos_f >= bns->anns[mid].offset) {\n\t\t\tif (mid == bns->n_seqs - 1) break;\n\t\t\tif (pos_f < bns->anns[mid+1].offset) break; // bracketed\n\t\t\tleft = mid + 1;\n\t\t} else right = mid;\n\t}\n\treturn mid;\n}", "idx": 121}
{"project": "BWA", "commit_id": "210_BWA_0.7.17_kopen.c_kftp_send_cmd.c", "target": 0, "func": "static int kftp_send_cmd(ftpaux_t *aux, const char *cmd, int is_get)\n{\n\tif (socket_wait(aux->ctrl_fd, 0) <= 0) return -1; // socket is not ready for writing\n\tif (write_bytes(aux->ctrl_fd, cmd, strlen(cmd)) != 0) return -1;\n\treturn is_get? kftp_get_response(aux) : 0;\n}", "idx": 122}
{"project": "BWA", "commit_id": "211_BWA_0.7.17_kopen.c_ftp_open.c", "target": 0, "func": "static int ftp_open(const char *fn)\n{\n\tchar *p, *host = 0, *port = 0, *retr = 0;\n\tchar host2[80], port2[10];\n\tint v[6], l, fd = -1, ret, pasv_port, pasv_ip[4];\n\tftpaux_t aux;\n\t\n\t/* parse URL */\n\tif (strstr(fn, \"ftp://\") != fn) return 0;\n\tfor (p = (char*)fn + 6; *p && *p != '/'; ++p);\n\tif (*p != '/') return 0;\n\tl = p - fn - 6;\n\tport = strdup(\"21\");\n\thost = calloc(l + 1, 1);\n\tstrncpy(host, fn + 6, l);\n\tretr = calloc(strlen(p) + 8, 1);\n\tsprintf(retr, \"RETR %s\\r\\n\", p);\n\t\n\t/* connect to ctrl */\n\tmemset(&aux, 0, sizeof(ftpaux_t));\n\taux.ctrl_fd = socket_connect(host, port);\n\tif (aux.ctrl_fd == -1) goto ftp_open_end; /* fail to connect ctrl */\n\n\t/* connect to the data stream */\n\tkftp_get_response(&aux);\n\tkftp_send_cmd(&aux, \"USER anonymous\\r\\n\", 1);\n\tkftp_send_cmd(&aux, \"PASS kopen@\\r\\n\", 1);\n\tkftp_send_cmd(&aux, \"TYPE I\\r\\n\", 1);\n\tkftp_send_cmd(&aux, \"PASV\\r\\n\", 1);\n\tfor (p = aux.response; *p && *p != '('; ++p);\n\tif (*p != '(') goto ftp_open_end;\n\t++p;\n\tsscanf(p, \"%d,%d,%d,%d,%d,%d\", &v[0], &v[1], &v[2], &v[3], &v[4], &v[5]);\n\tmemcpy(pasv_ip, v, 4 * sizeof(int));\n\tpasv_port = (v[4]<<8&0xff00) + v[5];\n\tkftp_send_cmd(&aux, retr, 0);\n\tsprintf(host2, \"%d.%d.%d.%d\", pasv_ip[0], pasv_ip[1], pasv_ip[2], pasv_ip[3]);\n\tsprintf(port2, \"%d\", pasv_port);\n\tfd = socket_connect(host2, port2);\n\tif (fd == -1) goto ftp_open_end;\n\tret = kftp_get_response(&aux);\n\tif (ret != 150) {\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n\tclose(aux.ctrl_fd);\n\nftp_open_end:\n\tfree(host); free(port); free(retr); free(aux.response);\n\treturn fd;\n}", "idx": 123}
{"project": "BWA", "commit_id": "212_BWA_0.7.17_kopen.c_cmd2argv.c", "target": 0, "func": "static char **cmd2argv(const char *cmd)\n{\n\tint i, beg, end, argc;\n\tchar **argv, *str;\n\tend = strlen(cmd);\n\tfor (i = end - 1; i >= 0; --i)\n\t\tif (!isspace(cmd[i])) break;\n\tend = i + 1;\n\tfor (beg = 0; beg < end; ++beg)\n\t\tif (!isspace(cmd[beg])) break;\n\tif (beg == end) return 0;\n\tfor (i = beg + 1, argc = 0; i < end; ++i)\n\t\tif (isspace(cmd[i]) && !isspace(cmd[i-1]))\n\t\t\t++argc;\n\targv = (char**)calloc(argc + 2, sizeof(void*));\n\targv[0] = str = (char*)calloc(end - beg + 1, 1);\n\tstrncpy(argv[0], cmd + beg, end - beg);\n\tfor (i = argc = 1; i < end - beg; ++i)\n\t\tif (isspace(str[i])) str[i] = 0;\n\t\telse if (str[i] && str[i-1] == 0) argv[argc++] = &str[i];\n\treturn argv;\n}", "idx": 124}
{"project": "BWA", "commit_id": "213_BWA_0.7.17_kopen.c_kclose.c", "target": 0, "func": "int kclose(void *a)\n{\n\tkoaux_t *aux = (koaux_t*)a;\n\tif (aux->type == KO_PIPE) {\n\t\tint status;\n\t\tpid_t pid;\n\t\tpid = waitpid(aux->pid, &status, WNOHANG);\n\t\tif (pid != aux->pid) kill(aux->pid, 15);\n\t}\n\tfree(aux);\n\treturn 0;\n}", "idx": 125}
{"project": "BWA", "commit_id": "214_BWA_0.7.17_kopen.c_main.c", "target": 0, "func": "int main(int argc, char *argv[])\n{\n\tvoid *x;\n\tint l, fd;\n\tunsigned char buf[BUF_SIZE];\n\tFILE *fp;\n\tif (argc == 1) {\n\t\tfprintf(stderr, \"Usage: kopen <file>\\n\");\n\t\treturn 1;\n\t}\n\tx = kopen(argv[1], &fd);\n\tfp = fdopen(fd, \"r\");\n\tif (fp == 0) {\n\t\tfprintf(stderr, \"ERROR: fail to open the input\\n\");\n\t\treturn 1;\n\t}\n\tdo {\n\t\tif ((l = fread(buf, 1, BUF_SIZE, fp)) != 0)\n\t\t\tfwrite(buf, 1, l, stdout);\n\t} while (l == BUF_SIZE);\n\tfclose(fp);\n\tkclose(x);\n\treturn 0;\n}", "idx": 126}
{"project": "BWA", "commit_id": "215_BWA_0.7.17_kstring.c_ksprintf.c", "target": 0, "func": "int ksprintf(kstring_t *s, const char *fmt, ...)\n{\n\tva_list ap;\n\tint l;\n\tva_start(ap, fmt);\n\tl = vsnprintf(s->s + s->l, s->m - s->l, fmt, ap);\n\tva_end(ap);\n\tif (l + 1 > s->m - s->l) {\n\t\ts->m = s->l + l + 2;\n\t\tkroundup32(s->m);\n\t\ts->s = (char*)realloc(s->s, s->m);\n\t\tva_start(ap, fmt);\n\t\tl = vsnprintf(s->s + s->l, s->m - s->l, fmt, ap);\n\t}\n\tva_end(ap);\n\ts->l += l;\n\treturn l;\n}", "idx": 127}
{"project": "BWA", "commit_id": "216_BWA_0.7.17_kstring.c_main.c", "target": 0, "func": "int main()\n{\n\tkstring_t *s;\n\ts = (kstring_t*)calloc(1, sizeof(kstring_t));\n\tksprintf(s, \"abcdefg: %d\", 100);\n\tprintf(\"%s\\n\", s->s);\n\tfree(s);\n\treturn 0;\n}", "idx": 128}
{"project": "BWA", "commit_id": "217_BWA_0.7.17_ksw.c_ksw_qinit.c", "target": 0, "func": "kswq_t *ksw_qinit(int size, int qlen, const uint8_t *query, int m, const int8_t *mat)\n{\n\tkswq_t *q;\n\tint slen, a, tmp, p;\n\n\tsize = size > 1? 2 : 1;\n\tp = 8 * (3 - size); // # values per __m128i\n\tslen = (qlen + p - 1) / p; // segmented length\n\tq = (kswq_t*)malloc(sizeof(kswq_t) + 256 + 16 * slen * (m + 4)); // a single block of memory\n\tq->qp = (__m128i*)(((size_t)q + sizeof(kswq_t) + 15) >> 4 << 4); // align memory\n\tq->H0 = q->qp + slen * m;\n\tq->H1 = q->H0 + slen;\n\tq->E  = q->H1 + slen;\n\tq->Hmax = q->E + slen;\n\tq->slen = slen; q->qlen = qlen; q->size = size;\n\t// compute shift\n\ttmp = m * m;\n\tfor (a = 0, q->shift = 127, q->mdiff = 0; a < tmp; ++a) { // find the minimum and maximum score\n\t\tif (mat[a] < (int8_t)q->shift) q->shift = mat[a];\n\t\tif (mat[a] > (int8_t)q->mdiff) q->mdiff = mat[a];\n\t}\n\tq->max = q->mdiff;\n\tq->shift = 256 - q->shift; // NB: q->shift is uint8_t\n\tq->mdiff += q->shift; // this is the difference between the min and max scores\n\t// An example: p=8, qlen=19, slen=3 and segmentation:\n\t//  {{0,3,6,9,12,15,18,-1},{1,4,7,10,13,16,-1,-1},{2,5,8,11,14,17,-1,-1}}\n\tif (size == 1) {\n\t\tint8_t *t = (int8_t*)q->qp;\n\t\tfor (a = 0; a < m; ++a) {\n\t\t\tint i, k, nlen = slen * p;\n\t\t\tconst int8_t *ma = mat + a * m;\n\t\t\tfor (i = 0; i < slen; ++i)\n\t\t\t\tfor (k = i; k < nlen; k += slen) // p iterations\n\t\t\t\t\t*t++ = (k >= qlen? 0 : ma[query[k]]) + q->shift;\n\t\t}\n\t} else {\n\t\tint16_t *t = (int16_t*)q->qp;\n\t\tfor (a = 0; a < m; ++a) {\n\t\t\tint i, k, nlen = slen * p;\n\t\t\tconst int8_t *ma = mat + a * m;\n\t\t\tfor (i = 0; i < slen; ++i)\n\t\t\t\tfor (k = i; k < nlen; k += slen) // p iterations\n\t\t\t\t\t*t++ = (k >= qlen? 0 : ma[query[k]]);\n\t\t}\n\t}\n\treturn q;\n}", "idx": 129}
{"project": "BWA", "commit_id": "218_BWA_0.7.17_ksw.c_revseq.c", "target": 0, "func": "static inline void revseq(int l, uint8_t *s)\n{\n\tint i, t;\n\tfor (i = 0; i < l>>1; ++i)\n\t\tt = s[i], s[i] = s[l - 1 - i], s[l - 1 - i] = t;\n}", "idx": 130}
{"project": "BWA", "commit_id": "219_BWA_0.7.17_ksw.c_ksw_align2.c", "target": 0, "func": "kswr_t ksw_align2(int qlen, uint8_t *query, int tlen, uint8_t *target, int m, const int8_t *mat, int o_del, int e_del, int o_ins, int e_ins, int xtra, kswq_t **qry)\n{\n\tint size;\n\tkswq_t *q;\n\tkswr_t r, rr;\n\tkswr_t (*func)(kswq_t*, int, const uint8_t*, int, int, int, int, int);\n\n\tq = (qry && *qry)? *qry : ksw_qinit((xtra&KSW_XBYTE)? 1 : 2, qlen, query, m, mat);\n\tif (qry && *qry == 0) *qry = q;\n\tfunc = q->size == 2? ksw_i16 : ksw_u8;\n\tsize = q->size;\n\tr = func(q, tlen, target, o_del, e_del, o_ins, e_ins, xtra);\n\tif (qry == 0) free(q);\n\tif ((xtra&KSW_XSTART) == 0 || ((xtra&KSW_XSUBO) && r.score < (xtra&0xffff))) return r;\n\trevseq(r.qe + 1, query); revseq(r.te + 1, target); // +1 because qe/te points to the exact end, not the position after the end\n\tq = ksw_qinit(size, r.qe + 1, query, m, mat);\n\trr = func(q, tlen, target, o_del, e_del, o_ins, e_ins, KSW_XSTOP | r.score);\n\trevseq(r.qe + 1, query); revseq(r.te + 1, target);\n\tfree(q);\n\tif (r.score == rr.score)\n\t\tr.tb = r.te - rr.te, r.qb = r.qe - rr.qe;\n\treturn r;\n}", "idx": 131}
{"project": "BWA", "commit_id": "21_BWA_0.7.17_bntseq.c_bns_intv2rid.c", "target": 0, "func": "int bns_intv2rid(const bntseq_t *bns, int64_t rb, int64_t re)\n{\n\tint is_rev, rid_b, rid_e;\n\tif (rb < bns->l_pac && re > bns->l_pac) return -2;\n\tassert(rb <= re);\n\trid_b = bns_pos2rid(bns, bns_depos(bns, rb, &is_rev));\n\trid_e = rb < re? bns_pos2rid(bns, bns_depos(bns, re - 1, &is_rev)) : rid_b;\n\treturn rid_b == rid_e? rid_b : -1;\n}", "idx": 132}
{"project": "BWA", "commit_id": "220_BWA_0.7.17_ksw.c_ksw_align.c", "target": 0, "func": "kswr_t ksw_align(int qlen, uint8_t *query, int tlen, uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int xtra, kswq_t **qry)\n{\n\treturn ksw_align2(qlen, query, tlen, target, m, mat, gapo, gape, gapo, gape, xtra, qry);\n}", "idx": 133}
{"project": "BWA", "commit_id": "221_BWA_0.7.17_ksw.c_ksw_extend.c", "target": 0, "func": "int ksw_extend(int qlen, const uint8_t *query, int tlen, const uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int w, int end_bonus, int zdrop, int h0, int *qle, int *tle, int *gtle, int *gscore, int *max_off)\n{\n\treturn ksw_extend2(qlen, query, tlen, target, m, mat, gapo, gape, gapo, gape, w, end_bonus, zdrop, h0, qle, tle, gtle, gscore, max_off);\n}", "idx": 134}
{"project": "BWA", "commit_id": "222_BWA_0.7.17_ksw.c_push_cigar.c", "target": 0, "func": "static inline uint32_t *push_cigar(int *n_cigar, int *m_cigar, uint32_t *cigar, int op, int len)\n{\n\tif (*n_cigar == 0 || op != (cigar[(*n_cigar) - 1]&0xf)) {\n\t\tif (*n_cigar == *m_cigar) {\n\t\t\t*m_cigar = *m_cigar? (*m_cigar)<<1 : 4;\n\t\t\tcigar = realloc(cigar, (*m_cigar) << 2);\n\t\t}\n\t\tcigar[(*n_cigar)++] = len<<4 | op;\n\t} else cigar[(*n_cigar)-1] += len<<4;\n\treturn cigar;\n}", "idx": 135}
{"project": "BWA", "commit_id": "223_BWA_0.7.17_ksw.c_while.c", "target": 0, "func": "while (i >= 0 && k >= 0) {\n\t\t\twhich = z[(long)i * n_col + (k - (i > w? i - w : 0))] >> (which<<1) & 3;\n\t\t\tif (which == 0)      cigar = push_cigar(&n_cigar, &m_cigar, cigar, 0, 1), --i, --k;\n\t\t\telse if (which == 1) cigar = push_cigar(&n_cigar, &m_cigar, cigar, 2, 1), --i;\n\t\t\telse                 cigar = push_cigar(&n_cigar, &m_cigar, cigar, 1, 1), --k;\n\t\t}", "idx": 136}
{"project": "BWA", "commit_id": "224_BWA_0.7.17_ksw.c_ksw_global.c", "target": 0, "func": "int ksw_global(int qlen, const uint8_t *query, int tlen, const uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int w, int *n_cigar_, uint32_t **cigar_)\n{\n\treturn ksw_global2(qlen, query, tlen, target, m, mat, gapo, gape, gapo, gape, w, n_cigar_, cigar_);\n}", "idx": 137}
{"project": "BWA", "commit_id": "225_BWA_0.7.17_kthread.c_steal_work.c", "target": 0, "func": "static inline long steal_work(kt_for_t *t)\n{\n\tint i, min_i = -1;\n\tlong k, min = LONG_MAX;\n\tfor (i = 0; i < t->n_threads; ++i)\n\t\tif (min > t->w[i].i) min = t->w[i].i, min_i = i;\n\tk = __sync_fetch_and_add(&t->w[min_i].i, t->n_threads);\n\treturn k >= t->n? -1 : k;\n}", "idx": 138}
{"project": "BWA", "commit_id": "226_BWA_0.7.17_kthread.c_ktf_worker.c", "target": 0, "func": "static void *ktf_worker(void *data)\n{\n\tktf_worker_t *w = (ktf_worker_t*)data;\n\tlong i;\n\tfor (;;) {\n\t\ti = __sync_fetch_and_add(&w->i, w->t->n_threads);\n\t\tif (i >= w->t->n) break;\n\t\tw->t->func(w->t->data, i, w - w->t->w);\n\t}\n\twhile ((i = steal_work(w->t)) >= 0)\n\t\tw->t->func(w->t->data, i, w - w->t->w);\n\tpthread_exit(0);\n}", "idx": 139}
{"project": "BWA", "commit_id": "227_BWA_0.7.17_main.c_usage.c", "target": 0, "func": "static int usage()\n{\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Program: bwa (alignment via Burrows-Wheeler transformation)\\n\");\n\tfprintf(stderr, \"Version: %s\\n\", PACKAGE_VERSION);\n\tfprintf(stderr, \"Contact: Heng Li <lh3@sanger.ac.uk>\\n\\n\");\n\tfprintf(stderr, \"Usage:   bwa <command> [options]\\n\\n\");\n\tfprintf(stderr, \"Command: index         index sequences in the FASTA format\\n\");\n\tfprintf(stderr, \"         mem           BWA-MEM algorithm\\n\");\n\tfprintf(stderr, \"         fastmap       identify super-maximal exact matches\\n\");\n\tfprintf(stderr, \"         pemerge       merge overlapping paired ends (EXPERIMENTAL)\\n\");\n\tfprintf(stderr, \"         aln           gapped/ungapped alignment\\n\");\n\tfprintf(stderr, \"         samse         generate alignment (single ended)\\n\");\n\tfprintf(stderr, \"         sampe         generate alignment (paired ended)\\n\");\n\tfprintf(stderr, \"         bwasw         BWA-SW for long queries\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"         shm           manage indices in shared memory\\n\");\n\tfprintf(stderr, \"         fa2pac        convert FASTA to PAC format\\n\");\n\tfprintf(stderr, \"         pac2bwt       generate BWT from PAC\\n\");\n\tfprintf(stderr, \"         pac2bwtgen    alternative algorithm for generating BWT\\n\");\n\tfprintf(stderr, \"         bwtupdate     update .bwt to the new format\\n\");\n\tfprintf(stderr, \"         bwt2sa        generate SA from BWT and Occ\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr,\n\"Note: To use BWA, you need to first index the genome with `bwa index'.\\n\"\n\"      There are three alignment algorithms in BWA: `mem', `bwasw', and\\n\"\n\"      `aln/samse/sampe'. If you are not sure which to use, try `bwa mem'\\n\"\n\"      first. Please `man ./bwa.1' for the manual.\\n\\n\");\n\treturn 1;\n}", "idx": 140}
{"project": "BWA", "commit_id": "228_BWA_0.7.17_main.c_main.c", "target": 0, "func": "int main(int argc, char *argv[])\n{\n\textern char *bwa_pg;\n\tint i, ret;\n\tdouble t_real;\n\tkstring_t pg = {0,0,0};\n\tt_real = realtime();\n\tksprintf(&pg, \"@PG\\tID:bwa\\tPN:bwa\\tVN:%s\\tCL:%s\", PACKAGE_VERSION, argv[0]);\n\tfor (i = 1; i < argc; ++i) ksprintf(&pg, \" %s\", argv[i]);\n\tbwa_pg = pg.s;\n\tif (argc < 2) return usage();\n\tif (strcmp(argv[1], \"fa2pac\") == 0) ret = bwa_fa2pac(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"pac2bwt\") == 0) ret = bwa_pac2bwt(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"pac2bwtgen\") == 0) ret = bwt_bwtgen_main(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"bwtupdate\") == 0) ret = bwa_bwtupdate(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"bwt2sa\") == 0) ret = bwa_bwt2sa(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"index\") == 0) ret = bwa_index(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"aln\") == 0) ret = bwa_aln(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"samse\") == 0) ret = bwa_sai2sam_se(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"sampe\") == 0) ret = bwa_sai2sam_pe(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"bwtsw2\") == 0) ret = bwa_bwtsw2(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"dbwtsw\") == 0) ret = bwa_bwtsw2(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"bwasw\") == 0) ret = bwa_bwtsw2(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"fastmap\") == 0) ret = main_fastmap(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"mem\") == 0) ret = main_mem(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"shm\") == 0) ret = main_shm(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"pemerge\") == 0) ret = main_pemerge(argc-1, argv+1);\n\telse if (strcmp(argv[1], \"maxk\") == 0) ret = main_maxk(argc-1, argv+1);\n\telse {\n\t\tfprintf(stderr, \"[main] unrecognized command '%s'\\n\", argv[1]);\n\t\treturn 1;\n\t}\n\terr_fflush(stdout);\n\terr_fclose(stdout);\n\tif (ret == 0) {\n\t\tfprintf(stderr, \"[%s] Version: %s\\n\", __func__, PACKAGE_VERSION);\n\t\tfprintf(stderr, \"[%s] CMD:\", __func__);\n\t\tfor (i = 0; i < argc; ++i)\n\t\t\tfprintf(stderr, \" %s\", argv[i]);\n\t\tfprintf(stderr, \"\\n[%s] Real time: %.3f sec; CPU: %.3f sec\\n\", __func__, realtime() - t_real, cputime());\n\t}\n\tfree(bwa_pg);\n\treturn ret;\n}", "idx": 141}
{"project": "BWA", "commit_id": "229_BWA_0.7.17_malloc_wrap.c_wrap_calloc.c", "target": 0, "func": "void *wrap_calloc(size_t nmemb, size_t size,\n\t\t\t\t  const char *file, unsigned int line, const char *func) {\n\tvoid *p = calloc(nmemb, size);\n\tif (NULL == p) {\n\t\tfprintf(stderr,\n\t\t\t\t\"[%s] Failed to allocate %zu bytes at %s line %u: %s\\n\",\n\t\t\t\tfunc, nmemb * size, file, line, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn p;\n}", "idx": 142}
{"project": "BWA", "commit_id": "22_BWA_0.7.17_bntseq.c_bns_get_seq.c", "target": 0, "func": "uint8_t *bns_get_seq(int64_t l_pac, const uint8_t *pac, int64_t beg, int64_t end, int64_t *len)\n{\n\tuint8_t *seq = 0;\n\tif (end < beg) end ^= beg, beg ^= end, end ^= beg; // if end is smaller, swap\n\tif (end > l_pac<<1) end = l_pac<<1;\n\tif (beg < 0) beg = 0;\n\tif (beg >= l_pac || end <= l_pac) {\n\t\tint64_t k, l = 0;\n\t\t*len = end - beg;\n\t\tseq = malloc(end - beg);\n\t\tif (beg >= l_pac) { // reverse strand\n\t\t\tint64_t beg_f = (l_pac<<1) - 1 - end;\n\t\t\tint64_t end_f = (l_pac<<1) - 1 - beg;\n\t\t\tfor (k = end_f; k > beg_f; --k)\n\t\t\t\tseq[l++] = 3 - _get_pac(pac, k);\n\t\t} else { // forward strand\n\t\t\tfor (k = beg; k < end; ++k)\n\t\t\t\tseq[l++] = _get_pac(pac, k);\n\t\t}\n\t} else *len = 0; // if bridging the forward-reverse boundary, return nothing\n\treturn seq;\n}", "idx": 143}
{"project": "BWA", "commit_id": "230_BWA_0.7.17_malloc_wrap.c_wrap_malloc.c", "target": 0, "func": "void *wrap_malloc(size_t size,\n\t\t\t\t  const char *file, unsigned int line, const char *func) {\n\tvoid *p = malloc(size);\n\tif (NULL == p) {\n\t\tfprintf(stderr,\n\t\t\t\t\"[%s] Failed to allocate %zu bytes at %s line %u: %s\\n\",\n\t\t\t\tfunc, size, file, line, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn p;\n}", "idx": 144}
{"project": "BWA", "commit_id": "231_BWA_0.7.17_malloc_wrap.c_wrap_realloc.c", "target": 0, "func": "void *wrap_realloc(void *ptr, size_t size,\n\t\t\t\t   const char *file, unsigned int line, const char *func) {\n\tvoid *p = realloc(ptr, size);\n\tif (NULL == p) {\n\t\tfprintf(stderr,\n\t\t\t\t\"[%s] Failed to allocate %zu bytes at %s line %u: %s\\n\",\n\t\t\t\tfunc, size, file, line, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn p;\n}", "idx": 145}
{"project": "BWA", "commit_id": "232_BWA_0.7.17_malloc_wrap.c_wrap_strdup.c", "target": 0, "func": "char *wrap_strdup(const char *s,\n\t\t\t\t  const char *file, unsigned int line, const char *func) {\n\tchar *p = strdup(s);\n\tif (NULL == p) {\n\t\tfprintf(stderr,\n\t\t\t\t\"[%s] Failed to allocate %zu bytes at %s line %u: %s\\n\",\n\t\t\t\tfunc, strlen(s), file, line, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn p;\n}", "idx": 146}
{"project": "BWA", "commit_id": "233_BWA_0.7.17_pemerge.c_pem_opt_init.c", "target": 0, "func": "pem_opt_t *pem_opt_init()\n{\n\tpem_opt_t *opt;\n\topt = calloc(1, sizeof(pem_opt_t));\n\topt->a = 5; opt->b = 4; opt->q = 2, opt->r = 17; opt->w = 20;\n\topt->T = opt->a * 10;\n\topt->q_def = 20;\n\topt->q_thres = 70;\n\topt->chunk_size = 10000000;\n\topt->n_threads = 1;\n\topt->flag = 3;\n\tbwa_fill_scmat(opt->a, opt->b, opt->mat);\n\treturn opt;\n}", "idx": 147}
{"project": "BWA", "commit_id": "234_BWA_0.7.17_pemerge.c_bwa_pemerge.c", "target": 0, "func": "int bwa_pemerge(const pem_opt_t *opt, bseq1_t x[2])\n{\n\tuint8_t *s[2], *q[2], *seq, *qual;\n\tint i, xtra, l, l_seq, sum_q, ret = 0;\n\tkswr_t r;\n\n\ts[0] = malloc(x[0].l_seq); q[0] = malloc(x[0].l_seq);\n\ts[1] = malloc(x[1].l_seq); q[1] = malloc(x[1].l_seq);\n\tfor (i = 0; i < x[0].l_seq; ++i) {\n\t\tint c = x[0].seq[i];\n\t\ts[0][i] = c < 0 || c > 127? 4 : c <= 4? c : nst_nt4_table[c];\n\t\tq[0][i] = x[0].qual? x[0].qual[i] - 33 : opt->q_def;\n\t}\n\tfor (i = 0; i < x[1].l_seq; ++i) {\n\t\tint c = x[1].seq[x[1].l_seq - 1 - i];\n\t\tc = c < 0 || c > 127? 4 : c < 4? c : nst_nt4_table[c];\n\t\ts[1][i] = c < 4? 3 - c : 4;\n\t\tq[1][i] = x[1].qual? x[1].qual[x[1].l_seq - 1 - i] - 33 : opt->q_def;\n\t}\n\n\txtra = KSW_XSTART | KSW_XSUBO;\n\tr = ksw_align(x[1].l_seq, s[1], x[0].l_seq, s[0], 5, opt->mat, opt->q, opt->r, xtra, 0);\n\t++r.qe; ++r.te; // change to the half-close-half-open coordinates\n\n\tif (r.score < opt->T) { ret = -1; goto pem_ret; } // poor alignment\n\tif (r.tb < r.qb) { ret = -2; goto pem_ret; } // no enough space for the left end\n\tif (x[0].l_seq - r.te > x[1].l_seq - r.qe) { ret = -3; goto pem_ret; } // no enough space for the right end\n\tif ((double)r.score2 / r.score >= MAX_SCORE_RATIO) { ret = -4; goto pem_ret; } // the second best score is too large\n\tif (r.qe - r.qb != r.te - r.tb) { ret = -5; goto pem_ret; } // we do not allow gaps\n\n\t{ // test tandem match; O(n^2)\n\t\tint max_m, max_m2, min_l, max_l, max_l2;\n\t\tmax_m = max_m2 = 0; max_l = max_l2 = 0;\n\t\tmin_l = x[0].l_seq < x[1].l_seq? x[0].l_seq : x[1].l_seq;\n\t\tfor (l = 1; l < min_l; ++l) {\n\t\t\tint m = 0, o = x[0].l_seq - l;\n\t\t\tuint8_t *s0o = &s[0][o], *s1 = s[1];\n\t\t\tfor (i = 0; i < l; ++i) // TODO: in principle, this can be done with SSE2. It is the bottleneck!\n\t\t\t\tm += opt->mat[(s1[i]<<2) + s1[i] + s0o[i]]; // equivalent to s[1][i]*5 + s[0][o+i]\n\t\t\tif (m > max_m) max_m2 = max_m, max_m = m, max_l2 = max_l, max_l = l;\n\t\t\telse if (m > max_m2) max_m2 = m, max_l2 = l;\n\t\t}\n\t\tif (max_m < opt->T || max_l != x[0].l_seq - (r.tb - r.qb)) { ret = -6; goto pem_ret; }\n\t\tif (max_l2 < max_l && max_m2 >= opt->T && (double)(max_m2 + (max_l - max_l2) * opt->a) / max_m >= MAX_SCORE_RATIO) {\n\t\t\tret = -7; goto pem_ret;\n\t\t}\n\t\tif (max_l2 > max_l && (double)max_m2 / max_m >= MAX_SCORE_RATIO) { ret = -7; goto pem_ret; }\n\t}\n\n\tl = x[0].l_seq - (r.tb - r.qb); // length to merge\n\tl_seq = x[0].l_seq + x[1].l_seq - l;\n\tseq = malloc(l_seq + 1);\n\tqual = malloc(l_seq + 1);\n\tmemcpy(seq,  s[0], x[0].l_seq); memcpy(seq  + x[0].l_seq, &s[1][l], x[1].l_seq - l);\n\tmemcpy(qual, q[0], x[0].l_seq); memcpy(qual + x[0].l_seq, &q[1][l], x[1].l_seq - l);\n\tfor (i = 0, sum_q = 0; i < l; ++i) {\n\t\tint k = x[0].l_seq - l + i;\n\t\tif (s[0][k] == 4) { // ambiguous\n\t\t\tseq[k]  = s[1][i];\n\t\t\tqual[k] = q[1][i];\n\t\t} else if (s[1][i] == 4) { // do nothing\n\t\t} else if (s[0][k] == s[1][i]) {\n\t\t\tqual[k] = qual[k] > q[1][i]? qual[k] : q[1][i];\n\t\t} else { // s[0][k] != s[1][i] and neither is N\n\t\t\tint qq = q[0][k] < q[1][i]? q[0][k] : q[1][i];\n\t\t\tsum_q += qq >= 3? qq<<1 : 1;\n\t\t\tseq[k]  = q[0][k] > q[1][i]? s[0][k] : s[1][i];\n\t\t\tqual[k] = abs((int)q[0][k] - (int)q[1][i]);\n\t\t}\n\t}\n\tif (sum_q>>1 > opt->q_thres) { // too many mismatches\n\t\tfree(seq); free(qual);\n\t\tret = -8; goto pem_ret;\n\t}\n\n\tfor (i = 0; i < l_seq; ++i) seq[i] = \"ACGTN\"[(int)seq[i]], qual[i] += 33;\n\tseq[l_seq] = qual[l_seq] = 0;\n\n\tfree(x[1].name); free(x[1].seq); free(x[1].qual); free(x[1].comment);\n\tmemset(&x[1], 0, sizeof(bseq1_t));\n\tfree(x[0].seq); free(x[0].qual);\n\tx[0].l_seq = l_seq; x[0].seq = (char*)seq; x[0].qual = (char*)qual;\n\npem_ret:\n\tfree(s[0]); free(s[1]); free(q[0]); free(q[1]);\n\treturn ret;\n}", "idx": 148}
{"project": "BWA", "commit_id": "235_BWA_0.7.17_pemerge.c_print_bseq.c", "target": 0, "func": "static inline void print_bseq(const bseq1_t *s, int rn)\n{\n\terr_putchar(s->qual? '@' : '>');\n\terr_fputs(s->name, stdout);\n\tif (rn == 1 || rn == 2) {\n\t\terr_putchar('/'); err_putchar('0' + rn); err_putchar('\\n');\n\t} else err_puts(\" merged\");\n\terr_puts(s->seq);\n\tif (s->qual) {\n\t\terr_puts(\"+\"); err_puts(s->qual);\n\t}\n}", "idx": 149}
{"project": "BWA", "commit_id": "236_BWA_0.7.17_pemerge.c_worker.c", "target": 0, "func": "void *worker(void *data)\n{\n\tworker_t *w = (worker_t*)data;\n\tint i;\n\tfor (i = w->start; i < w->n>>1; i += w->opt->n_threads)\n\t\t++w->cnt[-bwa_pemerge(w->opt, &w->seqs[i<<1])];\n\treturn 0;\n}", "idx": 150}
{"project": "BWA", "commit_id": "237_BWA_0.7.17_pemerge.c_main_pemerge.c", "target": 0, "func": "int main_pemerge(int argc, char *argv[])\n{\n\tint c, flag = 0, i, n, min_ovlp = 10;\n\tint64_t cnt[MAX_ERR+1];\n\tbseq1_t *bseq;\n\tgzFile fp, fp2 = 0;\n\tkseq_t *ks, *ks2 = 0;\n\tpem_opt_t *opt;\n\n\topt = pem_opt_init();\n\twhile ((c = getopt(argc, argv, \"muQ:t:T:\")) >= 0) {\n\t\tif (c == 'm') flag |= 1;\n\t\telse if (c == 'u') flag |= 2;\n\t\telse if (c == 'Q') opt->q_thres = atoi(optarg);\n\t\telse if (c == 't') opt->n_threads = atoi(optarg);\n\t\telse if (c == 'T') min_ovlp = atoi(optarg);\n\t\telse return 1;\n\t}\n\tif (flag == 0) flag = 3;\n\topt->flag = flag;\n\topt->T = opt->a * min_ovlp;\n\n\tif (optind == argc) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Usage:   bwa pemerge [-mu] <read1.fq> [read2.fq]\\n\\n\");\n\t\tfprintf(stderr, \"Options: -m       output merged reads only\\n\");\n\t\tfprintf(stderr, \"         -u       output unmerged reads only\\n\");\n\t\tfprintf(stderr, \"         -t INT   number of threads [%d]\\n\", opt->n_threads);\n\t\tfprintf(stderr, \"         -T INT   minimum end overlap [%d]\\n\", min_ovlp);\n\t\tfprintf(stderr, \"         -Q INT   max sum of errors [%d]\\n\", opt->q_thres);\n\t\tfprintf(stderr, \"\\n\");\n\t\tfree(opt);\n\t\treturn 1;\n\t}\n\n\tfp = strcmp(argv[optind], \"-\")? gzopen(argv[optind], \"r\") : gzdopen(fileno(stdin), \"r\");\n\tif (NULL == fp) {\n\t\tfprintf(stderr, \"Couldn't open %s : %s\\n\",\n\t\t\t\tstrcmp(argv[optind], \"-\") ? argv[optind] : \"stdin\",\n\t\t\t\terrno ? strerror(errno) : \"Out of memory\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tks = kseq_init(fp);\n\tif (optind + 1 < argc) {\n\t\tfp2 = strcmp(argv[optind+1], \"-\")? gzopen(argv[optind+1], \"r\") : gzdopen(fileno(stdin), \"r\");\n\t\tif (NULL == fp) {\n\t\t\tfprintf(stderr, \"Couldn't open %s : %s\\n\",\n\t\t\t\t\tstrcmp(argv[optind+1], \"-\") ? argv[optind+1] : \"stdin\",\n\t\t\t\t\terrno ? strerror(errno) : \"Out of memory\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tks2 = kseq_init(fp2);\n\t}\n\n\tmemset(cnt, 0, 8 * (MAX_ERR+1));\n\twhile ((bseq = bseq_read(opt->n_threads * opt->chunk_size, &n, ks, ks2)) != 0) {\n\t\tprocess_seqs(opt, n, bseq, cnt);\n\t\tfree(bseq);\n\t}\n\n\tfprintf(stderr, \"%12ld %s\\n\", (long)cnt[0], err_msg[0]);\n\tfor (i = 1; i <= MAX_ERR; ++i)\n\t\tfprintf(stderr, \"%12ld %s\\n\", (long)cnt[i], err_msg[i]);\n\tkseq_destroy(ks);\n\terr_gzclose(fp);\n\tif (ks2) {\n\t\tkseq_destroy(ks2);\n\t\terr_gzclose(fp2);\n\t}\n\tfree(opt);\n\n\terr_fflush(stdout);\n\n\treturn 0;\n}", "idx": 151}
{"project": "BWA", "commit_id": "238_BWA_0.7.17_QSufSort.c_QSufSortGenerateSaFromInverse.c", "target": 0, "func": "void QSufSortGenerateSaFromInverse(const qsint_t* V, qsint_t* __restrict I, const qsint_t numChar)\n{\n\tqsint_t i;\n\tfor (i=0; i<=numChar; i++)\n\t\tI[V[i]] = i + 1;\n}", "idx": 152}
{"project": "BWA", "commit_id": "239_BWA_0.7.17_QSufSort.c_QSufSortChoosePivot.c", "target": 0, "func": "static qsint_t QSufSortChoosePivot(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t lowestPos, \n\t\t\t\t\t\t\t   const qsint_t highestPos, const qsint_t numSortedChar) {\n\n\tqsint_t m;\n\tqsint_t keyl, keym, keyn;\n\tqsint_t key1, key2, key3;\n\tqsint_t s;\n\tqsint_t numItem;\n\n\tnumItem = highestPos - lowestPos + 1;\n\n\tm = lowestPos + numItem / 2;\n\n\ts = numItem / 8;\n\tkey1 = KEY(V, I, lowestPos, numSortedChar);\n\tkey2 = KEY(V, I, lowestPos+s, numSortedChar);\n\tkey3 = KEY(V, I, lowestPos+2*s, numSortedChar);\n\tkeyl = med3(key1, key2, key3);\n\tkey1 = KEY(V, I, m-s, numSortedChar);\n\tkey2 = KEY(V, I, m, numSortedChar);\n\tkey3 = KEY(V, I, m+s, numSortedChar);\n\tkeym = med3(key1, key2, key3);\n\tkey1 = KEY(V, I, highestPos-2*s, numSortedChar);\n\tkey2 = KEY(V, I, highestPos-s, numSortedChar);\n\tkey3 = KEY(V, I, highestPos, numSortedChar);\n\tkeyn = med3(key1, key2, key3);\n\n\treturn med3(keyl, keym, keyn);\n\n\n}", "idx": 153}
{"project": "BWA", "commit_id": "23_BWA_0.7.17_bntseq.c_bns_fetch_seq.c", "target": 0, "func": "uint8_t *bns_fetch_seq(const bntseq_t *bns, const uint8_t *pac, int64_t *beg, int64_t mid, int64_t *end, int *rid)\n{\n\tint64_t far_beg, far_end, len;\n\tint is_rev;\n\tuint8_t *seq;\n\n\tif (*end < *beg) *end ^= *beg, *beg ^= *end, *end ^= *beg; // if end is smaller, swap\n\tassert(*beg <= mid && mid < *end);\n\t*rid = bns_pos2rid(bns, bns_depos(bns, mid, &is_rev));\n\tfar_beg = bns->anns[*rid].offset;\n\tfar_end = far_beg + bns->anns[*rid].len;\n\tif (is_rev) { // flip to the reverse strand\n\t\tint64_t tmp = far_beg;\n\t\tfar_beg = (bns->l_pac<<1) - far_end;\n\t\tfar_end = (bns->l_pac<<1) - tmp;\n\t}\n\t*beg = *beg > far_beg? *beg : far_beg;\n\t*end = *end < far_end? *end : far_end;\n\tseq = bns_get_seq(bns->l_pac, pac, *beg, *end, &len);\n\tif (seq == 0 || *end - *beg != len) {\n\t\tfprintf(stderr, \"[E::%s] begin=%ld, mid=%ld, end=%ld, len=%ld, seq=%p, rid=%d, far_beg=%ld, far_end=%ld\\n\",\n\t\t\t\t__func__, (long)*beg, (long)mid, (long)*end, (long)len, seq, *rid, (long)far_beg, (long)far_end);\n\t}\n\tassert(seq && *end - *beg == len); // assertion failure should never happen\n\treturn seq;\n}", "idx": 154}
{"project": "BWA", "commit_id": "240_BWA_0.7.17_QSufSort.c_QSufSortInsertSortSplit.c", "target": 0, "func": "static void QSufSortInsertSortSplit(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t lowestPos, \n\t\t\t\t\t\t\t\t\tconst qsint_t highestPos, const qsint_t numSortedChar)\n{\n\tqsint_t i, j;\n\tqsint_t tmpKey, tmpPos;\n\tqsint_t numItem;\n\tqsint_t key[INSERT_SORT_NUM_ITEM], pos[INSERT_SORT_NUM_ITEM];\n\tqsint_t negativeSortedLength;\n\tqsint_t groupNum;\n\n\tnumItem = highestPos - lowestPos + 1;\n\n\tfor (i=0; i<numItem; i++) {\n\t\tpos[i] = I[lowestPos + i];\n\t\tkey[i] = V[pos[i] + numSortedChar];\n\t}\n\n\tfor (i=1; i<numItem; i++) {\n\t\ttmpKey = key[i];\n\t\ttmpPos = pos[i];\n\t\tfor (j=i; j>0 && key[j-1] > tmpKey; j--) {\n\t\t\tkey[j] = key[j-1];\n\t\t\tpos[j] = pos[j-1];\n\t\t}\n\t\tkey[j] = tmpKey;\n\t\tpos[j] = tmpPos;\n\t}\n\n\tnegativeSortedLength = -1;\n\n\ti = numItem - 1;\n\tgroupNum = highestPos;\n\twhile (i > 0) {\n\t\tI[i+lowestPos] = pos[i];\n\t\tV[I[i+lowestPos]] = groupNum;\n\t\tif (key[i-1] == key[i]) {\n\t\t\tnegativeSortedLength = 0;\n\t\t} else {\n\t\t\tif (negativeSortedLength < 0)\n\t\t\t\tI[i+lowestPos] = negativeSortedLength;\n\t\t\tgroupNum = i + lowestPos - 1;\n\t\t\tnegativeSortedLength--;\n\t\t}\n\t\ti--;\n\t}\n\n\tI[lowestPos] = pos[0];\n\tV[I[lowestPos]] = groupNum;\n\tif (negativeSortedLength < 0)\n\t\tI[lowestPos] = negativeSortedLength;\n}", "idx": 155}
{"project": "BWA", "commit_id": "241_BWA_0.7.17_QSufSort.c_QSufSortTransform.c", "target": 0, "func": "static qsint_t QSufSortTransform(qsint_t* __restrict V, qsint_t* __restrict I, const qsint_t numChar, const qsint_t largestInputSymbol, \n\t\t\t\t\t\t\t const qsint_t smallestInputSymbol, const qsint_t maxNewAlphabetSize, qsint_t *numSymbolAggregated)\n{\n\tqsint_t c, i, j;\n\tqsint_t a;\t// numSymbolAggregated\n\tqsint_t mask;\n\tqsint_t minSymbolInChunk = 0, maxSymbolInChunk = 0;\n\tqsint_t newAlphabetSize;\n\tqsint_t maxNumInputSymbol, maxNumBit, maxSymbol;\n\n\tmaxNumInputSymbol = largestInputSymbol - smallestInputSymbol + 1;\n\n\tfor (maxNumBit = 0, i = maxNumInputSymbol; i; i >>= 1) ++maxNumBit;\n\tmaxSymbol = QSINT_MAX >> maxNumBit;\n\n\tc = maxNumInputSymbol;\n\tfor (a = 0; a < numChar && maxSymbolInChunk <= maxSymbol && c <= maxNewAlphabetSize; a++) {\n\t\tminSymbolInChunk = (minSymbolInChunk << maxNumBit) | (V[a] - smallestInputSymbol + 1);\n\t\tmaxSymbolInChunk = c;\n\t\tc = (maxSymbolInChunk << maxNumBit) | maxNumInputSymbol;\n\t}\n\n\tmask = (1 << (a-1) * maxNumBit) - 1;\t/* mask masks off top old symbol from chunk.*/\n\tV[numChar] = smallestInputSymbol - 1;\t/* emulate zero terminator.*/\n\n\t/* bucketing possible, compact alphabet.*/\n\tfor (i=0; i<=maxSymbolInChunk; i++)\n\t\tI[i] = 0;\t/* zero transformation table.*/\n\tc = minSymbolInChunk;\n\tfor (i=a; i<=numChar; i++) {\n\t\tI[c] = 1;\t\t\t/* mark used chunk symbol.*/\n\t\tc = ((c & mask) << maxNumBit) | (V[i] - smallestInputSymbol + 1);\t/* shift in next old symbol in chunk.*/\n\t}\n\tfor (i=1; i<a; i++) {\t/* handle last r-1 positions.*/\n\t\tI[c] = 1;\t\t\t/* mark used chunk symbol.*/\n\t\tc = (c & mask) << maxNumBit;\t/* shift in next old symbol in chunk.*/\n\t}\n\tnewAlphabetSize = 1;\n\tfor (i=0; i<=maxSymbolInChunk; i++) {\n\t\tif (I[i]) {\n\t\t\tI[i] = newAlphabetSize;\n\t\t\tnewAlphabetSize++;\n\t\t}\n\t}\n\tc = minSymbolInChunk;\n\tfor (i=0, j=a; j<=numChar; i++, j++) {\n\t\tV[i] = I[c];\t\t\t\t\t\t/* transform to new alphabet.*/\n\t\tc = ((c & mask) << maxNumBit) | (V[j] - smallestInputSymbol + 1);\t/* shift in next old symbol in chunk.*/\n\t}\n\tfor (; i<numChar; i++) {\t/* handle last a-1 positions.*/\n\t\tV[i] = I[c];\t\t\t/* transform to new alphabet.*/\n\t\tc = (c & mask) << maxNumBit;\t/* shift right-end zero in chunk.*/\n\t}\n\n\tV[numChar] = 0;\t\t/* end-of-string symbol is zero.*/\n\n    *numSymbolAggregated = a;\n\treturn newAlphabetSize;\n}", "idx": 156}
{"project": "BWA", "commit_id": "242_BWA_0.7.17_rle.c_rle_insert.c", "target": 0, "func": "int rle_insert(uint8_t *block, int64_t x, int a, int64_t rl, int64_t cnt[6], const int64_t ec[6])\n{\n\tint beg = 0;\n\tint64_t bc[6];\n\tmemset(bc, 0, 48);\n\treturn rle_insert_cached(block, x, a, rl, cnt, ec, &beg, bc);\n}", "idx": 157}
{"project": "BWA", "commit_id": "243_BWA_0.7.17_rle.c_rle_split.c", "target": 0, "func": "void rle_split(uint8_t *block, uint8_t *new_block)\n{\n\tint n = *(uint16_t*)block;\n\tuint8_t *end = block + 2 + n, *q = block + 2 + (n>>1);\n\twhile (*q>>6 == 2) --q;\n\tmemcpy(new_block + 2, q, end - q);\n\t*(uint16_t*)new_block = end - q;\n\t*(uint16_t*)block = q - block - 2;\n}", "idx": 158}
{"project": "BWA", "commit_id": "244_BWA_0.7.17_rle.c_rle_count.c", "target": 0, "func": "void rle_count(const uint8_t *block, int64_t cnt[6])\n{\n\tconst uint8_t *q = block + 2, *end = q + *(uint16_t*)block;\n\twhile (q < end) {\n\t\tint c;\n\t\tint64_t l;\n\t\trle_dec1(q, c, l);\n\t\tcnt[c] += l;\n\t}\n}", "idx": 159}
{"project": "BWA", "commit_id": "245_BWA_0.7.17_rle.c_rle_print.c", "target": 0, "func": "void rle_print(const uint8_t *block, int expand)\n{\n\tconst uint16_t *p = (const uint16_t*)block;\n\tconst uint8_t *q = block + 2, *end = block + 2 + *p;\n\twhile (q < end) {\n\t\tint c;\n\t\tint64_t l, x;\n\t\trle_dec1(q, c, l);\n\t\tif (expand) for (x = 0; x < l; ++x) putchar(\"$ACGTN\"[c]);\n\t\telse printf(\"%c%ld\", \"$ACGTN\"[c], (long)l);\n\t}\n\tputchar('\\n');\n}", "idx": 160}
{"project": "BWA", "commit_id": "246_BWA_0.7.17_rope.c_mp_init.c", "target": 0, "func": "static mempool_t *mp_init(int size)\n{\n\tmempool_t *mp;\n\tmp = calloc(1, sizeof(mempool_t));\n\tmp->size = size;\n\tmp->i = mp->n_elems = MP_CHUNK_SIZE / size;\n\tmp->top = -1;\n\treturn mp;\n}", "idx": 161}
{"project": "BWA", "commit_id": "247_BWA_0.7.17_rope.c_mp_destroy.c", "target": 0, "func": "static void mp_destroy(mempool_t *mp)\n{\n\tint64_t i;\n\tfor (i = 0; i <= mp->top; ++i) free(mp->mem[i]);\n\tfree(mp->mem); free(mp);\n}", "idx": 162}
{"project": "BWA", "commit_id": "248_BWA_0.7.17_rope.c_mp_alloc.c", "target": 0, "func": "static inline void *mp_alloc(mempool_t *mp)\n{\n\tif (mp->i == mp->n_elems) {\n\t\tif (++mp->top == mp->max) {\n\t\t\tmp->max = mp->max? mp->max<<1 : 1;\n\t\t\tmp->mem = realloc(mp->mem, sizeof(void*) * mp->max);\n\t\t}\n\t\tmp->mem[mp->top] = calloc(mp->n_elems, mp->size);\n\t\tmp->i = 0;\n\t}\n\treturn mp->mem[mp->top] + (mp->i++) * mp->size;\n}", "idx": 163}
{"project": "BWA", "commit_id": "249_BWA_0.7.17_rope.c_rope_init.c", "target": 0, "func": "rope_t *rope_init(int max_nodes, int block_len)\n{\n\trope_t *rope;\n\trope = calloc(1, sizeof(rope_t));\n\tif (block_len < 32) block_len = 32;\n\trope->max_nodes = (max_nodes+ 1)>>1<<1;\n\trope->block_len = (block_len + 7) >> 3 << 3;\n\trope->node = mp_init(sizeof(rpnode_t) * rope->max_nodes);\n\trope->leaf = mp_init(rope->block_len);\n\trope->root = mp_alloc(rope->node);\n\trope->root->n = 1;\n\trope->root->is_bottom = 1;\n\trope->root->p = mp_alloc(rope->leaf);\n\treturn rope;\n}", "idx": 164}
{"project": "BWA", "commit_id": "24_BWA_0.7.17_bwa.c_trim_readno.c", "target": 0, "func": "static inline void trim_readno(kstring_t *s)\n{\n\tif (s->l > 2 && s->s[s->l-2] == '/' && isdigit(s->s[s->l-1]))\n\t\ts->l -= 2, s->s[s->l] = 0;\n}", "idx": 165}
{"project": "BWA", "commit_id": "250_BWA_0.7.17_rope.c_rope_destroy.c", "target": 0, "func": "void rope_destroy(rope_t *rope)\n{\n\tmp_destroy(rope->node);\n\tmp_destroy(rope->leaf);\n\tfree(rope);\n}", "idx": 166}
{"project": "BWA", "commit_id": "251_BWA_0.7.17_rope.c_split_node.c", "target": 0, "func": "static inline rpnode_t *split_node(rope_t *rope, rpnode_t *u, rpnode_t *v)\n{ // split $v's child. $u is the first node in the bucket. $v and $u are in the same bucket. IMPORTANT: there is always enough room in $u\n\tint j, i = v - u;\n\trpnode_t *w; // $w is the sibling of $v\n\tif (u == 0) { // only happens at the root; add a new root\n\t\tu = v = mp_alloc(rope->node);\n\t\tv->n = 1; v->p = rope->root; // the new root has the old root as the only child\n\t\tmemcpy(v->c, rope->c, 48);\n\t\tfor (j = 0; j < 6; ++j) v->l += v->c[j];\n\t\trope->root = v;\n\t}\n\tif (i != u->n - 1) // then make room for a new node\n\t\tmemmove(v + 2, v + 1, sizeof(rpnode_t) * (u->n - i - 1));\n\t++u->n; w = v + 1;\n\tmemset(w, 0, sizeof(rpnode_t));\n\tw->p = mp_alloc(u->is_bottom? rope->leaf : rope->node);\n\tif (u->is_bottom) { // we are at the bottom level; $v->p is a string instead of a node\n\t\tuint8_t *p = (uint8_t*)v->p, *q = (uint8_t*)w->p;\n\t\trle_split(p, q);\n\t\trle_count(q, w->c);\n\t} else { // $v->p is a node, not a string\n\t\trpnode_t *p = v->p, *q = w->p; // $v and $w are siblings and thus $p and $q are cousins\n\t\tp->n -= rope->max_nodes>>1;\n\t\tmemcpy(q, p + p->n, sizeof(rpnode_t) * (rope->max_nodes>>1));\n\t\tq->n = rope->max_nodes>>1; // NB: this line must below memcpy() as $q->n and $q->is_bottom are modified by memcpy()\n\t\tq->is_bottom = p->is_bottom;\n\t\tfor (i = 0; i < q->n; ++i)\n\t\t\tfor (j = 0; j < 6; ++j)\n\t\t\t\tw->c[j] += q[i].c[j];\n\t}\n\tfor (j = 0; j < 6; ++j) // compute $w->l and update $v->c\n\t\tw->l += w->c[j], v->c[j] -= w->c[j];\n\tv->l -= w->l; // update $v->c\n\treturn v;\n}", "idx": 167}
{"project": "BWA", "commit_id": "252_BWA_0.7.17_rope.c_rope_insert_run.c", "target": 0, "func": "int64_t rope_insert_run(rope_t *rope, int64_t x, int a, int64_t rl, rpcache_t *cache)\n{ // insert $a after $x symbols in $rope and the returns rank(a, x)\n\trpnode_t *u = 0, *v = 0, *p = rope->root; // $v is the parent of $p; $u and $v are at the same level and $u is the first node in the bucket\n\tint64_t y = 0, z = 0, cnt[6];\n\tint n_runs;\n\tdo { // top-down update. Searching and node splitting are done together in one pass.\n\t\tif (p->n == rope->max_nodes) { // node is full; split\n\t\t\tv = split_node(rope, u, v); // $v points to the parent of $p; when a new root is added, $v points to the root\n\t\t\tif (y + v->l < x) // if $v is not long enough after the split, we need to move both $p and its parent $v\n\t\t\t\ty += v->l, z += v->c[a], ++v, p = v->p;\n\t\t}\n\t\tu = p;\n\t\tif (v && x - y > v->l>>1) { // then search backwardly for the right node to descend\n\t\t\tp += p->n - 1; y += v->l; z += v->c[a];\n\t\t\tfor (; y >= x; --p) y -= p->l, z -= p->c[a];\n\t\t\t++p;\n\t\t} else for (; y + p->l < x; ++p) y += p->l, z += p->c[a]; // then search forwardly\n\t\tassert(p - u < u->n);\n\t\tif (v) v->c[a] += rl, v->l += rl; // we should not change p->c[a] because this may cause troubles when p's child is split\n\t\tv = p; p = p->p; // descend\n\t} while (!u->is_bottom);\n\trope->c[a] += rl; // $rope->c should be updated after the loop as adding a new root needs the old $rope->c counts\n\tif (cache) {\n\t\tif (cache->p != (uint8_t*)p) memset(cache, 0, sizeof(rpcache_t));\n\t\tn_runs = rle_insert_cached((uint8_t*)p, x - y, a, rl, cnt, v->c, &cache->beg, cache->bc);\n\t\tcache->p = (uint8_t*)p;\n\t} else n_runs = rle_insert((uint8_t*)p, x - y, a, rl, cnt, v->c);\n\tz += cnt[a];\n\tv->c[a] += rl; v->l += rl; // this should be after rle_insert(); otherwise rle_insert() won't work\n\tif (n_runs + RLE_MIN_SPACE > rope->block_len) {\n\t\tsplit_node(rope, u, v);\n\t\tif (cache) memset(cache, 0, sizeof(rpcache_t));\n\t}\n\treturn z;\n}", "idx": 168}
{"project": "BWA", "commit_id": "253_BWA_0.7.17_rope.c_rope_rank2a.c", "target": 0, "func": "void rope_rank2a(const rope_t *rope, int64_t x, int64_t y, int64_t *cx, int64_t *cy)\n{\n\trpnode_t *v;\n\tint64_t rest;\n\tv = rope_count_to_leaf(rope, x, cx, &rest);\n\tif (y < x || cy == 0) {\n\t\trle_rank1a((const uint8_t*)v->p, rest, cx, v->c);\n\t} else if (rest + (y - x) <= v->l) {\n\t\tmemcpy(cy, cx, 48);\n\t\trle_rank2a((const uint8_t*)v->p, rest, rest + (y - x), cx, cy, v->c);\n\t} else {\n\t\trle_rank1a((const uint8_t*)v->p, rest, cx, v->c);\n\t\tv = rope_count_to_leaf(rope, y, cy, &rest);\n\t\trle_rank1a((const uint8_t*)v->p, rest, cy, v->c);\n\t}\n}", "idx": 169}
{"project": "BWA", "commit_id": "254_BWA_0.7.17_rope.c_rope_itr_first.c", "target": 0, "func": "void rope_itr_first(const rope_t *rope, rpitr_t *i)\n{\n\tmemset(i, 0, sizeof(rpitr_t));\n\ti->rope = rope;\n\tfor (i->pa[i->d] = rope->root; !i->pa[i->d]->is_bottom;) // descend to the leftmost leaf\n\t\t++i->d, i->pa[i->d] = i->pa[i->d - 1]->p;\n}", "idx": 170}
{"project": "BWA", "commit_id": "255_BWA_0.7.17_rope.c_rope_itr_next_block.c", "target": 0, "func": "const uint8_t *rope_itr_next_block(rpitr_t *i)\n{\n\tconst uint8_t *ret;\n\tassert(i->d < ROPE_MAX_DEPTH); // a B+ tree should not be that tall\n\tif (i->d < 0) return 0;\n\tret = (uint8_t*)i->pa[i->d][i->ia[i->d]].p;\n\twhile (i->d >= 0 && ++i->ia[i->d] == i->pa[i->d]->n) i->ia[i->d--] = 0; // backtracking\n\tif (i->d >= 0)\n\t\twhile (!i->pa[i->d]->is_bottom) // descend to the leftmost leaf\n\t\t\t++i->d, i->pa[i->d] = i->pa[i->d - 1][i->ia[i->d - 1]].p;\n\treturn ret;\n}", "idx": 171}
{"project": "BWA", "commit_id": "256_BWA_0.7.17_rope.c_rope_dump_node.c", "target": 0, "func": "void rope_dump_node(const rpnode_t *p, FILE *fp)\n{\n\tint16_t i, n = p->n;\n\tuint8_t is_bottom = p->is_bottom;\n\tfwrite(&is_bottom, 1, 1, fp);\n\tfwrite(&n, 2, 1, fp);\n\tif (is_bottom) {\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tfwrite(p[i].c, 8, 6, fp);\n\t\t\tfwrite(p[i].p, 1, *rle_nptr(p[i].p) + 2, fp);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < p->n; ++i)\n\t\t\trope_dump_node(p[i].p, fp);\n\t}\n}", "idx": 172}
{"project": "BWA", "commit_id": "257_BWA_0.7.17_rope.c_rope_dump.c", "target": 0, "func": "void rope_dump(const rope_t *r, FILE *fp)\n{\n\tfwrite(&r->max_nodes, 4, 1, fp);\n\tfwrite(&r->block_len, 4, 1, fp);\n\trope_dump_node(r->root, fp);\n}", "idx": 173}
{"project": "BWA", "commit_id": "258_BWA_0.7.17_rope.c_rope_restore_node.c", "target": 0, "func": "rpnode_t *rope_restore_node(const rope_t *r, FILE *fp, int64_t c[6])\n{\n\tuint8_t is_bottom, a;\n\tint16_t i, n;\n\trpnode_t *p;\n\tfread(&is_bottom, 1, 1, fp);\n\tfread(&n, 2, 1, fp);\n\tp = mp_alloc(r->node);\n\tp->is_bottom = is_bottom, p->n = n;\n\tif (is_bottom) {\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tuint16_t *q;\n\t\t\tp[i].p = mp_alloc(r->leaf);\n\t\t\tq = rle_nptr(p[i].p);\n\t\t\tfread(p[i].c, 8, 6, fp);\n\t\t\tfread(q, 2, 1, fp);\n\t\t\tfread(q + 1, 1, *q, fp);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tp[i].p = rope_restore_node(r, fp, p[i].c);\n\t}\n\tmemset(c, 0, 48);\n\tfor (i = 0; i < n; ++i) {\n\t\tp[i].l = 0;\n\t\tfor (a = 0; a < 6; ++a)\n\t\t\tc[a] += p[i].c[a], p[i].l += p[i].c[a];\n\t}\n\treturn p;\n}", "idx": 174}
{"project": "BWA", "commit_id": "259_BWA_0.7.17_rope.c_rope_restore.c", "target": 0, "func": "rope_t *rope_restore(FILE *fp)\n{\n\trope_t *r;\n\tr = calloc(1, sizeof(rope_t));\n\tfread(&r->max_nodes, 4, 1, fp);\n\tfread(&r->block_len, 4, 1, fp);\n\tr->node = mp_init(sizeof(rpnode_t) * r->max_nodes);\n\tr->leaf = mp_init(r->block_len);\n\tr->root = rope_restore_node(r, fp, r->c);\n\treturn r;\n}", "idx": 175}
{"project": "BWA", "commit_id": "25_BWA_0.7.17_bwa.c_dupkstring.c", "target": 0, "func": "static inline char *dupkstring(const kstring_t *str, int dupempty)\n{\n\tchar *s = (str->l > 0 || dupempty)? malloc(str->l + 1) : NULL;\n\tif (!s) return NULL;\n\n\tmemcpy(s, str->s, str->l);\n\ts[str->l] = '\\0';\n\treturn s;\n}", "idx": 176}
{"project": "BWA", "commit_id": "260_BWA_0.7.17_utils.c_err_xopen_core.c", "target": 0, "func": "FILE *err_xopen_core(const char *func, const char *fn, const char *mode)\n{\n\tFILE *fp = 0;\n\tif (strcmp(fn, \"-\") == 0)\n\t\treturn (strstr(mode, \"r\"))? stdin : stdout;\n\tif ((fp = fopen(fn, mode)) == 0) {\n\t\terr_fatal(func, \"fail to open file '%s' : %s\", fn, strerror(errno));\n\t}\n\treturn fp;\n}", "idx": 177}
{"project": "BWA", "commit_id": "261_BWA_0.7.17_utils.c_err_xreopen_core.c", "target": 0, "func": "FILE *err_xreopen_core(const char *func, const char *fn, const char *mode, FILE *fp)\n{\n\tif (freopen(fn, mode, fp) == 0) {\n\t\terr_fatal(func, \"fail to open file '%s' : %s\", fn, strerror(errno));\n\t}\n\treturn fp;\n}", "idx": 178}
{"project": "BWA", "commit_id": "262_BWA_0.7.17_utils.c_err_xzopen_core.c", "target": 0, "func": "gzFile err_xzopen_core(const char *func, const char *fn, const char *mode)\n{\n\tgzFile fp;\n\tif (strcmp(fn, \"-\") == 0) {\n\t\tfp = gzdopen(fileno((strstr(mode, \"r\"))? stdin : stdout), mode);\n\t\t/* According to zlib.h, this is the only reason gzdopen can fail */\n\t\tif (!fp) err_fatal(func, \"Out of memory\");\n\t\treturn fp;\n\t}\n\tif ((fp = gzopen(fn, mode)) == 0) {\n\t\terr_fatal(func, \"fail to open file '%s' : %s\", fn, errno ? strerror(errno) : \"Out of memory\");\n\t}\n\treturn fp;\n}", "idx": 179}
{"project": "BWA", "commit_id": "263_BWA_0.7.17_utils.c_err_fatal.c", "target": 0, "func": "void err_fatal(const char *header, const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tfprintf(stderr, \"[%s] \", header);\n\tvfprintf(stderr, fmt, args);\n\tfprintf(stderr, \"\\n\");\n\tva_end(args);\n\texit(EXIT_FAILURE);\n}", "idx": 180}
{"project": "BWA", "commit_id": "264_BWA_0.7.17_utils.c_err_fatal_core.c", "target": 0, "func": "void err_fatal_core(const char *header, const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tfprintf(stderr, \"[%s] \", header);\n\tvfprintf(stderr, fmt, args);\n\tfprintf(stderr, \" Abort!\\n\");\n\tva_end(args);\n\tabort();\n}", "idx": 181}
{"project": "BWA", "commit_id": "265_BWA_0.7.17_utils.c__err_fatal_simple.c", "target": 0, "func": "void _err_fatal_simple(const char *func, const char *msg)\n{\n\tfprintf(stderr, \"[%s] %s\\n\", func, msg);\n\texit(EXIT_FAILURE);\n}", "idx": 182}
{"project": "BWA", "commit_id": "266_BWA_0.7.17_utils.c__err_fatal_simple_core.c", "target": 0, "func": "void _err_fatal_simple_core(const char *func, const char *msg)\n{\n\tfprintf(stderr, \"[%s] %s Abort!\\n\", func, msg);\n\tabort();\n}", "idx": 183}
{"project": "BWA", "commit_id": "267_BWA_0.7.17_utils.c_err_fwrite.c", "target": 0, "func": "size_t err_fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)\n{\n\tsize_t ret = fwrite(ptr, size, nmemb, stream);\n\tif (ret != nmemb) \n\t\t_err_fatal_simple(\"fwrite\", strerror(errno));\n\treturn ret;\n}", "idx": 184}
{"project": "BWA", "commit_id": "268_BWA_0.7.17_utils.c_err_fread_noeof.c", "target": 0, "func": "size_t err_fread_noeof(void *ptr, size_t size, size_t nmemb, FILE *stream)\n{\n\tsize_t ret = fread(ptr, size, nmemb, stream);\n\tif (ret != nmemb)\n\t{\n\t\t_err_fatal_simple(\"fread\", ferror(stream) ? strerror(errno) : \"Unexpected end of file\");\n\t}\n\treturn ret;\n}", "idx": 185}
{"project": "BWA", "commit_id": "269_BWA_0.7.17_utils.c_err_gzread.c", "target": 0, "func": "int err_gzread(gzFile file, void *ptr, unsigned int len)\n{\n\tint ret = gzread(file, ptr, len);\n\n\tif (ret < 0)\n\t{\n\t\tint errnum = 0;\n\t\tconst char *msg = gzerror(file, &errnum);\n\t\t_err_fatal_simple(\"gzread\", Z_ERRNO == errnum ? strerror(errno) : msg);\n\t}\n\n\treturn ret;\n}", "idx": 186}
{"project": "BWA", "commit_id": "26_BWA_0.7.17_bwa.c_kseq2bseq1.c", "target": 0, "func": "static inline void kseq2bseq1(const kseq_t *ks, bseq1_t *s)\n{ // TODO: it would be better to allocate one chunk of memory, but probably it does not matter in practice\n\ts->name = dupkstring(&ks->name, 1);\n\ts->comment = dupkstring(&ks->comment, 0);\n\ts->seq = dupkstring(&ks->seq, 1);\n\ts->qual = dupkstring(&ks->qual, 0);\n\ts->l_seq = ks->seq.l;\n}", "idx": 187}
{"project": "BWA", "commit_id": "270_BWA_0.7.17_utils.c_err_fseek.c", "target": 0, "func": "int err_fseek(FILE *stream, long offset, int whence)\n{\n\tint ret = fseek(stream, offset, whence);\n\tif (0 != ret)\n\t{\n\t\t_err_fatal_simple(\"fseek\", strerror(errno));\n\t}\n\treturn ret;\n}", "idx": 188}
{"project": "BWA", "commit_id": "271_BWA_0.7.17_utils.c_err_ftell.c", "target": 0, "func": "long err_ftell(FILE *stream)\n{\n\tlong ret = ftell(stream);\n\tif (-1 == ret)\n\t{\n\t\t_err_fatal_simple(\"ftell\", strerror(errno));\n\t}\n\treturn ret;\n}", "idx": 189}
{"project": "BWA", "commit_id": "272_BWA_0.7.17_utils.c_err_printf.c", "target": 0, "func": "int err_printf(const char *format, ...) \n{\n\tva_list arg;\n\tint done;\n\tva_start(arg, format);\n\tdone = vfprintf(stdout, format, arg);\n\tint saveErrno = errno;\n\tva_end(arg);\n\tif (done < 0) _err_fatal_simple(\"vfprintf(stdout)\", strerror(saveErrno));\n\treturn done;\n}", "idx": 190}
{"project": "BWA", "commit_id": "273_BWA_0.7.17_utils.c_err_fprintf.c", "target": 0, "func": "int err_fprintf(FILE *stream, const char *format, ...) \n{\n\tva_list arg;\n\tint done;\n\tva_start(arg, format);\n\tdone = vfprintf(stream, format, arg);\n\tint saveErrno = errno;\n\tva_end(arg);\n\tif (done < 0) _err_fatal_simple(\"vfprintf\", strerror(saveErrno));\n\treturn done;\n}", "idx": 191}
{"project": "BWA", "commit_id": "274_BWA_0.7.17_utils.c_err_fputc.c", "target": 0, "func": "int err_fputc(int c, FILE *stream)\n{\n\tint ret = putc(c, stream);\n\tif (EOF == ret)\n\t{\n\t\t_err_fatal_simple(\"fputc\", strerror(errno));\n\t}\n\n\treturn ret;\n}", "idx": 192}
{"project": "BWA", "commit_id": "275_BWA_0.7.17_utils.c_err_fputs.c", "target": 0, "func": "int err_fputs(const char *s, FILE *stream)\n{\n\tint ret = fputs(s, stream);\n\tif (EOF == ret)\n\t{\n\t\t_err_fatal_simple(\"fputs\", strerror(errno));\n\t}\n\n\treturn ret;\n}", "idx": 193}
{"project": "BWA", "commit_id": "276_BWA_0.7.17_utils.c_err_puts.c", "target": 0, "func": "int err_puts(const char *s)\n{\n\tint ret = puts(s);\n\tif (EOF == ret)\n\t{\n\t\t_err_fatal_simple(\"puts\", strerror(errno));\n\t}\n\n\treturn ret;\n}", "idx": 194}
{"project": "BWA", "commit_id": "277_BWA_0.7.17_utils.c_err_fflush.c", "target": 0, "func": "int err_fflush(FILE *stream) \n{\n    int ret = fflush(stream);\n    if (ret != 0) _err_fatal_simple(\"fflush\", strerror(errno));\n\n#ifdef FSYNC_ON_FLUSH\n\t/* Calling fflush() ensures that all the data has made it to the\n\t   kernel buffers, but this may not be sufficient for remote filesystems\n\t   (e.g. NFS, lustre) as an error may still occur while the kernel\n\t   is copying the buffered data to the file server.  To be sure of\n\t   catching these errors, we need to call fsync() on the file\n\t   descriptor, but only if it is a regular file.  */\n\t{\n\t\tstruct stat sbuf;\n\t\tif (0 != fstat(fileno(stream), &sbuf))\n\t\t\t_err_fatal_simple(\"fstat\", strerror(errno));\n\t\t\n\t\tif (S_ISREG(sbuf.st_mode))\n\t\t{\n\t\t\tif (0 != fsync(fileno(stream)))\n\t\t\t\t_err_fatal_simple(\"fsync\", strerror(errno));\n\t\t}\n\t}\n#endif\n    return ret;\n}", "idx": 195}
{"project": "BWA", "commit_id": "278_BWA_0.7.17_utils.c_err_fclose.c", "target": 0, "func": "int err_fclose(FILE *stream) \n{\n\tint ret = fclose(stream);\n\tif (ret != 0) _err_fatal_simple(\"fclose\", strerror(errno));\n\treturn ret;\n}", "idx": 196}
{"project": "BWA", "commit_id": "279_BWA_0.7.17_utils.c_err_gzclose.c", "target": 0, "func": "int err_gzclose(gzFile file)\n{\n\tint ret = gzclose(file);\n\tif (Z_OK != ret)\n\t{\n\t\t_err_fatal_simple(\"gzclose\", Z_ERRNO == ret ? strerror(errno) : zError(ret));\n\t}\n\n\treturn ret;\n}", "idx": 197}
{"project": "BWA", "commit_id": "27_BWA_0.7.17_bwa.c_bseq_read.c", "target": 0, "func": "bseq1_t *bseq_read(int chunk_size, int *n_, void *ks1_, void *ks2_)\n{\n\tkseq_t *ks = (kseq_t*)ks1_, *ks2 = (kseq_t*)ks2_;\n\tint size = 0, m, n;\n\tbseq1_t *seqs;\n\tm = n = 0; seqs = 0;\n\twhile (kseq_read(ks) >= 0) {\n\t\tif (ks2 && kseq_read(ks2) < 0) { // the 2nd file has fewer reads\n\t\t\tfprintf(stderr, \"[W::%s] the 2nd file has fewer sequences.\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tif (n >= m) {\n\t\t\tm = m? m<<1 : 256;\n\t\t\tseqs = realloc(seqs, m * sizeof(bseq1_t));\n\t\t}\n\t\ttrim_readno(&ks->name);\n\t\tkseq2bseq1(ks, &seqs[n]);\n\t\tseqs[n].id = n;\n\t\tsize += seqs[n++].l_seq;\n\t\tif (ks2) {\n\t\t\ttrim_readno(&ks2->name);\n\t\t\tkseq2bseq1(ks2, &seqs[n]);\n\t\t\tseqs[n].id = n;\n\t\t\tsize += seqs[n++].l_seq;\n\t\t}\n\t\tif (size >= chunk_size && (n&1) == 0) break;\n\t}\n\tif (size == 0) { // test if the 2nd file is finished\n\t\tif (ks2 && kseq_read(ks2) >= 0)\n\t\t\tfprintf(stderr, \"[W::%s] the 1st file has fewer sequences.\\n\", __func__);\n\t}\n\t*n_ = n;\n\treturn seqs;\n}", "idx": 198}
{"project": "BWA", "commit_id": "280_BWA_0.7.17_utils.c_cputime.c", "target": 0, "func": "double cputime()\n{\n\tstruct rusage r;\n\tgetrusage(RUSAGE_SELF, &r);\n\treturn r.ru_utime.tv_sec + r.ru_stime.tv_sec + 1e-6 * (r.ru_utime.tv_usec + r.ru_stime.tv_usec);\n}", "idx": 199}
{"project": "BWA", "commit_id": "281_BWA_0.7.17_utils.c_realtime.c", "target": 0, "func": "double realtime()\n{\n\tstruct timeval tp;\n\tstruct timezone tzp;\n\tgettimeofday(&tp, &tzp);\n\treturn tp.tv_sec + tp.tv_usec * 1e-6;\n}", "idx": 200}
{"project": "BWA", "commit_id": "282_BWA_0.7.17_bwamem.c_mem_aln2sam.c", "target": 1, "func": "void mem_aln2sam(const mem_opt_t *opt, const bntseq_t *bns, kstring_t *str, bseq1_t *s, int n, const mem_aln_t *list, int which, const mem_aln_t *m_)\n{\n\tint i, l_name;\n\tmem_aln_t ptmp = list[which], *p = &ptmp, mtmp, *m = 0; // make a copy of the alignment to convert\n\n\tif (m_) mtmp = *m_, m = &mtmp;\n\t// set flag\n\tp->flag |= m? 0x1 : 0; // is paired in sequencing\n\tp->flag |= p->rid < 0? 0x4 : 0; // is mapped\n\tp->flag |= m && m->rid < 0? 0x8 : 0; // is mate mapped\n\tif (p->rid < 0 && m && m->rid >= 0) // copy mate to alignment\n\t\tp->rid = m->rid, p->pos = m->pos, p->is_rev = m->is_rev, p->n_cigar = 0;\n\tif (m && m->rid < 0 && p->rid >= 0) // copy alignment to mate\n\t\tm->rid = p->rid, m->pos = p->pos, m->is_rev = p->is_rev, m->n_cigar = 0;\n\tp->flag |= p->is_rev? 0x10 : 0; // is on the reverse strand\n\tp->flag |= m && m->is_rev? 0x20 : 0; // is mate on the reverse strand\n\n\t// print up to CIGAR\n\tl_name = strlen(s->name);\n\tks_resize(str, str->l + s->l_seq + l_name + (s->qual? s->l_seq : 0) + 20);\n\tkputsn(s->name, l_name, str); kputc('\\t', str); // QNAME\n\tkputw((p->flag&0xffff) | (p->flag&0x10000? 0x100 : 0), str); kputc('\\t', str); // FLAG\n\tif (p->rid >= 0) { // with coordinate\n\t\tkputs(bns->anns[p->rid].name, str); kputc('\\t', str); // RNAME\n\t\tkputl(p->pos + 1, str); kputc('\\t', str); // POS\n\t\tkputw(p->mapq, str); kputc('\\t', str); // MAPQ\n\t\tadd_cigar(opt, p, str, which);\n\t} else kputsn(\"*\\t0\\t0\\t*\", 7, str); // without coordinte\n\tkputc('\\t', str);\n\n\t// print the mate position if applicable\n\tif (m && m->rid >= 0) {\n\t\tif (p->rid == m->rid) kputc('=', str);\n\t\telse kputs(bns->anns[m->rid].name, str);\n\t\tkputc('\\t', str);\n\t\tkputl(m->pos + 1, str); kputc('\\t', str);\n\t\tif (p->rid == m->rid) {\n\t\t\tint64_t p0 = p->pos + (p->is_rev? get_rlen(p->n_cigar, p->cigar) - 1 : 0);\n\t\t\tint64_t p1 = m->pos + (m->is_rev? get_rlen(m->n_cigar, m->cigar) - 1 : 0);\n\t\t\tif (m->n_cigar == 0 || p->n_cigar == 0) kputc('0', str);\n\t\t\telse kputl(-(p0 - p1 + (p0 > p1? 1 : p0 < p1? -1 : 0)), str);\n\t\t} else kputc('0', str);\n\t} else kputsn(\"*\\t0\\t0\", 5, str);\n\tkputc('\\t', str);\n\n\t// print SEQ and QUAL\n\tif (p->flag & 0x100) { // for secondary alignments, don't write SEQ and QUAL\n\t\tkputsn(\"*\\t*\", 3, str);\n\t} else if (!p->is_rev) { // the forward strand\n\t\tint i, qb = 0, qe = s->l_seq;\n\t\tif (p->n_cigar && which && !(opt->flag&MEM_F_SOFTCLIP) && !p->is_alt) { // have cigar && not the primary alignment && not softclip all\n\t\t\tif ((p->cigar[0]&0xf) == 4 || (p->cigar[0]&0xf) == 3) qb += p->cigar[0]>>4;\n\t\t\tif ((p->cigar[p->n_cigar-1]&0xf) == 4 || (p->cigar[p->n_cigar-1]&0xf) == 3) qe -= p->cigar[p->n_cigar-1]>>4;\n\t\t}\n\t\tks_resize(str, str->l + (qe - qb) + 1);\n\t\tfor (i = qb; i < qe; ++i) str->s[str->l++] = \"ACGTN\"[(int)s->seq[i]];\n\t\tkputc('\\t', str);\n\t\tif (s->qual) { // printf qual\n\t\t\tks_resize(str, str->l + (qe - qb) + 1);\n\t\t\tfor (i = qb; i < qe; ++i) str->s[str->l++] = s->qual[i];\n\t\t\tstr->s[str->l] = 0;\n\t\t} else kputc('*', str);\n\t} else { // the reverse strand\n\t\tint i, qb = 0, qe = s->l_seq;\n\t\tif (p->n_cigar && which && !(opt->flag&MEM_F_SOFTCLIP) && !p->is_alt) {\n\t\t\tif ((p->cigar[0]&0xf) == 4 || (p->cigar[0]&0xf) == 3) qe -= p->cigar[0]>>4;\n\t\t\tif ((p->cigar[p->n_cigar-1]&0xf) == 4 || (p->cigar[p->n_cigar-1]&0xf) == 3) qb += p->cigar[p->n_cigar-1]>>4;\n\t\t}\n\t\tks_resize(str, str->l + (qe - qb) + 1);\n\t\tfor (i = qe-1; i >= qb; --i) str->s[str->l++] = \"TGCAN\"[(int)s->seq[i]];\n\t\tkputc('\\t', str);\n\t\tif (s->qual) { // printf qual\n\t\t\tks_resize(str, str->l + (qe - qb) + 1);\n\t\t\tfor (i = qe-1; i >= qb; --i) str->s[str->l++] = s->qual[i];\n\t\t\tstr->s[str->l] = 0;\n\t\t} else kputc('*', str);\n\t}\n\n\t// print optional tags\n\tif (p->n_cigar) {\n\t\tkputsn(\"\\tNM:i:\", 6, str); kputw(p->NM, str);\n\t\tkputsn(\"\\tMD:Z:\", 6, str); kputs((char*)(p->cigar + p->n_cigar), str);\n\t}\n\tif (m && m->n_cigar) { kputsn(\"\\tMC:Z:\", 6, str); add_cigar(opt, m, str, which); }\n\tif (p->score >= 0) { kputsn(\"\\tAS:i:\", 6, str); kputw(p->score, str); }\n\tif (p->sub >= 0) { kputsn(\"\\tXS:i:\", 6, str); kputw(p->sub, str); }\n\tif (bwa_rg_id[0]) { kputsn(\"\\tRG:Z:\", 6, str); kputs(bwa_rg_id, str); }\n\tif (!(p->flag & 0x100)) { // not multi-hit\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tif (i != which && !(list[i].flag&0x100)) break;\n\t\tif (i < n) { // there are other primary hits; output them\n\t\t\tkputsn(\"\\tSA:Z:\", 6, str);\n\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\tconst mem_aln_t *r = &list[i];\n\t\t\t\tint k;\n\t\t\t\tif (i == which || (r->flag&0x100)) continue; // proceed if: 1) different from the current; 2) not shadowed multi hit\n\t\t\t\tkputs(bns->anns[r->rid].name, str); kputc(',', str);\n\t\t\t\tkputl(r->pos+1, str); kputc(',', str);\n\t\t\t\tkputc(\"+-\"[r->is_rev], str); kputc(',', str);\n\t\t\t\tfor (k = 0; k < r->n_cigar; ++k) {\n\t\t\t\t\tkputw(r->cigar[k]>>4, str); kputc(\"MIDSH\"[r->cigar[k]&0xf], str);\n\t\t\t\t}\n\t\t\t\tkputc(',', str); kputw(r->mapq, str);\n\t\t\t\tkputc(',', str); kputw(r->NM, str);\n\t\t\t\tkputc(';', str);\n\t\t\t}\n\t\t}\n\t\tif (p->alt_sc > 0)\n\t\t\tksprintf(str, \"\\tpa:f:%.3f\", (double)p->score / p->alt_sc);\n\t}\n\tif (p->XA) { kputsn(\"\\tXA:Z:\", 6, str); kputs(p->XA, str); }\n\tif (s->comment) { kputc('\\t', str); kputs(s->comment, str); }\n\tif ((opt->flag&MEM_F_REF_HDR) && p->rid >= 0 && bns->anns[p->rid].anno != 0 && bns->anns[p->rid].anno[0] != 0) {\n\t\tint tmp;\n\t\tkputsn(\"\\tXR:Z:\", 6, str);\n\t\ttmp = str->l;\n\t\tkputs(bns->anns[p->rid].anno, str);\n\t\tfor (i = tmp; i < str->l; ++i) // replace TAB in the comment to SPACE\n\t\t\tif (str->s[i] == '\\t') str->s[i] = ' ';\n\t}\n\tkputc('\\n', str);\n}", "idx": 201}
{"project": "BWA", "commit_id": "283_BWA_0.7.17_bwamem_extra.c_mem_gen_alt.c", "target": 1, "func": "char **mem_gen_alt(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, const mem_alnreg_v *a, int l_query, const char *query) // ONLY work after mem_mark_primary_se()\n{\n\tint i, k, r, *cnt, tot;\n\tkstring_t *aln = 0, str = {0,0,0};\n\tchar **XA = 0, *has_alt;\n\n\tcnt = calloc(a->n, sizeof(int));\n\thas_alt = calloc(a->n, 1);\n\tfor (i = 0, tot = 0; i < a->n; ++i) {\n\t\tr = get_pri_idx(opt->XA_drop_ratio, a->a, i);\n\t\tif (r >= 0) {\n\t\t\t++cnt[r], ++tot;\n\t\t\tif (a->a[i].is_alt) has_alt[r] = 1;\n\t\t}\n\t}\n\tif (tot == 0) goto end_gen_alt;\n\taln = calloc(a->n, sizeof(kstring_t));\n\tfor (i = 0; i < a->n; ++i) {\n\t\tmem_aln_t t;\n\t\tif ((r = get_pri_idx(opt->XA_drop_ratio, a->a, i)) < 0) continue;\n\t\tif (cnt[r] > opt->max_XA_hits_alt || (!has_alt[r] && cnt[r] > opt->max_XA_hits)) continue;\n\t\tt = mem_reg2aln(opt, bns, pac, l_query, query, &a->a[i]);\n\t\tstr.l = 0;\n\t\tkputs(bns->anns[t.rid].name, &str);\n\t\tkputc(',', &str); kputc(\"+-\"[t.is_rev], &str); kputl(t.pos + 1, &str);\n\t\tkputc(',', &str);\n\t\tfor (k = 0; k < t.n_cigar; ++k) {\n\t\t\tkputw(t.cigar[k]>>4, &str);\n\t\t\tkputc(\"MIDSHN\"[t.cigar[k]&0xf], &str);\n\t\t}\n\t\tkputc(',', &str); kputw(t.NM, &str);\n\t\tkputc(';', &str);\n\t\tfree(t.cigar);\n\t\tkputsn(str.s, str.l, &aln[r]);\n\t}\n\tXA = calloc(a->n, sizeof(char*));\n\tfor (k = 0; k < a->n; ++k)\n\t\tXA[k] = aln[k].s;\n\nend_gen_alt:\n\tfree(has_alt); free(cnt); free(aln); free(str.s);\n\treturn XA;\n}", "idx": 202}
{"project": "BWA", "commit_id": "284_BWA_0.7.17_fastmap.c_main_mem.c", "target": 1, "func": "int main_mem(int argc, char *argv[])\n{\n\tmem_opt_t *opt, opt0;\n\tint fd, fd2, i, c, ignore_alt = 0, no_mt_io = 0;\n\tint fixed_chunk_size = -1;\n\tgzFile fp, fp2 = 0;\n\tchar *p, *rg_line = 0, *hdr_line = 0;\n\tconst char *mode = 0;\n\tvoid *ko = 0, *ko2 = 0;\n\tmem_pestat_t pes[4];\n\tktp_aux_t aux;\n\n\tmemset(&aux, 0, sizeof(ktp_aux_t));\n\tmemset(pes, 0, 4 * sizeof(mem_pestat_t));\n\tfor (i = 0; i < 4; ++i) pes[i].failed = 1;\n\n\taux.opt = opt = mem_opt_init();\n\tmemset(&opt0, 0, sizeof(mem_opt_t));\n\twhile ((c = getopt(argc, argv, \"51qpaMCSPVYjk:c:v:s:r:t:R:A:B:O:E:U:w:L:d:T:Q:D:m:I:N:o:f:W:x:G:h:y:K:X:H:\")) >= 0) {\n\t\tif (c == 'k') opt->min_seed_len = atoi(optarg), opt0.min_seed_len = 1;\n\t\telse if (c == '1') no_mt_io = 1;\n\t\telse if (c == 'x') mode = optarg;\n\t\telse if (c == 'w') opt->w = atoi(optarg), opt0.w = 1;\n\t\telse if (c == 'A') opt->a = atoi(optarg), opt0.a = 1;\n\t\telse if (c == 'B') opt->b = atoi(optarg), opt0.b = 1;\n\t\telse if (c == 'T') opt->T = atoi(optarg), opt0.T = 1;\n\t\telse if (c == 'U') opt->pen_unpaired = atoi(optarg), opt0.pen_unpaired = 1;\n\t\telse if (c == 't') opt->n_threads = atoi(optarg), opt->n_threads = opt->n_threads > 1? opt->n_threads : 1;\n\t\telse if (c == 'P') opt->flag |= MEM_F_NOPAIRING;\n\t\telse if (c == 'a') opt->flag |= MEM_F_ALL;\n\t\telse if (c == 'p') opt->flag |= MEM_F_PE | MEM_F_SMARTPE;\n\t\telse if (c == 'M') opt->flag |= MEM_F_NO_MULTI;\n\t\telse if (c == 'S') opt->flag |= MEM_F_NO_RESCUE;\n\t\telse if (c == 'Y') opt->flag |= MEM_F_SOFTCLIP;\n\t\telse if (c == 'V') opt->flag |= MEM_F_REF_HDR;\n\t\telse if (c == '5') opt->flag |= MEM_F_PRIMARY5 | MEM_F_KEEP_SUPP_MAPQ; // always apply MEM_F_KEEP_SUPP_MAPQ with -5\n\t\telse if (c == 'q') opt->flag |= MEM_F_KEEP_SUPP_MAPQ;\n\t\telse if (c == 'c') opt->max_occ = atoi(optarg), opt0.max_occ = 1;\n\t\telse if (c == 'd') opt->zdrop = atoi(optarg), opt0.zdrop = 1;\n\t\telse if (c == 'v') bwa_verbose = atoi(optarg);\n\t\telse if (c == 'j') ignore_alt = 1;\n\t\telse if (c == 'r') opt->split_factor = atof(optarg), opt0.split_factor = 1.;\n\t\telse if (c == 'D') opt->drop_ratio = atof(optarg), opt0.drop_ratio = 1.;\n\t\telse if (c == 'm') opt->max_matesw = atoi(optarg), opt0.max_matesw = 1;\n\t\telse if (c == 's') opt->split_width = atoi(optarg), opt0.split_width = 1;\n\t\telse if (c == 'G') opt->max_chain_gap = atoi(optarg), opt0.max_chain_gap = 1;\n\t\telse if (c == 'N') opt->max_chain_extend = atoi(optarg), opt0.max_chain_extend = 1;\n\t\telse if (c == 'o' || c == 'f') xreopen(optarg, \"wb\", stdout);\n\t\telse if (c == 'W') opt->min_chain_weight = atoi(optarg), opt0.min_chain_weight = 1;\n\t\telse if (c == 'y') opt->max_mem_intv = atol(optarg), opt0.max_mem_intv = 1;\n\t\telse if (c == 'C') aux.copy_comment = 1;\n\t\telse if (c == 'K') fixed_chunk_size = atoi(optarg);\n\t\telse if (c == 'X') opt->mask_level = atof(optarg);\n\t\telse if (c == 'h') {\n\t\t\topt0.max_XA_hits = opt0.max_XA_hits_alt = 1;\n\t\t\topt->max_XA_hits = opt->max_XA_hits_alt = strtol(optarg, &p, 10);\n\t\t\tif (*p != 0 && ispunct(*p) && isdigit(p[1]))\n\t\t\t\topt->max_XA_hits_alt = strtol(p+1, &p, 10);\n\t\t}\n\t\telse if (c == 'Q') {\n\t\t\topt0.mapQ_coef_len = 1;\n\t\t\topt->mapQ_coef_len = atoi(optarg);\n\t\t\topt->mapQ_coef_fac = opt->mapQ_coef_len > 0? log(opt->mapQ_coef_len) : 0;\n\t\t} else if (c == 'O') {\n\t\t\topt0.o_del = opt0.o_ins = 1;\n\t\t\topt->o_del = opt->o_ins = strtol(optarg, &p, 10);\n\t\t\tif (*p != 0 && ispunct(*p) && isdigit(p[1]))\n\t\t\t\topt->o_ins = strtol(p+1, &p, 10);\n\t\t} else if (c == 'E') {\n\t\t\topt0.e_del = opt0.e_ins = 1;\n\t\t\topt->e_del = opt->e_ins = strtol(optarg, &p, 10);\n\t\t\tif (*p != 0 && ispunct(*p) && isdigit(p[1]))\n\t\t\t\topt->e_ins = strtol(p+1, &p, 10);\n\t\t} else if (c == 'L') {\n\t\t\topt0.pen_clip5 = opt0.pen_clip3 = 1;\n\t\t\topt->pen_clip5 = opt->pen_clip3 = strtol(optarg, &p, 10);\n\t\t\tif (*p != 0 && ispunct(*p) && isdigit(p[1]))\n\t\t\t\topt->pen_clip3 = strtol(p+1, &p, 10);\n\t\t} else if (c == 'R') {\n\t\t\tif ((rg_line = bwa_set_rg(optarg)) == 0) return 1; // FIXME: memory leak\n\t\t} else if (c == 'H') {\n\t\t\tif (optarg[0] != '@') {\n\t\t\t\tFILE *fp;\n\t\t\t\tif ((fp = fopen(optarg, \"r\")) != 0) {\n\t\t\t\t\tchar *buf;\n\t\t\t\t\tbuf = calloc(1, 0x10000);\n\t\t\t\t\twhile (fgets(buf, 0xffff, fp)) {\n\t\t\t\t\t\ti = strlen(buf);\n\t\t\t\t\t\tassert(buf[i-1] == '\\n'); // a long line\n\t\t\t\t\t\tbuf[i-1] = 0;\n\t\t\t\t\t\thdr_line = bwa_insert_header(buf, hdr_line);\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf);\n\t\t\t\t\tfclose(fp);\n\t\t\t\t}\n\t\t\t} else hdr_line = bwa_insert_header(optarg, hdr_line);\n\t\t} else if (c == 'I') { // specify the insert size distribution\n\t\t\taux.pes0 = pes;\n\t\t\tpes[1].failed = 0;\n\t\t\tpes[1].avg = strtod(optarg, &p);\n\t\t\tpes[1].std = pes[1].avg * .1;\n\t\t\tif (*p != 0 && ispunct(*p) && isdigit(p[1]))\n\t\t\t\tpes[1].std = strtod(p+1, &p);\n\t\t\tpes[1].high = (int)(pes[1].avg + 4. * pes[1].std + .499);\n\t\t\tpes[1].low  = (int)(pes[1].avg - 4. * pes[1].std + .499);\n\t\t\tif (pes[1].low < 1) pes[1].low = 1;\n\t\t\tif (*p != 0 && ispunct(*p) && isdigit(p[1]))\n\t\t\t\tpes[1].high = (int)(strtod(p+1, &p) + .499);\n\t\t\tif (*p != 0 && ispunct(*p) && isdigit(p[1]))\n\t\t\t\tpes[1].low  = (int)(strtod(p+1, &p) + .499);\n\t\t\tif (bwa_verbose >= 3)\n\t\t\t\tfprintf(stderr, \"[M::%s] mean insert size: %.3f, stddev: %.3f, max: %d, min: %d\\n\",\n\t\t\t\t\t\t__func__, pes[1].avg, pes[1].std, pes[1].high, pes[1].low);\n\t\t}\n\t\telse return 1;\n\t}\n\n\tif (rg_line) {\n\t\thdr_line = bwa_insert_header(rg_line, hdr_line);\n\t\tfree(rg_line);\n\t}\n\n\tif (opt->n_threads < 1) opt->n_threads = 1;\n\tif (optind + 1 >= argc || optind + 3 < argc) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Usage: bwa mem [options] <idxbase> <in1.fq> [in2.fq]\\n\\n\");\n\t\tfprintf(stderr, \"Algorithm options:\\n\\n\");\n\t\tfprintf(stderr, \"       -t INT        number of threads [%d]\\n\", opt->n_threads);\n\t\tfprintf(stderr, \"       -k INT        minimum seed length [%d]\\n\", opt->min_seed_len);\n\t\tfprintf(stderr, \"       -w INT        band width for banded alignment [%d]\\n\", opt->w);\n\t\tfprintf(stderr, \"       -d INT        off-diagonal X-dropoff [%d]\\n\", opt->zdrop);\n\t\tfprintf(stderr, \"       -r FLOAT      look for internal seeds inside a seed longer than {-k} * FLOAT [%g]\\n\", opt->split_factor);\n\t\tfprintf(stderr, \"       -y INT        seed occurrence for the 3rd round seeding [%ld]\\n\", (long)opt->max_mem_intv);\n//\t\tfprintf(stderr, \"       -s INT        look for internal seeds inside a seed with less than INT occ [%d]\\n\", opt->split_width);\n\t\tfprintf(stderr, \"       -c INT        skip seeds with more than INT occurrences [%d]\\n\", opt->max_occ);\n\t\tfprintf(stderr, \"       -D FLOAT      drop chains shorter than FLOAT fraction of the longest overlapping chain [%.2f]\\n\", opt->drop_ratio);\n\t\tfprintf(stderr, \"       -W INT        discard a chain if seeded bases shorter than INT [0]\\n\");\n\t\tfprintf(stderr, \"       -m INT        perform at most INT rounds of mate rescues for each read [%d]\\n\", opt->max_matesw);\n\t\tfprintf(stderr, \"       -S            skip mate rescue\\n\");\n\t\tfprintf(stderr, \"       -P            skip pairing; mate rescue performed unless -S also in use\\n\");\n\t\tfprintf(stderr, \"\\nScoring options:\\n\\n\");\n\t\tfprintf(stderr, \"       -A INT        score for a sequence match, which scales options -TdBOELU unless overridden [%d]\\n\", opt->a);\n\t\tfprintf(stderr, \"       -B INT        penalty for a mismatch [%d]\\n\", opt->b);\n\t\tfprintf(stderr, \"       -O INT[,INT]  gap open penalties for deletions and insertions [%d,%d]\\n\", opt->o_del, opt->o_ins);\n\t\tfprintf(stderr, \"       -E INT[,INT]  gap extension penalty; a gap of size k cost '{-O} + {-E}*k' [%d,%d]\\n\", opt->e_del, opt->e_ins);\n\t\tfprintf(stderr, \"       -L INT[,INT]  penalty for 5'- and 3'-end clipping [%d,%d]\\n\", opt->pen_clip5, opt->pen_clip3);\n\t\tfprintf(stderr, \"       -U INT        penalty for an unpaired read pair [%d]\\n\\n\", opt->pen_unpaired);\n\t\tfprintf(stderr, \"       -x STR        read type. Setting -x changes multiple parameters unless overridden [null]\\n\");\n\t\tfprintf(stderr, \"                     pacbio: -k17 -W40 -r10 -A1 -B1 -O1 -E1 -L0  (PacBio reads to ref)\\n\");\n\t\tfprintf(stderr, \"                     ont2d: -k14 -W20 -r10 -A1 -B1 -O1 -E1 -L0  (Oxford Nanopore 2D-reads to ref)\\n\");\n\t\tfprintf(stderr, \"                     intractg: -B9 -O16 -L5  (intra-species contigs to ref)\\n\");\n\t\tfprintf(stderr, \"\\nInput/output options:\\n\\n\");\n\t\tfprintf(stderr, \"       -p            smart pairing (ignoring in2.fq)\\n\");\n\t\tfprintf(stderr, \"       -R STR        read group header line such as '@RG\\\\tID:foo\\\\tSM:bar' [null]\\n\");\n\t\tfprintf(stderr, \"       -H STR/FILE   insert STR to header if it starts with @; or insert lines in FILE [null]\\n\");\n\t\tfprintf(stderr, \"       -o FILE       sam file to output results to [stdout]\\n\");\n\t\tfprintf(stderr, \"       -j            treat ALT contigs as part of the primary assembly (i.e. ignore <idxbase>.alt file)\\n\");\n\t\tfprintf(stderr, \"       -5            for split alignment, take the alignment with the smallest coordinate as primary\\n\");\n\t\tfprintf(stderr, \"       -q            don't modify mapQ of supplementary alignments\\n\");\n\t\tfprintf(stderr, \"       -K INT        process INT input bases in each batch regardless of nThreads (for reproducibility) []\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"       -v INT        verbosity level: 1=error, 2=warning, 3=message, 4+=debugging [%d]\\n\", bwa_verbose);\n\t\tfprintf(stderr, \"       -T INT        minimum score to output [%d]\\n\", opt->T);\n\t\tfprintf(stderr, \"       -h INT[,INT]  if there are <INT hits with score >80%% of the max score, output all in XA [%d,%d]\\n\", opt->max_XA_hits, opt->max_XA_hits_alt);\n\t\tfprintf(stderr, \"       -a            output all alignments for SE or unpaired PE\\n\");\n\t\tfprintf(stderr, \"       -C            append FASTA/FASTQ comment to SAM output\\n\");\n\t\tfprintf(stderr, \"       -V            output the reference FASTA header in the XR tag\\n\");\n\t\tfprintf(stderr, \"       -Y            use soft clipping for supplementary alignments\\n\");\n\t\tfprintf(stderr, \"       -M            mark shorter split hits as secondary\\n\\n\");\n\t\tfprintf(stderr, \"       -I FLOAT[,FLOAT[,INT[,INT]]]\\n\");\n\t\tfprintf(stderr, \"                     specify the mean, standard deviation (10%% of the mean if absent), max\\n\");\n\t\tfprintf(stderr, \"                     (4 sigma from the mean if absent) and min of the insert size distribution.\\n\");\n\t\tfprintf(stderr, \"                     FR orientation only. [inferred]\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Note: Please read the man page for detailed description of the command line and options.\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t\tfree(opt);\n\t\treturn 1;\n\t}\n\n\tif (mode) {\n\t\tif (strcmp(mode, \"intractg\") == 0) {\n\t\t\tif (!opt0.o_del) opt->o_del = 16;\n\t\t\tif (!opt0.o_ins) opt->o_ins = 16;\n\t\t\tif (!opt0.b) opt->b = 9;\n\t\t\tif (!opt0.pen_clip5) opt->pen_clip5 = 5;\n\t\t\tif (!opt0.pen_clip3) opt->pen_clip3 = 5;\n\t\t} else if (strcmp(mode, \"pacbio\") == 0 || strcmp(mode, \"pbref\") == 0 || strcmp(mode, \"ont2d\") == 0) {\n\t\t\tif (!opt0.o_del) opt->o_del = 1;\n\t\t\tif (!opt0.e_del) opt->e_del = 1;\n\t\t\tif (!opt0.o_ins) opt->o_ins = 1;\n\t\t\tif (!opt0.e_ins) opt->e_ins = 1;\n\t\t\tif (!opt0.b) opt->b = 1;\n\t\t\tif (opt0.split_factor == 0.) opt->split_factor = 10.;\n\t\t\tif (strcmp(mode, \"ont2d\") == 0) {\n\t\t\t\tif (!opt0.min_chain_weight) opt->min_chain_weight = 20;\n\t\t\t\tif (!opt0.min_seed_len) opt->min_seed_len = 14;\n\t\t\t\tif (!opt0.pen_clip5) opt->pen_clip5 = 0;\n\t\t\t\tif (!opt0.pen_clip3) opt->pen_clip3 = 0;\n\t\t\t} else {\n\t\t\t\tif (!opt0.min_chain_weight) opt->min_chain_weight = 40;\n\t\t\t\tif (!opt0.min_seed_len) opt->min_seed_len = 17;\n\t\t\t\tif (!opt0.pen_clip5) opt->pen_clip5 = 0;\n\t\t\t\tif (!opt0.pen_clip3) opt->pen_clip3 = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"[E::%s] unknown read type '%s'\\n\", __func__, mode);\n\t\t\treturn 1; // FIXME memory leak\n\t\t}\n\t} else update_a(opt, &opt0);\n\tbwa_fill_scmat(opt->a, opt->b, opt->mat);\n\n\taux.idx = bwa_idx_load_from_shm(argv[optind]);\n\tif (aux.idx == 0) {\n\t\tif ((aux.idx = bwa_idx_load(argv[optind], BWA_IDX_ALL)) == 0) return 1; // FIXME: memory leak\n\t} else if (bwa_verbose >= 3)\n\t\tfprintf(stderr, \"[M::%s] load the bwa index from shared memory\\n\", __func__);\n\tif (ignore_alt)\n\t\tfor (i = 0; i < aux.idx->bns->n_seqs; ++i)\n\t\t\taux.idx->bns->anns[i].is_alt = 0;\n\n\tko = kopen(argv[optind + 1], &fd);\n\tif (ko == 0) {\n\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] fail to open file `%s'.\\n\", __func__, argv[optind + 1]);\n\t\treturn 1;\n\t}\n\tfp = gzdopen(fd, \"r\");\n\taux.ks = kseq_init(fp);\n\tif (optind + 2 < argc) {\n\t\tif (opt->flag&MEM_F_PE) {\n\t\t\tif (bwa_verbose >= 2)\n\t\t\t\tfprintf(stderr, \"[W::%s] when '-p' is in use, the second query file is ignored.\\n\", __func__);\n\t\t} else {\n\t\t\tko2 = kopen(argv[optind + 2], &fd2);\n\t\t\tif (ko2 == 0) {\n\t\t\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] fail to open file `%s'.\\n\", __func__, argv[optind + 2]);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfp2 = gzdopen(fd2, \"r\");\n\t\t\taux.ks2 = kseq_init(fp2);\n\t\t\topt->flag |= MEM_F_PE;\n\t\t}\n\t}\n\tbwa_print_sam_hdr(aux.idx->bns, hdr_line);\n\taux.actual_chunk_size = fixed_chunk_size > 0? fixed_chunk_size : opt->chunk_size * opt->n_threads;\n\tkt_pipeline(no_mt_io? 1 : 2, process, &aux, 3);\n\tfree(hdr_line);\n\tfree(opt);\n\tbwa_idx_destroy(aux.idx);\n\tkseq_destroy(aux.ks);\n\terr_gzclose(fp); kclose(ko);\n\tif (aux.ks2) {\n\t\tkseq_destroy(aux.ks2);\n\t\terr_gzclose(fp2); kclose(ko2);\n\t}\n\treturn 0;\n}", "idx": 203}
{"project": "BWA", "commit_id": "285_BWA_0.7.17_bntseq.c_bns_restore.c", "target": 1, "func": "bntseq_t *bns_restore(const char *prefix)\n{  \n\tchar ann_filename[1024], amb_filename[1024], pac_filename[1024], alt_filename[1024];\n\tFILE *fp;\n\tbntseq_t *bns;\n\tstrcat(strcpy(ann_filename, prefix), \".ann\");\n\tstrcat(strcpy(amb_filename, prefix), \".amb\");\n\tstrcat(strcpy(pac_filename, prefix), \".pac\");\n\tbns = bns_restore_core(ann_filename, amb_filename, pac_filename);\n\tif (bns == 0) return 0;\n\tif ((fp = fopen(strcat(strcpy(alt_filename, prefix), \".alt\"), \"r\")) != 0) { // read .alt file if present\n\t\tchar str[1024];\n\t\tkhash_t(str) *h;\n\t\tint c, i, absent;\n\t\tkhint_t k;\n\t\th = kh_init(str);\n\t\tfor (i = 0; i < bns->n_seqs; ++i) {\n\t\t\tk = kh_put(str, h, bns->anns[i].name, &absent);\n\t\t\tkh_val(h, k) = i;\n\t\t}\n\t\ti = 0;\n\t\twhile ((c = fgetc(fp)) != EOF) {\n\t\t\tif (c == '\\t' || c == '\\n' || c == '\\r') {\n\t\t\t\tstr[i] = 0;\n\t\t\t\tif (str[0] != '@') {\n\t\t\t\t\tk = kh_get(str, h, str);\n\t\t\t\t\tif (k != kh_end(h))\n\t\t\t\t\t\tbns->anns[kh_val(h, k)].is_alt = 1;\n\t\t\t\t}\n\t\t\t\twhile (c != '\\n' && c != EOF) c = fgetc(fp);\n\t\t\t\ti = 0;\n\t\t\t} else str[i++] = c; // FIXME: potential segfault here\n\t\t}\n\t\tkh_destroy(str, h);\n\t\tfclose(fp);\n\t}\n\treturn bns;\n}", "idx": 204}
{"project": "BWA", "commit_id": "286_BWA_0.7.17_ksw.c_ksw_u8.c", "target": 1, "func": "kswr_t ksw_u8(kswq_t *q, int tlen, const uint8_t *target, int _o_del, int _e_del, int _o_ins, int _e_ins, int xtra) // the first gap costs -(_o+_e)\n{\n\tint slen, i, m_b, n_b, te = -1, gmax = 0, minsc, endsc;\n\tuint64_t *b;\n\t__m128i zero, oe_del, e_del, oe_ins, e_ins, shift, *H0, *H1, *E, *Hmax;\n\tkswr_t r;\n\n#define __max_16(ret, xx) do { \\\n\t\t(xx) = _mm_max_epu8((xx), _mm_srli_si128((xx), 8)); \\\n\t\t(xx) = _mm_max_epu8((xx), _mm_srli_si128((xx), 4)); \\\n\t\t(xx) = _mm_max_epu8((xx), _mm_srli_si128((xx), 2)); \\\n\t\t(xx) = _mm_max_epu8((xx), _mm_srli_si128((xx), 1)); \\\n    \t(ret) = _mm_extract_epi16((xx), 0) & 0x00ff; \\\n\t} while (0)\n\n\t// initialization\n\tr = g_defr;\n\tminsc = (xtra&KSW_XSUBO)? xtra&0xffff : 0x10000;\n\tendsc = (xtra&KSW_XSTOP)? xtra&0xffff : 0x10000;\n\tm_b = n_b = 0; b = 0;\n\tzero = _mm_set1_epi32(0);\n\toe_del = _mm_set1_epi8(_o_del + _e_del);\n\te_del = _mm_set1_epi8(_e_del);\n\toe_ins = _mm_set1_epi8(_o_ins + _e_ins);\n\te_ins = _mm_set1_epi8(_e_ins);\n\tshift = _mm_set1_epi8(q->shift);\n\tH0 = q->H0; H1 = q->H1; E = q->E; Hmax = q->Hmax;\n\tslen = q->slen;\n\tfor (i = 0; i < slen; ++i) {\n\t\t_mm_store_si128(E + i, zero);\n\t\t_mm_store_si128(H0 + i, zero);\n\t\t_mm_store_si128(Hmax + i, zero);\n\t}\n\t// the core loop\n\tfor (i = 0; i < tlen; ++i) {\n\t\tint j, k, cmp, imax;\n\t\t__m128i e, h, t, f = zero, max = zero, *S = q->qp + target[i] * slen; // s is the 1st score vector\n\t\th = _mm_load_si128(H0 + slen - 1); // h={2,5,8,11,14,17,-1,-1} in the above example\n\t\th = _mm_slli_si128(h, 1); // h=H(i-1,-1); << instead of >> because x64 is little-endian\n\t\tfor (j = 0; LIKELY(j < slen); ++j) {\n\t\t\t/* SW cells are computed in the following order:\n\t\t\t *   H(i,j)   = max{H(i-1,j-1)+S(i,j), E(i,j), F(i,j)}\n\t\t\t *   E(i+1,j) = max{H(i,j)-q, E(i,j)-r}\n\t\t\t *   F(i,j+1) = max{H(i,j)-q, F(i,j)-r}\n\t\t\t */\n\t\t\t// compute H'(i,j); note that at the beginning, h=H'(i-1,j-1)\n\t\t\th = _mm_adds_epu8(h, _mm_load_si128(S + j));\n\t\t\th = _mm_subs_epu8(h, shift); // h=H'(i-1,j-1)+S(i,j)\n\t\t\te = _mm_load_si128(E + j); // e=E'(i,j)\n\t\t\th = _mm_max_epu8(h, e);\n\t\t\th = _mm_max_epu8(h, f); // h=H'(i,j)\n\t\t\tmax = _mm_max_epu8(max, h); // set max\n\t\t\t_mm_store_si128(H1 + j, h); // save to H'(i,j)\n\t\t\t// now compute E'(i+1,j)\n\t\t\te = _mm_subs_epu8(e, e_del); // e=E'(i,j) - e_del\n\t\t\tt = _mm_subs_epu8(h, oe_del); // h=H'(i,j) - o_del - e_del\n\t\t\te = _mm_max_epu8(e, t); // e=E'(i+1,j)\n\t\t\t_mm_store_si128(E + j, e); // save to E'(i+1,j)\n\t\t\t// now compute F'(i,j+1)\n\t\t\tf = _mm_subs_epu8(f, e_ins);\n\t\t\tt = _mm_subs_epu8(h, oe_ins); // h=H'(i,j) - o_ins - e_ins\n\t\t\tf = _mm_max_epu8(f, t);\n\t\t\t// get H'(i-1,j) and prepare for the next j\n\t\t\th = _mm_load_si128(H0 + j); // h=H'(i-1,j)\n\t\t}\n\t\t// NB: we do not need to set E(i,j) as we disallow adjecent insertion and then deletion\n\t\tfor (k = 0; LIKELY(k < 16); ++k) { // this block mimics SWPS3; NB: H(i,j) updated in the lazy-F loop cannot exceed max\n\t\t\tf = _mm_slli_si128(f, 1);\n\t\t\tfor (j = 0; LIKELY(j < slen); ++j) {\n\t\t\t\th = _mm_load_si128(H1 + j);\n\t\t\t\th = _mm_max_epu8(h, f); // h=H'(i,j)\n\t\t\t\t_mm_store_si128(H1 + j, h);\n\t\t\t\th = _mm_subs_epu8(h, oe_ins);\n\t\t\t\tf = _mm_subs_epu8(f, e_ins);\n\t\t\t\tcmp = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_subs_epu8(f, h), zero));\n\t\t\t\tif (UNLIKELY(cmp == 0xffff)) goto end_loop16;\n\t\t\t}\n\t\t}\nend_loop16:\n\t\t//int k;for (k=0;k<16;++k)printf(\"%d \", ((uint8_t*)&max)[k]);printf(\"\\n\");\n\t\t__max_16(imax, max); // imax is the maximum number in max\n\t\tif (imax >= minsc) { // write the b array; this condition adds branching unfornately\n\t\t\tif (n_b == 0 || (int32_t)b[n_b-1] + 1 != i) { // then append\n\t\t\t\tif (n_b == m_b) {\n\t\t\t\t\tm_b = m_b? m_b<<1 : 8;\n\t\t\t\t\tb = (uint64_t*)realloc(b, 8 * m_b);\n\t\t\t\t}\n\t\t\t\tb[n_b++] = (uint64_t)imax<<32 | i;\n\t\t\t} else if ((int)(b[n_b-1]>>32) < imax) b[n_b-1] = (uint64_t)imax<<32 | i; // modify the last\n\t\t}\n\t\tif (imax > gmax) {\n\t\t\tgmax = imax; te = i; // te is the end position on the target\n\t\t\tfor (j = 0; LIKELY(j < slen); ++j) // keep the H1 vector\n\t\t\t\t_mm_store_si128(Hmax + j, _mm_load_si128(H1 + j));\n\t\t\tif (gmax + q->shift >= 255 || gmax >= endsc) break;\n\t\t}\n\t\tS = H1; H1 = H0; H0 = S; // swap H0 and H1\n\t}\n\tr.score = gmax + q->shift < 255? gmax : 255;\n\tr.te = te;\n\tif (r.score != 255) { // get a->qe, the end of query match; find the 2nd best score\n\t\tint max = -1, tmp, low, high, qlen = slen * 16;\n\t\tuint8_t *t = (uint8_t*)Hmax;\n\t\tfor (i = 0; i < qlen; ++i, ++t)\n\t\t\tif ((int)*t > max) max = *t, r.qe = i / 16 + i % 16 * slen;\n\t\t\telse if ((int)*t == max && (tmp = i / 16 + i % 16 * slen) < r.qe) r.qe = tmp; \n\t\t//printf(\"%d,%d\\n\", max, gmax);\n\t\tif (b) {\n\t\t\ti = (r.score + q->max - 1) / q->max;\n\t\t\tlow = te - i; high = te + i;\n\t\t\tfor (i = 0; i < n_b; ++i) {\n\t\t\t\tint e = (int32_t)b[i];\n\t\t\t\tif ((e < low || e > high) && (int)(b[i]>>32) > r.score2)\n\t\t\t\t\tr.score2 = b[i]>>32, r.te2 = e;\n\t\t\t}\n\t\t}\n\t}\n\tfree(b);\n\treturn r;\n}", "idx": 205}
{"project": "BWA", "commit_id": "28_BWA_0.7.17_bwa.c_bwa_fill_scmat.c", "target": 0, "func": "void bwa_fill_scmat(int a, int b, int8_t mat[25])\n{\n\tint i, j, k;\n\tfor (i = k = 0; i < 4; ++i) {\n\t\tfor (j = 0; j < 4; ++j)\n\t\t\tmat[k++] = i == j? a : -b;\n\t\tmat[k++] = -1; // ambiguous base\n\t}\n\tfor (j = 0; j < 5; ++j) mat[k++] = -1;\n}", "idx": 206}
{"project": "BWA", "commit_id": "29_BWA_0.7.17_bwa.c_bwa_gen_cigar.c", "target": 0, "func": "uint32_t *bwa_gen_cigar(const int8_t mat[25], int q, int r, int w_, int64_t l_pac, const uint8_t *pac, int l_query, uint8_t *query, int64_t rb, int64_t re, int *score, int *n_cigar, int *NM)\n{\n\treturn bwa_gen_cigar2(mat, q, r, q, r, w_, l_pac, pac, l_query, query, rb, re, score, n_cigar, NM);\n}", "idx": 207}
{"project": "BWA", "commit_id": "2_BWA_0.7.17_bamlite.c_bam_swap_endian_2.c", "target": 0, "func": "static inline uint16_t bam_swap_endian_2(uint16_t v)\n{\n\treturn (uint16_t)(((v & 0x00FF00FFU) << 8) | ((v & 0xFF00FF00U) >> 8));\n}", "idx": 208}
{"project": "BWA", "commit_id": "30_BWA_0.7.17_bwa.c_bwa_idx_infer_prefix.c", "target": 0, "func": "char *bwa_idx_infer_prefix(const char *hint)\n{\n\tchar *prefix;\n\tint l_hint;\n\tFILE *fp;\n\tl_hint = strlen(hint);\n\tprefix = malloc(l_hint + 3 + 4 + 1);\n\tstrcpy(prefix, hint);\n\tstrcpy(prefix + l_hint, \".64.bwt\");\n\tif ((fp = fopen(prefix, \"rb\")) != 0) {\n\t\tfclose(fp);\n\t\tprefix[l_hint + 3] = 0;\n\t\treturn prefix;\n\t} else {\n\t\tstrcpy(prefix + l_hint, \".bwt\");\n\t\tif ((fp = fopen(prefix, \"rb\")) == 0) {\n\t\t\tfree(prefix);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tfclose(fp);\n\t\t\tprefix[l_hint] = 0;\n\t\t\treturn prefix;\n\t\t}\n\t}\n}", "idx": 209}
{"project": "BWA", "commit_id": "31_BWA_0.7.17_bwa.c_bwa_idx_load_bwt.c", "target": 0, "func": "bwt_t *bwa_idx_load_bwt(const char *hint)\n{\n\tchar *tmp, *prefix;\n\tbwt_t *bwt;\n\tprefix = bwa_idx_infer_prefix(hint);\n\tif (prefix == 0) {\n\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] fail to locate the index files\\n\", __func__);\n\t\treturn 0;\n\t}\n\ttmp = calloc(strlen(prefix) + 5, 1);\n\tstrcat(strcpy(tmp, prefix), \".bwt\"); // FM-index\n\tbwt = bwt_restore_bwt(tmp);\n\tstrcat(strcpy(tmp, prefix), \".sa\");  // partial suffix array (SA)\n\tbwt_restore_sa(tmp, bwt);\n\tfree(tmp); free(prefix);\n\treturn bwt;\n}", "idx": 210}
{"project": "BWA", "commit_id": "32_BWA_0.7.17_bwa.c_bwa_idx_load_from_disk.c", "target": 0, "func": "bwaidx_t *bwa_idx_load_from_disk(const char *hint, int which)\n{\n\tbwaidx_t *idx;\n\tchar *prefix;\n\tprefix = bwa_idx_infer_prefix(hint);\n\tif (prefix == 0) {\n\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] fail to locate the index files\\n\", __func__);\n\t\treturn 0;\n\t}\n\tidx = calloc(1, sizeof(bwaidx_t));\n\tif (which & BWA_IDX_BWT) idx->bwt = bwa_idx_load_bwt(hint);\n\tif (which & BWA_IDX_BNS) {\n\t\tint i, c;\n\t\tidx->bns = bns_restore(prefix);\n\t\tfor (i = c = 0; i < idx->bns->n_seqs; ++i)\n\t\t\tif (idx->bns->anns[i].is_alt) ++c;\n\t\tif (bwa_verbose >= 3)\n\t\t\tfprintf(stderr, \"[M::%s] read %d ALT contigs\\n\", __func__, c);\n\t\tif (which & BWA_IDX_PAC) {\n\t\t\tidx->pac = calloc(idx->bns->l_pac/4+1, 1);\n\t\t\terr_fread_noeof(idx->pac, 1, idx->bns->l_pac/4+1, idx->bns->fp_pac); // concatenated 2-bit encoded sequence\n\t\t\terr_fclose(idx->bns->fp_pac);\n\t\t\tidx->bns->fp_pac = 0;\n\t\t}\n\t}\n\tfree(prefix);\n\treturn idx;\n}", "idx": 211}
{"project": "BWA", "commit_id": "33_BWA_0.7.17_bwa.c_bwa_idx_load.c", "target": 0, "func": "bwaidx_t *bwa_idx_load(const char *hint, int which)\n{\n\treturn bwa_idx_load_from_disk(hint, which);\n}", "idx": 212}
{"project": "BWA", "commit_id": "34_BWA_0.7.17_bwa.c_bwa_idx_destroy.c", "target": 0, "func": "void bwa_idx_destroy(bwaidx_t *idx)\n{\n\tif (idx == 0) return;\n\tif (idx->mem == 0) {\n\t\tif (idx->bwt) bwt_destroy(idx->bwt);\n\t\tif (idx->bns) bns_destroy(idx->bns);\n\t\tif (idx->pac) free(idx->pac);\n\t} else {\n\t\tfree(idx->bwt); free(idx->bns->anns); free(idx->bns);\n\t\tif (!idx->is_shm) free(idx->mem);\n\t}\n\tfree(idx);\n}", "idx": 213}
{"project": "BWA", "commit_id": "35_BWA_0.7.17_bwa.c_bwa_mem2idx.c", "target": 0, "func": "int bwa_mem2idx(int64_t l_mem, uint8_t *mem, bwaidx_t *idx)\n{\n\tint64_t k = 0, x;\n\tint i;\n\n\t// generate idx->bwt\n\tx = sizeof(bwt_t); idx->bwt = malloc(x); memcpy(idx->bwt, mem + k, x); k += x;\n\tx = idx->bwt->bwt_size * 4; idx->bwt->bwt = (uint32_t*)(mem + k); k += x;\n\tx = idx->bwt->n_sa * sizeof(bwtint_t); idx->bwt->sa = (bwtint_t*)(mem + k); k += x;\n\n\t// generate idx->bns and idx->pac\n\tx = sizeof(bntseq_t); idx->bns = malloc(x); memcpy(idx->bns, mem + k, x); k += x;\n\tx = idx->bns->n_holes * sizeof(bntamb1_t); idx->bns->ambs = (bntamb1_t*)(mem + k); k += x;\n\tx = idx->bns->n_seqs  * sizeof(bntann1_t); idx->bns->anns = malloc(x); memcpy(idx->bns->anns, mem + k, x); k += x;\n\tfor (i = 0; i < idx->bns->n_seqs; ++i) {\n\t\tidx->bns->anns[i].name = (char*)(mem + k); k += strlen(idx->bns->anns[i].name) + 1;\n\t\tidx->bns->anns[i].anno = (char*)(mem + k); k += strlen(idx->bns->anns[i].anno) + 1;\n\t}\n\tidx->pac = (uint8_t*)(mem + k); k += idx->bns->l_pac/4+1;\n\tassert(k == l_mem);\n\n\tidx->l_mem = k; idx->mem = mem;\n\treturn 0;\n}", "idx": 214}
{"project": "BWA", "commit_id": "36_BWA_0.7.17_bwa.c_bwa_idx2mem.c", "target": 0, "func": "int bwa_idx2mem(bwaidx_t *idx)\n{\n\tint i;\n\tint64_t k, x, tmp;\n\tuint8_t *mem;\n\n\t// copy idx->bwt\n\tx = idx->bwt->bwt_size * 4;\n\tmem = realloc(idx->bwt->bwt, sizeof(bwt_t) + x); idx->bwt->bwt = 0;\n\tmemmove(mem + sizeof(bwt_t), mem, x);\n\tmemcpy(mem, idx->bwt, sizeof(bwt_t)); k = sizeof(bwt_t) + x;\n\tx = idx->bwt->n_sa * sizeof(bwtint_t); mem = realloc(mem, k + x); memcpy(mem + k, idx->bwt->sa, x); k += x;\n\tfree(idx->bwt->sa);\n\tfree(idx->bwt); idx->bwt = 0;\n\n\t// copy idx->bns\n\ttmp = idx->bns->n_seqs * sizeof(bntann1_t) + idx->bns->n_holes * sizeof(bntamb1_t);\n\tfor (i = 0; i < idx->bns->n_seqs; ++i) // compute the size of heap-allocated memory\n\t\ttmp += strlen(idx->bns->anns[i].name) + strlen(idx->bns->anns[i].anno) + 2;\n\tmem = realloc(mem, k + sizeof(bntseq_t) + tmp);\n\tx = sizeof(bntseq_t); memcpy(mem + k, idx->bns, x); k += x;\n\tx = idx->bns->n_holes * sizeof(bntamb1_t); memcpy(mem + k, idx->bns->ambs, x); k += x;\n\tfree(idx->bns->ambs);\n\tx = idx->bns->n_seqs * sizeof(bntann1_t); memcpy(mem + k, idx->bns->anns, x); k += x;\n\tfor (i = 0; i < idx->bns->n_seqs; ++i) {\n\t\tx = strlen(idx->bns->anns[i].name) + 1; memcpy(mem + k, idx->bns->anns[i].name, x); k += x;\n\t\tx = strlen(idx->bns->anns[i].anno) + 1; memcpy(mem + k, idx->bns->anns[i].anno, x); k += x;\n\t\tfree(idx->bns->anns[i].name); free(idx->bns->anns[i].anno);\n\t}\n\tfree(idx->bns->anns);\n\n\t// copy idx->pac\n\tx = idx->bns->l_pac/4+1;\n\tmem = realloc(mem, k + x);\n\tmemcpy(mem + k, idx->pac, x); k += x;\n\tfree(idx->bns); idx->bns = 0;\n\tfree(idx->pac); idx->pac = 0;\n\n\treturn bwa_mem2idx(k, mem, idx);\n}", "idx": 215}
{"project": "BWA", "commit_id": "37_BWA_0.7.17_bwa.c_bwa_print_sam_hdr.c", "target": 1, "func": "void bwa_print_sam_hdr(const bntseq_t *bns, const char *hdr_line)\n{\n\tint i, n_SQ = 0;\n\textern char *bwa_pg;\n\tif (hdr_line) {\n\t\tconst char *p = hdr_line;\n\t\twhile ((p = strstr(p, \"@SQ\\t\")) != 0) {\n\t\t\tif (p == hdr_line || *(p-1) == '\\n') ++n_SQ;\n\t\t\tp += 4;\n\t\t}\n\t}\n\tif (n_SQ == 0) {\n\t\tfor (i = 0; i < bns->n_seqs; ++i) {\n\t\t\terr_printf(\"@SQ\\tSN:%s\\tLN:%d\", bns->anns[i].name, bns->anns[i].len);\n\t\t\tif (bns->anns[i].is_alt) err_printf(\"\\tAH:*\\n\");\n\t\t\telse err_fputc('\\n', stdout);\n\t\t}\n\t} else if (n_SQ != bns->n_seqs && bwa_verbose >= 2)\n\t\tfprintf(stderr, \"[W::%s] %d @SQ lines provided with -H; %d sequences in the index. Continue anyway.\\n\", __func__, n_SQ, bns->n_seqs);\n\tif (hdr_line) err_printf(\"%s\\n\", hdr_line);\n\tif (bwa_pg) err_printf(\"%s\\n\", bwa_pg);\n}", "idx": 216}
{"project": "BWA", "commit_id": "38_BWA_0.7.17_bwa.c_bwa_escape.c", "target": 0, "func": "static char *bwa_escape(char *s)\n{\n\tchar *p, *q;\n\tfor (p = q = s; *p; ++p) {\n\t\tif (*p == '\\\\') {\n\t\t\t++p;\n\t\t\tif (*p == 't') *q++ = '\\t';\n\t\t\telse if (*p == 'n') *q++ = '\\n';\n\t\t\telse if (*p == 'r') *q++ = '\\r';\n\t\t\telse if (*p == '\\\\') *q++ = '\\\\';\n\t\t} else *q++ = *p;\n\t}\n\t*q = '\\0';\n\treturn s;\n}", "idx": 217}
{"project": "BWA", "commit_id": "39_BWA_0.7.17_bwa.c_bwa_set_rg.c", "target": 0, "func": "char *bwa_set_rg(const char *s)\n{\n\tchar *p, *q, *r, *rg_line = 0;\n\tmemset(bwa_rg_id, 0, 256);\n\tif (strstr(s, \"@RG\") != s) {\n\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] the read group line is not started with @RG\\n\", __func__);\n\t\tgoto err_set_rg;\n\t}\n\tif (strstr(s, \"\\t\") != NULL) {\n\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] the read group line contained literal <tab> characters -- replace with escaped tabs: \\\\t\\n\", __func__);\n\t\tgoto err_set_rg;\n\t}\n\trg_line = strdup(s);\n\tbwa_escape(rg_line);\n\tif ((p = strstr(rg_line, \"\\tID:\")) == 0) {\n\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] no ID within the read group line\\n\", __func__);\n\t\tgoto err_set_rg;\n\t}\n\tp += 4;\n\tfor (q = p; *q && *q != '\\t' && *q != '\\n'; ++q);\n\tif (q - p + 1 > 256) {\n\t\tif (bwa_verbose >= 1) fprintf(stderr, \"[E::%s] @RG:ID is longer than 255 characters\\n\", __func__);\n\t\tgoto err_set_rg;\n\t}\n\tfor (q = p, r = bwa_rg_id; *q && *q != '\\t' && *q != '\\n'; ++q)\n\t\t*r++ = *q;\n\treturn rg_line;\n\nerr_set_rg:\n\tfree(rg_line);\n\treturn 0;\n}", "idx": 218}
{"project": "BWA", "commit_id": "3_BWA_0.7.17_bamlite.c_bam_swap_endian_2p.c", "target": 0, "func": "static inline void *bam_swap_endian_2p(void *x)\n{\n\t*(uint16_t*)x = bam_swap_endian_2(*(uint16_t*)x);\n\treturn x;\n}", "idx": 219}
{"project": "BWA", "commit_id": "40_BWA_0.7.17_bwa.c_bwa_insert_header.c", "target": 0, "func": "char *bwa_insert_header(const char *s, char *hdr)\n{\n\tint len = 0;\n\tif (s == 0 || s[0] != '@') return hdr;\n\tif (hdr) {\n\t\tlen = strlen(hdr);\n\t\thdr = realloc(hdr, len + strlen(s) + 2);\n\t\thdr[len++] = '\\n';\n\t\tstrcpy(hdr + len, s);\n\t} else hdr = strdup(s);\n\tbwa_escape(hdr + len);\n\treturn hdr;\n}", "idx": 220}
{"project": "BWA", "commit_id": "41_BWA_0.7.17_bwamem.c_mem_opt_init.c", "target": 0, "func": "for debugging only\n\nmem_opt_t *mem_opt_init()\n{\n\tmem_opt_t *o;\n\to = calloc(1, sizeof(mem_opt_t));\n\to->flag = 0;\n\to->a = 1; o->b = 4;\n\to->o_del = o->o_ins = 6;\n\to->e_del = o->e_ins = 1;\n\to->w = 100;\n\to->T = 30;\n\to->zdrop = 100;\n\to->pen_unpaired = 17;\n\to->pen_clip5 = o->pen_clip3 = 5;\n\n\to->max_mem_intv = 20;\n\n\to->min_seed_len = 19;\n\to->split_width = 10;\n\to->max_occ = 500;\n\to->max_chain_gap = 10000;\n\to->max_ins = 10000;\n\to->mask_level = 0.50;\n\to->drop_ratio = 0.50;\n\to->XA_drop_ratio = 0.80;\n\to->split_factor = 1.5;\n\to->chunk_size = 10000000;\n\to->n_threads = 1;\n\to->max_XA_hits = 5;\n\to->max_XA_hits_alt = 200;\n\to->max_matesw = 50;\n\to->mask_level_redun = 0.95;\n\to->min_chain_weight = 0;\n\to->max_chain_extend = 1<<30;\n\to->mapQ_coef_len = 50; o->mapQ_coef_fac = log(o->mapQ_coef_len);\n\tbwa_fill_scmat(o->a, o->b, o->mat);\n\treturn o;\n}", "idx": 221}
{"project": "BWA", "commit_id": "42_BWA_0.7.17_bwamem.c_smem_aux_init.c", "target": 0, "func": "static smem_aux_t *smem_aux_init()\n{\n\tsmem_aux_t *a;\n\ta = calloc(1, sizeof(smem_aux_t));\n\ta->tmpv[0] = calloc(1, sizeof(bwtintv_v));\n\ta->tmpv[1] = calloc(1, sizeof(bwtintv_v));\n\treturn a;\n}", "idx": 222}
{"project": "BWA", "commit_id": "43_BWA_0.7.17_bwamem.c_smem_aux_destroy.c", "target": 0, "func": "static void smem_aux_destroy(smem_aux_t *a)\n{\t\n\tfree(a->tmpv[0]->a); free(a->tmpv[0]);\n\tfree(a->tmpv[1]->a); free(a->tmpv[1]);\n\tfree(a->mem.a); free(a->mem1.a);\n\tfree(a);\n}", "idx": 223}
{"project": "BWA", "commit_id": "44_BWA_0.7.17_bwamem.c_while.c", "target": 0, "func": "while (x < len) {\n\t\tif (seq[x] < 4) {\n\t\t\tx = bwt_smem1(bwt, len, seq, x, start_width, &a->mem1, a->tmpv);\n\t\t\tfor (i = 0; i < a->mem1.n; ++i) {\n\t\t\t\tbwtintv_t *p = &a->mem1.a[i];\n\t\t\t\tint slen = (uint32_t)p->info - (p->info>>32); // seed length\n\t\t\t\tif (slen >= opt->min_seed_len)\n\t\t\t\t\tkv_push(bwtintv_t, a->mem, *p);\n\t\t\t}\n\t\t} else ++x;\n\t}", "idx": 224}
{"project": "BWA", "commit_id": "45_BWA_0.7.17_bwamem.c_test_and_merge.c", "target": 0, "func": "static int test_and_merge(const mem_opt_t *opt, int64_t l_pac, mem_chain_t *c, const mem_seed_t *p, int seed_rid)\n{\n\tint64_t qend, rend, x, y;\n\tconst mem_seed_t *last = &c->seeds[c->n-1];\n\tqend = last->qbeg + last->len;\n\trend = last->rbeg + last->len;\n\tif (seed_rid != c->rid) return 0; // different chr; request a new chain\n\tif (p->qbeg >= c->seeds[0].qbeg && p->qbeg + p->len <= qend && p->rbeg >= c->seeds[0].rbeg && p->rbeg + p->len <= rend)\n\t\treturn 1; // contained seed; do nothing\n\tif ((last->rbeg < l_pac || c->seeds[0].rbeg < l_pac) && p->rbeg >= l_pac) return 0; // don't chain if on different strand\n\tx = p->qbeg - last->qbeg; // always non-negtive\n\ty = p->rbeg - last->rbeg;\n\tif (y >= 0 && x - y <= opt->w && y - x <= opt->w && x - last->len < opt->max_chain_gap && y - last->len < opt->max_chain_gap) { // grow the chain\n\t\tif (c->n == c->m) {\n\t\t\tc->m <<= 1;\n\t\t\tc->seeds = realloc(c->seeds, c->m * sizeof(mem_seed_t));\n\t\t}\n\t\tc->seeds[c->n++] = *p;\n\t\treturn 1;\n\t}\n\treturn 0; // request to add a new chain\n}", "idx": 225}
{"project": "BWA", "commit_id": "46_BWA_0.7.17_bwamem.c_mem_chain_weight.c", "target": 0, "func": "int mem_chain_weight(const mem_chain_t *c)\n{\n\tint64_t end;\n\tint j, w = 0, tmp;\n\tfor (j = 0, end = 0; j < c->n; ++j) {\n\t\tconst mem_seed_t *s = &c->seeds[j];\n\t\tif (s->qbeg >= end) w += s->len;\n\t\telse if (s->qbeg + s->len > end) w += s->qbeg + s->len - end;\n\t\tend = end > s->qbeg + s->len? end : s->qbeg + s->len;\n\t}\n\ttmp = w; w = 0;\n\tfor (j = 0, end = 0; j < c->n; ++j) {\n\t\tconst mem_seed_t *s = &c->seeds[j];\n\t\tif (s->rbeg >= end) w += s->len;\n\t\telse if (s->rbeg + s->len > end) w += s->rbeg + s->len - end;\n\t\tend = end > s->rbeg + s->len? end : s->rbeg + s->len;\n\t}\n\tw = w < tmp? w : tmp;\n\treturn w < 1<<30? w : (1<<30)-1;\n}", "idx": 226}
{"project": "BWA", "commit_id": "47_BWA_0.7.17_bwamem.c_mem_print_chain.c", "target": 0, "func": "void mem_print_chain(const bntseq_t *bns, mem_chain_v *chn)\n{\n\tint i, j;\n\tfor (i = 0; i < chn->n; ++i) {\n\t\tmem_chain_t *p = &chn->a[i];\n\t\terr_printf(\"* Found CHAIN(%d): n=%d; weight=%d\", i, p->n, mem_chain_weight(p));\n\t\tfor (j = 0; j < p->n; ++j) {\n\t\t\tbwtint_t pos;\n\t\t\tint is_rev;\n\t\t\tpos = bns_depos(bns, p->seeds[j].rbeg, &is_rev);\n\t\t\tif (is_rev) pos -= p->seeds[j].len - 1;\n\t\t\terr_printf(\"\\t%d;%d;%d,%ld(%s:%c%ld)\", p->seeds[j].score, p->seeds[j].len, p->seeds[j].qbeg, (long)p->seeds[j].rbeg, bns->anns[p->rid].name, \"+-\"[is_rev], (long)(pos - bns->anns[p->rid].offset) + 1);\n\t\t}\n\t\terr_putchar('\\n');\n\t}\n}", "idx": 227}
{"project": "BWA", "commit_id": "48_BWA_0.7.17_bwamem.c_mem_patch_reg.c", "target": 0, "func": "int mem_patch_reg(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, uint8_t *query, const mem_alnreg_t *a, const mem_alnreg_t *b, int *_w)\n{\n\tint w, score, q_s, r_s;\n\tdouble r;\n\tif (bns == 0 || pac == 0 || query == 0) return 0;\n\tassert(a->rid == b->rid && a->rb <= b->rb);\n\tif (a->rb < bns->l_pac && b->rb >= bns->l_pac) return 0; // on different strands\n\tif (a->qb >= b->qb || a->qe >= b->qe || a->re >= b->re) return 0; // not colinear\n\tw = (a->re - b->rb) - (a->qe - b->qb); // required bandwidth\n\tw = w > 0? w : -w; // l = abs(l)\n\tr = (double)(a->re - b->rb) / (b->re - a->rb) - (double)(a->qe - b->qb) / (b->qe - a->qb); // relative bandwidth\n\tr = r > 0.? r : -r; // r = fabs(r)\n\tif (bwa_verbose >= 4)\n\t\tprintf(\"* potential hit merge between [%d,%d)<=>[%ld,%ld) and [%d,%d)<=>[%ld,%ld), @ %s; w=%d, r=%.4g\\n\",\n\t\t\t   a->qb, a->qe, (long)a->rb, (long)a->re, b->qb, b->qe, (long)b->rb, (long)b->re, bns->anns[a->rid].name, w, r);\n\tif (a->re < b->rb || a->qe < b->qb) { // no overlap on query or on ref\n\t\tif (w > opt->w<<1 || r >= PATCH_MAX_R_BW) return 0; // the bandwidth or the relative bandwidth is too large\n\t} else if (w > opt->w<<2 || r >= PATCH_MAX_R_BW*2) return 0; // more permissive if overlapping on both ref and query\n\t// global alignment\n\tw += a->w + b->w;\n\tw = w < opt->w<<2? w : opt->w<<2;\n\tif (bwa_verbose >= 4) printf(\"* test potential hit merge with global alignment; w=%d\\n\", w);\n\tbwa_gen_cigar2(opt->mat, opt->o_del, opt->e_del, opt->o_ins, opt->e_ins, w, bns->l_pac, pac, b->qe - a->qb, query + a->qb, a->rb, b->re, &score, 0, 0);\n\tq_s = (int)((double)(b->qe - a->qb) / ((b->qe - b->qb) + (a->qe - a->qb)) * (b->score + a->score) + .499); // predicted score from query\n\tr_s = (int)((double)(b->re - a->rb) / ((b->re - b->rb) + (a->re - a->rb)) * (b->score + a->score) + .499); // predicted score from ref\n\tif (bwa_verbose >= 4) printf(\"* score=%d;(%d,%d)\\n\", score, q_s, r_s);\n\tif ((double)score / (q_s > r_s? q_s : r_s) < PATCH_MIN_SC_RATIO) return 0;\n\t*_w = w;\n\treturn score;\n}", "idx": 228}
{"project": "BWA", "commit_id": "49_BWA_0.7.17_bwamem.c_mem_seed_sw.c", "target": 0, "func": "int mem_seed_sw(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, int l_query, const uint8_t *query, const mem_seed_t *s)\n{\n\tint qb, qe, rid;\n\tint64_t rb, re, mid, l_pac = bns->l_pac;\n\tuint8_t *rseq = 0;\n\tkswr_t x;\n\n\tif (s->len >= MEM_SHORT_LEN) return -1; // the seed is longer than the max-extend; no need to do SW\n\tqb = s->qbeg, qe = s->qbeg + s->len;\n\trb = s->rbeg, re = s->rbeg + s->len;\n\tmid = (rb + re) >> 1;\n\tqb -= MEM_SHORT_EXT; qb = qb > 0? qb : 0;\n\tqe += MEM_SHORT_EXT; qe = qe < l_query? qe : l_query;\n\trb -= MEM_SHORT_EXT; rb = rb > 0? rb : 0;\n\tre += MEM_SHORT_EXT; re = re < l_pac<<1? re : l_pac<<1;\n\tif (rb < l_pac && l_pac < re) {\n\t\tif (mid < l_pac) re = l_pac;\n\t\telse rb = l_pac;\n\t}\n\tif (qe - qb >= MEM_SHORT_LEN || re - rb >= MEM_SHORT_LEN) return -1; // the seed seems good enough; no need to do SW\n\n\trseq = bns_fetch_seq(bns, pac, &rb, mid, &re, &rid);\n\tx = ksw_align2(qe - qb, (uint8_t*)query + qb, re - rb, rseq, 5, opt->mat, opt->o_del, opt->e_del, opt->o_ins, opt->e_ins, KSW_XSTART, 0);\n\tfree(rseq);\n\treturn x.score;\n}", "idx": 229}
{"project": "BWA", "commit_id": "4_BWA_0.7.17_bamlite.c_bam_swap_endian_4.c", "target": 0, "func": "static inline uint32_t bam_swap_endian_4(uint32_t v)\n{\n\tv = ((v & 0x0000FFFFU) << 16) | (v >> 16);\n\treturn ((v & 0x00FF00FFU) << 8) | ((v & 0xFF00FF00U) >> 8);\n}", "idx": 230}
{"project": "BWA", "commit_id": "50_BWA_0.7.17_bwamem.c_cal_max_gap.c", "target": 0, "func": "static inline int cal_max_gap(const mem_opt_t *opt, int qlen)\n{\n\tint l_del = (int)((double)(qlen * opt->a - opt->o_del) / opt->e_del + 1.);\n\tint l_ins = (int)((double)(qlen * opt->a - opt->o_ins) / opt->e_ins + 1.);\n\tint l = l_del > l_ins? l_del : l_ins;\n\tl = l > 1? l : 1;\n\treturn l < opt->w<<1? l : opt->w<<1;\n}", "idx": 231}
{"project": "BWA", "commit_id": "51_BWA_0.7.17_bwamem.c_infer_bw.c", "target": 0, "func": "static inline int infer_bw(int l1, int l2, int score, int a, int q, int r)\n{\n\tint w;\n\tif (l1 == l2 && l1 * a - score < (q + r - a)<<1) return 0; // to get equal alignment length, we need at least two gaps\n\tw = ((double)((l1 < l2? l1 : l2) * a - score - q) / r + 2.);\n\tif (w < abs(l1 - l2)) w = abs(l1 - l2);\n\treturn w;\n}", "idx": 232}
{"project": "BWA", "commit_id": "52_BWA_0.7.17_bwamem.c_get_rlen.c", "target": 0, "func": "static inline int get_rlen(int n_cigar, const uint32_t *cigar)\n{\n\tint k, l;\n\tfor (k = l = 0; k < n_cigar; ++k) {\n\t\tint op = cigar[k]&0xf;\n\t\tif (op == 0 || op == 2)\n\t\t\tl += cigar[k]>>4;\n\t}\n\treturn l;\n}", "idx": 233}
{"project": "BWA", "commit_id": "53_BWA_0.7.17_bwamem.c_add_cigar.c", "target": 1, "func": "static inline void add_cigar(const mem_opt_t *opt, mem_aln_t *p, kstring_t *str, int which)\n{\n\tint i;\n\tif (p->n_cigar) { // aligned\n\t\tfor (i = 0; i < p->n_cigar; ++i) {\n\t\t\tint c = p->cigar[i]&0xf;\n\t\t\tif (!(opt->flag&MEM_F_SOFTCLIP) && !p->is_alt && (c == 3 || c == 4))\n\t\t\t\tc = which? 4 : 3; // use hard clipping for supplementary alignments\n\t\t\tkputw(p->cigar[i]>>4, str); kputc(\"MIDSH\"[c], str);\n\t\t}\n\t} else kputc('*', str); // having a coordinate but unaligned (e.g. when copy_mate is true)\n}", "idx": 234}
{"project": "BWA", "commit_id": "54_BWA_0.7.17_bwamem.c_mem_approx_mapq_se.c", "target": 0, "func": "int mem_approx_mapq_se(const mem_opt_t *opt, const mem_alnreg_t *a)\n{\n\tint mapq, l, sub = a->sub? a->sub : opt->min_seed_len * opt->a;\n\tdouble identity;\n\tsub = a->csub > sub? a->csub : sub;\n\tif (sub >= a->score) return 0;\n\tl = a->qe - a->qb > a->re - a->rb? a->qe - a->qb : a->re - a->rb;\n\tidentity = 1. - (double)(l * opt->a - a->score) / (opt->a + opt->b) / l;\n\tif (a->score == 0) {\n\t\tmapq = 0;\n\t} else if (opt->mapQ_coef_len > 0) {\n\t\tdouble tmp;\n\t\ttmp = l < opt->mapQ_coef_len? 1. : opt->mapQ_coef_fac / log(l);\n\t\ttmp *= identity * identity;\n\t\tmapq = (int)(6.02 * (a->score - sub) / opt->a * tmp * tmp + .499);\n\t} else {\n\t\tmapq = (int)(MEM_MAPQ_COEF * (1. - (double)sub / a->score) * log(a->seedcov) + .499);\n\t\tmapq = identity < 0.95? (int)(mapq * identity * identity + .499) : mapq;\n\t}\n\tif (a->sub_n > 0) mapq -= (int)(4.343 * log(a->sub_n+1) + .499);\n\tif (mapq > 60) mapq = 60;\n\tif (mapq < 0) mapq = 0;\n\tmapq = (int)(mapq * (1. - a->frac_rep) + .499);\n\treturn mapq;\n}", "idx": 235}
{"project": "BWA", "commit_id": "55_BWA_0.7.17_bwamem.c_mem_reorder_primary5.c", "target": 0, "func": "void mem_reorder_primary5(int T, mem_alnreg_v *a)\n{\n\tint k, n_pri = 0, left_st = INT_MAX, left_k = -1;\n\tmem_alnreg_t t;\n\tfor (k = 0; k < a->n; ++k)\n\t\tif (a->a[k].secondary < 0 && !a->a[k].is_alt && a->a[k].score >= T) ++n_pri;\n\tif (n_pri <= 1) return; // only one alignment\n\tfor (k = 0; k < a->n; ++k) {\n\t\tmem_alnreg_t *p = &a->a[k];\n\t\tif (p->secondary >= 0 || p->is_alt || p->score < T) continue;\n\t\tif (p->qb < left_st) left_st = p->qb, left_k = k;\n\t}\n\tassert(a->a[0].secondary < 0);\n\tif (left_k == 0) return; // no need to reorder\n\tt = a->a[0], a->a[0] = a->a[left_k], a->a[left_k] = t;\n\tfor (k = 1; k < a->n; ++k) { // update secondary and secondary_all\n\t\tmem_alnreg_t *p = &a->a[k];\n\t\tif (p->secondary == 0) p->secondary = left_k;\n\t\telse if (p->secondary == left_k) p->secondary = 0;\n\t\tif (p->secondary_all == 0) p->secondary_all = left_k;\n\t\telse if (p->secondary_all == left_k) p->secondary_all = 0;\n\t}\n}", "idx": 236}
{"project": "BWA", "commit_id": "56_BWA_0.7.17_bwamem.c_mem_reg2sam.c", "target": 1, "func": "void mem_reg2sam(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, bseq1_t *s, mem_alnreg_v *a, int extra_flag, const mem_aln_t *m)\n{\n\textern char **mem_gen_alt(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, mem_alnreg_v *a, int l_query, const char *query);\n\tkstring_t str;\n\tkvec_t(mem_aln_t) aa;\n\tint k, l;\n\tchar **XA = 0;\n\n\tif (!(opt->flag & MEM_F_ALL))\n\t\tXA = mem_gen_alt(opt, bns, pac, a, s->l_seq, s->seq);\n\tkv_init(aa);\n\tstr.l = str.m = 0; str.s = 0;\n\tfor (k = l = 0; k < a->n; ++k) {\n\t\tmem_alnreg_t *p = &a->a[k];\n\t\tmem_aln_t *q;\n\t\tif (p->score < opt->T) continue;\n\t\tif (p->secondary >= 0 && (p->is_alt || !(opt->flag&MEM_F_ALL))) continue;\n\t\tif (p->secondary >= 0 && p->secondary < INT_MAX && p->score < a->a[p->secondary].score * opt->drop_ratio) continue;\n\t\tq = kv_pushp(mem_aln_t, aa);\n\t\t*q = mem_reg2aln(opt, bns, pac, s->l_seq, s->seq, p);\n\t\tassert(q->rid >= 0); // this should not happen with the new code\n\t\tq->XA = XA? XA[k] : 0;\n\t\tq->flag |= extra_flag; // flag secondary\n\t\tif (p->secondary >= 0) q->sub = -1; // don't output sub-optimal score\n\t\tif (l && p->secondary < 0) // if supplementary\n\t\t\tq->flag |= (opt->flag&MEM_F_NO_MULTI)? 0x10000 : 0x800;\n\t\tif (!(opt->flag & MEM_F_KEEP_SUPP_MAPQ) && l && !p->is_alt && q->mapq > aa.a[0].mapq)\n\t\t\tq->mapq = aa.a[0].mapq; // lower mapq for supplementary mappings, unless -5 or -q is applied\n\t\t++l;\n\t}\n\tif (aa.n == 0) { // no alignments good enough; then write an unaligned record\n\t\tmem_aln_t t;\n\t\tt = mem_reg2aln(opt, bns, pac, s->l_seq, s->seq, 0);\n\t\tt.flag |= extra_flag;\n\t\tmem_aln2sam(opt, bns, &str, s, 1, &t, 0, m);\n\t} else {\n\t\tfor (k = 0; k < aa.n; ++k)\n\t\t\tmem_aln2sam(opt, bns, &str, s, aa.n, aa.a, k, m);\n\t\tfor (k = 0; k < aa.n; ++k) free(aa.a[k].cigar);\n\t\tfree(aa.a);\n\t}\n\ts->sam = str.s;\n\tif (XA) {\n\t\tfor (k = 0; k < a->n; ++k) free(XA[k]);\n\t\tfree(XA);\n\t}\n}", "idx": 237}
{"project": "BWA", "commit_id": "57_BWA_0.7.17_bwamem.c_mem_align1_core.c", "target": 0, "func": "mem_alnreg_v mem_align1_core(const mem_opt_t *opt, const bwt_t *bwt, const bntseq_t *bns, const uint8_t *pac, int l_seq, char *seq, void *buf)\n{\n\tint i;\n\tmem_chain_v chn;\n\tmem_alnreg_v regs;\n\n\tfor (i = 0; i < l_seq; ++i) // convert to 2-bit encoding if we have not done so\n\t\tseq[i] = seq[i] < 4? seq[i] : nst_nt4_table[(int)seq[i]];\n\n\tchn = mem_chain(opt, bwt, bns, l_seq, (uint8_t*)seq, buf);\n\tchn.n = mem_chain_flt(opt, chn.n, chn.a);\n\tmem_flt_chained_seeds(opt, bns, pac, l_seq, (uint8_t*)seq, chn.n, chn.a);\n\tif (bwa_verbose >= 4) mem_print_chain(bns, &chn);\n\n\tkv_init(regs);\n\tfor (i = 0; i < chn.n; ++i) {\n\t\tmem_chain_t *p = &chn.a[i];\n\t\tif (bwa_verbose >= 4) err_printf(\"* ---> Processing chain(%d) <---\\n\", i);\n\t\tmem_chain2aln(opt, bns, pac, l_seq, (uint8_t*)seq, p, &regs);\n\t\tfree(chn.a[i].seeds);\n\t}\n\tfree(chn.a);\n\tregs.n = mem_sort_dedup_patch(opt, bns, pac, (uint8_t*)seq, regs.n, regs.a);\n\tif (bwa_verbose >= 4) {\n\t\terr_printf(\"* %ld chains remain after removing duplicated chains\\n\", regs.n);\n\t\tfor (i = 0; i < regs.n; ++i) {\n\t\t\tmem_alnreg_t *p = &regs.a[i];\n\t\t\tprintf(\"** %d, [%d,%d) <=> [%ld,%ld)\\n\", p->score, p->qb, p->qe, (long)p->rb, (long)p->re);\n\t\t}\n\t}\n\tfor (i = 0; i < regs.n; ++i) {\n\t\tmem_alnreg_t *p = &regs.a[i];\n\t\tif (p->rid >= 0 && bns->anns[p->rid].is_alt)\n\t\t\tp->is_alt = 1;\n\t}\n\treturn regs;\n}", "idx": 238}
{"project": "BWA", "commit_id": "58_BWA_0.7.17_bwamem.c_mem_reg2aln.c", "target": 0, "func": "mem_aln_t mem_reg2aln(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, int l_query, const char *query_, const mem_alnreg_t *ar)\n{\n\tmem_aln_t a;\n\tint i, w2, tmp, qb, qe, NM, score, is_rev, last_sc = -(1<<30), l_MD;\n\tint64_t pos, rb, re;\n\tuint8_t *query;\n\n\tmemset(&a, 0, sizeof(mem_aln_t));\n\tif (ar == 0 || ar->rb < 0 || ar->re < 0) { // generate an unmapped record\n\t\ta.rid = -1; a.pos = -1; a.flag |= 0x4;\n\t\treturn a;\n\t}\n\tqb = ar->qb, qe = ar->qe;\n\trb = ar->rb, re = ar->re;\n\tquery = malloc(l_query);\n\tfor (i = 0; i < l_query; ++i) // convert to the nt4 encoding\n\t\tquery[i] = query_[i] < 5? query_[i] : nst_nt4_table[(int)query_[i]];\n\ta.mapq = ar->secondary < 0? mem_approx_mapq_se(opt, ar) : 0;\n\tif (ar->secondary >= 0) a.flag |= 0x100; // secondary alignment\n\ttmp = infer_bw(qe - qb, re - rb, ar->truesc, opt->a, opt->o_del, opt->e_del);\n\tw2  = infer_bw(qe - qb, re - rb, ar->truesc, opt->a, opt->o_ins, opt->e_ins);\n\tw2 = w2 > tmp? w2 : tmp;\n\tif (bwa_verbose >= 4) printf(\"* Band width: inferred=%d, cmd_opt=%d, alnreg=%d\\n\", w2, opt->w, ar->w);\n\tif (w2 > opt->w) w2 = w2 < ar->w? w2 : ar->w;\n\ti = 0; a.cigar = 0;\n\tdo {\n\t\tfree(a.cigar);\n\t\tw2 = w2 < opt->w<<2? w2 : opt->w<<2;\n\t\ta.cigar = bwa_gen_cigar2(opt->mat, opt->o_del, opt->e_del, opt->o_ins, opt->e_ins, w2, bns->l_pac, pac, qe - qb, (uint8_t*)&query[qb], rb, re, &score, &a.n_cigar, &NM);\n\t\tif (bwa_verbose >= 4) printf(\"* Final alignment: w2=%d, global_sc=%d, local_sc=%d\\n\", w2, score, ar->truesc);\n\t\tif (score == last_sc || w2 == opt->w<<2) break; // it is possible that global alignment and local alignment give different scores\n\t\tlast_sc = score;\n\t\tw2 <<= 1;\n\t} while (++i < 3 && score < ar->truesc - opt->a);\n\tl_MD = strlen((char*)(a.cigar + a.n_cigar)) + 1;\n\ta.NM = NM;\n\tpos = bns_depos(bns, rb < bns->l_pac? rb : re - 1, &is_rev);\n\ta.is_rev = is_rev;\n\tif (a.n_cigar > 0) { // squeeze out leading or trailing deletions\n\t\tif ((a.cigar[0]&0xf) == 2) {\n\t\t\tpos += a.cigar[0]>>4;\n\t\t\t--a.n_cigar;\n\t\t\tmemmove(a.cigar, a.cigar + 1, a.n_cigar * 4 + l_MD);\n\t\t} else if ((a.cigar[a.n_cigar-1]&0xf) == 2) {\n\t\t\t--a.n_cigar;\n\t\t\tmemmove(a.cigar + a.n_cigar, a.cigar + a.n_cigar + 1, l_MD); // MD needs to be moved accordingly\n\t\t}\n\t}\n\tif (qb != 0 || qe != l_query) { // add clipping to CIGAR\n\t\tint clip5, clip3;\n\t\tclip5 = is_rev? l_query - qe : qb;\n\t\tclip3 = is_rev? qb : l_query - qe;\n\t\ta.cigar = realloc(a.cigar, 4 * (a.n_cigar + 2) + l_MD);\n\t\tif (clip5) {\n\t\t\tmemmove(a.cigar+1, a.cigar, a.n_cigar * 4 + l_MD); // make room for 5'-end clipping\n\t\t\ta.cigar[0] = clip5<<4 | 3;\n\t\t\t++a.n_cigar;\n\t\t}\n\t\tif (clip3) {\n\t\t\tmemmove(a.cigar + a.n_cigar + 1, a.cigar + a.n_cigar, l_MD); // make room for 3'-end clipping\n\t\t\ta.cigar[a.n_cigar++] = clip3<<4 | 3;\n\t\t}\n\t}\n\ta.rid = bns_pos2rid(bns, pos);\n\tassert(a.rid == ar->rid);\n\ta.pos = pos - bns->anns[a.rid].offset;\n\ta.score = ar->score; a.sub = ar->sub > ar->csub? ar->sub : ar->csub;\n\ta.is_alt = ar->is_alt; a.alt_sc = ar->alt_sc;\n\tfree(query);\n\treturn a;\n}", "idx": 239}
{"project": "BWA", "commit_id": "59_BWA_0.7.17_bwamem.c_worker1.c", "target": 1, "func": "static void worker1(void *data, int i, int tid)\n{\n\tworker_t *w = (worker_t*)data;\n\tif (!(w->opt->flag&MEM_F_PE)) {\n\t\tif (bwa_verbose >= 4) printf(\"=====> Processing read '%s' <=====\\n\", w->seqs[i].name);\n\t\tw->regs[i] = mem_align1_core(w->opt, w->bwt, w->bns, w->pac, w->seqs[i].l_seq, w->seqs[i].seq, w->aux[tid]);\n\t} else {\n\t\tif (bwa_verbose >= 4) printf(\"=====> Processing read '%s'/1 <=====\\n\", w->seqs[i<<1|0].name);\n\t\tw->regs[i<<1|0] = mem_align1_core(w->opt, w->bwt, w->bns, w->pac, w->seqs[i<<1|0].l_seq, w->seqs[i<<1|0].seq, w->aux[tid]);\n\t\tif (bwa_verbose >= 4) printf(\"=====> Processing read '%s'/2 <=====\\n\", w->seqs[i<<1|1].name);\n\t\tw->regs[i<<1|1] = mem_align1_core(w->opt, w->bwt, w->bns, w->pac, w->seqs[i<<1|1].l_seq, w->seqs[i<<1|1].seq, w->aux[tid]);\n\t}\n}", "idx": 240}
{"project": "BWA", "commit_id": "5_BWA_0.7.17_bamlite.c_bam_swap_endian_4p.c", "target": 0, "func": "static inline void *bam_swap_endian_4p(void *x)\n{\n\t*(uint32_t*)x = bam_swap_endian_4(*(uint32_t*)x);\n\treturn x;\n}", "idx": 241}
{"project": "BWA", "commit_id": "60_BWA_0.7.17_bwamem.c_worker2.c", "target": 1, "func": "static void worker2(void *data, int i, int tid)\n{\n\textern int mem_sam_pe(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, const mem_pestat_t pes[4], uint64_t id, bseq1_t s[2], mem_alnreg_v a[2]);\n\textern void mem_reg2ovlp(const mem_opt_t *opt, const bntseq_t *bns, const uint8_t *pac, bseq1_t *s, mem_alnreg_v *a);\n\tworker_t *w = (worker_t*)data;\n\tif (!(w->opt->flag&MEM_F_PE)) {\n\t\tif (bwa_verbose >= 4) printf(\"=====> Finalizing read '%s' <=====\\n\", w->seqs[i].name);\n\t\tmem_mark_primary_se(w->opt, w->regs[i].n, w->regs[i].a, w->n_processed + i);\n\t\tif (w->opt->flag & MEM_F_PRIMARY5) mem_reorder_primary5(w->opt->T, &w->regs[i]);\n\t\tmem_reg2sam(w->opt, w->bns, w->pac, &w->seqs[i], &w->regs[i], 0, 0);\n\t\tfree(w->regs[i].a);\n\t} else {\n\t\tif (bwa_verbose >= 4) printf(\"=====> Finalizing read pair '%s' <=====\\n\", w->seqs[i<<1|0].name);\n\t\tmem_sam_pe(w->opt, w->bns, w->pac, w->pes, (w->n_processed>>1) + i, &w->seqs[i<<1], &w->regs[i<<1]);\n\t\tfree(w->regs[i<<1|0].a); free(w->regs[i<<1|1].a);\n\t}\n}", "idx": 242}
{"project": "BWA", "commit_id": "61_BWA_0.7.17_bwamem.c_mem_process_seqs.c", "target": 0, "func": "void mem_process_seqs(const mem_opt_t *opt, const bwt_t *bwt, const bntseq_t *bns, const uint8_t *pac, int64_t n_processed, int n, bseq1_t *seqs, const mem_pestat_t *pes0)\n{\n\textern void kt_for(int n_threads, void (*func)(void*,int,int), void *data, int n);\n\tworker_t w;\n\tmem_pestat_t pes[4];\n\tdouble ctime, rtime;\n\tint i;\n\n\tctime = cputime(); rtime = realtime();\n\tglobal_bns = bns;\n\tw.regs = malloc(n * sizeof(mem_alnreg_v));\n\tw.opt = opt; w.bwt = bwt; w.bns = bns; w.pac = pac;\n\tw.seqs = seqs; w.n_processed = n_processed;\n\tw.pes = &pes[0];\n\tw.aux = malloc(opt->n_threads * sizeof(smem_aux_t));\n\tfor (i = 0; i < opt->n_threads; ++i)\n\t\tw.aux[i] = smem_aux_init();\n\tkt_for(opt->n_threads, worker1, &w, (opt->flag&MEM_F_PE)? n>>1 : n); // find mapping positions\n\tfor (i = 0; i < opt->n_threads; ++i)\n\t\tsmem_aux_destroy(w.aux[i]);\n\tfree(w.aux);\n\tif (opt->flag&MEM_F_PE) { // infer insert sizes if not provided\n\t\tif (pes0) memcpy(pes, pes0, 4 * sizeof(mem_pestat_t)); // if pes0 != NULL, set the insert-size distribution as pes0\n\t\telse mem_pestat(opt, bns->l_pac, n, w.regs, pes); // otherwise, infer the insert size distribution from data\n\t}\n\tkt_for(opt->n_threads, worker2, &w, (opt->flag&MEM_F_PE)? n>>1 : n); // generate alignment\n\tfree(w.regs);\n\tif (bwa_verbose >= 3)\n\t\tfprintf(stderr, \"[M::%s] Processed %d reads in %.3f CPU sec, %.3f real sec\\n\", __func__, n, cputime() - ctime, realtime() - rtime);\n}", "idx": 243}
{"project": "BWA", "commit_id": "62_BWA_0.7.17_bwamem_extra.c_smem_itr_init.c", "target": 0, "func": "smem_i *smem_itr_init(const bwt_t *bwt)\n{\n\tsmem_i *itr;\n\titr = calloc(1, sizeof(smem_i));\n\titr->bwt = bwt;\n\titr->tmpvec[0] = calloc(1, sizeof(bwtintv_v));\n\titr->tmpvec[1] = calloc(1, sizeof(bwtintv_v));\n\titr->matches   = calloc(1, sizeof(bwtintv_v));\n\titr->sub       = calloc(1, sizeof(bwtintv_v));\n\titr->min_intv = 1;\n\titr->max_len  = INT_MAX;\n\titr->max_intv = 0;\n\treturn itr;\n}", "idx": 244}
{"project": "BWA", "commit_id": "63_BWA_0.7.17_bwamem_extra.c_smem_itr_destroy.c", "target": 0, "func": "void smem_itr_destroy(smem_i *itr)\n{\n\tfree(itr->tmpvec[0]->a); free(itr->tmpvec[0]);\n\tfree(itr->tmpvec[1]->a); free(itr->tmpvec[1]);\n\tfree(itr->matches->a);   free(itr->matches);\n\tfree(itr->sub->a);       free(itr->sub);\n\tfree(itr);\n}", "idx": 245}
{"project": "BWA", "commit_id": "64_BWA_0.7.17_bwamem_extra.c_smem_set_query.c", "target": 0, "func": "void smem_set_query(smem_i *itr, int len, const uint8_t *query)\n{\n\titr->query = query;\n\titr->start = 0;\n\titr->len = len;\n}", "idx": 246}
{"project": "BWA", "commit_id": "65_BWA_0.7.17_bwamem_extra.c_smem_config.c", "target": 0, "func": "void smem_config(smem_i *itr, int min_intv, int max_len, uint64_t max_intv)\n{\n\titr->min_intv = min_intv;\n\titr->max_len  = max_len;\n\titr->max_intv = max_intv;\n}", "idx": 247}
{"project": "BWA", "commit_id": "66_BWA_0.7.17_bwamem_extra.c_smem_next.c", "target": 0, "func": "const bwtintv_v *smem_next(smem_i *itr)\n{\n\tint ori_start;\n\titr->tmpvec[0]->n = itr->tmpvec[1]->n = itr->matches->n = itr->sub->n = 0;\n\tif (itr->start >= itr->len || itr->start < 0) return 0;\n\twhile (itr->start < itr->len && itr->query[itr->start] > 3) ++itr->start; // skip ambiguous bases\n\tif (itr->start == itr->len) return 0;\n\tori_start = itr->start;\n\titr->start = bwt_smem1a(itr->bwt, itr->len, itr->query, ori_start, itr->min_intv, itr->max_intv, itr->matches, itr->tmpvec); // search for SMEM\n\treturn itr->matches;\n}", "idx": 248}
{"project": "BWA", "commit_id": "67_BWA_0.7.17_bwamem_extra.c_mem_align1.c", "target": 0, "func": "mem_alnreg_v mem_align1(const mem_opt_t *opt, const bwt_t *bwt, const bntseq_t *bns, const uint8_t *pac, int l_seq, const char *seq_)\n{ // the difference from mem_align1_core() is that this routine: 1) calls mem_mark_primary_se(); 2) does not modify the input sequence\n\textern mem_alnreg_v mem_align1_core(const mem_opt_t *opt, const bwt_t *bwt, const bntseq_t *bns, const uint8_t *pac, int l_seq, char *seq, void *buf);\n\textern void mem_mark_primary_se(const mem_opt_t *opt, int n, mem_alnreg_t *a, int64_t id);\n\tmem_alnreg_v ar;\n\tchar *seq;\n\tseq = malloc(l_seq);\n\tmemcpy(seq, seq_, l_seq); // makes a copy of seq_\n\tar = mem_align1_core(opt, bwt, bns, pac, l_seq, seq, 0);\n\tmem_mark_primary_se(opt, ar.n, ar.a, lrand48());\n\tfree(seq);\n\treturn ar;\n}", "idx": 249}
{"project": "BWA", "commit_id": "68_BWA_0.7.17_bwamem_extra.c_get_pri_idx.c", "target": 0, "func": "static inline int get_pri_idx(double XA_drop_ratio, const mem_alnreg_t *a, int i)\n{\n\tint k = a[i].secondary_all;\n\tif (k >= 0 && a[i].score >= a[k].score * XA_drop_ratio) return k;\n\treturn -1;\n}", "idx": 250}
{"project": "BWA", "commit_id": "69_BWA_0.7.17_bwamem_extra.c_mem_mark_primary_se.c", "target": 0, "func": "ONLY work after mem_mark_primary_se()\n{\n\tint i, k, r, *cnt, tot;\n\tkstring_t *aln = 0, str = {0,0,0};\n\tchar **XA = 0, *has_alt;\n\n\tcnt = calloc(a->n, sizeof(int));\n\thas_alt = calloc(a->n, 1);\n\tfor (i = 0, tot = 0; i < a->n; ++i) {\n\t\tr = get_pri_idx(opt->XA_drop_ratio, a->a, i);\n\t\tif (r >= 0) {\n\t\t\t++cnt[r], ++tot;\n\t\t\tif (a->a[i].is_alt) has_alt[r] = 1;\n\t\t}\n\t}\n\tif (tot == 0) goto end_gen_alt;\n\taln = calloc(a->n, sizeof(kstring_t));\n\tfor (i = 0; i < a->n; ++i) {\n\t\tmem_aln_t t;\n\t\tif ((r = get_pri_idx(opt->XA_drop_ratio, a->a, i)) < 0) continue;\n\t\tif (cnt[r] > opt->max_XA_hits_alt || (!has_alt[r] && cnt[r] > opt->max_XA_hits)) continue;\n\t\tt = mem_reg2aln(opt, bns, pac, l_query, query, &a->a[i]);\n\t\tstr.l = 0;\n\t\tkputs(bns->anns[t.rid].name, &str);\n\t\tkputc(',', &str); kputc(\"+-\"[t.is_rev], &str); kputl(t.pos + 1, &str);\n\t\tkputc(',', &str);\n\t\tfor (k = 0; k < t.n_cigar; ++k) {\n\t\t\tkputw(t.cigar[k]>>4, &str);\n\t\t\tkputc(\"MIDSHN\"[t.cigar[k]&0xf], &str);\n\t\t}\n\t\tkputc(',', &str); kputw(t.NM, &str);\n\t\tkputc(';', &str);\n\t\tfree(t.cigar);\n\t\tkputsn(str.s, str.l, &aln[r]);\n\t}\n\tXA = calloc(a->n, sizeof(char*));\n\tfor (k = 0; k < a->n; ++k)\n\t\tXA[k] = aln[k].s;\n\nend_gen_alt:\n\tfree(has_alt); free(cnt); free(aln); free(str.s);\n\treturn XA;\n}", "idx": 251}
{"project": "BWA", "commit_id": "6_BWA_0.7.17_bamlite.c_bam_swap_endian_8.c", "target": 0, "func": "static inline uint64_t bam_swap_endian_8(uint64_t v)\n{\n\tv = ((v & 0x00000000FFFFFFFFLLU) << 32) | (v >> 32);\n\tv = ((v & 0x0000FFFF0000FFFFLLU) << 16) | ((v & 0xFFFF0000FFFF0000LLU) >> 16);\n\treturn ((v & 0x00FF00FF00FF00FFLLU) << 8) | ((v & 0xFF00FF00FF00FF00LLU) >> 8);\n}", "idx": 252}
{"project": "BWA", "commit_id": "70_BWA_0.7.17_bwamem_pair.c_mem_infer_dir.c", "target": 0, "func": "static inline int mem_infer_dir(int64_t l_pac, int64_t b1, int64_t b2, int64_t *dist)\n{\n\tint64_t p2;\n\tint r1 = (b1 >= l_pac), r2 = (b2 >= l_pac);\n\tp2 = r1 == r2? b2 : (l_pac<<1) - 1 - b2; // p2 is the coordinate of read 2 on the read 1 strand\n\t*dist = p2 > b1? p2 - b1 : b1 - p2;\n\treturn (r1 == r2? 0 : 1) ^ (p2 > b1? 0 : 3);\n}", "idx": 253}
{"project": "BWA", "commit_id": "71_BWA_0.7.17_bwamem_pair.c_cal_sub.c", "target": 0, "func": "static int cal_sub(const mem_opt_t *opt, mem_alnreg_v *r)\n{\n\tint j;\n\tfor (j = 1; j < r->n; ++j) { // choose unique alignment\n\t\tint b_max = r->a[j].qb > r->a[0].qb? r->a[j].qb : r->a[0].qb;\n\t\tint e_min = r->a[j].qe < r->a[0].qe? r->a[j].qe : r->a[0].qe;\n\t\tif (e_min > b_max) { // have overlap\n\t\t\tint min_l = r->a[j].qe - r->a[j].qb < r->a[0].qe - r->a[0].qb? r->a[j].qe - r->a[j].qb : r->a[0].qe - r->a[0].qb;\n\t\t\tif (e_min - b_max >= min_l * opt->mask_level) break; // significant overlap\n\t\t}\n\t}\n\treturn j < r->n? r->a[j].score : opt->min_seed_len * opt->a;\n}", "idx": 254}
{"project": "BWA", "commit_id": "72_BWA_0.7.17_bwamem_pair.c_mem_pestat.c", "target": 0, "func": "void mem_pestat(const mem_opt_t *opt, int64_t l_pac, int n, const mem_alnreg_v *regs, mem_pestat_t pes[4])\n{\n\tint i, d, max;\n\tuint64_v isize[4];\n\tmemset(pes, 0, 4 * sizeof(mem_pestat_t));\n\tmemset(isize, 0, sizeof(kvec_t(int)) * 4);\n\tfor (i = 0; i < n>>1; ++i) {\n\t\tint dir;\n\t\tint64_t is;\n\t\tmem_alnreg_v *r[2];\n\t\tr[0] = (mem_alnreg_v*)&regs[i<<1|0];\n\t\tr[1] = (mem_alnreg_v*)&regs[i<<1|1];\n\t\tif (r[0]->n == 0 || r[1]->n == 0) continue;\n\t\tif (cal_sub(opt, r[0]) > MIN_RATIO * r[0]->a[0].score) continue;\n\t\tif (cal_sub(opt, r[1]) > MIN_RATIO * r[1]->a[0].score) continue;\n\t\tif (r[0]->a[0].rid != r[1]->a[0].rid) continue; // not on the same chr\n\t\tdir = mem_infer_dir(l_pac, r[0]->a[0].rb, r[1]->a[0].rb, &is);\n\t\tif (is && is <= opt->max_ins) kv_push(uint64_t, isize[dir], is);\n\t}\n\tif (bwa_verbose >= 3) fprintf(stderr, \"[M::%s] # candidate unique pairs for (FF, FR, RF, RR): (%ld, %ld, %ld, %ld)\\n\", __func__, isize[0].n, isize[1].n, isize[2].n, isize[3].n);\n\tfor (d = 0; d < 4; ++d) { // TODO: this block is nearly identical to the one in bwtsw2_pair.c. It would be better to merge these two.\n\t\tmem_pestat_t *r = &pes[d];\n\t\tuint64_v *q = &isize[d];\n\t\tint p25, p50, p75, x;\n\t\tif (q->n < MIN_DIR_CNT) {\n\t\t\tfprintf(stderr, \"[M::%s] skip orientation %c%c as there are not enough pairs\\n\", __func__, \"FR\"[d>>1&1], \"FR\"[d&1]);\n\t\t\tr->failed = 1;\n\t\t\tfree(q->a);\n\t\t\tcontinue;\n\t\t} else fprintf(stderr, \"[M::%s] analyzing insert size distribution for orientation %c%c...\\n\", __func__, \"FR\"[d>>1&1], \"FR\"[d&1]);\n\t\tks_introsort_64(q->n, q->a);\n\t\tp25 = q->a[(int)(.25 * q->n + .499)];\n\t\tp50 = q->a[(int)(.50 * q->n + .499)];\n\t\tp75 = q->a[(int)(.75 * q->n + .499)];\n\t\tr->low  = (int)(p25 - OUTLIER_BOUND * (p75 - p25) + .499);\n\t\tif (r->low < 1) r->low = 1;\n\t\tr->high = (int)(p75 + OUTLIER_BOUND * (p75 - p25) + .499);\n\t\tfprintf(stderr, \"[M::%s] (25, 50, 75) percentile: (%d, %d, %d)\\n\", __func__, p25, p50, p75);\n\t\tfprintf(stderr, \"[M::%s] low and high boundaries for computing mean and std.dev: (%d, %d)\\n\", __func__, r->low, r->high);\n\t\tfor (i = x = 0, r->avg = 0; i < q->n; ++i)\n\t\t\tif (q->a[i] >= r->low && q->a[i] <= r->high)\n\t\t\t\tr->avg += q->a[i], ++x;\n\t\tr->avg /= x;\n\t\tfor (i = 0, r->std = 0; i < q->n; ++i)\n\t\t\tif (q->a[i] >= r->low && q->a[i] <= r->high)\n\t\t\t\tr->std += (q->a[i] - r->avg) * (q->a[i] - r->avg);\n\t\tr->std = sqrt(r->std / x);\n\t\tfprintf(stderr, \"[M::%s] mean and std.dev: (%.2f, %.2f)\\n\", __func__, r->avg, r->std);\n\t\tr->low  = (int)(p25 - MAPPING_BOUND * (p75 - p25) + .499);\n\t\tr->high = (int)(p75 + MAPPING_BOUND * (p75 - p25) + .499);\n\t\tif (r->low  > r->avg - MAX_STDDEV * r->std) r->low  = (int)(r->avg - MAX_STDDEV * r->std + .499);\n\t\tif (r->high < r->avg + MAX_STDDEV * r->std) r->high = (int)(r->avg + MAX_STDDEV * r->std + .499);\n\t\tif (r->low < 1) r->low = 1;\n\t\tfprintf(stderr, \"[M::%s] low and high boundaries for proper pairs: (%d, %d)\\n\", __func__, r->low, r->high);\n\t\tfree(q->a);\n\t}\n\tfor (d = 0, max = 0; d < 4; ++d)\n\t\tmax = max > isize[d].n? max : isize[d].n;\n\tfor (d = 0; d < 4; ++d)\n\t\tif (pes[d].failed == 0 && isize[d].n < max * MIN_DIR_RATIO) {\n\t\t\tpes[d].failed = 1;\n\t\t\tfprintf(stderr, \"[M::%s] skip orientation %c%c\\n\", __func__, \"FR\"[d>>1&1], \"FR\"[d&1]);\n\t\t}\n}", "idx": 255}
{"project": "BWA", "commit_id": "73_BWA_0.7.17_bwape.c_bwa_init_pe_opt.c", "target": 0, "func": "pe_opt_t *bwa_init_pe_opt()\n{\n\tpe_opt_t *po;\n\tpo = (pe_opt_t*)calloc(1, sizeof(pe_opt_t));\n\tpo->max_isize = 500;\n\tpo->force_isize = 0;\n\tpo->max_occ = 100000;\n\tpo->n_multi = 3;\n\tpo->N_multi = 10;\n\tpo->type = BWA_PET_STD;\n\tpo->is_sw = 1;\n\tpo->ap_prior = 1e-5;\n\treturn po;\n}", "idx": 256}
{"project": "BWA", "commit_id": "74_BWA_0.7.17_bwape.c_infer_isize.c", "target": 0, "func": "static int infer_isize(int n_seqs, bwa_seq_t *seqs[2], isize_info_t *ii, double ap_prior, int64_t L)\n{\n\tuint64_t x, *isizes, n_ap = 0;\n\tint n, i, tot, p25, p75, p50, max_len = 1, tmp;\n\tdouble skewness = 0.0, kurtosis = 0.0, y;\n\n\tii->avg = ii->std = -1.0;\n\tii->low = ii->high = ii->high_bayesian = 0;\n\tisizes = (uint64_t*)calloc(n_seqs, 8);\n\tfor (i = 0, tot = 0; i != n_seqs; ++i) {\n\t\tbwa_seq_t *p[2];\n\t\tp[0] = seqs[0] + i; p[1] = seqs[1] + i;\n\t\tif (p[0]->mapQ >= 20 && p[1]->mapQ >= 20) {\n\t\t\tx = (p[0]->pos < p[1]->pos)? p[1]->pos + p[1]->len - p[0]->pos : p[0]->pos + p[0]->len - p[1]->pos;\n\t\t\tif (x < 100000) isizes[tot++] = x;\n\t\t}\n\t\tif (p[0]->len > max_len) max_len = p[0]->len;\n\t\tif (p[1]->len > max_len) max_len = p[1]->len;\n\t}\n\tif (tot < 20) {\n\t\tfprintf(stderr, \"[infer_isize] fail to infer insert size: too few good pairs\\n\");\n\t\tfree(isizes);\n\t\treturn -1;\n\t}\n\tks_introsort_64(tot, isizes);\n\tp25 = isizes[(int)(tot*0.25 + 0.5)];\n\tp50 = isizes[(int)(tot*0.50 + 0.5)];\n\tp75 = isizes[(int)(tot*0.75 + 0.5)];\n\ttmp  = (int)(p25 - OUTLIER_BOUND * (p75 - p25) + .499);\n\tii->low = tmp > max_len? tmp : max_len; // ii->low is unsigned\n\tii->high = (int)(p75 + OUTLIER_BOUND * (p75 - p25) + .499);\n\tif (ii->low > ii->high) {\n\t\tfprintf(stderr, \"[infer_isize] fail to infer insert size: upper bound is smaller than read length\\n\");\n\t\tfree(isizes);\n\t\treturn -1;\n\t}\n\tfor (i = 0, x = n = 0; i < tot; ++i)\n\t\tif (isizes[i] >= ii->low && isizes[i] <= ii->high)\n\t\t\t++n, x += isizes[i];\n\tii->avg = (double)x / n;\n\tfor (i = 0; i < tot; ++i) {\n\t\tif (isizes[i] >= ii->low && isizes[i] <= ii->high) {\n\t\t\tdouble tmp = (isizes[i] - ii->avg) * (isizes[i] - ii->avg);\n\t\t\tii->std += tmp;\n\t\t\tskewness += tmp * (isizes[i] - ii->avg);\n\t\t\tkurtosis += tmp * tmp;\n\t\t}\n\t}\n\tkurtosis = kurtosis/n / (ii->std / n * ii->std / n) - 3;\n\tii->std = sqrt(ii->std / n); // it would be better as n-1, but n is usually very large\n\tskewness = skewness / n / (ii->std * ii->std * ii->std);\n\tfor (y = 1.0; y < 10.0; y += 0.01)\n\t\tif (.5 * erfc(y / M_SQRT2) < ap_prior / L * (y * ii->std + ii->avg)) break;\n\tii->high_bayesian = (bwtint_t)(y * ii->std + ii->avg + .499);\n\tfor (i = 0; i < tot; ++i)\n\t\tif (isizes[i] > ii->high_bayesian) ++n_ap;\n\tii->ap_prior = .01 * (n_ap + .01) / tot;\n\tif (ii->ap_prior < ap_prior) ii->ap_prior = ap_prior;\n\tfree(isizes);\n\tfprintf(stderr, \"[infer_isize] (25, 50, 75) percentile: (%d, %d, %d)\\n\", p25, p50, p75);\n\tif (isnan(ii->std) || p75 > 100000) {\n\t\tii->low = ii->high = ii->high_bayesian = 0; ii->avg = ii->std = -1.0;\n\t\tfprintf(stderr, \"[infer_isize] fail to infer insert size: weird pairing\\n\");\n\t\treturn -1;\n\t}\n\tfor (y = 1.0; y < 10.0; y += 0.01)\n\t\tif (.5 * erfc(y / M_SQRT2) < ap_prior / L * (y * ii->std + ii->avg)) break;\n\tii->high_bayesian = (bwtint_t)(y * ii->std + ii->avg + .499);\n\tfprintf(stderr, \"[infer_isize] low and high boundaries: %ld and %ld for estimating avg and std\\n\", (long)ii->low, (long)ii->high);\n\tfprintf(stderr, \"[infer_isize] inferred external isize from %d pairs: %.3lf +/- %.3lf\\n\", n, ii->avg, ii->std);\n\tfprintf(stderr, \"[infer_isize] skewness: %.3lf; kurtosis: %.3lf; ap_prior: %.2e\\n\", skewness, kurtosis, ii->ap_prior);\n\tfprintf(stderr, \"[infer_isize] inferred maximum insert size: %ld (%.2lf sigma)\\n\", (long)ii->high_bayesian, y);\n\treturn 0;\n}", "idx": 257}
{"project": "BWA", "commit_id": "75_BWA_0.7.17_bwape.c_bwa_sai2sam_pe.c", "target": 0, "func": "int bwa_sai2sam_pe(int argc, char *argv[])\n{\n\tint c;\n\tpe_opt_t *popt;\n\tchar *prefix, *rg_line = 0;\n\n\tpopt = bwa_init_pe_opt();\n\twhile ((c = getopt(argc, argv, \"a:o:sPn:N:c:f:Ar:\")) >= 0) {\n\t\tswitch (c) {\n\t\tcase 'r':\n\t\t\tif ((rg_line = bwa_set_rg(optarg)) == 0) return 1;\n\t\t\tbreak;\n\t\tcase 'a': popt->max_isize = atoi(optarg); break;\n\t\tcase 'o': popt->max_occ = atoi(optarg); break;\n\t\tcase 's': popt->is_sw = 0; break;\n\t\tcase 'P': popt->is_preload = 1; break;\n\t\tcase 'n': popt->n_multi = atoi(optarg); break;\n\t\tcase 'N': popt->N_multi = atoi(optarg); break;\n\t\tcase 'c': popt->ap_prior = atof(optarg); break;\n\t\tcase 'f': xreopen(optarg, \"w\", stdout); break;\n\t\tcase 'A': popt->force_isize = 1; break;\n\t\tdefault: return 1;\n\t\t}\n\t}\n\n\tif (optind + 5 > argc) {\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Usage:   bwa sampe [options] <prefix> <in1.sai> <in2.sai> <in1.fq> <in2.fq>\\n\\n\");\n\t\tfprintf(stderr, \"Options: -a INT   maximum insert size [%d]\\n\", popt->max_isize);\n\t\tfprintf(stderr, \"         -o INT   maximum occurrences for one end [%d]\\n\", popt->max_occ);\n\t\tfprintf(stderr, \"         -n INT   maximum hits to output for paired reads [%d]\\n\", popt->n_multi);\n\t\tfprintf(stderr, \"         -N INT   maximum hits to output for discordant pairs [%d]\\n\", popt->N_multi);\n\t\tfprintf(stderr, \"         -c FLOAT prior of chimeric rate (lower bound) [%.1le]\\n\", popt->ap_prior);\n        fprintf(stderr, \"         -f FILE  sam file to output results to [stdout]\\n\");\n\t\tfprintf(stderr, \"         -r STR   read group header line such as `@RG\\\\tID:foo\\\\tSM:bar' [null]\\n\");\n\t\tfprintf(stderr, \"         -P       preload index into memory (for base-space reads only)\\n\");\n\t\tfprintf(stderr, \"         -s       disable Smith-Waterman for the unmapped mate\\n\");\n\t\tfprintf(stderr, \"         -A       disable insert size estimate (force -s)\\n\\n\");\n\t\tfprintf(stderr, \"Notes: 1. For SOLiD reads, <in1.fq> corresponds R3 reads and <in2.fq> to F3.\\n\");\n\t\tfprintf(stderr, \"       2. For reads shorter than 30bp, applying a smaller -o is recommended to\\n\");\n\t\tfprintf(stderr, \"          to get a sensible speed at the cost of pairing accuracy.\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn 1;\n\t}\n\tif ((prefix = bwa_idx_infer_prefix(argv[optind])) == 0) {\n\t\tfprintf(stderr, \"[%s] fail to locate the index\\n\", __func__);\n\t\treturn 1;\n\t}\n\tbwa_sai2sam_pe_core(prefix, argv + optind + 1, argv + optind+3, popt, rg_line);\n\tfree(prefix); free(popt);\n\treturn 0;\n}", "idx": 258}
{"project": "BWA", "commit_id": "76_BWA_0.7.17_bwase.c_bwa_aln2seq.c", "target": 0, "func": "void bwa_aln2seq(int n_aln, const bwt_aln1_t *aln, bwa_seq_t *s)\n{\n\tbwa_aln2seq_core(n_aln, aln, s, 1, 0);\n}", "idx": 259}
{"project": "BWA", "commit_id": "77_BWA_0.7.17_bwase.c_bwa_approx_mapQ.c", "target": 0, "func": "int bwa_approx_mapQ(const bwa_seq_t *p, int mm)\n{\n\tint n;\n\tif (p->c1 == 0) return 23;\n\tif (p->c1 > 1) return 0;\n\tif (p->n_mm == mm) return 25;\n\tif (p->c2 == 0) return 37;\n\tn = (p->c2 >= 255)? 255 : p->c2;\n\treturn (23 < g_log_n[n])? 0 : 23 - g_log_n[n];\n}", "idx": 260}
{"project": "BWA", "commit_id": "78_BWA_0.7.17_bwase.c_bwa_sa2pos.c", "target": 0, "func": "bwtint_t bwa_sa2pos(const bntseq_t *bns, const bwt_t *bwt, bwtint_t sapos, int ref_len, int *strand)\n{\n\tbwtint_t pos_f;\n\tint is_rev;\n\t*strand = 0; // initialise strand to 0 otherwise we could return without setting it\n\tpos_f = bwt_sa(bwt, sapos); // position on the forward-reverse coordinate\n\tif (pos_f < bns->l_pac && bns->l_pac < pos_f + ref_len) return (bwtint_t)-1;\n\tpos_f = bns_depos(bns, pos_f, &is_rev); // position on the forward strand; this may be the first base or the last base\n\t*strand = !is_rev;\n\tif (is_rev) pos_f = pos_f + 1 < ref_len? 0 : pos_f - ref_len + 1; // position of the first base\n\treturn pos_f; // FIXME: it is possible that pos_f < bns->anns[ref_id].offset\n}", "idx": 261}
{"project": "BWA", "commit_id": "79_BWA_0.7.17_bwase.c_bwa_cal_pac_pos_core.c", "target": 0, "func": "void bwa_cal_pac_pos_core(const bntseq_t *bns, const bwt_t *bwt, bwa_seq_t *seq, const int max_mm, const float fnr)\n{\n\tint max_diff, strand;\n\tif (seq->type != BWA_TYPE_UNIQUE && seq->type != BWA_TYPE_REPEAT) return;\n\tmax_diff = fnr > 0.0? bwa_cal_maxdiff(seq->len, BWA_AVG_ERR, fnr) : max_mm;\n\tseq->seQ = seq->mapQ = bwa_approx_mapQ(seq, max_diff);\n\t//fprintf(stderr, \"%d\\n\", seq->ref_shift);\n\tseq->pos = bwa_sa2pos(bns, bwt, seq->sa, seq->len + seq->ref_shift, &strand);\n\tseq->strand = strand;\n\tseq->seQ = seq->mapQ = bwa_approx_mapQ(seq, max_diff);\n\tif (seq->pos == (bwtint_t)-1) seq->type = BWA_TYPE_NO_MATCH;\n}", "idx": 262}
{"project": "BWA", "commit_id": "7_BWA_0.7.17_bamlite.c_bam_swap_endian_8p.c", "target": 0, "func": "static inline void *bam_swap_endian_8p(void *x)\n{\n\t*(uint64_t*)x = bam_swap_endian_8(*(uint64_t*)x);\n\treturn x;\n}", "idx": 263}
{"project": "BWA", "commit_id": "80_BWA_0.7.17_bwase.c_bwa_cal_pac_pos.c", "target": 0, "func": "void bwa_cal_pac_pos(const bntseq_t *bns, const char *prefix, int n_seqs, bwa_seq_t *seqs, int max_mm, float fnr)\n{\n\tint i, j, strand, n_multi;\n\tchar str[1024];\n\tbwt_t *bwt;\n\t// load forward SA\n\tstrcpy(str, prefix); strcat(str, \".bwt\");  bwt = bwt_restore_bwt(str);\n\tstrcpy(str, prefix); strcat(str, \".sa\"); bwt_restore_sa(str, bwt);\n\tfor (i = 0; i != n_seqs; ++i) {\n\t\tbwa_seq_t *p = &seqs[i];\n\t\tbwa_cal_pac_pos_core(bns, bwt, p, max_mm, fnr);\n\t\tfor (j = n_multi = 0; j < p->n_multi; ++j) {\n\t\t\tbwt_multi1_t *q = p->multi + j;\n\t\t\tq->pos = bwa_sa2pos(bns, bwt, q->pos, p->len + q->ref_shift, &strand);\n\t\t\tq->strand = strand;\n\t\t\tif (q->pos != p->pos && q->pos != (bwtint_t)-1)\n\t\t\t\tp->multi[n_multi++] = *q;\n\t\t}\n\t\tp->n_multi = n_multi;\n\t}\n\tbwt_destroy(bwt);\n}", "idx": 264}
{"project": "BWA", "commit_id": "81_BWA_0.7.17_bwase.c_bwa_refine_gapped_core.c", "target": 0, "func": "bwa_cigar_t *bwa_refine_gapped_core(bwtint_t l_pac, const ubyte_t *pacseq, int len, ubyte_t *seq, int ref_shift, bwtint_t *_rb, int *n_cigar)\n{\n\tbwa_cigar_t *cigar = 0;\n\tuint32_t *cigar32 = 0;\n\tubyte_t *rseq;\n\tint64_t k, rb, re, rlen;\n\tint8_t mat[25];\n\tint w;\n\n\tbwa_fill_scmat(1, 3, mat);\n\trb = *_rb; re = rb + len + ref_shift;\n\tassert(re <= l_pac);\n\trseq = bns_get_seq(l_pac, pacseq, rb, re, &rlen);\n\tassert(re - rb == rlen);\n\tw = abs((int)rlen - len) * 1.5;\n\tksw_global(len, seq, rlen, rseq, 5, mat, 5, 1, SW_BW > w? SW_BW : w, n_cigar, &cigar32);\n\tassert(*n_cigar > 0);\n\tif ((cigar32[*n_cigar - 1]&0xf) == 1) cigar32[*n_cigar - 1] = (cigar32[*n_cigar - 1]>>4<<4) | 3; // change endding ins to soft clipping\n\tif ((cigar32[0]&0xf) == 1) cigar32[0] = (cigar32[0]>>4<<4) | 3; // change beginning ins to soft clipping\n\tif ((cigar32[*n_cigar - 1]&0xf) == 2) --*n_cigar; // delete endding del\n\tif ((cigar32[0]&0xf) == 2) { // delete beginning del\n\t\t*_rb += cigar32[0]>>4;\n\t\t--*n_cigar;\n\t\tmemmove(cigar32, cigar32+1, (*n_cigar) * 4);\n\t}\n\tcigar = (bwa_cigar_t*)cigar32;\n\tfor (k = 0; k < *n_cigar; ++k)\n\t\tcigar[k] = __cigar_create((cigar32[k]&0xf), (cigar32[k]>>4));\n\tfree(rseq);\n\treturn cigar;\n}", "idx": 265}
{"project": "BWA", "commit_id": "82_BWA_0.7.17_bwase.c_pos_end.c", "target": 0, "func": "analogy to pos_end()\n{\n\tif (p->cigar) {\n\t\tint j;\n\t\tint64_t x = p->pos;\n\t\tfor (j = 0; j != p->n_cigar; ++j) {\n\t\t\tint op = __cigar_op(p->cigar[j]);\n\t\t\tif (op == 0 || op == 2) x += __cigar_len(p->cigar[j]);\n\t\t}\n\t\treturn x;\n\t} else return p->pos + len;\n}", "idx": 266}
{"project": "BWA", "commit_id": "83_BWA_0.7.17_bwase.c_pos_5.c", "target": 0, "func": "static int64_t pos_5(const bwa_seq_t *p)\n{\n\tif (p->type != BWA_TYPE_NO_MATCH)\n\t\treturn p->strand? pos_end(p) : p->pos;\n\treturn -1;\n}", "idx": 267}
{"project": "BWA", "commit_id": "84_BWA_0.7.17_bwase.c_bwa_print_seq.c", "target": 0, "func": "void bwa_print_seq(FILE *stream, bwa_seq_t *seq) {\n\tchar buffer[4096];\n\tconst int bsz = sizeof(buffer);\n\tint i, j, l;\n\t\n\tif (seq->strand == 0) {\n\t\tfor (i = 0; i < seq->full_len; i += bsz) {\n\t\t\tl = seq->full_len - i > bsz ? bsz : seq->full_len - i;\n\t\t\tfor (j = 0; j < l; j++) buffer[j] = \"ACGTN\"[seq->seq[i + j]];\n\t\t\terr_fwrite(buffer, 1, l, stream);\n\t\t}\n\t} else {\n\t\tfor (i = seq->full_len - 1; i >= 0; i -= bsz) {\n\t\t\tl = i + 1 > bsz ? bsz : i + 1;\n\t\t\tfor (j = 0; j < l; j++) buffer[j] = \"TGCAN\"[seq->seq[i - j]];\n\t\t\terr_fwrite(buffer, 1, l, stream);\n\t\t}\n\t}\n}", "idx": 268}
{"project": "BWA", "commit_id": "85_BWA_0.7.17_bwase.c_bwase_initialize.c", "target": 0, "func": "void bwase_initialize() \n{\n\tint i;\n\tfor (i = 1; i != 256; ++i) g_log_n[i] = (int)(4.343 * log(i) + 0.5);\n}", "idx": 269}
{"project": "BWA", "commit_id": "86_BWA_0.7.17_bwase.c_bwa_sai2sam_se.c", "target": 0, "func": "int bwa_sai2sam_se(int argc, char *argv[])\n{\n\tint c, n_occ = 3;\n\tchar *prefix, *rg_line = 0;\n\twhile ((c = getopt(argc, argv, \"hn:f:r:\")) >= 0) {\n\t\tswitch (c) {\n\t\tcase 'h': break;\n\t\tcase 'r':\n\t\t\tif ((rg_line = bwa_set_rg(optarg)) == 0) return 1;\n\t\t\tbreak;\n\t\tcase 'n': n_occ = atoi(optarg); break;\n\t\tcase 'f': xreopen(optarg, \"w\", stdout); break;\n\t\tdefault: return 1;\n\t\t}\n\t}\n\n\tif (optind + 3 > argc) {\n\t\tfprintf(stderr, \"Usage: bwa samse [-n max_occ] [-f out.sam] [-r RG_line] <prefix> <in.sai> <in.fq>\\n\");\n\t\treturn 1;\n\t}\n\tif ((prefix = bwa_idx_infer_prefix(argv[optind])) == 0) {\n\t\tfprintf(stderr, \"[%s] fail to locate the index\\n\", __func__);\n\t\treturn 1;\n\t}\n\tbwa_sai2sam_se_core(prefix, argv[optind+1], argv[optind+2], n_occ, rg_line);\n\tfree(prefix);\n\treturn 0;\n}", "idx": 270}
{"project": "BWA", "commit_id": "87_BWA_0.7.17_bwaseqio.c_bwa_bam_open.c", "target": 0, "func": "bwa_seqio_t *bwa_bam_open(const char *fn, int which)\n{\n\tbwa_seqio_t *bs;\n\tbam_header_t *h;\n\tbs = (bwa_seqio_t*)calloc(1, sizeof(bwa_seqio_t));\n\tbs->is_bam = 1;\n\tbs->which = which;\n\tbs->fp = bam_open(fn, \"r\");\n\tif (0 == bs->fp) err_fatal_simple(\"Couldn't open bam file\");\n\th = bam_header_read(bs->fp);\n\tbam_header_destroy(h);\n\treturn bs;\n}", "idx": 271}
{"project": "BWA", "commit_id": "88_BWA_0.7.17_bwaseqio.c_bwa_seq_open.c", "target": 0, "func": "bwa_seqio_t *bwa_seq_open(const char *fn)\n{\n\tgzFile fp;\n\tbwa_seqio_t *bs;\n\tbs = (bwa_seqio_t*)calloc(1, sizeof(bwa_seqio_t));\n\tfp = xzopen(fn, \"r\");\n\tbs->ks = kseq_init(fp);\n\treturn bs;\n}", "idx": 272}
{"project": "BWA", "commit_id": "89_BWA_0.7.17_bwaseqio.c_bwa_seq_close.c", "target": 0, "func": "void bwa_seq_close(bwa_seqio_t *bs)\n{\n\tif (bs == 0) return;\n\tif (bs->is_bam) {\n\t\tif (0 != bam_close(bs->fp)) err_fatal_simple(\"Error closing bam file\");\n\t} else {\n\t\terr_gzclose(bs->ks->f->f);\n\t\tkseq_destroy(bs->ks);\n\t}\n\tfree(bs);\n}", "idx": 273}
{"project": "BWA", "commit_id": "8_BWA_0.7.17_bamlite.c_bam_header_init.c", "target": 0, "func": "bam_header_t *bam_header_init()\n{\n\tbam_is_be = bam_is_big_endian();\n\treturn (bam_header_t*)calloc(1, sizeof(bam_header_t));\n}", "idx": 274}
{"project": "BWA", "commit_id": "90_BWA_0.7.17_bwaseqio.c_seq_reverse.c", "target": 0, "func": "void seq_reverse(int len, ubyte_t *seq, int is_comp)\n{\n\tint i;\n\tif (is_comp) {\n\t\tfor (i = 0; i < len>>1; ++i) {\n\t\t\tchar tmp = seq[len-1-i];\n\t\t\tif (tmp < 4) tmp = 3 - tmp;\n\t\t\tseq[len-1-i] = (seq[i] >= 4)? seq[i] : 3 - seq[i];\n\t\t\tseq[i] = tmp;\n\t\t}\n\t\tif (len&1) seq[i] = (seq[i] >= 4)? seq[i] : 3 - seq[i];\n\t} else {\n\t\tfor (i = 0; i < len>>1; ++i) {\n\t\t\tchar tmp = seq[len-1-i];\n\t\t\tseq[len-1-i] = seq[i]; seq[i] = tmp;\n\t\t}\n\t}\n}", "idx": 275}
{"project": "BWA", "commit_id": "91_BWA_0.7.17_bwaseqio.c_bwa_trim_read.c", "target": 0, "func": "int bwa_trim_read(int trim_qual, bwa_seq_t *p)\n{\n\tint s = 0, l, max = 0, max_l = p->len;\n\tif (trim_qual < 1 || p->qual == 0) return 0;\n\tfor (l = p->len - 1; l >= BWA_MIN_RDLEN; --l) {\n\t\ts += trim_qual - (p->qual[l] - 33);\n\t\tif (s < 0) break;\n\t\tif (s > max) max = s, max_l = l;\n\t}\n\tp->clip_len = p->len = max_l;\n\treturn p->full_len - p->len;\n}", "idx": 276}
{"project": "BWA", "commit_id": "92_BWA_0.7.17_bwaseqio.c_bwa_read_bam.c", "target": 0, "func": "static bwa_seq_t *bwa_read_bam(bwa_seqio_t *bs, int n_needed, int *n, int is_comp, int trim_qual)\n{\n\tbwa_seq_t *seqs, *p;\n\tint n_seqs, l, i;\n\tlong n_trimmed = 0, n_tot = 0;\n\tbam1_t *b;\n\tint res;\n\n\tb = bam_init1();\n\tn_seqs = 0;\n\tseqs = (bwa_seq_t*)calloc(n_needed, sizeof(bwa_seq_t));\n\twhile ((res = bam_read1(bs->fp, b)) >= 0) {\n\t\tuint8_t *s, *q;\n\t\tint go = 0;\n\t\tif ((bs->which & 1) && (b->core.flag & BAM_FREAD1)) go = 1;\n\t\tif ((bs->which & 2) && (b->core.flag & BAM_FREAD2)) go = 1;\n\t\tif ((bs->which & 4) && !(b->core.flag& BAM_FREAD1) && !(b->core.flag& BAM_FREAD2))go = 1;\n\t\tif (go == 0) continue;\n\t\tl = b->core.l_qseq;\n\t\tp = &seqs[n_seqs++];\n\t\tp->tid = -1; // no assigned to a thread\n\t\tp->qual = 0;\n\t\tp->full_len = p->clip_len = p->len = l;\n\t\tn_tot += p->full_len;\n\t\ts = bam1_seq(b); q = bam1_qual(b);\n\t\tp->seq = (ubyte_t*)calloc(p->len + 1, 1);\n\t\tp->qual = (ubyte_t*)calloc(p->len + 1, 1);\n\t\tfor (i = 0; i != p->full_len; ++i) {\n\t\t\tp->seq[i] = bam_nt16_nt4_table[(int)bam1_seqi(s, i)];\n\t\t\tp->qual[i] = q[i] + 33 < 126? q[i] + 33 : 126;\n\t\t}\n\t\tif (bam1_strand(b)) { // then reverse \n\t\t\tseq_reverse(p->len, p->seq, 1);\n\t\t\tseq_reverse(p->len, p->qual, 0);\n\t\t}\n\t\tif (trim_qual >= 1) n_trimmed += bwa_trim_read(trim_qual, p);\n\t\tp->rseq = (ubyte_t*)calloc(p->full_len, 1);\n\t\tmemcpy(p->rseq, p->seq, p->len);\n\t\tseq_reverse(p->len, p->seq, 0); // *IMPORTANT*: will be reversed back in bwa_refine_gapped()\n\t\tseq_reverse(p->len, p->rseq, is_comp);\n\t\tp->name = strdup((const char*)bam1_qname(b));\n\t\tif (n_seqs == n_needed) break;\n\t}\n\tif (res < 0 && res != -1) err_fatal_simple(\"Error reading bam file\");\n\t*n = n_seqs;\n\tif (n_seqs && trim_qual >= 1)\n\t\tfprintf(stderr, \"[bwa_read_seq] %.1f%% bases are trimmed.\\n\", 100.0f * n_trimmed/n_tot);\n\tif (n_seqs == 0) {\n\t\tfree(seqs);\n\t\tbam_destroy1(b);\n\t\treturn 0;\n\t}\n\tbam_destroy1(b);\n\treturn seqs;\n}", "idx": 277}
{"project": "BWA", "commit_id": "93_BWA_0.7.17_bwaseqio.c_bwa_free_read_seq.c", "target": 0, "func": "void bwa_free_read_seq(int n_seqs, bwa_seq_t *seqs)\n{\n\tint i, j;\n\tfor (i = 0; i != n_seqs; ++i) {\n\t\tbwa_seq_t *p = seqs + i;\n\t\tfor (j = 0; j < p->n_multi; ++j)\n\t\t\tif (p->multi[j].cigar) free(p->multi[j].cigar);\n\t\tfree(p->name);\n\t\tfree(p->seq); free(p->rseq); free(p->qual); free(p->aln); free(p->md); free(p->multi);\n\t\tfree(p->cigar);\n\t}\n\tfree(seqs);\n}", "idx": 278}
{"project": "BWA", "commit_id": "94_BWA_0.7.17_bwashm.c_bwa_idx_load_from_shm.c", "target": 0, "func": "bwaidx_t *bwa_idx_load_from_shm(const char *hint)\n{\n\tconst char *name;\n\tuint8_t *shm, *shm_idx;\n\tuint16_t *cnt, i;\n\tchar *p, path[PATH_MAX + 1];\n\tint shmid;\n\tint64_t l_mem;\n\tbwaidx_t *idx;\n\n\tif (hint == 0 || hint[0] == 0) return 0;\n\tfor (name = hint + strlen(hint) - 1; name >= hint && *name != '/'; --name);\n\t++name;\n\tif ((shmid = shm_open(\"/bwactl\", O_RDONLY, 0)) < 0) return 0;\n\tshm = mmap(0, BWA_CTL_SIZE, PROT_READ, MAP_SHARED, shmid, 0);\n\tcnt = (uint16_t*)shm;\n\tif (cnt[0] == 0) return 0;\n\tfor (i = 0, p = (char*)(shm + 4); i < cnt[0]; ++i) {\n\t\tmemcpy(&l_mem, p, 8); p += 8;\n\t\tif (strcmp(p, name) == 0) break;\n\t\tp += strlen(p) + 1;\n\t}\n\tif (i == cnt[0]) return 0;\n\n\tstrcat(strcpy(path, \"/bwaidx-\"), name);\n\tif ((shmid = shm_open(path, O_RDONLY, 0)) < 0) return 0;\n\tshm_idx = mmap(0, l_mem, PROT_READ, MAP_SHARED, shmid, 0);\n\tidx = calloc(1, sizeof(bwaidx_t));\n\tbwa_mem2idx(l_mem, shm_idx, idx);\n\tidx->is_shm = 1;\n\treturn idx;\n}", "idx": 279}
{"project": "BWA", "commit_id": "95_BWA_0.7.17_bwashm.c_bwa_shm_test.c", "target": 0, "func": "int bwa_shm_test(const char *hint)\n{\n\tint shmid;\n\tuint16_t *cnt, i;\n\tchar *p, *shm;\n\tconst char *name;\n\n\tif (hint == 0 || hint[0] == 0) return 0;\n\tfor (name = hint + strlen(hint) - 1; name >= hint && *name != '/'; --name);\n\t++name;\n\tif ((shmid = shm_open(\"/bwactl\", O_RDONLY, 0)) < 0) return 0;\n\tshm = mmap(0, BWA_CTL_SIZE, PROT_READ, MAP_SHARED, shmid, 0);\n\tcnt = (uint16_t*)shm;\n\tfor (i = 0, p = shm + 4; i < cnt[0]; ++i) {\n\t\tif (strcmp(p + 8, name) == 0) return 1;\n\t\tp += strlen(p) + 9;\n\t}\n\treturn 0;\n}", "idx": 280}
{"project": "BWA", "commit_id": "96_BWA_0.7.17_bwashm.c_bwa_shm_list.c", "target": 0, "func": "int bwa_shm_list(void)\n{\n\tint shmid;\n\tuint16_t *cnt, i;\n\tchar *p, *shm;\n\tif ((shmid = shm_open(\"/bwactl\", O_RDONLY, 0)) < 0) return -1;\n\tshm = mmap(0, BWA_CTL_SIZE, PROT_READ, MAP_SHARED, shmid, 0);\n\tcnt = (uint16_t*)shm;\n\tfor (i = 0, p = shm + 4; i < cnt[0]; ++i) {\n\t\tint64_t l_mem;\n\t\tmemcpy(&l_mem, p, 8); p += 8;\n\t\tprintf(\"%s\\t%ld\\n\", p, (long)l_mem);\n\t\tp += strlen(p) + 1;\n\t}\n\treturn 0;\n}", "idx": 281}
{"project": "BWA", "commit_id": "97_BWA_0.7.17_bwashm.c_bwa_shm_destroy.c", "target": 0, "func": "int bwa_shm_destroy(void)\n{\n\tint shmid;\n\tuint16_t *cnt, i;\n\tchar *p, *shm;\n\tchar path[PATH_MAX + 1];\n\n\tif ((shmid = shm_open(\"/bwactl\", O_RDONLY, 0)) < 0) return -1;\n\tshm = mmap(0, BWA_CTL_SIZE, PROT_READ, MAP_SHARED, shmid, 0);\n\tcnt = (uint16_t*)shm;\n\tfor (i = 0, p = shm + 4; i < cnt[0]; ++i) {\n\t\tint64_t l_mem;\n\t\tmemcpy(&l_mem, p, 8); p += 8;\n\t\tstrcat(strcpy(path, \"/bwaidx-\"), p);\n\t\tshm_unlink(path);\n\t\tp += strlen(p) + 1;\n\t}\n\tmunmap(shm, BWA_CTL_SIZE);\n\tshm_unlink(\"/bwactl\");\n\treturn 0;\n}", "idx": 282}
{"project": "BWA", "commit_id": "98_BWA_0.7.17_bwt.c_bwt_gen_cnt_table.c", "target": 0, "func": "void bwt_gen_cnt_table(bwt_t *bwt)\n{\n\tint i, j;\n\tfor (i = 0; i != 256; ++i) {\n\t\tuint32_t x = 0;\n\t\tfor (j = 0; j != 4; ++j)\n\t\t\tx |= (((i&3) == j) + ((i>>2&3) == j) + ((i>>4&3) == j) + (i>>6 == j)) << (j<<3);\n\t\tbwt->cnt_table[i] = x;\n\t}\n}", "idx": 283}
{"project": "BWA", "commit_id": "99_BWA_0.7.17_bwt.c_bwt_cal_sa.c", "target": 0, "func": "void bwt_cal_sa(bwt_t *bwt, int intv)\n{\n\tbwtint_t isa, sa, i; // S(isa) = sa\n\tint intv_round = intv;\n\n\tkv_roundup32(intv_round);\n\txassert(intv_round == intv, \"SA sample interval is not a power of 2.\");\n\txassert(bwt->bwt, \"bwt_t::bwt is not initialized.\");\n\n\tif (bwt->sa) free(bwt->sa);\n\tbwt->sa_intv = intv;\n\tbwt->n_sa = (bwt->seq_len + intv) / intv;\n\tbwt->sa = (bwtint_t*)calloc(bwt->n_sa, sizeof(bwtint_t));\n\t// calculate SA value\n\tisa = 0; sa = bwt->seq_len;\n\tfor (i = 0; i < bwt->seq_len; ++i) {\n\t\tif (isa % intv == 0) bwt->sa[isa/intv] = sa;\n\t\t--sa;\n\t\tisa = bwt_invPsi(bwt, isa);\n\t}\n\tif (isa % intv == 0) bwt->sa[isa/intv] = sa;\n\tbwt->sa[0] = (bwtint_t)-1; // before this line, bwt->sa[0] = bwt->seq_len\n}", "idx": 284}
{"project": "BWA", "commit_id": "9_BWA_0.7.17_bamlite.c_bam_header_destroy.c", "target": 0, "func": "void bam_header_destroy(bam_header_t *header)\n{\n\tint32_t i;\n\tif (header == 0) return;\n\tif (header->target_name) {\n\t\tfor (i = 0; i < header->n_targets; ++i)\n\t\t\tif (header->target_name[i]) free(header->target_name[i]);\n\t\tif (header->target_len) free(header->target_len);\n\t\tfree(header->target_name);\n\t}\n\tif (header->text) free(header->text);\n\tfree(header);\n}", "idx": 285}

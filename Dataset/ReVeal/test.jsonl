{"code": "void jbig2_word_stream_buf_free ( Jbig2Ctx * ctx , Jbig2WordStream * ws ) {\n jbig2_free ( ctx -> allocator , ws ) ;\n }", "hash": -1768728156572022708, "project": "debian", "size": 3, "target": 0, "idx": 23}
{"code": "Jbig2WordStream * jbig2_word_stream_buf_new ( Jbig2Ctx * ctx , const byte * data , size_t size ) {\n Jbig2WordStreamBuf * result = jbig2_new ( ctx , Jbig2WordStreamBuf , 1 ) ;\n if ( result == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , - 1 , \"failed to allocate Jbig2WordStreamBuf in jbig2_word_stream_buf_new\" ) ;\n return NULL ;\n }\n result -> super . get_next_word = jbig2_word_stream_buf_get_next_word ;\n result -> data = data ;\n result -> size = size ;\n return & result -> super ;\n }", "hash": -1768728156572022708, "project": "debian", "size": 11, "target": 0, "idx": 35}
{"code": "int32_t jbig2_get_int32 ( const byte * bptr ) {\n return ( ( int32_t ) get_int16 ( bptr ) << 16 ) | get_uint16 ( bptr + 2 ) ;\n }", "hash": -1768728156572022708, "project": "debian", "size": 3, "target": 0, "idx": 41}
{"code": "static int jbig2_decode_generic_region_TPGDON ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2GenericRegionParams * params , Jbig2ArithState * as , Jbig2Image * image , Jbig2ArithCx * GB_stats ) {\n switch ( params -> GBTEMPLATE ) {\n case 0 : return jbig2_decode_generic_template0_TPGDON ( ctx , segment , params , as , image , GB_stats ) ;\n case 1 : return jbig2_decode_generic_template1_TPGDON ( ctx , segment , params , as , image , GB_stats ) ;\n case 2 : return jbig2_decode_generic_template2_TPGDON ( ctx , segment , params , as , image , GB_stats ) ;\n case 3 : return jbig2_decode_generic_template3_TPGDON ( ctx , segment , params , as , image , GB_stats ) ;\n }\n return - 1 ;\n }", "hash": 8458201026073747179, "project": "debian", "size": 9, "target": 0, "idx": 49}
{"code": "static int jbig2_decode_generic_template0 ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2GenericRegionParams * params , Jbig2ArithState * as , Jbig2Image * image , Jbig2ArithCx * GB_stats ) {\n const int GBW = image -> width ;\n const int GBH = image -> height ;\n const int rowstride = image -> stride ;\n int x , y ;\n byte * gbreg_line = ( byte * ) image -> data ;\n # ifdef OUTPUT_PBM printf ( \"P4\\n%d %d\\n\" , GBW , GBH ) ;\n # endif if ( GBW <= 0 ) return 0 ;\n for ( y = 0 ;\n y < GBH ;\n y ++ ) {\n uint32_t CONTEXT ;\n uint32_t line_m1 ;\n uint32_t line_m2 ;\n int padded_width = ( GBW + 7 ) & - 8 ;\n line_m1 = ( y >= 1 ) ? gbreg_line [ - rowstride ] : 0 ;\n line_m2 = ( y >= 2 ) ? gbreg_line [ - ( rowstride << 1 ) ] << 6 : 0 ;\n CONTEXT = ( line_m1 & 0x7f0 ) | ( line_m2 & 0xf800 ) ;\n for ( x = 0 ;\n x < padded_width ;\n x += 8 ) {\n byte result = 0 ;\n int x_minor ;\n int minor_width = GBW - x > 8 ? 8 : GBW - x ;\n if ( y >= 1 ) line_m1 = ( line_m1 << 8 ) | ( x + 8 < GBW ? gbreg_line [ - rowstride + ( x >> 3 ) + 1 ] : 0 ) ;\n if ( y >= 2 ) line_m2 = ( line_m2 << 8 ) | ( x + 8 < GBW ? gbreg_line [ - ( rowstride << 1 ) + ( x >> 3 ) + 1 ] << 6 : 0 ) ;\n for ( x_minor = 0 ;\n x_minor < minor_width ;\n x_minor ++ ) {\n bool bit ;\n bit = jbig2_arith_decode ( as , & GB_stats [ CONTEXT ] ) ;\n if ( bit < 0 ) return - 1 ;\n result |= bit << ( 7 - x_minor ) ;\n CONTEXT = ( ( CONTEXT & 0x7bf7 ) << 1 ) | bit | ( ( line_m1 >> ( 7 - x_minor ) ) & 0x10 ) | ( ( line_m2 >> ( 7 - x_minor ) ) & 0x800 ) ;\n }\n gbreg_line [ x >> 3 ] = result ;\n }\n # ifdef OUTPUT_PBM fwrite ( gbreg_line , 1 , rowstride , stdout ) ;\n # endif gbreg_line += rowstride ;\n }\n return 0 ;\n }", "hash": 8458201026073747179, "project": "debian", "size": 42, "target": 0, "idx": 55}
{"code": "static void copy_prev_row ( Jbig2Image * image , int row ) {\n if ( ! row ) {\n memset ( image -> data , 0 , image -> stride ) ;\n }\n else {\n uint8_t * src = image -> data + ( row - 1 ) * image -> stride ;\n memcpy ( src + image -> stride , src , image -> stride ) ;\n }\n }", "hash": 8458201026073747179, "project": "debian", "size": 9, "target": 0, "idx": 57}
{"code": "int jbig2_halftone_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n int offset = 0 ;\n Jbig2RegionSegmentInfo region_info ;\n Jbig2HalftoneRegionParams params ;\n Jbig2Image * image = NULL ;\n Jbig2ArithCx * GB_stats = NULL ;\n int code = 0 ;\n if ( segment -> data_length < 17 ) goto too_short ;\n jbig2_get_region_segment_info ( & region_info , segment_data ) ;\n offset += 17 ;\n if ( segment -> data_length < 18 ) goto too_short ;\n params . flags = segment_data [ offset ] ;\n params . HMMR = params . flags & 1 ;\n params . HTEMPLATE = ( params . flags & 6 ) >> 1 ;\n params . HENABLESKIP = ( params . flags & 8 ) >> 3 ;\n params . op = ( Jbig2ComposeOp ) ( ( params . flags & 0x70 ) >> 4 ) ;\n params . HDEFPIXEL = ( params . flags & 0x80 ) >> 7 ;\n offset += 1 ;\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"halftone region: %d x %d @ (%x,%d) flags=%02x\" , region_info . width , region_info . height , region_info . x , region_info . y , params . flags ) ;\n if ( params . HMMR && params . HTEMPLATE ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"HTEMPLATE is %d when HMMR is %d, contrary to spec\" , params . HTEMPLATE , params . HMMR ) ;\n }\n if ( params . HMMR && params . HENABLESKIP ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"HENABLESKIP is %d when HMMR is %d, contrary to spec\" , params . HENABLESKIP , params . HMMR ) ;\n }\n if ( segment -> data_length - offset < 16 ) goto too_short ;\n params . HGW = jbig2_get_uint32 ( segment_data + offset ) ;\n params . HGH = jbig2_get_uint32 ( segment_data + offset + 4 ) ;\n params . HGX = jbig2_get_int32 ( segment_data + offset + 8 ) ;\n params . HGY = jbig2_get_int32 ( segment_data + offset + 12 ) ;\n offset += 16 ;\n if ( segment -> data_length - offset < 4 ) goto too_short ;\n params . HRX = jbig2_get_uint16 ( segment_data + offset ) ;\n params . HRY = jbig2_get_uint16 ( segment_data + offset + 2 ) ;\n offset += 4 ;\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \" grid %d x %d @ (%d.%d,%d.%d) vector (%d.%d,%d.%d)\" , params . HGW , params . HGH , params . HGX >> 8 , params . HGX & 0xff , params . HGY >> 8 , params . HGY & 0xff , params . HRX >> 8 , params . HRX & 0xff , params . HRY >> 8 , params . HRY & 0xff ) ;\n if ( ! params . HMMR ) {\n int stats_size = jbig2_generic_stats_size ( ctx , params . HTEMPLATE ) ;\n GB_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ;\n if ( GB_stats == NULL ) {\n return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate GB_stats in halftone region\" ) ;\n }\n memset ( GB_stats , 0 , stats_size ) ;\n }\n image = jbig2_image_new ( ctx , region_info . width , region_info . height ) ;\n if ( image == NULL ) {\n jbig2_free ( ctx -> allocator , GB_stats ) ;\n return jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"unable to allocate halftone image\" ) ;\n }\n code = jbig2_decode_halftone_region ( ctx , segment , & params , segment_data + offset , segment -> data_length - offset , image , GB_stats ) ;\n if ( ! params . HMMR ) {\n jbig2_free ( ctx -> allocator , GB_stats ) ;\n }\n jbig2_page_add_result ( ctx , & ctx -> pages [ ctx -> current_page ] , image , region_info . x , region_info . y , region_info . op ) ;\n jbig2_image_release ( ctx , image ) ;\n return code ;\n too_short : return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Segment too short\" ) ;\n }", "hash": -3955770052982962380, "project": "debian", "size": 58, "target": 0, "idx": 63}
{"code": "static void dump_page_info ( Jbig2Ctx * ctx , Jbig2Segment * segment , Jbig2Page * page ) {\n if ( page -> x_resolution == 0 ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"page %d image is %dx%d (unknown res)\" , page -> number , page -> width , page -> height ) ;\n }\n else if ( page -> x_resolution == page -> y_resolution ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"page %d image is %dx%d (%d ppm)\" , page -> number , page -> width , page -> height , page -> x_resolution ) ;\n }\n else {\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"page %d image is %dx%d (%dx%d ppm)\" , page -> number , page -> width , page -> height , page -> x_resolution , page -> y_resolution ) ;\n }\n if ( page -> striped ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"\\tmaximum stripe size: %d\" , page -> stripe_size ) ;\n }\n }", "hash": -7241004363975794258, "project": "debian", "size": 14, "target": 0, "idx": 69}
{"code": "int jbig2_page_add_result ( Jbig2Ctx * ctx , Jbig2Page * page , Jbig2Image * image , int x , int y , Jbig2ComposeOp op ) {\n if ( page -> image == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , - 1 , \"page info possibly missing, no image defined\" ) ;\n return 0 ;\n }\n if ( page -> striped ) {\n uint32_t new_height = y + image -> height + page -> end_row ;\n if ( page -> image -> height < new_height ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , \"growing page buffer to %d rows \" \"to accomodate new stripe\" , new_height ) ;\n jbig2_image_resize ( ctx , page -> image , page -> image -> width , new_height ) ;\n }\n }\n jbig2_image_compose ( ctx , page -> image , image , x , y + page -> end_row , op ) ;\n return 0 ;\n }", "hash": -7241004363975794258, "project": "debian", "size": 15, "target": 0, "idx": 70}
{"code": "int jbig2_complete_page ( Jbig2Ctx * ctx ) {\n int code = 0 ;\n if ( ctx -> segment_index != ctx -> n_segments ) {\n Jbig2Segment * segment = ctx -> segments [ ctx -> segment_index ] ;\n if ( ( segment -> data_length & 0xffffffff ) == 0xffffffff ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"File has an invalid segment data length!\" \" Trying to decode using the available data.\" ) ;\n segment -> data_length = ctx -> buf_wr_ix - ctx -> buf_rd_ix ;\n code = jbig2_parse_segment ( ctx , segment , ctx -> buf + ctx -> buf_rd_ix ) ;\n ctx -> buf_rd_ix += segment -> data_length ;\n ctx -> segment_index ++ ;\n }\n }\n if ( ctx -> pages [ ctx -> current_page ] . image != NULL ) {\n ctx -> pages [ ctx -> current_page ] . state = JBIG2_PAGE_COMPLETE ;\n }\n return code ;\n }", "hash": -7241004363975794258, "project": "debian", "size": 17, "target": 0, "idx": 75}
{"code": "static int jbig2_decode_mmr_line ( Jbig2MmrCtx * mmr , const byte * ref , byte * dst ) {\n uint32_t a0 = MINUS1 ;\n uint32_t a1 , a2 , b1 , b2 ;\n int c = 0 ;\n while ( 1 ) {\n uint32_t word = mmr -> word ;\n if ( a0 != MINUS1 && a0 >= mmr -> width ) break ;\n if ( ( word >> ( 32 - 3 ) ) == 1 ) {\n int white_run , black_run ;\n jbig2_decode_mmr_consume ( mmr , 3 ) ;\n if ( a0 == MINUS1 ) a0 = 0 ;\n if ( c == 0 ) {\n white_run = jbig2_decode_get_run ( mmr , jbig2_mmr_white_decode , 8 ) ;\n black_run = jbig2_decode_get_run ( mmr , jbig2_mmr_black_decode , 7 ) ;\n a1 = a0 + white_run ;\n a2 = a1 + black_run ;\n if ( a1 > mmr -> width ) a1 = mmr -> width ;\n if ( a2 > mmr -> width ) a2 = mmr -> width ;\n if ( a1 == MINUS1 || a2 < a1 ) return - 1 ;\n jbig2_set_bits ( dst , a1 , a2 ) ;\n a0 = a2 ;\n }\n else {\n black_run = jbig2_decode_get_run ( mmr , jbig2_mmr_black_decode , 7 ) ;\n white_run = jbig2_decode_get_run ( mmr , jbig2_mmr_white_decode , 8 ) ;\n a1 = a0 + black_run ;\n a2 = a1 + white_run ;\n if ( a1 > mmr -> width ) a1 = mmr -> width ;\n if ( a2 > mmr -> width ) a2 = mmr -> width ;\n if ( a0 == MINUS1 || a1 < a0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , a1 ) ;\n a0 = a2 ;\n }\n }\n else if ( ( word >> ( 32 - 4 ) ) == 1 ) {\n jbig2_decode_mmr_consume ( mmr , 4 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n b2 = jbig2_find_changing_element ( ref , b1 , mmr -> width ) ;\n if ( c ) {\n if ( a0 == MINUS1 || b2 < a0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b2 ) ;\n }\n a0 = b2 ;\n }\n else if ( ( word >> ( 32 - 1 ) ) == 1 ) {\n jbig2_decode_mmr_consume ( mmr , 1 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n if ( c ) {\n if ( a0 == MINUS1 || b1 < a0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b1 ) ;\n }\n a0 = b1 ;\n c = ! c ;\n }\n else if ( ( word >> ( 32 - 3 ) ) == 3 ) {\n jbig2_decode_mmr_consume ( mmr , 3 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n if ( b1 + 1 > mmr -> width ) break ;\n if ( c ) {\n if ( a0 == MINUS1 || b1 + 1 < a0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b1 + 1 ) ;\n }\n a0 = b1 + 1 ;\n c = ! c ;\n }\n else if ( ( word >> ( 32 - 6 ) ) == 3 ) {\n jbig2_decode_mmr_consume ( mmr , 6 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n if ( b1 + 2 > mmr -> width ) break ;\n if ( c ) {\n if ( a0 == MINUS1 || b1 + 2 < a0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b1 + 2 ) ;\n }\n a0 = b1 + 2 ;\n c = ! c ;\n }\n else if ( ( word >> ( 32 - 7 ) ) == 3 ) {\n jbig2_decode_mmr_consume ( mmr , 7 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n if ( b1 + 3 > ( int ) mmr -> width ) break ;\n if ( c ) {\n if ( a0 == MINUS1 || b1 + 3 < a0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b1 + 3 ) ;\n }\n a0 = b1 + 3 ;\n c = ! c ;\n }\n else if ( ( word >> ( 32 - 3 ) ) == 2 ) {\n jbig2_decode_mmr_consume ( mmr , 3 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n if ( b1 < 1 ) break ;\n if ( c ) {\n if ( a0 == MINUS1 || b1 - 1 < a0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b1 - 1 ) ;\n }\n a0 = b1 - 1 ;\n c = ! c ;\n }\n else if ( ( word >> ( 32 - 6 ) ) == 2 ) {\n jbig2_decode_mmr_consume ( mmr , 6 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n if ( b1 < 2 ) break ;\n if ( c ) {\n if ( b1 - 2 < a0 || a0 < 0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b1 - 2 ) ;\n }\n a0 = b1 - 2 ;\n c = ! c ;\n }\n else if ( ( word >> ( 32 - 7 ) ) == 2 ) {\n jbig2_decode_mmr_consume ( mmr , 7 ) ;\n b1 = jbig2_find_changing_element_of_color ( ref , a0 , mmr -> width , ! c ) ;\n if ( b1 < 3 ) break ;\n if ( c ) {\n if ( a0 == MINUS1 || b1 - 3 < a0 ) return - 1 ;\n jbig2_set_bits ( dst , a0 , b1 - 3 ) ;\n }\n a0 = b1 - 3 ;\n c = ! c ;\n }\n else break ;\n }\n return 0 ;\n }", "hash": 1286774465219423144, "project": "debian", "size": 124, "target": 0, "idx": 85}
{"code": "void jbig2_free_segment ( Jbig2Ctx * ctx , Jbig2Segment * segment ) {\n if ( segment -> referred_to_segments != NULL ) {\n jbig2_free ( ctx -> allocator , segment -> referred_to_segments ) ;\n }\n switch ( segment -> flags & 63 ) {\n case 0 : if ( segment -> result != NULL ) jbig2_sd_release ( ctx , ( Jbig2SymbolDict * ) segment -> result ) ;\n break ;\n case 4 : case 40 : if ( segment -> result != NULL ) jbig2_image_release ( ctx , ( Jbig2Image * ) segment -> result ) ;\n break ;\n case 16 : if ( segment -> result != NULL ) jbig2_hd_release ( ctx , ( Jbig2PatternDict * ) segment -> result ) ;\n break ;\n case 53 : if ( segment -> result != NULL ) jbig2_table_free ( ctx , ( Jbig2HuffmanParams * ) segment -> result ) ;\n break ;\n case 62 : if ( segment -> result != NULL ) jbig2_metadata_free ( ctx , ( Jbig2Metadata * ) segment -> result ) ;\n break ;\n default : break ;\n }\n jbig2_free ( ctx -> allocator , segment ) ;\n }", "hash": -2492312952058578720, "project": "debian", "size": 19, "target": 0, "idx": 91}
{"code": "int PEM_write_bio_ ## name ( BIO * bp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write ( name , type ) DECLARE_PEM_write_bio ( name , type ) DECLARE_PEM_write_fp ( name , type ) # define DECLARE_PEM_write_const ( name , type ) DECLARE_PEM_write_bio_const ( name , type ) DECLARE_PEM_write_fp_const ( name , type ) # define DECLARE_PEM_write_cb ( name , type ) DECLARE_PEM_write_cb_bio ( name , type ) DECLARE_PEM_write_cb_fp ( name , type ) # define DECLARE_PEM_read ( name , type ) DECLARE_PEM_read_bio ( name , type ) DECLARE_PEM_read_fp ( name , type ) # define DECLARE_PEM_rw ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write ( name , type ) # define DECLARE_PEM_rw_const ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_const ( name , type ) # define DECLARE_PEM_rw_cb ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_cb ( name , type ) typedef int pem_password_cb ( char * buf , int size , int rwflag , void * userdata ) ;\n int PEM_get_EVP_CIPHER_INFO ( char * header , EVP_CIPHER_INFO * cipher ) ;\n int PEM_do_header ( EVP_CIPHER_INFO * cipher , unsigned char * data , long * len , pem_password_cb * callback , void * u ) ;\n int PEM_read_bio ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n # define PEM_FLAG_SECURE 0x1 # define PEM_FLAG_EAY_COMPATIBLE 0x2 # define PEM_FLAG_ONLY_B64 0x4 int PEM_read_bio_ex ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len , unsigned int flags ) ;\n int PEM_bytes_read_bio_secmem ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n int PEM_write_bio ( BIO * bp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n int PEM_bytes_read_bio ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n void * PEM_ASN1_read_bio ( d2i_of_void * d2i , const char * name , BIO * bp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write_bio ( i2d_of_void * i2d , const char * name , BIO * bp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read_bio ( BIO * bp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n int PEM_X509_INFO_write_bio ( BIO * bp , X509_INFO * xi , EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cd , void * u ) ;\n # ifndef OPENSSL_NO_STDIO int PEM_read ( FILE * fp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n int PEM_write ( FILE * fp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n void * PEM_ASN1_read ( d2i_of_void * d2i , const char * name , FILE * fp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write ( i2d_of_void * i2d , const char * name , FILE * fp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * callback , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read ( FILE * fp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n # endif int PEM_SignInit ( EVP_MD_CTX * ctx , EVP_MD * type ) ;\n int PEM_SignUpdate ( EVP_MD_CTX * ctx , unsigned char * d , unsigned int cnt ) ;\n int PEM_SignFinal ( EVP_MD_CTX * ctx , unsigned char * sigret , unsigned int * siglen , EVP_PKEY * pkey ) ;\n int PEM_def_callback ( char * buf , int num , int rwflag , void * userdata ) ;\n void PEM_proc_type ( char * buf , int type ) ;\n void PEM_dek_info ( char * buf , const char * type , int len , char * str ) ;\n # include < openssl / symhacks . h > DECLARE_PEM_rw ( X509 , X509 ) DECLARE_PEM_rw ( X509_AUX , X509 ) DECLARE_PEM_rw ( X509_REQ , X509_REQ ) DECLARE_PEM_write ( X509_REQ_NEW , X509_REQ ) DECLARE_PEM_rw ( X509_CRL , X509_CRL ) DECLARE_PEM_rw ( PKCS7 , PKCS7 ) DECLARE_PEM_rw ( NETSCAPE_CERT_SEQUENCE , NETSCAPE_CERT_SEQUENCE ) DECLARE_PEM_rw ( PKCS8 , X509_SIG ) DECLARE_PEM_rw ( PKCS8_PRIV_KEY_INFO , PKCS8_PRIV_KEY_INFO ) # ifndef OPENSSL_NO_RSA DECLARE_PEM_rw_cb ( RSAPrivateKey , RSA ) DECLARE_PEM_rw_const ( RSAPublicKey , RSA ) DECLARE_PEM_rw ( RSA_PUBKEY , RSA ) # endif # ifndef OPENSSL_NO_DSA DECLARE_PEM_rw_cb ( DSAPrivateKey , DSA )", "hash": 3599206110384554647, "project": "debian", "size": 25, "target": 0, "idx": 98}
{"code": "int i2d_ ## name ( type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( itname ) # define DECLARE_ASN1_ENCODE_FUNCTIONS_const ( type , name ) type * d2i_ ## name ( type * * a , const unsigned char * * in , long len ) ;\n int i2d_ ## name ( const type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( name ) # define DECLARE_ASN1_NDEF_FUNCTION ( name ) int i2d_ ## name ## _NDEF ( name * a , unsigned char * * out ) ;\n # define DECLARE_ASN1_FUNCTIONS_const ( name ) DECLARE_ASN1_ALLOC_FUNCTIONS ( name ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( name , name ) # define DECLARE_ASN1_ALLOC_FUNCTIONS_name ( type , name ) type * name ## _new ( void ) ;\n void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_NULL ) DECLARE_ASN1_FUNCTIONS ( ASN1_BMPSTRING ) int UTF8_getc ( const unsigned char * str , int len , unsigned long * val ) ;\n int UTF8_putc ( unsigned char * str , int len , unsigned long value ) ;\n DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , ASN1_PRINTABLE ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DIRECTORYSTRING ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DISPLAYTEXT ) DECLARE_ASN1_FUNCTIONS ( ASN1_PRINTABLESTRING )", "hash": 3599206110384554647, "project": "debian", "size": 97, "target": 0, "idx": 100}
{"code": "static ossl_inline type * lh_ ## type ## _delete ( LHASH_OF ( type ) * lh , const type * d ) {\n return ( type * ) OPENSSL_LH_delete ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline type * lh_ ## type ## _retrieve ( LHASH_OF ( type ) * lh , const type * d ) {\n return ( type * ) OPENSSL_LH_retrieve ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline int lh_ ## type ## _error ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_error ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _num_items ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_num_items ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _node_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _node_usage_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_usage_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )", "hash": 3599206110384554647, "project": "debian", "size": 34, "target": 0, "idx": 102}
{"code": "int i2d_ ## name ( type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( itname ) # define DECLARE_ASN1_ENCODE_FUNCTIONS_const ( type , name ) type * d2i_ ## name ( type * * a , const unsigned char * * in , long len ) ;\n int i2d_ ## name ( const type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( name ) # define DECLARE_ASN1_NDEF_FUNCTION ( name ) int i2d_ ## name ## _NDEF ( name * a , unsigned char * * out ) ;\n # define DECLARE_ASN1_FUNCTIONS_const ( name ) DECLARE_ASN1_ALLOC_FUNCTIONS ( name ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( name , name ) # define DECLARE_ASN1_ALLOC_FUNCTIONS_name ( type , name ) type * name ## _new ( void ) ;\n void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_NULL ) DECLARE_ASN1_FUNCTIONS ( ASN1_BMPSTRING ) int UTF8_getc ( const unsigned char * str , int len , unsigned long * val ) ;\n int UTF8_putc ( unsigned char * str , int len , unsigned long value ) ;\n DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , ASN1_PRINTABLE ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DIRECTORYSTRING ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DISPLAYTEXT ) DECLARE_ASN1_FUNCTIONS ( ASN1_PRINTABLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_T61STRING )", "hash": 3599206110384554647, "project": "debian", "size": 97, "target": 0, "idx": 107}
{"code": "static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )", "hash": 3599206110384554647, "project": "debian", "size": 15, "target": 0, "idx": 109}
{"code": "static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char ) typedef void * OPENSSL_BLOCK ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_BLOCK , void )", "hash": 3599206110384554647, "project": "debian", "size": 16, "target": 0, "idx": 110}
{"code": "int PEM_write_bio_ ## name ( BIO * bp , const type * x ) ;\n # define DECLARE_PEM_write_cb_bio ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write ( name , type ) DECLARE_PEM_write_bio ( name , type ) DECLARE_PEM_write_fp ( name , type ) # define DECLARE_PEM_write_const ( name , type ) DECLARE_PEM_write_bio_const ( name , type ) DECLARE_PEM_write_fp_const ( name , type ) # define DECLARE_PEM_write_cb ( name , type ) DECLARE_PEM_write_cb_bio ( name , type ) DECLARE_PEM_write_cb_fp ( name , type ) # define DECLARE_PEM_read ( name , type ) DECLARE_PEM_read_bio ( name , type ) DECLARE_PEM_read_fp ( name , type ) # define DECLARE_PEM_rw ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write ( name , type ) # define DECLARE_PEM_rw_const ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_const ( name , type ) # define DECLARE_PEM_rw_cb ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_cb ( name , type ) typedef int pem_password_cb ( char * buf , int size , int rwflag , void * userdata ) ;\n int PEM_get_EVP_CIPHER_INFO ( char * header , EVP_CIPHER_INFO * cipher ) ;\n int PEM_do_header ( EVP_CIPHER_INFO * cipher , unsigned char * data , long * len , pem_password_cb * callback , void * u ) ;\n int PEM_read_bio ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n # define PEM_FLAG_SECURE 0x1 # define PEM_FLAG_EAY_COMPATIBLE 0x2 # define PEM_FLAG_ONLY_B64 0x4 int PEM_read_bio_ex ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len , unsigned int flags ) ;\n int PEM_bytes_read_bio_secmem ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n int PEM_write_bio ( BIO * bp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n int PEM_bytes_read_bio ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n void * PEM_ASN1_read_bio ( d2i_of_void * d2i , const char * name , BIO * bp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write_bio ( i2d_of_void * i2d , const char * name , BIO * bp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read_bio ( BIO * bp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n int PEM_X509_INFO_write_bio ( BIO * bp , X509_INFO * xi , EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cd , void * u ) ;\n # ifndef OPENSSL_NO_STDIO int PEM_read ( FILE * fp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n int PEM_write ( FILE * fp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n void * PEM_ASN1_read ( d2i_of_void * d2i , const char * name , FILE * fp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write ( i2d_of_void * i2d , const char * name , FILE * fp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * callback , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read ( FILE * fp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n # endif int PEM_SignInit ( EVP_MD_CTX * ctx , EVP_MD * type ) ;\n int PEM_SignUpdate ( EVP_MD_CTX * ctx , unsigned char * d , unsigned int cnt ) ;\n int PEM_SignFinal ( EVP_MD_CTX * ctx , unsigned char * sigret , unsigned int * siglen , EVP_PKEY * pkey ) ;\n int PEM_def_callback ( char * buf , int num , int rwflag , void * userdata ) ;\n void PEM_proc_type ( char * buf , int type ) ;\n void PEM_dek_info ( char * buf , const char * type , int len , char * str ) ;\n # include < openssl / symhacks . h > DECLARE_PEM_rw ( X509 , X509 ) DECLARE_PEM_rw ( X509_AUX , X509 ) DECLARE_PEM_rw ( X509_REQ , X509_REQ ) DECLARE_PEM_write ( X509_REQ_NEW , X509_REQ ) DECLARE_PEM_rw ( X509_CRL , X509_CRL ) DECLARE_PEM_rw ( PKCS7 , PKCS7 ) DECLARE_PEM_rw ( NETSCAPE_CERT_SEQUENCE , NETSCAPE_CERT_SEQUENCE ) DECLARE_PEM_rw ( PKCS8 , X509_SIG ) DECLARE_PEM_rw ( PKCS8_PRIV_KEY_INFO , PKCS8_PRIV_KEY_INFO ) # ifndef OPENSSL_NO_RSA DECLARE_PEM_rw_cb ( RSAPrivateKey , RSA ) DECLARE_PEM_rw_const ( RSAPublicKey , RSA )", "hash": 3599206110384554647, "project": "debian", "size": 26, "target": 0, "idx": 123}
{"code": "int PEM_write_ ## name ( FILE * fp , type * x ) ;\n # define DECLARE_PEM_write_fp_const ( name , type ) int PEM_write_ ## name ( FILE * fp , const type * x ) ;\n # define DECLARE_PEM_write_cb_fp ( name , type ) int PEM_write_ ## name ( FILE * fp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # endif # define DECLARE_PEM_read_bio ( name , type ) type * PEM_read_bio_ ## name ( BIO * bp , type * * x , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write_bio ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , type * x ) ;\n # define DECLARE_PEM_write_bio_const ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , const type * x ) ;\n # define DECLARE_PEM_write_cb_bio ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write ( name , type ) DECLARE_PEM_write_bio ( name , type ) DECLARE_PEM_write_fp ( name , type ) # define DECLARE_PEM_write_const ( name , type ) DECLARE_PEM_write_bio_const ( name , type ) DECLARE_PEM_write_fp_const ( name , type ) # define DECLARE_PEM_write_cb ( name , type ) DECLARE_PEM_write_cb_bio ( name , type ) DECLARE_PEM_write_cb_fp ( name , type ) # define DECLARE_PEM_read ( name , type ) DECLARE_PEM_read_bio ( name , type ) DECLARE_PEM_read_fp ( name , type ) # define DECLARE_PEM_rw ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write ( name , type ) # define DECLARE_PEM_rw_const ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_const ( name , type ) # define DECLARE_PEM_rw_cb ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_cb ( name , type ) typedef int pem_password_cb ( char * buf , int size , int rwflag , void * userdata ) ;\n int PEM_get_EVP_CIPHER_INFO ( char * header , EVP_CIPHER_INFO * cipher ) ;\n int PEM_do_header ( EVP_CIPHER_INFO * cipher , unsigned char * data , long * len , pem_password_cb * callback , void * u ) ;\n int PEM_read_bio ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n # define PEM_FLAG_SECURE 0x1 # define PEM_FLAG_EAY_COMPATIBLE 0x2 # define PEM_FLAG_ONLY_B64 0x4 int PEM_read_bio_ex ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len , unsigned int flags ) ;\n int PEM_bytes_read_bio_secmem ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n int PEM_write_bio ( BIO * bp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n int PEM_bytes_read_bio ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n void * PEM_ASN1_read_bio ( d2i_of_void * d2i , const char * name , BIO * bp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write_bio ( i2d_of_void * i2d , const char * name , BIO * bp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read_bio ( BIO * bp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n int PEM_X509_INFO_write_bio ( BIO * bp , X509_INFO * xi , EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cd , void * u ) ;\n # ifndef OPENSSL_NO_STDIO int PEM_read ( FILE * fp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n int PEM_write ( FILE * fp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n void * PEM_ASN1_read ( d2i_of_void * d2i , const char * name , FILE * fp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write ( i2d_of_void * i2d , const char * name , FILE * fp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * callback , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read ( FILE * fp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n # endif int PEM_SignInit ( EVP_MD_CTX * ctx , EVP_MD * type ) ;\n int PEM_SignUpdate ( EVP_MD_CTX * ctx , unsigned char * d , unsigned int cnt ) ;\n int PEM_SignFinal ( EVP_MD_CTX * ctx , unsigned char * sigret , unsigned int * siglen , EVP_PKEY * pkey ) ;\n int PEM_def_callback ( char * buf , int num , int rwflag , void * userdata ) ;\n void PEM_proc_type ( char * buf , int type ) ;\n void PEM_dek_info ( char * buf , const char * type , int len , char * str ) ;\n # include < openssl / symhacks . h > DECLARE_PEM_rw ( X509 , X509 ) DECLARE_PEM_rw ( X509_AUX , X509 ) DECLARE_PEM_rw ( X509_REQ , X509_REQ ) DECLARE_PEM_write ( X509_REQ_NEW , X509_REQ ) DECLARE_PEM_rw ( X509_CRL , X509_CRL ) DECLARE_PEM_rw ( PKCS7 , PKCS7 ) DECLARE_PEM_rw ( NETSCAPE_CERT_SEQUENCE , NETSCAPE_CERT_SEQUENCE ) DECLARE_PEM_rw ( PKCS8 , X509_SIG ) DECLARE_PEM_rw ( PKCS8_PRIV_KEY_INFO , PKCS8_PRIV_KEY_INFO ) # ifndef OPENSSL_NO_RSA DECLARE_PEM_rw_cb ( RSAPrivateKey , RSA ) DECLARE_PEM_rw_const ( RSAPublicKey , RSA ) DECLARE_PEM_rw ( RSA_PUBKEY , RSA )", "hash": 3599206110384554647, "project": "debian", "size": 31, "target": 0, "idx": 132}
{"code": "static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char ) typedef void * OPENSSL_BLOCK ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_BLOCK , void )", "hash": 3599206110384554647, "project": "debian", "size": 28, "target": 0, "idx": 137}
{"code": "int PEM_write_bio_ ## name ( BIO * bp , type * x ) ;\n # define DECLARE_PEM_write_bio_const ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , const type * x ) ;\n # define DECLARE_PEM_write_cb_bio ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write ( name , type ) DECLARE_PEM_write_bio ( name , type ) DECLARE_PEM_write_fp ( name , type ) # define DECLARE_PEM_write_const ( name , type ) DECLARE_PEM_write_bio_const ( name , type ) DECLARE_PEM_write_fp_const ( name , type ) # define DECLARE_PEM_write_cb ( name , type ) DECLARE_PEM_write_cb_bio ( name , type ) DECLARE_PEM_write_cb_fp ( name , type ) # define DECLARE_PEM_read ( name , type ) DECLARE_PEM_read_bio ( name , type ) DECLARE_PEM_read_fp ( name , type ) # define DECLARE_PEM_rw ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write ( name , type ) # define DECLARE_PEM_rw_const ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_const ( name , type ) # define DECLARE_PEM_rw_cb ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_cb ( name , type ) typedef int pem_password_cb ( char * buf , int size , int rwflag , void * userdata ) ;\n int PEM_get_EVP_CIPHER_INFO ( char * header , EVP_CIPHER_INFO * cipher ) ;\n int PEM_do_header ( EVP_CIPHER_INFO * cipher , unsigned char * data , long * len , pem_password_cb * callback , void * u ) ;\n int PEM_read_bio ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n # define PEM_FLAG_SECURE 0x1 # define PEM_FLAG_EAY_COMPATIBLE 0x2 # define PEM_FLAG_ONLY_B64 0x4 int PEM_read_bio_ex ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len , unsigned int flags ) ;\n int PEM_bytes_read_bio_secmem ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n int PEM_write_bio ( BIO * bp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n int PEM_bytes_read_bio ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n void * PEM_ASN1_read_bio ( d2i_of_void * d2i , const char * name , BIO * bp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write_bio ( i2d_of_void * i2d , const char * name , BIO * bp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read_bio ( BIO * bp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n int PEM_X509_INFO_write_bio ( BIO * bp , X509_INFO * xi , EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cd , void * u ) ;\n # ifndef OPENSSL_NO_STDIO int PEM_read ( FILE * fp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n int PEM_write ( FILE * fp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n void * PEM_ASN1_read ( d2i_of_void * d2i , const char * name , FILE * fp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write ( i2d_of_void * i2d , const char * name , FILE * fp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * callback , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read ( FILE * fp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n # endif int PEM_SignInit ( EVP_MD_CTX * ctx , EVP_MD * type ) ;\n int PEM_SignUpdate ( EVP_MD_CTX * ctx , unsigned char * d , unsigned int cnt ) ;\n int PEM_SignFinal ( EVP_MD_CTX * ctx , unsigned char * sigret , unsigned int * siglen , EVP_PKEY * pkey ) ;\n int PEM_def_callback ( char * buf , int num , int rwflag , void * userdata ) ;\n void PEM_proc_type ( char * buf , int type ) ;\n void PEM_dek_info ( char * buf , const char * type , int len , char * str ) ;\n # include < openssl / symhacks . h > DECLARE_PEM_rw ( X509 , X509 ) DECLARE_PEM_rw ( X509_AUX , X509 ) DECLARE_PEM_rw ( X509_REQ , X509_REQ )", "hash": 3599206110384554647, "project": "debian", "size": 27, "target": 0, "idx": 152}
{"code": "static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )", "hash": 3599206110384554647, "project": "debian", "size": 33, "target": 0, "idx": 169}
{"code": "int i2d_ ## name ( type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( itname ) # define DECLARE_ASN1_ENCODE_FUNCTIONS_const ( type , name ) type * d2i_ ## name ( type * * a , const unsigned char * * in , long len ) ;\n int i2d_ ## name ( const type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( name ) # define DECLARE_ASN1_NDEF_FUNCTION ( name ) int i2d_ ## name ## _NDEF ( name * a , unsigned char * * out ) ;\n # define DECLARE_ASN1_FUNCTIONS_const ( name ) DECLARE_ASN1_ALLOC_FUNCTIONS ( name ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( name , name ) # define DECLARE_ASN1_ALLOC_FUNCTIONS_name ( type , name ) type * name ## _new ( void ) ;\n void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_NULL ) DECLARE_ASN1_FUNCTIONS ( ASN1_BMPSTRING ) int UTF8_getc ( const unsigned char * str , int len , unsigned long * val ) ;\n int UTF8_putc ( unsigned char * str , int len , unsigned long value ) ;\n DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , ASN1_PRINTABLE ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DIRECTORYSTRING )", "hash": 3599206110384554647, "project": "debian", "size": 97, "target": 0, "idx": 170}
{"code": "int i2d_ ## name ( type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( itname ) # define DECLARE_ASN1_ENCODE_FUNCTIONS_const ( type , name ) type * d2i_ ## name ( type * * a , const unsigned char * * in , long len ) ;\n int i2d_ ## name ( const type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( name ) # define DECLARE_ASN1_NDEF_FUNCTION ( name ) int i2d_ ## name ## _NDEF ( name * a , unsigned char * * out ) ;\n # define DECLARE_ASN1_FUNCTIONS_const ( name ) DECLARE_ASN1_ALLOC_FUNCTIONS ( name ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( name , name ) # define DECLARE_ASN1_ALLOC_FUNCTIONS_name ( type , name ) type * name ## _new ( void ) ;\n void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING )", "hash": 3599206110384554647, "project": "debian", "size": 72, "target": 0, "idx": 174}
{"code": "int i2d_ ## name ( type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( itname ) # define DECLARE_ASN1_ENCODE_FUNCTIONS_const ( type , name ) type * d2i_ ## name ( type * * a , const unsigned char * * in , long len ) ;\n int i2d_ ## name ( const type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( name ) # define DECLARE_ASN1_NDEF_FUNCTION ( name ) int i2d_ ## name ## _NDEF ( name * a , unsigned char * * out ) ;\n # define DECLARE_ASN1_FUNCTIONS_const ( name ) DECLARE_ASN1_ALLOC_FUNCTIONS ( name ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( name , name ) # define DECLARE_ASN1_ALLOC_FUNCTIONS_name ( type , name ) type * name ## _new ( void ) ;\n void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE )", "hash": 3599206110384554647, "project": "debian", "size": 49, "target": 0, "idx": 176}
{"code": "int PEM_write_bio_ ## name ( BIO * bp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write ( name , type ) DECLARE_PEM_write_bio ( name , type ) DECLARE_PEM_write_fp ( name , type ) # define DECLARE_PEM_write_const ( name , type ) DECLARE_PEM_write_bio_const ( name , type ) DECLARE_PEM_write_fp_const ( name , type ) # define DECLARE_PEM_write_cb ( name , type ) DECLARE_PEM_write_cb_bio ( name , type ) DECLARE_PEM_write_cb_fp ( name , type ) # define DECLARE_PEM_read ( name , type ) DECLARE_PEM_read_bio ( name , type ) DECLARE_PEM_read_fp ( name , type ) # define DECLARE_PEM_rw ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write ( name , type ) # define DECLARE_PEM_rw_const ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_const ( name , type ) # define DECLARE_PEM_rw_cb ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_cb ( name , type ) typedef int pem_password_cb ( char * buf , int size , int rwflag , void * userdata ) ;\n int PEM_get_EVP_CIPHER_INFO ( char * header , EVP_CIPHER_INFO * cipher ) ;\n int PEM_do_header ( EVP_CIPHER_INFO * cipher , unsigned char * data , long * len , pem_password_cb * callback , void * u ) ;\n int PEM_read_bio ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n # define PEM_FLAG_SECURE 0x1 # define PEM_FLAG_EAY_COMPATIBLE 0x2 # define PEM_FLAG_ONLY_B64 0x4 int PEM_read_bio_ex ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len , unsigned int flags ) ;\n int PEM_bytes_read_bio_secmem ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n int PEM_write_bio ( BIO * bp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n int PEM_bytes_read_bio ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n void * PEM_ASN1_read_bio ( d2i_of_void * d2i , const char * name , BIO * bp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write_bio ( i2d_of_void * i2d , const char * name , BIO * bp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read_bio ( BIO * bp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n int PEM_X509_INFO_write_bio ( BIO * bp , X509_INFO * xi , EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cd , void * u ) ;\n # ifndef OPENSSL_NO_STDIO int PEM_read ( FILE * fp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n int PEM_write ( FILE * fp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n void * PEM_ASN1_read ( d2i_of_void * d2i , const char * name , FILE * fp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write ( i2d_of_void * i2d , const char * name , FILE * fp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * callback , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read ( FILE * fp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n # endif int PEM_SignInit ( EVP_MD_CTX * ctx , EVP_MD * type ) ;\n int PEM_SignUpdate ( EVP_MD_CTX * ctx , unsigned char * d , unsigned int cnt ) ;\n int PEM_SignFinal ( EVP_MD_CTX * ctx , unsigned char * sigret , unsigned int * siglen , EVP_PKEY * pkey ) ;\n int PEM_def_callback ( char * buf , int num , int rwflag , void * userdata ) ;\n void PEM_proc_type ( char * buf , int type ) ;\n void PEM_dek_info ( char * buf , const char * type , int len , char * str ) ;\n # include < openssl / symhacks . h > DECLARE_PEM_rw ( X509 , X509 ) DECLARE_PEM_rw ( X509_AUX , X509 ) DECLARE_PEM_rw ( X509_REQ , X509_REQ ) DECLARE_PEM_write ( X509_REQ_NEW , X509_REQ ) DECLARE_PEM_rw ( X509_CRL , X509_CRL ) DECLARE_PEM_rw ( PKCS7 , PKCS7 ) DECLARE_PEM_rw ( NETSCAPE_CERT_SEQUENCE , NETSCAPE_CERT_SEQUENCE ) DECLARE_PEM_rw ( PKCS8 , X509_SIG ) DECLARE_PEM_rw ( PKCS8_PRIV_KEY_INFO , PKCS8_PRIV_KEY_INFO ) # ifndef OPENSSL_NO_RSA DECLARE_PEM_rw_cb ( RSAPrivateKey , RSA ) DECLARE_PEM_rw_const ( RSAPublicKey , RSA ) DECLARE_PEM_rw ( RSA_PUBKEY , RSA ) # endif # ifndef OPENSSL_NO_DSA DECLARE_PEM_rw_cb ( DSAPrivateKey , DSA ) DECLARE_PEM_rw ( DSA_PUBKEY , DSA ) DECLARE_PEM_rw_const ( DSAparams , DSA ) # endif # ifndef OPENSSL_NO_EC DECLARE_PEM_rw_const ( ECPKParameters , EC_GROUP ) DECLARE_PEM_rw_cb ( ECPrivateKey , EC_KEY ) DECLARE_PEM_rw ( EC_PUBKEY , EC_KEY ) # endif # ifndef OPENSSL_NO_DH DECLARE_PEM_rw_const ( DHparams , DH ) DECLARE_PEM_write_const ( DHxparams , DH ) # endif DECLARE_PEM_rw_cb ( PrivateKey , EVP_PKEY )", "hash": 3599206110384554647, "project": "debian", "size": 25, "target": 0, "idx": 178}
{"code": "int PEM_write_bio_ ## name ( BIO * bp , const type * x ) ;\n # define DECLARE_PEM_write_cb_bio ( name , type ) int PEM_write_bio_ ## name ( BIO * bp , type * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n # define DECLARE_PEM_write ( name , type ) DECLARE_PEM_write_bio ( name , type ) DECLARE_PEM_write_fp ( name , type ) # define DECLARE_PEM_write_const ( name , type ) DECLARE_PEM_write_bio_const ( name , type ) DECLARE_PEM_write_fp_const ( name , type ) # define DECLARE_PEM_write_cb ( name , type ) DECLARE_PEM_write_cb_bio ( name , type ) DECLARE_PEM_write_cb_fp ( name , type ) # define DECLARE_PEM_read ( name , type ) DECLARE_PEM_read_bio ( name , type ) DECLARE_PEM_read_fp ( name , type ) # define DECLARE_PEM_rw ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write ( name , type ) # define DECLARE_PEM_rw_const ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_const ( name , type ) # define DECLARE_PEM_rw_cb ( name , type ) DECLARE_PEM_read ( name , type ) DECLARE_PEM_write_cb ( name , type ) typedef int pem_password_cb ( char * buf , int size , int rwflag , void * userdata ) ;\n int PEM_get_EVP_CIPHER_INFO ( char * header , EVP_CIPHER_INFO * cipher ) ;\n int PEM_do_header ( EVP_CIPHER_INFO * cipher , unsigned char * data , long * len , pem_password_cb * callback , void * u ) ;\n int PEM_read_bio ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n # define PEM_FLAG_SECURE 0x1 # define PEM_FLAG_EAY_COMPATIBLE 0x2 # define PEM_FLAG_ONLY_B64 0x4 int PEM_read_bio_ex ( BIO * bp , char * * name , char * * header , unsigned char * * data , long * len , unsigned int flags ) ;\n int PEM_bytes_read_bio_secmem ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n int PEM_write_bio ( BIO * bp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n int PEM_bytes_read_bio ( unsigned char * * pdata , long * plen , char * * pnm , const char * name , BIO * bp , pem_password_cb * cb , void * u ) ;\n void * PEM_ASN1_read_bio ( d2i_of_void * d2i , const char * name , BIO * bp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write_bio ( i2d_of_void * i2d , const char * name , BIO * bp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cb , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read_bio ( BIO * bp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n int PEM_X509_INFO_write_bio ( BIO * bp , X509_INFO * xi , EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * cd , void * u ) ;\n # ifndef OPENSSL_NO_STDIO int PEM_read ( FILE * fp , char * * name , char * * header , unsigned char * * data , long * len ) ;\n int PEM_write ( FILE * fp , const char * name , const char * hdr , const unsigned char * data , long len ) ;\n void * PEM_ASN1_read ( d2i_of_void * d2i , const char * name , FILE * fp , void * * x , pem_password_cb * cb , void * u ) ;\n int PEM_ASN1_write ( i2d_of_void * i2d , const char * name , FILE * fp , void * x , const EVP_CIPHER * enc , unsigned char * kstr , int klen , pem_password_cb * callback , void * u ) ;\n STACK_OF ( X509_INFO ) * PEM_X509_INFO_read ( FILE * fp , STACK_OF ( X509_INFO ) * sk , pem_password_cb * cb , void * u ) ;\n # endif int PEM_SignInit ( EVP_MD_CTX * ctx , EVP_MD * type ) ;\n int PEM_SignUpdate ( EVP_MD_CTX * ctx , unsigned char * d , unsigned int cnt ) ;\n int PEM_SignFinal ( EVP_MD_CTX * ctx , unsigned char * sigret , unsigned int * siglen , EVP_PKEY * pkey ) ;\n int PEM_def_callback ( char * buf , int num , int rwflag , void * userdata ) ;\n void PEM_proc_type ( char * buf , int type ) ;\n void PEM_dek_info ( char * buf , const char * type , int len , char * str ) ;\n # include < openssl / symhacks . h > DECLARE_PEM_rw ( X509 , X509 ) DECLARE_PEM_rw ( X509_AUX , X509 ) DECLARE_PEM_rw ( X509_REQ , X509_REQ ) DECLARE_PEM_write ( X509_REQ_NEW , X509_REQ ) DECLARE_PEM_rw ( X509_CRL , X509_CRL ) DECLARE_PEM_rw ( PKCS7 , PKCS7 ) DECLARE_PEM_rw ( NETSCAPE_CERT_SEQUENCE , NETSCAPE_CERT_SEQUENCE ) DECLARE_PEM_rw ( PKCS8 , X509_SIG ) DECLARE_PEM_rw ( PKCS8_PRIV_KEY_INFO , PKCS8_PRIV_KEY_INFO ) # ifndef OPENSSL_NO_RSA DECLARE_PEM_rw_cb ( RSAPrivateKey , RSA ) DECLARE_PEM_rw_const ( RSAPublicKey , RSA ) DECLARE_PEM_rw ( RSA_PUBKEY , RSA ) # endif # ifndef OPENSSL_NO_DSA DECLARE_PEM_rw_cb ( DSAPrivateKey , DSA ) DECLARE_PEM_rw ( DSA_PUBKEY , DSA ) DECLARE_PEM_rw_const ( DSAparams , DSA ) # endif # ifndef OPENSSL_NO_EC DECLARE_PEM_rw_const ( ECPKParameters , EC_GROUP ) DECLARE_PEM_rw_cb ( ECPrivateKey , EC_KEY ) DECLARE_PEM_rw ( EC_PUBKEY , EC_KEY ) # endif # ifndef OPENSSL_NO_DH DECLARE_PEM_rw_const ( DHparams , DH )", "hash": 3599206110384554647, "project": "debian", "size": 26, "target": 0, "idx": 183}
{"code": "int i2d_ ## name ( type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( itname ) # define DECLARE_ASN1_ENCODE_FUNCTIONS_const ( type , name ) type * d2i_ ## name ( type * * a , const unsigned char * * in , long len ) ;\n int i2d_ ## name ( const type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( name ) # define DECLARE_ASN1_NDEF_FUNCTION ( name ) int i2d_ ## name ## _NDEF ( name * a , unsigned char * * out ) ;\n # define DECLARE_ASN1_FUNCTIONS_const ( name ) DECLARE_ASN1_ALLOC_FUNCTIONS ( name ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( name , name ) # define DECLARE_ASN1_ALLOC_FUNCTIONS_name ( type , name ) type * name ## _new ( void ) ;\n void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING )", "hash": 3599206110384554647, "project": "debian", "size": 95, "target": 0, "idx": 197}
{"code": "static ossl_inline type * lh_ ## type ## _delete ( LHASH_OF ( type ) * lh , const type * d ) {\n return ( type * ) OPENSSL_LH_delete ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline type * lh_ ## type ## _retrieve ( LHASH_OF ( type ) * lh , const type * d ) {\n return ( type * ) OPENSSL_LH_retrieve ( ( OPENSSL_LHASH * ) lh , d ) ;\n }\n static ossl_inline int lh_ ## type ## _error ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_error ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _num_items ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_num_items ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _node_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _node_usage_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_usage_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING ) ;\n # ifdef _MSC_VER # pragma warning ( push ) # pragma warning ( disable : 4090 ) # endif DEFINE_LHASH_OF ( OPENSSL_CSTRING )", "hash": 3599206110384554647, "project": "debian", "size": 35, "target": 0, "idx": 199}
{"code": "static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char ) typedef void * OPENSSL_BLOCK ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_BLOCK , void )", "hash": 3599206110384554647, "project": "debian", "size": 19, "target": 0, "idx": 211}
{"code": "static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )", "hash": 3599206110384554647, "project": "debian", "size": 16, "target": 0, "idx": 238}
{"code": "X509_ATTRIBUTE * X509_REQ_get_attr ( const X509_REQ * req , int loc ) {\n return X509at_get_attr ( req -> req_info -> attributes , loc ) ;\n }", "hash": 3599206110384554647, "project": "debian", "size": 3, "target": 0, "idx": 274}
{"code": "static ossl_inline t2 * sk_ ## t1 ## _delete ( STACK_OF ( t1 ) * sk , int i ) {\n return ( t2 * ) OPENSSL_sk_delete ( ( OPENSSL_STACK * ) sk , i ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete_ptr ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_delete_ptr ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char )", "hash": 3599206110384554647, "project": "debian", "size": 51, "target": 0, "idx": 280}
{"code": "void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_NULL ) DECLARE_ASN1_FUNCTIONS ( ASN1_BMPSTRING ) int UTF8_getc ( const unsigned char * str , int len , unsigned long * val ) ;\n int UTF8_putc ( unsigned char * str , int len , unsigned long value ) ;\n DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , ASN1_PRINTABLE ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DIRECTORYSTRING ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DISPLAYTEXT ) DECLARE_ASN1_FUNCTIONS ( ASN1_PRINTABLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_T61STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_IA5STRING )", "hash": 3599206110384554647, "project": "debian", "size": 92, "target": 0, "idx": 291}
{"code": "static int tls_process_cke_srp ( SSL * s , PACKET * pkt , int * al ) {\n # ifndef OPENSSL_NO_SRP unsigned int i ;\n const unsigned char * data ;\n if ( ! PACKET_get_net_2 ( pkt , & i ) || ! PACKET_get_bytes ( pkt , & data , i ) ) {\n * al = SSL_AD_DECODE_ERROR ;\n SSLerr ( SSL_F_TLS_PROCESS_CKE_SRP , SSL_R_BAD_SRP_A_LENGTH ) ;\n return 0 ;\n }\n if ( ( s -> srp_ctx . A = BN_bin2bn ( data , i , NULL ) ) == NULL ) {\n SSLerr ( SSL_F_TLS_PROCESS_CKE_SRP , ERR_R_BN_LIB ) ;\n return 0 ;\n }\n if ( BN_ucmp ( s -> srp_ctx . A , s -> srp_ctx . N ) >= 0 || BN_is_zero ( s -> srp_ctx . A ) ) {\n * al = SSL_AD_ILLEGAL_PARAMETER ;\n SSLerr ( SSL_F_TLS_PROCESS_CKE_SRP , SSL_R_BAD_SRP_PARAMETERS ) ;\n return 0 ;\n }\n OPENSSL_free ( s -> session -> srp_username ) ;\n s -> session -> srp_username = OPENSSL_strdup ( s -> srp_ctx . login ) ;\n if ( s -> session -> srp_username == NULL ) {\n SSLerr ( SSL_F_TLS_PROCESS_CKE_SRP , ERR_R_MALLOC_FAILURE ) ;\n return 0 ;\n }\n if ( ! srp_generate_server_master_secret ( s ) ) {\n SSLerr ( SSL_F_TLS_PROCESS_CKE_SRP , ERR_R_INTERNAL_ERROR ) ;\n return 0 ;\n }\n return 1 ;\n # else * al = SSL_AD_INTERNAL_ERROR ;\n SSLerr ( SSL_F_TLS_PROCESS_CKE_SRP , ERR_R_INTERNAL_ERROR ) ;\n return 0 ;\n # endif }", "hash": 1366214969540455677, "project": "debian", "size": 32, "target": 0, "idx": 308}
{"code": "MSG_PROCESS_RETURN tls_process_client_certificate ( SSL * s , PACKET * pkt ) {\n int i , al = SSL_AD_INTERNAL_ERROR , ret = MSG_PROCESS_ERROR ;\n X509 * x = NULL ;\n unsigned long l , llen ;\n const unsigned char * certstart , * certbytes ;\n STACK_OF ( X509 ) * sk = NULL ;\n PACKET spkt ;\n if ( ( sk = sk_X509_new_null ( ) ) == NULL ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE , ERR_R_MALLOC_FAILURE ) ;\n goto f_err ;\n }\n if ( ! PACKET_get_net_3 ( pkt , & llen ) || ! PACKET_get_sub_packet ( pkt , & spkt , llen ) || PACKET_remaining ( pkt ) != 0 ) {\n al = SSL_AD_DECODE_ERROR ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE , SSL_R_LENGTH_MISMATCH ) ;\n goto f_err ;\n }\n while ( PACKET_remaining ( & spkt ) > 0 ) {\n if ( ! PACKET_get_net_3 ( & spkt , & l ) || ! PACKET_get_bytes ( & spkt , & certbytes , l ) ) {\n al = SSL_AD_DECODE_ERROR ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE , SSL_R_CERT_LENGTH_MISMATCH ) ;\n goto f_err ;\n }\n certstart = certbytes ;\n x = d2i_X509 ( NULL , ( const unsigned char * * ) & certbytes , l ) ;\n if ( x == NULL ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE , ERR_R_ASN1_LIB ) ;\n goto f_err ;\n }\n if ( certbytes != ( certstart + l ) ) {\n al = SSL_AD_DECODE_ERROR ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE , SSL_R_CERT_LENGTH_MISMATCH ) ;\n goto f_err ;\n }\n if ( ! sk_X509_push ( sk , x ) ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE , ERR_R_MALLOC_FAILURE ) ;\n goto f_err ;\n }\n x = NULL ;\n }\n if ( sk_X509_num ( sk ) <= 0 ) {\n if ( s -> version == SSL3_VERSION ) {\n al = SSL_AD_HANDSHAKE_FAILURE ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE , SSL_R_NO_CERTIFICATES_RETURNED ) ;\n goto f_err ;\n }\n else if ( ( s -> verify_mode & SSL_VERIFY_PEER ) && ( s -> verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE , SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE ) ;\n al = SSL_AD_HANDSHAKE_FAILURE ;\n goto f_err ;\n }\n if ( s -> s3 -> handshake_buffer && ! ssl3_digest_cached_records ( s , 0 ) ) {\n goto f_err ;\n }\n }\n else {\n EVP_PKEY * pkey ;\n i = ssl_verify_cert_chain ( s , sk ) ;\n if ( i <= 0 ) {\n al = ssl_verify_alarm_type ( s -> verify_result ) ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE , SSL_R_CERTIFICATE_VERIFY_FAILED ) ;\n goto f_err ;\n }\n if ( i > 1 ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE , i ) ;\n al = SSL_AD_HANDSHAKE_FAILURE ;\n goto f_err ;\n }\n pkey = X509_get0_pubkey ( sk_X509_value ( sk , 0 ) ) ;\n if ( pkey == NULL ) {\n al = SSL3_AD_HANDSHAKE_FAILURE ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE , SSL_R_UNKNOWN_CERTIFICATE_TYPE ) ;\n goto f_err ;\n }\n }\n X509_free ( s -> session -> peer ) ;\n s -> session -> peer = sk_X509_shift ( sk ) ;\n s -> session -> verify_result = s -> verify_result ;\n sk_X509_pop_free ( s -> session -> peer_chain , X509_free ) ;\n s -> session -> peer_chain = sk ;\n sk = NULL ;\n ret = MSG_PROCESS_CONTINUE_READING ;\n goto done ;\n f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ;\n ossl_statem_set_error ( s ) ;\n done : X509_free ( x ) ;\n sk_X509_pop_free ( sk , X509_free ) ;\n return ret ;\n }", "hash": 1366214969540455677, "project": "debian", "size": 88, "target": 0, "idx": 309}
{"code": "WORK_STATE ossl_statem_server_post_work ( SSL * s , WORK_STATE wst ) {\n OSSL_STATEM * st = & s -> statem ;\n s -> init_num = 0 ;\n switch ( st -> hand_state ) {\n case TLS_ST_SW_HELLO_REQ : if ( statem_flush ( s ) != 1 ) return WORK_MORE_A ;\n if ( ! ssl3_init_finished_mac ( s ) ) {\n ossl_statem_set_error ( s ) ;\n return WORK_ERROR ;\n }\n break ;\n case DTLS_ST_SW_HELLO_VERIFY_REQUEST : if ( statem_flush ( s ) != 1 ) return WORK_MORE_A ;\n if ( s -> version != DTLS1_BAD_VER && ! ssl3_init_finished_mac ( s ) ) {\n ossl_statem_set_error ( s ) ;\n return WORK_ERROR ;\n }\n s -> first_packet = 1 ;\n break ;\n case TLS_ST_SW_SRVR_HELLO : # ifndef OPENSSL_NO_SCTP if ( SSL_IS_DTLS ( s ) && s -> hit ) {\n unsigned char sctpauthkey [ 64 ] ;\n char labelbuffer [ sizeof ( DTLS1_SCTP_AUTH_LABEL ) ] ;\n memcpy ( labelbuffer , DTLS1_SCTP_AUTH_LABEL , sizeof ( DTLS1_SCTP_AUTH_LABEL ) ) ;\n if ( SSL_export_keying_material ( s , sctpauthkey , sizeof ( sctpauthkey ) , labelbuffer , sizeof ( labelbuffer ) , NULL , 0 , 0 ) <= 0 ) {\n ossl_statem_set_error ( s ) ;\n return WORK_ERROR ;\n }\n BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY , sizeof ( sctpauthkey ) , sctpauthkey ) ;\n }\n # endif break ;\n case TLS_ST_SW_CHANGE : # ifndef OPENSSL_NO_SCTP if ( SSL_IS_DTLS ( s ) && ! s -> hit ) {\n BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY , 0 , NULL ) ;\n }\n # endif if ( ! s -> method -> ssl3_enc -> change_cipher_state ( s , SSL3_CHANGE_CIPHER_SERVER_WRITE ) ) {\n ossl_statem_set_error ( s ) ;\n return WORK_ERROR ;\n }\n if ( SSL_IS_DTLS ( s ) ) dtls1_reset_seq_numbers ( s , SSL3_CC_WRITE ) ;\n break ;\n case TLS_ST_SW_SRVR_DONE : if ( statem_flush ( s ) != 1 ) return WORK_MORE_A ;\n break ;\n case TLS_ST_SW_FINISHED : if ( statem_flush ( s ) != 1 ) return WORK_MORE_A ;\n # ifndef OPENSSL_NO_SCTP if ( SSL_IS_DTLS ( s ) && s -> hit ) {\n BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY , 0 , NULL ) ;\n }\n # endif break ;\n default : break ;\n }\n return WORK_FINISHED_CONTINUE ;\n }", "hash": 1366214969540455677, "project": "debian", "size": 48, "target": 0, "idx": 322}
{"code": "MSG_PROCESS_RETURN tls_process_client_hello ( SSL * s , PACKET * pkt ) {\n int i , al = SSL_AD_INTERNAL_ERROR ;\n unsigned int j , complen = 0 ;\n unsigned long id ;\n const SSL_CIPHER * c ;\n # ifndef OPENSSL_NO_COMP SSL_COMP * comp = NULL ;\n # endif STACK_OF ( SSL_CIPHER ) * ciphers = NULL ;\n int protverr ;\n PACKET session_id , cipher_suites , compression , extensions , cookie ;\n int is_v2_record ;\n static const unsigned char null_compression = 0 ;\n is_v2_record = RECORD_LAYER_is_sslv2_record ( & s -> rlayer ) ;\n PACKET_null_init ( & cookie ) ;\n if ( is_v2_record ) {\n unsigned int version ;\n unsigned int mt ;\n if ( ! PACKET_get_1 ( pkt , & mt ) || mt != SSL2_MT_CLIENT_HELLO ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , ERR_R_INTERNAL_ERROR ) ;\n goto err ;\n }\n if ( ! PACKET_get_net_2 ( pkt , & version ) ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_UNKNOWN_PROTOCOL ) ;\n goto err ;\n }\n if ( version == 0x0002 ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_UNKNOWN_PROTOCOL ) ;\n goto err ;\n }\n else if ( ( version & 0xff00 ) == ( SSL3_VERSION_MAJOR << 8 ) ) {\n s -> client_version = version ;\n }\n else {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_UNKNOWN_PROTOCOL ) ;\n goto err ;\n }\n }\n else {\n if ( ! PACKET_get_net_2 ( pkt , ( unsigned int * ) & s -> client_version ) ) {\n al = SSL_AD_DECODE_ERROR ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_LENGTH_TOO_SHORT ) ;\n goto f_err ;\n }\n }\n if ( ! SSL_IS_DTLS ( s ) ) {\n protverr = ssl_choose_server_version ( s ) ;\n }\n else if ( s -> method -> version != DTLS_ANY_VERSION && DTLS_VERSION_LT ( s -> client_version , s -> version ) ) {\n protverr = SSL_R_VERSION_TOO_LOW ;\n }\n else {\n protverr = 0 ;\n }\n if ( protverr ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , protverr ) ;\n if ( ( ! s -> enc_write_ctx && ! s -> write_hash ) ) {\n s -> version = s -> client_version ;\n }\n al = SSL_AD_PROTOCOL_VERSION ;\n goto f_err ;\n }\n if ( is_v2_record ) {\n unsigned int cipher_len , session_id_len , challenge_len ;\n PACKET challenge ;\n if ( ! PACKET_get_net_2 ( pkt , & cipher_len ) || ! PACKET_get_net_2 ( pkt , & session_id_len ) || ! PACKET_get_net_2 ( pkt , & challenge_len ) ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH ) ;\n al = SSL_AD_DECODE_ERROR ;\n goto f_err ;\n }\n if ( session_id_len > SSL_MAX_SSL_SESSION_ID_LENGTH ) {\n al = SSL_AD_DECODE_ERROR ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_LENGTH_MISMATCH ) ;\n goto f_err ;\n }\n if ( ! PACKET_get_sub_packet ( pkt , & cipher_suites , cipher_len ) || ! PACKET_get_sub_packet ( pkt , & session_id , session_id_len ) || ! PACKET_get_sub_packet ( pkt , & challenge , challenge_len ) || PACKET_remaining ( pkt ) != 0 ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH ) ;\n al = SSL_AD_DECODE_ERROR ;\n goto f_err ;\n }\n challenge_len = challenge_len > SSL3_RANDOM_SIZE ? SSL3_RANDOM_SIZE : challenge_len ;\n memset ( s -> s3 -> client_random , 0 , SSL3_RANDOM_SIZE ) ;\n if ( ! PACKET_copy_bytes ( & challenge , s -> s3 -> client_random + SSL3_RANDOM_SIZE - challenge_len , challenge_len ) || ! PACKET_buf_init ( & compression , & null_compression , 1 ) ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , ERR_R_INTERNAL_ERROR ) ;\n al = SSL_AD_INTERNAL_ERROR ;\n goto f_err ;\n }\n PACKET_null_init ( & extensions ) ;\n }\n else {\n if ( ! PACKET_copy_bytes ( pkt , s -> s3 -> client_random , SSL3_RANDOM_SIZE ) || ! PACKET_get_length_prefixed_1 ( pkt , & session_id ) ) {\n al = SSL_AD_DECODE_ERROR ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_LENGTH_MISMATCH ) ;\n goto f_err ;\n }\n if ( PACKET_remaining ( & session_id ) > SSL_MAX_SSL_SESSION_ID_LENGTH ) {\n al = SSL_AD_DECODE_ERROR ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_LENGTH_MISMATCH ) ;\n goto f_err ;\n }\n if ( SSL_IS_DTLS ( s ) ) {\n if ( ! PACKET_get_length_prefixed_1 ( pkt , & cookie ) ) {\n al = SSL_AD_DECODE_ERROR ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_LENGTH_MISMATCH ) ;\n goto f_err ;\n }\n if ( SSL_get_options ( s ) & SSL_OP_COOKIE_EXCHANGE ) {\n if ( PACKET_remaining ( & cookie ) == 0 ) return 1 ;\n }\n }\n if ( ! PACKET_get_length_prefixed_2 ( pkt , & cipher_suites ) || ! PACKET_get_length_prefixed_1 ( pkt , & compression ) ) {\n al = SSL_AD_DECODE_ERROR ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_LENGTH_MISMATCH ) ;\n goto f_err ;\n }\n extensions = * pkt ;\n }\n if ( SSL_IS_DTLS ( s ) ) {\n if ( SSL_get_options ( s ) & SSL_OP_COOKIE_EXCHANGE ) {\n if ( s -> ctx -> app_verify_cookie_cb != NULL ) {\n if ( s -> ctx -> app_verify_cookie_cb ( s , PACKET_data ( & cookie ) , PACKET_remaining ( & cookie ) ) == 0 ) {\n al = SSL_AD_HANDSHAKE_FAILURE ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_COOKIE_MISMATCH ) ;\n goto f_err ;\n }\n }\n else if ( ! PACKET_equal ( & cookie , s -> d1 -> cookie , s -> d1 -> cookie_len ) ) {\n al = SSL_AD_HANDSHAKE_FAILURE ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_COOKIE_MISMATCH ) ;\n goto f_err ;\n }\n s -> d1 -> cookie_verified = 1 ;\n }\n if ( s -> method -> version == DTLS_ANY_VERSION ) {\n protverr = ssl_choose_server_version ( s ) ;\n if ( protverr != 0 ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , protverr ) ;\n s -> version = s -> client_version ;\n al = SSL_AD_PROTOCOL_VERSION ;\n goto f_err ;\n }\n }\n }\n s -> hit = 0 ;\n if ( is_v2_record || ( s -> new_session && ( s -> options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION ) ) ) {\n if ( ! ssl_get_new_session ( s , 1 ) ) goto err ;\n }\n else {\n i = ssl_get_prev_session ( s , & extensions , & session_id ) ;\n if ( i == 1 && s -> version == s -> session -> ssl_version ) {\n s -> hit = 1 ;\n }\n else if ( i == - 1 ) {\n goto err ;\n }\n else {\n if ( ! ssl_get_new_session ( s , 1 ) ) goto err ;\n }\n }\n if ( ssl_bytes_to_cipher_list ( s , & cipher_suites , & ( ciphers ) , is_v2_record , & al ) == NULL ) {\n goto f_err ;\n }\n if ( s -> hit ) {\n j = 0 ;\n id = s -> session -> cipher -> id ;\n # ifdef CIPHER_DEBUG fprintf ( stderr , \"client sent %d ciphers\\n\" , sk_SSL_CIPHER_num ( ciphers ) ) ;\n # endif for ( i = 0 ;\n i < sk_SSL_CIPHER_num ( ciphers ) ;\n i ++ ) {\n c = sk_SSL_CIPHER_value ( ciphers , i ) ;\n # ifdef CIPHER_DEBUG fprintf ( stderr , \"client [%2d of %2d]:%s\\n\" , i , sk_SSL_CIPHER_num ( ciphers ) , SSL_CIPHER_get_name ( c ) ) ;\n # endif if ( c -> id == id ) {\n j = 1 ;\n break ;\n }\n }\n if ( j == 0 ) {\n al = SSL_AD_ILLEGAL_PARAMETER ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_REQUIRED_CIPHER_MISSING ) ;\n goto f_err ;\n }\n }\n complen = PACKET_remaining ( & compression ) ;\n for ( j = 0 ;\n j < complen ;\n j ++ ) {\n if ( PACKET_data ( & compression ) [ j ] == 0 ) break ;\n }\n if ( j >= complen ) {\n al = SSL_AD_DECODE_ERROR ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_NO_COMPRESSION_SPECIFIED ) ;\n goto f_err ;\n }\n if ( s -> version >= SSL3_VERSION ) {\n if ( ! ssl_parse_clienthello_tlsext ( s , & extensions ) ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_PARSE_TLSEXT ) ;\n goto err ;\n }\n }\n {\n unsigned char * pos ;\n pos = s -> s3 -> server_random ;\n if ( ssl_fill_hello_random ( s , 1 , pos , SSL3_RANDOM_SIZE ) <= 0 ) {\n goto f_err ;\n }\n }\n if ( ! s -> hit && s -> version >= TLS1_VERSION && s -> tls_session_secret_cb ) {\n const SSL_CIPHER * pref_cipher = NULL ;\n s -> session -> master_key_length = sizeof ( s -> session -> master_key ) ;\n if ( s -> tls_session_secret_cb ( s , s -> session -> master_key , & s -> session -> master_key_length , ciphers , & pref_cipher , s -> tls_session_secret_cb_arg ) ) {\n s -> hit = 1 ;\n s -> session -> ciphers = ciphers ;\n s -> session -> verify_result = X509_V_OK ;\n ciphers = NULL ;\n pref_cipher = pref_cipher ? pref_cipher : ssl3_choose_cipher ( s , s -> session -> ciphers , SSL_get_ciphers ( s ) ) ;\n if ( pref_cipher == NULL ) {\n al = SSL_AD_HANDSHAKE_FAILURE ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_NO_SHARED_CIPHER ) ;\n goto f_err ;\n }\n s -> session -> cipher = pref_cipher ;\n sk_SSL_CIPHER_free ( s -> cipher_list ) ;\n s -> cipher_list = sk_SSL_CIPHER_dup ( s -> session -> ciphers ) ;\n sk_SSL_CIPHER_free ( s -> cipher_list_by_id ) ;\n s -> cipher_list_by_id = sk_SSL_CIPHER_dup ( s -> session -> ciphers ) ;\n }\n }\n s -> s3 -> tmp . new_compression = NULL ;\n # ifndef OPENSSL_NO_COMP if ( s -> session -> compress_meth != 0 ) {\n int m , comp_id = s -> session -> compress_meth ;\n unsigned int k ;\n if ( ! ssl_allow_compression ( s ) ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_INCONSISTENT_COMPRESSION ) ;\n goto f_err ;\n }\n for ( m = 0 ;\n m < sk_SSL_COMP_num ( s -> ctx -> comp_methods ) ;\n m ++ ) {\n comp = sk_SSL_COMP_value ( s -> ctx -> comp_methods , m ) ;\n if ( comp_id == comp -> id ) {\n s -> s3 -> tmp . new_compression = comp ;\n break ;\n }\n }\n if ( s -> s3 -> tmp . new_compression == NULL ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_INVALID_COMPRESSION_ALGORITHM ) ;\n goto f_err ;\n }\n for ( k = 0 ;\n k < complen ;\n k ++ ) {\n if ( PACKET_data ( & compression ) [ k ] == comp_id ) break ;\n }\n if ( k >= complen ) {\n al = SSL_AD_ILLEGAL_PARAMETER ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_REQUIRED_COMPRESSION_ALGORITHM_MISSING ) ;\n goto f_err ;\n }\n }\n else if ( s -> hit ) comp = NULL ;\n else if ( ssl_allow_compression ( s ) && s -> ctx -> comp_methods ) {\n int m , nn , v , done = 0 ;\n unsigned int o ;\n nn = sk_SSL_COMP_num ( s -> ctx -> comp_methods ) ;\n for ( m = 0 ;\n m < nn ;\n m ++ ) {\n comp = sk_SSL_COMP_value ( s -> ctx -> comp_methods , m ) ;\n v = comp -> id ;\n for ( o = 0 ;\n o < complen ;\n o ++ ) {\n if ( v == PACKET_data ( & compression ) [ o ] ) {\n done = 1 ;\n break ;\n }\n }\n if ( done ) break ;\n }\n if ( done ) s -> s3 -> tmp . new_compression = comp ;\n else comp = NULL ;\n }\n # else if ( s -> session -> compress_meth != 0 ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_INCONSISTENT_COMPRESSION ) ;\n goto f_err ;\n }\n # endif if ( ! s -> hit ) {\n # ifdef OPENSSL_NO_COMP s -> session -> compress_meth = 0 ;\n # else s -> session -> compress_meth = ( comp == NULL ) ? 0 : comp -> id ;\n # endif sk_SSL_CIPHER_free ( s -> session -> ciphers ) ;\n s -> session -> ciphers = ciphers ;\n if ( ciphers == NULL ) {\n al = SSL_AD_INTERNAL_ERROR ;\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , ERR_R_INTERNAL_ERROR ) ;\n goto f_err ;\n }\n ciphers = NULL ;\n if ( ! tls1_set_server_sigalgs ( s ) ) {\n SSLerr ( SSL_F_TLS_PROCESS_CLIENT_HELLO , SSL_R_CLIENTHELLO_TLSEXT ) ;\n goto err ;\n }\n }\n sk_SSL_CIPHER_free ( ciphers ) ;\n return MSG_PROCESS_CONTINUE_PROCESSING ;\n f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ;\n err : ossl_statem_set_error ( s ) ;\n sk_SSL_CIPHER_free ( ciphers ) ;\n return MSG_PROCESS_ERROR ;\n }", "hash": 1366214969540455677, "project": "debian", "size": 307, "target": 0, "idx": 329}
{"code": "int dtls1_do_write ( SSL * s , int type ) {\n int ret ;\n unsigned int curr_mtu ;\n int retry = 1 ;\n unsigned int len , frag_off , mac_size , blocksize , used_len ;\n if ( ! dtls1_query_mtu ( s ) ) return - 1 ;\n if ( s -> d1 -> mtu < dtls1_min_mtu ( s ) ) return - 1 ;\n if ( s -> init_off == 0 && type == SSL3_RT_HANDSHAKE ) OPENSSL_assert ( s -> init_num == ( int ) s -> d1 -> w_msg_hdr . msg_len + DTLS1_HM_HEADER_LENGTH ) ;\n if ( s -> write_hash ) {\n if ( s -> enc_write_ctx && ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & EVP_CIPH_FLAG_AEAD_CIPHER ) != 0 ) mac_size = 0 ;\n else mac_size = EVP_MD_CTX_size ( s -> write_hash ) ;\n }\n else mac_size = 0 ;\n if ( s -> enc_write_ctx && ( EVP_CIPHER_CTX_mode ( s -> enc_write_ctx ) == EVP_CIPH_CBC_MODE ) ) blocksize = 2 * EVP_CIPHER_CTX_block_size ( s -> enc_write_ctx ) ;\n else blocksize = 0 ;\n frag_off = 0 ;\n s -> rwstate = SSL_NOTHING ;\n while ( s -> init_num > 0 ) {\n if ( type == SSL3_RT_HANDSHAKE && s -> init_off != 0 ) {\n if ( frag_off > 0 ) {\n if ( s -> init_off <= DTLS1_HM_HEADER_LENGTH ) {\n return - 1 ;\n }\n s -> init_off -= DTLS1_HM_HEADER_LENGTH ;\n s -> init_num += DTLS1_HM_HEADER_LENGTH ;\n }\n else {\n frag_off = s -> d1 -> w_msg_hdr . frag_off ;\n }\n }\n used_len = BIO_wpending ( s -> wbio ) + DTLS1_RT_HEADER_LENGTH + mac_size + blocksize ;\n if ( s -> d1 -> mtu > used_len ) curr_mtu = s -> d1 -> mtu - used_len ;\n else curr_mtu = 0 ;\n if ( curr_mtu <= DTLS1_HM_HEADER_LENGTH ) {\n ret = BIO_flush ( s -> wbio ) ;\n if ( ret <= 0 ) {\n s -> rwstate = SSL_WRITING ;\n return ret ;\n }\n used_len = DTLS1_RT_HEADER_LENGTH + mac_size + blocksize ;\n if ( s -> d1 -> mtu > used_len + DTLS1_HM_HEADER_LENGTH ) {\n curr_mtu = s -> d1 -> mtu - used_len ;\n }\n else {\n return - 1 ;\n }\n }\n if ( ( ( unsigned int ) s -> init_num ) > curr_mtu ) len = curr_mtu ;\n else len = s -> init_num ;\n if ( len > INT_MAX ) len = INT_MAX ;\n if ( type == SSL3_RT_HANDSHAKE ) {\n if ( len < DTLS1_HM_HEADER_LENGTH ) {\n return - 1 ;\n }\n dtls1_fix_message_header ( s , frag_off , len - DTLS1_HM_HEADER_LENGTH ) ;\n dtls1_write_message_header ( s , ( unsigned char * ) & s -> init_buf -> data [ s -> init_off ] ) ;\n }\n ret = dtls1_write_bytes ( s , type , & s -> init_buf -> data [ s -> init_off ] , len ) ;\n if ( ret < 0 ) {\n if ( retry && BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_MTU_EXCEEDED , 0 , NULL ) > 0 ) {\n if ( ! ( SSL_get_options ( s ) & SSL_OP_NO_QUERY_MTU ) ) {\n if ( ! dtls1_query_mtu ( s ) ) return - 1 ;\n retry = 0 ;\n }\n else return - 1 ;\n }\n else {\n return ( - 1 ) ;\n }\n }\n else {\n OPENSSL_assert ( len == ( unsigned int ) ret ) ;\n if ( type == SSL3_RT_HANDSHAKE && ! s -> d1 -> retransmitting ) {\n unsigned char * p = ( unsigned char * ) & s -> init_buf -> data [ s -> init_off ] ;\n const struct hm_header_st * msg_hdr = & s -> d1 -> w_msg_hdr ;\n int xlen ;\n if ( frag_off == 0 && s -> version != DTLS1_BAD_VER ) {\n * p ++ = msg_hdr -> type ;\n l2n3 ( msg_hdr -> msg_len , p ) ;\n s2n ( msg_hdr -> seq , p ) ;\n l2n3 ( 0 , p ) ;\n l2n3 ( msg_hdr -> msg_len , p ) ;\n p -= DTLS1_HM_HEADER_LENGTH ;\n xlen = ret ;\n }\n else {\n p += DTLS1_HM_HEADER_LENGTH ;\n xlen = ret - DTLS1_HM_HEADER_LENGTH ;\n }\n if ( ! ssl3_finish_mac ( s , p , xlen ) ) return - 1 ;\n }\n if ( ret == s -> init_num ) {\n if ( s -> msg_callback ) s -> msg_callback ( 1 , s -> version , type , s -> init_buf -> data , ( size_t ) ( s -> init_off + s -> init_num ) , s , s -> msg_callback_arg ) ;\n s -> init_off = 0 ;\n s -> init_num = 0 ;\n return ( 1 ) ;\n }\n s -> init_off += ret ;\n s -> init_num -= ret ;\n ret -= DTLS1_HM_HEADER_LENGTH ;\n frag_off += ret ;\n dtls1_fix_message_header ( s , frag_off , 0 ) ;\n }\n }\n return ( 0 ) ;\n }", "hash": 5575425611513297119, "project": "debian", "size": 106, "target": 0, "idx": 338}
{"code": "static void dtls1_fix_message_header ( SSL * s , unsigned long frag_off , unsigned long frag_len ) {\n struct hm_header_st * msg_hdr = & s -> d1 -> w_msg_hdr ;\n msg_hdr -> frag_off = frag_off ;\n msg_hdr -> frag_len = frag_len ;\n }", "hash": 5575425611513297119, "project": "debian", "size": 5, "target": 0, "idx": 345}
{"code": "int dtls1_retransmit_buffered_messages ( SSL * s ) {\n pqueue * sent = s -> d1 -> sent_messages ;\n piterator iter ;\n pitem * item ;\n hm_fragment * frag ;\n int found = 0 ;\n iter = pqueue_iterator ( sent ) ;\n for ( item = pqueue_next ( & iter ) ;\n item != NULL ;\n item = pqueue_next ( & iter ) ) {\n frag = ( hm_fragment * ) item -> data ;\n if ( dtls1_retransmit_message ( s , ( unsigned short ) dtls1_get_queue_priority ( frag -> msg_header . seq , frag -> msg_header . is_ccs ) , & found ) <= 0 ) return - 1 ;\n }\n return 1 ;\n }", "hash": 5575425611513297119, "project": "debian", "size": 15, "target": 0, "idx": 347}
{"code": "static int version_cmp ( const SSL * s , int a , int b ) {\n int dtls = SSL_IS_DTLS ( s ) ;\n if ( a == b ) return 0 ;\n if ( ! dtls ) return a < b ? - 1 : 1 ;\n return DTLS_VERSION_LT ( a , b ) ? - 1 : 1 ;\n }", "hash": 2709342705526909410, "project": "debian", "size": 6, "target": 0, "idx": 374}
{"code": "int dtls1_new ( SSL * s ) {\n DTLS1_STATE * d1 ;\n if ( ! DTLS_RECORD_LAYER_new ( & s -> rlayer ) ) {\n return 0 ;\n }\n if ( ! ssl3_new ( s ) ) return ( 0 ) ;\n if ( ( d1 = OPENSSL_zalloc ( sizeof ( * d1 ) ) ) == NULL ) {\n ssl3_free ( s ) ;\n return ( 0 ) ;\n }\n d1 -> buffered_messages = pqueue_new ( ) ;\n d1 -> sent_messages = pqueue_new ( ) ;\n if ( s -> server ) {\n d1 -> cookie_len = sizeof ( s -> d1 -> cookie ) ;\n }\n d1 -> link_mtu = 0 ;\n d1 -> mtu = 0 ;\n if ( d1 -> buffered_messages == NULL || d1 -> sent_messages == NULL ) {\n pqueue_free ( d1 -> buffered_messages ) ;\n pqueue_free ( d1 -> sent_messages ) ;\n OPENSSL_free ( d1 ) ;\n ssl3_free ( s ) ;\n return ( 0 ) ;\n }\n s -> d1 = d1 ;\n s -> method -> ssl_clear ( s ) ;\n return ( 1 ) ;\n }", "hash": -3062453801436404700, "project": "debian", "size": 28, "target": 0, "idx": 381}
{"code": "static unsigned int dtls1_link_min_mtu ( void ) {\n return ( g_probable_mtu [ ( sizeof ( g_probable_mtu ) / sizeof ( g_probable_mtu [ 0 ] ) ) - 1 ] ) ;\n }", "hash": -3062453801436404700, "project": "debian", "size": 3, "target": 0, "idx": 389}
{"code": "static Dwarf_Small dwarf_elf_object_access_get_length_size ( void * obj_in ) {\n dwarf_elf_object_access_internals_t * obj = ( dwarf_elf_object_access_internals_t * ) obj_in ;\n return obj -> length_size ;\n }", "hash": 6500423400461365723, "project": "debian", "size": 4, "target": 0, "idx": 411}
{"code": "char * xmlrpc_boolean ( char * buf , int value ) {\n * buf = '\\0' ;\n snprintf ( buf , XMLRPC_BUFSIZE , \"<boolean>%d</boolean>\" , ( value ? 1 : 0 ) ) ;\n return buf ;\n }", "hash": -5249292504513104172, "project": "debian", "size": 5, "target": 0, "idx": 440}
{"code": "char * xmlrpc_decode_string ( char * buf ) {\n const char * p ;\n char * q ;\n p = buf ;\n q = buf ;\n while ( * p != '\\0' ) {\n if ( * p == '&' ) {\n p ++ ;\n if ( ! strncmp ( p , \"gt;\n\" , 3 ) ) * q ++ = '>' , p += 3 ;\n else if ( ! strncmp ( p , \"lt;\n\" , 3 ) ) * q ++ = '<' , p += 3 ;\n else if ( ! strncmp ( p , \"quot;\n\" , 5 ) ) * q ++ = '\"' , p += 5 ;\n else if ( ! strncmp ( p , \"amp;\n\" , 4 ) ) * q ++ = '&' , p += 4 ;\n else if ( * p == '#' ) {\n p ++ ;\n * q ++ = ( char ) atoi ( p ) ;\n while ( * p != ';\n' && * p != '\\0' ) p ++ ;\n }\n }\n else * q ++ = * p ++ ;\n }\n * q = '\\0' ;\n return buf ;\n }", "hash": -5249292504513104172, "project": "debian", "size": 28, "target": 0, "idx": 448}
{"code": "static char * xmlrpc_write_header ( int length ) {\n char buf [ 512 ] ;\n time_t ts ;\n char timebuf [ 64 ] ;\n struct tm tm ;\n * buf = '\\0' ;\n ts = time ( NULL ) ;\n tm = * localtime ( & ts ) ;\n strftime ( timebuf , sizeof timebuf , \"%Y-%m-%d %H:%M:%S\" , & tm ) ;\n snprintf ( buf , sizeof buf , \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\n\" \"Content-Length: %d\\r\\n\" \"Content-Type: text/xml\\r\\n\" \"Date: %s\\r\\n\" \"Server: Atheme/%s\\r\\n\\r\\n\" , length , timebuf , PACKAGE_VERSION ) ;\n return sstrdup ( buf ) ;\n }", "hash": -5249292504513104172, "project": "debian", "size": 12, "target": 0, "idx": 452}
{"code": "char * xmlrpc_string ( char * buf , const char * value ) {\n char encoded [ XMLRPC_BUFSIZE ] ;\n * buf = '\\0' ;\n xmlrpc_char_encode ( encoded , value ) ;\n snprintf ( buf , XMLRPC_BUFSIZE , \"<string>%s</string>\" , encoded ) ;\n return buf ;\n }", "hash": -5249292504513104172, "project": "debian", "size": 7, "target": 0, "idx": 460}
{"code": "inline void mime_hdr_set_accelerator_slotnum ( MIMEHdrImpl * mh , int32_t slot_id , uint32_t slot_num ) {\n ink_assert ( ( slot_id != MIME_SLOTID_NONE ) && ( slot_id < 32 ) ) ;\n ink_assert ( slot_num < 16 ) ;\n uint32_t word_index = slot_id / 8 ;\n uint32_t word = mh -> m_slot_accelerators [ word_index ] ;\n uint32_t nybble = slot_id % 8 ;\n uint32_t shift = nybble * 4 ;\n uint32_t mask = ~ ( MIME_FIELD_SLOTNUM_MASK << shift ) ;\n uint32_t graft = ( slot_num << shift ) ;\n uint32_t new_word = ( word & mask ) | graft ;\n mh -> m_slot_accelerators [ word_index ] = new_word ;\n }", "hash": 2546373479020365143, "project": "debian", "size": 12, "target": 0, "idx": 489}
{"code": "ParseResult mime_scanner_get ( MIMEScanner * S , const char * * raw_input_s , const char * raw_input_e , const char * * output_s , const char * * output_e , bool * output_shares_raw_input , bool raw_input_eof , int raw_input_scan_type ) {\n const char * raw_input_c , * lf_ptr ;\n ParseResult zret = PARSE_RESULT_CONT ;\n static const char RAW_CR = ParseRules : : CHAR_CR ;\n ink_assert ( ( raw_input_s != nullptr ) && ( * raw_input_s != nullptr ) ) ;\n ink_assert ( raw_input_e != nullptr ) ;\n raw_input_c = * raw_input_s ;\n while ( PARSE_RESULT_CONT == zret && raw_input_c < raw_input_e ) {\n ptrdiff_t runway = raw_input_e - raw_input_c ;\n switch ( S -> m_state ) {\n case MIME_PARSE_BEFORE : if ( ParseRules : : is_cr ( * raw_input_c ) ) {\n ++ raw_input_c ;\n if ( runway >= 2 && ParseRules : : is_lf ( * raw_input_c ) ) {\n ++ raw_input_c ;\n zret = PARSE_RESULT_DONE ;\n }\n else {\n S -> m_state = MIME_PARSE_FOUND_CR ;\n }\n }\n else if ( ParseRules : : is_lf ( * raw_input_c ) ) {\n ++ raw_input_c ;\n zret = PARSE_RESULT_DONE ;\n }\n else {\n S -> m_state = MIME_PARSE_INSIDE ;\n }\n break ;\n case MIME_PARSE_FOUND_CR : if ( ParseRules : : is_lf ( * raw_input_c ) ) {\n ++ raw_input_c ;\n zret = PARSE_RESULT_DONE ;\n }\n else {\n mime_scanner_append ( S , & RAW_CR , 1 ) ;\n S -> m_state = MIME_PARSE_INSIDE ;\n }\n break ;\n case MIME_PARSE_INSIDE : lf_ptr = static_cast < const char * > ( memchr ( raw_input_c , ParseRules : : CHAR_LF , runway ) ) ;\n if ( lf_ptr ) {\n raw_input_c = lf_ptr + 1 ;\n if ( MIME_SCANNER_TYPE_LINE == raw_input_scan_type ) {\n zret = PARSE_RESULT_OK ;\n S -> m_state = MIME_PARSE_BEFORE ;\n }\n else {\n S -> m_state = MIME_PARSE_AFTER ;\n }\n }\n else {\n raw_input_c = raw_input_e ;\n }\n break ;\n case MIME_PARSE_AFTER : if ( ParseRules : : is_ws ( * raw_input_c ) ) {\n char * unfold = const_cast < char * > ( raw_input_c - 1 ) ;\n * unfold -- = ' ' ;\n if ( ParseRules : : is_cr ( * unfold ) ) {\n * unfold = ' ' ;\n }\n S -> m_state = MIME_PARSE_INSIDE ;\n }\n else {\n S -> m_state = MIME_PARSE_BEFORE ;\n zret = PARSE_RESULT_OK ;\n }\n break ;\n }\n }\n ptrdiff_t data_size = raw_input_c - * raw_input_s ;\n if ( PARSE_RESULT_CONT == zret ) {\n if ( raw_input_eof ) {\n if ( 0 == data_size ) {\n if ( MIME_PARSE_INSIDE != S -> m_state ) {\n S -> m_state = MIME_PARSE_BEFORE ;\n zret = PARSE_RESULT_DONE ;\n }\n else {\n zret = PARSE_RESULT_ERROR ;\n }\n }\n else if ( MIME_PARSE_AFTER == S -> m_state ) {\n S -> m_state = MIME_PARSE_BEFORE ;\n zret = PARSE_RESULT_OK ;\n }\n else {\n zret = PARSE_RESULT_ERROR ;\n }\n }\n else if ( data_size ) {\n if ( MIME_PARSE_INSIDE == S -> m_state ) {\n mime_scanner_append ( S , * raw_input_s , data_size ) ;\n data_size = 0 ;\n }\n else if ( MIME_PARSE_AFTER == S -> m_state ) {\n S -> m_state = MIME_PARSE_BEFORE ;\n zret = PARSE_RESULT_OK ;\n }\n }\n }\n if ( data_size && S -> m_line_length ) {\n mime_scanner_append ( S , * raw_input_s , data_size ) ;\n }\n * output_shares_raw_input = 0 == S -> m_line_length ;\n if ( PARSE_RESULT_CONT != zret ) {\n if ( 0 != S -> m_line_length ) {\n * output_s = S -> m_line ;\n * output_e = * output_s + S -> m_line_length ;\n S -> m_line_length = 0 ;\n }\n else {\n * output_s = * raw_input_s ;\n * output_e = raw_input_c ;\n }\n }\n if ( zret != PARSE_RESULT_ERROR && memchr ( * raw_input_s , '\\0' , raw_input_c - * raw_input_s ) != nullptr ) {\n zret = PARSE_RESULT_ERROR ;\n }\n * raw_input_s = raw_input_c ;\n return zret ;\n }", "hash": 2546373479020365143, "project": "debian", "size": 119, "target": 0, "idx": 490}
{"code": "void mime_hdr_presence_set ( MIMEHdrImpl * h , int well_known_str_index ) {\n const char * wks = hdrtoken_index_to_wks ( well_known_str_index ) ;\n mime_hdr_presence_set ( h , wks ) ;\n }", "hash": 2546373479020365143, "project": "debian", "size": 4, "target": 0, "idx": 501}
{"code": "uint32_t mime_parse_uint ( const char * buf , const char * end ) {\n uint32_t num ;\n if ( ! buf || ( buf == end ) ) {\n return 0 ;\n }\n if ( is_digit ( * buf ) ) {\n num = * buf ++ - '0' ;\n while ( ( buf != end ) && is_digit ( * buf ) ) {\n num = ( num * 10 ) + ( * buf ++ - '0' ) ;\n }\n return num ;\n }\n else {\n num = 0 ;\n while ( ( buf != end ) && ParseRules : : is_space ( * buf ) ) {\n buf += 1 ;\n }\n while ( ( buf != end ) && is_digit ( * buf ) ) {\n num = ( num * 10 ) + ( * buf ++ - '0' ) ;\n }\n return num ;\n }\n }", "hash": 2546373479020365143, "project": "debian", "size": 23, "target": 0, "idx": 508}
{"code": "int mime_hdr_print ( HdrHeap * , MIMEHdrImpl * mh , char * buf_start , int buf_length , int * buf_index_inout , int * buf_chars_to_skip_inout ) {\n MIMEFieldBlockImpl * fblock ;\n MIMEField * field ;\n uint32_t index ;\n # define SIMPLE_MIME_HDR_PRINT # ifdef SIMPLE_MIME_HDR_PRINT for ( fblock = & ( mh -> m_first_fblock ) ;\n fblock != nullptr ;\n fblock = fblock -> m_next ) {\n for ( index = 0 ;\n index < fblock -> m_freetop ;\n index ++ ) {\n field = & ( fblock -> m_field_slots [ index ] ) ;\n if ( field -> is_live ( ) ) {\n if ( ! mime_field_print ( field , buf_start , buf_length , buf_index_inout , buf_chars_to_skip_inout ) ) {\n return 0 ;\n }\n }\n }\n }\n # else for ( fblock = & ( mh -> m_first_fblock ) ;\n fblock != NULL ;\n fblock = fblock -> m_next ) {\n const char * contig_start = NULL ;\n int this_length , contig_length = 0 ;\n for ( index = 0 ;\n index < fblock -> m_freetop ;\n index ++ ) {\n field = & ( fblock -> m_field_slots [ index ] ) ;\n this_length = field -> m_len_name + field -> m_len_value + field -> m_n_v_raw_printable_pad ;\n if ( field -> is_live ( ) ) {\n if ( ( field -> m_ptr_name == contig_start + contig_length ) && field -> m_n_v_raw_printable && ( ( buf_index_inout == NULL ) || ( contig_length + this_length <= buf_length - * buf_index_inout ) ) ) {\n contig_length += this_length ;\n }\n else {\n if ( contig_length > 0 ) {\n if ( ! mime_mem_print ( contig_start , contig_length , buf_start , buf_length , buf_index_inout , buf_chars_to_skip_inout ) ) return 0 ;\n }\n contig_start = field -> m_ptr_name ;\n contig_length = this_length ;\n }\n }\n }\n if ( contig_length > 0 ) {\n if ( ! mime_mem_print ( contig_start , contig_length , buf_start , buf_length , buf_index_inout , buf_chars_to_skip_inout ) ) return 0 ;\n }\n }\n # endif if ( ! mime_mem_print ( \"\\r\\n\" , 2 , buf_start , buf_length , buf_index_inout , buf_chars_to_skip_inout ) ) {\n return 0 ;\n }\n return 1 ;\n }", "hash": 2546373479020365143, "project": "debian", "size": 50, "target": 0, "idx": 517}
{"code": "int mime_parse_year ( const char * & buf , const char * end , int * year ) {\n int val ;\n while ( ( buf != end ) && * buf && ! is_digit ( * buf ) ) {\n buf += 1 ;\n }\n if ( ( buf == end ) || ( * buf == '\\0' ) ) {\n return 0 ;\n }\n val = 0 ;\n while ( ( buf != end ) && * buf && is_digit ( * buf ) ) {\n val = ( val * 10 ) + ( * buf ++ - '0' ) ;\n }\n if ( val >= 1900 ) {\n val -= 1900 ;\n }\n else if ( val < 70 ) {\n val += 100 ;\n }\n * year = val ;\n return 1 ;\n }", "hash": 2546373479020365143, "project": "debian", "size": 21, "target": 0, "idx": 541}
{"code": "void mime_hdr_presence_unset ( MIMEHdrImpl * h , int well_known_str_index ) {\n const char * wks = hdrtoken_index_to_wks ( well_known_str_index ) ;\n mime_hdr_presence_unset ( h , wks ) ;\n }", "hash": 2546373479020365143, "project": "debian", "size": 4, "target": 0, "idx": 544}
{"code": "MIMEField * mime_field_create ( HdrHeap * heap , MIMEHdrImpl * mh ) {\n MIMEField * field ;\n MIMEFieldBlockImpl * tail_fblock , * new_fblock ;\n tail_fblock = mh -> m_fblock_list_tail ;\n if ( tail_fblock -> m_freetop >= MIME_FIELD_BLOCK_SLOTS ) {\n new_fblock = ( MIMEFieldBlockImpl * ) heap -> allocate_obj ( sizeof ( MIMEFieldBlockImpl ) , HDR_HEAP_OBJ_FIELD_BLOCK ) ;\n _mime_hdr_field_block_init ( new_fblock ) ;\n tail_fblock -> m_next = new_fblock ;\n tail_fblock = new_fblock ;\n mh -> m_fblock_list_tail = new_fblock ;\n }\n field = & ( tail_fblock -> m_field_slots [ tail_fblock -> m_freetop ] ) ;\n ++ tail_fblock -> m_freetop ;\n mime_field_init ( field ) ;\n return field ;\n }", "hash": 2546373479020365143, "project": "debian", "size": 16, "target": 0, "idx": 547}
{"code": "void mime_hdr_field_block_list_adjust ( int , MIMEFieldBlockImpl * old_list , MIMEFieldBlockImpl * new_list ) {\n for ( MIMEFieldBlockImpl * new_blk = new_list ;\n new_blk ;\n new_blk = new_blk -> m_next ) {\n for ( MIMEField * field = new_blk -> m_field_slots , * end = field + new_blk -> m_freetop ;\n field != end ;\n ++ field ) {\n if ( field -> is_live ( ) && field -> m_next_dup ) {\n relocate ( field , new_list , old_list ) ;\n }\n }\n }\n }", "hash": 2546373479020365143, "project": "debian", "size": 13, "target": 0, "idx": 561}
{"code": "inline static int is_digit ( char c ) {\n return ( ( c <= '9' ) && ( c >= '0' ) ) ;\n }", "hash": 2546373479020365143, "project": "debian", "size": 3, "target": 0, "idx": 564}
{"code": "static void http_skip_ws ( const char * & buf , int & len ) {\n while ( len > 0 && * buf && ParseRules : : is_ws ( * buf ) ) {\n buf += 1 ;\n len -= 1 ;\n }\n }", "hash": 4976989049001279223, "project": "debian", "size": 6, "target": 0, "idx": 572}
{"code": "const char * http_hdr_method_get ( HTTPHdrImpl * hh , int * length ) {\n const char * str ;\n ink_assert ( hh -> m_polarity == HTTP_TYPE_REQUEST ) ;\n if ( hh -> u . req . m_method_wks_idx >= 0 ) {\n str = hdrtoken_index_to_wks ( hh -> u . req . m_method_wks_idx ) ;\n * length = hdrtoken_index_to_length ( hh -> u . req . m_method_wks_idx ) ;\n }\n else {\n str = hh -> u . req . m_ptr_method ;\n * length = hh -> u . req . m_len_method ;\n }\n return ( str ) ;\n }", "hash": 4976989049001279223, "project": "debian", "size": 13, "target": 0, "idx": 585}
{"code": "void http_hdr_reason_set ( HdrHeap * heap , HTTPHdrImpl * hh , const char * value , int length , bool must_copy ) {\n ink_assert ( hh -> m_polarity == HTTP_TYPE_RESPONSE ) ;\n mime_str_u16_set ( heap , value , length , & ( hh -> u . resp . m_ptr_reason ) , & ( hh -> u . resp . m_len_reason ) , must_copy ) ;\n }", "hash": 4976989049001279223, "project": "debian", "size": 4, "target": 0, "idx": 599}
{"code": "SPL_METHOD ( DirectoryIterator , seek ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n zval * retval = NULL ;\n long pos ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"l\" , & pos ) == FAILURE ) {\n return ;\n }\n if ( intern -> u . dir . index > pos ) {\n zend_call_method_with_0_params ( & this_ptr , Z_OBJCE_P ( getThis ( ) ) , & intern -> u . dir . func_rewind , \"rewind\" , & retval ) ;\n if ( retval ) {\n zval_ptr_dtor ( & retval ) ;\n retval = NULL ;\n }\n }\n while ( intern -> u . dir . index < pos ) {\n int valid = 0 ;\n zend_call_method_with_0_params ( & this_ptr , Z_OBJCE_P ( getThis ( ) ) , & intern -> u . dir . func_valid , \"valid\" , & retval ) ;\n if ( retval ) {\n valid = zend_is_true ( retval ) ;\n zval_ptr_dtor ( & retval ) ;\n retval = NULL ;\n }\n if ( ! valid ) {\n break ;\n }\n zend_call_method_with_0_params ( & this_ptr , Z_OBJCE_P ( getThis ( ) ) , & intern -> u . dir . func_next , \"next\" , & retval ) ;\n if ( retval ) {\n zval_ptr_dtor ( & retval ) ;\n }\n }\n }", "hash": 1223258652239369123, "project": "debian", "size": 31, "target": 0, "idx": 632}
{"code": "static void spl_filesystem_dir_open ( spl_filesystem_object * intern , char * path TSRMLS_DC ) {\n int skip_dots = SPL_HAS_FLAG ( intern -> flags , SPL_FILE_DIR_SKIPDOTS ) ;\n intern -> type = SPL_FS_DIR ;\n intern -> _path_len = strlen ( path ) ;\n intern -> u . dir . dirp = php_stream_opendir ( path , REPORT_ERRORS , FG ( default_context ) ) ;\n if ( intern -> _path_len > 1 && IS_SLASH_AT ( path , intern -> _path_len - 1 ) ) {\n intern -> _path = estrndup ( path , -- intern -> _path_len ) ;\n }\n else {\n intern -> _path = estrndup ( path , intern -> _path_len ) ;\n }\n intern -> u . dir . index = 0 ;\n if ( EG ( exception ) || intern -> u . dir . dirp == NULL ) {\n intern -> u . dir . entry . d_name [ 0 ] = '\\0' ;\n if ( ! EG ( exception ) ) {\n zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 TSRMLS_CC , \"Failed to open directory \\\"%s\\\"\" , path ) ;\n }\n }\n else {\n do {\n spl_filesystem_dir_read ( intern TSRMLS_CC ) ;\n }\n while ( skip_dots && spl_filesystem_is_dot ( intern -> u . dir . entry . d_name ) ) ;\n }\n }", "hash": 1223258652239369123, "project": "debian", "size": 25, "target": 0, "idx": 647}
{"code": "zend_object_iterator * spl_filesystem_tree_get_iterator ( zend_class_entry * ce , zval * object , int by_ref TSRMLS_DC ) {\n spl_filesystem_iterator * iterator ;\n spl_filesystem_object * dir_object ;\n if ( by_ref ) {\n zend_error ( E_ERROR , \"An iterator cannot be used with foreach by reference\" ) ;\n }\n dir_object = ( spl_filesystem_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ;\n iterator = spl_filesystem_object_to_iterator ( dir_object ) ;\n if ( iterator -> intern . data == NULL ) {\n iterator -> intern . data = object ;\n iterator -> intern . funcs = & spl_filesystem_tree_it_funcs ;\n }\n zval_add_ref ( & object ) ;\n return ( zend_object_iterator * ) iterator ;\n }", "hash": 1223258652239369123, "project": "debian", "size": 15, "target": 0, "idx": 692}
{"code": "static int spl_filesystem_file_read ( spl_filesystem_object * intern , int silent TSRMLS_DC ) {\n char * buf ;\n size_t line_len = 0 ;\n long line_add = ( intern -> u . file . current_line || intern -> u . file . current_zval ) ? 1 : 0 ;\n spl_filesystem_file_free_line ( intern TSRMLS_CC ) ;\n if ( php_stream_eof ( intern -> u . file . stream ) ) {\n if ( ! silent ) {\n zend_throw_exception_ex ( spl_ce_RuntimeException , 0 TSRMLS_CC , \"Cannot read from file %s\" , intern -> file_name ) ;\n }\n return FAILURE ;\n }\n if ( intern -> u . file . max_line_len > 0 ) {\n buf = safe_emalloc ( ( intern -> u . file . max_line_len + 1 ) , sizeof ( char ) , 0 ) ;\n if ( php_stream_get_line ( intern -> u . file . stream , buf , intern -> u . file . max_line_len + 1 , & line_len ) == NULL ) {\n efree ( buf ) ;\n buf = NULL ;\n }\n else {\n buf [ line_len ] = '\\0' ;\n }\n }\n else {\n buf = php_stream_get_line ( intern -> u . file . stream , NULL , 0 , & line_len ) ;\n }\n if ( ! buf ) {\n intern -> u . file . current_line = estrdup ( \"\" ) ;\n intern -> u . file . current_line_len = 0 ;\n }\n else {\n if ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_DROP_NEW_LINE ) ) {\n line_len = strcspn ( buf , \"\\r\\n\" ) ;\n buf [ line_len ] = '\\0' ;\n }\n intern -> u . file . current_line = buf ;\n intern -> u . file . current_line_len = line_len ;\n }\n intern -> u . file . current_line_num += line_add ;\n return SUCCESS ;\n }", "hash": 1223258652239369123, "project": "debian", "size": 39, "target": 0, "idx": 694}
{"code": "static void spl_filesystem_file_free_line ( spl_filesystem_object * intern TSRMLS_DC ) {\n if ( intern -> u . file . current_line ) {\n efree ( intern -> u . file . current_line ) ;\n intern -> u . file . current_line = NULL ;\n }\n if ( intern -> u . file . current_zval ) {\n zval_ptr_dtor ( & intern -> u . file . current_zval ) ;\n intern -> u . file . current_zval = NULL ;\n }\n }", "hash": 1223258652239369123, "project": "debian", "size": 10, "target": 0, "idx": 697}
{"code": "SPL_METHOD ( RecursiveDirectoryIterator , __construct ) {\n spl_filesystem_object_construct ( INTERNAL_FUNCTION_PARAM_PASSTHRU , DIT_CTOR_FLAGS ) ;\n }", "hash": 1223258652239369123, "project": "debian", "size": 3, "target": 0, "idx": 702}
{"code": "static void spl_filesystem_dir_it_dtor ( zend_object_iterator * iter TSRMLS_DC ) {\n spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ;\n if ( iterator -> intern . data ) {\n zval * object = iterator -> intern . data ;\n zval_ptr_dtor ( & object ) ;\n }\n }", "hash": 1223258652239369123, "project": "debian", "size": 7, "target": 0, "idx": 722}
{"code": "zend_function * spl_filesystem_object_get_method_check ( zval * * object_ptr , char * method , int method_len , const struct _zend_literal * key TSRMLS_DC ) {\n spl_filesystem_object * fsobj = zend_object_store_get_object ( * object_ptr TSRMLS_CC ) ;\n if ( fsobj -> u . dir . entry . d_name [ 0 ] == '\\0' && fsobj -> orig_path == NULL ) {\n method = \"_bad_state_ex\" ;\n method_len = sizeof ( \"_bad_state_ex\" ) - 1 ;\n key = NULL ;\n }\n return zend_get_std_object_handlers ( ) -> get_method ( object_ptr , method , method_len , key TSRMLS_CC ) ;\n }", "hash": 1223258652239369123, "project": "debian", "size": 9, "target": 0, "idx": 725}
{"code": "SPL_METHOD ( SplFileObject , eof ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_BOOL ( php_stream_eof ( intern -> u . file . stream ) ) ;\n }", "hash": 1223258652239369123, "project": "debian", "size": 7, "target": 0, "idx": 728}
{"code": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl )", "hash": 5825340398912191389, "project": "debian", "size": 3, "target": 0, "idx": 742}
{"code": "static unsigned char * extra_open_record ( unsigned char * bp , int dr_len , struct isoent * isoent , struct ctl_extr_rec * ctl ) {\n ctl -> bp = bp ;\n if ( bp != NULL ) bp += dr_len ;\n ctl -> use_extr = 0 ;\n ctl -> isoent = isoent ;\n ctl -> ce_ptr = NULL ;\n ctl -> cur_len = ctl -> dr_len = dr_len ;\n ctl -> limit = DR_LIMIT ;\n return ( bp ) ;\n }", "hash": -2607754285145856562, "project": "debian", "size": 10, "target": 0, "idx": 763}
{"code": "static unsigned char * extra_get_record ( struct isoent * isoent , int * space , int * off , int * loc ) {\n struct extr_rec * rec ;\n isoent = isoent -> parent ;\n if ( off != NULL ) {\n rec = isoent -> extr_rec_list . current ;\n if ( DR_SAFETY > LOGICAL_BLOCK_SIZE - rec -> offset ) rec = rec -> next ;\n }\n else {\n rec = extra_last_record ( isoent ) ;\n if ( rec == NULL || DR_SAFETY > LOGICAL_BLOCK_SIZE - rec -> offset ) {\n rec = malloc ( sizeof ( * rec ) ) ;\n if ( rec == NULL ) return ( NULL ) ;\n rec -> location = 0 ;\n rec -> offset = 0 ;\n rec -> next = NULL ;\n if ( isoent -> extr_rec_list . last == NULL ) isoent -> extr_rec_list . last = & ( isoent -> extr_rec_list . first ) ;\n * isoent -> extr_rec_list . last = rec ;\n isoent -> extr_rec_list . last = & ( rec -> next ) ;\n }\n }\n * space = LOGICAL_BLOCK_SIZE - rec -> offset - DR_SAFETY ;\n if ( * space & 0x01 ) * space -= 1 ;\n if ( off != NULL ) * off = rec -> offset ;\n if ( loc != NULL ) * loc = rec -> location ;\n isoent -> extr_rec_list . current = rec ;\n return ( & rec -> buf [ rec -> offset ] ) ;\n }", "hash": -2607754285145856562, "project": "debian", "size": 27, "target": 0, "idx": 768}
{"code": "static int write_VD_boot_record ( struct archive_write * a ) {\n struct iso9660 * iso9660 ;\n unsigned char * bp ;\n iso9660 = a -> format_data ;\n bp = wb_buffptr ( a ) - 1 ;\n set_VD_bp ( bp , VDT_BOOT_RECORD , 1 ) ;\n memcpy ( bp + 8 , \"EL TORITO SPECIFICATION\" , 23 ) ;\n set_unused_field_bp ( bp , 8 + 23 , 39 ) ;\n set_unused_field_bp ( bp , 40 , 71 ) ;\n set_num_731 ( bp + 72 , iso9660 -> el_torito . catalog -> file -> content . location ) ;\n set_unused_field_bp ( bp , 76 , LOGICAL_BLOCK_SIZE ) ;\n return ( wb_consume ( a , LOGICAL_BLOCK_SIZE ) ) ;\n }", "hash": -2607754285145856562, "project": "debian", "size": 13, "target": 0, "idx": 785}
{"code": "static int isoent_alloc_path_table ( struct archive_write * a , struct vdd * vdd , int max_depth ) {\n int i ;\n vdd -> max_depth = max_depth ;\n vdd -> pathtbl = malloc ( sizeof ( * vdd -> pathtbl ) * vdd -> max_depth ) ;\n if ( vdd -> pathtbl == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate memory\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n for ( i = 0 ;\n i < vdd -> max_depth ;\n i ++ ) {\n vdd -> pathtbl [ i ] . first = NULL ;\n vdd -> pathtbl [ i ] . last = & ( vdd -> pathtbl [ i ] . first ) ;\n vdd -> pathtbl [ i ] . sorted = NULL ;\n vdd -> pathtbl [ i ] . cnt = 0 ;\n }\n return ( ARCHIVE_OK ) ;\n }", "hash": -2607754285145856562, "project": "debian", "size": 18, "target": 0, "idx": 801}
{"code": "static void isofile_free ( struct isofile * file ) {\n struct content * con , * tmp ;\n con = file -> content . next ;\n while ( con != NULL ) {\n tmp = con ;\n con = con -> next ;\n free ( tmp ) ;\n }\n archive_entry_free ( file -> entry ) ;\n archive_string_free ( & ( file -> parentdir ) ) ;\n archive_string_free ( & ( file -> basename ) ) ;\n archive_string_free ( & ( file -> basename_utf16 ) ) ;\n archive_string_free ( & ( file -> symlink ) ) ;\n free ( file ) ;\n }", "hash": -2607754285145856562, "project": "debian", "size": 15, "target": 0, "idx": 812}
{"code": "static int set_file_identifier ( unsigned char * bp , int from , int to , enum vdc vdc , struct archive_write * a , struct vdd * vdd , struct archive_string * id , const char * label , int leading_under , enum char_type char_type ) {\n char identifier [ 256 ] ;\n struct isoent * isoent ;\n const char * ids ;\n size_t len ;\n int r ;\n if ( id -> length > 0 && leading_under && id -> s [ 0 ] != '_' ) {\n if ( char_type == A_CHAR ) r = set_str_a_characters_bp ( a , bp , from , to , id -> s , vdc ) ;\n else r = set_str_d_characters_bp ( a , bp , from , to , id -> s , vdc ) ;\n }\n else if ( id -> length > 0 ) {\n ids = id -> s ;\n if ( leading_under ) ids ++ ;\n isoent = isoent_find_entry ( vdd -> rootent , ids ) ;\n if ( isoent == NULL ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Not Found %s `%s'.\" , label , ids ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n len = isoent -> ext_off + isoent -> ext_len ;\n if ( vdd -> vdd_type == VDD_JOLIET ) {\n if ( len > sizeof ( identifier ) - 2 ) len = sizeof ( identifier ) - 2 ;\n }\n else {\n if ( len > sizeof ( identifier ) - 1 ) len = sizeof ( identifier ) - 1 ;\n }\n memcpy ( identifier , isoent -> identifier , len ) ;\n identifier [ len ] = '\\0' ;\n if ( vdd -> vdd_type == VDD_JOLIET ) {\n identifier [ len + 1 ] = 0 ;\n vdc = VDC_UCS2_DIRECT ;\n }\n if ( char_type == A_CHAR ) r = set_str_a_characters_bp ( a , bp , from , to , identifier , vdc ) ;\n else r = set_str_d_characters_bp ( a , bp , from , to , identifier , vdc ) ;\n }\n else {\n if ( char_type == A_CHAR ) r = set_str_a_characters_bp ( a , bp , from , to , NULL , vdc ) ;\n else r = set_str_d_characters_bp ( a , bp , from , to , NULL , vdc ) ;\n }\n return ( r ) ;\n }", "hash": -2607754285145856562, "project": "debian", "size": 40, "target": 0, "idx": 829}
{"code": "static int zisofs_rewind_boot_file ( struct archive_write * a ) {\n struct iso9660 * iso9660 = a -> format_data ;\n if ( iso9660 -> el_torito . boot -> file -> zisofs . header_size != 0 ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"We cannot extract the zisofs imaged boot file;\n\" \" this may not boot in being zisofs imaged\" ) ;\n return ( ARCHIVE_FAILED ) ;\n }\n return ( ARCHIVE_OK ) ;\n }", "hash": -2607754285145856562, "project": "debian", "size": 9, "target": 0, "idx": 831}
{"code": "static int idr_ensure_poolsize ( struct archive_write * a , struct idr * idr , int cnt ) {\n if ( idr -> pool_size < cnt ) {\n void * p ;\n const int bk = ( 1 << 7 ) - 1 ;\n int psize ;\n psize = ( cnt + bk ) & ~ bk ;\n p = realloc ( idr -> idrent_pool , sizeof ( struct idrent ) * psize ) ;\n if ( p == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate memory\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n idr -> idrent_pool = ( struct idrent * ) p ;\n idr -> pool_size = psize ;\n }\n return ( ARCHIVE_OK ) ;\n }", "hash": -2607754285145856562, "project": "debian", "size": 16, "target": 0, "idx": 840}
{"code": "static int set_str_d_characters_bp ( struct archive_write * a , unsigned char * bp , int from , int to , const char * s , enum vdc vdc ) {\n int r ;\n switch ( vdc ) {\n case VDC_STD : set_str ( bp + from , s , to - from + 1 , 0x20 , d_characters_map ) ;\n r = ARCHIVE_OK ;\n break ;\n case VDC_LOWERCASE : set_str ( bp + from , s , to - from + 1 , 0x20 , d1_characters_map ) ;\n r = ARCHIVE_OK ;\n break ;\n case VDC_UCS2 : case VDC_UCS2_DIRECT : r = set_str_utf16be ( a , bp + from , s , to - from + 1 , 0x0020 , vdc ) ;\n break ;\n default : r = ARCHIVE_FATAL ;\n }\n return ( r ) ;\n }", "hash": -2607754285145856562, "project": "debian", "size": 15, "target": 0, "idx": 842}
{"code": "static size_t fd_boot_image_size ( int media_type ) {\n switch ( media_type ) {\n case BOOT_MEDIA_1_2M_DISKETTE : return ( FD_1_2M_SIZE ) ;\n case BOOT_MEDIA_1_44M_DISKETTE : return ( FD_1_44M_SIZE ) ;\n case BOOT_MEDIA_2_88M_DISKETTE : return ( FD_2_88M_SIZE ) ;\n default : return ( 0 ) ;\n }\n }", "hash": -2607754285145856562, "project": "debian", "size": 8, "target": 0, "idx": 845}
{"code": "static void idr_cleanup ( struct idr * idr ) {\n free ( idr -> idrent_pool ) ;\n }", "hash": -2607754285145856562, "project": "debian", "size": 3, "target": 0, "idx": 859}
{"code": "static int isoent_cmp_key_iso9660 ( const struct archive_rb_node * node , const void * key ) {\n const struct isoent * isoent = ( const struct isoent * ) key ;\n const struct idrent * idrent = ( const struct idrent * ) node ;\n return ( isoent_cmp_iso9660_identifier ( isoent , idrent -> isoent ) ) ;\n }", "hash": -2607754285145856562, "project": "debian", "size": 5, "target": 0, "idx": 880}
{"code": "static inline unsigned char * wb_buffptr ( struct archive_write * a ) {\n struct iso9660 * iso9660 = ( struct iso9660 * ) a -> format_data ;\n return ( & ( iso9660 -> wbuff [ sizeof ( iso9660 -> wbuff ) - iso9660 -> wbuff_remaining ] ) ) ;\n }", "hash": -2607754285145856562, "project": "debian", "size": 4, "target": 0, "idx": 890}
{"code": "static int isofile_hd_cmp_node ( const struct archive_rb_node * n1 , const struct archive_rb_node * n2 ) {\n const struct hardlink * h1 = ( const struct hardlink * ) n1 ;\n const struct hardlink * h2 = ( const struct hardlink * ) n2 ;\n return ( strcmp ( archive_entry_pathname ( h1 -> file_list . first -> entry ) , archive_entry_pathname ( h2 -> file_list . first -> entry ) ) ) ;\n }", "hash": -2607754285145856562, "project": "debian", "size": 5, "target": 0, "idx": 894}
{"code": "static void dissect_udvm_bytecode ( tvbuff_t * udvm_tvb , packet_info * pinfo , proto_tree * sigcomp_udvm_tree , guint start_address ) {\n guint instruction ;\n gint offset = 0 ;\n gint start_offset = 0 ;\n gint len ;\n gint n ;\n guint instruction_no = 0 ;\n guint16 value = 0 ;\n proto_item * item , * item2 ;\n guint UDVM_address = start_address ;\n gboolean is_memory_address ;\n guint16 msg_length = tvb_reported_length_remaining ( udvm_tvb , offset ) ;\n while ( msg_length > offset ) {\n instruction = tvb_get_guint8 ( udvm_tvb , offset ) ;\n instruction_no ++ ;\n UDVM_address = start_address + offset ;\n item = proto_tree_add_uint_format ( sigcomp_udvm_tree , hf_sigcomp_udvm_instruction , udvm_tvb , offset , 1 , instruction_no , \"######### UDVM instruction %u at UDVM-address %u (0x%x) #########\" , instruction_no , UDVM_address , UDVM_address ) ;\n PROTO_ITEM_SET_GENERATED ( item ) ;\n proto_tree_add_item ( sigcomp_udvm_tree , hf_sigcomp_udvm_instr , udvm_tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n switch ( instruction ) {\n case SIGCOMP_INSTR_AND : offset = dissect_udvm_reference_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_1 , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2 , udvm_tvb , start_offset , len , value ) ;\n }\n break ;\n case SIGCOMP_INSTR_OR : offset = dissect_udvm_reference_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_1 , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2 , udvm_tvb , start_offset , len , value ) ;\n }\n break ;\n case SIGCOMP_INSTR_NOT : offset = dissect_udvm_reference_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_1 , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_LSHIFT : offset = dissect_udvm_reference_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_1 , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2 , udvm_tvb , start_offset , len , value ) ;\n }\n break ;\n case SIGCOMP_INSTR_RSHIFT : offset = dissect_udvm_reference_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_1 , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2 , udvm_tvb , start_offset , len , value ) ;\n }\n break ;\n case SIGCOMP_INSTR_ADD : offset = dissect_udvm_reference_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_1 , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2 , udvm_tvb , start_offset , len , value ) ;\n }\n break ;\n case SIGCOMP_INSTR_SUBTRACT : offset = dissect_udvm_reference_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_1 , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2 , udvm_tvb , start_offset , len , value ) ;\n }\n break ;\n case SIGCOMP_INSTR_MULTIPLY : offset = dissect_udvm_reference_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_1 , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2 , udvm_tvb , start_offset , len , value ) ;\n }\n break ;\n case SIGCOMP_INSTR_DIVIDE : offset = dissect_udvm_reference_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_1 , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2 , udvm_tvb , start_offset , len , value ) ;\n }\n break ;\n case SIGCOMP_INSTR_REMAINDER : offset = dissect_udvm_reference_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_1 , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_operand_2 , udvm_tvb , start_offset , len , value ) ;\n }\n break ;\n case SIGCOMP_INSTR_SORT_ASCENDING : offset = offset + tvb_reported_length_remaining ( udvm_tvb , offset ) ;\n break ;\n case SIGCOMP_INSTR_SORT_DESCENDING : offset = offset + tvb_reported_length_remaining ( udvm_tvb , offset ) ;\n break ;\n case SIGCOMP_INSTR_SHA_1 : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_position , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_length , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_length , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_reference_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_ref_dest , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_LOAD : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_address , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_value , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_value , udvm_tvb , start_offset , len , value ) ;\n }\n break ;\n case SIGCOMP_INSTR_MULTILOAD : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_address , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_literal_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_literal_num , udvm_tvb , start_offset , len , value ) ;\n n = value ;\n while ( n > 0 ) {\n n = n - 1 ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_value , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_value , udvm_tvb , start_offset , len , value ) ;\n }\n }\n break ;\n case SIGCOMP_INSTR_PUSH : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_value , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_value , udvm_tvb , start_offset , len , value ) ;\n }\n break ;\n case SIGCOMP_INSTR_POP : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_address , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_COPY : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_position , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_length , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_length , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_reference_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_ref_dest , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_COPY_LITERAL : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_position , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_length , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_length , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_reference_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_ref_dest , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_COPY_OFFSET : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_offset , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_offset , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_length , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_length , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_reference_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_ref_dest , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_MEMSET : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_address , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_length , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_length , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_start_value , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_offset , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_JUMP : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n value = ( value + UDVM_address ) & 0xffff ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_at_address , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_COMPARE : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_value , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_value , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_value , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_value , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n value = ( value + UDVM_address ) & 0xffff ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_at_address , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n value = ( value + UDVM_address ) & 0xffff ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_at_address , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n value = ( value + UDVM_address ) & 0xffff ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_at_address , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_CALL : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n value = ( value + UDVM_address ) & 0xffff ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_at_address , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_RETURN : break ;\n case SIGCOMP_INSTR_SWITCH : offset = dissect_udvm_literal_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_literal_num , udvm_tvb , start_offset , len , value ) ;\n n = value ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_j , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_j , udvm_tvb , start_offset , len , value ) ;\n }\n while ( n > 0 ) {\n n = n - 1 ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n value = ( value + UDVM_address ) & 0xffff ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_at_address , udvm_tvb , start_offset , len , value ) ;\n }\n break ;\n case SIGCOMP_INSTR_CRC : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_value , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_value , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_position , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_length , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_length , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n value = ( value + UDVM_address ) & 0xffff ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_at_address , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_INPUT_BYTES : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_length , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_length , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_destination , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_destination , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n value = ( value + UDVM_address ) & 0xffff ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_at_address , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_INPUT_BITS : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_length , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_length , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_destination , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_destination , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n value = ( value + UDVM_address ) & 0xffff ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_at_address , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_INPUT_HUFFMAN : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_destination , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_destination , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n value = ( value + UDVM_address ) & 0xffff ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_at_address , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_literal_operand ( udvm_tvb , sigcomp_udvm_tree , offset , & start_offset , & value ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_literal_num , udvm_tvb , start_offset , len , value ) ;\n n = value ;\n while ( n > 0 ) {\n n = n - 1 ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_bits , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_lower_bound , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_upper_bound , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , FALSE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_uncompressed , udvm_tvb , start_offset , len , value ) ;\n }\n break ;\n case SIGCOMP_INSTR_STATE_ACCESS : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_partial_identifier_start , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_partial_identifier_length , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_state_begin , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_length_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_length , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_address_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_address , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_instr , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_STATE_CREATE : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_length_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_length , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_address_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_address , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_instr , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_min_acc_len , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_ret_pri , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_STATE_FREE : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_partial_identifier_start , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_partial_identifier_length , udvm_tvb , start_offset , len , value ) ;\n break ;\n case SIGCOMP_INSTR_OUTPUT : offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_addr_output_start , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_output_start , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_output_length_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_output_length , udvm_tvb , start_offset , len , value ) ;\n }\n break ;\n case SIGCOMP_INSTR_END_MESSAGE : if ( ( msg_length - 1 ) < offset ) {\n proto_tree_add_expert ( sigcomp_udvm_tree , pinfo , & ei_sigcomp_all_remaining_parameters_zero , udvm_tvb , 0 , - 1 ) ;\n return ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_req_feedback_loc , udvm_tvb , start_offset , len , value ) ;\n if ( ( msg_length - 1 ) < offset ) {\n proto_tree_add_expert ( sigcomp_udvm_tree , pinfo , & ei_sigcomp_all_remaining_parameters_zero , udvm_tvb , offset - 1 , - 1 ) ;\n return ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_ret_param_loc , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_length_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_length , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n if ( is_memory_address ) {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_address_addr , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_address , udvm_tvb , start_offset , len , value ) ;\n }\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_instr , udvm_tvb , start_offset , len , value ) ;\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_min_acc_len , udvm_tvb , start_offset , len , value ) ;\n if ( tvb_reported_length_remaining ( udvm_tvb , offset ) != 0 ) {\n offset = dissect_udvm_multitype_operand ( udvm_tvb , sigcomp_udvm_tree , offset , TRUE , & start_offset , & value , & is_memory_address ) ;\n len = offset - start_offset ;\n proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_state_ret_pri , udvm_tvb , start_offset , len , value ) ;\n }\n else {\n item2 = proto_tree_add_uint_format_value ( sigcomp_udvm_tree , hf_udvm_state_ret_pri , udvm_tvb , offset , 1 , 0 , \"0 (Not in the uploaded code as UDVM buffer initialized to Zero\" ) ;\n PROTO_ITEM_SET_GENERATED ( item2 ) ;\n }\n if ( tvb_reported_length_remaining ( udvm_tvb , offset ) != 0 ) {\n len = tvb_reported_length_remaining ( udvm_tvb , offset ) ;\n UDVM_address = start_address + offset ;\n proto_tree_add_bytes_format ( sigcomp_udvm_tree , hf_sigcomp_remaining_bytes , udvm_tvb , offset , len , NULL , \"Remaining %u bytes starting at UDVM addr %u (0x%x)- State information ?\" , len , UDVM_address , UDVM_address ) ;\n }\n offset = offset + tvb_reported_length_remaining ( udvm_tvb , offset ) ;\n break ;\n default : offset = offset + tvb_reported_length_remaining ( udvm_tvb , offset ) ;\n break ;\n }\n }\n return ;\n }", "hash": -7777644912037188223, "project": "debian", "size": 559, "target": 0, "idx": 901}
{"code": "static void sigcomp_init_udvm ( void ) {\n gchar * partial_state_str ;\n guint8 * sip_sdp_buff , * presence_buff ;\n state_buffer_table = g_hash_table_new_full ( g_str_hash , g_str_equal , g_free , g_free ) ;\n sip_sdp_buff = ( guint8 * ) g_malloc ( SIP_SDP_STATE_LENGTH + 8 ) ;\n partial_state_str = bytes_to_str ( NULL , sip_sdp_state_identifier , 6 ) ;\n memset ( sip_sdp_buff , 0 , 8 ) ;\n sip_sdp_buff [ 0 ] = SIP_SDP_STATE_LENGTH >> 8 ;\n sip_sdp_buff [ 1 ] = SIP_SDP_STATE_LENGTH & 0xff ;\n memcpy ( sip_sdp_buff + 8 , sip_sdp_static_dictionaty_for_sigcomp , SIP_SDP_STATE_LENGTH ) ;\n g_hash_table_insert ( state_buffer_table , g_strdup ( partial_state_str ) , sip_sdp_buff ) ;\n wmem_free ( NULL , partial_state_str ) ;\n presence_buff = ( guint8 * ) g_malloc ( PRESENCE_STATE_LENGTH + 8 ) ;\n partial_state_str = bytes_to_str ( NULL , presence_state_identifier , 6 ) ;\n memset ( presence_buff , 0 , 8 ) ;\n presence_buff [ 0 ] = PRESENCE_STATE_LENGTH >> 8 ;\n presence_buff [ 1 ] = PRESENCE_STATE_LENGTH & 0xff ;\n memcpy ( presence_buff + 8 , presence_static_dictionary_for_sigcomp , PRESENCE_STATE_LENGTH ) ;\n g_hash_table_insert ( state_buffer_table , g_strdup ( partial_state_str ) , presence_buff ) ;\n wmem_free ( NULL , partial_state_str ) ;\n }", "hash": -7777644912037188223, "project": "debian", "size": 21, "target": 0, "idx": 903}
{"code": "static int decomp_dispatch_get_bits ( tvbuff_t * message_tvb , proto_tree * udvm_tree , guint8 bit_order , guint8 * buff , guint16 * old_input_bit_order , guint16 * remaining_bits , guint16 * input_bits , guint * input_address , guint16 length , guint16 * result_code , guint msg_end , gboolean print_level_1 ) {\n guint16 input_bit_order ;\n guint16 bits_still_required = length ;\n guint16 value = 0 ;\n guint8 octet ;\n gint extra_bytes_available = msg_end - * input_address ;\n gint p_bit ;\n gint prev_p_bit = * old_input_bit_order & 0x0001 ;\n gint bits_to_use = 0 ;\n input_bit_order = buff [ 68 ] << 8 ;\n input_bit_order = input_bit_order | buff [ 69 ] ;\n * result_code = 0 ;\n p_bit = ( input_bit_order & 0x0001 ) != 0 ;\n if ( prev_p_bit != p_bit ) {\n * remaining_bits = 0 ;\n * old_input_bit_order = input_bit_order ;\n }\n if ( * remaining_bits + extra_bytes_available * 8 < length ) {\n * result_code = 11 ;\n return 0xfbad ;\n }\n while ( bits_still_required > 0 ) {\n if ( * remaining_bits == 0 ) {\n octet = tvb_get_guint8 ( message_tvb , * input_address ) ;\n if ( print_level_1 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_sigcomp_getting_value , message_tvb , * input_address , 1 , octet , \" Getting value: %u (0x%x) From Addr: %u\" , octet , octet , * input_address ) ;\n }\n * input_address = * input_address + 1 ;\n if ( p_bit != 0 ) {\n octet = reverse [ octet ] ;\n }\n * input_bits = octet ;\n * remaining_bits = 8 ;\n }\n bits_to_use = bits_still_required < * remaining_bits ? bits_still_required : * remaining_bits ;\n bits_still_required -= bits_to_use ;\n * input_bits <<= bits_to_use ;\n value = ( value << bits_to_use ) | ( ( * input_bits >> 8 ) & 0xFF ) ;\n * remaining_bits -= bits_to_use ;\n * input_bits &= 0x00FF ;\n }\n if ( ( bit_order != 0 ) && ( length <= 16 ) ) {\n guint16 lsb = reverse [ ( value >> 8 ) & 0xFF ] ;\n guint16 msb = reverse [ value & 0xFF ] ;\n value = ( ( msb << 8 ) | lsb ) >> ( 16 - length ) ;\n }\n return value ;\n }", "hash": -7777644912037188223, "project": "debian", "size": 48, "target": 0, "idx": 908}
{"code": "static int dissect_udvm_reference_operand_memory ( guint8 * buff , guint operand_address , guint16 * value , guint * result_dest ) {\n guint bytecode ;\n guint16 operand ;\n guint offset = operand_address ;\n guint test_bits ;\n guint8 temp_data ;\n guint16 temp_data16 ;\n if ( operand_address >= UDVM_MEMORY_SIZE ) return - 1 ;\n bytecode = buff [ operand_address ] ;\n test_bits = bytecode >> 7 ;\n if ( test_bits == 1 ) {\n test_bits = bytecode >> 6 ;\n if ( test_bits == 2 ) {\n temp_data = buff [ operand_address ] & 0x3f ;\n operand = temp_data << 8 ;\n temp_data = buff [ ( operand_address + 1 ) & 0xffff ] ;\n operand = operand | temp_data ;\n operand = ( operand * 2 ) ;\n * result_dest = operand ;\n temp_data16 = buff [ operand ] << 8 ;\n temp_data16 = temp_data16 | buff [ ( operand + 1 ) & 0xffff ] ;\n * value = temp_data16 ;\n offset = offset + 2 ;\n }\n else {\n operand_address ++ ;\n operand = buff [ operand_address ] << 8 ;\n operand = operand | buff [ ( operand_address + 1 ) & 0xffff ] ;\n * result_dest = operand ;\n temp_data16 = buff [ operand ] << 8 ;\n temp_data16 = temp_data16 | buff [ ( operand + 1 ) & 0xffff ] ;\n * value = temp_data16 ;\n offset = offset + 3 ;\n }\n }\n else {\n operand = ( bytecode & 0x7f ) ;\n operand = ( operand * 2 ) ;\n * result_dest = operand ;\n temp_data16 = buff [ operand ] << 8 ;\n temp_data16 = temp_data16 | buff [ ( operand + 1 ) & 0xffff ] ;\n * value = temp_data16 ;\n offset ++ ;\n }\n if ( offset >= UDVM_MEMORY_SIZE || * result_dest >= UDVM_MEMORY_SIZE - 1 ) return - 1 ;\n return offset ;\n }", "hash": -7777644912037188223, "project": "debian", "size": 47, "target": 0, "idx": 911}
{"code": "static int dissect_udvm_reference_operand ( tvbuff_t * udvm_tvb , proto_tree * sigcomp_udvm_tree , gint offset , gint * start_offset , guint16 * value ) {\n guint bytecode ;\n guint16 operand ;\n guint test_bits ;\n guint display_bytecode ;\n bytecode = tvb_get_guint8 ( udvm_tvb , offset ) ;\n test_bits = bytecode >> 7 ;\n if ( test_bits == 1 ) {\n test_bits = bytecode >> 6 ;\n if ( test_bits == 2 ) {\n display_bytecode = bytecode & 0xc0 ;\n if ( display_udvm_bytecode ) proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_reference_bytecode , udvm_tvb , offset , 1 , display_bytecode ) ;\n operand = tvb_get_ntohs ( udvm_tvb , offset ) & 0x3fff ;\n * value = ( operand * 2 ) ;\n * start_offset = offset ;\n offset = offset + 2 ;\n }\n else {\n display_bytecode = bytecode & 0xc0 ;\n if ( display_udvm_bytecode ) proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_reference_bytecode , udvm_tvb , offset , 1 , display_bytecode ) ;\n offset ++ ;\n operand = tvb_get_ntohs ( udvm_tvb , offset ) ;\n * value = operand ;\n * start_offset = offset ;\n offset = offset + 2 ;\n }\n }\n else {\n display_bytecode = bytecode & 0xc0 ;\n if ( display_udvm_bytecode ) proto_tree_add_uint ( sigcomp_udvm_tree , hf_udvm_reference_bytecode , udvm_tvb , offset , 1 , display_bytecode ) ;\n operand = ( bytecode & 0x7f ) ;\n * value = ( operand * 2 ) ;\n * start_offset = offset ;\n offset ++ ;\n }\n return offset ;\n }", "hash": -7777644912037188223, "project": "debian", "size": 37, "target": 0, "idx": 914}
{"code": "int set_wep_key ( char * string ) {\n int bit = 0 ;\n char * p , type ;\n char * tok ;\n char s [ strlen ( string ) + 1 ] ;\n u_char tmp_wkey [ 512 ] ;\n size_t tmp_wkey_len ;\n char tmp [ 128 ] ;\n memset ( GBL_WIFI -> wkey , 0 , sizeof ( GBL_WIFI -> wkey ) ) ;\n GBL_WIFI -> wkey_len = 0 ;\n strcpy ( s , string ) ;\n p = ec_strtok ( s , \":\" , & tok ) ;\n if ( p == NULL ) SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n bit = atoi ( p ) ;\n if ( bit <= 0 ) SEMIFATAL_ERROR ( \"Unsupported WEP key length\" ) ;\n tmp_wkey_len = bit / 8 - WEP_IV_LEN ;\n if ( bit != 64 && bit != 128 ) SEMIFATAL_ERROR ( \"Unsupported WEP key length\" ) ;\n p = ec_strtok ( NULL , \":\" , & tok ) ;\n if ( p == NULL ) SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n type = * p ;\n p = ec_strtok ( NULL , \":\" , & tok ) ;\n if ( p == NULL ) SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n if ( type == 's' ) {\n if ( strescape ( ( char * ) tmp_wkey , p , strlen ( tmp_wkey ) + 1 ) != ( int ) tmp_wkey_len ) SEMIFATAL_ERROR ( \"Specified WEP key length does not match the given string\" ) ;\n }\n else if ( type == 'p' ) {\n if ( bit == 64 ) make_key_64 ( ( u_char * ) p , tmp_wkey ) ;\n else if ( bit == 128 ) make_key_128 ( ( u_char * ) p , tmp_wkey ) ;\n }\n else {\n SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n }\n USER_MSG ( \"Using WEP key: %s\\n\" , str_tohex ( tmp_wkey , tmp_wkey_len , tmp , sizeof ( tmp ) ) ) ;\n memcpy ( GBL_WIFI -> wkey , tmp_wkey , sizeof ( GBL_WIFI -> wkey ) ) ;\n GBL_WIFI -> wkey_len = tmp_wkey_len ;\n return E_SUCCESS ;\n }", "hash": 9083170310480750768, "project": "debian", "size": 37, "target": 0, "idx": 936}
{"code": "static void gtkui_connection_purge ( void * conn ) {\n struct row_pairs * row , * nextrow , * list = connections ;\n ( void ) conn ;\n DEBUG_MSG ( \"gtkui_connection_purge\" ) ;\n connections = NULL ;\n for ( row = list ;\n row ;\n row = nextrow ) {\n nextrow = row -> next ;\n SAFE_FREE ( row ) ;\n }\n conntrack_purge ( ) ;\n gtk_list_store_clear ( GTK_LIST_STORE ( ls_conns ) ) ;\n }", "hash": 6790518433053241091, "project": "debian", "size": 14, "target": 0, "idx": 970}
{"code": "static void gtkui_kill_connections ( void ) {\n DEBUG_MSG ( \"gtk_kill_connections\" ) ;\n g_source_remove ( connections_idle ) ;\n gtk_widget_destroy ( conns_window ) ;\n conns_window = NULL ;\n }", "hash": 6790518433053241091, "project": "debian", "size": 6, "target": 0, "idx": 981}
{"code": "static void inject_user ( void ) {\n size_t len ;\n len = strescape ( ( char * ) injectbuf , ( char * ) injectbuf , strlen ( injectbuf ) + 1 ) ;\n if ( wdg_c1 -> flags & WDG_OBJ_FOCUSED ) {\n user_inject ( injectbuf , len , curr_conn , 1 ) ;\n }\n else if ( wdg_c2 -> flags & WDG_OBJ_FOCUSED ) {\n user_inject ( injectbuf , len , curr_conn , 2 ) ;\n }\n }", "hash": 8895005875911486570, "project": "debian", "size": 10, "target": 0, "idx": 989}
{"code": "static int dissect_opcua_message ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n FctParse pfctParse = NULL ;\n enum MessageType msgtype = MSG_INVALID ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"OpcUa\" ) ;\n if ( tvb_memeql ( tvb , 0 , \"HEL\" , 3 ) == 0 ) {\n msgtype = MSG_HELLO ;\n pfctParse = parseHello ;\n }\n else if ( tvb_memeql ( tvb , 0 , \"ACK\" , 3 ) == 0 ) {\n msgtype = MSG_ACKNOWLEDGE ;\n pfctParse = parseAcknowledge ;\n }\n else if ( tvb_memeql ( tvb , 0 , \"ERR\" , 3 ) == 0 ) {\n msgtype = MSG_ERROR ;\n pfctParse = parseError ;\n }\n else if ( tvb_memeql ( tvb , 0 , \"MSG\" , 3 ) == 0 ) {\n msgtype = MSG_MESSAGE ;\n pfctParse = parseMessage ;\n }\n else if ( tvb_memeql ( tvb , 0 , \"OPN\" , 3 ) == 0 ) {\n msgtype = MSG_OPENSECURECHANNEL ;\n pfctParse = parseOpenSecureChannel ;\n }\n else if ( tvb_memeql ( tvb , 0 , \"CLO\" , 3 ) == 0 ) {\n msgtype = MSG_CLOSESECURECHANNEL ;\n pfctParse = parseCloseSecureChannel ;\n }\n else {\n msgtype = MSG_INVALID ;\n }\n col_set_str ( pinfo -> cinfo , COL_INFO , g_szMessageTypes [ msgtype ] ) ;\n if ( pfctParse ) {\n gint offset = 0 ;\n int iServiceId = - 1 ;\n tvbuff_t * next_tvb = tvb ;\n gboolean bParseService = TRUE ;\n gboolean bIsLastFragment = FALSE ;\n proto_item * ti = NULL ;\n proto_tree * transport_tree = NULL ;\n ti = proto_tree_add_item ( tree , proto_opcua , tvb , 0 , - 1 , ENC_NA ) ;\n transport_tree = proto_item_add_subtree ( ti , ett_opcua_transport ) ;\n if ( msgtype == MSG_MESSAGE ) {\n guint8 chunkType = 0 ;\n guint32 opcua_seqid = 0 ;\n guint32 opcua_num = 0 ;\n guint32 opcua_seqnum = 0 ;\n fragment_head * frag_msg = NULL ;\n offset = 3 ;\n chunkType = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n offset += 4 ;\n offset += 4 ;\n offset += 4 ;\n opcua_num = tvb_get_letohl ( tvb , offset ) ;\n offset += 4 ;\n opcua_seqid = tvb_get_letohl ( tvb , offset ) ;\n offset += 4 ;\n if ( chunkType == 'A' ) {\n fragment_delete ( & opcua_reassembly_table , pinfo , opcua_seqid , NULL ) ;\n col_clear_fence ( pinfo -> cinfo , COL_INFO ) ;\n col_set_str ( pinfo -> cinfo , COL_INFO , \"Abort message\" ) ;\n offset = 0 ;\n ( * pfctParse ) ( transport_tree , tvb , pinfo , & offset ) ;\n parseAbort ( transport_tree , tvb , pinfo , & offset ) ;\n return tvb_reported_length ( tvb ) ;\n }\n frag_msg = fragment_get ( & opcua_reassembly_table , pinfo , opcua_seqid , NULL ) ;\n if ( frag_msg == NULL ) {\n frag_msg = fragment_get_reassembled_id ( & opcua_reassembly_table , pinfo , opcua_seqid ) ;\n }\n if ( frag_msg != NULL || chunkType != 'F' ) {\n gboolean bSaveFragmented = pinfo -> fragmented ;\n gboolean bMoreFragments = TRUE ;\n tvbuff_t * new_tvb = NULL ;\n pinfo -> fragmented = TRUE ;\n if ( frag_msg == NULL ) {\n opcua_seqnum = 0 ;\n }\n else {\n while ( frag_msg -> next ) {\n frag_msg = frag_msg -> next ;\n }\n opcua_seqnum = frag_msg -> offset + 1 ;\n if ( chunkType == 'F' ) {\n bMoreFragments = FALSE ;\n }\n }\n frag_msg = fragment_add_seq_check ( & opcua_reassembly_table , tvb , offset , pinfo , opcua_seqid , NULL , opcua_seqnum , tvb_captured_length_remaining ( tvb , offset ) , bMoreFragments ) ;\n new_tvb = process_reassembled_data ( tvb , offset , pinfo , \"Reassembled Message\" , frag_msg , & opcua_frag_items , NULL , transport_tree ) ;\n if ( new_tvb ) {\n bIsLastFragment = TRUE ;\n }\n else {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" (Message fragment %u)\" , opcua_num ) ;\n }\n if ( new_tvb ) {\n next_tvb = new_tvb ;\n }\n else {\n bParseService = FALSE ;\n next_tvb = tvb_new_subset_remaining ( tvb , 0 ) ;\n }\n pinfo -> fragmented = bSaveFragmented ;\n }\n }\n offset = 0 ;\n iServiceId = ( * pfctParse ) ( transport_tree , tvb , pinfo , & offset ) ;\n if ( msgtype == MSG_MESSAGE && bParseService ) {\n if ( bIsLastFragment != FALSE ) {\n offset = 0 ;\n }\n iServiceId = parseService ( transport_tree , next_tvb , pinfo , & offset ) ;\n }\n if ( iServiceId != - 1 ) {\n const gchar * szServiceName = val_to_str ( ( guint32 ) iServiceId , g_requesttypes , \"ServiceId %d\" ) ;\n if ( bIsLastFragment == FALSE ) {\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"%s: %s\" , g_szMessageTypes [ msgtype ] , szServiceName ) ;\n }\n else {\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"%s: %s (Message Reassembled)\" , g_szMessageTypes [ msgtype ] , szServiceName ) ;\n }\n }\n }\n return tvb_reported_length ( tvb ) ;\n }", "hash": 8035933693347914822, "project": "debian", "size": 126, "target": 0, "idx": 1007}
{"code": "proto_item * parseUInt16 ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo _U_ , gint * pOffset , int hfIndex ) {\n proto_item * item = proto_tree_add_item ( tree , hfIndex , tvb , * pOffset , 2 , ENC_LITTLE_ENDIAN ) ;\n * pOffset += 2 ;\n return item ;\n }", "hash": 1208165234047591297, "project": "debian", "size": 5, "target": 0, "idx": 1016}
{"code": "void parseDataValue ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo , gint * pOffset , const char * szFieldName ) {\n static const int * datavalue_mask [ ] = {\n & hf_opcua_datavalue_mask_valueflag , & hf_opcua_datavalue_mask_statuscodeflag , & hf_opcua_datavalue_mask_sourcetimestampflag , & hf_opcua_datavalue_mask_servertimestampflag , & hf_opcua_datavalue_mask_sourcepicoseconds , & hf_opcua_datavalue_mask_serverpicoseconds , NULL }\n ;\n proto_item * ti ;\n proto_tree * subtree = proto_tree_add_subtree_format ( tree , tvb , * pOffset , - 1 , ett_opcua_datavalue , & ti , \"%s: DataValue\" , szFieldName ) ;\n gint iOffset = * pOffset ;\n guint8 EncodingMask ;\n EncodingMask = tvb_get_guint8 ( tvb , iOffset ) ;\n proto_tree_add_bitmask ( subtree , tvb , iOffset , hf_opcua_datavalue_mask , ett_opcua_datavalue_encodingmask , datavalue_mask , ENC_LITTLE_ENDIAN ) ;\n iOffset ++ ;\n if ( EncodingMask & DATAVALUE_ENCODINGBYTE_VALUE ) {\n parseVariant ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n }\n if ( EncodingMask & DATAVALUE_ENCODINGBYTE_STATUSCODE ) {\n parseStatusCode ( subtree , tvb , pinfo , & iOffset , hf_opcua_StatusCode ) ;\n }\n if ( EncodingMask & DATAVALUE_ENCODINGBYTE_SOURCETIMESTAMP ) {\n parseDateTime ( subtree , tvb , pinfo , & iOffset , hf_opcua_SourceTimestamp ) ;\n }\n if ( EncodingMask & DATAVALUE_ENCODINGBYTE_SOURCEPICOSECONDS ) {\n parseUInt16 ( subtree , tvb , pinfo , & iOffset , hf_opcua_SourcePicoseconds ) ;\n }\n if ( EncodingMask & DATAVALUE_ENCODINGBYTE_SERVERTIMESTAMP ) {\n parseDateTime ( subtree , tvb , pinfo , & iOffset , hf_opcua_ServerTimestamp ) ;\n }\n if ( EncodingMask & DATAVALUE_ENCODINGBYTE_SERVERPICOSECONDS ) {\n parseUInt16 ( subtree , tvb , pinfo , & iOffset , hf_opcua_ServerPicoseconds ) ;\n }\n proto_item_set_end ( ti , tvb , iOffset ) ;\n * pOffset = iOffset ;\n }", "hash": 1208165234047591297, "project": "debian", "size": 32, "target": 0, "idx": 1022}
{"code": "proto_item * parseUInt32 ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo _U_ , gint * pOffset , int hfIndex ) {\n proto_item * item = proto_tree_add_item ( tree , hfIndex , tvb , * pOffset , 4 , ENC_LITTLE_ENDIAN ) ;\n * pOffset += 4 ;\n return item ;\n }", "hash": 1208165234047591297, "project": "debian", "size": 5, "target": 0, "idx": 1031}
{"code": "int main ( int argc , char * argv [ ] ) {\n int ret_value = 0 ;\n libettercap_init ( ) ;\n ef_globals_alloc ( ) ;\n select_text_interface ( ) ;\n libettercap_ui_init ( ) ;\n fprintf ( stdout , \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\" , PROGRAM , EC_VERSION , EC_COPYRIGHT , EC_AUTHORS ) ;\n EF_GBL -> lineno = 1 ;\n parse_options ( argc , argv ) ;\n if ( EF_GBL_OPTIONS -> source_file ) {\n yyin = fopen ( EF_GBL_OPTIONS -> source_file , \"r\" ) ;\n if ( yyin == NULL ) FATAL_ERROR ( \"Input file not found !\" ) ;\n }\n else {\n FATAL_ERROR ( \"No source file.\" ) ;\n }\n setbuf ( yyin , NULL ) ;\n setbuf ( stdout , NULL ) ;\n setbuf ( stderr , NULL ) ;\n load_tables ( ) ;\n load_constants ( ) ;\n fprintf ( stdout , \"\\n Parsing source file \\'%s\\' \" , EF_GBL_OPTIONS -> source_file ) ;\n fflush ( stdout ) ;\n ef_debug ( 1 , \"\\n\" ) ;\n if ( yyparse ( ) == 0 ) fprintf ( stdout , \" done.\\n\\n\" ) ;\n else fprintf ( stdout , \"\\n\\nThe script contains errors...\\n\\n\" ) ;\n ret_value = write_output ( ) ;\n if ( ret_value == - E_NOTHANDLED ) FATAL_ERROR ( \"Cannot write output file (%s): the filter is not correctly handled.\" , EF_GBL_OPTIONS -> output_file ) ;\n else if ( ret_value == - E_INVALID ) FATAL_ERROR ( \"Cannot write output file (%s): the filter format is not correct. \" , EF_GBL_OPTIONS -> output_file ) ;\n ef_globals_free ( ) ;\n return 0 ;\n }", "hash": -7559567117301601597, "project": "debian", "size": 32, "target": 0, "idx": 1042}
{"code": "void ef_globals_free ( void ) {\n SAFE_FREE ( ef_gbls -> source_file ) ;\n SAFE_FREE ( ef_gbls -> output_file ) ;\n SAFE_FREE ( ef_gbls ) ;\n return ;\n }", "hash": -7559567117301601597, "project": "debian", "size": 6, "target": 0, "idx": 1044}
{"code": "int write_output ( void ) {\n int fd ;\n struct filter_op * fop ;\n struct filter_header fh ;\n size_t ninst , i ;\n u_char * data ;\n ninst = compile_tree ( & fop ) ;\n if ( fop == NULL ) return - E_NOTHANDLED ;\n if ( ninst == 0 ) return - E_INVALID ;\n fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;\n ON_ERROR ( fd , - 1 , \"Can't create file %s\" , EF_GBL_OPTIONS -> output_file ) ;\n fprintf ( stdout , \" Writing output to \\'%s\\' \" , EF_GBL_OPTIONS -> output_file ) ;\n fflush ( stdout ) ;\n fh . magic = htons ( EC_FILTER_MAGIC ) ;\n strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ;\n fh . data = sizeof ( fh ) ;\n data = create_data_segment ( & fh , fop , ninst ) ;\n write ( fd , & fh , sizeof ( struct filter_header ) ) ;\n write ( fd , data , fh . code - fh . data ) ;\n for ( i = 0 ;\n i <= ninst ;\n i ++ ) {\n print_progress_bar ( & fop [ i ] ) ;\n write ( fd , & fop [ i ] , sizeof ( struct filter_op ) ) ;\n }\n close ( fd ) ;\n fprintf ( stdout , \" done.\\n\\n\" ) ;\n fprintf ( stdout , \" -> Script encoded into %d instructions.\\n\\n\" , ( int ) ( i - 1 ) ) ;\n return E_SUCCESS ;\n }", "hash": 131568608762928706, "project": "debian", "size": 30, "target": 0, "idx": 1047}
{"code": "size_t compile_tree ( struct filter_op * * fop ) {\n int i = 1 ;\n struct filter_op * array = NULL ;\n struct unfold_elm * ue ;\n if ( tree_root == NULL ) return 0 ;\n fprintf ( stdout , \" Unfolding the meta-tree \" ) ;\n fflush ( stdout ) ;\n unfold_blk ( & tree_root ) ;\n fprintf ( stdout , \" done.\\n\\n\" ) ;\n labels_to_offsets ( ) ;\n TAILQ_FOREACH ( ue , & unfolded_tree , next ) {\n if ( ue -> label == 0 ) {\n SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ;\n memcpy ( & array [ i - 1 ] , & ue -> fop , sizeof ( struct filter_op ) ) ;\n i ++ ;\n }\n }\n SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ;\n array [ i - 1 ] . opcode = FOP_EXIT ;\n * fop = array ;\n return ( i ) ;\n }", "hash": -6351630154286607278, "project": "debian", "size": 22, "target": 0, "idx": 1057}
{"code": "static void unfold_blk ( struct block * * blk ) {\n struct unfold_elm * ue = NULL ;\n BUG_IF ( * blk == NULL ) ;\n ef_debug ( 1 , \"+\" ) ;\n do {\n switch ( ( * blk ) -> type ) {\n case BLK_INSTR : SAFE_CALLOC ( ue , 1 , sizeof ( struct unfold_elm ) ) ;\n memcpy ( & ue -> fop , ( * blk ) -> un . ins , sizeof ( struct filter_op ) ) ;\n TAILQ_INSERT_TAIL ( & unfolded_tree , ue , next ) ;\n break ;\n case BLK_IFBLK : unfold_ifblk ( blk ) ;\n break ;\n default : BUG ( \"undefined tree element\" ) ;\n break ;\n }\n }\n while ( ( * blk = ( * blk ) -> next ) ) ;\n }", "hash": -6351630154286607278, "project": "debian", "size": 18, "target": 0, "idx": 1060}
{"code": "static int dict_threshold_common_params ( const ref * pdict , gs_threshold_halftone_common * ptp , ref * * pptstring , ref * ptproc ) {\n int code ;\n check_dict_read ( * pdict ) ;\n if ( ( code = dict_int_param ( pdict , \"Width\" , 1 , 0x7fff , - 1 , & ptp -> width ) ) < 0 || ( code = dict_int_param ( pdict , \"Height\" , 1 , 0x7fff , - 1 , & ptp -> height ) ) < 0 || ( code = dict_find_string ( pdict , \"Thresholds\" , pptstring ) ) <= 0 || ( code = dict_proc_param ( pdict , \"TransferFunction\" , ptproc , false ) ) < 0 ) return ( code < 0 ? code : gs_error_undefined ) ;\n ptp -> transfer_closure . proc = 0 ;\n ptp -> transfer_closure . data = 0 ;\n return code ;\n }", "hash": -2653265013496966602, "project": "debian", "size": 8, "target": 0, "idx": 1062}
{"code": "static int zsethalftone5 ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n uint count ;\n gs_halftone_component * phtc = 0 ;\n gs_halftone_component * pc ;\n int code = 0 ;\n int j ;\n bool have_default ;\n gs_halftone * pht = 0 ;\n gx_device_halftone * pdht = 0 ;\n ref sprocs [ GS_CLIENT_COLOR_MAX_COMPONENTS + 1 ] ;\n ref tprocs [ GS_CLIENT_COLOR_MAX_COMPONENTS + 1 ] ;\n gs_memory_t * mem ;\n uint edepth = ref_stack_count ( & e_stack ) ;\n int npop = 2 ;\n int dict_enum ;\n ref rvalue [ 2 ] ;\n int cname , colorant_number ;\n byte * pname ;\n uint name_size ;\n int halftonetype , type = 0 ;\n gs_gstate * pgs = igs ;\n int space_index ;\n if ( ref_stack_count ( & o_stack ) < 2 ) return_error ( gs_error_stackunderflow ) ;\n check_type ( * op , t_dictionary ) ;\n check_type ( * ( op - 1 ) , t_dictionary ) ;\n dict_enum = dict_first ( op ) ;\n space_index = r_space_index ( op - 1 ) ;\n mem = ( gs_memory_t * ) idmemory -> spaces_indexed [ space_index ] ;\n check_type ( * op , t_dictionary ) ;\n check_dict_read ( * op ) ;\n check_type ( op [ - 1 ] , t_dictionary ) ;\n check_dict_read ( op [ - 1 ] ) ;\n code = dict_int_param ( op - 1 , \"HalftoneType\" , 1 , 100 , 0 , & type ) ;\n if ( code < 0 ) return code ;\n halftonetype = ( type == 2 || type == 4 ) ? ht_type_multiple_colorscreen : ht_type_multiple ;\n have_default = false ;\n for ( count = 0 ;\n ;\n ) {\n if ( ( dict_enum = dict_next ( op , dict_enum , rvalue ) ) == - 1 ) break ;\n if ( ! r_has_type ( & rvalue [ 0 ] , t_name ) ) continue ;\n if ( ! r_has_type ( & rvalue [ 1 ] , t_dictionary ) ) continue ;\n cname = name_index ( mem , & rvalue [ 0 ] ) ;\n code = gs_get_colorname_string ( mem , cname , & pname , & name_size ) ;\n if ( code < 0 ) break ;\n colorant_number = gs_cname_to_colorant_number ( pgs , pname , name_size , halftonetype ) ;\n if ( colorant_number < 0 ) continue ;\n else if ( colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS ) {\n if ( have_default ) return_error ( gs_error_rangecheck ) ;\n have_default = true ;\n }\n count ++ ;\n if ( count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1 ) {\n code = gs_note_error ( gs_error_rangecheck ) ;\n break ;\n }\n }\n if ( count == 0 || ( halftonetype == ht_type_multiple && ! have_default ) ) code = gs_note_error ( gs_error_rangecheck ) ;\n if ( code >= 0 ) {\n check_estack ( 5 ) ;\n refset_null ( sprocs , count ) ;\n refset_null ( tprocs , count ) ;\n rc_alloc_struct_0 ( pht , gs_halftone , & st_halftone , imemory , pht = 0 , \".sethalftone5\" ) ;\n phtc = gs_alloc_struct_array ( mem , count , gs_halftone_component , & st_ht_component_element , \".sethalftone5\" ) ;\n rc_alloc_struct_0 ( pdht , gx_device_halftone , & st_device_halftone , imemory , pdht = 0 , \".sethalftone5\" ) ;\n if ( pht == 0 || phtc == 0 || pdht == 0 ) {\n j = 0 ;\n code = gs_note_error ( gs_error_VMerror ) ;\n }\n }\n if ( code >= 0 ) {\n dict_enum = dict_first ( op ) ;\n for ( j = 0 , pc = phtc ;\n ;\n ) {\n int type ;\n if ( ( dict_enum = dict_next ( op , dict_enum , rvalue ) ) == - 1 ) break ;\n if ( ! r_has_type ( & rvalue [ 0 ] , t_name ) ) continue ;\n if ( ! r_has_type ( & rvalue [ 1 ] , t_dictionary ) ) continue ;\n cname = name_index ( mem , & rvalue [ 0 ] ) ;\n code = gs_get_colorname_string ( mem , cname , & pname , & name_size ) ;\n if ( code < 0 ) break ;\n colorant_number = gs_cname_to_colorant_number ( pgs , pname , name_size , halftonetype ) ;\n if ( colorant_number < 0 ) continue ;\n pc -> cname = cname ;\n pc -> comp_number = colorant_number ;\n check_dict_read ( rvalue [ 1 ] ) ;\n if ( dict_int_param ( & rvalue [ 1 ] , \"HalftoneType\" , 1 , 7 , 0 , & type ) < 0 ) {\n code = gs_note_error ( gs_error_typecheck ) ;\n break ;\n }\n switch ( type ) {\n default : code = gs_note_error ( gs_error_rangecheck ) ;\n break ;\n case 1 : code = dict_spot_params ( & rvalue [ 1 ] , & pc -> params . spot , sprocs + j , tprocs + j , mem ) ;\n pc -> params . spot . screen . spot_function = spot1_dummy ;\n pc -> type = ht_type_spot ;\n break ;\n case 3 : code = dict_threshold_params ( & rvalue [ 1 ] , & pc -> params . threshold , tprocs + j ) ;\n pc -> type = ht_type_threshold ;\n break ;\n case 7 : code = dict_threshold2_params ( & rvalue [ 1 ] , & pc -> params . threshold2 , tprocs + j , imemory ) ;\n pc -> type = ht_type_threshold2 ;\n break ;\n }\n if ( code < 0 ) break ;\n pc ++ ;\n j ++ ;\n }\n }\n if ( code >= 0 ) {\n pht -> type = halftonetype ;\n pht -> params . multiple . components = phtc ;\n pht -> params . multiple . num_comp = j ;\n pht -> params . multiple . get_colorname_string = gs_get_colorname_string ;\n code = gs_sethalftone_prepare ( igs , pht , pdht ) ;\n }\n if ( code >= 0 ) {\n dict_enum = dict_first ( op ) ;\n for ( pc = phtc ;\n ;\n ) {\n if ( ( dict_enum = dict_next ( op , dict_enum , rvalue ) ) == - 1 ) break ;\n if ( ! r_has_type ( & rvalue [ 0 ] , t_name ) ) continue ;\n if ( ! r_has_type ( & rvalue [ 1 ] , t_dictionary ) ) continue ;\n cname = name_index ( mem , & rvalue [ 0 ] ) ;\n code = gs_get_colorname_string ( mem , cname , & pname , & name_size ) ;\n if ( code < 0 ) break ;\n colorant_number = gs_cname_to_colorant_number ( pgs , pname , name_size , halftonetype ) ;\n if ( colorant_number < 0 ) continue ;\n if ( pc -> type == ht_type_spot ) {\n code = dict_spot_results ( i_ctx_p , & rvalue [ 1 ] , & pc -> params . spot ) ;\n if ( code < 0 ) break ;\n }\n pc ++ ;\n }\n }\n if ( code >= 0 ) {\n uint odepth = ref_stack_count ( & o_stack ) ;\n ref odict , odict5 ;\n odict = op [ - 1 ] ;\n odict5 = * op ;\n pop ( 2 ) ;\n op = osp ;\n esp += 5 ;\n make_mark_estack ( esp - 4 , es_other , sethalftone_cleanup ) ;\n esp [ - 3 ] = odict ;\n make_istruct ( esp - 2 , 0 , pht ) ;\n make_istruct ( esp - 1 , 0 , pdht ) ;\n make_op_estack ( esp , sethalftone_finish ) ;\n for ( j = 0 ;\n j < count ;\n j ++ ) {\n gx_ht_order * porder = NULL ;\n if ( pdht -> components == 0 ) porder = & pdht -> order ;\n else {\n int k ;\n int comp_number = phtc [ j ] . comp_number ;\n for ( k = 0 ;\n k < count ;\n k ++ ) {\n if ( pdht -> components [ k ] . comp_number == comp_number ) {\n porder = & pdht -> components [ k ] . corder ;\n break ;\n }\n }\n }\n switch ( phtc [ j ] . type ) {\n case ht_type_spot : code = zscreen_enum_init ( i_ctx_p , porder , & phtc [ j ] . params . spot . screen , & sprocs [ j ] , 0 , 0 , space_index ) ;\n if ( code < 0 ) break ;\n case ht_type_threshold : if ( ! r_has_type ( tprocs + j , t__invalid ) ) {\n check_ostack ( zcolor_remap_one_ostack ) ;\n check_estack ( zcolor_remap_one_estack ) ;\n code = zcolor_remap_one ( i_ctx_p , tprocs + j , porder -> transfer , igs , zcolor_remap_one_finish ) ;\n op = osp ;\n }\n break ;\n default : ;\n }\n if ( code < 0 ) {\n ref_stack_pop_to ( & o_stack , odepth ) ;\n ref_stack_pop_to ( & e_stack , edepth ) ;\n op = osp ;\n op [ - 1 ] = odict ;\n * op = odict5 ;\n break ;\n }\n npop = 0 ;\n }\n }\n if ( code < 0 ) {\n gs_free_object ( mem , pdht , \".sethalftone5\" ) ;\n gs_free_object ( mem , phtc , \".sethalftone5\" ) ;\n gs_free_object ( mem , pht , \".sethalftone5\" ) ;\n return code ;\n }\n pop ( npop ) ;\n return ( ref_stack_count ( & e_stack ) > edepth ? o_push_estack : 0 ) ;\n }", "hash": -2653265013496966602, "project": "debian", "size": 200, "target": 0, "idx": 1067}
{"code": "static void fts_parser_script_more ( struct fts_parser * _parser , struct message_block * block ) {\n struct script_fts_parser * parser = ( struct script_fts_parser * ) _parser ;\n ssize_t ret ;\n if ( block -> size > 0 ) {\n if ( ! parser -> failed && write_full ( parser -> fd , block -> data , block -> size ) < 0 ) {\n i_error ( \"write(%s) failed: %m\" , parser -> path ) ;\n parser -> failed = TRUE ;\n }\n block -> size = 0 ;\n }\n else {\n if ( ! parser -> shutdown ) {\n if ( shutdown ( parser -> fd , SHUT_WR ) < 0 ) i_error ( \"shutdown(%s) failed: %m\" , parser -> path ) ;\n parser -> shutdown = TRUE ;\n }\n ret = read ( parser -> fd , parser -> outbuf , sizeof ( parser -> outbuf ) ) ;\n if ( ret < 0 ) i_error ( \"read(%s) failed: %m\" , parser -> path ) ;\n else {\n block -> data = parser -> outbuf ;\n block -> size = ret ;\n }\n }\n }", "hash": -6228844445714759206, "project": "debian", "size": 23, "target": 0, "idx": 1092}
{"code": "static ssize_t i_stream_attachment_extractor_read ( struct istream_private * stream ) {\n struct attachment_istream * astream = ( struct attachment_istream * ) stream ;\n bool retry ;\n ssize_t ret ;\n do {\n ret = astream_read_next ( astream , & retry ) ;\n }\n while ( retry && astream -> set . drain_parent_input ) ;\n astream -> retry_read = retry ;\n return ret ;\n }", "hash": -2064332158282087279, "project": "debian", "size": 11, "target": 0, "idx": 1107}
{"code": "static void parse_content_type ( struct attachment_istream * astream , const struct message_header_line * hdr ) {\n struct rfc822_parser_context parser ;\n string_t * content_type ;\n if ( astream -> part . content_type != NULL ) return ;\n rfc822_parser_init ( & parser , hdr -> full_value , hdr -> full_value_len , NULL ) ;\n rfc822_skip_lwsp ( & parser ) ;\n T_BEGIN {\n content_type = t_str_new ( 64 ) ;\n ( void ) rfc822_parse_content_type ( & parser , content_type ) ;\n astream -> part . content_type = i_strdup ( str_c ( content_type ) ) ;\n }\n T_END ;\n rfc822_parser_deinit ( & parser ) ;\n }", "hash": -2064332158282087279, "project": "debian", "size": 14, "target": 0, "idx": 1110}
{"code": "static void astream_part_reset ( struct attachment_istream * astream ) {\n struct attachment_istream_part * part = & astream -> part ;\n if ( part -> temp_output != NULL ) o_stream_destroy ( & part -> temp_output ) ;\n if ( part -> temp_fd != - 1 ) i_close_fd ( & part -> temp_fd ) ;\n i_free_and_null ( part -> content_type ) ;\n i_free_and_null ( part -> content_disposition ) ;\n if ( part -> part_buf != NULL ) buffer_free ( & part -> part_buf ) ;\n i_zero ( part ) ;\n part -> temp_fd = - 1 ;\n hash_format_reset ( astream -> set . hash_format ) ;\n }", "hash": -2064332158282087279, "project": "debian", "size": 11, "target": 0, "idx": 1112}
{"code": "struct message_search_context * message_search_init ( const char * normalized_key_utf8 , normalizer_func_t * normalizer , enum message_search_flags flags ) {\n struct message_search_context * ctx ;\n i_assert ( * normalized_key_utf8 != '\\0' ) ;\n ctx = i_new ( struct message_search_context , 1 ) ;\n ctx -> flags = flags ;\n ctx -> decoder = message_decoder_init ( normalizer , 0 ) ;\n ctx -> str_find_ctx = str_find_init ( default_pool , normalized_key_utf8 ) ;\n return ctx ;\n }", "hash": 7324112841603622093, "project": "debian", "size": 9, "target": 0, "idx": 1139}
{"code": "void * xmalloc ( size_t num , size_t size ) {\n size_t res ;\n if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;\n void * ptr = malloc ( res ) ;\n if ( ! ptr && ( size != 0 ) ) {\n perror ( \"xmalloc: Memory allocation failure\" ) ;\n abort ( ) ;\n }\n return ptr ;\n }", "hash": -6579823731174944595, "project": "debian", "size": 10, "target": 0, "idx": 1148}
{"code": "void set_alloc_limit ( size_t size ) {\n alloc_limit = size ;\n }", "hash": -6579823731174944595, "project": "debian", "size": 3, "target": 0, "idx": 1154}
{"code": "void alloc_limit_assert ( char * fn_name , size_t size ) {\n if ( alloc_limit && size > alloc_limit ) {\n alloc_limit_failure ( fn_name , size ) ;\n exit ( - 1 ) ;\n }\n }", "hash": -6579823731174944595, "project": "debian", "size": 6, "target": 0, "idx": 1155}
{"code": "void proto_register_gsm_a_common ( void ) {\n guint i ;\n guint last_offset ;\n static hf_register_info hf [ ] = {\n {\n & hf_gsm_a_common_elem_id , {\n \"Element ID\" , \"gsm_a.common.elem_id\" , FT_UINT8 , BASE_HEX , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_common_elem_id_f0 , {\n \"Element ID\" , \"gsm_a.common.elem_id\" , FT_UINT8 , BASE_HEX , NULL , 0xF0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_l_ext , {\n \"ext\" , \"gsm_a.l_ext\" , FT_UINT8 , BASE_DEC , NULL , 0x80 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_tmsi , {\n \"TMSI/P-TMSI\" , \"gsm_a.tmsi\" , FT_UINT32 , BASE_HEX , 0 , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_imei , {\n \"IMEI\" , \"gsm_a.imei\" , FT_STRING , BASE_NONE , 0 , 0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_imeisv , {\n \"IMEISV\" , \"gsm_a.imeisv\" , FT_STRING , BASE_NONE , 0 , 0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_MSC_rev , {\n \"Revision Level\" , \"gsm_a.MSC_rev\" , FT_UINT8 , BASE_DEC , VALS ( gsm_a_msc_rev_vals ) , 0x60 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ES_IND , {\n \"ES IND\" , \"gsm_a.ES_IND\" , FT_BOOLEAN , 8 , TFS ( & ES_IND_vals ) , 0x10 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_A5_1_algorithm_sup , {\n \"A5/1 algorithm supported\" , \"gsm_a.A5_1_algorithm_sup\" , FT_BOOLEAN , 8 , TFS ( & A5_1_algorithm_sup_vals ) , 0x08 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_RF_power_capability , {\n \"RF Power Capability\" , \"gsm_a.RF_power_capability\" , FT_UINT8 , BASE_DEC , VALS ( RF_power_capability_vals ) , 0x07 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ps_sup_cap , {\n \"PS capability (pseudo-synchronization capability)\" , \"gsm_a.ps_sup_cap\" , FT_BOOLEAN , 8 , TFS ( & ps_sup_cap_vals ) , 0x40 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_SS_screening_indicator , {\n \"SS Screening Indicator\" , \"gsm_a.SS_screening_indicator\" , FT_UINT8 , BASE_DEC , VALS ( SS_screening_indicator_vals ) , 0x30 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_SM_capability , {\n \"SM capability (MT SMS pt to pt capability)\" , \"gsm_a.SM_cap\" , FT_BOOLEAN , 8 , TFS ( & SM_capability_vals ) , 0x08 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_VBS_notification_rec , {\n \"VBS notification reception\" , \"gsm_a.VBS_notification_rec\" , FT_BOOLEAN , 8 , TFS ( & VBS_notification_rec_vals ) , 0x04 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_VGCS_notification_rec , {\n \"VGCS notification reception\" , \"gsm_a.VGCS_notification_rec\" , FT_BOOLEAN , 8 , TFS ( & VGCS_notification_rec_vals ) , 0x02 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_FC_frequency_cap , {\n \"FC Frequency Capability\" , \"gsm_a.FC_frequency_cap\" , FT_BOOLEAN , 8 , TFS ( & FC_frequency_cap_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_CM3 , {\n \"CM3\" , \"gsm_a.CM3\" , FT_BOOLEAN , 8 , TFS ( & CM3_vals ) , 0x80 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_LCS_VA_cap , {\n \"LCS VA capability (LCS value added location request notification capability)\" , \"gsm_a.LCS_VA_cap\" , FT_BOOLEAN , 8 , TFS ( & LCS_VA_cap_vals ) , 0x20 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_UCS2_treatment , {\n \"UCS2 treatment\" , \"gsm_a.UCS2_treatment\" , FT_BOOLEAN , 8 , TFS ( & UCS2_treatment_vals ) , 0x10 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_SoLSA , {\n \"SoLSA\" , \"gsm_a.SoLSA\" , FT_BOOLEAN , 8 , TFS ( & SoLSA_vals ) , 0x08 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_CMSP , {\n \"CMSP: CM Service Prompt\" , \"gsm_a.CMSP\" , FT_BOOLEAN , 8 , TFS ( & CMSP_vals ) , 0x04 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_A5_7_algorithm_sup , {\n \"A5/7 algorithm supported\" , \"gsm_a.A5_7_algorithm_sup\" , FT_BOOLEAN , BASE_NONE , TFS ( & A5_7_algorithm_sup_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_A5_6_algorithm_sup , {\n \"A5/6 algorithm supported\" , \"gsm_a.A5_6_algorithm_sup\" , FT_BOOLEAN , BASE_NONE , TFS ( & A5_6_algorithm_sup_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_A5_5_algorithm_sup , {\n \"A5/5 algorithm supported\" , \"gsm_a.A5_5_algorithm_sup\" , FT_BOOLEAN , BASE_NONE , TFS ( & A5_5_algorithm_sup_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_A5_4_algorithm_sup , {\n \"A5/4 algorithm supported\" , \"gsm_a.A5_4_algorithm_sup\" , FT_BOOLEAN , BASE_NONE , TFS ( & A5_4_algorithm_sup_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_A5_3_algorithm_sup , {\n \"A5/3 algorithm supported\" , \"gsm_a.A5_3_algorithm_sup\" , FT_BOOLEAN , 8 , TFS ( & A5_3_algorithm_sup_vals ) , 0x02 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_A5_2_algorithm_sup , {\n \"A5/2 algorithm supported\" , \"gsm_a.A5_2_algorithm_sup\" , FT_BOOLEAN , 8 , TFS ( & A5_2_algorithm_sup_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_mobile_identity_type , {\n \"Mobile Identity Type\" , \"gsm_a.ie.mobileid.type\" , FT_UINT8 , BASE_DEC , VALS ( mobile_identity_type_vals ) , 0x07 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_id_dig_1 , {\n \"Identity Digit 1\" , \"gsm_a.id_dig_1\" , FT_UINT8 , BASE_DEC , NULL , 0xf0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_odd_even_ind , {\n \"Odd/even indication\" , \"gsm_a.oddevenind\" , FT_BOOLEAN , 8 , TFS ( & oddevenind_vals ) , 0x08 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_unused , {\n \"Unused\" , \"gsm_a.unused\" , FT_UINT8 , BASE_HEX , NULL , 0xf0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_tmgi_mcc_mnc_ind , {\n \"MCC/MNC indication\" , \"gsm_a.tmgi_mcc_mnc_ind\" , FT_BOOLEAN , 8 , TFS ( & gsm_a_present_vals ) , 0x10 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_mbs_ses_id_ind , {\n \"MBMS Session Identity indication\" , \"gsm_a.mbs_session_id_ind\" , FT_BOOLEAN , 8 , TFS ( & gsm_a_present_vals ) , 0x20 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_mbs_service_id , {\n \"MBMS Service ID\" , \"gsm_a.mbs_service_id\" , FT_UINT24 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_mbs_session_id , {\n \"MBMS Session ID\" , \"gsm_a.mbs_session_id\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_length , {\n \"Length\" , \"gsm_a.len\" , FT_UINT16 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_element_value , {\n \"Element Value\" , \"gsm_a.element_value\" , FT_BYTES , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_extension , {\n \"Extension\" , \"gsm_a.extension\" , FT_BOOLEAN , 8 , TFS ( & gsm_a_extension_value ) , 0x80 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_L3_protocol_discriminator , {\n \"Protocol discriminator\" , \"gsm_a.L3_protocol_discriminator\" , FT_UINT8 , BASE_HEX , VALS ( protocol_discriminator_vals ) , 0x0f , NULL , HFILL }\n }\n , {\n & hf_gsm_a_call_prio , {\n \"Call priority\" , \"gsm_a.call_prio\" , FT_UINT8 , BASE_DEC , VALS ( gsm_a_call_prio_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_type_of_ciph_alg , {\n \"Call priority\" , \"gsm_a.call_prio\" , FT_UINT8 , BASE_DEC , VALS ( gsm_a_gm_type_of_ciph_alg_vals ) , 0x07 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_att , {\n \"ATT\" , \"gsm_a.att\" , FT_BOOLEAN , 8 , TFS ( & gsm_a_att_value ) , 0x01 , \"ttach-detach allowed\" , HFILL }\n }\n , {\n & hf_gsm_a_nmo_1 , {\n \"NMO I\" , \"gsm_a.nmo_1\" , FT_BOOLEAN , 8 , TFS ( & gsm_a_nmo_1_value ) , 0x02 , \"Network Mode of Operation I\" , HFILL }\n }\n , {\n & hf_gsm_a_nmo , {\n \"NMO\" , \"gsm_a.nmo\" , FT_BOOLEAN , 8 , TFS ( & gsm_a_nmo_value ) , 0x01 , \"Network Mode of Operation\" , HFILL }\n }\n , {\n & hf_gsm_a_old_xid , {\n \"Old XID\" , \"gsm_a.old_xid\" , FT_UINT8 , BASE_DEC , VALS ( gsm_a_pld_xid_vals ) , 0x10 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_iov_ui , {\n \"IOV-UI\" , \"gsm_a.iov_ui\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ext_periodic_timers , {\n \"Extended periodic timers\" , \"gsm_a.ext_periodic_timers\" , FT_BOOLEAN , BASE_NONE , TFS ( & gsm_a_ext_periodic_timers_value ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_skip_ind , {\n \"Skip Indicator\" , \"gsm_a.skip.ind\" , FT_UINT8 , BASE_DEC , VALS ( gsm_a_skip_ind_vals ) , 0xf0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_b7spare , {\n \"Spare\" , \"gsm_a.spareb7\" , FT_UINT8 , BASE_DEC , NULL , 0x40 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_b8spare , {\n \"Spare\" , \"gsm_a.spareb8\" , FT_UINT8 , BASE_DEC , NULL , 0x80 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_spare_bits , {\n \"Spare bit(s)\" , \"gsm_a.spare_bits\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_multi_bnd_sup_fields , {\n \"Multiband supported field\" , \"gsm_a.multi_bnd_sup_fields\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_pgsm_supported , {\n \"P-GSM Supported\" , \"gsm_a.classmark3.pgsmSupported\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_egsm_supported , {\n \"E-GSM or R-GSM Supported\" , \"gsm_a.classmark3.egsmSupported\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_gsm1800_supported , {\n \"GSM 1800 Supported\" , \"gsm_a.classmark3.gsm1800Supported\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ass_radio_cap1 , {\n \"Associated Radio Capability 1\" , \"gsm_a.classmark3.ass_radio_cap1\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ass_radio_cap2 , {\n \"Associated Radio Capability 2\" , \"gsm_a.classmark3.ass_radio_cap2\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_cm3_A5_bits , {\n \"A5 bits\" , \"gsm_a.classmark3.a5_bits\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_rsupport , {\n \"R Support\" , \"gsm_a.classmark3.rsupport\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_r_capabilities , {\n \"R-GSM band Associated Radio Capability\" , \"gsm_a.classmark3.r_capabilities\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_multislot_capabilities , {\n \"HSCSD Multi Slot Capability\" , \"gsm_a.classmark3.multislot_capabilities\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_multislot_class , {\n \"HSCSD Multi Slot Class\" , \"gsm_a.classmark3.multislot_cap\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ucs2_treatment , {\n \"UCS2 treatment\" , \"gsm_a.UCS2_treatment\" , FT_BOOLEAN , BASE_NONE , TFS ( & UCS2_treatment_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_extended_measurement_cap , {\n \"Extended Measurement Capability\" , \"gsm_a.classmark3.ext_meas_cap\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ms_measurement_capability , {\n \"MS measurement capability\" , \"gsm_a.classmark3.ms_measurement_capability\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_sms_value , {\n \"SMS_VALUE (Switch-Measure-Switch)\" , \"gsm_a.classmark3.sms_value\" , FT_UINT8 , BASE_DEC , VALS ( gsm_a_sms_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_sm_value , {\n \"SM_VALUE (Switch-Measure)\" , \"gsm_a.classmark3.sm_value\" , FT_UINT8 , BASE_DEC , VALS ( gsm_a_sms_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ms_pos_method_cap_present , {\n \"MS Positioning Method Capability present\" , \"gsm_a.classmark3.ms_pos_method_cap_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ms_pos_method , {\n \"MS Positioning Method\" , \"gsm_a.classmark3.ms_pos_method\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ms_assisted_e_otd , {\n \"MS assisted E-OTD\" , \"gsm_a.classmark3.ms_assisted_e_otd\" , FT_BOOLEAN , BASE_NONE , TFS ( & ms_assisted_e_otd_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ms_based_e_otd , {\n \"MS based E-OTD\" , \"gsm_a.classmark3.ms_based_e_otd\" , FT_BOOLEAN , BASE_NONE , TFS ( & ms_based_e_otd_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ms_assisted_gps , {\n \"MS assisted GPS\" , \"gsm_a.classmark3.ms_assisted_gps\" , FT_BOOLEAN , BASE_NONE , TFS ( & ms_assisted_gps_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ms_based_gps , {\n \"MS based GPS\" , \"gsm_a.classmark3.ms_based_gps\" , FT_BOOLEAN , BASE_NONE , TFS ( & ms_based_gps_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ms_conventional_gps , {\n \"MS Conventional GPS\" , \"gsm_a.classmark3.ms_conventional_gps\" , FT_BOOLEAN , BASE_NONE , TFS ( & ms_conventional_gps_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ecsd_multi_slot_capability , {\n \"ECSD Multi Slot Capability present\" , \"gsm_a.classmark3.ecsd_multi_slot_capability\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ecsd_multi_slot_class , {\n \"ECSD Multi Slot Class\" , \"gsm_a.classmark3.ecsd_multi_slot_class\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_8_psk_struct_present , {\n \"8-PSK Struct present\" , \"gsm_a.classmark3.8_psk_struct_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_8_psk_struct , {\n \"8-PSK Struct\" , \"gsm_a.classmark3.8_psk_struct\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_modulation_capability , {\n \"Modulation Capability\" , \"gsm_a.classmark3.modulation_capability\" , FT_BOOLEAN , BASE_NONE , TFS ( & modulation_capability_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_8_psk_rf_power_capability_1_present , {\n \"8-PSK RF Power Capability 1 present\" , \"gsm_a.classmark3.8_psk_rf_power_capability_1_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_8_psk_rf_power_capability_1 , {\n \"8-PSK RF Power Capability 1\" , \"gsm_a.classmark3.8_psk_rf_power_capability_1\" , FT_UINT8 , BASE_HEX , VALS ( eight_psk_rf_power_capability_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_8_psk_rf_power_capability_2_present , {\n \"8-PSK RF Power Capability 2 present\" , \"gsm_a.classmark3.8_psk_rf_power_capability_2_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_8_psk_rf_power_capability_2 , {\n \"8-PSK RF Power Capability 2\" , \"gsm_a.classmark3.8_psk_rf_power_capability_2\" , FT_UINT8 , BASE_HEX , VALS ( eight_psk_rf_power_capability_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_gsm_400_band_info_present , {\n \"GSM 400 Band Information present\" , \"gsm_a.classmark3.gsm_400_band_info_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_gsm_400_bands_supported , {\n \"GSM 400 Bands Supported\" , \"gsm_a.classmark3.gsm_400_bands_supported\" , FT_UINT8 , BASE_HEX , VALS ( gsm_400_bands_supported_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_gsm_400_assoc_radio_cap , {\n \"GSM 400 Associated Radio Capability\" , \"gsm_a.classmark3.gsm_400_assoc_radio_cap\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_gsm_850_assoc_radio_cap_present , {\n \"GSM 850 Associated Radio Capability present\" , \"gsm_a.classmark3.gsm_850_assoc_radio_cap_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_gsm_850_assoc_radio_cap , {\n \"GSM 850 Associated Radio Capability\" , \"gsm_a.classmark3.gsm_850_assoc_radio_cap\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_gsm_1900_assoc_radio_cap_present , {\n \"GSM 1900 Associated Radio Capability present\" , \"gsm_a.classmark3.gsm_1900_assoc_radio_cap_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_gsm_1900_assoc_radio_cap , {\n \"GSM 1900 Associated Radio Capability\" , \"gsm_a.classmark3.gsm_1900_assoc_radio_cap\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_umts_fdd_rat_cap , {\n \"UMTS FDD Radio Access Technology Capability\" , \"gsm_a.classmark3.umts_fdd_rat_cap\" , FT_BOOLEAN , BASE_NONE , TFS ( & umts_fdd_rat_cap_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_umts_384_mcps_tdd_rat_cap , {\n \"UMTS 3.84 Mcps TDD Radio Access Technology Capability\" , \"gsm_a.classmark3.umts_384_mcps_tdd_rat_cap\" , FT_BOOLEAN , BASE_NONE , TFS ( & umts_384_mcps_tdd_rat_cap_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_cdma_2000_rat_cap , {\n \"CDMA 2000 Radio Access Technology Capability\" , \"gsm_a.classmark3.cdma_2000_rat_cap\" , FT_BOOLEAN , BASE_NONE , TFS ( & cdma_2000_rat_cap_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_dtm_e_gprs_multi_slot_info_present , {\n \"DTM E/GPRS Multi Slot Information present\" , \"gsm_a.classmark3.dtm_e_gprs_multi_slot_info_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_dtm_gprs_multi_slot_class , {\n \"DTM GPRS Multi Slot Class\" , \"gsm_a.classmark3.dtm_gprs_multi_slot_class\" , FT_UINT8 , BASE_DEC , VALS ( dtm_gprs_multi_slot_class_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_single_slot_dtm , {\n \"Single Slot DTM\" , \"gsm_a.classmark3.single_slot_dtm_supported\" , FT_BOOLEAN , BASE_NONE , TFS ( & single_slot_dtm_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_dtm_egprs_multi_slot_class_present , {\n \"DTM EGPRS Multi Slot Class present\" , \"gsm_a.classmark3.dtm_egprs_multi_slot_class_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_dtm_egprs_multi_slot_class , {\n \"DTM EGPRS Multi Slot Class\" , \"gsm_a.classmark3.dtm_egprs_multi_slot_class\" , FT_UINT8 , BASE_DEC , VALS ( dtm_gprs_multi_slot_class_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_single_band_support , {\n \"Single Band Support\" , \"gsm_a.classmark3.single_band_support\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_gsm_band , {\n \"GSM Band\" , \"gsm_a.classmark3.gsm_band\" , FT_UINT8 , BASE_DEC , VALS ( gsm_band_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_gsm_750_assoc_radio_cap_present , {\n \"GSM 750 Associated Radio Capability present\" , \"gsm_a.classmark3.gsm_750_assoc_radio_cap_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_gsm_750_assoc_radio_cap , {\n \"GSM 750 Associated Radio Capability\" , \"gsm_a.classmark3.gsm_750_assoc_radio_cap\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_umts_128_mcps_tdd_rat_cap , {\n \"UMTS 1.28 Mcps TDD Radio Access Technology Capability\" , \"gsm_a.classmark3.umts_128_mcps_tdd_rat_cap\" , FT_BOOLEAN , BASE_NONE , TFS ( & umts_128_mcps_tdd_rat_cap_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geran_feature_package_1 , {\n \"GERAN Feature Package 1\" , \"gsm_a.classmark3.geran_feature_package_1\" , FT_BOOLEAN , BASE_NONE , TFS ( & geran_feature_package_1_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ext_dtm_e_gprs_multi_slot_info_present , {\n \"Extended DTM E/GPRS Multi Slot Information present\" , \"gsm_a.classmark3.ext_dtm_e_gprs_info_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ext_dtm_gprs_multi_slot_class , {\n \"Extended DTM GPRS Multi Slot Class\" , \"gsm_a.classmark3.ext_dtm_gprs_multi_slot_class\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ext_dtm_egprs_multi_slot_class , {\n \"Extended DTM EGPRS Multi Slot Class\" , \"gsm_a.classmark3.ext_dtm_egprs_multi_slot_class\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_high_multislot_cap_present , {\n \"High Multislot Capability present\" , \"gsm_a.classmark3.high_multislot_cap_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_high_multislot_cap , {\n \"High Multislot Capability\" , \"gsm_a.classmark3.high_multislot_cap\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geran_iu_mode_support , {\n \"GERAN Iu Mode Support\" , \"gsm_a.classmark3.geran_iu_mode_support\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geran_iu_mode_cap , {\n \"GERAN Iu Mode Capabilities\" , \"gsm_a.classmark3.geran_iu_mode_cap\" , FT_UINT24 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geran_iu_mode_cap_length , {\n \"Length\" , \"gsm_a.classmark3.geran_iu_mode_cap.length\" , FT_UINT8 , BASE_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_flo_iu_cap , {\n \"FLO Iu Capability\" , \"gsm_a.classmark3.geran_iu_mode_cap.flo_iu_cap\" , FT_BOOLEAN , BASE_NONE , TFS ( & flo_iu_cap_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geran_feature_package_2 , {\n \"GERAN Feature Package 2\" , \"gsm_a.classmark3.geran_feature_package_2\" , FT_BOOLEAN , BASE_NONE , TFS ( & geran_feature_package_2_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_gmsk_multislot_power_prof , {\n \"GMSK Multislot Power Profile\" , \"gsm_a.classmark3.gmsk_multislot_power_prof\" , FT_UINT8 , BASE_DEC , VALS ( gmsk_multislot_power_prof_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_8_psk_multislot_power_prof , {\n \"8-PSK Multislot Power Profile\" , \"gsm_a.classmark3.8_psk_multislot_power_prof\" , FT_UINT8 , BASE_DEC , VALS ( eight_psk_multislot_power_prof_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_t_gsm_400_band_info_present , {\n \"T-GSM 400 Band Information present\" , \"gsm_a.classmark3.gsm_400_band_info_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_t_gsm_400_bands_supported , {\n \"T-GSM 400 Bands Supported\" , \"gsm_a.classmark3.t_gsm_400_bands_supported\" , FT_UINT8 , BASE_HEX , VALS ( t_gsm_400_bands_supported_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_t_gsm_400_assoc_radio_cap , {\n \"T-GSM 400 Associated Radio Capability\" , \"gsm_a.classmark3.t_gsm_400_assoc_radio_cap\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_t_gsm_900_assoc_radio_cap_present , {\n \"T-GSM 900 Associated Radio Capability present\" , \"gsm_a.classmark3.t_gsm_900_assoc_radio_cap_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_t_gsm_900_assoc_radio_cap , {\n \"T-GSM 900 Associated Radio Capability\" , \"gsm_a.classmark3.t_gsm_900_assoc_radio_cap\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_downlink_adv_receiver_perf , {\n \"Downlink Advanced Receiver Performance\" , \"gsm_a.classmark3.downlink_adv_receiver_perf\" , FT_UINT8 , BASE_DEC , VALS ( downlink_adv_receiver_perf_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_dtm_enhancements_cap , {\n \"DTM Enhancements Capability\" , \"gsm_a.classmark3.dtm_enhancements_capability\" , FT_BOOLEAN , BASE_NONE , TFS ( & dtm_enhancements_cap_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_dtm_e_gprs_high_multi_slot_info_present , {\n \"DTM E/GPRS High Multi Slot Information present\" , \"gsm_a.classmark3.dtm_e_gprs_high_mutli_slot_info_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_dtm_gprs_high_multi_slot_class , {\n \"DTM GPRS Multi Slot Class\" , \"gsm_a.classmark3.dtm_gprs_multi_slot_class\" , FT_UINT8 , BASE_DEC , VALS ( dtm_gprs_high_multi_slot_class_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_offset_required , {\n \"Offset required\" , \"gsm_a.classmark3.offset_required\" , FT_BOOLEAN , BASE_NONE , TFS ( & offset_required_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_dtm_egprs_high_multi_slot_class_present , {\n \"DTM EGPRS High Multi Slot Class present\" , \"gsm_a.classmark3.dtm_egprs_high_multi_slot_class_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_dtm_egprs_high_multi_slot_class , {\n \"DTM EGPRS High Multi Slot Class\" , \"gsm_a.classmark3.dtm_egprs_high_multi_slot_class\" , FT_UINT8 , BASE_DEC , VALS ( dtm_gprs_high_multi_slot_class_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_repeated_acch_cap , {\n \"Repeated ACCH Capability\" , \"gsm_a.classmark3.repeated_acch_cap\" , FT_BOOLEAN , BASE_NONE , TFS ( & repeated_acch_cap_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_gsm_710_assoc_radio_cap_present , {\n \"GSM 710 Associated Radio Capability present\" , \"gsm_a.classmark3.gsm_710_assoc_radio_cap_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_gsm_710_assoc_radio_cap , {\n \"GSM 710 Associated Radio Capability\" , \"gsm_a.classmark3.gsm_710_assoc_radio_cap\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_t_gsm_810_assoc_radio_cap_present , {\n \"T-GSM 810 Associated Radio Capability present\" , \"gsm_a.classmark3.t_gsm_810_assoc_radio_cap_present\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_t_gsm_810_assoc_radio_cap , {\n \"T-GSM 810 Associated Radio Capability\" , \"gsm_a.classmark3.t_gsm_810_assoc_radio_cap\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ciphering_mode_setting_cap , {\n \"Ciphering Mode Setting Capability\" , \"gsm_a.classmark3.ciphering_mode_setting_cap\" , FT_BOOLEAN , BASE_NONE , TFS ( & ciphering_mode_setting_cap_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_additional_positioning_caps , {\n \"Additional Positioning Capabilities\" , \"gsm_a.classmark3.additional_positioning_caps\" , FT_BOOLEAN , BASE_NONE , TFS ( & additional_positioning_caps_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_e_utra_fdd_support , {\n \"E-UTRA FDD support\" , \"gsm_a.classmark3.e_utra_fdd_support\" , FT_BOOLEAN , BASE_NONE , TFS ( & e_utra_fdd_support_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_e_utra_tdd_support , {\n \"E-UTRA TDD support\" , \"gsm_a.classmark3.e_utra_tdd_support\" , FT_BOOLEAN , BASE_NONE , TFS ( & e_utra_tdd_support_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_e_utra_meas_and_report_support , {\n \"E-UTRA Measurement and Reporting support\" , \"gsm_a.classmark3.e_utra_meas_and_report_support\" , FT_BOOLEAN , BASE_NONE , TFS ( & e_utra_meas_and_report_support_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_prio_based_resel_support , {\n \"Priority-based reselection support\" , \"gsm_a.classmark3.prio_based_resel_support\" , FT_BOOLEAN , BASE_NONE , TFS ( & prio_based_resel_support_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_utra_csg_cells_reporting , {\n \"UTRA CSG Cells Reporting\" , \"gsm_a.classmark3.utra_csg_cells_reporting\" , FT_BOOLEAN , BASE_NONE , TFS ( & utra_csg_cells_reporting_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_vamos_level , {\n \"VAMOS Level\" , \"gsm_a.classmark3.vamos_level\" , FT_UINT8 , BASE_DEC , VALS ( vamos_level_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_tighter_cap , {\n \"TIGHTER Capability\" , \"gsm_a.classmark3.tighter_cap\" , FT_UINT8 , BASE_DEC , VALS ( tighter_cap_level_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_selective_ciph_down_sacch , {\n \"Selective Ciphering of Downlink SACCH\" , \"gsm_a.classmark3.selective_ciph_down_sacch\" , FT_BOOLEAN , BASE_NONE , TFS ( & tfs_supported_not_supported ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_cs_to_ps_srvcc_geran_to_utra , {\n \"CS to PS SRVCC from GERAN to UTRA\" , \"gsm_a.classmark3.cs_to_ps_srvcc_geran_to_utra\" , FT_UINT8 , BASE_DEC , VALS ( cs_to_ps_srvcc_geran_to_utra_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_cs_to_ps_srvcc_geran_to_eutra , {\n \"CS to PS SRVCC from GERAN to E-UTRA\" , \"gsm_a.classmark3.cs_to_ps_srvcc_geran_to_eutra\" , FT_UINT8 , BASE_DEC , VALS ( cs_to_ps_srvcc_geran_to_eutra_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geran_network_sharing_support , {\n \"GERAN Network Sharing support\" , \"gsm_a.classmark3.geran_network_sharing_support\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_eutra_wb_rsrq_support , {\n \"E-UTRA Wideband RSRQ measurements support\" , \"gsm_a.classmark3.eutra_wb_rsrq_support\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_er_band_support , {\n \"ER Band support\" , \"gsm_a.classmark3.er_band_support\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_utra_mfbi_support , {\n \"UTRA Multiple Frequency Band Indicators support\" , \"gsm_a.classmark3.utra_mfbi_support\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_eutra_mfbi_support , {\n \"E-UTRA Multiple Frequency Band Indicators support\" , \"gsm_a.classmark3.eutra_mfbi_support\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ext_tsc_set_cap_support , {\n \"Extended TSC Set Capability support\" , \"gsm_a.classmark3.ext_tsc_set_cap_support\" , FT_BOOLEAN , BASE_NONE , TFS ( & true_false_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ext_earfcn_value_range , {\n \"Extended EARFCN value range\" , \"gsm_a.classmark3.ext_earfcn_value_range\" , FT_BOOLEAN , BASE_NONE , TFS ( & tfs_supported_not_supported ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_type_of_shape , {\n \"Location estimate\" , \"gsm_a.gad.location_estimate\" , FT_UINT8 , BASE_DEC , VALS ( type_of_shape_vals ) , 0xf0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_sign_of_lat , {\n \"Sign of latitude\" , \"gsm_a.gad.sign_of_latitude\" , FT_UINT8 , BASE_DEC , VALS ( sign_of_latitude_vals ) , 0x80 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_deg_of_lat , {\n \"Degrees of latitude\" , \"gsm_a.gad.deg_of_latitude\" , FT_UINT24 , BASE_DEC , NULL , 0x7fffff , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_deg_of_long , {\n \"Degrees of longitude\" , \"gsm_a.gad.deg_of_longitude\" , FT_INT24 , BASE_DEC , NULL , 0xffffff , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_uncertainty_code , {\n \"Uncertainty code\" , \"gsm_a.gad.uncertainty_code\" , FT_UINT8 , BASE_DEC , NULL , 0x7f , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_uncertainty_semi_major , {\n \"Uncertainty semi-major\" , \"gsm_a.gad.uncertainty_semi_major\" , FT_UINT8 , BASE_DEC , NULL , 0x7f , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_uncertainty_semi_minor , {\n \"Uncertainty semi-minor\" , \"gsm_a.gad.uncertainty_semi_minor\" , FT_UINT8 , BASE_DEC , NULL , 0x7f , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_orientation_of_major_axis , {\n \"Orientation of major axis\" , \"gsm_a.gad.orientation_of_major_axis\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_uncertainty_altitude , {\n \"Uncertainty Altitude\" , \"gsm_a.gad.uncertainty_altitude\" , FT_UINT8 , BASE_DEC , NULL , 0x7f , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_confidence , {\n \"Confidence(%)\" , \"gsm_a.gad.confidence\" , FT_UINT8 , BASE_DEC , NULL , 0x7f , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_no_of_points , {\n \"Number of points\" , \"gsm_a.gad.no_of_points\" , FT_UINT8 , BASE_DEC , NULL , 0x0f , NULL , HFILL }\n }\n , {\n & hf_gsm_a_velocity_type , {\n \"Number of points\" , \"gsm_a.gad.velocity_type\" , FT_UINT8 , BASE_DEC , VALS ( gsm_a_velocity_type_vals ) , 0xf0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_bearing , {\n \"Bearing\" , \"gsm_a.gad.bearing\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_horizontal_speed , {\n \"Horizontal Speed\" , \"gsm_a.gad.horizontal_velocity\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_vertical_speed , {\n \"Vertical Speed\" , \"gsm_a.gad.vertical_speed\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_uncertainty_speed , {\n \"Uncertainty Speed\" , \"gsm_a.gad.uncertainty_speed\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_h_uncertainty_speed , {\n \"Horizontal Uncertainty Speed\" , \"gsm_a.gad.v_uncertainty_speed\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_v_uncertainty_speed , {\n \"Vertical Uncertainty Speed\" , \"gsm_a.gad.h_uncertainty_speed\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_d , {\n \"Direction of Vertical Speed\" , \"gsm_a.gad.d\" , FT_BOOLEAN , 8 , TFS ( & gsm_a_dir_of_ver_speed_vals ) , 0x08 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_D , {\n \"D: Direction of Altitude\" , \"gsm_a.gad.D\" , FT_UINT16 , BASE_DEC , VALS ( dir_of_alt_vals ) , 0x8000 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_altitude , {\n \"Altitude in meters\" , \"gsm_a.gad.altitude\" , FT_UINT16 , BASE_DEC , NULL , 0x7fff , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_inner_radius , {\n \"Inner radius\" , \"gsm_a.gad.altitude\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_uncertainty_radius , {\n \"Uncertainty radius\" , \"gsm_a.gad.no_of_points\" , FT_UINT8 , BASE_DEC , NULL , 0x7f , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_offset_angle , {\n \"Offset angle\" , \"gsm_a.gad.offset_angle\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_geo_loc_included_angle , {\n \"Included angle\" , \"gsm_a.gad.included_angle\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_key_seq , {\n \"key sequence\" , \"gsm_a.key_seq\" , FT_UINT8 , BASE_DEC , VALS ( gsm_a_key_seq_vals ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_lac , {\n \"Location Area Code (LAC)\" , \"gsm_a.lac\" , FT_UINT16 , BASE_HEX_DEC , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_spare_nibble , {\n \"Spare Nibble\" , \"gsm_a.spare\" , FT_UINT8 , BASE_DEC_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_filler , {\n \"Filler\" , \"gsm_a.filler\" , FT_UINT8 , BASE_HEX , NULL , 0xF0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_identity_digit1 , {\n \"Identity Digit 1\" , \"gsm_a.identity_digit1\" , FT_UINT8 , BASE_HEX , NULL , 0xF0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_group_call_reference , {\n \"Group or Broadcast call reference\" , \"gsm_a.group_call_reference\" , FT_UINT32 , BASE_DEC_HEX , NULL , 0xffffffe0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_service_flag , {\n \"SF Service Flag\" , \"gsm_a.service_flag\" , FT_BOOLEAN , 32 , TFS ( & tfs_vgcs_vbs ) , 0x00000010 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_af_acknowledgement , {\n \"AF Acknowledgement\" , \"gsm_a.af_acknowledgement\" , FT_BOOLEAN , 32 , TFS ( & tfs_required_not_required ) , 0x00000008 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_call_priority , {\n \"Call Priority\" , \"gsm_a.call_priority\" , FT_UINT32 , BASE_DEC , VALS ( gsm_a_call_priority_vals ) , 0x00000007 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_ciphering_info , {\n \"Ciphering Information\" , \"gsm_a.ciphering_info\" , FT_UINT8 , BASE_HEX , NULL , 0xf0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_sapi , {\n \"SAPI (Service Access Point Identifier)\" , \"gsm_a.sapi\" , FT_UINT8 , BASE_DEC , VALS ( gsm_a_sapi_vals ) , 0x30 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_mobile_country_code , {\n \"Mobile Country Code (MCC)\" , \"gsm_a.mobile_country_code\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_gsm_a_mobile_network_code , {\n \"Mobile Network Code (MNC)\" , \"gsm_a.mobile_network_code\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , }\n ;\n # define NUM_INDIVIDUAL_ELEMS 1 static gint * ett [ NUM_INDIVIDUAL_ELEMS + NUM_GSM_COMMON_ELEM ] ;\n static ei_register_info ei [ ] = {\n {\n & ei_gsm_a_extraneous_data , {\n \"gsm_a.extraneous_data\" , PI_PROTOCOL , PI_NOTE , \"Extraneous Data, dissector bug or later version spec(report to wireshark.org)\" , EXPFILL }\n }\n , {\n & ei_gsm_a_unknown_element , {\n \"gsm_a.unknown_element\" , PI_PROTOCOL , PI_ERROR , \"Unknown - aborting dissection\" , EXPFILL }\n }\n , {\n & ei_gsm_a_unknown_pdu_type , {\n \"gsm_a.unknown_pdu_type\" , PI_PROTOCOL , PI_WARN , \"Unknown PDU type\" , EXPFILL }\n }\n , {\n & ei_gsm_a_no_element_dissector , {\n \"gsm_a.no_element_dissector\" , PI_PROTOCOL , PI_WARN , \"No element dissector, rest of dissection may be incorrect\" , EXPFILL }\n }\n , {\n & ei_gsm_a_format_not_supported , {\n \"gsm_a.format_not_supported\" , PI_PROTOCOL , PI_WARN , \"Format not supported\" , EXPFILL }\n }\n , {\n & ei_gsm_a_mobile_identity_type , {\n \"gsm_a.ie.mobileid.type.unknown\" , PI_PROTOCOL , PI_WARN , \"Format unknown\" , EXPFILL }\n }\n , }\n ;\n expert_module_t * expert_a_common ;\n static tap_param gsm_a_stat_params [ ] = {\n {\n PARAM_FILTER , \"filter\" , \"Filter\" , NULL , TRUE }\n }\n ;\n static new_stat_tap_ui gsm_a_bssmap_stat_table = {\n REGISTER_STAT_GROUP_TELEPHONY_GSM , \"A-Interface BSSMAP\" , \"gsm_a\" , \"gsm_a,bssmap\" , gsm_a_bssmap_stat_init , gsm_a_bssmap_stat_packet , gsm_a_stat_reset , gsm_a_stat_free_table_item , NULL , sizeof ( gsm_a_stat_fields ) / sizeof ( stat_tap_table_item ) , gsm_a_stat_fields , sizeof ( gsm_a_stat_params ) / sizeof ( tap_param ) , gsm_a_stat_params , NULL }\n ;\n static new_stat_tap_ui gsm_a_dtap_mm_stat_table = {\n REGISTER_STAT_GROUP_TELEPHONY_GSM , \"A-Interface DTAP Mobility Management\" , \"gsm_a\" , \"gsm_a,dtap_mm\" , gsm_a_dtap_mm_stat_init , gsm_a_dtap_mm_stat_packet , gsm_a_stat_reset , NULL , NULL , sizeof ( gsm_a_stat_fields ) / sizeof ( stat_tap_table_item ) , gsm_a_stat_fields , sizeof ( gsm_a_stat_params ) / sizeof ( tap_param ) , gsm_a_stat_params , NULL }\n ;\n static new_stat_tap_ui gsm_a_dtap_rr_stat_table = {\n REGISTER_STAT_GROUP_TELEPHONY_GSM , \"A-Interface DTAP Radio Resource Management\" , \"gsm_a\" , \"gsm_a,dtap_rr\" , gsm_a_dtap_rr_stat_init , gsm_a_dtap_rr_stat_packet , gsm_a_stat_reset , NULL , NULL , sizeof ( gsm_a_stat_fields ) / sizeof ( stat_tap_table_item ) , gsm_a_stat_fields , sizeof ( gsm_a_stat_params ) / sizeof ( tap_param ) , gsm_a_stat_params , NULL }\n ;\n static new_stat_tap_ui gsm_a_dtap_cc_stat_table = {\n REGISTER_STAT_GROUP_TELEPHONY_GSM , \"A-Interface DTAP Call Control\" , \"gsm_a\" , \"gsm_a,dtap_cc\" , gsm_a_dtap_cc_stat_init , gsm_a_dtap_cc_stat_packet , gsm_a_stat_reset , NULL , NULL , sizeof ( gsm_a_stat_fields ) / sizeof ( stat_tap_table_item ) , gsm_a_stat_fields , sizeof ( gsm_a_stat_params ) / sizeof ( tap_param ) , gsm_a_stat_params , NULL }\n ;\n static new_stat_tap_ui gsm_a_dtap_gmm_stat_table = {\n REGISTER_STAT_GROUP_TELEPHONY_GSM , \"A-Interface DTAP GPRS Mobility Management\" , \"gsm_a\" , \"gsm_a,dtap_gmm\" , gsm_a_dtap_gmm_stat_init , gsm_a_dtap_gmm_stat_packet , gsm_a_stat_reset , NULL , NULL , sizeof ( gsm_a_stat_fields ) / sizeof ( stat_tap_table_item ) , gsm_a_stat_fields , sizeof ( gsm_a_stat_params ) / sizeof ( tap_param ) , gsm_a_stat_params , NULL }\n ;\n static new_stat_tap_ui gsm_a_dtap_sm_stat_table = {\n REGISTER_STAT_GROUP_TELEPHONY_GSM , \"A-Interface DTAP GPRS Session Management\" , \"gsm_a\" , \"gsm_a,dtap_sm\" , gsm_a_dtap_sm_stat_init , gsm_a_dtap_sm_stat_packet , gsm_a_stat_reset , NULL , NULL , sizeof ( gsm_a_stat_fields ) / sizeof ( stat_tap_table_item ) , gsm_a_stat_fields , sizeof ( gsm_a_stat_params ) / sizeof ( tap_param ) , gsm_a_stat_params , NULL }\n ;\n static new_stat_tap_ui gsm_a_dtap_sms_stat_table = {\n REGISTER_STAT_GROUP_TELEPHONY_GSM , \"A-Interface DTAP Short Message Service\" , \"gsm_a\" , \"gsm_a,dtap_sms\" , gsm_a_dtap_sms_stat_init , gsm_a_dtap_sms_stat_packet , gsm_a_stat_reset , NULL , NULL , sizeof ( gsm_a_stat_fields ) / sizeof ( stat_tap_table_item ) , gsm_a_stat_fields , sizeof ( gsm_a_stat_params ) / sizeof ( tap_param ) , gsm_a_stat_params , NULL }\n ;\n static new_stat_tap_ui gsm_a_dtap_tp_stat_table = {\n REGISTER_STAT_GROUP_TELEPHONY_GSM , \"A-Interface DTAP Special Conformance Testing Functions\" , \"gsm_a\" , \"gsm_a,dtap_tp\" , gsm_a_dtap_tp_stat_init , gsm_a_dtap_tp_stat_packet , gsm_a_stat_reset , NULL , NULL , sizeof ( gsm_a_stat_fields ) / sizeof ( stat_tap_table_item ) , gsm_a_stat_fields , sizeof ( gsm_a_stat_params ) / sizeof ( tap_param ) , gsm_a_stat_params , NULL }\n ;\n static new_stat_tap_ui gsm_a_dtap_ss_stat_table = {\n REGISTER_STAT_GROUP_TELEPHONY_GSM , \"A-Interface DTAP Supplementary Services\" , \"gsm_a\" , \"gsm_a,dtap_ss\" , gsm_a_dtap_ss_stat_init , gsm_a_dtap_ss_stat_packet , gsm_a_stat_reset , NULL , NULL , sizeof ( gsm_a_stat_fields ) / sizeof ( stat_tap_table_item ) , gsm_a_stat_fields , sizeof ( gsm_a_stat_params ) / sizeof ( tap_param ) , gsm_a_stat_params , NULL }\n ;\n static new_stat_tap_ui gsm_a_sacch_rr_stat_table = {\n REGISTER_STAT_GROUP_TELEPHONY_GSM , \"A-Interface SACCH\" , \"gsm_a\" , \"gsm_a,dtap_sacch\" , gsm_a_sacch_rr_stat_init , gsm_a_sacch_rr_stat_packet , gsm_a_stat_reset , NULL , NULL , sizeof ( gsm_a_stat_fields ) / sizeof ( stat_tap_table_item ) , gsm_a_stat_fields , sizeof ( gsm_a_stat_params ) / sizeof ( tap_param ) , gsm_a_stat_params , NULL }\n ;\n last_offset = NUM_INDIVIDUAL_ELEMS ;\n ett [ 0 ] = & ett_gsm_a_plmn ;\n for ( i = 0 ;\n i < NUM_GSM_COMMON_ELEM ;\n i ++ , last_offset ++ ) {\n ett_gsm_common_elem [ i ] = - 1 ;\n ett [ last_offset ] = & ett_gsm_common_elem [ i ] ;\n }\n proto_a_common = proto_register_protocol ( \"GSM A-I/F COMMON\" , \"GSM COMMON\" , \"gsm_a\" ) ;\n proto_register_field_array ( proto_a_common , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n expert_a_common = expert_register_protocol ( proto_a_common ) ;\n expert_register_field_array ( expert_a_common , ei , array_length ( ei ) ) ;\n gsm_a_tap = register_tap ( \"gsm_a\" ) ;\n register_new_stat_tap_ui ( & gsm_a_bssmap_stat_table ) ;\n register_new_stat_tap_ui ( & gsm_a_dtap_mm_stat_table ) ;\n register_new_stat_tap_ui ( & gsm_a_dtap_rr_stat_table ) ;\n register_new_stat_tap_ui ( & gsm_a_dtap_cc_stat_table ) ;\n register_new_stat_tap_ui ( & gsm_a_dtap_gmm_stat_table ) ;\n register_new_stat_tap_ui ( & gsm_a_dtap_sms_stat_table ) ;\n register_new_stat_tap_ui ( & gsm_a_dtap_sm_stat_table ) ;\n register_new_stat_tap_ui ( & gsm_a_dtap_ss_stat_table ) ;\n register_new_stat_tap_ui ( & gsm_a_dtap_tp_stat_table ) ;\n register_new_stat_tap_ui ( & gsm_a_sacch_rr_stat_table ) ;\n }", "hash": -2648356651055439484, "project": "debian", "size": 855, "target": 0, "idx": 1176}
{"code": "guint16 de_ps_domain_spec_sys_info ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n curr_offset = offset ;\n proto_tree_add_item ( tree , hf_gsm_a_gm_rac , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n curr_offset ++ ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , ( curr_offset << 3 ) , 6 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_nmo_1 , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_nmo , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n curr_offset ++ ;\n EXTRANEOUS_DATA_CHECK ( len , curr_offset - offset , pinfo , & ei_gsm_a_extraneous_data ) ;\n return ( curr_offset - offset ) ;\n }", "hash": -2648356651055439484, "project": "debian", "size": 12, "target": 0, "idx": 1183}
{"code": "static void gsm_a_stat_init ( new_stat_tap_ui * new_stat , new_stat_tap_gui_init_cb gui_callback , void * gui_data , const char * table_title , const value_string * msg_strings ) {\n int num_fields = sizeof ( gsm_a_stat_fields ) / sizeof ( stat_tap_table_item ) ;\n new_stat_tap_table * table ;\n guint i ;\n stat_tap_table_item_type items [ sizeof ( gsm_a_stat_fields ) / sizeof ( stat_tap_table_item ) ] ;\n items [ IEI_COLUMN ] . type = TABLE_ITEM_UINT ;\n items [ MSG_NAME_COLUMN ] . type = TABLE_ITEM_STRING ;\n items [ COUNT_COLUMN ] . type = TABLE_ITEM_UINT ;\n items [ COUNT_COLUMN ] . value . uint_value = 0 ;\n table = new_stat_tap_init_table ( table_title , num_fields , 0 , NULL , gui_callback , gui_data ) ;\n new_stat_tap_add_table ( new_stat , table ) ;\n for ( i = 0 ;\n i < 256 ;\n i ++ ) {\n const char * msg_str = try_val_to_str ( i , msg_strings ) ;\n char * col_str ;\n if ( msg_str ) {\n col_str = g_strdup ( msg_str ) ;\n }\n else {\n col_str = g_strdup_printf ( \"Unknown message %d\" , i ) ;\n }\n items [ IEI_COLUMN ] . value . uint_value = i ;\n items [ MSG_NAME_COLUMN ] . value . string_value = col_str ;\n new_stat_tap_init_table_row ( table , i , num_fields , items ) ;\n }\n }", "hash": -2648356651055439484, "project": "debian", "size": 27, "target": 0, "idx": 1185}
{"code": "static void gsm_a_dtap_mm_stat_init ( new_stat_tap_ui * new_stat , new_stat_tap_gui_init_cb gui_callback , void * gui_data ) {\n gsm_a_stat_init ( new_stat , gui_callback , gui_data , \"GSM A-I/F DTAP Mobility Management Statistics\" , gsm_a_dtap_msg_mm_strings ) ;\n }", "hash": -2648356651055439484, "project": "debian", "size": 3, "target": 0, "idx": 1199}
{"code": "static guint16 de_ms_net_feat_sup ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset , bit_offset ;\n curr_offset = offset ;\n bit_offset = ( curr_offset << 3 ) + 4 ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , bit_offset , 3 , ENC_BIG_ENDIAN ) ;\n bit_offset += 3 ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_ext_periodic_timers , tvb , bit_offset , 1 , ENC_BIG_ENDIAN ) ;\n curr_offset ++ ;\n return ( curr_offset - offset ) ;\n }", "hash": -2648356651055439484, "project": "debian", "size": 10, "target": 0, "idx": 1201}
{"code": "static guint16 de_pd_sapi ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n proto_tree * subtree ;\n curr_offset = offset ;\n subtree = proto_tree_add_subtree ( tree , tvb , curr_offset , 1 , ett_gsm_dtap_elem [ DE_PD_SAPI ] , NULL , val_to_str_ext_const ( DE_PD_SAPI , & gsm_dtap_elem_strings_ext , \"\" ) ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , curr_offset << 3 , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( subtree , hf_gsm_a_sapi , tvb , curr_offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( tree , hf_gsm_a_L3_protocol_discriminator , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n curr_offset ++ ;\n return ( curr_offset - offset ) ;\n }", "hash": -2648356651055439484, "project": "debian", "size": 11, "target": 0, "idx": 1207}
{"code": "static int dissect_zbee_zcl_scenes ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n proto_tree * payload_tree ;\n zbee_zcl_packet * zcl ;\n guint offset = 0 ;\n guint8 cmd_id ;\n gint rem_len ;\n if ( data == NULL ) return 0 ;\n zcl = ( zbee_zcl_packet * ) data ;\n cmd_id = zcl -> cmd_id ;\n if ( zcl -> direction == ZBEE_ZCL_FCF_TO_SERVER ) {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"%s, Seq: %u\" , val_to_str_const ( cmd_id , zbee_zcl_scenes_srv_rx_cmd_names , \"Unknown Command\" ) , zcl -> tran_seqno ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_scenes_srv_rx_cmd_id , tvb , offset , 1 , cmd_id ) ;\n rem_len = tvb_reported_length_remaining ( tvb , ++ offset ) ;\n if ( rem_len > 0 ) {\n payload_tree = proto_tree_add_subtree ( tree , tvb , offset , rem_len , ett_zbee_zcl_scenes , NULL , \"Payload\" ) ;\n switch ( cmd_id ) {\n case ZBEE_ZCL_CMD_ID_SCENES_ADD_SCENE : dissect_zcl_scenes_add_scene ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_SCENES_VIEW_SCENE : case ZBEE_ZCL_CMD_ID_SCENES_REMOVE_SCENE : case ZBEE_ZCL_CMD_ID_SCENES_STORE_SCENE : case ZBEE_ZCL_CMD_ID_SCENES_RECALL_SCENE : dissect_zcl_scenes_view_remove_store_recall_scene ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_SCENES_REMOVE_ALL_SCENES : case ZBEE_ZCL_CMD_ID_SCENES_GET_SCENE_MEMBERSHIP : dissect_zcl_scenes_remove_all_get_scene_membership ( tvb , payload_tree , & offset ) ;\n break ;\n default : break ;\n }\n }\n }\n else {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"%s, Seq: %u\" , val_to_str_const ( cmd_id , zbee_zcl_scenes_srv_tx_cmd_names , \"Unknown Command\" ) , zcl -> tran_seqno ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_scenes_srv_tx_cmd_id , tvb , offset , 1 , cmd_id ) ;\n rem_len = tvb_reported_length_remaining ( tvb , ++ offset ) ;\n if ( rem_len > 0 ) {\n payload_tree = proto_tree_add_subtree ( tree , tvb , offset , rem_len , ett_zbee_zcl_scenes , NULL , \"Payload\" ) ;\n switch ( cmd_id ) {\n case ZBEE_ZCL_CMD_ID_SCENES_ADD_SCENE_RESPONSE : case ZBEE_ZCL_CMD_ID_SCENES_REMOVE_SCENE_RESPONSE : case ZBEE_ZCL_CMD_ID_SCENES_STORE_SCENE_RESPONSE : dissect_zcl_scenes_add_remove_store_scene_response ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_SCENES_VIEW_SCENE_RESPONSE : dissect_zcl_scenes_view_scene_response ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_SCENES_REMOVE_ALL_SCENES_RESPONSE : dissect_zcl_scenes_remove_all_scenes_response ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_SCENES_GET_SCENE_MEMBERSHIP_RESPONSE : dissect_zcl_scenes_get_scene_membership_response ( tvb , payload_tree , & offset ) ;\n break ;\n default : break ;\n }\n }\n }\n return tvb_captured_length ( tvb ) ;\n }", "hash": 6336384260629386331, "project": "debian", "size": 47, "target": 0, "idx": 1216}
{"code": "static void dissect_zcl_pwr_prof_pwrprofnotif ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n proto_tree * sub_tree = NULL ;\n guint i ;\n guint8 total_profile_number ;\n guint8 num_of_transferred_phases ;\n total_profile_number = tvb_get_guint8 ( tvb , * offset ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_tot_prof_num , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n if ( total_profile_number != 0 ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_pwr_prof_id , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n num_of_transferred_phases = tvb_get_guint8 ( tvb , * offset ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_num_of_trans_phases , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n for ( i = 0 ;\n i < num_of_transferred_phases ;\n i ++ ) {\n sub_tree = proto_tree_add_subtree_format ( tree , tvb , * offset , 1 , ett_zbee_zcl_pwr_prof_enphases [ i ] , NULL , \"Energy Phase #%u\" , i ) ;\n dissect_zcl_energy_phase ( tvb , sub_tree , offset ) ;\n }\n }\n }", "hash": 6336384260629386331, "project": "debian", "size": 22, "target": 0, "idx": 1219}
{"code": "static void decode_zcl_ota_upgr_time ( gchar * s , guint32 value ) {\n if ( value == ZBEE_ZCL_OTA_TIME_WAIT ) {\n g_snprintf ( s , ITEM_LABEL_LENGTH , \"Wait for upgrade command\" ) ;\n }\n else {\n gchar * tmp = time_secs_to_str ( NULL , value ) ;\n g_snprintf ( s , ITEM_LABEL_LENGTH , \"%s from now\" , tmp ) ;\n wmem_free ( NULL , tmp ) ;\n }\n return ;\n }", "hash": 6336384260629386331, "project": "debian", "size": 11, "target": 0, "idx": 1238}
{"code": "static int dissect_zbee_zcl_part ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n proto_tree * payload_tree ;\n zbee_zcl_packet * zcl ;\n guint offset = 0 ;\n guint8 cmd_id ;\n gint rem_len ;\n if ( data == NULL ) return 0 ;\n zcl = ( zbee_zcl_packet * ) data ;\n cmd_id = zcl -> cmd_id ;\n if ( zcl -> direction == ZBEE_ZCL_FCF_TO_SERVER ) {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"%s, Seq: %u\" , val_to_str_const ( cmd_id , zbee_zcl_part_srv_rx_cmd_names , \"Unknown Command\" ) , zcl -> tran_seqno ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_part_srv_rx_cmd_id , tvb , offset , 1 , cmd_id ) ;\n rem_len = tvb_reported_length_remaining ( tvb , ++ offset ) ;\n if ( rem_len > 0 ) {\n payload_tree = proto_tree_add_subtree ( tree , tvb , offset , rem_len , ett_zbee_zcl_part , NULL , \"Payload\" ) ;\n switch ( cmd_id ) {\n case ZBEE_ZCL_CMD_ID_PART_TRANSF_PART_FRAME : dissect_zcl_part_trasfpartframe ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_PART_RD_HANDSHAKE_PARAM : dissect_zcl_part_rdhandshakeparam ( tvb , pinfo , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_PART_WR_HANDSHAKE_PARAM : dissect_zcl_part_wrhandshakeparam ( tvb , pinfo , payload_tree , & offset ) ;\n break ;\n default : break ;\n }\n }\n }\n else {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"%s, Seq: %u\" , val_to_str_const ( cmd_id , zbee_zcl_part_srv_tx_cmd_names , \"Unknown Command\" ) , zcl -> tran_seqno ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_part_srv_tx_cmd_id , tvb , offset , 1 , cmd_id ) ;\n rem_len = tvb_reported_length_remaining ( tvb , ++ offset ) ;\n if ( rem_len > 0 ) {\n payload_tree = proto_tree_add_subtree ( tree , tvb , offset , rem_len , ett_zbee_zcl_part , NULL , \"Payload\" ) ;\n switch ( cmd_id ) {\n case ZBEE_ZCL_CMD_ID_PART_MULTI_ACK : dissect_zcl_part_multiack ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_PART_RD_HANDSHAKE_PARAM_RSP : dissect_zcl_part_rdhandshakeparamrsp ( tvb , pinfo , payload_tree , & offset ) ;\n break ;\n default : break ;\n }\n }\n }\n return tvb_captured_length ( tvb ) ;\n }", "hash": 6336384260629386331, "project": "debian", "size": 43, "target": 0, "idx": 1248}
{"code": "void proto_reg_handoff_zbee_zcl_pwr_prof ( void ) {\n dissector_handle_t pwr_prof_handle ;\n pwr_prof_handle = find_dissector ( ZBEE_PROTOABBREV_ZCL_PWRPROF ) ;\n dissector_add_uint ( \"zbee.zcl.cluster\" , ZBEE_ZCL_CID_POWER_PROFILE , pwr_prof_handle ) ;\n zbee_zcl_init_cluster ( proto_zbee_zcl_pwr_prof , ett_zbee_zcl_pwr_prof , ZBEE_ZCL_CID_POWER_PROFILE , hf_zbee_zcl_pwr_prof_attr_id , hf_zbee_zcl_pwr_prof_srv_rx_cmd_id , hf_zbee_zcl_pwr_prof_srv_tx_cmd_id , ( zbee_zcl_fn_attr_data ) dissect_zcl_pwr_prof_attr_data ) ;\n }", "hash": 6336384260629386331, "project": "debian", "size": 6, "target": 0, "idx": 1277}
{"code": "static ssize_t net_slirp_receive ( NetClientState * nc , const uint8_t * buf , size_t size ) {\n SlirpState * s = DO_UPCAST ( SlirpState , nc , nc ) ;\n slirp_input ( s -> slirp , buf , size ) ;\n return size ;\n }", "hash": 583170025160259883, "project": "debian", "size": 5, "target": 0, "idx": 1342}
{"code": "static const char * * slirp_dnssearch ( const StringList * dnsname ) {\n const StringList * c = dnsname ;\n size_t i = 0 , num_opts = 0 ;\n const char * * ret ;\n while ( c ) {\n num_opts ++ ;\n c = c -> next ;\n }\n if ( num_opts == 0 ) {\n return NULL ;\n }\n ret = g_malloc ( ( num_opts + 1 ) * sizeof ( * ret ) ) ;\n c = dnsname ;\n while ( c ) {\n ret [ i ++ ] = c -> value -> str ;\n c = c -> next ;\n }\n ret [ i ] = NULL ;\n return ret ;\n }", "hash": 583170025160259883, "project": "debian", "size": 20, "target": 0, "idx": 1344}
{"code": "int net_slirp_redir ( const char * redir_str ) {\n struct slirp_config_str * config ;\n if ( QTAILQ_EMPTY ( & slirp_stacks ) ) {\n config = g_malloc ( sizeof ( * config ) ) ;\n pstrcpy ( config -> str , sizeof ( config -> str ) , redir_str ) ;\n config -> flags = SLIRP_CFG_HOSTFWD | SLIRP_CFG_LEGACY ;\n config -> next = slirp_configs ;\n slirp_configs = config ;\n return 0 ;\n }\n return slirp_hostfwd ( QTAILQ_FIRST ( & slirp_stacks ) , redir_str , 1 ) ;\n }", "hash": 583170025160259883, "project": "debian", "size": 12, "target": 0, "idx": 1353}
{"code": "static int rds_cmsg_recv ( struct rds_incoming * inc , struct msghdr * msg , struct rds_sock * rs ) {\n int ret = 0 ;\n if ( inc -> i_rdma_cookie ) {\n ret = put_cmsg ( msg , SOL_RDS , RDS_CMSG_RDMA_DEST , sizeof ( inc -> i_rdma_cookie ) , & inc -> i_rdma_cookie ) ;\n if ( ret ) return ret ;\n }\n if ( ( inc -> i_rx_tstamp . tv_sec != 0 ) && sock_flag ( rds_rs_to_sk ( rs ) , SOCK_RCVTSTAMP ) ) {\n ret = put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( struct timeval ) , & inc -> i_rx_tstamp ) ;\n if ( ret ) return ret ;\n }\n return 0 ;\n }", "hash": 6595989226414083189, "project": "debian", "size": 12, "target": 0, "idx": 1365}
{"code": "static __always_inline void __swab32s ( __u32 * p ) {\n # ifdef __arch_swab32s __arch_swab32s ( p ) ;\n # else * p = __swab32p ( p ) ;\n # endif }", "hash": 6595989226414083189, "project": "debian", "size": 4, "target": 0, "idx": 1368}
{"code": "static __inline__ __u32 __swahw32p ( const __u32 * p ) {\n # ifdef __arch_swahw32p return __arch_swahw32p ( p ) ;\n # else return __swahw32 ( * p ) ;\n # endif }", "hash": 6595989226414083189, "project": "debian", "size": 4, "target": 0, "idx": 1375}
{"code": "void jpc_ns_fwdlift_row ( jpc_fix_t * a , int numcols , int parity ) {\n register jpc_fix_t * lptr ;\n register jpc_fix_t * hptr ;\n register int n ;\n int llen ;\n llen = ( numcols + 1 - parity ) >> 1 ;\n if ( numcols > 1 ) {\n lptr = & a [ 0 ] ;\n hptr = & a [ llen ] ;\n if ( parity ) {\n jpc_fix_pluseq ( hptr [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * ALPHA ) , lptr [ 0 ] ) ) ;\n ++ hptr ;\n }\n n = numcols - llen - parity - ( parity == ( numcols & 1 ) ) ;\n while ( n -- > 0 ) {\n jpc_fix_pluseq ( hptr [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( ALPHA ) , jpc_fix_add ( lptr [ 0 ] , lptr [ 1 ] ) ) ) ;\n ++ hptr ;\n ++ lptr ;\n }\n if ( parity == ( numcols & 1 ) ) {\n jpc_fix_pluseq ( hptr [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * ALPHA ) , lptr [ 0 ] ) ) ;\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen ] ;\n if ( ! parity ) {\n jpc_fix_pluseq ( lptr [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * BETA ) , hptr [ 0 ] ) ) ;\n ++ lptr ;\n }\n n = llen - ( ! parity ) - ( parity != ( numcols & 1 ) ) ;\n while ( n -- > 0 ) {\n jpc_fix_pluseq ( lptr [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( BETA ) , jpc_fix_add ( hptr [ 0 ] , hptr [ 1 ] ) ) ) ;\n ++ lptr ;\n ++ hptr ;\n }\n if ( parity != ( numcols & 1 ) ) {\n jpc_fix_pluseq ( lptr [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * BETA ) , hptr [ 0 ] ) ) ;\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen ] ;\n if ( parity ) {\n jpc_fix_pluseq ( hptr [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * GAMMA ) , lptr [ 0 ] ) ) ;\n ++ hptr ;\n }\n n = numcols - llen - parity - ( parity == ( numcols & 1 ) ) ;\n while ( n -- > 0 ) {\n jpc_fix_pluseq ( hptr [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( GAMMA ) , jpc_fix_add ( lptr [ 0 ] , lptr [ 1 ] ) ) ) ;\n ++ hptr ;\n ++ lptr ;\n }\n if ( parity == ( numcols & 1 ) ) {\n jpc_fix_pluseq ( hptr [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * GAMMA ) , lptr [ 0 ] ) ) ;\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen ] ;\n if ( ! parity ) {\n jpc_fix_pluseq ( lptr [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * DELTA ) , hptr [ 0 ] ) ) ;\n ++ lptr ;\n }\n n = llen - ( ! parity ) - ( parity != ( numcols & 1 ) ) ;\n while ( n -- > 0 ) {\n jpc_fix_pluseq ( lptr [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( DELTA ) , jpc_fix_add ( hptr [ 0 ] , hptr [ 1 ] ) ) ) ;\n ++ lptr ;\n ++ hptr ;\n }\n if ( parity != ( numcols & 1 ) ) {\n jpc_fix_pluseq ( lptr [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * DELTA ) , hptr [ 0 ] ) ) ;\n }\n # if defined ( WT_DOSCALE ) lptr = & a [ 0 ] ;\n n = llen ;\n while ( n -- > 0 ) {\n lptr [ 0 ] = jpc_fix_mul ( lptr [ 0 ] , jpc_dbltofix ( LGAIN ) ) ;\n ++ lptr ;\n }\n hptr = & a [ llen ] ;\n n = numcols - llen ;\n while ( n -- > 0 ) {\n hptr [ 0 ] = jpc_fix_mul ( hptr [ 0 ] , jpc_dbltofix ( HGAIN ) ) ;\n ++ hptr ;\n }\n # endif }\n else {\n # if defined ( WT_LENONE ) if ( parity ) {\n lptr = & a [ 0 ] ;\n lptr [ 0 ] = jpc_fix_asl ( lptr [ 0 ] , 1 ) ;\n }\n # endif }\n }", "hash": 4715922168896528064, "project": "debian", "size": 87, "target": 0, "idx": 1414}
{"code": "void jpc_ft_fwdlift_colres ( jpc_fix_t * a , int numrows , int numcols , int stride , int parity ) {\n jpc_fix_t * lptr ;\n jpc_fix_t * hptr ;\n register jpc_fix_t * lptr2 ;\n register jpc_fix_t * hptr2 ;\n register int n ;\n register int i ;\n int llen ;\n llen = ( numrows + 1 - parity ) >> 1 ;\n if ( numrows > 1 ) {\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n hptr2 [ 0 ] -= lptr2 [ 0 ] ;\n ++ hptr2 ;\n ++ lptr2 ;\n }\n hptr += stride ;\n }\n n = numrows - llen - parity - ( parity == ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n hptr2 [ 0 ] -= jpc_fix_asr ( lptr2 [ 0 ] + lptr2 [ stride ] , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n hptr += stride ;\n lptr += stride ;\n }\n if ( parity == ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n hptr2 [ 0 ] -= lptr2 [ 0 ] ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( ! parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n lptr2 [ 0 ] += jpc_fix_asr ( hptr2 [ 0 ] + 1 , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n }\n n = llen - ( ! parity ) - ( parity != ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n lptr2 [ 0 ] += jpc_fix_asr ( hptr2 [ 0 ] + hptr2 [ stride ] + 2 , 2 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n hptr += stride ;\n }\n if ( parity != ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n lptr2 [ 0 ] += jpc_fix_asr ( hptr2 [ 0 ] + 1 , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n }\n else {\n if ( parity ) {\n lptr2 = & a [ 0 ] ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n lptr2 [ 0 ] = jpc_fix_asl ( lptr2 [ 0 ] , 1 ) ;\n ++ lptr2 ;\n }\n }\n }\n }", "hash": 4715922168896528064, "project": "debian", "size": 101, "target": 0, "idx": 1415}
{"code": "void jpc_qmfb_split_col ( jpc_fix_t * a , int numrows , int stride , int parity ) {\n int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ;\n jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE ] ;\n jpc_fix_t * buf = splitbuf ;\n register jpc_fix_t * srcptr ;\n register jpc_fix_t * dstptr ;\n register int n ;\n register int m ;\n int hstartrow ;\n if ( bufsize > QMFB_SPLITBUFSIZE ) {\n if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) {\n abort ( ) ;\n }\n }\n if ( numrows >= 2 ) {\n hstartrow = ( numrows + 1 - parity ) >> 1 ;\n m = numrows - hstartrow ;\n n = m ;\n dstptr = buf ;\n srcptr = & a [ ( 1 - parity ) * stride ] ;\n while ( n -- > 0 ) {\n * dstptr = * srcptr ;\n ++ dstptr ;\n srcptr += stride << 1 ;\n }\n dstptr = & a [ ( 1 - parity ) * stride ] ;\n srcptr = & a [ ( 2 - parity ) * stride ] ;\n n = numrows - m - ( ! parity ) ;\n while ( n -- > 0 ) {\n * dstptr = * srcptr ;\n dstptr += stride ;\n srcptr += stride << 1 ;\n }\n dstptr = & a [ hstartrow * stride ] ;\n srcptr = buf ;\n n = m ;\n while ( n -- > 0 ) {\n * dstptr = * srcptr ;\n dstptr += stride ;\n ++ srcptr ;\n }\n }\n if ( buf != splitbuf ) {\n jas_free ( buf ) ;\n }\n }", "hash": 4715922168896528064, "project": "debian", "size": 46, "target": 0, "idx": 1416}
{"code": "void jpc_ft_invlift_colres ( jpc_fix_t * a , int numrows , int numcols , int stride , int parity ) {\n jpc_fix_t * lptr ;\n jpc_fix_t * hptr ;\n register jpc_fix_t * lptr2 ;\n register jpc_fix_t * hptr2 ;\n register int n ;\n register int i ;\n int llen ;\n llen = ( numrows + 1 - parity ) >> 1 ;\n if ( numrows > 1 ) {\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( ! parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n lptr2 [ 0 ] -= jpc_fix_asr ( hptr2 [ 0 ] + 1 , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n }\n n = llen - ( ! parity ) - ( parity != ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n lptr2 [ 0 ] -= jpc_fix_asr ( hptr2 [ 0 ] + hptr2 [ stride ] + 2 , 2 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n hptr += stride ;\n }\n if ( parity != ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n lptr2 [ 0 ] -= jpc_fix_asr ( hptr2 [ 0 ] + 1 , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n hptr2 [ 0 ] += lptr2 [ 0 ] ;\n ++ hptr2 ;\n ++ lptr2 ;\n }\n hptr += stride ;\n }\n n = numrows - llen - parity - ( parity == ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n hptr2 [ 0 ] += jpc_fix_asr ( lptr2 [ 0 ] + lptr2 [ stride ] , 1 ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n hptr += stride ;\n lptr += stride ;\n }\n if ( parity == ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n hptr2 [ 0 ] += lptr2 [ 0 ] ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n }\n else {\n if ( parity ) {\n lptr2 = & a [ 0 ] ;\n for ( i = 0 ;\n i < numcols ;\n ++ i ) {\n lptr2 [ 0 ] = jpc_fix_asr ( lptr2 [ 0 ] , 1 ) ;\n ++ lptr2 ;\n }\n }\n }\n }", "hash": 4715922168896528064, "project": "debian", "size": 101, "target": 0, "idx": 1420}
{"code": "void jpc_ns_invlift_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) {\n jpc_fix_t * lptr ;\n jpc_fix_t * hptr ;\n register jpc_fix_t * lptr2 ;\n register jpc_fix_t * hptr2 ;\n register int n ;\n register int i ;\n int llen ;\n llen = ( numrows + 1 - parity ) >> 1 ;\n if ( numrows > 1 ) {\n # if defined ( WT_DOSCALE ) lptr = & a [ 0 ] ;\n n = llen ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n lptr2 [ 0 ] = jpc_fix_mul ( lptr2 [ 0 ] , jpc_dbltofix ( 1.0 / LGAIN ) ) ;\n ++ lptr2 ;\n }\n lptr += stride ;\n }\n hptr = & a [ llen * stride ] ;\n n = numrows - llen ;\n while ( n -- > 0 ) {\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n hptr2 [ 0 ] = jpc_fix_mul ( hptr2 [ 0 ] , jpc_dbltofix ( 1.0 / HGAIN ) ) ;\n ++ hptr2 ;\n }\n hptr += stride ;\n }\n # endif lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( ! parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * DELTA ) , hptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n }\n n = llen - ( ! parity ) - ( parity != ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( DELTA ) , jpc_fix_add ( hptr2 [ 0 ] , hptr2 [ stride ] ) ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n hptr += stride ;\n }\n if ( parity != ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * DELTA ) , hptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * GAMMA ) , lptr2 [ 0 ] ) ) ;\n ++ hptr2 ;\n ++ lptr2 ;\n }\n hptr += stride ;\n }\n n = numrows - llen - parity - ( parity == ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( GAMMA ) , jpc_fix_add ( lptr2 [ 0 ] , lptr2 [ stride ] ) ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n hptr += stride ;\n lptr += stride ;\n }\n if ( parity == ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * GAMMA ) , lptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( ! parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * BETA ) , hptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n }\n n = llen - ( ! parity ) - ( parity != ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( BETA ) , jpc_fix_add ( hptr2 [ 0 ] , hptr2 [ stride ] ) ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n lptr += stride ;\n hptr += stride ;\n }\n if ( parity != ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n jpc_fix_minuseq ( lptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * BETA ) , hptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n lptr = & a [ 0 ] ;\n hptr = & a [ llen * stride ] ;\n if ( parity ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * ALPHA ) , lptr2 [ 0 ] ) ) ;\n ++ hptr2 ;\n ++ lptr2 ;\n }\n hptr += stride ;\n }\n n = numrows - llen - parity - ( parity == ( numrows & 1 ) ) ;\n while ( n -- > 0 ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( ALPHA ) , jpc_fix_add ( lptr2 [ 0 ] , lptr2 [ stride ] ) ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n hptr += stride ;\n lptr += stride ;\n }\n if ( parity == ( numrows & 1 ) ) {\n lptr2 = lptr ;\n hptr2 = hptr ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n jpc_fix_minuseq ( hptr2 [ 0 ] , jpc_fix_mul ( jpc_dbltofix ( 2.0 * ALPHA ) , lptr2 [ 0 ] ) ) ;\n ++ lptr2 ;\n ++ hptr2 ;\n }\n }\n }\n else {\n # if defined ( WT_LENONE ) if ( parity ) {\n lptr2 = & a [ 0 ] ;\n for ( i = 0 ;\n i < JPC_QMFB_COLGRPSIZE ;\n ++ i ) {\n lptr2 [ 0 ] = jpc_fix_asr ( lptr2 [ 0 ] , 1 ) ;\n ++ lptr2 ;\n }\n }\n # endif }\n }", "hash": 4715922168896528064, "project": "debian", "size": 203, "target": 0, "idx": 1431}
{"code": "static int tipc_tlv_sprintf ( struct sk_buff * skb , const char * fmt , ... ) {\n int n ;\n u16 len ;\n u32 rem ;\n char * buf ;\n struct tlv_desc * tlv ;\n va_list args ;\n rem = tipc_skb_tailroom ( skb ) ;\n tlv = ( struct tlv_desc * ) skb -> data ;\n len = TLV_GET_LEN ( tlv ) ;\n buf = TLV_DATA ( tlv ) + len ;\n va_start ( args , fmt ) ;\n n = vscnprintf ( buf , rem , fmt , args ) ;\n va_end ( args ) ;\n TLV_SET_LEN ( tlv , n + len ) ;\n skb_put ( skb , n ) ;\n return n ;\n }", "hash": 9046191708840218774, "project": "debian", "size": 18, "target": 0, "idx": 1458}
{"code": "static __inline__ void TLV_SET_LEN ( struct tlv_desc * tlv , __u16 len ) {\n tlv -> tlv_len = htons ( len ) ;\n }", "hash": 9046191708840218774, "project": "debian", "size": 3, "target": 0, "idx": 1466}
{"code": "static int rawv6_sendmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len ) {\n struct ipv6_txoptions opt_space ;\n struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ;\n struct in6_addr * daddr , * final_p = NULL , final ;\n struct inet_sock * inet = inet_sk ( sk ) ;\n struct ipv6_pinfo * np = inet6_sk ( sk ) ;\n struct raw6_sock * rp = raw6_sk ( sk ) ;\n struct ipv6_txoptions * opt = NULL ;\n struct ip6_flowlabel * flowlabel = NULL ;\n struct dst_entry * dst = NULL ;\n struct flowi fl ;\n int addr_len = msg -> msg_namelen ;\n int hlimit = - 1 ;\n int tclass = - 1 ;\n int dontfrag = - 1 ;\n u16 proto ;\n int err ;\n if ( len > INT_MAX ) return - EMSGSIZE ;\n if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ;\n memset ( & fl , 0 , sizeof ( fl ) ) ;\n fl . mark = sk -> sk_mark ;\n if ( sin6 ) {\n if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ;\n if ( sin6 -> sin6_family && sin6 -> sin6_family != AF_INET6 ) return ( - EAFNOSUPPORT ) ;\n proto = ntohs ( sin6 -> sin6_port ) ;\n if ( ! proto ) proto = inet -> inet_num ;\n else if ( proto != inet -> inet_num ) return ( - EINVAL ) ;\n if ( proto > 255 ) return ( - EINVAL ) ;\n daddr = & sin6 -> sin6_addr ;\n if ( np -> sndflow ) {\n fl . fl6_flowlabel = sin6 -> sin6_flowinfo & IPV6_FLOWINFO_MASK ;\n if ( fl . fl6_flowlabel & IPV6_FLOWLABEL_MASK ) {\n flowlabel = fl6_sock_lookup ( sk , fl . fl6_flowlabel ) ;\n if ( flowlabel == NULL ) return - EINVAL ;\n daddr = & flowlabel -> dst ;\n }\n }\n if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & np -> daddr ) ) daddr = & np -> daddr ;\n if ( addr_len >= sizeof ( struct sockaddr_in6 ) && sin6 -> sin6_scope_id && ipv6_addr_type ( daddr ) & IPV6_ADDR_LINKLOCAL ) fl . oif = sin6 -> sin6_scope_id ;\n }\n else {\n if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ;\n proto = inet -> inet_num ;\n daddr = & np -> daddr ;\n fl . fl6_flowlabel = np -> flow_label ;\n }\n if ( fl . oif == 0 ) fl . oif = sk -> sk_bound_dev_if ;\n if ( msg -> msg_controllen ) {\n opt = & opt_space ;\n memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ;\n opt -> tot_len = sizeof ( struct ipv6_txoptions ) ;\n err = datagram_send_ctl ( sock_net ( sk ) , msg , & fl , opt , & hlimit , & tclass , & dontfrag ) ;\n if ( err < 0 ) {\n fl6_sock_release ( flowlabel ) ;\n return err ;\n }\n if ( ( fl . fl6_flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) {\n flowlabel = fl6_sock_lookup ( sk , fl . fl6_flowlabel ) ;\n if ( flowlabel == NULL ) return - EINVAL ;\n }\n if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ;\n }\n if ( opt == NULL ) opt = np -> opt ;\n if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ;\n opt = ipv6_fixup_options ( & opt_space , opt ) ;\n fl . proto = proto ;\n err = rawv6_probe_proto_opt ( & fl , msg ) ;\n if ( err ) goto out ;\n if ( ! ipv6_addr_any ( daddr ) ) ipv6_addr_copy ( & fl . fl6_dst , daddr ) ;\n else fl . fl6_dst . s6_addr [ 15 ] = 0x1 ;\n if ( ipv6_addr_any ( & fl . fl6_src ) && ! ipv6_addr_any ( & np -> saddr ) ) ipv6_addr_copy ( & fl . fl6_src , & np -> saddr ) ;\n if ( opt && opt -> srcrt ) {\n struct rt0_hdr * rt0 = ( struct rt0_hdr * ) opt -> srcrt ;\n ipv6_addr_copy ( & final , & fl . fl6_dst ) ;\n ipv6_addr_copy ( & fl . fl6_dst , rt0 -> addr ) ;\n final_p = & final ;\n }\n if ( ! fl . oif && ipv6_addr_is_multicast ( & fl . fl6_dst ) ) fl . oif = np -> mcast_oif ;\n security_sk_classify_flow ( sk , & fl ) ;\n err = ip6_dst_lookup ( sk , & dst , & fl ) ;\n if ( err ) goto out ;\n if ( final_p ) ipv6_addr_copy ( & fl . fl6_dst , final_p ) ;\n err = __xfrm_lookup ( sock_net ( sk ) , & dst , & fl , sk , XFRM_LOOKUP_WAIT ) ;\n if ( err < 0 ) {\n if ( err == - EREMOTE ) err = ip6_dst_blackhole ( sk , & dst , & fl ) ;\n if ( err < 0 ) goto out ;\n }\n if ( hlimit < 0 ) {\n if ( ipv6_addr_is_multicast ( & fl . fl6_dst ) ) hlimit = np -> mcast_hops ;\n else hlimit = np -> hop_limit ;\n if ( hlimit < 0 ) hlimit = ip6_dst_hoplimit ( dst ) ;\n }\n if ( tclass < 0 ) tclass = np -> tclass ;\n if ( dontfrag < 0 ) dontfrag = np -> dontfrag ;\n if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ;\n back_from_confirm : if ( inet -> hdrincl ) {\n err = rawv6_send_hdrinc ( sk , msg -> msg_iov , len , & fl , ( struct rt6_info * ) dst , msg -> msg_flags ) ;\n }\n else {\n lock_sock ( sk ) ;\n err = ip6_append_data ( sk , ip_generic_getfrag , msg -> msg_iov , len , 0 , hlimit , tclass , opt , & fl , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ;\n if ( err ) ip6_flush_pending_frames ( sk ) ;\n else if ( ! ( msg -> msg_flags & MSG_MORE ) ) err = rawv6_push_pending_frames ( sk , & fl , rp ) ;\n release_sock ( sk ) ;\n }\n done : dst_release ( dst ) ;\n out : fl6_sock_release ( flowlabel ) ;\n return err < 0 ? err : len ;\n do_confirm : dst_confirm ( dst ) ;\n if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ;\n err = 0 ;\n goto done ;\n }", "hash": -7888349587538303571, "project": "debian", "size": 113, "target": 0, "idx": 1496}
{"code": "static void raw6_destroy ( struct sock * sk ) {\n lock_sock ( sk ) ;\n ip6_flush_pending_frames ( sk ) ;\n release_sock ( sk ) ;\n inet6_destroy_sock ( sk ) ;\n }", "hash": -7888349587538303571, "project": "debian", "size": 6, "target": 0, "idx": 1508}
{"code": "static __inline__ void udpv6_err ( struct sk_buff * skb , struct inet6_skb_parm * opt , u8 type , u8 code , int offset , __be32 info ) {\n __udp6_lib_err ( skb , opt , type , code , offset , info , & udp_table ) ;\n }", "hash": 7889142355347191490, "project": "debian", "size": 3, "target": 0, "idx": 1516}
{"code": "void __udp6_lib_err ( struct sk_buff * skb , struct inet6_skb_parm * opt , u8 type , u8 code , int offset , __be32 info , struct udp_table * udptable ) {\n struct ipv6_pinfo * np ;\n struct ipv6hdr * hdr = ( struct ipv6hdr * ) skb -> data ;\n struct in6_addr * saddr = & hdr -> saddr ;\n struct in6_addr * daddr = & hdr -> daddr ;\n struct udphdr * uh = ( struct udphdr * ) ( skb -> data + offset ) ;\n struct sock * sk ;\n int err ;\n sk = __udp6_lib_lookup ( dev_net ( skb -> dev ) , daddr , uh -> dest , saddr , uh -> source , inet6_iif ( skb ) , udptable ) ;\n if ( sk == NULL ) return ;\n np = inet6_sk ( sk ) ;\n if ( ! icmpv6_err_convert ( type , code , & err ) && ! np -> recverr ) goto out ;\n if ( sk -> sk_state != TCP_ESTABLISHED && ! np -> recverr ) goto out ;\n if ( np -> recverr ) ipv6_icmp_error ( sk , skb , err , uh -> dest , ntohl ( info ) , ( u8 * ) ( uh + 1 ) ) ;\n sk -> sk_err = err ;\n sk -> sk_error_report ( sk ) ;\n out : sock_put ( sk ) ;\n }", "hash": 7889142355347191490, "project": "debian", "size": 18, "target": 0, "idx": 1522}
{"code": "static int udp6_ufo_send_check ( struct sk_buff * skb ) {\n struct ipv6hdr * ipv6h ;\n struct udphdr * uh ;\n if ( ! pskb_may_pull ( skb , sizeof ( * uh ) ) ) return - EINVAL ;\n ipv6h = ipv6_hdr ( skb ) ;\n uh = udp_hdr ( skb ) ;\n uh -> check = ~ csum_ipv6_magic ( & ipv6h -> saddr , & ipv6h -> daddr , skb -> len , IPPROTO_UDP , 0 ) ;\n skb -> csum_start = skb_transport_header ( skb ) - skb -> head ;\n skb -> csum_offset = offsetof ( struct udphdr , check ) ;\n skb -> ip_summed = CHECKSUM_PARTIAL ;\n return 0 ;\n }", "hash": 7889142355347191490, "project": "debian", "size": 12, "target": 0, "idx": 1528}
{"code": "static jpc_enc_cblk_t * cblk_create ( jpc_enc_cblk_t * cblk , jpc_enc_cp_t * cp , jpc_enc_prc_t * prc ) {\n jpc_enc_band_t * band ;\n uint_fast32_t cblktlx ;\n uint_fast32_t cblktly ;\n uint_fast32_t cblkbrx ;\n uint_fast32_t cblkbry ;\n jpc_enc_rlvl_t * rlvl ;\n uint_fast32_t cblkxind ;\n uint_fast32_t cblkyind ;\n uint_fast32_t cblkno ;\n uint_fast32_t tlcblktlx ;\n uint_fast32_t tlcblktly ;\n cblkno = cblk - prc -> cblks ;\n cblkxind = cblkno % prc -> numhcblks ;\n cblkyind = cblkno / prc -> numhcblks ;\n rlvl = prc -> band -> rlvl ;\n cblk -> prc = prc ;\n cblk -> numpasses = 0 ;\n cblk -> passes = 0 ;\n cblk -> numencpasses = 0 ;\n cblk -> numimsbs = 0 ;\n cblk -> numlenbits = 0 ;\n cblk -> stream = 0 ;\n cblk -> mqenc = 0 ;\n cblk -> flags = 0 ;\n cblk -> numbps = 0 ;\n cblk -> curpass = 0 ;\n cblk -> data = 0 ;\n cblk -> savedcurpass = 0 ;\n cblk -> savednumlenbits = 0 ;\n cblk -> savednumencpasses = 0 ;\n band = prc -> band ;\n tlcblktlx = JPC_FLOORTOMULTPOW2 ( prc -> tlx , rlvl -> cblkwidthexpn ) ;\n tlcblktly = JPC_FLOORTOMULTPOW2 ( prc -> tly , rlvl -> cblkheightexpn ) ;\n cblktlx = JAS_MAX ( tlcblktlx + ( cblkxind << rlvl -> cblkwidthexpn ) , prc -> tlx ) ;\n cblktly = JAS_MAX ( tlcblktly + ( cblkyind << rlvl -> cblkheightexpn ) , prc -> tly ) ;\n cblkbrx = JAS_MIN ( tlcblktlx + ( ( cblkxind + 1 ) << rlvl -> cblkwidthexpn ) , prc -> brx ) ;\n cblkbry = JAS_MIN ( tlcblktly + ( ( cblkyind + 1 ) << rlvl -> cblkheightexpn ) , prc -> bry ) ;\n assert ( cblktlx < cblkbrx && cblktly < cblkbry ) ;\n if ( ! ( cblk -> data = jas_seq2d_create ( 0 , 0 , 0 , 0 ) ) ) {\n goto error ;\n }\n jas_seq2d_bindsub ( cblk -> data , band -> data , cblktlx , cblktly , cblkbrx , cblkbry ) ;\n return cblk ;\n error : cblk_destroy ( cblk ) ;\n return 0 ;\n }", "hash": -8721757784652752372, "project": "debian", "size": 47, "target": 0, "idx": 1543}
{"code": "static uint_fast32_t jpc_abstorelstepsize ( jpc_fix_t absdelta , int scaleexpn ) {\n int p ;\n uint_fast32_t mant ;\n uint_fast32_t expn ;\n int n ;\n if ( absdelta < 0 ) {\n abort ( ) ;\n }\n p = jpc_firstone ( absdelta ) - JPC_FIX_FRACBITS ;\n n = 11 - jpc_firstone ( absdelta ) ;\n mant = ( ( n < 0 ) ? ( absdelta >> ( - n ) ) : ( absdelta << n ) ) & 0x7ff ;\n expn = scaleexpn - p ;\n if ( scaleexpn < p ) {\n abort ( ) ;\n }\n return JPC_QCX_EXPN ( expn ) | JPC_QCX_MANT ( mant ) ;\n }", "hash": -8721757784652752372, "project": "debian", "size": 17, "target": 0, "idx": 1566}
{"code": "static void cblk_destroy ( jpc_enc_cblk_t * cblk ) {\n uint_fast16_t passno ;\n jpc_enc_pass_t * pass ;\n if ( cblk -> passes ) {\n for ( passno = 0 , pass = cblk -> passes ;\n passno < cblk -> numpasses ;\n ++ passno , ++ pass ) {\n pass_destroy ( pass ) ;\n }\n jas_free ( cblk -> passes ) ;\n cblk -> passes = NULL ;\n }\n if ( cblk -> stream ) {\n jas_stream_close ( cblk -> stream ) ;\n cblk -> stream = NULL ;\n }\n if ( cblk -> mqenc ) {\n jpc_mqenc_destroy ( cblk -> mqenc ) ;\n cblk -> mqenc = NULL ;\n }\n if ( cblk -> data ) {\n jas_seq2d_destroy ( cblk -> data ) ;\n cblk -> data = NULL ;\n }\n if ( cblk -> flags ) {\n jas_seq2d_destroy ( cblk -> flags ) ;\n cblk -> flags = NULL ;\n }\n }", "hash": -8721757784652752372, "project": "debian", "size": 29, "target": 0, "idx": 1568}
{"code": "static u_short create_keyword_scanner ( void ) {\n u_short scanner ;\n u_short i ;\n sst_highwater = 1 ;\n scanner = 0 ;\n for ( i = 0 ;\n i < COUNTOF ( ntp_keywords ) ;\n i ++ ) {\n current_keyword = ntp_keywords [ i ] . key ;\n scanner = create_scan_states ( ntp_keywords [ i ] . key , ntp_keywords [ i ] . token , ntp_keywords [ i ] . followedby , scanner ) ;\n }\n return scanner ;\n }", "hash": 4496746249504396521, "project": "debian", "size": 13, "target": 0, "idx": 1585}
{"code": "static int dissect_ber_sq_of ( gboolean implicit_tag , gint32 type , asn1_ctx_t * actx , proto_tree * parent_tree , tvbuff_t * tvb , int offset , gint32 min_len , gint32 max_len , const ber_sequence_t * seq , gint hf_id , gint ett_id ) {\n gint8 classx ;\n gboolean pcx , ind = FALSE , ind_field ;\n gint32 tagx ;\n guint32 lenx ;\n proto_tree * tree = parent_tree ;\n proto_item * item = NULL ;\n proto_item * causex ;\n int cnt , hoffsetx , end_offset ;\n gboolean have_cnt ;\n header_field_info * hfi ;\n tvbuff_t * next_tvb ;\n # ifdef DEBUG_BER_SQ_OF {\n const char * name ;\n header_field_info * hfinfo ;\n if ( hf_id >= 0 ) {\n hfinfo = proto_registrar_get_nth ( hf_id ) ;\n name = hfinfo -> name ;\n }\n else {\n name = \"unnamed\" ;\n }\n if ( tvb_reported_length_remaining ( tvb , offset ) > 3 ) {\n printf ( \"SQ OF dissect_ber_sq_of(%s) entered implicit_tag:%d offset:%d len:%d %02x:%02x:%02x\\n\" , name , implicit_tag , offset , tvb_reported_length_remaining ( tvb , offset ) , tvb_get_guint8 ( tvb , offset ) , tvb_get_guint8 ( tvb , offset + 1 ) , tvb_get_guint8 ( tvb , offset + 2 ) ) ;\n }\n else {\n printf ( \"SQ OF dissect_ber_sq_of(%s) entered\\n\" , name ) ;\n }\n }\n # endif if ( ! implicit_tag ) {\n hoffsetx = offset ;\n offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & classx , & pcx , & tagx ) ;\n offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & lenx , & ind ) ;\n end_offset = offset + lenx ;\n if ( ( classx != BER_CLASS_APP ) && ( classx != BER_CLASS_PRI ) ) {\n if ( ! pcx || ( ! implicit_tag && ( ( classx != BER_CLASS_UNI ) || ( tagx != type ) ) ) ) {\n tvb_ensure_bytes_exist ( tvb , hoffsetx , 2 ) ;\n causex = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , lenx , ( type == BER_UNI_TAG_SEQUENCE ) ? \"set_of_expected\" : \"sequence_of_expected\" , \"%s Of expected but class:%s(%d) %s tag:%d was unexpected\" , ( type == BER_UNI_TAG_SEQUENCE ) ? \"Set\" : \"Sequence\" , val_to_str_const ( classx , ber_class_codes , \"Unknown\" ) , classx , pcx ? ber_pc_codes_short . true_string : ber_pc_codes_short . false_string , tagx ) ;\n if ( type == BER_UNI_TAG_SEQUENCE ) {\n expert_add_info_format ( actx -> pinfo , causex , & ei_ber_expected_set , \"BER Error: Set Of expected\" ) ;\n }\n else {\n expert_add_info_format ( actx -> pinfo , causex , & ei_ber_expected_sequence , \"BER Error: Sequence Of expected\" ) ;\n }\n if ( decode_unexpected ) {\n proto_tree * unknown_tree = proto_item_add_subtree ( causex , ett_ber_unknown ) ;\n dissect_unknown_ber ( actx -> pinfo , tvb , hoffsetx , unknown_tree ) ;\n }\n return end_offset ;\n }\n }\n }\n else {\n lenx = tvb_reported_length_remaining ( tvb , offset ) ;\n end_offset = offset + lenx ;\n }\n cnt = 0 ;\n have_cnt = FALSE ;\n hoffsetx = offset ;\n if ( tvb_captured_length_remaining ( tvb , offset ) == tvb_reported_length_remaining ( tvb , offset ) ) {\n have_cnt = TRUE ;\n while ( offset < end_offset ) {\n guint32 len ;\n gint s_offset ;\n s_offset = offset ;\n if ( ( tvb_get_guint8 ( tvb , offset ) == 0 ) && ( tvb_get_guint8 ( tvb , offset + 1 ) == 0 ) ) {\n break ;\n }\n offset = get_ber_identifier ( tvb , offset , NULL , NULL , NULL ) ;\n offset = get_ber_length ( tvb , offset , & len , & ind ) ;\n offset += len ;\n cnt ++ ;\n if ( offset <= s_offset ) {\n have_cnt = FALSE ;\n cnt = 0 ;\n break ;\n }\n }\n }\n offset = hoffsetx ;\n if ( hf_id >= 0 ) {\n hfi = proto_registrar_get_nth ( hf_id ) ;\n if ( parent_tree ) {\n if ( hfi -> type == FT_NONE ) {\n item = proto_tree_add_item ( parent_tree , hf_id , tvb , offset , lenx , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( item , \":\" ) ;\n }\n else {\n if ( have_cnt ) {\n item = proto_tree_add_uint ( parent_tree , hf_id , tvb , offset , lenx , cnt ) ;\n proto_item_append_text ( item , ( cnt == 1 ) ? \" item\" : \" items\" ) ;\n }\n else item = proto_tree_add_uint_format_value ( parent_tree , hf_id , tvb , offset , lenx , cnt , \"unknown number of items\" ) ;\n }\n tree = proto_item_add_subtree ( item , ett_id ) ;\n ber_check_items ( cnt , min_len , max_len , actx , item ) ;\n }\n }\n while ( offset < end_offset ) {\n gint8 ber_class ;\n gboolean pc ;\n gint32 tag ;\n guint32 len ;\n int eoffset ;\n int hoffset ;\n proto_item * cause ;\n gboolean imp_tag ;\n hoffset = offset ;\n if ( ( tvb_get_guint8 ( tvb , offset ) == 0 ) && ( tvb_get_guint8 ( tvb , offset + 1 ) == 0 ) ) {\n if ( show_internal_ber_fields ) {\n proto_tree_add_item ( tree , hf_ber_seq_of_eoc , tvb , hoffset , end_offset - hoffset , ENC_NA ) ;\n }\n return offset + 2 ;\n }\n offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag ) ;\n offset = get_ber_length ( tvb , offset , & len , & ind_field ) ;\n eoffset = offset + len ;\n if ( eoffset <= hoffset ) THROW ( ReportedBoundsError ) ;\n if ( ( ber_class == BER_CLASS_UNI ) && ( tag == BER_UNI_TAG_EOC ) ) {\n hoffset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL , NULL ) ;\n dissect_ber_length ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL ) ;\n return eoffset ;\n }\n if ( seq -> ber_class != BER_CLASS_ANY ) {\n if ( ( seq -> ber_class != ber_class ) || ( seq -> tag != tag ) ) {\n if ( ! ( seq -> flags & BER_FLAGS_NOTCHKTAG ) ) {\n if ( seq -> ber_class == BER_CLASS_UNI ) {\n cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , \"wrong_field\" , \"Wrong field in SQ OF expected class:%s(%d) tag:%d(%s) but found class:%s(%d) tag:%d\" , val_to_str_const ( seq -> ber_class , ber_class_codes , \"Unknown\" ) , seq -> ber_class , seq -> tag , val_to_str_ext_const ( seq -> tag , & ber_uni_tag_codes_ext , \"Unknown\" ) , val_to_str_const ( ber_class , ber_class_codes , \"Unknown\" ) , ber_class , tag ) ;\n }\n else {\n cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , \"wrong_field\" , \"Wrong field in SQ OF expected class:%s(%d) tag:%d but found class:%s(%d) tag:%d\" , val_to_str_const ( seq -> ber_class , ber_class_codes , \"Unknown\" ) , seq -> ber_class , seq -> tag , val_to_str_const ( ber_class , ber_class_codes , \"Unknown\" ) , ber_class , tag ) ;\n }\n expert_add_info_format ( actx -> pinfo , cause , & ei_ber_sequence_field_wrong , \"BER Error: Wrong field in SEQUENCE OF\" ) ;\n if ( decode_unexpected ) {\n proto_tree * unknown_tree = proto_item_add_subtree ( cause , ett_ber_unknown ) ;\n dissect_unknown_ber ( actx -> pinfo , tvb , hoffset , unknown_tree ) ;\n }\n offset = eoffset ;\n continue ;\n }\n }\n }\n if ( ! ( seq -> flags & BER_FLAGS_NOOWNTAG ) && ! ( seq -> flags & BER_FLAGS_IMPLTAG ) ) {\n hoffset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL , NULL ) ;\n hoffset = dissect_ber_length ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL ) ;\n }\n if ( ( seq -> flags == BER_FLAGS_IMPLTAG ) && ( seq -> ber_class == BER_CLASS_CON ) ) {\n hoffset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL , NULL ) ;\n hoffset = dissect_ber_length ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL ) ;\n }\n next_tvb = ber_tvb_new_subset_length ( tvb , hoffset , eoffset - hoffset ) ;\n imp_tag = FALSE ;\n if ( seq -> flags == BER_FLAGS_IMPLTAG ) imp_tag = TRUE ;\n seq -> func ( imp_tag , next_tvb , 0 , actx , tree , * seq -> p_id ) ;\n cnt ++ ;\n offset = eoffset ;\n }\n if ( offset != end_offset ) {\n tvb_ensure_bytes_exist ( tvb , offset - 2 , 2 ) ;\n causex = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset - 2 , 2 , \"illegal_length\" , \"%s Of ate %d too many bytes\" , ( type == BER_UNI_TAG_SEQUENCE ) ? \"Set\" : \"Sequence\" , offset - end_offset ) ;\n expert_add_info_format ( actx -> pinfo , causex , & ei_ber_error_length , \"BER Error:too many byte in %s\" , ( type == BER_UNI_TAG_SEQUENCE ) ? \"Set\" : \"Sequence\" ) ;\n }\n return end_offset ;\n }", "hash": -7434014980763120366, "project": "debian", "size": 164, "target": 0, "idx": 1594}
{"code": "static int dissect_ber_external_U ( gboolean implicit_tag , tvbuff_t * tvb , int offset , asn1_ctx_t * actx _U_ , proto_tree * tree , int hf_index _U_ ) {\n offset = dissect_ber_sequence ( implicit_tag , actx , tree , tvb , offset , external_U_sequence , hf_index , ett_ber_EXTERNAL ) ;\n return offset ;\n }", "hash": -7434014980763120366, "project": "debian", "size": 4, "target": 0, "idx": 1628}
{"code": "static void ber_add_syntax_name ( gpointer key , gpointer value _U_ , gpointer user_data ) {\n guint * i = ( guint * ) user_data ;\n if ( * i < MAX_SYNTAX_NAMES ) {\n syntax_names [ * i ] . value = * i ;\n syntax_names [ * i ] . strptr = ( const gchar * ) key ;\n ( * i ) ++ ;\n }\n }", "hash": -7434014980763120366, "project": "debian", "size": 8, "target": 0, "idx": 1642}
{"code": "int dissect_ber_set ( gboolean implicit_tag , asn1_ctx_t * actx , proto_tree * parent_tree , tvbuff_t * tvb , int offset , const ber_sequence_t * set , gint hf_id , gint ett_id ) {\n gint8 classx ;\n gboolean pcx , ind = 0 , ind_field , imp_tag = FALSE ;\n gint32 tagx ;\n guint32 lenx ;\n proto_tree * tree = parent_tree ;\n proto_item * item = NULL ;\n proto_item * cause ;\n int end_offset , s_offset ;\n int hoffset ;\n tvbuff_t * next_tvb ;\n guint32 mandatory_fields = 0 ;\n guint8 set_idx ;\n gboolean first_pass ;\n const ber_sequence_t * cset = NULL ;\n # define MAX_SET_ELEMENTS 32 s_offset = offset ;\n # ifdef DEBUG_BER {\n const char * name ;\n header_field_info * hfinfo ;\n if ( hf_id >= 0 ) {\n hfinfo = proto_registrar_get_nth ( hf_id ) ;\n name = hfinfo -> name ;\n }\n else {\n name = \"unnamed\" ;\n }\n if ( tvb_reported_length_remaining ( tvb , offset ) > 3 ) {\n printf ( \"SET dissect_ber_set(%s) entered offset:%d len:%d %02x:%02x:%02x\\n\" , name , offset , tvb_reported_length_remaining ( tvb , offset ) , tvb_get_guint8 ( tvb , offset ) , tvb_get_guint8 ( tvb , offset + 1 ) , tvb_get_guint8 ( tvb , offset + 2 ) ) ;\n }\n else {\n printf ( \"SET dissect_ber_set(%s) entered\\n\" , name ) ;\n }\n }\n # endif if ( ! implicit_tag ) {\n hoffset = offset ;\n offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & classx , & pcx , & tagx ) ;\n offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & lenx , & ind ) ;\n if ( ind ) {\n end_offset = offset + lenx - 2 ;\n }\n else {\n end_offset = offset + lenx ;\n }\n if ( ( classx != BER_CLASS_APP ) && ( classx != BER_CLASS_PRI ) ) {\n if ( ! pcx || ( ! implicit_tag && ( ( classx != BER_CLASS_UNI ) || ( tagx != BER_UNI_TAG_SET ) ) ) ) {\n tvb_ensure_bytes_exist ( tvb , hoffset , 2 ) ;\n cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , lenx , \"set_expected\" , \"SET expected but class:%s(%d) %s tag:%d was found\" , val_to_str_const ( classx , ber_class_codes , \"Unknown\" ) , classx , pcx ? ber_pc_codes_short . true_string : ber_pc_codes_short . false_string , tagx ) ;\n expert_add_info ( actx -> pinfo , cause , & ei_ber_expected_set ) ;\n if ( decode_unexpected ) {\n proto_tree * unknown_tree = proto_item_add_subtree ( cause , ett_ber_unknown ) ;\n dissect_unknown_ber ( actx -> pinfo , tvb , hoffset , unknown_tree ) ;\n }\n return end_offset ;\n }\n }\n }\n else {\n lenx = tvb_reported_length_remaining ( tvb , offset ) ;\n end_offset = offset + lenx ;\n }\n if ( hf_id >= 0 ) {\n if ( parent_tree ) {\n item = proto_tree_add_item ( parent_tree , hf_id , tvb , offset , lenx , ENC_BIG_ENDIAN ) ;\n tree = proto_item_add_subtree ( item , ett_id ) ;\n }\n }\n for ( set_idx = 0 ;\n ( cset = & set [ set_idx ] ) -> func && ( set_idx < MAX_SET_ELEMENTS ) ;\n set_idx ++ ) {\n if ( ! ( cset -> flags & BER_FLAGS_OPTIONAL ) ) mandatory_fields |= 1 << set_idx ;\n }\n while ( offset < end_offset ) {\n gint8 ber_class ;\n gboolean pc ;\n gint32 tag ;\n guint32 len ;\n int eoffset , count ;\n if ( ( tvb_get_guint8 ( tvb , offset ) == 0 ) && ( tvb_get_guint8 ( tvb , offset + 1 ) == 0 ) ) {\n if ( show_internal_ber_fields ) {\n proto_tree_add_item ( tree , hf_ber_seq_eoc , tvb , s_offset , offset + 2 , ENC_NA ) ;\n }\n return end_offset ;\n }\n hoffset = offset ;\n offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag ) ;\n offset = get_ber_length ( tvb , offset , & len , & ind_field ) ;\n eoffset = offset + len ;\n for ( first_pass = TRUE , cset = set , set_idx = 0 ;\n cset -> func || first_pass ;\n cset ++ , set_idx ++ ) {\n if ( ! cset -> func ) {\n first_pass = FALSE ;\n cset = set ;\n set_idx = 0 ;\n }\n if ( ( first_pass && ( ( cset -> ber_class == ber_class ) && ( cset -> tag == tag ) ) ) || ( ! first_pass && ( ( cset -> ber_class == BER_CLASS_ANY ) && ( cset -> tag == - 1 ) ) ) ) {\n if ( ! ( cset -> flags & BER_FLAGS_NOOWNTAG ) ) {\n hoffset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL , NULL ) ;\n hoffset = dissect_ber_length ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL ) ;\n next_tvb = ber_tvb_new_subset_length ( tvb , hoffset , eoffset - hoffset - ( 2 * ind_field ) ) ;\n }\n else {\n next_tvb = ber_tvb_new_subset_length ( tvb , hoffset , eoffset - hoffset ) ;\n }\n # if 0 if ( ( eoffset - hoffset ) > length_remaining ) {\n next_tvb = tvb_new_subset_remaining ( tvb , hoffset ) ;\n }\n else {\n }\n # endif # ifdef DEBUG_BER {\n const char * name ;\n header_field_info * hfinfo ;\n if ( hf_id >= 0 ) {\n hfinfo = proto_registrar_get_nth ( hf_id ) ;\n name = hfinfo -> name ;\n }\n else {\n name = \"unnamed\" ;\n }\n if ( tvb_reported_length_remaining ( next_tvb , 0 ) > 3 ) {\n printf ( \"SET dissect_ber_set(%s) calling subdissector offset:%d len:%d %02x:%02x:%02x\\n\" , name , offset , tvb_reported_length_remaining ( next_tvb , 0 ) , tvb_get_guint8 ( next_tvb , 0 ) , tvb_get_guint8 ( next_tvb , 1 ) , tvb_get_guint8 ( next_tvb , 2 ) ) ;\n }\n else {\n printf ( \"SET dissect_ber_set(%s) calling subdissector\\n\" , name ) ;\n }\n }\n # endif if ( next_tvb == NULL ) {\n THROW ( ReportedBoundsError ) ;\n }\n imp_tag = FALSE ;\n if ( ( cset -> flags & BER_FLAGS_IMPLTAG ) ) imp_tag = TRUE ;\n count = cset -> func ( imp_tag , next_tvb , 0 , actx , tree , * cset -> p_id ) ;\n if ( count || ( first_pass && ( ( len == 0 ) || ( ( ind_field == 1 ) && ( len == 2 ) ) ) ) ) {\n if ( set_idx < MAX_SET_ELEMENTS ) mandatory_fields &= ~ ( 1 << set_idx ) ;\n offset = eoffset ;\n if ( ! ( cset -> flags & BER_FLAGS_NOOWNTAG ) ) {\n if ( ind_field == 1 ) {\n if ( show_internal_ber_fields ) {\n proto_tree_add_item ( tree , hf_ber_set_field_eoc , tvb , offset , count , ENC_NA ) ;\n }\n }\n }\n break ;\n }\n }\n }\n if ( ! cset -> func ) {\n cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , \"unknown_field\" , \"Unknown field in SET class:%s(%d) tag:%d\" , val_to_str_const ( ber_class , ber_class_codes , \"Unknown\" ) , ber_class , tag ) ;\n expert_add_info ( actx -> pinfo , cause , & ei_ber_unknown_field_set ) ;\n if ( decode_unexpected ) {\n proto_tree * unknown_tree = proto_item_add_subtree ( cause , ett_ber_unknown ) ;\n dissect_unknown_ber ( actx -> pinfo , tvb , hoffset , unknown_tree ) ;\n }\n offset = eoffset ;\n }\n }\n if ( mandatory_fields ) {\n for ( set_idx = 0 ;\n ( cset = & set [ set_idx ] ) -> func && ( set_idx < MAX_SET_ELEMENTS ) ;\n set_idx ++ ) {\n if ( mandatory_fields & ( 1 << set_idx ) ) {\n cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , lenx , \"missing_field\" , \"Missing field in SET class:%s(%d) tag:%d expected\" , val_to_str_const ( cset -> ber_class , ber_class_codes , \"Unknown\" ) , cset -> ber_class , cset -> tag ) ;\n expert_add_info ( actx -> pinfo , cause , & ei_ber_missing_field_set ) ;\n }\n }\n }\n if ( offset != end_offset ) {\n tvb_ensure_bytes_exist ( tvb , offset - 2 , 2 ) ;\n cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset - 2 , 2 , \"illegal_length\" , \"SET ate %d too many bytes\" , offset - end_offset ) ;\n expert_add_info_format ( actx -> pinfo , cause , & ei_ber_error_length , \"BER Error: too many bytes in SET\" ) ;\n }\n if ( ind ) {\n end_offset += 2 ;\n if ( show_internal_ber_fields ) {\n proto_tree_add_item ( tree , hf_ber_set_eoc , tvb , end_offset - 2 , 2 , ENC_NA ) ;\n }\n }\n return end_offset ;\n }", "hash": -7434014980763120366, "project": "debian", "size": 179, "target": 0, "idx": 1667}
{"code": "void register_ber_oid_syntax ( const char * oid , const char * name , const char * syntax ) {\n if ( syntax && * syntax ) g_hash_table_insert ( syntax_table , ( gpointer ) g_strdup ( oid ) , ( gpointer ) g_strdup ( syntax ) ) ;\n if ( name && * name ) register_ber_oid_name ( oid , name ) ;\n }", "hash": -7434014980763120366, "project": "debian", "size": 4, "target": 0, "idx": 1669}
{"code": "static gboolean ber_decode_as_reset ( const char * name _U_ , const gpointer pattern _U_ ) {\n ber_decode_as ( NULL ) ;\n return FALSE ;\n }", "hash": -7434014980763120366, "project": "debian", "size": 4, "target": 0, "idx": 1675}
{"code": "static int pop_value ( i_ctx_t * i_ctx_p , ref * pvalue ) {\n if ( ! ref_stack_count ( & o_stack ) ) return_error ( gs_error_stackunderflow ) ;\n * pvalue = * ref_stack_index ( & o_stack , 0L ) ;\n return 0 ;\n }", "hash": -7670127399145950875, "project": "debian", "size": 5, "target": 0, "idx": 1707}
{"code": "void xps_parse_render_transform ( xps_document * doc , char * transform , fz_matrix * matrix ) {\n float args [ 6 ] ;\n char * s = transform ;\n int i ;\n args [ 0 ] = 1 ;\n args [ 1 ] = 0 ;\n args [ 2 ] = 0 ;\n args [ 3 ] = 1 ;\n args [ 4 ] = 0 ;\n args [ 5 ] = 0 ;\n for ( i = 0 ;\n i < 6 && * s ;\n i ++ ) {\n args [ i ] = fz_atof ( s ) ;\n while ( * s && * s != ',' ) s ++ ;\n if ( * s == ',' ) s ++ ;\n }\n matrix -> a = args [ 0 ] ;\n matrix -> b = args [ 1 ] ;\n matrix -> c = args [ 2 ] ;\n matrix -> d = args [ 3 ] ;\n matrix -> e = args [ 4 ] ;\n matrix -> f = args [ 5 ] ;\n }", "hash": 6573793021826676268, "project": "debian", "size": 24, "target": 0, "idx": 1742}
{"code": "static int count_commas ( char * s ) {\n int n = 0 ;\n while ( * s ) {\n if ( * s == ',' ) n ++ ;\n s ++ ;\n }\n return n ;\n }", "hash": 6573793021826676268, "project": "debian", "size": 8, "target": 0, "idx": 1749}
{"code": "static int cmp_stop ( const void * a , const void * b ) {\n const struct stop * astop = a ;\n const struct stop * bstop = b ;\n float diff = astop -> offset - bstop -> offset ;\n if ( diff < 0 ) return - 1 ;\n if ( diff > 0 ) return 1 ;\n return astop -> index - bstop -> index ;\n }", "hash": -9028269206303312561, "project": "debian", "size": 8, "target": 0, "idx": 1760}
{"code": "static int xps_parse_line_cap ( char * attr ) {\n if ( attr ) {\n if ( ! strcmp ( attr , \"Flat\" ) ) return 0 ;\n if ( ! strcmp ( attr , \"Round\" ) ) return 1 ;\n if ( ! strcmp ( attr , \"Square\" ) ) return 2 ;\n if ( ! strcmp ( attr , \"Triangle\" ) ) return 3 ;\n }\n return 0 ;\n }", "hash": -5927738579069082820, "project": "debian", "size": 9, "target": 0, "idx": 1765}
{"code": "void send_protected_args ( int fd , char * args [ ] ) {\n int i ;\n # ifdef ICONV_OPTION int convert = ic_send != ( iconv_t ) - 1 ;\n xbuf outbuf , inbuf ;\n if ( convert ) alloc_xbuf ( & outbuf , 1024 ) ;\n # endif for ( i = 0 ;\n args [ i ] ;\n i ++ ) {\n }\n args [ i ] = \"rsync\" ;\n if ( DEBUG_GTE ( CMD , 1 ) ) print_child_argv ( \"protected args:\" , args + i + 1 ) ;\n do {\n if ( ! args [ i ] [ 0 ] ) write_buf ( fd , \".\" , 2 ) ;\n # ifdef ICONV_OPTION else if ( convert ) {\n INIT_XBUF_STRLEN ( inbuf , args [ i ] ) ;\n iconvbufs ( ic_send , & inbuf , & outbuf , ICB_EXPAND_OUT | ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE | ICB_INIT ) ;\n outbuf . buf [ outbuf . len ] = '\\0' ;\n write_buf ( fd , outbuf . buf , outbuf . len + 1 ) ;\n outbuf . len = 0 ;\n }\n # endif else write_buf ( fd , args [ i ] , strlen ( args [ i ] ) + 1 ) ;\n }\n while ( args [ ++ i ] ) ;\n write_byte ( fd , 0 ) ;\n # ifdef ICONV_OPTION if ( convert ) free ( outbuf . buf ) ;\n # endif }", "hash": 7198560023137364337, "project": "debian", "size": 26, "target": 0, "idx": 1786}
{"code": "static inline void decode8x8 ( GetBitContext * gb , uint8_t * dst , int linesize , DSPContext * dsp ) {\n int i , j , v [ 2 ] ;\n switch ( get_bits ( gb , 2 ) ) {\n case 1 : v [ 0 ] = get_bits ( gb , 8 ) ;\n dsp -> fill_block_tab [ 1 ] ( dst , v [ 0 ] , linesize , 8 ) ;\n break ;\n case 2 : v [ 0 ] = get_bits ( gb , 8 ) ;\n v [ 1 ] = get_bits ( gb , 8 ) ;\n for ( j = 7 ;\n j >= 0 ;\n j -- ) for ( i = 0 ;\n i < 8 ;\n i ++ ) dst [ j * linesize + i ] = v [ get_bits1 ( gb ) ] ;\n break ;\n case 3 : for ( j = 0 ;\n j < 8 ;\n j += 4 ) for ( i = 0 ;\n i < 8 ;\n i += 4 ) decode4x4 ( gb , dst + j * linesize + i , linesize ) ;\n }\n }", "hash": 9040629826477849200, "project": "debian", "size": 21, "target": 0, "idx": 1803}
{"code": "static int aura_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) {\n AVFrame * frame = data ;\n uint8_t * Y , * U , * V ;\n uint8_t val ;\n int x , y , ret ;\n const uint8_t * buf = pkt -> data ;\n const int8_t * delta_table = ( const int8_t * ) buf + 16 ;\n if ( pkt -> size != 48 + avctx -> height * avctx -> width ) {\n av_log ( avctx , AV_LOG_ERROR , \"got a buffer with %d bytes when %d were expected\\n\" , pkt -> size , 48 + avctx -> height * avctx -> width ) ;\n return AVERROR_INVALIDDATA ;\n }\n buf += 48 ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n Y = frame -> data [ 0 ] ;\n U = frame -> data [ 1 ] ;\n V = frame -> data [ 2 ] ;\n for ( y = 0 ;\n y < avctx -> height ;\n y ++ ) {\n val = * buf ++ ;\n U [ 0 ] = val & 0xF0 ;\n Y [ 0 ] = val << 4 ;\n val = * buf ++ ;\n V [ 0 ] = val & 0xF0 ;\n Y [ 1 ] = Y [ 0 ] + delta_table [ val & 0xF ] ;\n Y += 2 ;\n U ++ ;\n V ++ ;\n for ( x = 1 ;\n x < ( avctx -> width >> 1 ) ;\n x ++ ) {\n val = * buf ++ ;\n U [ 0 ] = U [ - 1 ] + delta_table [ val >> 4 ] ;\n Y [ 0 ] = Y [ - 1 ] + delta_table [ val & 0xF ] ;\n val = * buf ++ ;\n V [ 0 ] = V [ - 1 ] + delta_table [ val >> 4 ] ;\n Y [ 1 ] = Y [ 0 ] + delta_table [ val & 0xF ] ;\n Y += 2 ;\n U ++ ;\n V ++ ;\n }\n Y += frame -> linesize [ 0 ] - avctx -> width ;\n U += frame -> linesize [ 1 ] - ( avctx -> width >> 1 ) ;\n V += frame -> linesize [ 2 ] - ( avctx -> width >> 1 ) ;\n }\n * got_frame = 1 ;\n return pkt -> size ;\n }", "hash": 6984172841296431440, "project": "debian", "size": 51, "target": 0, "idx": 1804}
{"code": "static inline void idx_to_quant ( MPCContext * c , GetBitContext * gb , int idx , int * dst ) {\n int i , i1 , t ;\n switch ( idx ) {\n case - 1 : for ( i = 0 ;\n i < SAMPLES_PER_BAND ;\n i ++ ) {\n * dst ++ = ( av_lfg_get ( & c -> rnd ) & 0x3FC ) - 510 ;\n }\n break ;\n case 1 : i1 = get_bits1 ( gb ) ;\n for ( i = 0 ;\n i < SAMPLES_PER_BAND / 3 ;\n i ++ ) {\n t = get_vlc2 ( gb , quant_vlc [ 0 ] [ i1 ] . table , 9 , 2 ) ;\n * dst ++ = mpc7_idx30 [ t ] ;\n * dst ++ = mpc7_idx31 [ t ] ;\n * dst ++ = mpc7_idx32 [ t ] ;\n }\n break ;\n case 2 : i1 = get_bits1 ( gb ) ;\n for ( i = 0 ;\n i < SAMPLES_PER_BAND / 2 ;\n i ++ ) {\n t = get_vlc2 ( gb , quant_vlc [ 1 ] [ i1 ] . table , 9 , 2 ) ;\n * dst ++ = mpc7_idx50 [ t ] ;\n * dst ++ = mpc7_idx51 [ t ] ;\n }\n break ;\n case 3 : case 4 : case 5 : case 6 : case 7 : i1 = get_bits1 ( gb ) ;\n for ( i = 0 ;\n i < SAMPLES_PER_BAND ;\n i ++ ) * dst ++ = get_vlc2 ( gb , quant_vlc [ idx - 1 ] [ i1 ] . table , 9 , 2 ) - mpc7_quant_vlc_off [ idx - 1 ] ;\n break ;\n case 8 : case 9 : case 10 : case 11 : case 12 : case 13 : case 14 : case 15 : case 16 : case 17 : t = ( 1 << ( idx - 2 ) ) - 1 ;\n for ( i = 0 ;\n i < SAMPLES_PER_BAND ;\n i ++ ) * dst ++ = get_bits ( gb , idx - 1 ) - t ;\n break ;\n default : return ;\n }\n }", "hash": -482717283558482293, "project": "debian", "size": 41, "target": 0, "idx": 1822}
{"code": "int ff_h263_get_gob_height ( MpegEncContext * s ) {\n if ( s -> height <= 400 ) return 1 ;\n else if ( s -> height <= 800 ) return 2 ;\n else return 4 ;\n }", "hash": 4445816241987236477, "project": "debian", "size": 5, "target": 0, "idx": 1827}
{"code": "static YuvPixel mp_get_yuv_from_rgb ( MotionPixelsContext * mp , int x , int y ) {\n int color ;\n color = * ( uint16_t * ) & mp -> frame . data [ 0 ] [ y * mp -> frame . linesize [ 0 ] + x * 2 ] ;\n return mp_rgb_yuv_table [ color ] ;\n }", "hash": -1409980668468066833, "project": "debian", "size": 5, "target": 0, "idx": 1831}
{"code": "static int read_colors ( GetBitContext * gb , Bundle * b , BinkContext * c ) {\n int t , sign , v ;\n const uint8_t * dec_end ;\n CHECK_READ_VAL ( gb , b , t ) ;\n dec_end = b -> cur_dec + t ;\n if ( dec_end > b -> data_end ) {\n av_log ( c -> avctx , AV_LOG_ERROR , \"Too many color values\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( get_bits1 ( gb ) ) {\n c -> col_lastval = GET_HUFF ( gb , c -> col_high [ c -> col_lastval ] ) ;\n v = GET_HUFF ( gb , b -> tree ) ;\n v = ( c -> col_lastval << 4 ) | v ;\n if ( c -> version < 'i' ) {\n sign = ( ( int8_t ) v ) >> 7 ;\n v = ( ( v & 0x7F ) ^ sign ) - sign ;\n v += 0x80 ;\n }\n memset ( b -> cur_dec , v , t ) ;\n b -> cur_dec += t ;\n }\n else {\n while ( b -> cur_dec < dec_end ) {\n c -> col_lastval = GET_HUFF ( gb , c -> col_high [ c -> col_lastval ] ) ;\n v = GET_HUFF ( gb , b -> tree ) ;\n v = ( c -> col_lastval << 4 ) | v ;\n if ( c -> version < 'i' ) {\n sign = ( ( int8_t ) v ) >> 7 ;\n v = ( ( v & 0x7F ) ^ sign ) - sign ;\n v += 0x80 ;\n }\n * b -> cur_dec ++ = v ;\n }\n }\n return 0 ;\n }", "hash": -7131177824150194183, "project": "debian", "size": 36, "target": 0, "idx": 1854}
{"code": "static float get_float ( GetBitContext * gb ) {\n int power = get_bits ( gb , 5 ) ;\n float f = ldexpf ( get_bits_long ( gb , 23 ) , power - 23 ) ;\n if ( get_bits1 ( gb ) ) f = - f ;\n return f ;\n }", "hash": -7456613930747243098, "project": "debian", "size": 6, "target": 0, "idx": 1907}
{"code": "static inline int tm2_read_header ( TM2Context * ctx , const uint8_t * buf ) {\n uint32_t magic = AV_RL32 ( buf ) ;\n switch ( magic ) {\n case TM2_OLD_HEADER_MAGIC : av_log_missing_feature ( ctx -> avctx , \"TM2 old header\" , 1 ) ;\n return 0 ;\n case TM2_NEW_HEADER_MAGIC : return 0 ;\n default : av_log ( ctx -> avctx , AV_LOG_ERROR , \"Not a TM2 header: 0x%08X\\n\" , magic ) ;\n return AVERROR_INVALIDDATA ;\n }\n }", "hash": -5459605226342014540, "project": "debian", "size": 10, "target": 0, "idx": 1908}
{"code": "static inline void tm2_high_chroma ( int * data , int stride , int * last , int * CD , int * deltas ) {\n int i , j ;\n for ( j = 0 ;\n j < 2 ;\n j ++ ) {\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n CD [ j ] += deltas [ i + j * 2 ] ;\n last [ i ] += CD [ j ] ;\n data [ i ] = last [ i ] ;\n }\n data += stride ;\n }\n }", "hash": -5459605226342014540, "project": "debian", "size": 15, "target": 0, "idx": 1910}
{"code": "static inline int GET_TOK ( TM2Context * ctx , int type ) {\n if ( ctx -> tok_ptrs [ type ] >= ctx -> tok_lens [ type ] ) {\n av_log ( ctx -> avctx , AV_LOG_ERROR , \"Read token from stream %i out of bounds (%i>=%i)\\n\" , type , ctx -> tok_ptrs [ type ] , ctx -> tok_lens [ type ] ) ;\n return 0 ;\n }\n if ( type <= TM2_MOT ) return ctx -> deltas [ type ] [ ctx -> tokens [ type ] [ ctx -> tok_ptrs [ type ] ++ ] ] ;\n return ctx -> tokens [ type ] [ ctx -> tok_ptrs [ type ] ++ ] ;\n }", "hash": -5459605226342014540, "project": "debian", "size": 8, "target": 0, "idx": 1922}
{"code": "static inline void tm2_med_res_block ( TM2Context * ctx , AVFrame * pic , int bx , int by ) {\n int i ;\n int deltas [ 16 ] ;\n TM2_INIT_POINTERS ( ) ;\n deltas [ 0 ] = GET_TOK ( ctx , TM2_C_LO ) ;\n deltas [ 1 ] = deltas [ 2 ] = deltas [ 3 ] = 0 ;\n tm2_low_chroma ( U , Ustride , clast , ctx -> CD , deltas , bx ) ;\n deltas [ 0 ] = GET_TOK ( ctx , TM2_C_LO ) ;\n deltas [ 1 ] = deltas [ 2 ] = deltas [ 3 ] = 0 ;\n tm2_low_chroma ( V , Vstride , clast + 2 , ctx -> CD + 2 , deltas , bx ) ;\n for ( i = 0 ;\n i < 16 ;\n i ++ ) deltas [ i ] = GET_TOK ( ctx , TM2_L_HI ) ;\n tm2_apply_deltas ( ctx , Y , Ystride , deltas , last ) ;\n }", "hash": -5459605226342014540, "project": "debian", "size": 15, "target": 0, "idx": 1923}
{"code": "static inline int tm2_get_token ( GetBitContext * gb , TM2Codes * code ) {\n int val ;\n val = get_vlc2 ( gb , code -> vlc . table , code -> bits , 1 ) ;\n return code -> recode [ val ] ;\n }", "hash": -5459605226342014540, "project": "debian", "size": 5, "target": 0, "idx": 1924}
{"code": "static int tm2_read_tree ( TM2Context * ctx , uint32_t prefix , int length , TM2Huff * huff ) {\n int ret ;\n if ( length > huff -> max_bits ) {\n av_log ( ctx -> avctx , AV_LOG_ERROR , \"Tree exceeded its given depth (%i)\\n\" , huff -> max_bits ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ! get_bits1 ( & ctx -> gb ) ) {\n if ( length == 0 ) {\n length = 1 ;\n }\n if ( huff -> num >= huff -> max_num ) {\n av_log ( ctx -> avctx , AV_LOG_DEBUG , \"Too many literals\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n huff -> nums [ huff -> num ] = get_bits_long ( & ctx -> gb , huff -> val_bits ) ;\n huff -> bits [ huff -> num ] = prefix ;\n huff -> lens [ huff -> num ] = length ;\n huff -> num ++ ;\n return 0 ;\n }\n else {\n if ( ( ret = tm2_read_tree ( ctx , prefix << 1 , length + 1 , huff ) ) < 0 ) return ret ;\n if ( ( ret = tm2_read_tree ( ctx , ( prefix << 1 ) | 1 , length + 1 , huff ) ) < 0 ) return ret ;\n }\n return 0 ;\n }", "hash": -5459605226342014540, "project": "debian", "size": 26, "target": 0, "idx": 1925}
{"code": "static int decode_cabac_mb_mvd ( H264Context * h , int ctxbase , int amvd , int * mvda ) {\n int mvd ;\n if ( ! get_cabac ( & h -> cabac , & h -> cabac_state [ ctxbase + ( ( amvd - 3 ) >> ( INT_BIT - 1 ) ) + ( ( amvd - 33 ) >> ( INT_BIT - 1 ) ) + 2 ] ) ) {\n * mvda = 0 ;\n return 0 ;\n }\n mvd = 1 ;\n ctxbase += 3 ;\n while ( mvd < 9 && get_cabac ( & h -> cabac , & h -> cabac_state [ ctxbase ] ) ) {\n if ( mvd < 4 ) ctxbase ++ ;\n mvd ++ ;\n }\n if ( mvd >= 9 ) {\n int k = 3 ;\n while ( get_cabac_bypass ( & h -> cabac ) ) {\n mvd += 1 << k ;\n k ++ ;\n if ( k > 24 ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"overflow in decode_cabac_mb_mvd\\n\" ) ;\n return INT_MIN ;\n }\n }\n while ( k -- ) {\n mvd += get_cabac_bypass ( & h -> cabac ) << k ;\n }\n * mvda = mvd < 70 ? mvd : 70 ;\n }\n else * mvda = mvd ;\n return get_cabac_bypass_sign ( & h -> cabac , - mvd ) ;\n }", "hash": -4456702502726364053, "project": "debian", "size": 30, "target": 0, "idx": 1940}
{"code": "static int16_t * wmv2_pred_motion ( Wmv2Context * w , int * px , int * py ) {\n MpegEncContext * const s = & w -> s ;\n int xy , wrap , diff , type ;\n int16_t * A , * B , * C , * mot_val ;\n wrap = s -> b8_stride ;\n xy = s -> block_index [ 0 ] ;\n mot_val = s -> current_picture . motion_val [ 0 ] [ xy ] ;\n A = s -> current_picture . motion_val [ 0 ] [ xy - 1 ] ;\n B = s -> current_picture . motion_val [ 0 ] [ xy - wrap ] ;\n C = s -> current_picture . motion_val [ 0 ] [ xy + 2 - wrap ] ;\n if ( s -> mb_x && ! s -> first_slice_line && ! s -> mspel && w -> top_left_mv_flag ) diff = FFMAX ( FFABS ( A [ 0 ] - B [ 0 ] ) , FFABS ( A [ 1 ] - B [ 1 ] ) ) ;\n else diff = 0 ;\n if ( diff >= 8 ) type = get_bits1 ( & s -> gb ) ;\n else type = 2 ;\n if ( type == 0 ) {\n * px = A [ 0 ] ;\n * py = A [ 1 ] ;\n }\n else if ( type == 1 ) {\n * px = B [ 0 ] ;\n * py = B [ 1 ] ;\n }\n else {\n if ( s -> first_slice_line ) {\n * px = A [ 0 ] ;\n * py = A [ 1 ] ;\n }\n else {\n * px = mid_pred ( A [ 0 ] , B [ 0 ] , C [ 0 ] ) ;\n * py = mid_pred ( A [ 1 ] , B [ 1 ] , C [ 1 ] ) ;\n }\n }\n return mot_val ;\n }", "hash": 6511303611138191176, "project": "debian", "size": 34, "target": 0, "idx": 1955}
{"code": "static inline int wmv2_decode_inter_block ( Wmv2Context * w , int16_t * block , int n , int cbp ) {\n MpegEncContext * const s = & w -> s ;\n static const int sub_cbp_table [ 3 ] = {\n 2 , 3 , 1 }\n ;\n int sub_cbp ;\n if ( ! cbp ) {\n s -> block_last_index [ n ] = - 1 ;\n return 0 ;\n }\n if ( w -> per_block_abt ) w -> abt_type = decode012 ( & s -> gb ) ;\n w -> abt_type_table [ n ] = w -> abt_type ;\n if ( w -> abt_type ) {\n const uint8_t * scantable = w -> abt_scantable [ w -> abt_type - 1 ] . scantable ;\n sub_cbp = sub_cbp_table [ decode012 ( & s -> gb ) ] ;\n if ( sub_cbp & 1 ) {\n if ( ff_msmpeg4_decode_block ( s , block , n , 1 , scantable ) < 0 ) return - 1 ;\n }\n if ( sub_cbp & 2 ) {\n if ( ff_msmpeg4_decode_block ( s , w -> abt_block2 [ n ] , n , 1 , scantable ) < 0 ) return - 1 ;\n }\n s -> block_last_index [ n ] = 63 ;\n return 0 ;\n }\n else {\n return ff_msmpeg4_decode_block ( s , block , n , 1 , s -> inter_scantable . permutated ) ;\n }\n }", "hash": 6511303611138191176, "project": "debian", "size": 28, "target": 0, "idx": 1958}
{"code": "static int ilbc_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n ILBCDecContext * s = avctx -> priv_data ;\n AVFrame * frame = data ;\n int ret ;\n if ( s -> decoder . no_of_bytes > buf_size ) {\n av_log ( avctx , AV_LOG_ERROR , \"iLBC frame too short (%u, should be %u)\\n\" , buf_size , s -> decoder . no_of_bytes ) ;\n return AVERROR_INVALIDDATA ;\n }\n frame -> nb_samples = s -> decoder . blockl ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n WebRtcIlbcfix_DecodeImpl ( ( WebRtc_Word16 * ) frame -> data [ 0 ] , ( const WebRtc_UWord16 * ) buf , & s -> decoder , 1 ) ;\n * got_frame_ptr = 1 ;\n return s -> decoder . no_of_bytes ;\n }", "hash": 2559621819476647153, "project": "debian", "size": 19, "target": 0, "idx": 1962}
{"code": "static inline void idct_put ( MDECContext * a , AVFrame * frame , int mb_x , int mb_y ) {\n int16_t ( * block ) [ 64 ] = a -> block ;\n int linesize = frame -> linesize [ 0 ] ;\n uint8_t * dest_y = frame -> data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;\n uint8_t * dest_cb = frame -> data [ 1 ] + ( mb_y * 8 * frame -> linesize [ 1 ] ) + mb_x * 8 ;\n uint8_t * dest_cr = frame -> data [ 2 ] + ( mb_y * 8 * frame -> linesize [ 2 ] ) + mb_x * 8 ;\n a -> dsp . idct_put ( dest_y , linesize , block [ 0 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 , linesize , block [ 1 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 * linesize , linesize , block [ 2 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 * linesize + 8 , linesize , block [ 3 ] ) ;\n if ( ! ( a -> avctx -> flags & CODEC_FLAG_GRAY ) ) {\n a -> dsp . idct_put ( dest_cb , frame -> linesize [ 1 ] , block [ 4 ] ) ;\n a -> dsp . idct_put ( dest_cr , frame -> linesize [ 2 ] , block [ 5 ] ) ;\n }\n }", "hash": 7078129966845159750, "project": "debian", "size": 15, "target": 0, "idx": 1965}
{"code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n MDECContext * const a = avctx -> priv_data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n ThreadFrame frame = {\n . f = data }\n ;\n int i , ret ;\n if ( ( ret = ff_thread_get_buffer ( avctx , & frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n frame . f -> pict_type = AV_PICTURE_TYPE_I ;\n frame . f -> key_frame = 1 ;\n av_fast_malloc ( & a -> bitstream_buffer , & a -> bitstream_buffer_size , buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! a -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n for ( i = 0 ;\n i < buf_size ;\n i += 2 ) {\n a -> bitstream_buffer [ i ] = buf [ i + 1 ] ;\n a -> bitstream_buffer [ i + 1 ] = buf [ i ] ;\n }\n init_get_bits ( & a -> gb , a -> bitstream_buffer , buf_size * 8 ) ;\n skip_bits ( & a -> gb , 32 ) ;\n a -> qscale = get_bits ( & a -> gb , 16 ) ;\n a -> version = get_bits ( & a -> gb , 16 ) ;\n a -> last_dc [ 0 ] = a -> last_dc [ 1 ] = a -> last_dc [ 2 ] = 128 ;\n for ( a -> mb_x = 0 ;\n a -> mb_x < a -> mb_width ;\n a -> mb_x ++ ) {\n for ( a -> mb_y = 0 ;\n a -> mb_y < a -> mb_height ;\n a -> mb_y ++ ) {\n if ( ( ret = decode_mb ( a , a -> block ) ) < 0 ) return ret ;\n idct_put ( a , frame . f , a -> mb_x , a -> mb_y ) ;\n }\n }\n * got_frame = 1 ;\n return ( get_bits_count ( & a -> gb ) + 31 ) / 32 * 4 ;\n }", "hash": 7078129966845159750, "project": "debian", "size": 40, "target": 0, "idx": 1966}
{"code": "static int vc1_decode_p_mb ( VC1Context * v ) {\n MpegEncContext * s = & v -> s ;\n GetBitContext * gb = & s -> gb ;\n int i , j ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int cbp ;\n int mqdiff , mquant ;\n int ttmb = v -> ttfrm ;\n int mb_has_coeffs = 1 ;\n int dmv_x , dmv_y ;\n int index , index1 ;\n int val , sign ;\n int first_block = 1 ;\n int dst_idx , off ;\n int skipped , fourmv ;\n int block_cbp = 0 , pat , block_tt = 0 , block_intra = 0 ;\n mquant = v -> pq ;\n if ( v -> mv_type_is_raw ) fourmv = get_bits1 ( gb ) ;\n else fourmv = v -> mv_type_mb_plane [ mb_pos ] ;\n if ( v -> skip_is_raw ) skipped = get_bits1 ( gb ) ;\n else skipped = v -> s . mbskip_table [ mb_pos ] ;\n if ( ! fourmv ) {\n if ( ! skipped ) {\n GET_MVDATA ( dmv_x , dmv_y ) ;\n if ( s -> mb_intra ) {\n s -> current_picture . motion_val [ 1 ] [ s -> block_index [ 0 ] ] [ 0 ] = 0 ;\n s -> current_picture . motion_val [ 1 ] [ s -> block_index [ 0 ] ] [ 1 ] = 0 ;\n }\n s -> current_picture . mb_type [ mb_pos ] = s -> mb_intra ? MB_TYPE_INTRA : MB_TYPE_16x16 ;\n vc1_pred_mv ( v , 0 , dmv_x , dmv_y , 1 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] , 0 , 0 ) ;\n if ( s -> mb_intra && ! mb_has_coeffs ) {\n GET_MQUANT ( ) ;\n s -> ac_pred = get_bits1 ( gb ) ;\n cbp = 0 ;\n }\n else if ( mb_has_coeffs ) {\n if ( s -> mb_intra ) s -> ac_pred = get_bits1 ( gb ) ;\n cbp = get_vlc2 ( & v -> s . gb , v -> cbpcy_vlc -> table , VC1_CBPCY_P_VLC_BITS , 2 ) ;\n GET_MQUANT ( ) ;\n }\n else {\n mquant = v -> pq ;\n cbp = 0 ;\n }\n s -> current_picture . qscale_table [ mb_pos ] = mquant ;\n if ( ! v -> ttmbf && ! s -> mb_intra && mb_has_coeffs ) ttmb = get_vlc2 ( gb , ff_vc1_ttmb_vlc [ v -> tt_index ] . table , VC1_TTMB_VLC_BITS , 2 ) ;\n if ( ! s -> mb_intra ) vc1_mc_1mv ( v , 0 ) ;\n dst_idx = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n dst_idx += i >> 2 ;\n val = ( ( cbp >> ( 5 - i ) ) & 1 ) ;\n off = ( i & 4 ) ? 0 : ( ( i & 1 ) * 8 + ( i & 2 ) * 4 * s -> linesize ) ;\n v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = s -> mb_intra ;\n if ( s -> mb_intra ) {\n v -> a_avail = v -> c_avail = 0 ;\n if ( i == 2 || i == 3 || ! s -> first_slice_line ) v -> a_avail = v -> mb_type [ 0 ] [ s -> block_index [ i ] - s -> block_wrap [ i ] ] ;\n if ( i == 1 || i == 3 || s -> mb_x ) v -> c_avail = v -> mb_type [ 0 ] [ s -> block_index [ i ] - 1 ] ;\n vc1_decode_intra_block ( v , s -> block [ i ] , i , val , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n if ( ( i > 3 ) && ( s -> flags & CODEC_FLAG_GRAY ) ) continue ;\n v -> vc1dsp . vc1_inv_trans_8x8 ( s -> block [ i ] ) ;\n if ( v -> rangeredfrm ) for ( j = 0 ;\n j < 64 ;\n j ++ ) s -> block [ i ] [ j ] <<= 1 ;\n s -> dsp . put_signed_pixels_clamped ( s -> block [ i ] , s -> dest [ dst_idx ] + off , i & 4 ? s -> uvlinesize : s -> linesize ) ;\n if ( v -> pq >= 9 && v -> overlap ) {\n if ( v -> c_avail ) v -> vc1dsp . vc1_h_overlap ( s -> dest [ dst_idx ] + off , i & 4 ? s -> uvlinesize : s -> linesize ) ;\n if ( v -> a_avail ) v -> vc1dsp . vc1_v_overlap ( s -> dest [ dst_idx ] + off , i & 4 ? s -> uvlinesize : s -> linesize ) ;\n }\n block_cbp |= 0xF << ( i << 2 ) ;\n block_intra |= 1 << i ;\n }\n else if ( val ) {\n pat = vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : s -> linesize , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , & block_tt ) ;\n block_cbp |= pat << ( i << 2 ) ;\n if ( ! v -> ttmbf && ttmb < 8 ) ttmb = - 1 ;\n first_block = 0 ;\n }\n }\n }\n else {\n s -> mb_intra = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n }\n s -> current_picture . mb_type [ mb_pos ] = MB_TYPE_SKIP ;\n s -> current_picture . qscale_table [ mb_pos ] = 0 ;\n vc1_pred_mv ( v , 0 , 0 , 0 , 1 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] , 0 , 0 ) ;\n vc1_mc_1mv ( v , 0 ) ;\n }\n }\n else {\n if ( ! skipped ) {\n int intra_count = 0 , coded_inter = 0 ;\n int is_intra [ 6 ] , is_coded [ 6 ] ;\n cbp = get_vlc2 ( & v -> s . gb , v -> cbpcy_vlc -> table , VC1_CBPCY_P_VLC_BITS , 2 ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n val = ( ( cbp >> ( 5 - i ) ) & 1 ) ;\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n s -> mb_intra = 0 ;\n if ( i < 4 ) {\n dmv_x = dmv_y = 0 ;\n s -> mb_intra = 0 ;\n mb_has_coeffs = 0 ;\n if ( val ) {\n GET_MVDATA ( dmv_x , dmv_y ) ;\n }\n vc1_pred_mv ( v , i , dmv_x , dmv_y , 0 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] , 0 , 0 ) ;\n if ( ! s -> mb_intra ) vc1_mc_4mv_luma ( v , i , 0 ) ;\n intra_count += s -> mb_intra ;\n is_intra [ i ] = s -> mb_intra ;\n is_coded [ i ] = mb_has_coeffs ;\n }\n if ( i & 4 ) {\n is_intra [ i ] = ( intra_count >= 3 ) ;\n is_coded [ i ] = val ;\n }\n if ( i == 4 ) vc1_mc_4mv_chroma ( v , 0 ) ;\n v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = is_intra [ i ] ;\n if ( ! coded_inter ) coded_inter = ! is_intra [ i ] & is_coded [ i ] ;\n }\n dst_idx = 0 ;\n if ( ! intra_count && ! coded_inter ) goto end ;\n GET_MQUANT ( ) ;\n s -> current_picture . qscale_table [ mb_pos ] = mquant ;\n {\n int intrapred = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) if ( is_intra [ i ] ) {\n if ( ( ( ! s -> first_slice_line || ( i == 2 || i == 3 ) ) && v -> mb_type [ 0 ] [ s -> block_index [ i ] - s -> block_wrap [ i ] ] ) || ( ( s -> mb_x || ( i == 1 || i == 3 ) ) && v -> mb_type [ 0 ] [ s -> block_index [ i ] - 1 ] ) ) {\n intrapred = 1 ;\n break ;\n }\n }\n if ( intrapred ) s -> ac_pred = get_bits1 ( gb ) ;\n else s -> ac_pred = 0 ;\n }\n if ( ! v -> ttmbf && coded_inter ) ttmb = get_vlc2 ( gb , ff_vc1_ttmb_vlc [ v -> tt_index ] . table , VC1_TTMB_VLC_BITS , 2 ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n dst_idx += i >> 2 ;\n off = ( i & 4 ) ? 0 : ( ( i & 1 ) * 8 + ( i & 2 ) * 4 * s -> linesize ) ;\n s -> mb_intra = is_intra [ i ] ;\n if ( is_intra [ i ] ) {\n v -> a_avail = v -> c_avail = 0 ;\n if ( i == 2 || i == 3 || ! s -> first_slice_line ) v -> a_avail = v -> mb_type [ 0 ] [ s -> block_index [ i ] - s -> block_wrap [ i ] ] ;\n if ( i == 1 || i == 3 || s -> mb_x ) v -> c_avail = v -> mb_type [ 0 ] [ s -> block_index [ i ] - 1 ] ;\n vc1_decode_intra_block ( v , s -> block [ i ] , i , is_coded [ i ] , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n if ( ( i > 3 ) && ( s -> flags & CODEC_FLAG_GRAY ) ) continue ;\n v -> vc1dsp . vc1_inv_trans_8x8 ( s -> block [ i ] ) ;\n if ( v -> rangeredfrm ) for ( j = 0 ;\n j < 64 ;\n j ++ ) s -> block [ i ] [ j ] <<= 1 ;\n s -> dsp . put_signed_pixels_clamped ( s -> block [ i ] , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : s -> linesize ) ;\n if ( v -> pq >= 9 && v -> overlap ) {\n if ( v -> c_avail ) v -> vc1dsp . vc1_h_overlap ( s -> dest [ dst_idx ] + off , i & 4 ? s -> uvlinesize : s -> linesize ) ;\n if ( v -> a_avail ) v -> vc1dsp . vc1_v_overlap ( s -> dest [ dst_idx ] + off , i & 4 ? s -> uvlinesize : s -> linesize ) ;\n }\n block_cbp |= 0xF << ( i << 2 ) ;\n block_intra |= 1 << i ;\n }\n else if ( is_coded [ i ] ) {\n pat = vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : s -> linesize , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , & block_tt ) ;\n block_cbp |= pat << ( i << 2 ) ;\n if ( ! v -> ttmbf && ttmb < 8 ) ttmb = - 1 ;\n first_block = 0 ;\n }\n }\n }\n else {\n s -> mb_intra = 0 ;\n s -> current_picture . qscale_table [ mb_pos ] = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n vc1_pred_mv ( v , i , 0 , 0 , 0 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] , 0 , 0 ) ;\n vc1_mc_4mv_luma ( v , i , 0 ) ;\n }\n vc1_mc_4mv_chroma ( v , 0 ) ;\n s -> current_picture . qscale_table [ mb_pos ] = 0 ;\n }\n }\n end : v -> cbp [ s -> mb_x ] = block_cbp ;\n v -> ttblk [ s -> mb_x ] = block_tt ;\n v -> is_intra [ s -> mb_x ] = block_intra ;\n return 0 ;\n }", "hash": 6080147530626246065, "project": "debian", "size": 202, "target": 0, "idx": 1969}
{"code": "static int vc1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size , n_slices = 0 , i , ret ;\n VC1Context * v = avctx -> priv_data ;\n MpegEncContext * s = & v -> s ;\n AVFrame * pict = data ;\n uint8_t * buf2 = NULL ;\n const uint8_t * buf_start = buf ;\n int mb_height , n_slices1 ;\n struct {\n uint8_t * buf ;\n GetBitContext gb ;\n int mby_start ;\n }\n * slices = NULL , * tmp ;\n if ( buf_size == 0 || ( buf_size == 4 && AV_RB32 ( buf ) == VC1_CODE_ENDOFSEQ ) ) {\n if ( s -> low_delay == 0 && s -> next_picture_ptr ) {\n if ( ( ret = av_frame_ref ( pict , & s -> next_picture_ptr -> f ) ) < 0 ) return ret ;\n s -> next_picture_ptr = NULL ;\n * got_frame = 1 ;\n }\n return 0 ;\n }\n if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) {\n if ( v -> profile < PROFILE_ADVANCED ) avctx -> pix_fmt = AV_PIX_FMT_VDPAU_WMV3 ;\n else avctx -> pix_fmt = AV_PIX_FMT_VDPAU_VC1 ;\n }\n if ( avctx -> codec_id == AV_CODEC_ID_VC1 || avctx -> codec_id == AV_CODEC_ID_VC1IMAGE ) {\n int buf_size2 = 0 ;\n buf2 = av_mallocz ( buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( IS_MARKER ( AV_RB32 ( buf ) ) ) {\n const uint8_t * start , * end , * next ;\n int size ;\n next = buf ;\n for ( start = buf , end = buf + buf_size ;\n next < end ;\n start = next ) {\n next = find_next_marker ( start + 4 , end ) ;\n size = next - start - 4 ;\n if ( size <= 0 ) continue ;\n switch ( AV_RB32 ( start ) ) {\n case VC1_CODE_FRAME : if ( avctx -> hwaccel || s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) buf_start = start ;\n buf_size2 = vc1_unescape_buffer ( start + 4 , size , buf2 ) ;\n break ;\n case VC1_CODE_FIELD : {\n int buf_size3 ;\n tmp = av_realloc ( slices , sizeof ( * slices ) * ( n_slices + 1 ) ) ;\n if ( ! tmp ) goto err ;\n slices = tmp ;\n slices [ n_slices ] . buf = av_mallocz ( buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! slices [ n_slices ] . buf ) goto err ;\n buf_size3 = vc1_unescape_buffer ( start + 4 , size , slices [ n_slices ] . buf ) ;\n init_get_bits ( & slices [ n_slices ] . gb , slices [ n_slices ] . buf , buf_size3 << 3 ) ;\n slices [ n_slices ] . mby_start = s -> mb_height >> 1 ;\n n_slices1 = n_slices - 1 ;\n n_slices ++ ;\n break ;\n }\n case VC1_CODE_ENTRYPOINT : buf_size2 = vc1_unescape_buffer ( start + 4 , size , buf2 ) ;\n init_get_bits ( & s -> gb , buf2 , buf_size2 * 8 ) ;\n ff_vc1_decode_entry_point ( avctx , v , & s -> gb ) ;\n break ;\n case VC1_CODE_SLICE : {\n int buf_size3 ;\n tmp = av_realloc ( slices , sizeof ( * slices ) * ( n_slices + 1 ) ) ;\n if ( ! tmp ) goto err ;\n slices = tmp ;\n slices [ n_slices ] . buf = av_mallocz ( buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! slices [ n_slices ] . buf ) goto err ;\n buf_size3 = vc1_unescape_buffer ( start + 4 , size , slices [ n_slices ] . buf ) ;\n init_get_bits ( & slices [ n_slices ] . gb , slices [ n_slices ] . buf , buf_size3 << 3 ) ;\n slices [ n_slices ] . mby_start = get_bits ( & slices [ n_slices ] . gb , 9 ) ;\n n_slices ++ ;\n break ;\n }\n }\n }\n }\n else if ( v -> interlace && ( ( buf [ 0 ] & 0xC0 ) == 0xC0 ) ) {\n const uint8_t * divider ;\n int buf_size3 ;\n divider = find_next_marker ( buf , buf + buf_size ) ;\n if ( ( divider == ( buf + buf_size ) ) || AV_RB32 ( divider ) != VC1_CODE_FIELD ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error in WVC1 interlaced frame\\n\" ) ;\n goto err ;\n }\n else {\n tmp = av_realloc ( slices , sizeof ( * slices ) * ( n_slices + 1 ) ) ;\n if ( ! tmp ) goto err ;\n slices = tmp ;\n slices [ n_slices ] . buf = av_mallocz ( buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! slices [ n_slices ] . buf ) goto err ;\n buf_size3 = vc1_unescape_buffer ( divider + 4 , buf + buf_size - divider - 4 , slices [ n_slices ] . buf ) ;\n init_get_bits ( & slices [ n_slices ] . gb , slices [ n_slices ] . buf , buf_size3 << 3 ) ;\n slices [ n_slices ] . mby_start = s -> mb_height >> 1 ;\n n_slices1 = n_slices - 1 ;\n n_slices ++ ;\n }\n buf_size2 = vc1_unescape_buffer ( buf , divider - buf , buf2 ) ;\n }\n else {\n buf_size2 = vc1_unescape_buffer ( buf , buf_size , buf2 ) ;\n }\n init_get_bits ( & s -> gb , buf2 , buf_size2 * 8 ) ;\n }\n else init_get_bits ( & s -> gb , buf , buf_size * 8 ) ;\n if ( v -> res_sprite ) {\n v -> new_sprite = ! get_bits1 ( & s -> gb ) ;\n v -> two_sprites = get_bits1 ( & s -> gb ) ;\n if ( avctx -> codec_id == AV_CODEC_ID_WMV3IMAGE || avctx -> codec_id == AV_CODEC_ID_VC1IMAGE ) {\n if ( v -> new_sprite ) {\n avctx -> width = avctx -> coded_width = v -> sprite_width ;\n avctx -> height = avctx -> coded_height = v -> sprite_height ;\n }\n else {\n goto image ;\n }\n }\n }\n if ( s -> context_initialized && ( s -> width != avctx -> coded_width || s -> height != avctx -> coded_height ) ) {\n ff_vc1_decode_end ( avctx ) ;\n }\n if ( ! s -> context_initialized ) {\n if ( ff_msmpeg4_decode_init ( avctx ) < 0 || ff_vc1_decode_init_alloc_tables ( v ) < 0 ) goto err ;\n s -> low_delay = ! avctx -> has_b_frames || v -> res_sprite ;\n if ( v -> profile == PROFILE_ADVANCED ) {\n s -> h_edge_pos = avctx -> coded_width ;\n s -> v_edge_pos = avctx -> coded_height ;\n }\n }\n if ( s -> current_picture_ptr == NULL || s -> current_picture_ptr -> f . data [ 0 ] ) {\n int i = ff_find_unused_picture ( s , 0 ) ;\n if ( i < 0 ) goto err ;\n s -> current_picture_ptr = & s -> picture [ i ] ;\n }\n v -> pic_header_flag = 0 ;\n if ( v -> profile < PROFILE_ADVANCED ) {\n if ( ff_vc1_parse_frame_header ( v , & s -> gb ) == - 1 ) {\n goto err ;\n }\n }\n else {\n if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) == - 1 ) {\n goto err ;\n }\n }\n if ( ( avctx -> codec_id == AV_CODEC_ID_WMV3IMAGE || avctx -> codec_id == AV_CODEC_ID_VC1IMAGE ) && s -> pict_type != AV_PICTURE_TYPE_I ) {\n av_log ( v -> s . avctx , AV_LOG_ERROR , \"Sprite decoder: expected I-frame\\n\" ) ;\n goto err ;\n }\n s -> current_picture_ptr -> f . repeat_pict = 0 ;\n if ( v -> rff ) {\n s -> current_picture_ptr -> f . repeat_pict = 1 ;\n }\n else if ( v -> rptfrm ) {\n s -> current_picture_ptr -> f . repeat_pict = v -> rptfrm * 2 ;\n }\n s -> current_picture . f . pict_type = s -> pict_type ;\n s -> current_picture . f . key_frame = s -> pict_type == AV_PICTURE_TYPE_I ;\n if ( s -> last_picture_ptr == NULL && ( s -> pict_type == AV_PICTURE_TYPE_B || s -> droppable ) ) {\n goto err ;\n }\n if ( ( avctx -> skip_frame >= AVDISCARD_NONREF && s -> pict_type == AV_PICTURE_TYPE_B ) || ( avctx -> skip_frame >= AVDISCARD_NONKEY && s -> pict_type != AV_PICTURE_TYPE_I ) || avctx -> skip_frame >= AVDISCARD_ALL ) {\n goto end ;\n }\n if ( s -> next_p_frame_damaged ) {\n if ( s -> pict_type == AV_PICTURE_TYPE_B ) goto end ;\n else s -> next_p_frame_damaged = 0 ;\n }\n if ( ff_MPV_frame_start ( s , avctx ) < 0 ) {\n goto err ;\n }\n s -> me . qpel_put = s -> dsp . put_qpel_pixels_tab ;\n s -> me . qpel_avg = s -> dsp . avg_qpel_pixels_tab ;\n if ( ( CONFIG_VC1_VDPAU_DECODER ) && s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) ff_vdpau_vc1_decode_picture ( s , buf_start , ( buf + buf_size ) - buf_start ) ;\n else if ( avctx -> hwaccel ) {\n if ( avctx -> hwaccel -> start_frame ( avctx , buf , buf_size ) < 0 ) goto err ;\n if ( avctx -> hwaccel -> decode_slice ( avctx , buf_start , ( buf + buf_size ) - buf_start ) < 0 ) goto err ;\n if ( avctx -> hwaccel -> end_frame ( avctx ) < 0 ) goto err ;\n }\n else {\n ff_mpeg_er_frame_start ( s ) ;\n v -> bits = buf_size * 8 ;\n v -> end_mb_x = s -> mb_width ;\n if ( v -> field_mode ) {\n uint8_t * tmp [ 2 ] ;\n s -> current_picture . f . linesize [ 0 ] <<= 1 ;\n s -> current_picture . f . linesize [ 1 ] <<= 1 ;\n s -> current_picture . f . linesize [ 2 ] <<= 1 ;\n s -> linesize <<= 1 ;\n s -> uvlinesize <<= 1 ;\n tmp [ 0 ] = v -> mv_f_last [ 0 ] ;\n tmp [ 1 ] = v -> mv_f_last [ 1 ] ;\n v -> mv_f_last [ 0 ] = v -> mv_f_next [ 0 ] ;\n v -> mv_f_last [ 1 ] = v -> mv_f_next [ 1 ] ;\n v -> mv_f_next [ 0 ] = v -> mv_f [ 0 ] ;\n v -> mv_f_next [ 1 ] = v -> mv_f [ 1 ] ;\n v -> mv_f [ 0 ] = tmp [ 0 ] ;\n v -> mv_f [ 1 ] = tmp [ 1 ] ;\n }\n mb_height = s -> mb_height >> v -> field_mode ;\n for ( i = 0 ;\n i <= n_slices ;\n i ++ ) {\n if ( i > 0 && slices [ i - 1 ] . mby_start >= mb_height ) {\n if ( v -> field_mode <= 0 ) {\n av_log ( v -> s . avctx , AV_LOG_ERROR , \"Slice %d starts beyond \" \"picture boundary (%d >= %d)\\n\" , i , slices [ i - 1 ] . mby_start , mb_height ) ;\n continue ;\n }\n v -> second_field = 1 ;\n v -> blocks_off = s -> mb_width * s -> mb_height << 1 ;\n v -> mb_off = s -> mb_stride * s -> mb_height >> 1 ;\n }\n else {\n v -> second_field = 0 ;\n v -> blocks_off = 0 ;\n v -> mb_off = 0 ;\n }\n if ( i ) {\n v -> pic_header_flag = 0 ;\n if ( v -> field_mode && i == n_slices1 + 2 ) {\n if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) < 0 ) {\n av_log ( v -> s . avctx , AV_LOG_ERROR , \"Field header damaged\\n\" ) ;\n continue ;\n }\n }\n else if ( get_bits1 ( & s -> gb ) ) {\n v -> pic_header_flag = 1 ;\n if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) < 0 ) {\n av_log ( v -> s . avctx , AV_LOG_ERROR , \"Slice header damaged\\n\" ) ;\n continue ;\n }\n }\n }\n s -> start_mb_y = ( i == 0 ) ? 0 : FFMAX ( 0 , slices [ i - 1 ] . mby_start % mb_height ) ;\n if ( ! v -> field_mode || v -> second_field ) s -> end_mb_y = ( i == n_slices ) ? mb_height : FFMIN ( mb_height , slices [ i ] . mby_start % mb_height ) ;\n else s -> end_mb_y = ( i <= n_slices1 + 1 ) ? mb_height : FFMIN ( mb_height , slices [ i ] . mby_start % mb_height ) ;\n ff_vc1_decode_blocks ( v ) ;\n if ( i != n_slices ) s -> gb = slices [ i ] . gb ;\n }\n if ( v -> field_mode ) {\n v -> second_field = 0 ;\n if ( s -> pict_type == AV_PICTURE_TYPE_B ) {\n memcpy ( v -> mv_f_base , v -> mv_f_next_base , 2 * ( s -> b8_stride * ( s -> mb_height * 2 + 1 ) + s -> mb_stride * ( s -> mb_height + 1 ) * 2 ) ) ;\n }\n s -> current_picture . f . linesize [ 0 ] >>= 1 ;\n s -> current_picture . f . linesize [ 1 ] >>= 1 ;\n s -> current_picture . f . linesize [ 2 ] >>= 1 ;\n s -> linesize >>= 1 ;\n s -> uvlinesize >>= 1 ;\n }\n av_dlog ( s -> avctx , \"Consumed %i/%i bits\\n\" , get_bits_count ( & s -> gb ) , s -> gb . size_in_bits ) ;\n ff_er_frame_end ( & s -> er ) ;\n }\n ff_MPV_frame_end ( s ) ;\n if ( avctx -> codec_id == AV_CODEC_ID_WMV3IMAGE || avctx -> codec_id == AV_CODEC_ID_VC1IMAGE ) {\n image : avctx -> width = avctx -> coded_width = v -> output_width ;\n avctx -> height = avctx -> coded_height = v -> output_height ;\n if ( avctx -> skip_frame >= AVDISCARD_NONREF ) goto end ;\n # if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER if ( vc1_decode_sprites ( v , & s -> gb ) ) goto err ;\n # endif if ( ( ret = av_frame_ref ( pict , & v -> sprite_output_frame ) ) < 0 ) goto err ;\n * got_frame = 1 ;\n }\n else {\n if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) {\n if ( ( ret = av_frame_ref ( pict , & s -> current_picture_ptr -> f ) ) < 0 ) goto err ;\n ff_print_debug_info ( s , s -> current_picture_ptr ) ;\n }\n else if ( s -> last_picture_ptr != NULL ) {\n if ( ( ret = av_frame_ref ( pict , & s -> last_picture_ptr -> f ) ) < 0 ) goto err ;\n ff_print_debug_info ( s , s -> last_picture_ptr ) ;\n }\n if ( s -> last_picture_ptr || s -> low_delay ) {\n * got_frame = 1 ;\n }\n }\n end : av_free ( buf2 ) ;\n for ( i = 0 ;\n i < n_slices ;\n i ++ ) av_free ( slices [ i ] . buf ) ;\n av_free ( slices ) ;\n return buf_size ;\n err : av_free ( buf2 ) ;\n for ( i = 0 ;\n i < n_slices ;\n i ++ ) av_free ( slices [ i ] . buf ) ;\n av_free ( slices ) ;\n return - 1 ;\n }", "hash": 6080147530626246065, "project": "debian", "size": 289, "target": 0, "idx": 1985}
{"code": "static void vc1_decode_i_blocks_adv ( VC1Context * v ) {\n int k ;\n MpegEncContext * s = & v -> s ;\n int cbp , val ;\n uint8_t * coded_val ;\n int mb_pos ;\n int mquant = v -> pq ;\n int mqdiff ;\n GetBitContext * gb = & s -> gb ;\n switch ( v -> y_ac_table_index ) {\n case 0 : v -> codingset = ( v -> pqindex <= 8 ) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA ;\n break ;\n case 1 : v -> codingset = CS_HIGH_MOT_INTRA ;\n break ;\n case 2 : v -> codingset = CS_MID_RATE_INTRA ;\n break ;\n }\n switch ( v -> c_ac_table_index ) {\n case 0 : v -> codingset2 = ( v -> pqindex <= 8 ) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER ;\n break ;\n case 1 : v -> codingset2 = CS_HIGH_MOT_INTER ;\n break ;\n case 2 : v -> codingset2 = CS_MID_RATE_INTER ;\n break ;\n }\n s -> mb_x = s -> mb_y = 0 ;\n s -> mb_intra = 1 ;\n s -> first_slice_line = 1 ;\n s -> mb_y = s -> start_mb_y ;\n if ( s -> start_mb_y ) {\n s -> mb_x = 0 ;\n ff_init_block_index ( s ) ;\n memset ( & s -> coded_block [ s -> block_index [ 0 ] - s -> b8_stride ] , 0 , ( 1 + s -> b8_stride ) * sizeof ( * s -> coded_block ) ) ;\n }\n for ( ;\n s -> mb_y < s -> end_mb_y ;\n s -> mb_y ++ ) {\n s -> mb_x = 0 ;\n ff_init_block_index ( s ) ;\n for ( ;\n s -> mb_x < s -> mb_width ;\n s -> mb_x ++ ) {\n int16_t ( * block ) [ 64 ] = v -> block [ v -> cur_blk_idx ] ;\n ff_update_block_index ( s ) ;\n s -> dsp . clear_blocks ( block [ 0 ] ) ;\n mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n s -> current_picture . mb_type [ mb_pos + v -> mb_off ] = MB_TYPE_INTRA ;\n s -> current_picture . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 0 ] = 0 ;\n s -> current_picture . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 1 ] = 0 ;\n if ( v -> fieldtx_is_raw ) v -> fieldtx_plane [ mb_pos ] = get_bits1 ( & v -> s . gb ) ;\n cbp = get_vlc2 ( & v -> s . gb , ff_msmp4_mb_i_vlc . table , MB_INTRA_VLC_BITS , 2 ) ;\n if ( v -> acpred_is_raw ) v -> s . ac_pred = get_bits1 ( & v -> s . gb ) ;\n else v -> s . ac_pred = v -> acpred_plane [ mb_pos ] ;\n if ( v -> condover == CONDOVER_SELECT && v -> overflg_is_raw ) v -> over_flags_plane [ mb_pos ] = get_bits1 ( & v -> s . gb ) ;\n GET_MQUANT ( ) ;\n s -> current_picture . qscale_table [ mb_pos ] = mquant ;\n s -> y_dc_scale = s -> y_dc_scale_table [ mquant ] ;\n s -> c_dc_scale = s -> c_dc_scale_table [ mquant ] ;\n for ( k = 0 ;\n k < 6 ;\n k ++ ) {\n val = ( ( cbp >> ( 5 - k ) ) & 1 ) ;\n if ( k < 4 ) {\n int pred = vc1_coded_block_pred ( & v -> s , k , & coded_val ) ;\n val = val ^ pred ;\n * coded_val = val ;\n }\n cbp |= val << ( 5 - k ) ;\n v -> a_avail = ! s -> first_slice_line || ( k == 2 || k == 3 ) ;\n v -> c_avail = ! ! s -> mb_x || ( k == 1 || k == 3 ) ;\n vc1_decode_i_block_adv ( v , block [ k ] , k , val , ( k < 4 ) ? v -> codingset : v -> codingset2 , mquant ) ;\n if ( k > 3 && ( s -> flags & CODEC_FLAG_GRAY ) ) continue ;\n v -> vc1dsp . vc1_inv_trans_8x8 ( block [ k ] ) ;\n }\n vc1_smooth_overlap_filter_iblk ( v ) ;\n vc1_put_signed_blocks_clamped ( v ) ;\n if ( v -> s . loop_filter ) vc1_loop_filter_iblk_delayed ( v , v -> pq ) ;\n if ( get_bits_count ( & s -> gb ) > v -> bits ) {\n ff_er_add_slice ( & s -> er , 0 , s -> start_mb_y , s -> mb_x , s -> mb_y , ER_MB_ERROR ) ;\n av_log ( s -> avctx , AV_LOG_ERROR , \"Bits overconsumption: %i > %i\\n\" , get_bits_count ( & s -> gb ) , v -> bits ) ;\n return ;\n }\n }\n if ( ! v -> s . loop_filter ) ff_mpeg_draw_horiz_band ( s , s -> mb_y * 16 , 16 ) ;\n else if ( s -> mb_y ) ff_mpeg_draw_horiz_band ( s , ( s -> mb_y - 1 ) * 16 , 16 ) ;\n s -> first_slice_line = 0 ;\n }\n s -> mb_x = 0 ;\n ff_init_block_index ( s ) ;\n for ( ;\n s -> mb_x < s -> mb_width ;\n s -> mb_x ++ ) {\n ff_update_block_index ( s ) ;\n vc1_put_signed_blocks_clamped ( v ) ;\n if ( v -> s . loop_filter ) vc1_loop_filter_iblk_delayed ( v , v -> pq ) ;\n }\n if ( v -> s . loop_filter ) ff_mpeg_draw_horiz_band ( s , ( s -> end_mb_y - 1 ) * 16 , 16 ) ;\n ff_er_add_slice ( & s -> er , 0 , s -> start_mb_y << v -> field_mode , s -> mb_width - 1 , ( s -> end_mb_y << v -> field_mode ) - 1 , ER_MB_END ) ;\n }", "hash": 6080147530626246065, "project": "debian", "size": 99, "target": 0, "idx": 1991}
{"code": "static int vc1_decode_intra_block ( VC1Context * v , int16_t block [ 64 ] , int n , int coded , int mquant , int codingset ) {\n GetBitContext * gb = & v -> s . gb ;\n MpegEncContext * s = & v -> s ;\n int dc_pred_dir = 0 ;\n int i ;\n int16_t * dc_val ;\n int16_t * ac_val , * ac_val2 ;\n int dcdiff ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int a_avail = v -> a_avail , c_avail = v -> c_avail ;\n int use_pred = s -> ac_pred ;\n int scale ;\n int q1 , q2 = 0 ;\n s -> dsp . clear_block ( block ) ;\n mquant = ( mquant < 1 ) ? 0 : ( ( mquant > 31 ) ? 31 : mquant ) ;\n s -> y_dc_scale = s -> y_dc_scale_table [ mquant ] ;\n s -> c_dc_scale = s -> c_dc_scale_table [ mquant ] ;\n if ( n < 4 ) {\n dcdiff = get_vlc2 ( & s -> gb , ff_msmp4_dc_luma_vlc [ s -> dc_table_index ] . table , DC_VLC_BITS , 3 ) ;\n }\n else {\n dcdiff = get_vlc2 ( & s -> gb , ff_msmp4_dc_chroma_vlc [ s -> dc_table_index ] . table , DC_VLC_BITS , 3 ) ;\n }\n if ( dcdiff < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Illegal DC VLC\\n\" ) ;\n return - 1 ;\n }\n if ( dcdiff ) {\n if ( dcdiff == 119 ) {\n if ( mquant == 1 ) dcdiff = get_bits ( gb , 10 ) ;\n else if ( mquant == 2 ) dcdiff = get_bits ( gb , 9 ) ;\n else dcdiff = get_bits ( gb , 8 ) ;\n }\n else {\n if ( mquant == 1 ) dcdiff = ( dcdiff << 2 ) + get_bits ( gb , 2 ) - 3 ;\n else if ( mquant == 2 ) dcdiff = ( dcdiff << 1 ) + get_bits1 ( gb ) - 1 ;\n }\n if ( get_bits1 ( gb ) ) dcdiff = - dcdiff ;\n }\n dcdiff += vc1_pred_dc ( & v -> s , v -> overlap , mquant , n , a_avail , c_avail , & dc_val , & dc_pred_dir ) ;\n * dc_val = dcdiff ;\n if ( n < 4 ) {\n block [ 0 ] = dcdiff * s -> y_dc_scale ;\n }\n else {\n block [ 0 ] = dcdiff * s -> c_dc_scale ;\n }\n i = 1 ;\n if ( ! a_avail ) dc_pred_dir = 1 ;\n if ( ! c_avail ) dc_pred_dir = 0 ;\n if ( ! a_avail && ! c_avail ) use_pred = 0 ;\n ac_val = s -> ac_val [ 0 ] [ 0 ] + s -> block_index [ n ] * 16 ;\n ac_val2 = ac_val ;\n scale = mquant * 2 + v -> halfpq ;\n if ( dc_pred_dir ) ac_val -= 16 ;\n else ac_val -= 16 * s -> block_wrap [ n ] ;\n q1 = s -> current_picture . qscale_table [ mb_pos ] ;\n if ( dc_pred_dir && c_avail && mb_pos ) q2 = s -> current_picture . qscale_table [ mb_pos - 1 ] ;\n if ( ! dc_pred_dir && a_avail && mb_pos >= s -> mb_stride ) q2 = s -> current_picture . qscale_table [ mb_pos - s -> mb_stride ] ;\n if ( dc_pred_dir && n == 1 ) q2 = q1 ;\n if ( ! dc_pred_dir && n == 2 ) q2 = q1 ;\n if ( n == 3 ) q2 = q1 ;\n if ( coded ) {\n int last = 0 , skip , value ;\n int k ;\n while ( ! last ) {\n vc1_decode_ac_coeff ( v , & last , & skip , & value , codingset ) ;\n i += skip ;\n if ( i > 63 ) break ;\n if ( v -> fcm == PROGRESSIVE ) block [ v -> zz_8x8 [ 0 ] [ i ++ ] ] = value ;\n else {\n if ( use_pred && ( v -> fcm == ILACE_FRAME ) ) {\n if ( ! dc_pred_dir ) block [ v -> zz_8x8 [ 2 ] [ i ++ ] ] = value ;\n else block [ v -> zz_8x8 [ 3 ] [ i ++ ] ] = value ;\n }\n else {\n block [ v -> zzi_8x8 [ i ++ ] ] = value ;\n }\n }\n }\n if ( use_pred ) {\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> left_blk_sh ] += ( ac_val [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> top_blk_sh ] += ( ac_val [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n else {\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> left_blk_sh ] += ac_val [ k ] ;\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> top_blk_sh ] += ac_val [ k + 8 ] ;\n }\n }\n }\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n ac_val2 [ k ] = block [ k << v -> left_blk_sh ] ;\n ac_val2 [ k + 8 ] = block [ k << v -> top_blk_sh ] ;\n }\n for ( k = 1 ;\n k < 64 ;\n k ++ ) if ( block [ k ] ) {\n block [ k ] *= scale ;\n if ( ! v -> pquantizer ) block [ k ] += ( block [ k ] < 0 ) ? - mquant : mquant ;\n }\n if ( use_pred ) i = 63 ;\n }\n else {\n int k ;\n memset ( ac_val2 , 0 , 16 * 2 ) ;\n if ( dc_pred_dir ) {\n if ( use_pred ) {\n memcpy ( ac_val2 , ac_val , 8 * 2 ) ;\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n for ( k = 1 ;\n k < 8 ;\n k ++ ) ac_val2 [ k ] = ( ac_val2 [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n }\n else {\n if ( use_pred ) {\n memcpy ( ac_val2 + 8 , ac_val + 8 , 8 * 2 ) ;\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n for ( k = 1 ;\n k < 8 ;\n k ++ ) ac_val2 [ k + 8 ] = ( ac_val2 [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n }\n if ( use_pred ) {\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n block [ k << v -> left_blk_sh ] = ac_val2 [ k ] * scale ;\n if ( ! v -> pquantizer && block [ k << v -> left_blk_sh ] ) block [ k << v -> left_blk_sh ] += ( block [ k << v -> left_blk_sh ] < 0 ) ? - mquant : mquant ;\n }\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n block [ k << v -> top_blk_sh ] = ac_val2 [ k + 8 ] * scale ;\n if ( ! v -> pquantizer && block [ k << v -> top_blk_sh ] ) block [ k << v -> top_blk_sh ] += ( block [ k << v -> top_blk_sh ] < 0 ) ? - mquant : mquant ;\n }\n }\n i = 63 ;\n }\n }\n s -> block_last_index [ n ] = i ;\n return 0 ;\n }", "hash": 6080147530626246065, "project": "debian", "size": 175, "target": 0, "idx": 1992}
{"code": "static int cng_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n CNGContext * p = avctx -> priv_data ;\n int buf_size = avpkt -> size ;\n int ret , i ;\n int16_t * buf_out ;\n float e = 1.0 ;\n float scaling ;\n if ( avpkt -> size ) {\n int dbov = - avpkt -> data [ 0 ] ;\n p -> target_energy = 1081109975 * pow ( 10 , dbov / 10.0 ) * 0.75 ;\n memset ( p -> target_refl_coef , 0 , p -> order * sizeof ( * p -> target_refl_coef ) ) ;\n for ( i = 0 ;\n i < FFMIN ( avpkt -> size - 1 , p -> order ) ;\n i ++ ) {\n p -> target_refl_coef [ i ] = ( avpkt -> data [ 1 + i ] - 127 ) / 128.0 ;\n }\n }\n if ( p -> inited ) {\n p -> energy = p -> energy / 2 + p -> target_energy / 2 ;\n for ( i = 0 ;\n i < p -> order ;\n i ++ ) p -> refl_coef [ i ] = 0.6 * p -> refl_coef [ i ] + 0.4 * p -> target_refl_coef [ i ] ;\n }\n else {\n p -> energy = p -> target_energy ;\n memcpy ( p -> refl_coef , p -> target_refl_coef , p -> order * sizeof ( * p -> refl_coef ) ) ;\n p -> inited = 1 ;\n }\n make_lpc_coefs ( p -> lpc_coef , p -> refl_coef , p -> order ) ;\n for ( i = 0 ;\n i < p -> order ;\n i ++ ) e *= 1.0 - p -> refl_coef [ i ] * p -> refl_coef [ i ] ;\n scaling = sqrt ( e * p -> energy / 1081109975 ) ;\n for ( i = 0 ;\n i < avctx -> frame_size ;\n i ++ ) {\n int r = ( av_lfg_get ( & p -> lfg ) & 0xffff ) - 0x8000 ;\n p -> excitation [ i ] = scaling * r ;\n }\n ff_celp_lp_synthesis_filterf ( p -> filter_out + p -> order , p -> lpc_coef , p -> excitation , avctx -> frame_size , p -> order ) ;\n frame -> nb_samples = avctx -> frame_size ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n buf_out = ( int16_t * ) frame -> data [ 0 ] ;\n for ( i = 0 ;\n i < avctx -> frame_size ;\n i ++ ) buf_out [ i ] = p -> filter_out [ i + p -> order ] ;\n memcpy ( p -> filter_out , p -> filter_out + avctx -> frame_size , p -> order * sizeof ( * p -> filter_out ) ) ;\n * got_frame_ptr = 1 ;\n return buf_size ;\n }", "hash": -4744270124459050462, "project": "debian", "size": 54, "target": 0, "idx": 2005}
{"code": "static int pre_estimate_motion_thread ( AVCodecContext * c , void * arg ) {\n MpegEncContext * s = * ( void * * ) arg ;\n s -> me . pre_pass = 1 ;\n s -> me . dia_size = s -> avctx -> pre_dia_size ;\n s -> first_slice_line = 1 ;\n for ( s -> mb_y = s -> end_mb_y - 1 ;\n s -> mb_y >= s -> start_mb_y ;\n s -> mb_y -- ) {\n for ( s -> mb_x = s -> mb_width - 1 ;\n s -> mb_x >= 0 ;\n s -> mb_x -- ) {\n ff_pre_estimate_p_frame_motion ( s , s -> mb_x , s -> mb_y ) ;\n }\n s -> first_slice_line = 0 ;\n }\n s -> me . pre_pass = 0 ;\n return 0 ;\n }", "hash": -305162769887579921, "project": "debian", "size": 18, "target": 0, "idx": 2009}
{"code": "static inline void encode_mb_hq ( MpegEncContext * s , MpegEncContext * backup , MpegEncContext * best , int type , PutBitContext pb [ 2 ] , PutBitContext pb2 [ 2 ] , PutBitContext tex_pb [ 2 ] , int * dmin , int * next_block , int motion_x , int motion_y ) {\n int score ;\n uint8_t * dest_backup [ 3 ] ;\n copy_context_before_encode ( s , backup , type ) ;\n s -> block = s -> blocks [ * next_block ] ;\n s -> pb = pb [ * next_block ] ;\n if ( s -> data_partitioning ) {\n s -> pb2 = pb2 [ * next_block ] ;\n s -> tex_pb = tex_pb [ * next_block ] ;\n }\n if ( * next_block ) {\n memcpy ( dest_backup , s -> dest , sizeof ( s -> dest ) ) ;\n s -> dest [ 0 ] = s -> rd_scratchpad ;\n s -> dest [ 1 ] = s -> rd_scratchpad + 16 * s -> linesize ;\n s -> dest [ 2 ] = s -> rd_scratchpad + 16 * s -> linesize + 8 ;\n assert ( s -> linesize >= 32 ) ;\n }\n encode_mb ( s , motion_x , motion_y ) ;\n score = put_bits_count ( & s -> pb ) ;\n if ( s -> data_partitioning ) {\n score += put_bits_count ( & s -> pb2 ) ;\n score += put_bits_count ( & s -> tex_pb ) ;\n }\n if ( s -> avctx -> mb_decision == FF_MB_DECISION_RD ) {\n ff_MPV_decode_mb ( s , s -> block ) ;\n score *= s -> lambda2 ;\n score += sse_mb ( s ) << FF_LAMBDA_SHIFT ;\n }\n if ( * next_block ) {\n memcpy ( s -> dest , dest_backup , sizeof ( s -> dest ) ) ;\n }\n if ( score < * dmin ) {\n * dmin = score ;\n * next_block ^= 1 ;\n copy_context_after_encode ( best , s , type ) ;\n }\n }", "hash": -305162769887579921, "project": "debian", "size": 37, "target": 0, "idx": 2011}
{"code": "static void MPV_encode_defaults ( MpegEncContext * s ) {\n int i ;\n ff_MPV_common_defaults ( s ) ;\n for ( i = - 16 ;\n i < 16 ;\n i ++ ) {\n default_fcode_tab [ i + MAX_MV ] = 1 ;\n }\n s -> me . mv_penalty = default_mv_penalty ;\n s -> fcode_tab = default_fcode_tab ;\n }", "hash": -305162769887579921, "project": "debian", "size": 11, "target": 0, "idx": 2016}
{"code": "static int dct_quantize_refine ( MpegEncContext * s , int16_t * block , int16_t * weight , int16_t * orig , int n , int qscale ) {\n int16_t rem [ 64 ] ;\n LOCAL_ALIGNED_16 ( int16_t , d1 , [ 64 ] ) ;\n const uint8_t * scantable = s -> intra_scantable . scantable ;\n const uint8_t * perm_scantable = s -> intra_scantable . permutated ;\n int run_tab [ 65 ] ;\n int prev_run = 0 ;\n int prev_level = 0 ;\n int qmul , qadd , start_i , last_non_zero , i , dc ;\n uint8_t * length ;\n uint8_t * last_length ;\n int lambda ;\n int rle_index , run , q = 1 , sum ;\n # ifdef REFINE_STATS static int count = 0 ;\n static int after_last = 0 ;\n static int to_zero = 0 ;\n static int from_zero = 0 ;\n static int raise = 0 ;\n static int lower = 0 ;\n static int messed_sign = 0 ;\n # endif if ( basis [ 0 ] [ 0 ] == 0 ) build_basis ( s -> dsp . idct_permutation ) ;\n qmul = qscale * 2 ;\n qadd = ( qscale - 1 ) | 1 ;\n if ( s -> mb_intra ) {\n if ( ! s -> h263_aic ) {\n if ( n < 4 ) q = s -> y_dc_scale ;\n else q = s -> c_dc_scale ;\n }\n else {\n q = 1 ;\n qadd = 0 ;\n }\n q <<= RECON_SHIFT - 3 ;\n dc = block [ 0 ] * q ;\n start_i = 1 ;\n length = s -> intra_ac_vlc_length ;\n last_length = s -> intra_ac_vlc_last_length ;\n }\n else {\n dc = 0 ;\n start_i = 0 ;\n length = s -> inter_ac_vlc_length ;\n last_length = s -> inter_ac_vlc_last_length ;\n }\n last_non_zero = s -> block_last_index [ n ] ;\n # ifdef REFINE_STATS {\n START_TIMER # endif dc += ( 1 << ( RECON_SHIFT - 1 ) ) ;\n for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n rem [ i ] = dc - ( orig [ i ] << RECON_SHIFT ) ;\n }\n # ifdef REFINE_STATS STOP_TIMER ( \"memset rem[]\" ) }\n # endif sum = 0 ;\n for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n int one = 36 ;\n int qns = 4 ;\n int w ;\n w = FFABS ( weight [ i ] ) + qns * one ;\n w = 15 + ( 48 * qns * one + w / 2 ) / w ;\n weight [ i ] = w ;\n assert ( w > 0 ) ;\n assert ( w < ( 1 << 6 ) ) ;\n sum += w * w ;\n }\n lambda = sum * ( uint64_t ) s -> lambda2 >> ( FF_LAMBDA_SHIFT - 6 + 6 + 6 + 6 ) ;\n # ifdef REFINE_STATS {\n START_TIMER # endif run = 0 ;\n rle_index = 0 ;\n for ( i = start_i ;\n i <= last_non_zero ;\n i ++ ) {\n int j = perm_scantable [ i ] ;\n const int level = block [ j ] ;\n int coeff ;\n if ( level ) {\n if ( level < 0 ) coeff = qmul * level - qadd ;\n else coeff = qmul * level + qadd ;\n run_tab [ rle_index ++ ] = run ;\n run = 0 ;\n s -> dsp . add_8x8basis ( rem , basis [ j ] , coeff ) ;\n }\n else {\n run ++ ;\n }\n }\n # ifdef REFINE_STATS if ( last_non_zero > 0 ) {\n STOP_TIMER ( \"init rem[]\" ) }\n }\n {\n START_TIMER # endif for ( ;\n ;\n ) {\n int best_score = s -> dsp . try_8x8basis ( rem , weight , basis [ 0 ] , 0 ) ;\n int best_coeff = 0 ;\n int best_change = 0 ;\n int run2 , best_unquant_change = 0 , analyze_gradient ;\n # ifdef REFINE_STATS {\n START_TIMER # endif analyze_gradient = last_non_zero > 2 || s -> quantizer_noise_shaping >= 3 ;\n if ( analyze_gradient ) {\n # ifdef REFINE_STATS {\n START_TIMER # endif for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n int w = weight [ i ] ;\n d1 [ i ] = ( rem [ i ] * w * w + ( 1 << ( RECON_SHIFT + 12 - 1 ) ) ) >> ( RECON_SHIFT + 12 ) ;\n }\n # ifdef REFINE_STATS STOP_TIMER ( \"rem*w*w\" ) }\n {\n START_TIMER # endif s -> dsp . fdct ( d1 ) ;\n # ifdef REFINE_STATS STOP_TIMER ( \"dct\" ) }\n # endif }\n if ( start_i ) {\n const int level = block [ 0 ] ;\n int change , old_coeff ;\n assert ( s -> mb_intra ) ;\n old_coeff = q * level ;\n for ( change = - 1 ;\n change <= 1 ;\n change += 2 ) {\n int new_level = level + change ;\n int score , new_coeff ;\n new_coeff = q * new_level ;\n if ( new_coeff >= 2048 || new_coeff < 0 ) continue ;\n score = s -> dsp . try_8x8basis ( rem , weight , basis [ 0 ] , new_coeff - old_coeff ) ;\n if ( score < best_score ) {\n best_score = score ;\n best_coeff = 0 ;\n best_change = change ;\n best_unquant_change = new_coeff - old_coeff ;\n }\n }\n }\n run = 0 ;\n rle_index = 0 ;\n run2 = run_tab [ rle_index ++ ] ;\n prev_level = 0 ;\n prev_run = 0 ;\n for ( i = start_i ;\n i < 64 ;\n i ++ ) {\n int j = perm_scantable [ i ] ;\n const int level = block [ j ] ;\n int change , old_coeff ;\n if ( s -> quantizer_noise_shaping < 3 && i > last_non_zero + 1 ) break ;\n if ( level ) {\n if ( level < 0 ) old_coeff = qmul * level - qadd ;\n else old_coeff = qmul * level + qadd ;\n run2 = run_tab [ rle_index ++ ] ;\n }\n else {\n old_coeff = 0 ;\n run2 -- ;\n assert ( run2 >= 0 || i >= last_non_zero ) ;\n }\n for ( change = - 1 ;\n change <= 1 ;\n change += 2 ) {\n int new_level = level + change ;\n int score , new_coeff , unquant_change ;\n score = 0 ;\n if ( s -> quantizer_noise_shaping < 2 && FFABS ( new_level ) > FFABS ( level ) ) continue ;\n if ( new_level ) {\n if ( new_level < 0 ) new_coeff = qmul * new_level - qadd ;\n else new_coeff = qmul * new_level + qadd ;\n if ( new_coeff >= 2048 || new_coeff <= - 2048 ) continue ;\n if ( level ) {\n if ( level < 63 && level > - 63 ) {\n if ( i < last_non_zero ) score += length [ UNI_AC_ENC_INDEX ( run , new_level + 64 ) ] - length [ UNI_AC_ENC_INDEX ( run , level + 64 ) ] ;\n else score += last_length [ UNI_AC_ENC_INDEX ( run , new_level + 64 ) ] - last_length [ UNI_AC_ENC_INDEX ( run , level + 64 ) ] ;\n }\n }\n else {\n assert ( FFABS ( new_level ) == 1 ) ;\n if ( analyze_gradient ) {\n int g = d1 [ scantable [ i ] ] ;\n if ( g && ( g ^ new_level ) >= 0 ) continue ;\n }\n if ( i < last_non_zero ) {\n int next_i = i + run2 + 1 ;\n int next_level = block [ perm_scantable [ next_i ] ] + 64 ;\n if ( next_level & ( ~ 127 ) ) next_level = 0 ;\n if ( next_i < last_non_zero ) score += length [ UNI_AC_ENC_INDEX ( run , 65 ) ] + length [ UNI_AC_ENC_INDEX ( run2 , next_level ) ] - length [ UNI_AC_ENC_INDEX ( run + run2 + 1 , next_level ) ] ;\n else score += length [ UNI_AC_ENC_INDEX ( run , 65 ) ] + last_length [ UNI_AC_ENC_INDEX ( run2 , next_level ) ] - last_length [ UNI_AC_ENC_INDEX ( run + run2 + 1 , next_level ) ] ;\n }\n else {\n score += last_length [ UNI_AC_ENC_INDEX ( run , 65 ) ] ;\n if ( prev_level ) {\n score += length [ UNI_AC_ENC_INDEX ( prev_run , prev_level ) ] - last_length [ UNI_AC_ENC_INDEX ( prev_run , prev_level ) ] ;\n }\n }\n }\n }\n else {\n new_coeff = 0 ;\n assert ( FFABS ( level ) == 1 ) ;\n if ( i < last_non_zero ) {\n int next_i = i + run2 + 1 ;\n int next_level = block [ perm_scantable [ next_i ] ] + 64 ;\n if ( next_level & ( ~ 127 ) ) next_level = 0 ;\n if ( next_i < last_non_zero ) score += length [ UNI_AC_ENC_INDEX ( run + run2 + 1 , next_level ) ] - length [ UNI_AC_ENC_INDEX ( run2 , next_level ) ] - length [ UNI_AC_ENC_INDEX ( run , 65 ) ] ;\n else score += last_length [ UNI_AC_ENC_INDEX ( run + run2 + 1 , next_level ) ] - last_length [ UNI_AC_ENC_INDEX ( run2 , next_level ) ] - length [ UNI_AC_ENC_INDEX ( run , 65 ) ] ;\n }\n else {\n score += - last_length [ UNI_AC_ENC_INDEX ( run , 65 ) ] ;\n if ( prev_level ) {\n score += last_length [ UNI_AC_ENC_INDEX ( prev_run , prev_level ) ] - length [ UNI_AC_ENC_INDEX ( prev_run , prev_level ) ] ;\n }\n }\n }\n score *= lambda ;\n unquant_change = new_coeff - old_coeff ;\n assert ( ( score < 100 * lambda && score > - 100 * lambda ) || lambda == 0 ) ;\n score += s -> dsp . try_8x8basis ( rem , weight , basis [ j ] , unquant_change ) ;\n if ( score < best_score ) {\n best_score = score ;\n best_coeff = i ;\n best_change = change ;\n best_unquant_change = unquant_change ;\n }\n }\n if ( level ) {\n prev_level = level + 64 ;\n if ( prev_level & ( ~ 127 ) ) prev_level = 0 ;\n prev_run = run ;\n run = 0 ;\n }\n else {\n run ++ ;\n }\n }\n # ifdef REFINE_STATS STOP_TIMER ( \"iterative step\" ) }\n # endif if ( best_change ) {\n int j = perm_scantable [ best_coeff ] ;\n block [ j ] += best_change ;\n if ( best_coeff > last_non_zero ) {\n last_non_zero = best_coeff ;\n assert ( block [ j ] ) ;\n # ifdef REFINE_STATS after_last ++ ;\n # endif }\n else {\n # ifdef REFINE_STATS if ( block [ j ] ) {\n if ( block [ j ] - best_change ) {\n if ( FFABS ( block [ j ] ) > FFABS ( block [ j ] - best_change ) ) {\n raise ++ ;\n }\n else {\n lower ++ ;\n }\n }\n else {\n from_zero ++ ;\n }\n }\n else {\n to_zero ++ ;\n }\n # endif for ( ;\n last_non_zero >= start_i ;\n last_non_zero -- ) {\n if ( block [ perm_scantable [ last_non_zero ] ] ) break ;\n }\n }\n # ifdef REFINE_STATS count ++ ;\n if ( 256 * 256 * 256 * 64 % count == 0 ) {\n printf ( \"after_last:%d to_zero:%d from_zero:%d raise:%d lower:%d sign:%d xyp:%d/%d/%d\\n\" , after_last , to_zero , from_zero , raise , lower , messed_sign , s -> mb_x , s -> mb_y , s -> picture_number ) ;\n }\n # endif run = 0 ;\n rle_index = 0 ;\n for ( i = start_i ;\n i <= last_non_zero ;\n i ++ ) {\n int j = perm_scantable [ i ] ;\n const int level = block [ j ] ;\n if ( level ) {\n run_tab [ rle_index ++ ] = run ;\n run = 0 ;\n }\n else {\n run ++ ;\n }\n }\n s -> dsp . add_8x8basis ( rem , basis [ j ] , best_unquant_change ) ;\n }\n else {\n break ;\n }\n }\n # ifdef REFINE_STATS if ( last_non_zero > 0 ) {\n STOP_TIMER ( \"iterative search\" ) }\n }\n # endif return last_non_zero ;\n }", "hash": -305162769887579921, "project": "debian", "size": 295, "target": 0, "idx": 2019}
{"code": "static inline void update_qscale ( MpegEncContext * s ) {\n s -> qscale = ( s -> lambda * 139 + FF_LAMBDA_SCALE * 64 ) >> ( FF_LAMBDA_SHIFT + 7 ) ;\n s -> qscale = av_clip ( s -> qscale , s -> avctx -> qmin , s -> avctx -> qmax ) ;\n s -> lambda2 = ( s -> lambda * s -> lambda + FF_LAMBDA_SCALE / 2 ) >> FF_LAMBDA_SHIFT ;\n }", "hash": -305162769887579921, "project": "debian", "size": 5, "target": 0, "idx": 2034}
{"code": "static inline void dct_single_coeff_elimination ( MpegEncContext * s , int n , int threshold ) {\n static const char tab [ 64 ] = {\n 3 , 2 , 2 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 }\n ;\n int score = 0 ;\n int run = 0 ;\n int i ;\n int16_t * block = s -> block [ n ] ;\n const int last_index = s -> block_last_index [ n ] ;\n int skip_dc ;\n if ( threshold < 0 ) {\n skip_dc = 0 ;\n threshold = - threshold ;\n }\n else skip_dc = 1 ;\n if ( last_index <= skip_dc - 1 ) return ;\n for ( i = 0 ;\n i <= last_index ;\n i ++ ) {\n const int j = s -> intra_scantable . permutated [ i ] ;\n const int level = FFABS ( block [ j ] ) ;\n if ( level == 1 ) {\n if ( skip_dc && i == 0 ) continue ;\n score += tab [ run ] ;\n run = 0 ;\n }\n else if ( level > 1 ) {\n return ;\n }\n else {\n run ++ ;\n }\n }\n if ( score >= threshold ) return ;\n for ( i = skip_dc ;\n i <= last_index ;\n i ++ ) {\n const int j = s -> intra_scantable . permutated [ i ] ;\n block [ j ] = 0 ;\n }\n if ( block [ 0 ] ) s -> block_last_index [ n ] = 0 ;\n else s -> block_last_index [ n ] = - 1 ;\n }", "hash": -305162769887579921, "project": "debian", "size": 43, "target": 0, "idx": 2042}
{"code": "static int autocorr_max ( const int16_t * buf , int offset , int * ccr_max , int pitch_lag , int length , int dir ) {\n int limit , ccr , lag = 0 ;\n int i ;\n pitch_lag = FFMIN ( PITCH_MAX - 3 , pitch_lag ) ;\n if ( dir > 0 ) limit = FFMIN ( FRAME_LEN + PITCH_MAX - offset - length , pitch_lag + 3 ) ;\n else limit = pitch_lag + 3 ;\n for ( i = pitch_lag - 3 ;\n i <= limit ;\n i ++ ) {\n ccr = dot_product ( buf , buf + dir * i , length ) ;\n if ( ccr > * ccr_max ) {\n * ccr_max = ccr ;\n lag = i ;\n }\n }\n return lag ;\n }", "hash": -2591112946600337077, "project": "debian", "size": 17, "target": 0, "idx": 2064}
{"code": "static void get_residual ( int16_t * residual , int16_t * prev_excitation , int lag ) {\n int offset = PITCH_MAX - PITCH_ORDER / 2 - lag ;\n int i ;\n residual [ 0 ] = prev_excitation [ offset ] ;\n residual [ 1 ] = prev_excitation [ offset + 1 ] ;\n offset += 2 ;\n for ( i = 2 ;\n i < SUBFRAME_LEN + PITCH_ORDER - 1 ;\n i ++ ) residual [ i ] = prev_excitation [ offset + ( i - 2 ) % lag ] ;\n }", "hash": -2591112946600337077, "project": "debian", "size": 10, "target": 0, "idx": 2066}
{"code": "static void residual_interp ( int16_t * buf , int16_t * out , int lag , int gain , int * rseed ) {\n int i ;\n if ( lag ) {\n int16_t * vector_ptr = buf + PITCH_MAX ;\n for ( i = 0 ;\n i < lag ;\n i ++ ) out [ i ] = vector_ptr [ i - lag ] * 3 >> 2 ;\n av_memcpy_backptr ( ( uint8_t * ) ( out + lag ) , lag * sizeof ( * out ) , ( FRAME_LEN - lag ) * sizeof ( * out ) ) ;\n }\n else {\n for ( i = 0 ;\n i < FRAME_LEN ;\n i ++ ) {\n * rseed = * rseed * 521 + 259 ;\n out [ i ] = gain * * rseed >> 15 ;\n }\n memset ( buf , 0 , ( FRAME_LEN + PITCH_MAX ) * sizeof ( * buf ) ) ;\n }\n }", "hash": -2591112946600337077, "project": "debian", "size": 19, "target": 0, "idx": 2067}
{"code": "static int libschroedinger_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int64_t pts = avpkt -> pts ;\n SchroTag * tag ;\n SchroDecoderParams * p_schro_params = avctx -> priv_data ;\n SchroDecoder * decoder = p_schro_params -> decoder ;\n SchroBuffer * enc_buf ;\n SchroFrame * frame ;\n AVFrame * avframe = data ;\n int state ;\n int go = 1 ;\n int outer = 1 ;\n SchroParseUnitContext parse_ctx ;\n LibSchroFrameContext * framewithpts = NULL ;\n * got_frame = 0 ;\n parse_context_init ( & parse_ctx , buf , buf_size ) ;\n if ( ! buf_size ) {\n if ( ! p_schro_params -> eos_signalled ) {\n state = schro_decoder_push_end_of_stream ( decoder ) ;\n p_schro_params -> eos_signalled = 1 ;\n }\n }\n do {\n if ( ( enc_buf = find_next_parse_unit ( & parse_ctx ) ) ) {\n enc_buf -> tag = schro_tag_new ( av_malloc ( sizeof ( int64_t ) ) , av_free ) ;\n if ( ! enc_buf -> tag -> value ) {\n av_log ( avctx , AV_LOG_ERROR , \"Unable to allocate SchroTag\\n\" ) ;\n return AVERROR ( ENOMEM ) ;\n }\n AV_WN ( 64 , enc_buf -> tag -> value , pts ) ;\n if ( SCHRO_PARSE_CODE_IS_PICTURE ( enc_buf -> data [ 4 ] ) && SCHRO_PARSE_CODE_NUM_REFS ( enc_buf -> data [ 4 ] ) > 0 ) avctx -> has_b_frames = 1 ;\n state = schro_decoder_push ( decoder , enc_buf ) ;\n if ( state == SCHRO_DECODER_FIRST_ACCESS_UNIT ) libschroedinger_handle_first_access_unit ( avctx ) ;\n go = 1 ;\n }\n else outer = 0 ;\n while ( go ) {\n state = schro_decoder_wait ( decoder ) ;\n switch ( state ) {\n case SCHRO_DECODER_FIRST_ACCESS_UNIT : libschroedinger_handle_first_access_unit ( avctx ) ;\n break ;\n case SCHRO_DECODER_NEED_BITS : go = 0 ;\n break ;\n case SCHRO_DECODER_NEED_FRAME : frame = ff_create_schro_frame ( avctx , p_schro_params -> frame_format ) ;\n schro_decoder_add_output_picture ( decoder , frame ) ;\n break ;\n case SCHRO_DECODER_OK : tag = schro_decoder_get_picture_tag ( decoder ) ;\n frame = schro_decoder_pull ( decoder ) ;\n if ( frame ) {\n framewithpts = av_malloc ( sizeof ( LibSchroFrameContext ) ) ;\n if ( ! framewithpts ) {\n av_log ( avctx , AV_LOG_ERROR , \"Unable to allocate FrameWithPts\\n\" ) ;\n return AVERROR ( ENOMEM ) ;\n }\n framewithpts -> frame = frame ;\n framewithpts -> pts = AV_RN64 ( tag -> value ) ;\n ff_schro_queue_push_back ( & p_schro_params -> dec_frame_queue , framewithpts ) ;\n }\n break ;\n case SCHRO_DECODER_EOS : go = 0 ;\n p_schro_params -> eos_pulled = 1 ;\n schro_decoder_reset ( decoder ) ;\n outer = 0 ;\n break ;\n case SCHRO_DECODER_ERROR : return - 1 ;\n break ;\n }\n }\n }\n while ( outer ) ;\n framewithpts = ff_schro_queue_pop ( & p_schro_params -> dec_frame_queue ) ;\n if ( framewithpts && framewithpts -> frame ) {\n if ( ff_get_buffer ( avctx , avframe , 0 ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Unable to allocate buffer\\n\" ) ;\n return AVERROR ( ENOMEM ) ;\n }\n memcpy ( avframe -> data [ 0 ] , framewithpts -> frame -> components [ 0 ] . data , framewithpts -> frame -> components [ 0 ] . length ) ;\n memcpy ( avframe -> data [ 1 ] , framewithpts -> frame -> components [ 1 ] . data , framewithpts -> frame -> components [ 1 ] . length ) ;\n memcpy ( avframe -> data [ 2 ] , framewithpts -> frame -> components [ 2 ] . data , framewithpts -> frame -> components [ 2 ] . length ) ;\n avframe -> pkt_pts = framewithpts -> pts ;\n avframe -> linesize [ 0 ] = framewithpts -> frame -> components [ 0 ] . stride ;\n avframe -> linesize [ 1 ] = framewithpts -> frame -> components [ 1 ] . stride ;\n avframe -> linesize [ 2 ] = framewithpts -> frame -> components [ 2 ] . stride ;\n * got_frame = 1 ;\n libschroedinger_decode_frame_free ( framewithpts -> frame ) ;\n av_free ( framewithpts ) ;\n }\n else {\n data = NULL ;\n * got_frame = 0 ;\n }\n return buf_size ;\n }", "hash": -938099838013462850, "project": "debian", "size": 94, "target": 0, "idx": 2096}
{"code": "static inline void get_array ( GetBitContext * gb , int * dst , int len , int bits ) {\n while ( len -- ) * dst ++ = get_bits ( gb , bits ) ;\n }", "hash": -6068399010699045437, "project": "debian", "size": 3, "target": 0, "idx": 2100}
{"code": "static void ulti_grad ( AVFrame * frame , int x , int y , uint8_t * Y , int chroma , int angle ) {\n uint8_t Luma [ 16 ] ;\n if ( angle & 8 ) {\n int t ;\n angle &= 0x7 ;\n t = Y [ 0 ] ;\n Y [ 0 ] = Y [ 3 ] ;\n Y [ 3 ] = t ;\n t = Y [ 1 ] ;\n Y [ 1 ] = Y [ 2 ] ;\n Y [ 2 ] = t ;\n }\n switch ( angle ) {\n case 0 : Luma [ 0 ] = Y [ 0 ] ;\n Luma [ 1 ] = Y [ 1 ] ;\n Luma [ 2 ] = Y [ 2 ] ;\n Luma [ 3 ] = Y [ 3 ] ;\n Luma [ 4 ] = Y [ 0 ] ;\n Luma [ 5 ] = Y [ 1 ] ;\n Luma [ 6 ] = Y [ 2 ] ;\n Luma [ 7 ] = Y [ 3 ] ;\n Luma [ 8 ] = Y [ 0 ] ;\n Luma [ 9 ] = Y [ 1 ] ;\n Luma [ 10 ] = Y [ 2 ] ;\n Luma [ 11 ] = Y [ 3 ] ;\n Luma [ 12 ] = Y [ 0 ] ;\n Luma [ 13 ] = Y [ 1 ] ;\n Luma [ 14 ] = Y [ 2 ] ;\n Luma [ 15 ] = Y [ 3 ] ;\n break ;\n case 1 : Luma [ 0 ] = Y [ 1 ] ;\n Luma [ 1 ] = Y [ 2 ] ;\n Luma [ 2 ] = Y [ 3 ] ;\n Luma [ 3 ] = Y [ 3 ] ;\n Luma [ 4 ] = Y [ 0 ] ;\n Luma [ 5 ] = Y [ 1 ] ;\n Luma [ 6 ] = Y [ 2 ] ;\n Luma [ 7 ] = Y [ 3 ] ;\n Luma [ 8 ] = Y [ 0 ] ;\n Luma [ 9 ] = Y [ 1 ] ;\n Luma [ 10 ] = Y [ 2 ] ;\n Luma [ 11 ] = Y [ 3 ] ;\n Luma [ 12 ] = Y [ 0 ] ;\n Luma [ 13 ] = Y [ 0 ] ;\n Luma [ 14 ] = Y [ 1 ] ;\n Luma [ 15 ] = Y [ 2 ] ;\n break ;\n case 2 : Luma [ 0 ] = Y [ 1 ] ;\n Luma [ 1 ] = Y [ 2 ] ;\n Luma [ 2 ] = Y [ 3 ] ;\n Luma [ 3 ] = Y [ 3 ] ;\n Luma [ 4 ] = Y [ 1 ] ;\n Luma [ 5 ] = Y [ 2 ] ;\n Luma [ 6 ] = Y [ 2 ] ;\n Luma [ 7 ] = Y [ 3 ] ;\n Luma [ 8 ] = Y [ 0 ] ;\n Luma [ 9 ] = Y [ 1 ] ;\n Luma [ 10 ] = Y [ 1 ] ;\n Luma [ 11 ] = Y [ 2 ] ;\n Luma [ 12 ] = Y [ 0 ] ;\n Luma [ 13 ] = Y [ 0 ] ;\n Luma [ 14 ] = Y [ 1 ] ;\n Luma [ 15 ] = Y [ 2 ] ;\n break ;\n case 3 : Luma [ 0 ] = Y [ 2 ] ;\n Luma [ 1 ] = Y [ 3 ] ;\n Luma [ 2 ] = Y [ 3 ] ;\n Luma [ 3 ] = Y [ 3 ] ;\n Luma [ 4 ] = Y [ 1 ] ;\n Luma [ 5 ] = Y [ 2 ] ;\n Luma [ 6 ] = Y [ 2 ] ;\n Luma [ 7 ] = Y [ 3 ] ;\n Luma [ 8 ] = Y [ 0 ] ;\n Luma [ 9 ] = Y [ 1 ] ;\n Luma [ 10 ] = Y [ 1 ] ;\n Luma [ 11 ] = Y [ 2 ] ;\n Luma [ 12 ] = Y [ 0 ] ;\n Luma [ 13 ] = Y [ 0 ] ;\n Luma [ 14 ] = Y [ 0 ] ;\n Luma [ 15 ] = Y [ 1 ] ;\n break ;\n case 4 : Luma [ 0 ] = Y [ 3 ] ;\n Luma [ 1 ] = Y [ 3 ] ;\n Luma [ 2 ] = Y [ 3 ] ;\n Luma [ 3 ] = Y [ 3 ] ;\n Luma [ 4 ] = Y [ 2 ] ;\n Luma [ 5 ] = Y [ 2 ] ;\n Luma [ 6 ] = Y [ 2 ] ;\n Luma [ 7 ] = Y [ 2 ] ;\n Luma [ 8 ] = Y [ 1 ] ;\n Luma [ 9 ] = Y [ 1 ] ;\n Luma [ 10 ] = Y [ 1 ] ;\n Luma [ 11 ] = Y [ 1 ] ;\n Luma [ 12 ] = Y [ 0 ] ;\n Luma [ 13 ] = Y [ 0 ] ;\n Luma [ 14 ] = Y [ 0 ] ;\n Luma [ 15 ] = Y [ 0 ] ;\n break ;\n case 5 : Luma [ 0 ] = Y [ 3 ] ;\n Luma [ 1 ] = Y [ 3 ] ;\n Luma [ 2 ] = Y [ 3 ] ;\n Luma [ 3 ] = Y [ 2 ] ;\n Luma [ 4 ] = Y [ 3 ] ;\n Luma [ 5 ] = Y [ 2 ] ;\n Luma [ 6 ] = Y [ 2 ] ;\n Luma [ 7 ] = Y [ 1 ] ;\n Luma [ 8 ] = Y [ 2 ] ;\n Luma [ 9 ] = Y [ 1 ] ;\n Luma [ 10 ] = Y [ 1 ] ;\n Luma [ 11 ] = Y [ 0 ] ;\n Luma [ 12 ] = Y [ 1 ] ;\n Luma [ 13 ] = Y [ 0 ] ;\n Luma [ 14 ] = Y [ 0 ] ;\n Luma [ 15 ] = Y [ 0 ] ;\n break ;\n case 6 : Luma [ 0 ] = Y [ 3 ] ;\n Luma [ 1 ] = Y [ 3 ] ;\n Luma [ 2 ] = Y [ 2 ] ;\n Luma [ 3 ] = Y [ 2 ] ;\n Luma [ 4 ] = Y [ 3 ] ;\n Luma [ 5 ] = Y [ 2 ] ;\n Luma [ 6 ] = Y [ 1 ] ;\n Luma [ 7 ] = Y [ 1 ] ;\n Luma [ 8 ] = Y [ 2 ] ;\n Luma [ 9 ] = Y [ 2 ] ;\n Luma [ 10 ] = Y [ 1 ] ;\n Luma [ 11 ] = Y [ 0 ] ;\n Luma [ 12 ] = Y [ 1 ] ;\n Luma [ 13 ] = Y [ 1 ] ;\n Luma [ 14 ] = Y [ 0 ] ;\n Luma [ 15 ] = Y [ 0 ] ;\n break ;\n case 7 : Luma [ 0 ] = Y [ 3 ] ;\n Luma [ 1 ] = Y [ 3 ] ;\n Luma [ 2 ] = Y [ 2 ] ;\n Luma [ 3 ] = Y [ 1 ] ;\n Luma [ 4 ] = Y [ 3 ] ;\n Luma [ 5 ] = Y [ 2 ] ;\n Luma [ 6 ] = Y [ 1 ] ;\n Luma [ 7 ] = Y [ 0 ] ;\n Luma [ 8 ] = Y [ 3 ] ;\n Luma [ 9 ] = Y [ 2 ] ;\n Luma [ 10 ] = Y [ 1 ] ;\n Luma [ 11 ] = Y [ 0 ] ;\n Luma [ 12 ] = Y [ 2 ] ;\n Luma [ 13 ] = Y [ 1 ] ;\n Luma [ 14 ] = Y [ 0 ] ;\n Luma [ 15 ] = Y [ 0 ] ;\n break ;\n default : Luma [ 0 ] = Y [ 0 ] ;\n Luma [ 1 ] = Y [ 0 ] ;\n Luma [ 2 ] = Y [ 1 ] ;\n Luma [ 3 ] = Y [ 1 ] ;\n Luma [ 4 ] = Y [ 0 ] ;\n Luma [ 5 ] = Y [ 0 ] ;\n Luma [ 6 ] = Y [ 1 ] ;\n Luma [ 7 ] = Y [ 1 ] ;\n Luma [ 8 ] = Y [ 2 ] ;\n Luma [ 9 ] = Y [ 2 ] ;\n Luma [ 10 ] = Y [ 3 ] ;\n Luma [ 11 ] = Y [ 3 ] ;\n Luma [ 12 ] = Y [ 2 ] ;\n Luma [ 13 ] = Y [ 2 ] ;\n Luma [ 14 ] = Y [ 3 ] ;\n Luma [ 15 ] = Y [ 3 ] ;\n break ;\n }\n ulti_convert_yuv ( frame , x , y , Luma , chroma ) ;\n }", "hash": 4025891488552660940, "project": "debian", "size": 169, "target": 0, "idx": 2132}
{"code": "static inline void modify_pred ( const int8_t * mod_table , int * mode ) {\n * mode = mod_table [ * mode ] ;\n if ( * mode < 0 ) {\n av_log ( NULL , AV_LOG_ERROR , \"Illegal intra prediction mode\\n\" ) ;\n * mode = 0 ;\n }\n }", "hash": 7279312193592248512, "project": "debian", "size": 7, "target": 0, "idx": 2136}
{"code": "static void intra_pred_lp_top ( uint8_t * d , uint8_t * top , uint8_t * left , int stride ) {\n int x , y ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) for ( x = 0 ;\n x < 8 ;\n x ++ ) d [ y * stride + x ] = LOWPASS ( top , x + 1 ) ;\n }", "hash": 7279312193592248512, "project": "debian", "size": 8, "target": 0, "idx": 2146}
{"code": "void ff_cavs_init_top_lines ( AVSContext * h ) {\n h -> top_qp = av_mallocz ( h -> mb_width ) ;\n h -> top_mv [ 0 ] = av_mallocz ( ( h -> mb_width * 2 + 1 ) * sizeof ( cavs_vector ) ) ;\n h -> top_mv [ 1 ] = av_mallocz ( ( h -> mb_width * 2 + 1 ) * sizeof ( cavs_vector ) ) ;\n h -> top_pred_Y = av_mallocz ( h -> mb_width * 2 * sizeof ( * h -> top_pred_Y ) ) ;\n h -> top_border_y = av_mallocz ( ( h -> mb_width + 1 ) * 16 ) ;\n h -> top_border_u = av_mallocz ( h -> mb_width * 10 ) ;\n h -> top_border_v = av_mallocz ( h -> mb_width * 10 ) ;\n h -> col_mv = av_mallocz ( h -> mb_width * h -> mb_height * 4 * sizeof ( cavs_vector ) ) ;\n h -> col_type_base = av_mallocz ( h -> mb_width * h -> mb_height ) ;\n h -> block = av_mallocz ( 64 * sizeof ( int16_t ) ) ;\n }", "hash": 7279312193592248512, "project": "debian", "size": 12, "target": 0, "idx": 2150}
{"code": "static void init_2d_vlc_rl ( RLTable * rl ) {\n int i ;\n for ( i = 0 ;\n i < rl -> vlc . table_size ;\n i ++ ) {\n int code = rl -> vlc . table [ i ] [ 0 ] ;\n int len = rl -> vlc . table [ i ] [ 1 ] ;\n int level , run ;\n if ( len == 0 ) {\n run = 65 ;\n level = MAX_LEVEL ;\n }\n else if ( len < 0 ) {\n run = 0 ;\n level = code ;\n }\n else {\n if ( code == rl -> n ) {\n run = 65 ;\n level = 0 ;\n }\n else if ( code == rl -> n + 1 ) {\n run = 0 ;\n level = 127 ;\n }\n else {\n run = rl -> table_run [ code ] + 1 ;\n level = rl -> table_level [ code ] ;\n }\n }\n rl -> rl_vlc [ 0 ] [ i ] . len = len ;\n rl -> rl_vlc [ 0 ] [ i ] . level = level ;\n rl -> rl_vlc [ 0 ] [ i ] . run = run ;\n }\n }", "hash": -6435087038712482873, "project": "debian", "size": 35, "target": 0, "idx": 2175}
{"code": "static inline int get_qscale ( MpegEncContext * s ) {\n int qscale = get_bits ( & s -> gb , 5 ) ;\n if ( s -> q_scale_type ) {\n return non_linear_qscale [ qscale ] ;\n }\n else {\n return qscale << 1 ;\n }\n }", "hash": -6435087038712482873, "project": "debian", "size": 9, "target": 0, "idx": 2178}
{"code": "static int mpeg1_decode_picture ( AVCodecContext * avctx , const uint8_t * buf , int buf_size ) {\n Mpeg1Context * s1 = avctx -> priv_data ;\n MpegEncContext * s = & s1 -> mpeg_enc_ctx ;\n int ref , f_code , vbv_delay ;\n init_get_bits ( & s -> gb , buf , buf_size * 8 ) ;\n ref = get_bits ( & s -> gb , 10 ) ;\n s -> pict_type = get_bits ( & s -> gb , 3 ) ;\n if ( s -> pict_type == 0 || s -> pict_type > 3 ) return - 1 ;\n vbv_delay = get_bits ( & s -> gb , 16 ) ;\n if ( s -> pict_type == AV_PICTURE_TYPE_P || s -> pict_type == AV_PICTURE_TYPE_B ) {\n s -> full_pel [ 0 ] = get_bits1 ( & s -> gb ) ;\n f_code = get_bits ( & s -> gb , 3 ) ;\n if ( f_code == 0 && ( avctx -> err_recognition & AV_EF_BITSTREAM ) ) return - 1 ;\n s -> mpeg_f_code [ 0 ] [ 0 ] = f_code ;\n s -> mpeg_f_code [ 0 ] [ 1 ] = f_code ;\n }\n if ( s -> pict_type == AV_PICTURE_TYPE_B ) {\n s -> full_pel [ 1 ] = get_bits1 ( & s -> gb ) ;\n f_code = get_bits ( & s -> gb , 3 ) ;\n if ( f_code == 0 && ( avctx -> err_recognition & AV_EF_BITSTREAM ) ) return - 1 ;\n s -> mpeg_f_code [ 1 ] [ 0 ] = f_code ;\n s -> mpeg_f_code [ 1 ] [ 1 ] = f_code ;\n }\n s -> current_picture . f . pict_type = s -> pict_type ;\n s -> current_picture . f . key_frame = s -> pict_type == AV_PICTURE_TYPE_I ;\n if ( avctx -> debug & FF_DEBUG_PICT_INFO ) av_log ( avctx , AV_LOG_DEBUG , \"vbv_delay %d, ref %d type:%d\\n\" , vbv_delay , ref , s -> pict_type ) ;\n s -> y_dc_scale = 8 ;\n s -> c_dc_scale = 8 ;\n return 0 ;\n }", "hash": -6435087038712482873, "project": "debian", "size": 30, "target": 0, "idx": 2181}
{"code": "void ff_add_png_paeth_prediction ( uint8_t * dst , uint8_t * src , uint8_t * top , int w , int bpp ) {\n int i ;\n for ( i = 0 ;\n i < w ;\n i ++ ) {\n int a , b , c , p , pa , pb , pc ;\n a = dst [ i - bpp ] ;\n b = top [ i ] ;\n c = top [ i - bpp ] ;\n p = b - c ;\n pc = a - c ;\n pa = abs ( p ) ;\n pb = abs ( pc ) ;\n pc = abs ( p + pc ) ;\n if ( pa <= pb && pa <= pc ) p = a ;\n else if ( pb <= pc ) p = b ;\n else p = c ;\n dst [ i ] = p + src [ i ] ;\n }\n }", "hash": -4433254577494420260, "project": "debian", "size": 20, "target": 0, "idx": 2206}
{"code": "static void png_filter_row ( PNGDSPContext * dsp , uint8_t * dst , int filter_type , uint8_t * src , uint8_t * last , int size , int bpp ) {\n int i , p , r , g , b , a ;\n switch ( filter_type ) {\n case PNG_FILTER_VALUE_NONE : memcpy ( dst , src , size ) ;\n break ;\n case PNG_FILTER_VALUE_SUB : for ( i = 0 ;\n i < bpp ;\n i ++ ) {\n dst [ i ] = src [ i ] ;\n }\n if ( bpp == 4 ) {\n p = * ( int * ) dst ;\n for ( ;\n i < size ;\n i += bpp ) {\n int s = * ( int * ) ( src + i ) ;\n p = ( ( s & 0x7f7f7f7f ) + ( p & 0x7f7f7f7f ) ) ^ ( ( s ^ p ) & 0x80808080 ) ;\n * ( int * ) ( dst + i ) = p ;\n }\n }\n else {\n # define OP_SUB ( x , s , l ) x + s UNROLL_FILTER ( OP_SUB ) ;\n }\n break ;\n case PNG_FILTER_VALUE_UP : dsp -> add_bytes_l2 ( dst , src , last , size ) ;\n break ;\n case PNG_FILTER_VALUE_AVG : for ( i = 0 ;\n i < bpp ;\n i ++ ) {\n p = ( last [ i ] >> 1 ) ;\n dst [ i ] = p + src [ i ] ;\n }\n # define OP_AVG ( x , s , l ) ( ( ( x + l ) >> 1 ) + s ) & 0xff UNROLL_FILTER ( OP_AVG ) ;\n break ;\n case PNG_FILTER_VALUE_PAETH : for ( i = 0 ;\n i < bpp ;\n i ++ ) {\n p = last [ i ] ;\n dst [ i ] = p + src [ i ] ;\n }\n if ( bpp > 1 && size > 4 ) {\n int w = bpp == 4 ? size : size - 3 ;\n dsp -> add_paeth_prediction ( dst + i , src + i , last + i , w - i , bpp ) ;\n i = w ;\n }\n ff_add_png_paeth_prediction ( dst + i , src + i , last + i , size - i , bpp ) ;\n break ;\n }\n }", "hash": -4433254577494420260, "project": "debian", "size": 49, "target": 0, "idx": 2209}
{"code": "void ff_fix_long_mvs ( MpegEncContext * s , uint8_t * field_select_table , int field_select , int16_t ( * mv_table ) [ 2 ] , int f_code , int type , int truncate ) {\n MotionEstContext * const c = & s -> me ;\n int y , h_range , v_range ;\n int range = ( ( ( s -> out_format == FMT_MPEG1 || s -> msmpeg4_version ) ? 8 : 16 ) << f_code ) ;\n if ( c -> avctx -> me_range && range > c -> avctx -> me_range ) range = c -> avctx -> me_range ;\n h_range = range ;\n v_range = field_select_table ? range >> 1 : range ;\n for ( y = 0 ;\n y < s -> mb_height ;\n y ++ ) {\n int x ;\n int xy = y * s -> mb_stride ;\n for ( x = 0 ;\n x < s -> mb_width ;\n x ++ ) {\n if ( s -> mb_type [ xy ] & type ) {\n if ( field_select_table == NULL || field_select_table [ xy ] == field_select ) {\n if ( mv_table [ xy ] [ 0 ] >= h_range || mv_table [ xy ] [ 0 ] < - h_range || mv_table [ xy ] [ 1 ] >= v_range || mv_table [ xy ] [ 1 ] < - v_range ) {\n if ( truncate ) {\n if ( mv_table [ xy ] [ 0 ] > h_range - 1 ) mv_table [ xy ] [ 0 ] = h_range - 1 ;\n else if ( mv_table [ xy ] [ 0 ] < - h_range ) mv_table [ xy ] [ 0 ] = - h_range ;\n if ( mv_table [ xy ] [ 1 ] > v_range - 1 ) mv_table [ xy ] [ 1 ] = v_range - 1 ;\n else if ( mv_table [ xy ] [ 1 ] < - v_range ) mv_table [ xy ] [ 1 ] = - v_range ;\n }\n else {\n s -> mb_type [ xy ] &= ~ type ;\n s -> mb_type [ xy ] |= CANDIDATE_MB_TYPE_INTRA ;\n mv_table [ xy ] [ 0 ] = mv_table [ xy ] [ 1 ] = 0 ;\n }\n }\n }\n }\n xy ++ ;\n }\n }\n }", "hash": 1788300783882316916, "project": "debian", "size": 36, "target": 0, "idx": 2237}
{"code": "static int ivi_process_empty_tile ( AVCodecContext * avctx , IVIBandDesc * band , IVITile * tile , int32_t mv_scale ) {\n int x , y , need_mc , mbn , blk , num_blocks , mv_x , mv_y , mc_type ;\n int offs , mb_offset , row_offset ;\n IVIMbInfo * mb , * ref_mb ;\n const int16_t * src ;\n int16_t * dst ;\n void ( * mc_no_delta_func ) ( int16_t * buf , const int16_t * ref_buf , uint32_t pitch , int mc_type ) ;\n if ( tile -> num_MBs != IVI_MBs_PER_TILE ( tile -> width , tile -> height , band -> mb_size ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Allocated tile size %d mismatches \" \"parameters %d in ivi_process_empty_tile()\\n\" , tile -> num_MBs , IVI_MBs_PER_TILE ( tile -> width , tile -> height , band -> mb_size ) ) ;\n return AVERROR_INVALIDDATA ;\n }\n offs = tile -> ypos * band -> pitch + tile -> xpos ;\n mb = tile -> mbs ;\n ref_mb = tile -> ref_mbs ;\n row_offset = band -> mb_size * band -> pitch ;\n need_mc = 0 ;\n for ( y = tile -> ypos ;\n y < ( tile -> ypos + tile -> height ) ;\n y += band -> mb_size ) {\n mb_offset = offs ;\n for ( x = tile -> xpos ;\n x < ( tile -> xpos + tile -> width ) ;\n x += band -> mb_size ) {\n mb -> xpos = x ;\n mb -> ypos = y ;\n mb -> buf_offs = mb_offset ;\n mb -> type = 1 ;\n mb -> cbp = 0 ;\n if ( ! band -> qdelta_present && ! band -> plane && ! band -> band_num ) {\n mb -> q_delta = band -> glob_quant ;\n mb -> mv_x = 0 ;\n mb -> mv_y = 0 ;\n }\n if ( band -> inherit_qdelta && ref_mb ) mb -> q_delta = ref_mb -> q_delta ;\n if ( band -> inherit_mv ) {\n if ( mv_scale ) {\n mb -> mv_x = ivi_scale_mv ( ref_mb -> mv_x , mv_scale ) ;\n mb -> mv_y = ivi_scale_mv ( ref_mb -> mv_y , mv_scale ) ;\n }\n else {\n mb -> mv_x = ref_mb -> mv_x ;\n mb -> mv_y = ref_mb -> mv_y ;\n }\n need_mc |= mb -> mv_x || mb -> mv_y ;\n }\n mb ++ ;\n if ( ref_mb ) ref_mb ++ ;\n mb_offset += band -> mb_size ;\n }\n offs += row_offset ;\n }\n if ( band -> inherit_mv && need_mc ) {\n num_blocks = ( band -> mb_size != band -> blk_size ) ? 4 : 1 ;\n mc_no_delta_func = ( band -> blk_size == 8 ) ? ff_ivi_mc_8x8_no_delta : ff_ivi_mc_4x4_no_delta ;\n for ( mbn = 0 , mb = tile -> mbs ;\n mbn < tile -> num_MBs ;\n mb ++ , mbn ++ ) {\n mv_x = mb -> mv_x ;\n mv_y = mb -> mv_y ;\n if ( ! band -> is_halfpel ) {\n mc_type = 0 ;\n }\n else {\n mc_type = ( ( mv_y & 1 ) << 1 ) | ( mv_x & 1 ) ;\n mv_x >>= 1 ;\n mv_y >>= 1 ;\n }\n for ( blk = 0 ;\n blk < num_blocks ;\n blk ++ ) {\n offs = mb -> buf_offs + band -> blk_size * ( ( blk & 1 ) + ! ! ( blk & 2 ) * band -> pitch ) ;\n mc_no_delta_func ( band -> buf + offs , band -> ref_buf + offs + mv_y * band -> pitch + mv_x , band -> pitch , mc_type ) ;\n }\n }\n }\n else {\n src = band -> ref_buf + tile -> ypos * band -> pitch + tile -> xpos ;\n dst = band -> buf + tile -> ypos * band -> pitch + tile -> xpos ;\n for ( y = 0 ;\n y < tile -> height ;\n y ++ ) {\n memcpy ( dst , src , tile -> width * sizeof ( band -> buf [ 0 ] ) ) ;\n src += band -> pitch ;\n dst += band -> pitch ;\n }\n }\n return 0 ;\n }", "hash": -2222758297961835509, "project": "debian", "size": 88, "target": 0, "idx": 2249}
{"code": "static void ivi_output_plane ( IVIPlaneDesc * plane , uint8_t * dst , int dst_pitch ) {\n int x , y ;\n const int16_t * src = plane -> bands [ 0 ] . buf ;\n uint32_t pitch = plane -> bands [ 0 ] . pitch ;\n if ( ! src ) return ;\n for ( y = 0 ;\n y < plane -> height ;\n y ++ ) {\n for ( x = 0 ;\n x < plane -> width ;\n x ++ ) dst [ x ] = av_clip_uint8 ( src [ x ] + 128 ) ;\n src += pitch ;\n dst += dst_pitch ;\n }\n }", "hash": -2222758297961835509, "project": "debian", "size": 15, "target": 0, "idx": 2252}
{"code": "static int arith_get_prob ( ArithCoder * c , int16_t * probs ) {\n int range = c -> high - c -> low + 1 ;\n int val = ( ( c -> value - c -> low + 1 ) * probs [ 0 ] - 1 ) / range ;\n int sym = 1 ;\n while ( probs [ sym ] > val ) sym ++ ;\n c -> high = range * probs [ sym - 1 ] / probs [ 0 ] + c -> low - 1 ;\n c -> low += range * probs [ sym ] / probs [ 0 ] ;\n return sym ;\n }", "hash": 4724375811251028572, "project": "debian", "size": 9, "target": 0, "idx": 2264}
{"code": "static int flic_decode_frame_8BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n FlicDecodeContext * s = avctx -> priv_data ;\n GetByteContext g2 ;\n int stream_ptr_after_color_chunk ;\n int pixel_ptr ;\n int palette_ptr ;\n unsigned char palette_idx1 ;\n unsigned char palette_idx2 ;\n unsigned int frame_size ;\n int num_chunks ;\n unsigned int chunk_size ;\n int chunk_type ;\n int i , j , ret ;\n int color_packets ;\n int color_changes ;\n int color_shift ;\n unsigned char r , g , b ;\n int lines ;\n int compressed_lines ;\n int starting_line ;\n signed short line_packets ;\n int y_ptr ;\n int byte_run ;\n int pixel_skip ;\n int pixel_countdown ;\n unsigned char * pixels ;\n unsigned int pixel_limit ;\n bytestream2_init ( & g2 , buf , buf_size ) ;\n if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n pixels = s -> frame . data [ 0 ] ;\n pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ] ;\n frame_size = bytestream2_get_le32 ( & g2 ) ;\n bytestream2_skip ( & g2 , 2 ) ;\n num_chunks = bytestream2_get_le16 ( & g2 ) ;\n bytestream2_skip ( & g2 , 8 ) ;\n frame_size -= 16 ;\n while ( ( frame_size > 0 ) && ( num_chunks > 0 ) ) {\n chunk_size = bytestream2_get_le32 ( & g2 ) ;\n chunk_type = bytestream2_get_le16 ( & g2 ) ;\n switch ( chunk_type ) {\n case FLI_256_COLOR : case FLI_COLOR : stream_ptr_after_color_chunk = bytestream2_tell ( & g2 ) + chunk_size - 6 ;\n if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) ) color_shift = 0 ;\n else color_shift = 2 ;\n color_packets = bytestream2_get_le16 ( & g2 ) ;\n palette_ptr = 0 ;\n for ( i = 0 ;\n i < color_packets ;\n i ++ ) {\n palette_ptr += bytestream2_get_byte ( & g2 ) ;\n color_changes = bytestream2_get_byte ( & g2 ) ;\n if ( color_changes == 0 ) color_changes = 256 ;\n for ( j = 0 ;\n j < color_changes ;\n j ++ ) {\n unsigned int entry ;\n if ( ( unsigned ) palette_ptr >= 256 ) palette_ptr = 0 ;\n r = bytestream2_get_byte ( & g2 ) << color_shift ;\n g = bytestream2_get_byte ( & g2 ) << color_shift ;\n b = bytestream2_get_byte ( & g2 ) << color_shift ;\n entry = ( r << 16 ) | ( g << 8 ) | b ;\n if ( s -> palette [ palette_ptr ] != entry ) s -> new_palette = 1 ;\n s -> palette [ palette_ptr ++ ] = entry ;\n }\n }\n if ( stream_ptr_after_color_chunk - bytestream2_tell ( & g2 ) > 0 ) bytestream2_skip ( & g2 , stream_ptr_after_color_chunk - bytestream2_tell ( & g2 ) ) ;\n break ;\n case FLI_DELTA : y_ptr = 0 ;\n compressed_lines = bytestream2_get_le16 ( & g2 ) ;\n while ( compressed_lines > 0 ) {\n line_packets = bytestream2_get_le16 ( & g2 ) ;\n if ( ( line_packets & 0xC000 ) == 0xC000 ) {\n line_packets = - line_packets ;\n y_ptr += line_packets * s -> frame . linesize [ 0 ] ;\n }\n else if ( ( line_packets & 0xC000 ) == 0x4000 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Undefined opcode (%x) in DELTA_FLI\\n\" , line_packets ) ;\n }\n else if ( ( line_packets & 0xC000 ) == 0x8000 ) {\n pixel_ptr = y_ptr + s -> frame . linesize [ 0 ] - 1 ;\n CHECK_PIXEL_PTR ( 0 ) ;\n pixels [ pixel_ptr ] = line_packets & 0xff ;\n }\n else {\n compressed_lines -- ;\n pixel_ptr = y_ptr ;\n CHECK_PIXEL_PTR ( 0 ) ;\n pixel_countdown = s -> avctx -> width ;\n for ( i = 0 ;\n i < line_packets ;\n i ++ ) {\n pixel_skip = bytestream2_get_byte ( & g2 ) ;\n pixel_ptr += pixel_skip ;\n pixel_countdown -= pixel_skip ;\n byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n if ( byte_run < 0 ) {\n byte_run = - byte_run ;\n palette_idx1 = bytestream2_get_byte ( & g2 ) ;\n palette_idx2 = bytestream2_get_byte ( & g2 ) ;\n CHECK_PIXEL_PTR ( byte_run * 2 ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ , pixel_countdown -= 2 ) {\n pixels [ pixel_ptr ++ ] = palette_idx1 ;\n pixels [ pixel_ptr ++ ] = palette_idx2 ;\n }\n }\n else {\n CHECK_PIXEL_PTR ( byte_run * 2 ) ;\n for ( j = 0 ;\n j < byte_run * 2 ;\n j ++ , pixel_countdown -- ) {\n pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n }\n }\n }\n y_ptr += s -> frame . linesize [ 0 ] ;\n }\n }\n break ;\n case FLI_LC : starting_line = bytestream2_get_le16 ( & g2 ) ;\n y_ptr = 0 ;\n y_ptr += starting_line * s -> frame . linesize [ 0 ] ;\n compressed_lines = bytestream2_get_le16 ( & g2 ) ;\n while ( compressed_lines > 0 ) {\n pixel_ptr = y_ptr ;\n CHECK_PIXEL_PTR ( 0 ) ;\n pixel_countdown = s -> avctx -> width ;\n line_packets = bytestream2_get_byte ( & g2 ) ;\n if ( line_packets > 0 ) {\n for ( i = 0 ;\n i < line_packets ;\n i ++ ) {\n pixel_skip = bytestream2_get_byte ( & g2 ) ;\n pixel_ptr += pixel_skip ;\n pixel_countdown -= pixel_skip ;\n byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n if ( byte_run > 0 ) {\n CHECK_PIXEL_PTR ( byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ , pixel_countdown -- ) {\n pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n }\n }\n else if ( byte_run < 0 ) {\n byte_run = - byte_run ;\n palette_idx1 = bytestream2_get_byte ( & g2 ) ;\n CHECK_PIXEL_PTR ( byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ , pixel_countdown -- ) {\n pixels [ pixel_ptr ++ ] = palette_idx1 ;\n }\n }\n }\n }\n y_ptr += s -> frame . linesize [ 0 ] ;\n compressed_lines -- ;\n }\n break ;\n case FLI_BLACK : memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;\n break ;\n case FLI_BRUN : y_ptr = 0 ;\n for ( lines = 0 ;\n lines < s -> avctx -> height ;\n lines ++ ) {\n pixel_ptr = y_ptr ;\n bytestream2_skip ( & g2 , 1 ) ;\n pixel_countdown = s -> avctx -> width ;\n while ( pixel_countdown > 0 ) {\n byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n if ( ! byte_run ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid byte run value.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( byte_run > 0 ) {\n palette_idx1 = bytestream2_get_byte ( & g2 ) ;\n CHECK_PIXEL_PTR ( byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ ) {\n pixels [ pixel_ptr ++ ] = palette_idx1 ;\n pixel_countdown -- ;\n if ( pixel_countdown < 0 ) av_log ( avctx , AV_LOG_ERROR , \"pixel_countdown < 0 (%d) at line %d\\n\" , pixel_countdown , lines ) ;\n }\n }\n else {\n byte_run = - byte_run ;\n CHECK_PIXEL_PTR ( byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ ) {\n pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n pixel_countdown -- ;\n if ( pixel_countdown < 0 ) av_log ( avctx , AV_LOG_ERROR , \"pixel_countdown < 0 (%d) at line %d\\n\" , pixel_countdown , lines ) ;\n }\n }\n }\n y_ptr += s -> frame . linesize [ 0 ] ;\n }\n break ;\n case FLI_COPY : if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height ) {\n av_log ( avctx , AV_LOG_ERROR , \"In chunk FLI_COPY : source data (%d bytes) \" \\ \"bigger than image, skipping chunk\\n\" , chunk_size - 6 ) ;\n bytestream2_skip ( & g2 , chunk_size - 6 ) ;\n }\n else {\n for ( y_ptr = 0 ;\n y_ptr < s -> frame . linesize [ 0 ] * s -> avctx -> height ;\n y_ptr += s -> frame . linesize [ 0 ] ) {\n bytestream2_get_buffer ( & g2 , & pixels [ y_ptr ] , s -> avctx -> width ) ;\n }\n }\n break ;\n case FLI_MINI : bytestream2_skip ( & g2 , chunk_size - 6 ) ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unrecognized chunk type: %d\\n\" , chunk_type ) ;\n break ;\n }\n frame_size -= chunk_size ;\n num_chunks -- ;\n }\n if ( ( bytestream2_get_bytes_left ( & g2 ) != 0 ) && ( bytestream2_get_bytes_left ( & g2 ) != 1 ) ) av_log ( avctx , AV_LOG_ERROR , \"Processed FLI chunk where chunk size = %d \" \\ \"and final chunk ptr = %d\\n\" , buf_size , buf_size - bytestream2_get_bytes_left ( & g2 ) ) ;\n memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n if ( s -> new_palette ) {\n s -> frame . palette_has_changed = 1 ;\n s -> new_palette = 0 ;\n }\n if ( ( ret = av_frame_ref ( data , & s -> frame ) ) < 0 ) return ret ;\n * got_frame = 1 ;\n return buf_size ;\n }", "hash": 6030508190585699741, "project": "debian", "size": 234, "target": 0, "idx": 2272}
{"code": "static inline int ivi_pic_config_cmp ( IVIPicConfig * str1 , IVIPicConfig * str2 ) {\n return str1 -> pic_width != str2 -> pic_width || str1 -> pic_height != str2 -> pic_height || str1 -> chroma_width != str2 -> chroma_width || str1 -> chroma_height != str2 -> chroma_height || str1 -> tile_width != str2 -> tile_width || str1 -> tile_height != str2 -> tile_height || str1 -> luma_bands != str2 -> luma_bands || str1 -> chroma_bands != str2 -> chroma_bands ;\n }", "hash": 8346259359343160663, "project": "debian", "size": 3, "target": 0, "idx": 2277}
{"code": "static inline int32_t calculate_sign_huff ( MLPDecodeContext * m , unsigned int substr , unsigned int ch ) {\n SubStream * s = & m -> substream [ substr ] ;\n ChannelParams * cp = & s -> channel_params [ ch ] ;\n int lsb_bits = cp -> huff_lsbs - s -> quant_step_size [ ch ] ;\n int sign_shift = lsb_bits + ( cp -> codebook ? 2 - cp -> codebook : - 1 ) ;\n int32_t sign_huff_offset = cp -> huff_offset ;\n if ( cp -> codebook > 0 ) sign_huff_offset -= 7 << lsb_bits ;\n if ( sign_shift >= 0 ) sign_huff_offset -= 1 << sign_shift ;\n return sign_huff_offset ;\n }", "hash": 8218188955508624394, "project": "debian", "size": 10, "target": 0, "idx": 2285}
{"code": "static void fill_noise_buffer ( MLPDecodeContext * m , unsigned int substr ) {\n SubStream * s = & m -> substream [ substr ] ;\n unsigned int i ;\n uint32_t seed = s -> noisegen_seed ;\n for ( i = 0 ;\n i < m -> access_unit_size_pow2 ;\n i ++ ) {\n uint8_t seed_shr15 = seed >> 15 ;\n m -> noise_buffer [ i ] = noise_table [ seed_shr15 ] ;\n seed = ( seed << 8 ) ^ seed_shr15 ^ ( seed_shr15 << 5 ) ;\n }\n s -> noisegen_seed = seed ;\n }", "hash": 8218188955508624394, "project": "debian", "size": 13, "target": 0, "idx": 2286}
{"code": "static void fill_scaling_lists ( struct dxva_context * ctx , const H264Context * h , DXVA_Qmatrix_H264 * qm ) {\n unsigned i , j ;\n memset ( qm , 0 , sizeof ( * qm ) ) ;\n if ( ctx -> workaround & FF_DXVA2_WORKAROUND_SCALING_LIST_ZIGZAG ) {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) for ( j = 0 ;\n j < 16 ;\n j ++ ) qm -> bScalingLists4x4 [ i ] [ j ] = h -> pps . scaling_matrix4 [ i ] [ j ] ;\n for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n qm -> bScalingLists8x8 [ 0 ] [ i ] = h -> pps . scaling_matrix8 [ 0 ] [ i ] ;\n qm -> bScalingLists8x8 [ 1 ] [ i ] = h -> pps . scaling_matrix8 [ 3 ] [ i ] ;\n }\n }\n else {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) for ( j = 0 ;\n j < 16 ;\n j ++ ) qm -> bScalingLists4x4 [ i ] [ j ] = h -> pps . scaling_matrix4 [ i ] [ zigzag_scan [ j ] ] ;\n for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n qm -> bScalingLists8x8 [ 0 ] [ i ] = h -> pps . scaling_matrix8 [ 0 ] [ ff_zigzag_direct [ i ] ] ;\n qm -> bScalingLists8x8 [ 1 ] [ i ] = h -> pps . scaling_matrix8 [ 3 ] [ ff_zigzag_direct [ i ] ] ;\n }\n }\n }", "hash": 6871081691104220210, "project": "debian", "size": 30, "target": 0, "idx": 2317}
{"code": "static int dxva2_h264_end_frame ( AVCodecContext * avctx ) {\n H264Context * h = avctx -> priv_data ;\n struct dxva2_picture_context * ctx_pic = h -> cur_pic_ptr -> hwaccel_picture_private ;\n int ret ;\n if ( ctx_pic -> slice_count <= 0 || ctx_pic -> bitstream_size <= 0 ) return - 1 ;\n ret = ff_dxva2_common_end_frame ( avctx , h -> cur_pic_ptr , & ctx_pic -> pp , sizeof ( ctx_pic -> pp ) , & ctx_pic -> qm , sizeof ( ctx_pic -> qm ) , commit_bitstream_and_slice_buffer ) ;\n if ( ! ret ) ff_h264_draw_horiz_band ( h , 0 , h -> avctx -> height ) ;\n return ret ;\n }", "hash": 6871081691104220210, "project": "debian", "size": 9, "target": 0, "idx": 2318}
{"code": "static void fill_picture_entry ( DXVA_PicEntry_H264 * pic , unsigned index , unsigned flag ) {\n assert ( ( index & 0x7f ) == index && ( flag & 0x01 ) == flag ) ;\n pic -> bPicEntry = index | ( flag << 7 ) ;\n }", "hash": 6871081691104220210, "project": "debian", "size": 4, "target": 0, "idx": 2324}
{"code": "static int xan_decode_frame_type0 ( AVCodecContext * avctx ) {\n XanContext * s = avctx -> priv_data ;\n uint8_t * ybuf , * prev_buf , * src = s -> scratch_buffer ;\n unsigned chroma_off , corr_off ;\n int cur , last ;\n int i , j ;\n int ret ;\n chroma_off = bytestream2_get_le32 ( & s -> gb ) ;\n corr_off = bytestream2_get_le32 ( & s -> gb ) ;\n if ( ( ret = xan_decode_chroma ( avctx , chroma_off ) ) != 0 ) return ret ;\n if ( corr_off >= ( s -> gb . buffer_end - s -> gb . buffer_start ) ) {\n av_log ( avctx , AV_LOG_WARNING , \"Ignoring invalid correction block position\\n\" ) ;\n corr_off = 0 ;\n }\n bytestream2_seek ( & s -> gb , 12 , SEEK_SET ) ;\n ret = xan_unpack_luma ( s , src , s -> buffer_size >> 1 ) ;\n if ( ret ) {\n av_log ( avctx , AV_LOG_ERROR , \"Luma decoding failed\\n\" ) ;\n return ret ;\n }\n ybuf = s -> y_buffer ;\n last = * src ++ ;\n ybuf [ 0 ] = last << 1 ;\n for ( j = 1 ;\n j < avctx -> width - 1 ;\n j += 2 ) {\n cur = ( last + * src ++ ) & 0x1F ;\n ybuf [ j ] = last + cur ;\n ybuf [ j + 1 ] = cur << 1 ;\n last = cur ;\n }\n ybuf [ j ] = last << 1 ;\n prev_buf = ybuf ;\n ybuf += avctx -> width ;\n for ( i = 1 ;\n i < avctx -> height ;\n i ++ ) {\n last = ( ( prev_buf [ 0 ] >> 1 ) + * src ++ ) & 0x1F ;\n ybuf [ 0 ] = last << 1 ;\n for ( j = 1 ;\n j < avctx -> width - 1 ;\n j += 2 ) {\n cur = ( ( prev_buf [ j + 1 ] >> 1 ) + * src ++ ) & 0x1F ;\n ybuf [ j ] = last + cur ;\n ybuf [ j + 1 ] = cur << 1 ;\n last = cur ;\n }\n ybuf [ j ] = last << 1 ;\n prev_buf = ybuf ;\n ybuf += avctx -> width ;\n }\n if ( corr_off ) {\n int dec_size ;\n bytestream2_seek ( & s -> gb , 8 + corr_off , SEEK_SET ) ;\n dec_size = xan_unpack ( s , s -> scratch_buffer , s -> buffer_size ) ;\n if ( dec_size < 0 ) dec_size = 0 ;\n for ( i = 0 ;\n i < dec_size ;\n i ++ ) s -> y_buffer [ i * 2 + 1 ] = ( s -> y_buffer [ i * 2 + 1 ] + ( s -> scratch_buffer [ i ] << 1 ) ) & 0x3F ;\n }\n src = s -> y_buffer ;\n ybuf = s -> pic . data [ 0 ] ;\n for ( j = 0 ;\n j < avctx -> height ;\n j ++ ) {\n for ( i = 0 ;\n i < avctx -> width ;\n i ++ ) ybuf [ i ] = ( src [ i ] << 2 ) | ( src [ i ] >> 3 ) ;\n src += avctx -> width ;\n ybuf += s -> pic . linesize [ 0 ] ;\n }\n return 0 ;\n }", "hash": -8333315717208416815, "project": "debian", "size": 73, "target": 0, "idx": 2352}
{"code": "static int xan_decode_chroma ( AVCodecContext * avctx , unsigned chroma_off ) {\n XanContext * s = avctx -> priv_data ;\n uint8_t * U , * V ;\n int val , uval , vval ;\n int i , j ;\n const uint8_t * src , * src_end ;\n const uint8_t * table ;\n int mode , offset , dec_size , table_size ;\n if ( ! chroma_off ) return 0 ;\n if ( chroma_off + 4 >= bytestream2_get_bytes_left ( & s -> gb ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid chroma block position\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n bytestream2_seek ( & s -> gb , chroma_off + 4 , SEEK_SET ) ;\n mode = bytestream2_get_le16 ( & s -> gb ) ;\n table = s -> gb . buffer ;\n table_size = bytestream2_get_le16 ( & s -> gb ) ;\n offset = table_size * 2 ;\n table_size += 1 ;\n if ( offset >= bytestream2_get_bytes_left ( & s -> gb ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid chroma block offset\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n bytestream2_skip ( & s -> gb , offset ) ;\n memset ( s -> scratch_buffer , 0 , s -> buffer_size ) ;\n dec_size = xan_unpack ( s , s -> scratch_buffer , s -> buffer_size ) ;\n if ( dec_size < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Chroma unpacking failed\\n\" ) ;\n return dec_size ;\n }\n U = s -> pic . data [ 1 ] ;\n V = s -> pic . data [ 2 ] ;\n src = s -> scratch_buffer ;\n src_end = src + dec_size ;\n if ( mode ) {\n for ( j = 0 ;\n j < avctx -> height >> 1 ;\n j ++ ) {\n for ( i = 0 ;\n i < avctx -> width >> 1 ;\n i ++ ) {\n val = * src ++ ;\n if ( val && val < table_size ) {\n val = AV_RL16 ( table + ( val << 1 ) ) ;\n uval = ( val >> 3 ) & 0xF8 ;\n vval = ( val >> 8 ) & 0xF8 ;\n U [ i ] = uval | ( uval >> 5 ) ;\n V [ i ] = vval | ( vval >> 5 ) ;\n }\n if ( src == src_end ) return 0 ;\n }\n U += s -> pic . linesize [ 1 ] ;\n V += s -> pic . linesize [ 2 ] ;\n }\n if ( avctx -> height & 1 ) {\n memcpy ( U , U - s -> pic . linesize [ 1 ] , avctx -> width >> 1 ) ;\n memcpy ( V , V - s -> pic . linesize [ 2 ] , avctx -> width >> 1 ) ;\n }\n }\n else {\n uint8_t * U2 = U + s -> pic . linesize [ 1 ] ;\n uint8_t * V2 = V + s -> pic . linesize [ 2 ] ;\n for ( j = 0 ;\n j < avctx -> height >> 2 ;\n j ++ ) {\n for ( i = 0 ;\n i < avctx -> width >> 1 ;\n i += 2 ) {\n val = * src ++ ;\n if ( val && val < table_size ) {\n val = AV_RL16 ( table + ( val << 1 ) ) ;\n uval = ( val >> 3 ) & 0xF8 ;\n vval = ( val >> 8 ) & 0xF8 ;\n U [ i ] = U [ i + 1 ] = U2 [ i ] = U2 [ i + 1 ] = uval | ( uval >> 5 ) ;\n V [ i ] = V [ i + 1 ] = V2 [ i ] = V2 [ i + 1 ] = vval | ( vval >> 5 ) ;\n }\n }\n U += s -> pic . linesize [ 1 ] * 2 ;\n V += s -> pic . linesize [ 2 ] * 2 ;\n U2 += s -> pic . linesize [ 1 ] * 2 ;\n V2 += s -> pic . linesize [ 2 ] * 2 ;\n }\n if ( avctx -> height & 3 ) {\n int lines = ( ( avctx -> height + 1 ) >> 1 ) - ( avctx -> height >> 2 ) * 2 ;\n memcpy ( U , U - lines * s -> pic . linesize [ 1 ] , lines * s -> pic . linesize [ 1 ] ) ;\n memcpy ( V , V - lines * s -> pic . linesize [ 2 ] , lines * s -> pic . linesize [ 2 ] ) ;\n }\n }\n return 0 ;\n }", "hash": -8333315717208416815, "project": "debian", "size": 90, "target": 0, "idx": 2353}
{"code": "static int joint_decode ( COOKContext * q , COOKSubpacket * p , float * mlt_buffer_left , float * mlt_buffer_right ) {\n int i , j , res ;\n int decouple_tab [ SUBBAND_SIZE ] = {\n 0 }\n ;\n float * decode_buffer = q -> decode_buffer_0 ;\n int idx , cpl_tmp ;\n float f1 , f2 ;\n const float * cplscale ;\n memset ( decode_buffer , 0 , sizeof ( q -> decode_buffer_0 ) ) ;\n memset ( mlt_buffer_left , 0 , 1024 * sizeof ( * mlt_buffer_left ) ) ;\n memset ( mlt_buffer_right , 0 , 1024 * sizeof ( * mlt_buffer_right ) ) ;\n decouple_info ( q , p , decouple_tab ) ;\n if ( ( res = mono_decode ( q , p , decode_buffer ) ) < 0 ) return res ;\n for ( i = 0 ;\n i < p -> js_subband_start ;\n i ++ ) {\n for ( j = 0 ;\n j < SUBBAND_SIZE ;\n j ++ ) {\n mlt_buffer_left [ i * 20 + j ] = decode_buffer [ i * 40 + j ] ;\n mlt_buffer_right [ i * 20 + j ] = decode_buffer [ i * 40 + 20 + j ] ;\n }\n }\n idx = ( 1 << p -> js_vlc_bits ) - 1 ;\n for ( i = p -> js_subband_start ;\n i < p -> subbands ;\n i ++ ) {\n cpl_tmp = cplband [ i ] ;\n idx -= decouple_tab [ cpl_tmp ] ;\n cplscale = q -> cplscales [ p -> js_vlc_bits - 2 ] ;\n f1 = cplscale [ decouple_tab [ cpl_tmp ] + 1 ] ;\n f2 = cplscale [ idx ] ;\n q -> decouple ( q , p , i , f1 , f2 , decode_buffer , mlt_buffer_left , mlt_buffer_right ) ;\n idx = ( 1 << p -> js_vlc_bits ) - 1 ;\n }\n return 0 ;\n }", "hash": 5737086831275946085, "project": "debian", "size": 38, "target": 0, "idx": 2364}
{"code": "static int mono_decode ( COOKContext * q , COOKSubpacket * p , float * mlt_buffer ) {\n int category_index [ 128 ] = {\n 0 }\n ;\n int category [ 128 ] = {\n 0 }\n ;\n int quant_index_table [ 102 ] ;\n int res ;\n if ( ( res = decode_envelope ( q , p , quant_index_table ) ) < 0 ) return res ;\n q -> num_vectors = get_bits ( & q -> gb , p -> log2_numvector_size ) ;\n categorize ( q , p , quant_index_table , category , category_index ) ;\n expand_category ( q , category , category_index ) ;\n decode_vectors ( q , p , category , quant_index_table , mlt_buffer ) ;\n return 0 ;\n }", "hash": 5737086831275946085, "project": "debian", "size": 16, "target": 0, "idx": 2366}
{"code": "static void imc_adjust_bit_allocation ( IMCContext * q , IMCChannel * chctx , int summer ) {\n float workT [ 32 ] ;\n int corrected = 0 ;\n int i , j ;\n float highest = 0 ;\n int found_indx = 0 ;\n for ( i = 0 ;\n i < BANDS ;\n i ++ ) {\n workT [ i ] = ( chctx -> bitsBandT [ i ] == 6 ) ? - 1.e20 : ( chctx -> bitsBandT [ i ] * - 2 + chctx -> flcoeffs4 [ i ] - 0.415 ) ;\n }\n while ( corrected < summer ) {\n if ( highest <= - 1.e20 ) break ;\n highest = - 1.e20 ;\n for ( i = 0 ;\n i < BANDS ;\n i ++ ) {\n if ( workT [ i ] > highest ) {\n highest = workT [ i ] ;\n found_indx = i ;\n }\n }\n if ( highest > - 1.e20 ) {\n workT [ found_indx ] -= 2.0 ;\n if ( ++ ( chctx -> bitsBandT [ found_indx ] ) == 6 ) workT [ found_indx ] = - 1.e20 ;\n for ( j = band_tab [ found_indx ] ;\n j < band_tab [ found_indx + 1 ] && ( corrected < summer ) ;\n j ++ ) {\n if ( ! chctx -> skipFlags [ j ] && ( chctx -> CWlengthT [ j ] < 6 ) ) {\n chctx -> CWlengthT [ j ] ++ ;\n corrected ++ ;\n }\n }\n }\n }\n }", "hash": -4299048894522449432, "project": "debian", "size": 36, "target": 0, "idx": 2381}
{"code": "static int imc_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int ret , i ;\n IMCContext * q = avctx -> priv_data ;\n LOCAL_ALIGNED_16 ( uint16_t , buf16 , [ IMC_BLOCK_SIZE / 2 ] ) ;\n if ( buf_size < IMC_BLOCK_SIZE * avctx -> channels ) {\n av_log ( avctx , AV_LOG_ERROR , \"frame too small!\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n frame -> nb_samples = COEFFS ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n for ( i = 0 ;\n i < avctx -> channels ;\n i ++ ) {\n q -> out_samples = ( float * ) frame -> extended_data [ i ] ;\n q -> dsp . bswap16_buf ( buf16 , ( const uint16_t * ) buf , IMC_BLOCK_SIZE / 2 ) ;\n init_get_bits ( & q -> gb , ( const uint8_t * ) buf16 , IMC_BLOCK_SIZE * 8 ) ;\n buf += IMC_BLOCK_SIZE ;\n if ( ( ret = imc_decode_block ( avctx , q , i ) ) < 0 ) return ret ;\n }\n if ( avctx -> channels == 2 ) {\n q -> fdsp . butterflies_float ( ( float * ) frame -> extended_data [ 0 ] , ( float * ) frame -> extended_data [ 1 ] , COEFFS ) ;\n }\n * got_frame_ptr = 1 ;\n return IMC_BLOCK_SIZE * avctx -> channels ;\n }", "hash": -4299048894522449432, "project": "debian", "size": 31, "target": 0, "idx": 2383}
{"code": "static int decode_pic ( AVSContext * h ) {\n int skip_count = - 1 ;\n enum cavs_mb mb_type ;\n av_frame_unref ( h -> cur . f ) ;\n skip_bits ( & h -> gb , 16 ) ;\n if ( h -> stc == PIC_PB_START_CODE ) {\n h -> cur . f -> pict_type = get_bits ( & h -> gb , 2 ) + AV_PICTURE_TYPE_I ;\n if ( h -> cur . f -> pict_type > AV_PICTURE_TYPE_B ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"illegal picture type\\n\" ) ;\n return - 1 ;\n }\n if ( ! h -> DPB [ 0 ] . f -> data [ 0 ] || ( ! h -> DPB [ 1 ] . f -> data [ 0 ] && h -> cur . f -> pict_type == AV_PICTURE_TYPE_B ) ) return - 1 ;\n }\n else {\n h -> cur . f -> pict_type = AV_PICTURE_TYPE_I ;\n if ( get_bits1 ( & h -> gb ) ) skip_bits ( & h -> gb , 24 ) ;\n if ( h -> low_delay || ! ( show_bits ( & h -> gb , 9 ) & 1 ) ) h -> stream_revision = 1 ;\n else if ( show_bits ( & h -> gb , 11 ) & 3 ) h -> stream_revision = 1 ;\n if ( h -> stream_revision > 0 ) skip_bits ( & h -> gb , 1 ) ;\n }\n ff_get_buffer ( h -> avctx , h -> cur . f , h -> cur . f -> pict_type == AV_PICTURE_TYPE_B ? 0 : AV_GET_BUFFER_FLAG_REF ) ;\n if ( ! h -> edge_emu_buffer ) {\n int alloc_size = FFALIGN ( FFABS ( h -> cur . f -> linesize [ 0 ] ) + 32 , 32 ) ;\n h -> edge_emu_buffer = av_mallocz ( alloc_size * 2 * 24 ) ;\n if ( ! h -> edge_emu_buffer ) return AVERROR ( ENOMEM ) ;\n }\n ff_cavs_init_pic ( h ) ;\n h -> cur . poc = get_bits ( & h -> gb , 8 ) * 2 ;\n if ( h -> cur . f -> pict_type != AV_PICTURE_TYPE_B ) {\n h -> dist [ 0 ] = ( h -> cur . poc - h -> DPB [ 0 ] . poc + 512 ) % 512 ;\n }\n else {\n h -> dist [ 0 ] = ( h -> DPB [ 0 ] . poc - h -> cur . poc + 512 ) % 512 ;\n }\n h -> dist [ 1 ] = ( h -> cur . poc - h -> DPB [ 1 ] . poc + 512 ) % 512 ;\n h -> scale_den [ 0 ] = h -> dist [ 0 ] ? 512 / h -> dist [ 0 ] : 0 ;\n h -> scale_den [ 1 ] = h -> dist [ 1 ] ? 512 / h -> dist [ 1 ] : 0 ;\n if ( h -> cur . f -> pict_type == AV_PICTURE_TYPE_B ) {\n h -> sym_factor = h -> dist [ 0 ] * h -> scale_den [ 1 ] ;\n }\n else {\n h -> direct_den [ 0 ] = h -> dist [ 0 ] ? 16384 / h -> dist [ 0 ] : 0 ;\n h -> direct_den [ 1 ] = h -> dist [ 1 ] ? 16384 / h -> dist [ 1 ] : 0 ;\n }\n if ( h -> low_delay ) get_ue_golomb ( & h -> gb ) ;\n h -> progressive = get_bits1 ( & h -> gb ) ;\n h -> pic_structure = 1 ;\n if ( ! h -> progressive ) h -> pic_structure = get_bits1 ( & h -> gb ) ;\n if ( ! h -> pic_structure && h -> stc == PIC_PB_START_CODE ) skip_bits1 ( & h -> gb ) ;\n skip_bits1 ( & h -> gb ) ;\n skip_bits1 ( & h -> gb ) ;\n h -> qp_fixed = get_bits1 ( & h -> gb ) ;\n h -> qp = get_bits ( & h -> gb , 6 ) ;\n if ( h -> cur . f -> pict_type == AV_PICTURE_TYPE_I ) {\n if ( ! h -> progressive && ! h -> pic_structure ) skip_bits1 ( & h -> gb ) ;\n skip_bits ( & h -> gb , 4 ) ;\n }\n else {\n if ( ! ( h -> cur . f -> pict_type == AV_PICTURE_TYPE_B && h -> pic_structure == 1 ) ) h -> ref_flag = get_bits1 ( & h -> gb ) ;\n skip_bits ( & h -> gb , 4 ) ;\n h -> skip_mode_flag = get_bits1 ( & h -> gb ) ;\n }\n h -> loop_filter_disable = get_bits1 ( & h -> gb ) ;\n if ( ! h -> loop_filter_disable && get_bits1 ( & h -> gb ) ) {\n h -> alpha_offset = get_se_golomb ( & h -> gb ) ;\n h -> beta_offset = get_se_golomb ( & h -> gb ) ;\n }\n else {\n h -> alpha_offset = h -> beta_offset = 0 ;\n }\n if ( h -> cur . f -> pict_type == AV_PICTURE_TYPE_I ) {\n do {\n check_for_slice ( h ) ;\n decode_mb_i ( h , 0 ) ;\n }\n while ( ff_cavs_next_mb ( h ) ) ;\n }\n else if ( h -> cur . f -> pict_type == AV_PICTURE_TYPE_P ) {\n do {\n if ( check_for_slice ( h ) ) skip_count = - 1 ;\n if ( h -> skip_mode_flag && ( skip_count < 0 ) ) skip_count = get_ue_golomb ( & h -> gb ) ;\n if ( h -> skip_mode_flag && skip_count -- ) {\n decode_mb_p ( h , P_SKIP ) ;\n }\n else {\n mb_type = get_ue_golomb ( & h -> gb ) + P_SKIP + h -> skip_mode_flag ;\n if ( mb_type > P_8X8 ) decode_mb_i ( h , mb_type - P_8X8 - 1 ) ;\n else decode_mb_p ( h , mb_type ) ;\n }\n }\n while ( ff_cavs_next_mb ( h ) ) ;\n }\n else {\n do {\n if ( check_for_slice ( h ) ) skip_count = - 1 ;\n if ( h -> skip_mode_flag && ( skip_count < 0 ) ) skip_count = get_ue_golomb ( & h -> gb ) ;\n if ( h -> skip_mode_flag && skip_count -- ) {\n decode_mb_b ( h , B_SKIP ) ;\n }\n else {\n mb_type = get_ue_golomb ( & h -> gb ) + B_SKIP + h -> skip_mode_flag ;\n if ( mb_type > B_8X8 ) decode_mb_i ( h , mb_type - B_8X8 - 1 ) ;\n else decode_mb_b ( h , mb_type ) ;\n }\n }\n while ( ff_cavs_next_mb ( h ) ) ;\n }\n if ( h -> cur . f -> pict_type != AV_PICTURE_TYPE_B ) {\n av_frame_unref ( h -> DPB [ 1 ] . f ) ;\n FFSWAP ( AVSFrame , h -> cur , h -> DPB [ 1 ] ) ;\n FFSWAP ( AVSFrame , h -> DPB [ 0 ] , h -> DPB [ 1 ] ) ;\n }\n return 0 ;\n }", "hash": -4271192073087306668, "project": "debian", "size": 114, "target": 0, "idx": 2389}
{"code": "static int cavs_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n AVSContext * h = avctx -> priv_data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n uint32_t stc = - 1 ;\n int input_size , ret ;\n const uint8_t * buf_end ;\n const uint8_t * buf_ptr ;\n if ( buf_size == 0 ) {\n if ( ! h -> low_delay && h -> DPB [ 0 ] . f -> data [ 0 ] ) {\n * got_frame = 1 ;\n av_frame_move_ref ( data , h -> DPB [ 0 ] . f ) ;\n }\n return 0 ;\n }\n buf_ptr = buf ;\n buf_end = buf + buf_size ;\n for ( ;\n ;\n ) {\n buf_ptr = avpriv_mpv_find_start_code ( buf_ptr , buf_end , & stc ) ;\n if ( ( stc & 0xFFFFFE00 ) || buf_ptr == buf_end ) return FFMAX ( 0 , buf_ptr - buf ) ;\n input_size = ( buf_end - buf_ptr ) * 8 ;\n switch ( stc ) {\n case CAVS_START_CODE : init_get_bits ( & h -> gb , buf_ptr , input_size ) ;\n decode_seq_header ( h ) ;\n break ;\n case PIC_I_START_CODE : if ( ! h -> got_keyframe ) {\n av_frame_unref ( h -> DPB [ 0 ] . f ) ;\n av_frame_unref ( h -> DPB [ 1 ] . f ) ;\n h -> got_keyframe = 1 ;\n }\n case PIC_PB_START_CODE : * got_frame = 0 ;\n if ( ! h -> got_keyframe ) break ;\n init_get_bits ( & h -> gb , buf_ptr , input_size ) ;\n h -> stc = stc ;\n if ( decode_pic ( h ) ) break ;\n * got_frame = 1 ;\n if ( h -> cur . f -> pict_type != AV_PICTURE_TYPE_B ) {\n if ( h -> DPB [ 1 ] . f -> data [ 0 ] ) {\n if ( ( ret = av_frame_ref ( data , h -> DPB [ 1 ] . f ) ) < 0 ) return ret ;\n }\n else {\n * got_frame = 0 ;\n }\n }\n else {\n av_frame_move_ref ( data , h -> cur . f ) ;\n }\n break ;\n case EXT_START_CODE : break ;\n case USER_START_CODE : break ;\n default : if ( stc <= SLICE_MAX_START_CODE ) {\n init_get_bits ( & h -> gb , buf_ptr , input_size ) ;\n decode_slice_header ( h , & h -> gb ) ;\n }\n break ;\n }\n }\n }", "hash": -4271192073087306668, "project": "debian", "size": 60, "target": 0, "idx": 2392}
{"code": "static inline void mv_pred_direct ( AVSContext * h , cavs_vector * pmv_fw , cavs_vector * col_mv ) {\n cavs_vector * pmv_bw = pmv_fw + MV_BWD_OFFS ;\n int den = h -> direct_den [ col_mv -> ref ] ;\n int m = col_mv -> x >> 31 ;\n pmv_fw -> dist = h -> dist [ 1 ] ;\n pmv_bw -> dist = h -> dist [ 0 ] ;\n pmv_fw -> ref = 1 ;\n pmv_bw -> ref = 0 ;\n pmv_fw -> x = ( ( ( den + ( den * col_mv -> x * pmv_fw -> dist ^ m ) - m - 1 ) >> 14 ) ^ m ) - m ;\n pmv_bw -> x = m - ( ( ( den + ( den * col_mv -> x * pmv_bw -> dist ^ m ) - m - 1 ) >> 14 ) ^ m ) ;\n m = col_mv -> y >> 31 ;\n pmv_fw -> y = ( ( ( den + ( den * col_mv -> y * pmv_fw -> dist ^ m ) - m - 1 ) >> 14 ) ^ m ) - m ;\n pmv_bw -> y = m - ( ( ( den + ( den * col_mv -> y * pmv_bw -> dist ^ m ) - m - 1 ) >> 14 ) ^ m ) ;\n }", "hash": -4271192073087306668, "project": "debian", "size": 14, "target": 0, "idx": 2394}
{"code": "static void decode_mb_b ( AVSContext * h , enum cavs_mb mb_type ) {\n int block ;\n enum cavs_sub_mb sub_type [ 4 ] ;\n int flags ;\n ff_cavs_init_mb ( h ) ;\n h -> mv [ MV_FWD_X0 ] = ff_cavs_dir_mv ;\n set_mvs ( & h -> mv [ MV_FWD_X0 ] , BLK_16X16 ) ;\n h -> mv [ MV_BWD_X0 ] = ff_cavs_dir_mv ;\n set_mvs ( & h -> mv [ MV_BWD_X0 ] , BLK_16X16 ) ;\n switch ( mb_type ) {\n case B_SKIP : case B_DIRECT : if ( ! h -> col_type_base [ h -> mbidx ] ) {\n ff_cavs_mv ( h , MV_FWD_X0 , MV_FWD_C2 , MV_PRED_BSKIP , BLK_16X16 , 1 ) ;\n ff_cavs_mv ( h , MV_BWD_X0 , MV_BWD_C2 , MV_PRED_BSKIP , BLK_16X16 , 0 ) ;\n }\n else for ( block = 0 ;\n block < 4 ;\n block ++ ) mv_pred_direct ( h , & h -> mv [ mv_scan [ block ] ] , & h -> col_mv [ h -> mbidx * 4 + block ] ) ;\n break ;\n case B_FWD_16X16 : ff_cavs_mv ( h , MV_FWD_X0 , MV_FWD_C2 , MV_PRED_MEDIAN , BLK_16X16 , 1 ) ;\n break ;\n case B_SYM_16X16 : ff_cavs_mv ( h , MV_FWD_X0 , MV_FWD_C2 , MV_PRED_MEDIAN , BLK_16X16 , 1 ) ;\n mv_pred_sym ( h , & h -> mv [ MV_FWD_X0 ] , BLK_16X16 ) ;\n break ;\n case B_BWD_16X16 : ff_cavs_mv ( h , MV_BWD_X0 , MV_BWD_C2 , MV_PRED_MEDIAN , BLK_16X16 , 0 ) ;\n break ;\n case B_8X8 : for ( block = 0 ;\n block < 4 ;\n block ++ ) sub_type [ block ] = get_bits ( & h -> gb , 2 ) ;\n for ( block = 0 ;\n block < 4 ;\n block ++ ) {\n switch ( sub_type [ block ] ) {\n case B_SUB_DIRECT : if ( ! h -> col_type_base [ h -> mbidx ] ) {\n ff_cavs_mv ( h , mv_scan [ block ] , mv_scan [ block ] - 3 , MV_PRED_BSKIP , BLK_8X8 , 1 ) ;\n ff_cavs_mv ( h , mv_scan [ block ] + MV_BWD_OFFS , mv_scan [ block ] - 3 + MV_BWD_OFFS , MV_PRED_BSKIP , BLK_8X8 , 0 ) ;\n }\n else mv_pred_direct ( h , & h -> mv [ mv_scan [ block ] ] , & h -> col_mv [ h -> mbidx * 4 + block ] ) ;\n break ;\n case B_SUB_FWD : ff_cavs_mv ( h , mv_scan [ block ] , mv_scan [ block ] - 3 , MV_PRED_MEDIAN , BLK_8X8 , 1 ) ;\n break ;\n case B_SUB_SYM : ff_cavs_mv ( h , mv_scan [ block ] , mv_scan [ block ] - 3 , MV_PRED_MEDIAN , BLK_8X8 , 1 ) ;\n mv_pred_sym ( h , & h -> mv [ mv_scan [ block ] ] , BLK_8X8 ) ;\n break ;\n }\n }\n for ( block = 0 ;\n block < 4 ;\n block ++ ) {\n if ( sub_type [ block ] == B_SUB_BWD ) ff_cavs_mv ( h , mv_scan [ block ] + MV_BWD_OFFS , mv_scan [ block ] + MV_BWD_OFFS - 3 , MV_PRED_MEDIAN , BLK_8X8 , 0 ) ;\n }\n break ;\n default : assert ( ( mb_type > B_SYM_16X16 ) && ( mb_type < B_8X8 ) ) ;\n flags = ff_cavs_partition_flags [ mb_type ] ;\n if ( mb_type & 1 ) {\n if ( flags & FWD0 ) ff_cavs_mv ( h , MV_FWD_X0 , MV_FWD_C2 , MV_PRED_TOP , BLK_16X8 , 1 ) ;\n if ( flags & SYM0 ) mv_pred_sym ( h , & h -> mv [ MV_FWD_X0 ] , BLK_16X8 ) ;\n if ( flags & FWD1 ) ff_cavs_mv ( h , MV_FWD_X2 , MV_FWD_A1 , MV_PRED_LEFT , BLK_16X8 , 1 ) ;\n if ( flags & SYM1 ) mv_pred_sym ( h , & h -> mv [ MV_FWD_X2 ] , BLK_16X8 ) ;\n if ( flags & BWD0 ) ff_cavs_mv ( h , MV_BWD_X0 , MV_BWD_C2 , MV_PRED_TOP , BLK_16X8 , 0 ) ;\n if ( flags & BWD1 ) ff_cavs_mv ( h , MV_BWD_X2 , MV_BWD_A1 , MV_PRED_LEFT , BLK_16X8 , 0 ) ;\n }\n else {\n if ( flags & FWD0 ) ff_cavs_mv ( h , MV_FWD_X0 , MV_FWD_B3 , MV_PRED_LEFT , BLK_8X16 , 1 ) ;\n if ( flags & SYM0 ) mv_pred_sym ( h , & h -> mv [ MV_FWD_X0 ] , BLK_8X16 ) ;\n if ( flags & FWD1 ) ff_cavs_mv ( h , MV_FWD_X1 , MV_FWD_C2 , MV_PRED_TOPRIGHT , BLK_8X16 , 1 ) ;\n if ( flags & SYM1 ) mv_pred_sym ( h , & h -> mv [ MV_FWD_X1 ] , BLK_8X16 ) ;\n if ( flags & BWD0 ) ff_cavs_mv ( h , MV_BWD_X0 , MV_BWD_B3 , MV_PRED_LEFT , BLK_8X16 , 0 ) ;\n if ( flags & BWD1 ) ff_cavs_mv ( h , MV_BWD_X1 , MV_BWD_C2 , MV_PRED_TOPRIGHT , BLK_8X16 , 0 ) ;\n }\n }\n ff_cavs_inter ( h , mb_type ) ;\n set_intra_mode_default ( h ) ;\n if ( mb_type != B_SKIP ) decode_residual_inter ( h ) ;\n ff_cavs_filter ( h , mb_type ) ;\n }", "hash": -4271192073087306668, "project": "debian", "size": 75, "target": 0, "idx": 2395}
{"code": "static void gsm_flush ( AVCodecContext * avctx ) {\n GSMContext * s = avctx -> priv_data ;\n memset ( s , 0 , sizeof ( * s ) ) ;\n }", "hash": 2924570498240620769, "project": "debian", "size": 4, "target": 0, "idx": 2408}
{"code": "static inline int decode_subframe ( FLACContext * s , int channel ) {\n int32_t * decoded = s -> decoded [ channel ] ;\n int type , wasted = 0 ;\n int bps = s -> bps ;\n int i , tmp ;\n if ( channel == 0 ) {\n if ( s -> ch_mode == FLAC_CHMODE_RIGHT_SIDE ) bps ++ ;\n }\n else {\n if ( s -> ch_mode == FLAC_CHMODE_LEFT_SIDE || s -> ch_mode == FLAC_CHMODE_MID_SIDE ) bps ++ ;\n }\n if ( get_bits1 ( & s -> gb ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"invalid subframe padding\\n\" ) ;\n return - 1 ;\n }\n type = get_bits ( & s -> gb , 6 ) ;\n if ( get_bits1 ( & s -> gb ) ) {\n int left = get_bits_left ( & s -> gb ) ;\n wasted = 1 ;\n if ( left < 0 || ( left < bps && ! show_bits_long ( & s -> gb , left ) ) || ! show_bits_long ( & s -> gb , bps ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Invalid number of wasted bits > available bits (%d) - left=%d\\n\" , bps , left ) ;\n return AVERROR_INVALIDDATA ;\n }\n while ( ! get_bits1 ( & s -> gb ) ) wasted ++ ;\n bps -= wasted ;\n }\n if ( bps > 32 ) {\n av_log_missing_feature ( s -> avctx , \"Decorrelated bit depth > 32\" , 0 ) ;\n return AVERROR_PATCHWELCOME ;\n }\n if ( type == 0 ) {\n tmp = get_sbits_long ( & s -> gb , bps ) ;\n for ( i = 0 ;\n i < s -> blocksize ;\n i ++ ) decoded [ i ] = tmp ;\n }\n else if ( type == 1 ) {\n for ( i = 0 ;\n i < s -> blocksize ;\n i ++ ) decoded [ i ] = get_sbits_long ( & s -> gb , bps ) ;\n }\n else if ( ( type >= 8 ) && ( type <= 12 ) ) {\n if ( decode_subframe_fixed ( s , decoded , type & ~ 0x8 , bps ) < 0 ) return - 1 ;\n }\n else if ( type >= 32 ) {\n if ( decode_subframe_lpc ( s , decoded , ( type & ~ 0x20 ) + 1 , bps ) < 0 ) return - 1 ;\n }\n else {\n av_log ( s -> avctx , AV_LOG_ERROR , \"invalid coding type\\n\" ) ;\n return - 1 ;\n }\n if ( wasted ) {\n int i ;\n for ( i = 0 ;\n i < s -> blocksize ;\n i ++ ) decoded [ i ] <<= wasted ;\n }\n return 0 ;\n }", "hash": 6879275573700337956, "project": "debian", "size": 59, "target": 0, "idx": 2422}
{"code": "static void flac_set_bps ( FLACContext * s ) {\n enum AVSampleFormat req = s -> avctx -> request_sample_fmt ;\n int need32 = s -> bps > 16 ;\n int want32 = av_get_bytes_per_sample ( req ) > 2 ;\n int planar = av_sample_fmt_is_planar ( req ) ;\n if ( need32 || want32 ) {\n if ( planar ) s -> avctx -> sample_fmt = AV_SAMPLE_FMT_S32P ;\n else s -> avctx -> sample_fmt = AV_SAMPLE_FMT_S32 ;\n s -> sample_shift = 32 - s -> bps ;\n }\n else {\n if ( planar ) s -> avctx -> sample_fmt = AV_SAMPLE_FMT_S16P ;\n else s -> avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ;\n s -> sample_shift = 16 - s -> bps ;\n }\n }", "hash": 6879275573700337956, "project": "debian", "size": 16, "target": 0, "idx": 2427}
{"code": "static inline int check_line ( uint8_t * buf , uint8_t * start , uint8_t * end ) {\n return buf >= start && ( buf + 4 ) <= end ;\n }", "hash": 2091417324431734585, "project": "debian", "size": 3, "target": 0, "idx": 2430}
{"code": "static int x8_get_dc_rlf ( IntraX8Context * const w , int const mode , int * const level , int * const final ) {\n MpegEncContext * const s = w -> s ;\n int i , e , c ;\n assert ( mode < 3 ) ;\n if ( ! w -> j_dc_vlc [ mode ] ) {\n int table_index ;\n table_index = get_bits ( & s -> gb , 3 ) ;\n w -> j_dc_vlc [ mode ] = & j_dc_vlc [ w -> quant < 13 ] [ table_index ] ;\n }\n assert ( w -> j_dc_vlc ) ;\n assert ( w -> j_dc_vlc [ mode ] -> table ) ;\n i = get_vlc2 ( & s -> gb , w -> j_dc_vlc [ mode ] -> table , DC_VLC_BITS , DC_VLC_MTD ) ;\n c = i > 16 ;\n ( * final ) = c ;\n i -= 17 * c ;\n if ( i <= 0 ) {\n ( * level ) = 0 ;\n return - i ;\n }\n c = ( i + 1 ) >> 1 ;\n c -= c > 1 ;\n e = get_bits ( & s -> gb , c ) ;\n i = dc_index_offset [ i ] + ( e >> 1 ) ;\n e = - ( e & 1 ) ;\n ( * level ) = ( i ^ e ) - e ;\n return 0 ;\n }", "hash": -5390559971540708342, "project": "debian", "size": 27, "target": 0, "idx": 2441}
{"code": "static int decode_argb_frame ( CLLCContext * ctx , GetBitContext * gb , AVFrame * pic ) {\n AVCodecContext * avctx = ctx -> avctx ;\n uint8_t * dst ;\n int pred [ 4 ] ;\n int ret ;\n int i , j ;\n VLC vlc [ 4 ] ;\n pred [ 0 ] = 0 ;\n pred [ 1 ] = 0x80 ;\n pred [ 2 ] = 0x80 ;\n pred [ 3 ] = 0x80 ;\n dst = pic -> data [ 0 ] ;\n skip_bits ( gb , 16 ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n ret = read_code_table ( ctx , gb , & vlc [ i ] ) ;\n if ( ret < 0 ) {\n for ( j = 0 ;\n j <= i ;\n j ++ ) ff_free_vlc ( & vlc [ j ] ) ;\n av_log ( ctx -> avctx , AV_LOG_ERROR , \"Could not read code table %d.\\n\" , i ) ;\n return ret ;\n }\n }\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n read_argb_line ( ctx , gb , pred , vlc , dst ) ;\n dst += pic -> linesize [ 0 ] ;\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) ff_free_vlc ( & vlc [ i ] ) ;\n return 0 ;\n }", "hash": -3777025485787920715, "project": "debian", "size": 36, "target": 0, "idx": 2469}
{"code": "static float vorbisfloat2float ( unsigned val ) {\n double mant = val & 0x1fffff ;\n long exp = ( val & 0x7fe00000L ) >> 21 ;\n if ( val & 0x80000000 ) mant = - mant ;\n return ldexp ( mant , exp - 20 - 768 ) ;\n }", "hash": -8437173884317959107, "project": "debian", "size": 6, "target": 0, "idx": 2472}
{"code": "static int vorbis_parse_setup_hdr_mappings ( vorbis_context * vc ) {\n GetBitContext * gb = & vc -> gb ;\n unsigned i , j ;\n vc -> mapping_count = get_bits ( gb , 6 ) + 1 ;\n vc -> mappings = av_mallocz ( vc -> mapping_count * sizeof ( * vc -> mappings ) ) ;\n if ( ! vc -> mappings ) return AVERROR ( ENOMEM ) ;\n av_dlog ( NULL , \" There are %d mappings. \\n\" , vc -> mapping_count ) ;\n for ( i = 0 ;\n i < vc -> mapping_count ;\n ++ i ) {\n vorbis_mapping * mapping_setup = & vc -> mappings [ i ] ;\n if ( get_bits ( gb , 16 ) ) {\n av_log ( vc -> avctx , AV_LOG_ERROR , \"Other mappings than type 0 are not compliant with the Vorbis I specification. \\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( get_bits1 ( gb ) ) {\n mapping_setup -> submaps = get_bits ( gb , 4 ) + 1 ;\n }\n else {\n mapping_setup -> submaps = 1 ;\n }\n if ( get_bits1 ( gb ) ) {\n mapping_setup -> coupling_steps = get_bits ( gb , 8 ) + 1 ;\n mapping_setup -> magnitude = av_mallocz ( mapping_setup -> coupling_steps * sizeof ( * mapping_setup -> magnitude ) ) ;\n mapping_setup -> angle = av_mallocz ( mapping_setup -> coupling_steps * sizeof ( * mapping_setup -> angle ) ) ;\n if ( ! mapping_setup -> angle || ! mapping_setup -> magnitude ) return AVERROR ( ENOMEM ) ;\n for ( j = 0 ;\n j < mapping_setup -> coupling_steps ;\n ++ j ) {\n GET_VALIDATED_INDEX ( mapping_setup -> magnitude [ j ] , ilog ( vc -> audio_channels - 1 ) , vc -> audio_channels ) GET_VALIDATED_INDEX ( mapping_setup -> angle [ j ] , ilog ( vc -> audio_channels - 1 ) , vc -> audio_channels ) }\n }\n else {\n mapping_setup -> coupling_steps = 0 ;\n }\n av_dlog ( NULL , \" %u mapping coupling steps: %d\\n\" , i , mapping_setup -> coupling_steps ) ;\n if ( get_bits ( gb , 2 ) ) {\n av_log ( vc -> avctx , AV_LOG_ERROR , \"%u. mapping setup data invalid.\\n\" , i ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( mapping_setup -> submaps > 1 ) {\n mapping_setup -> mux = av_mallocz ( vc -> audio_channels * sizeof ( * mapping_setup -> mux ) ) ;\n if ( ! mapping_setup -> mux ) return AVERROR ( ENOMEM ) ;\n for ( j = 0 ;\n j < vc -> audio_channels ;\n ++ j ) mapping_setup -> mux [ j ] = get_bits ( gb , 4 ) ;\n }\n for ( j = 0 ;\n j < mapping_setup -> submaps ;\n ++ j ) {\n skip_bits ( gb , 8 ) ;\n GET_VALIDATED_INDEX ( mapping_setup -> submap_floor [ j ] , 8 , vc -> floor_count ) GET_VALIDATED_INDEX ( mapping_setup -> submap_residue [ j ] , 8 , vc -> residue_count ) av_dlog ( NULL , \" %u mapping %u submap : floor %d, residue %d\\n\" , i , j , mapping_setup -> submap_floor [ j ] , mapping_setup -> submap_residue [ j ] ) ;\n }\n }\n return 0 ;\n }", "hash": -8437173884317959107, "project": "debian", "size": 55, "target": 0, "idx": 2475}
{"code": "static int vorbis_parse_setup_hdr_residues ( vorbis_context * vc ) {\n GetBitContext * gb = & vc -> gb ;\n unsigned i , j , k ;\n vc -> residue_count = get_bits ( gb , 6 ) + 1 ;\n vc -> residues = av_mallocz ( vc -> residue_count * sizeof ( * vc -> residues ) ) ;\n if ( ! vc -> residues ) return AVERROR ( ENOMEM ) ;\n av_dlog ( NULL , \" There are %d residues. \\n\" , vc -> residue_count ) ;\n for ( i = 0 ;\n i < vc -> residue_count ;\n ++ i ) {\n vorbis_residue * res_setup = & vc -> residues [ i ] ;\n uint8_t cascade [ 64 ] ;\n unsigned high_bits , low_bits ;\n res_setup -> type = get_bits ( gb , 16 ) ;\n av_dlog ( NULL , \" %u. residue type %d\\n\" , i , res_setup -> type ) ;\n res_setup -> begin = get_bits ( gb , 24 ) ;\n res_setup -> end = get_bits ( gb , 24 ) ;\n res_setup -> partition_size = get_bits ( gb , 24 ) + 1 ;\n if ( res_setup -> begin > res_setup -> end || res_setup -> end > ( res_setup -> type == 2 ? vc -> avctx -> channels : 1 ) * vc -> blocksize [ 1 ] / 2 || ( res_setup -> end - res_setup -> begin ) / res_setup -> partition_size > V_MAX_PARTITIONS ) {\n av_log ( vc -> avctx , AV_LOG_ERROR , \"partition out of bounds: type, begin, end, size, blocksize: %\" PRIu16 \", %\" PRIu32 \", %\" PRIu32 \", %u, %\" PRIu32 \"\\n\" , res_setup -> type , res_setup -> begin , res_setup -> end , res_setup -> partition_size , vc -> blocksize [ 1 ] / 2 ) ;\n return AVERROR_INVALIDDATA ;\n }\n res_setup -> classifications = get_bits ( gb , 6 ) + 1 ;\n GET_VALIDATED_INDEX ( res_setup -> classbook , 8 , vc -> codebook_count ) res_setup -> ptns_to_read = ( res_setup -> end - res_setup -> begin ) / res_setup -> partition_size ;\n res_setup -> classifs = av_malloc ( res_setup -> ptns_to_read * vc -> audio_channels * sizeof ( * res_setup -> classifs ) ) ;\n if ( ! res_setup -> classifs ) return AVERROR ( ENOMEM ) ;\n av_dlog ( NULL , \" begin %d end %d part.size %d classif.s %d classbook %d \\n\" , res_setup -> begin , res_setup -> end , res_setup -> partition_size , res_setup -> classifications , res_setup -> classbook ) ;\n for ( j = 0 ;\n j < res_setup -> classifications ;\n ++ j ) {\n high_bits = 0 ;\n low_bits = get_bits ( gb , 3 ) ;\n if ( get_bits1 ( gb ) ) high_bits = get_bits ( gb , 5 ) ;\n cascade [ j ] = ( high_bits << 3 ) + low_bits ;\n av_dlog ( NULL , \" %u class cascade depth: %d\\n\" , j , ilog ( cascade [ j ] ) ) ;\n }\n res_setup -> maxpass = 0 ;\n for ( j = 0 ;\n j < res_setup -> classifications ;\n ++ j ) {\n for ( k = 0 ;\n k < 8 ;\n ++ k ) {\n if ( cascade [ j ] & ( 1 << k ) ) {\n GET_VALIDATED_INDEX ( res_setup -> books [ j ] [ k ] , 8 , vc -> codebook_count ) av_dlog ( NULL , \" %u class cascade depth %u book: %d\\n\" , j , k , res_setup -> books [ j ] [ k ] ) ;\n if ( k > res_setup -> maxpass ) res_setup -> maxpass = k ;\n }\n else {\n res_setup -> books [ j ] [ k ] = - 1 ;\n }\n }\n }\n }\n return 0 ;\n }", "hash": -8437173884317959107, "project": "debian", "size": 55, "target": 0, "idx": 2476}
{"code": "static void vorbis_free ( vorbis_context * vc ) {\n int i ;\n av_freep ( & vc -> channel_residues ) ;\n av_freep ( & vc -> saved ) ;\n for ( i = 0 ;\n i < vc -> residue_count ;\n i ++ ) av_free ( vc -> residues [ i ] . classifs ) ;\n av_freep ( & vc -> residues ) ;\n av_freep ( & vc -> modes ) ;\n ff_mdct_end ( & vc -> mdct [ 0 ] ) ;\n ff_mdct_end ( & vc -> mdct [ 1 ] ) ;\n for ( i = 0 ;\n i < vc -> codebook_count ;\n ++ i ) {\n av_free ( vc -> codebooks [ i ] . codevectors ) ;\n ff_free_vlc ( & vc -> codebooks [ i ] . vlc ) ;\n }\n av_freep ( & vc -> codebooks ) ;\n for ( i = 0 ;\n i < vc -> floor_count ;\n ++ i ) {\n if ( vc -> floors [ i ] . floor_type == 0 ) {\n av_free ( vc -> floors [ i ] . data . t0 . map [ 0 ] ) ;\n av_free ( vc -> floors [ i ] . data . t0 . map [ 1 ] ) ;\n av_free ( vc -> floors [ i ] . data . t0 . book_list ) ;\n av_free ( vc -> floors [ i ] . data . t0 . lsp ) ;\n }\n else {\n av_free ( vc -> floors [ i ] . data . t1 . list ) ;\n }\n }\n av_freep ( & vc -> floors ) ;\n for ( i = 0 ;\n i < vc -> mapping_count ;\n ++ i ) {\n av_free ( vc -> mappings [ i ] . magnitude ) ;\n av_free ( vc -> mappings [ i ] . angle ) ;\n av_free ( vc -> mappings [ i ] . mux ) ;\n }\n av_freep ( & vc -> mappings ) ;\n }", "hash": -8437173884317959107, "project": "debian", "size": 41, "target": 0, "idx": 2481}
{"code": "static int vorbis_parse_audio_packet ( vorbis_context * vc , float * * floor_ptr ) {\n GetBitContext * gb = & vc -> gb ;\n FFTContext * mdct ;\n unsigned previous_window = vc -> previous_window ;\n unsigned mode_number , blockflag , blocksize ;\n int i , j ;\n uint8_t no_residue [ 255 ] ;\n uint8_t do_not_decode [ 255 ] ;\n vorbis_mapping * mapping ;\n float * ch_res_ptr = vc -> channel_residues ;\n uint8_t res_chan [ 255 ] ;\n unsigned res_num = 0 ;\n int retlen = 0 ;\n unsigned ch_left = vc -> audio_channels ;\n unsigned vlen ;\n if ( get_bits1 ( gb ) ) {\n av_log ( vc -> avctx , AV_LOG_ERROR , \"Not a Vorbis I audio packet.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( vc -> mode_count == 1 ) {\n mode_number = 0 ;\n }\n else {\n GET_VALIDATED_INDEX ( mode_number , ilog ( vc -> mode_count - 1 ) , vc -> mode_count ) }\n vc -> mode_number = mode_number ;\n mapping = & vc -> mappings [ vc -> modes [ mode_number ] . mapping ] ;\n av_dlog ( NULL , \" Mode number: %u , mapping: %d , blocktype %d\\n\" , mode_number , vc -> modes [ mode_number ] . mapping , vc -> modes [ mode_number ] . blockflag ) ;\n blockflag = vc -> modes [ mode_number ] . blockflag ;\n blocksize = vc -> blocksize [ blockflag ] ;\n vlen = blocksize / 2 ;\n if ( blockflag ) {\n previous_window = get_bits ( gb , 1 ) ;\n skip_bits1 ( gb ) ;\n }\n memset ( ch_res_ptr , 0 , sizeof ( float ) * vc -> audio_channels * vlen ) ;\n for ( i = 0 ;\n i < vc -> audio_channels ;\n ++ i ) memset ( floor_ptr [ i ] , 0 , vlen * sizeof ( floor_ptr [ 0 ] [ 0 ] ) ) ;\n for ( i = 0 ;\n i < vc -> audio_channels ;\n ++ i ) {\n vorbis_floor * floor ;\n int ret ;\n if ( mapping -> submaps > 1 ) {\n floor = & vc -> floors [ mapping -> submap_floor [ mapping -> mux [ i ] ] ] ;\n }\n else {\n floor = & vc -> floors [ mapping -> submap_floor [ 0 ] ] ;\n }\n ret = floor -> decode ( vc , & floor -> data , floor_ptr [ i ] ) ;\n if ( ret < 0 ) {\n av_log ( vc -> avctx , AV_LOG_ERROR , \"Invalid codebook in vorbis_floor_decode.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n no_residue [ i ] = ret ;\n }\n for ( i = mapping -> coupling_steps - 1 ;\n i >= 0 ;\n -- i ) {\n if ( ! ( no_residue [ mapping -> magnitude [ i ] ] & no_residue [ mapping -> angle [ i ] ] ) ) {\n no_residue [ mapping -> magnitude [ i ] ] = 0 ;\n no_residue [ mapping -> angle [ i ] ] = 0 ;\n }\n }\n for ( i = 0 ;\n i < mapping -> submaps ;\n ++ i ) {\n vorbis_residue * residue ;\n unsigned ch = 0 ;\n int ret ;\n for ( j = 0 ;\n j < vc -> audio_channels ;\n ++ j ) {\n if ( ( mapping -> submaps == 1 ) || ( i == mapping -> mux [ j ] ) ) {\n res_chan [ j ] = res_num ;\n if ( no_residue [ j ] ) {\n do_not_decode [ ch ] = 1 ;\n }\n else {\n do_not_decode [ ch ] = 0 ;\n }\n ++ ch ;\n ++ res_num ;\n }\n }\n residue = & vc -> residues [ mapping -> submap_residue [ i ] ] ;\n if ( ch_left < ch ) {\n av_log ( vc -> avctx , AV_LOG_ERROR , \"Too many channels in vorbis_floor_decode.\\n\" ) ;\n return - 1 ;\n }\n if ( ch ) {\n ret = vorbis_residue_decode ( vc , residue , ch , do_not_decode , ch_res_ptr , vlen , ch_left ) ;\n if ( ret < 0 ) return ret ;\n }\n ch_res_ptr += ch * vlen ;\n ch_left -= ch ;\n }\n if ( ch_left > 0 ) return AVERROR_INVALIDDATA ;\n for ( i = mapping -> coupling_steps - 1 ;\n i >= 0 ;\n -- i ) {\n float * mag , * ang ;\n mag = vc -> channel_residues + res_chan [ mapping -> magnitude [ i ] ] * blocksize / 2 ;\n ang = vc -> channel_residues + res_chan [ mapping -> angle [ i ] ] * blocksize / 2 ;\n vc -> dsp . vorbis_inverse_coupling ( mag , ang , blocksize / 2 ) ;\n }\n mdct = & vc -> mdct [ blockflag ] ;\n for ( j = vc -> audio_channels - 1 ;\n j >= 0 ;\n j -- ) {\n ch_res_ptr = vc -> channel_residues + res_chan [ j ] * blocksize / 2 ;\n vc -> fdsp . vector_fmul ( floor_ptr [ j ] , floor_ptr [ j ] , ch_res_ptr , blocksize / 2 ) ;\n mdct -> imdct_half ( mdct , ch_res_ptr , floor_ptr [ j ] ) ;\n }\n retlen = ( blocksize + vc -> blocksize [ previous_window ] ) / 4 ;\n for ( j = 0 ;\n j < vc -> audio_channels ;\n j ++ ) {\n unsigned bs0 = vc -> blocksize [ 0 ] ;\n unsigned bs1 = vc -> blocksize [ 1 ] ;\n float * residue = vc -> channel_residues + res_chan [ j ] * blocksize / 2 ;\n float * saved = vc -> saved + j * bs1 / 4 ;\n float * ret = floor_ptr [ j ] ;\n float * buf = residue ;\n const float * win = vc -> win [ blockflag & previous_window ] ;\n if ( blockflag == previous_window ) {\n vc -> fdsp . vector_fmul_window ( ret , saved , buf , win , blocksize / 4 ) ;\n }\n else if ( blockflag > previous_window ) {\n vc -> fdsp . vector_fmul_window ( ret , saved , buf , win , bs0 / 4 ) ;\n memcpy ( ret + bs0 / 2 , buf + bs0 / 4 , ( ( bs1 - bs0 ) / 4 ) * sizeof ( float ) ) ;\n }\n else {\n memcpy ( ret , saved , ( ( bs1 - bs0 ) / 4 ) * sizeof ( float ) ) ;\n vc -> fdsp . vector_fmul_window ( ret + ( bs1 - bs0 ) / 4 , saved + ( bs1 - bs0 ) / 4 , buf , win , bs0 / 4 ) ;\n }\n memcpy ( saved , buf + blocksize / 4 , blocksize / 4 * sizeof ( float ) ) ;\n }\n vc -> previous_window = blockflag ;\n return retlen ;\n }", "hash": -8437173884317959107, "project": "debian", "size": 141, "target": 0, "idx": 2482}
{"code": "static inline int vorbis_residue_decode ( vorbis_context * vc , vorbis_residue * vr , unsigned ch , uint8_t * do_not_decode , float * vec , unsigned vlen , unsigned ch_left ) {\n if ( vr -> type == 2 ) return vorbis_residue_decode_internal ( vc , vr , ch , do_not_decode , vec , vlen , ch_left , 2 ) ;\n else if ( vr -> type == 1 ) return vorbis_residue_decode_internal ( vc , vr , ch , do_not_decode , vec , vlen , ch_left , 1 ) ;\n else if ( vr -> type == 0 ) return vorbis_residue_decode_internal ( vc , vr , ch , do_not_decode , vec , vlen , ch_left , 0 ) ;\n else {\n av_log ( vc -> avctx , AV_LOG_ERROR , \" Invalid residue type while residue decode?! \\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n }", "hash": -8437173884317959107, "project": "debian", "size": 9, "target": 0, "idx": 2485}
{"code": "static int vorbis_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n vorbis_context * vc = avctx -> priv_data ;\n AVFrame * frame = data ;\n GetBitContext * gb = & vc -> gb ;\n float * channel_ptrs [ 255 ] ;\n int i , len , ret ;\n av_dlog ( NULL , \"packet length %d \\n\" , buf_size ) ;\n frame -> nb_samples = vc -> blocksize [ 1 ] / 2 ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( vc -> audio_channels > 8 ) {\n for ( i = 0 ;\n i < vc -> audio_channels ;\n i ++ ) channel_ptrs [ i ] = ( float * ) frame -> extended_data [ i ] ;\n }\n else {\n for ( i = 0 ;\n i < vc -> audio_channels ;\n i ++ ) {\n int ch = ff_vorbis_channel_layout_offsets [ vc -> audio_channels - 1 ] [ i ] ;\n channel_ptrs [ ch ] = ( float * ) frame -> extended_data [ i ] ;\n }\n }\n init_get_bits ( gb , buf , buf_size * 8 ) ;\n if ( ( len = vorbis_parse_audio_packet ( vc , channel_ptrs ) ) <= 0 ) return len ;\n if ( ! vc -> first_frame ) {\n vc -> first_frame = 1 ;\n * got_frame_ptr = 0 ;\n return buf_size ;\n }\n av_dlog ( NULL , \"parsed %d bytes %d bits, returned %d samples (*ch*bits) \\n\" , get_bits_count ( gb ) / 8 , get_bits_count ( gb ) % 8 , len ) ;\n frame -> nb_samples = len ;\n * got_frame_ptr = 1 ;\n return buf_size ;\n }", "hash": -8437173884317959107, "project": "debian", "size": 39, "target": 0, "idx": 2486}
{"code": "void ff_h263_encode_init ( MpegEncContext * s ) {\n static int done = 0 ;\n if ( ! done ) {\n done = 1 ;\n ff_init_rl ( & ff_h263_rl_inter , ff_h263_static_rl_table_store [ 0 ] ) ;\n ff_init_rl ( & ff_rl_intra_aic , ff_h263_static_rl_table_store [ 1 ] ) ;\n init_uni_h263_rl_tab ( & ff_rl_intra_aic , NULL , uni_h263_intra_aic_rl_len ) ;\n init_uni_h263_rl_tab ( & ff_h263_rl_inter , NULL , uni_h263_inter_rl_len ) ;\n init_mv_penalty_and_fcode ( s ) ;\n }\n s -> me . mv_penalty = mv_penalty ;\n s -> intra_ac_vlc_length = s -> inter_ac_vlc_length = uni_h263_inter_rl_len ;\n s -> intra_ac_vlc_last_length = s -> inter_ac_vlc_last_length = uni_h263_inter_rl_len + 128 * 64 ;\n if ( s -> h263_aic ) {\n s -> intra_ac_vlc_length = uni_h263_intra_aic_rl_len ;\n s -> intra_ac_vlc_last_length = uni_h263_intra_aic_rl_len + 128 * 64 ;\n }\n s -> ac_esc_length = 7 + 1 + 6 + 8 ;\n switch ( s -> codec_id ) {\n case AV_CODEC_ID_MPEG4 : s -> fcode_tab = fcode_tab ;\n break ;\n case AV_CODEC_ID_H263P : if ( s -> umvplus ) s -> fcode_tab = umv_fcode_tab ;\n if ( s -> modified_quant ) {\n s -> min_qcoeff = - 2047 ;\n s -> max_qcoeff = 2047 ;\n }\n else {\n s -> min_qcoeff = - 127 ;\n s -> max_qcoeff = 127 ;\n }\n break ;\n case AV_CODEC_ID_FLV1 : if ( s -> h263_flv > 1 ) {\n s -> min_qcoeff = - 1023 ;\n s -> max_qcoeff = 1023 ;\n }\n else {\n s -> min_qcoeff = - 127 ;\n s -> max_qcoeff = 127 ;\n }\n s -> y_dc_scale_table = s -> c_dc_scale_table = ff_mpeg1_dc_scale_table ;\n break ;\n default : / othing needed - default table already set in mpegvideo . c s -> min_qcoeff = - 127 ;\n s -> max_qcoeff = 127 ;\n s -> y_dc_scale_table = s -> c_dc_scale_table = ff_mpeg1_dc_scale_table ;\n }\n }", "hash": 8436997111466619903, "project": "debian", "size": 46, "target": 0, "idx": 2488}
{"code": "static int decode_exp_vlc ( WMACodecContext * s , int ch ) {\n int last_exp , n , code ;\n const uint16_t * ptr ;\n float v , max_scale ;\n uint32_t * q , * q_end , iv ;\n const float * ptab = pow_tab + 60 ;\n const uint32_t * iptab = ( const uint32_t * ) ptab ;\n ptr = s -> exponent_bands [ s -> frame_len_bits - s -> block_len_bits ] ;\n q = ( uint32_t * ) s -> exponents [ ch ] ;\n q_end = q + s -> block_len ;\n max_scale = 0 ;\n if ( s -> version == 1 ) {\n last_exp = get_bits ( & s -> gb , 5 ) + 10 ;\n v = ptab [ last_exp ] ;\n iv = iptab [ last_exp ] ;\n max_scale = v ;\n n = * ptr ++ ;\n switch ( n & 3 ) do {\n case 0 : * q ++ = iv ;\n case 3 : * q ++ = iv ;\n case 2 : * q ++ = iv ;\n case 1 : * q ++ = iv ;\n }\n while ( ( n -= 4 ) > 0 ) ;\n }\n else last_exp = 36 ;\n while ( q < q_end ) {\n code = get_vlc2 ( & s -> gb , s -> exp_vlc . table , EXPVLCBITS , EXPMAX ) ;\n if ( code < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Exponent vlc invalid\\n\" ) ;\n return - 1 ;\n }\n last_exp += code - 60 ;\n if ( ( unsigned ) last_exp + 60 >= FF_ARRAY_ELEMS ( pow_tab ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Exponent out of range: %d\\n\" , last_exp ) ;\n return - 1 ;\n }\n v = ptab [ last_exp ] ;\n iv = iptab [ last_exp ] ;\n if ( v > max_scale ) max_scale = v ;\n n = * ptr ++ ;\n switch ( n & 3 ) do {\n case 0 : * q ++ = iv ;\n case 3 : * q ++ = iv ;\n case 2 : * q ++ = iv ;\n case 1 : * q ++ = iv ;\n }\n while ( ( n -= 4 ) > 0 ) ;\n }\n s -> max_exponent [ ch ] = max_scale ;\n return 0 ;\n }", "hash": -2922528420890432122, "project": "debian", "size": 52, "target": 0, "idx": 2506}
{"code": "static void ac3_upmix_delay ( AC3DecodeContext * s ) {\n int channel_data_size = sizeof ( s -> delay [ 0 ] ) ;\n switch ( s -> channel_mode ) {\n case AC3_CHMODE_DUALMONO : case AC3_CHMODE_STEREO : memcpy ( s -> delay [ 1 ] , s -> delay [ 0 ] , channel_data_size ) ;\n break ;\n case AC3_CHMODE_2F2R : memset ( s -> delay [ 3 ] , 0 , channel_data_size ) ;\n case AC3_CHMODE_2F1R : memset ( s -> delay [ 2 ] , 0 , channel_data_size ) ;\n break ;\n case AC3_CHMODE_3F2R : memset ( s -> delay [ 4 ] , 0 , channel_data_size ) ;\n case AC3_CHMODE_3F1R : memset ( s -> delay [ 3 ] , 0 , channel_data_size ) ;\n case AC3_CHMODE_3F : memcpy ( s -> delay [ 2 ] , s -> delay [ 1 ] , channel_data_size ) ;\n memset ( s -> delay [ 1 ] , 0 , channel_data_size ) ;\n break ;\n }\n }", "hash": 3071315158823512715, "project": "debian", "size": 15, "target": 0, "idx": 2519}
{"code": "static void decode_transform_coeffs ( AC3DecodeContext * s , int blk ) {\n int ch , end ;\n int got_cplchan = 0 ;\n mant_groups m ;\n m . b1 = m . b2 = m . b4 = 0 ;\n for ( ch = 1 ;\n ch <= s -> channels ;\n ch ++ ) {\n decode_transform_coeffs_ch ( s , blk , ch , & m ) ;\n if ( s -> channel_in_cpl [ ch ] ) {\n if ( ! got_cplchan ) {\n decode_transform_coeffs_ch ( s , blk , CPL_CH , & m ) ;\n calc_transform_coeffs_cpl ( s ) ;\n got_cplchan = 1 ;\n }\n end = s -> end_freq [ CPL_CH ] ;\n }\n else {\n end = s -> end_freq [ ch ] ;\n }\n do s -> fixed_coeffs [ ch ] [ end ] = 0 ;\n while ( ++ end < 256 ) ;\n }\n remove_dithering ( s ) ;\n }", "hash": 3071315158823512715, "project": "debian", "size": 25, "target": 0, "idx": 2522}
{"code": "static Picture * find_short ( H264Context * h , int frame_num , int * idx ) {\n int i ;\n for ( i = 0 ;\n i < h -> short_ref_count ;\n i ++ ) {\n Picture * pic = h -> short_ref [ i ] ;\n if ( h -> avctx -> debug & FF_DEBUG_MMCO ) av_log ( h -> avctx , AV_LOG_DEBUG , \"%d %d %p\\n\" , i , pic -> frame_num , pic ) ;\n if ( pic -> frame_num == frame_num ) {\n * idx = i ;\n return pic ;\n }\n }\n return NULL ;\n }", "hash": -1658505547857059267, "project": "debian", "size": 14, "target": 0, "idx": 2533}
{"code": "void ff_h264_direct_ref_list_init ( H264Context * const h ) {\n Picture * const ref1 = & h -> ref_list [ 1 ] [ 0 ] ;\n Picture * const cur = h -> cur_pic_ptr ;\n int list , j , field ;\n int sidx = ( h -> picture_structure & 1 ) ^ 1 ;\n int ref1sidx = ( ref1 -> reference & 1 ) ^ 1 ;\n for ( list = 0 ;\n list < 2 ;\n list ++ ) {\n cur -> ref_count [ sidx ] [ list ] = h -> ref_count [ list ] ;\n for ( j = 0 ;\n j < h -> ref_count [ list ] ;\n j ++ ) cur -> ref_poc [ sidx ] [ list ] [ j ] = 4 * h -> ref_list [ list ] [ j ] . frame_num + ( h -> ref_list [ list ] [ j ] . reference & 3 ) ;\n }\n if ( h -> picture_structure == PICT_FRAME ) {\n memcpy ( cur -> ref_count [ 1 ] , cur -> ref_count [ 0 ] , sizeof ( cur -> ref_count [ 0 ] ) ) ;\n memcpy ( cur -> ref_poc [ 1 ] , cur -> ref_poc [ 0 ] , sizeof ( cur -> ref_poc [ 0 ] ) ) ;\n }\n cur -> mbaff = FRAME_MBAFF ;\n h -> col_fieldoff = 0 ;\n if ( h -> picture_structure == PICT_FRAME ) {\n int cur_poc = h -> cur_pic_ptr -> poc ;\n int * col_poc = h -> ref_list [ 1 ] -> field_poc ;\n h -> col_parity = ( FFABS ( col_poc [ 0 ] - cur_poc ) >= FFABS ( col_poc [ 1 ] - cur_poc ) ) ;\n ref1sidx = sidx = h -> col_parity ;\n }\n else if ( ! ( h -> picture_structure & h -> ref_list [ 1 ] [ 0 ] . reference ) && ! h -> ref_list [ 1 ] [ 0 ] . mbaff ) {\n h -> col_fieldoff = 2 * h -> ref_list [ 1 ] [ 0 ] . reference - 3 ;\n }\n if ( h -> slice_type_nos != AV_PICTURE_TYPE_B || h -> direct_spatial_mv_pred ) return ;\n for ( list = 0 ;\n list < 2 ;\n list ++ ) {\n fill_colmap ( h , h -> map_col_to_list0 , list , sidx , ref1sidx , 0 ) ;\n if ( FRAME_MBAFF ) for ( field = 0 ;\n field < 2 ;\n field ++ ) fill_colmap ( h , h -> map_col_to_list0_field [ field ] , list , field , field , 1 ) ;\n }\n }", "hash": 1743019814289113128, "project": "debian", "size": 39, "target": 0, "idx": 2566}
{"code": "static inline void xan_wc3_copy_pixel_run ( XanContext * s , AVFrame * frame , int x , int y , int pixel_count , int motion_x , int motion_y ) {\n int stride ;\n int line_inc ;\n int curframe_index , prevframe_index ;\n int curframe_x , prevframe_x ;\n int width = s -> avctx -> width ;\n unsigned char * palette_plane , * prev_palette_plane ;\n if ( y + motion_y < 0 || y + motion_y >= s -> avctx -> height || x + motion_x < 0 || x + motion_x >= s -> avctx -> width ) return ;\n palette_plane = frame -> data [ 0 ] ;\n prev_palette_plane = s -> last_frame . data [ 0 ] ;\n if ( ! prev_palette_plane ) prev_palette_plane = palette_plane ;\n stride = frame -> linesize [ 0 ] ;\n line_inc = stride - width ;\n curframe_index = y * stride + x ;\n curframe_x = x ;\n prevframe_index = ( y + motion_y ) * stride + x + motion_x ;\n prevframe_x = x + motion_x ;\n while ( pixel_count && curframe_index < s -> frame_size && prevframe_index < s -> frame_size ) {\n int count = FFMIN3 ( pixel_count , width - curframe_x , width - prevframe_x ) ;\n memcpy ( palette_plane + curframe_index , prev_palette_plane + prevframe_index , count ) ;\n pixel_count -= count ;\n curframe_index += count ;\n prevframe_index += count ;\n curframe_x += count ;\n prevframe_x += count ;\n if ( curframe_x >= width ) {\n curframe_index += line_inc ;\n curframe_x = 0 ;\n }\n if ( prevframe_x >= width ) {\n prevframe_index += line_inc ;\n prevframe_x = 0 ;\n }\n }\n }", "hash": 8953904005695962093, "project": "debian", "size": 35, "target": 0, "idx": 2572}
{"code": "static int mpeg4_decode_partitioned_mb ( MpegEncContext * s , int16_t block [ 6 ] [ 64 ] ) {\n int cbp , mb_type ;\n const int xy = s -> mb_x + s -> mb_y * s -> mb_stride ;\n mb_type = s -> current_picture . mb_type [ xy ] ;\n cbp = s -> cbp_table [ xy ] ;\n s -> use_intra_dc_vlc = s -> qscale < s -> intra_dc_threshold ;\n if ( s -> current_picture . qscale_table [ xy ] != s -> qscale ) {\n ff_set_qscale ( s , s -> current_picture . qscale_table [ xy ] ) ;\n }\n if ( s -> pict_type == AV_PICTURE_TYPE_P || s -> pict_type == AV_PICTURE_TYPE_S ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n s -> mv [ 0 ] [ i ] [ 0 ] = s -> current_picture . motion_val [ 0 ] [ s -> block_index [ i ] ] [ 0 ] ;\n s -> mv [ 0 ] [ i ] [ 1 ] = s -> current_picture . motion_val [ 0 ] [ s -> block_index [ i ] ] [ 1 ] ;\n }\n s -> mb_intra = IS_INTRA ( mb_type ) ;\n if ( IS_SKIP ( mb_type ) ) {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) s -> block_last_index [ i ] = - 1 ;\n s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_16X16 ;\n if ( s -> pict_type == AV_PICTURE_TYPE_S && s -> vol_sprite_usage == GMC_SPRITE ) {\n s -> mcsel = 1 ;\n s -> mb_skipped = 0 ;\n }\n else {\n s -> mcsel = 0 ;\n s -> mb_skipped = 1 ;\n }\n }\n else if ( s -> mb_intra ) {\n s -> ac_pred = IS_ACPRED ( s -> current_picture . mb_type [ xy ] ) ;\n }\n else if ( ! s -> mb_intra ) {\n s -> mv_dir = MV_DIR_FORWARD ;\n if ( IS_8X8 ( mb_type ) ) {\n s -> mv_type = MV_TYPE_8X8 ;\n }\n else {\n s -> mv_type = MV_TYPE_16X16 ;\n }\n }\n }\n else {\n s -> mb_intra = 1 ;\n s -> ac_pred = IS_ACPRED ( s -> current_picture . mb_type [ xy ] ) ;\n }\n if ( ! IS_SKIP ( mb_type ) ) {\n int i ;\n s -> dsp . clear_blocks ( s -> block [ 0 ] ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( mpeg4_decode_block ( s , block [ i ] , i , cbp & 32 , s -> mb_intra , s -> rvlc ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"texture corrupted at %d %d %d\\n\" , s -> mb_x , s -> mb_y , s -> mb_intra ) ;\n return - 1 ;\n }\n cbp += cbp ;\n }\n }\n if ( -- s -> mb_num_left <= 0 ) {\n if ( mpeg4_is_resync ( s ) ) return SLICE_END ;\n else return SLICE_NOEND ;\n }\n else {\n if ( mpeg4_is_resync ( s ) ) {\n const int delta = s -> mb_x + 1 == s -> mb_width ? 2 : 1 ;\n if ( s -> cbp_table [ xy + delta ] ) return SLICE_END ;\n }\n return SLICE_OK ;\n }\n }", "hash": 8672904772426696383, "project": "debian", "size": 75, "target": 0, "idx": 2595}
{"code": "void ff_mpeg4_pred_ac ( MpegEncContext * s , int16_t * block , int n , int dir ) {\n int i ;\n int16_t * ac_val , * ac_val1 ;\n int8_t * const qscale_table = s -> current_picture . qscale_table ;\n ac_val = s -> ac_val [ 0 ] [ 0 ] + s -> block_index [ n ] * 16 ;\n ac_val1 = ac_val ;\n if ( s -> ac_pred ) {\n if ( dir == 0 ) {\n const int xy = s -> mb_x - 1 + s -> mb_y * s -> mb_stride ;\n ac_val -= 16 ;\n if ( s -> mb_x == 0 || s -> qscale == qscale_table [ xy ] || n == 1 || n == 3 ) {\n for ( i = 1 ;\n i < 8 ;\n i ++ ) {\n block [ s -> dsp . idct_permutation [ i << 3 ] ] += ac_val [ i ] ;\n }\n }\n else {\n for ( i = 1 ;\n i < 8 ;\n i ++ ) {\n block [ s -> dsp . idct_permutation [ i << 3 ] ] += ROUNDED_DIV ( ac_val [ i ] * qscale_table [ xy ] , s -> qscale ) ;\n }\n }\n }\n else {\n const int xy = s -> mb_x + s -> mb_y * s -> mb_stride - s -> mb_stride ;\n ac_val -= 16 * s -> block_wrap [ n ] ;\n if ( s -> mb_y == 0 || s -> qscale == qscale_table [ xy ] || n == 2 || n == 3 ) {\n for ( i = 1 ;\n i < 8 ;\n i ++ ) {\n block [ s -> dsp . idct_permutation [ i ] ] += ac_val [ i + 8 ] ;\n }\n }\n else {\n for ( i = 1 ;\n i < 8 ;\n i ++ ) {\n block [ s -> dsp . idct_permutation [ i ] ] += ROUNDED_DIV ( ac_val [ i + 8 ] * qscale_table [ xy ] , s -> qscale ) ;\n }\n }\n }\n }\n for ( i = 1 ;\n i < 8 ;\n i ++ ) ac_val1 [ i ] = block [ s -> dsp . idct_permutation [ i << 3 ] ] ;\n for ( i = 1 ;\n i < 8 ;\n i ++ ) ac_val1 [ 8 + i ] = block [ s -> dsp . idct_permutation [ i ] ] ;\n }", "hash": 8672904772426696383, "project": "debian", "size": 51, "target": 0, "idx": 2605}
{"code": "static void pitch_sharpening ( AMRWBContext * ctx , float * fixed_vector ) {\n int i ;\n for ( i = AMRWB_SFR_SIZE - 1 ;\n i != 0 ;\n i -- ) fixed_vector [ i ] -= fixed_vector [ i - 1 ] * ctx -> tilt_coef ;\n for ( i = ctx -> pitch_lag_int ;\n i < AMRWB_SFR_SIZE ;\n i ++ ) fixed_vector [ i ] += fixed_vector [ i - ctx -> pitch_lag_int ] * 0.85 ;\n }", "hash": -7019074708255236794, "project": "debian", "size": 9, "target": 0, "idx": 2606}
{"code": "static void scaled_hb_excitation ( AMRWBContext * ctx , float * hb_exc , const float * synth_exc , float hb_gain ) {\n int i ;\n float energy = avpriv_scalarproduct_float_c ( synth_exc , synth_exc , AMRWB_SFR_SIZE ) ;\n for ( i = 0 ;\n i < AMRWB_SFR_SIZE_16k ;\n i ++ ) hb_exc [ i ] = 32768.0 - ( uint16_t ) av_lfg_get ( & ctx -> prng ) ;\n ff_scale_vector_to_given_sum_of_squares ( hb_exc , hb_exc , energy * hb_gain * hb_gain , AMRWB_SFR_SIZE_16k ) ;\n }", "hash": -7019074708255236794, "project": "debian", "size": 8, "target": 0, "idx": 2613}
{"code": "static float noise_enhancer ( float fixed_gain , float * prev_tr_gain , float voice_fac , float stab_fac ) {\n float sm_fac = 0.5 * ( 1 - voice_fac ) * stab_fac ;\n float g0 ;\n if ( fixed_gain < * prev_tr_gain ) {\n g0 = FFMIN ( * prev_tr_gain , fixed_gain + fixed_gain * ( 6226 * ( 1.0f / ( 1 << 15 ) ) ) ) ;\n }\n else g0 = FFMAX ( * prev_tr_gain , fixed_gain * ( 27536 * ( 1.0f / ( 1 << 15 ) ) ) ) ;\n * prev_tr_gain = g0 ;\n return sm_fac * g0 + ( 1 - sm_fac ) * fixed_gain ;\n }", "hash": -7019074708255236794, "project": "debian", "size": 10, "target": 0, "idx": 2615}
{"code": "static int tscc2_decode_slice ( TSCC2Context * c , int mb_y , const uint8_t * buf , int buf_size ) {\n int i , mb_x , q , ret ;\n int off ;\n init_get_bits ( & c -> gb , buf , buf_size * 8 ) ;\n for ( mb_x = 0 ;\n mb_x < c -> mb_width ;\n mb_x ++ ) {\n q = c -> slice_quants [ mb_x + c -> mb_width * mb_y ] ;\n if ( q == 0 || q == 3 ) continue ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n off = mb_x * 16 + mb_y * 8 * c -> pic . linesize [ i ] ;\n ret = tscc2_decode_mb ( c , c -> q [ q - 1 ] , c -> quant [ q - 1 ] - 2 , c -> pic . data [ i ] + off , c -> pic . linesize [ i ] , i ) ;\n if ( ret ) return ret ;\n }\n }\n return 0 ;\n }", "hash": 6216601921913354724, "project": "debian", "size": 19, "target": 0, "idx": 2641}
{"code": "static int ff_h261_resync ( H261Context * h ) {\n MpegEncContext * const s = & h -> s ;\n int left , ret ;\n if ( h -> gob_start_code_skipped ) {\n ret = h261_decode_gob_header ( h ) ;\n if ( ret >= 0 ) return 0 ;\n }\n else {\n if ( show_bits ( & s -> gb , 15 ) == 0 ) {\n ret = h261_decode_gob_header ( h ) ;\n if ( ret >= 0 ) return 0 ;\n }\n s -> gb = s -> last_resync_gb ;\n align_get_bits ( & s -> gb ) ;\n left = get_bits_left ( & s -> gb ) ;\n for ( ;\n left > 15 + 1 + 4 + 5 ;\n left -= 8 ) {\n if ( show_bits ( & s -> gb , 15 ) == 0 ) {\n GetBitContext bak = s -> gb ;\n ret = h261_decode_gob_header ( h ) ;\n if ( ret >= 0 ) return 0 ;\n s -> gb = bak ;\n }\n skip_bits ( & s -> gb , 8 ) ;\n }\n }\n return - 1 ;\n }", "hash": 2600695546378251053, "project": "debian", "size": 29, "target": 0, "idx": 2645}
{"code": "static int h261_decode_mb ( H261Context * h ) {\n MpegEncContext * const s = & h -> s ;\n int i , cbp , xy ;\n cbp = 63 ;\n do {\n h -> mba_diff = get_vlc2 ( & s -> gb , h261_mba_vlc . table , H261_MBA_VLC_BITS , 2 ) ;\n if ( h -> mba_diff == MBA_STARTCODE ) {\n h -> gob_start_code_skipped = 1 ;\n return SLICE_END ;\n }\n }\n while ( h -> mba_diff == MBA_STUFFING ) ;\n if ( h -> mba_diff < 0 ) {\n if ( get_bits_left ( & s -> gb ) <= 7 ) return SLICE_END ;\n av_log ( s -> avctx , AV_LOG_ERROR , \"illegal mba at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return SLICE_ERROR ;\n }\n h -> mba_diff += 1 ;\n h -> current_mba += h -> mba_diff ;\n if ( h -> current_mba > MBA_STUFFING ) return SLICE_ERROR ;\n s -> mb_x = ( ( h -> gob_number - 1 ) % 2 ) * 11 + ( ( h -> current_mba - 1 ) % 11 ) ;\n s -> mb_y = ( ( h -> gob_number - 1 ) / 2 ) * 3 + ( ( h -> current_mba - 1 ) / 11 ) ;\n xy = s -> mb_x + s -> mb_y * s -> mb_stride ;\n ff_init_block_index ( s ) ;\n ff_update_block_index ( s ) ;\n h -> mtype = get_vlc2 ( & s -> gb , h261_mtype_vlc . table , H261_MTYPE_VLC_BITS , 2 ) ;\n h -> mtype = h261_mtype_map [ h -> mtype ] ;\n if ( IS_QUANT ( h -> mtype ) ) {\n ff_set_qscale ( s , get_bits ( & s -> gb , 5 ) ) ;\n }\n s -> mb_intra = IS_INTRA4x4 ( h -> mtype ) ;\n if ( IS_16X16 ( h -> mtype ) ) {\n if ( ( h -> current_mba == 1 ) || ( h -> current_mba == 12 ) || ( h -> current_mba == 23 ) || ( h -> mba_diff != 1 ) ) {\n h -> current_mv_x = 0 ;\n h -> current_mv_y = 0 ;\n }\n h -> current_mv_x = decode_mv_component ( & s -> gb , h -> current_mv_x ) ;\n h -> current_mv_y = decode_mv_component ( & s -> gb , h -> current_mv_y ) ;\n }\n else {\n h -> current_mv_x = 0 ;\n h -> current_mv_y = 0 ;\n }\n if ( HAS_CBP ( h -> mtype ) ) {\n cbp = get_vlc2 ( & s -> gb , h261_cbp_vlc . table , H261_CBP_VLC_BITS , 2 ) + 1 ;\n }\n if ( s -> mb_intra ) {\n s -> current_picture . mb_type [ xy ] = MB_TYPE_INTRA ;\n goto intra ;\n }\n s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_16X16 ;\n s -> current_picture . mb_type [ xy ] = MB_TYPE_16x16 | MB_TYPE_L0 ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = h -> current_mv_x * 2 ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = h -> current_mv_y * 2 ;\n intra : if ( s -> mb_intra || HAS_CBP ( h -> mtype ) ) {\n s -> dsp . clear_blocks ( s -> block [ 0 ] ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( h261_decode_block ( h , s -> block [ i ] , i , cbp & 32 ) < 0 ) {\n return SLICE_ERROR ;\n }\n cbp += cbp ;\n }\n }\n else {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) s -> block_last_index [ i ] = - 1 ;\n }\n ff_MPV_decode_mb ( s , s -> block ) ;\n return SLICE_OK ;\n }", "hash": 2600695546378251053, "project": "debian", "size": 74, "target": 0, "idx": 2653}
{"code": "static int msrle_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n MsrleContext * s = avctx -> priv_data ;\n int istride = FFALIGN ( avctx -> width * avctx -> bits_per_coded_sample , 32 ) / 8 ;\n int ret ;\n s -> buf = buf ;\n s -> size = buf_size ;\n if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( avctx -> bits_per_coded_sample <= 8 ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n s -> frame . palette_has_changed = 1 ;\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n }\n memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n }\n if ( avctx -> height * istride == avpkt -> size ) {\n int linesize = avctx -> width * avctx -> bits_per_coded_sample / 8 ;\n uint8_t * ptr = s -> frame . data [ 0 ] ;\n uint8_t * buf = avpkt -> data + ( avctx -> height - 1 ) * istride ;\n int i , j ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n if ( avctx -> bits_per_coded_sample == 4 ) {\n for ( j = 0 ;\n j < avctx -> width - 1 ;\n j += 2 ) {\n ptr [ j + 0 ] = buf [ j >> 1 ] >> 4 ;\n ptr [ j + 1 ] = buf [ j >> 1 ] & 0xF ;\n }\n if ( avctx -> width & 1 ) ptr [ j + 0 ] = buf [ j >> 1 ] >> 4 ;\n }\n else {\n memcpy ( ptr , buf , linesize ) ;\n }\n buf -= istride ;\n ptr += s -> frame . linesize [ 0 ] ;\n }\n }\n else {\n bytestream2_init ( & s -> gb , buf , buf_size ) ;\n ff_msrle_decode ( avctx , ( AVPicture * ) & s -> frame , avctx -> bits_per_coded_sample , & s -> gb ) ;\n }\n if ( ( ret = av_frame_ref ( data , & s -> frame ) ) < 0 ) return ret ;\n * got_frame = 1 ;\n return buf_size ;\n }", "hash": -2905271518485324905, "project": "debian", "size": 52, "target": 0, "idx": 2655}
{"code": "static int decode ( MimicContext * ctx , int quality , int num_coeffs , int is_iframe ) {\n int ret , y , x , plane , cur_row = 0 ;\n for ( plane = 0 ;\n plane < 3 ;\n plane ++ ) {\n const int is_chroma = ! ! plane ;\n const int qscale = av_clip ( 10000 - quality , is_chroma ? 1000 : 2000 , 10000 ) << 2 ;\n const int stride = ctx -> flipped_ptrs [ ctx -> cur_index ] . linesize [ plane ] ;\n const uint8_t * src = ctx -> flipped_ptrs [ ctx -> prev_index ] . data [ plane ] ;\n uint8_t * dst = ctx -> flipped_ptrs [ ctx -> cur_index ] . data [ plane ] ;\n for ( y = 0 ;\n y < ctx -> num_vblocks [ plane ] ;\n y ++ ) {\n for ( x = 0 ;\n x < ctx -> num_hblocks [ plane ] ;\n x ++ ) {\n if ( is_iframe || get_bits1 ( & ctx -> gb ) == is_chroma ) {\n if ( is_chroma || is_iframe || ! get_bits1 ( & ctx -> gb ) ) {\n if ( ( ret = vlc_decode_block ( ctx , num_coeffs , qscale ) ) < 0 ) {\n av_log ( ctx -> avctx , AV_LOG_ERROR , \"Error decoding \" \"block.\\n\" ) ;\n return ret ;\n }\n ctx -> dsp . idct_put ( dst , stride , ctx -> dct_block ) ;\n }\n else {\n unsigned int backref = get_bits ( & ctx -> gb , 4 ) ;\n int index = ( ctx -> cur_index + backref ) & 15 ;\n uint8_t * p = ctx -> flipped_ptrs [ index ] . data [ 0 ] ;\n if ( index != ctx -> cur_index && p ) {\n ff_thread_await_progress ( & ctx -> frames [ index ] , cur_row , 0 ) ;\n p += src - ctx -> flipped_ptrs [ ctx -> prev_index ] . data [ plane ] ;\n ctx -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , p , stride , 8 ) ;\n }\n else {\n av_log ( ctx -> avctx , AV_LOG_ERROR , \"No such backreference! Buggy sample.\\n\" ) ;\n }\n }\n }\n else {\n ff_thread_await_progress ( & ctx -> frames [ ctx -> prev_index ] , cur_row , 0 ) ;\n ctx -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , src , stride , 8 ) ;\n }\n src += 8 ;\n dst += 8 ;\n }\n src += ( stride - ctx -> num_hblocks [ plane ] ) << 3 ;\n dst += ( stride - ctx -> num_hblocks [ plane ] ) << 3 ;\n ff_thread_report_progress ( & ctx -> frames [ ctx -> cur_index ] , cur_row ++ , 0 ) ;\n }\n }\n return 0 ;\n }", "hash": -2504372172279754762, "project": "debian", "size": 52, "target": 0, "idx": 2660}
{"code": "static int vlc_decode_block ( MimicContext * ctx , int num_coeffs , int qscale ) {\n int16_t * block = ctx -> dct_block ;\n unsigned int pos ;\n ctx -> dsp . clear_block ( block ) ;\n block [ 0 ] = get_bits ( & ctx -> gb , 8 ) << 3 ;\n for ( pos = 1 ;\n pos < num_coeffs ;\n pos ++ ) {\n uint32_t vlc , num_bits ;\n int value ;\n int coeff ;\n vlc = get_vlc2 ( & ctx -> gb , ctx -> vlc . table , ctx -> vlc . bits , 3 ) ;\n if ( ! vlc ) return 0 ;\n if ( vlc == - 1 ) return AVERROR_INVALIDDATA ;\n pos += vlc & 15 ;\n num_bits = vlc >> 4 ;\n if ( pos >= 64 ) return AVERROR_INVALIDDATA ;\n value = get_bits ( & ctx -> gb , num_bits ) ;\n coeff = vlcdec_lookup [ num_bits ] [ value ] ;\n if ( pos < 3 ) coeff <<= 4 ;\n else coeff = ( coeff * qscale ) / 1001 ;\n block [ ctx -> scantable . permutated [ pos ] ] = coeff ;\n }\n return 0 ;\n }", "hash": -2504372172279754762, "project": "debian", "size": 25, "target": 0, "idx": 2661}
{"code": "static int fraps2_decode_plane ( FrapsContext * s , uint8_t * dst , int stride , int w , int h , const uint8_t * src , int size , int Uoff , const int step ) {\n int i , j , ret ;\n GetBitContext gb ;\n VLC vlc ;\n Node nodes [ 512 ] ;\n for ( i = 0 ;\n i < 256 ;\n i ++ ) nodes [ i ] . count = bytestream_get_le32 ( & src ) ;\n size -= 1024 ;\n if ( ( ret = ff_huff_build_tree ( s -> avctx , & vlc , 256 , nodes , huff_cmp , FF_HUFFMAN_FLAG_ZERO_COUNT ) ) < 0 ) return ret ;\n s -> dsp . bswap_buf ( ( uint32_t * ) s -> tmpbuf , ( const uint32_t * ) src , size >> 2 ) ;\n init_get_bits ( & gb , s -> tmpbuf , size * 8 ) ;\n for ( j = 0 ;\n j < h ;\n j ++ ) {\n for ( i = 0 ;\n i < w * step ;\n i += step ) {\n dst [ i ] = get_vlc2 ( & gb , vlc . table , 9 , 3 ) ;\n if ( j ) dst [ i ] += dst [ i - stride ] ;\n else if ( Uoff ) dst [ i ] += 0x80 ;\n if ( get_bits_left ( & gb ) < 0 ) {\n ff_free_vlc ( & vlc ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n dst += stride ;\n }\n ff_free_vlc ( & vlc ) ;\n return 0 ;\n }", "hash": 7698410135314428663, "project": "debian", "size": 31, "target": 0, "idx": 2665}
{"code": "static int very_broken_op ( int a , int b ) {\n int x = a * b + 200 ;\n int size ;\n const uint8_t * rtab ;\n if ( x % 400 || b % 5 ) return x / 400 ;\n x /= 400 ;\n size = tabs [ b / 5 ] . size ;\n rtab = tabs [ b / 5 ] . tab ;\n return x - rtab [ size * av_log2 ( 2 * ( x - 1 ) / size ) + ( x - 1 ) % size ] ;\n }", "hash": 2755982813601944893, "project": "debian", "size": 10, "target": 0, "idx": 2682}
{"code": "static inline void eval_lpcenv_or_interp ( TwinContext * tctx , enum FrameType ftype , float * out , const float * in , int size , int step , int part ) {\n int i ;\n const ModeTab * mtab = tctx -> mtab ;\n const float * cos_tab = tctx -> cos_tabs [ ftype ] ;\n for ( i = 0 ;\n i < size ;\n i += step ) out [ i ] = eval_lpc_spectrum ( in , get_cos ( i , part , cos_tab , size ) , mtab -> n_lsp ) ;\n for ( i = step ;\n i <= size - 2 * step ;\n i += step ) {\n if ( out [ i + step ] + out [ i - step ] > 1.95 * out [ i ] || out [ i + step ] >= out [ i - step ] ) {\n interpolate ( out + i - step + 1 , out [ i ] , out [ i - step ] , step - 1 ) ;\n }\n else {\n out [ i - step / 2 ] = eval_lpc_spectrum ( in , get_cos ( i - step / 2 , part , cos_tab , size ) , mtab -> n_lsp ) ;\n interpolate ( out + i - step + 1 , out [ i - step / 2 ] , out [ i - step ] , step / 2 - 1 ) ;\n interpolate ( out + i - step / 2 + 1 , out [ i ] , out [ i - step / 2 ] , step / 2 - 1 ) ;\n }\n }\n interpolate ( out + size - 2 * step + 1 , out [ size - step ] , out [ size - 2 * step ] , step - 1 ) ;\n }", "hash": 2755982813601944893, "project": "debian", "size": 21, "target": 0, "idx": 2700}
{"code": "static void rearrange_lsp ( int order , float * lsp , float min_dist ) {\n int i ;\n float min_dist2 = min_dist * 0.5 ;\n for ( i = 1 ;\n i < order ;\n i ++ ) if ( lsp [ i ] - lsp [ i - 1 ] < min_dist ) {\n float avg = ( lsp [ i ] + lsp [ i - 1 ] ) * 0.5 ;\n lsp [ i - 1 ] = avg - min_dist2 ;\n lsp [ i ] = avg + min_dist2 ;\n }\n }", "hash": 2755982813601944893, "project": "debian", "size": 11, "target": 0, "idx": 2701}
{"code": "static void fill_vaapi_RefPicList ( VAPictureH264 RefPicList [ 32 ] , Picture * ref_list , unsigned int ref_count ) {\n unsigned int i , n = 0 ;\n for ( i = 0 ;\n i < ref_count ;\n i ++ ) if ( ref_list [ i ] . reference ) fill_vaapi_pic ( & RefPicList [ n ++ ] , & ref_list [ i ] , 0 ) ;\n for ( ;\n n < 32 ;\n n ++ ) init_vaapi_pic ( & RefPicList [ n ] ) ;\n }", "hash": 5610242550647094255, "project": "debian", "size": 9, "target": 0, "idx": 2724}
{"code": "static int ipvideo_decode_block_opcode_0x7 ( IpvideoContext * s , AVFrame * frame ) {\n int x , y ;\n unsigned char P [ 2 ] ;\n unsigned int flags ;\n P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n if ( P [ 0 ] <= P [ 1 ] ) {\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n flags = bytestream2_get_byte ( & s -> stream_ptr ) | 0x100 ;\n for ( ;\n flags != 1 ;\n flags >>= 1 ) * s -> pixel_ptr ++ = P [ flags & 1 ] ;\n s -> pixel_ptr += s -> line_inc ;\n }\n }\n else {\n flags = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n for ( y = 0 ;\n y < 8 ;\n y += 2 ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 , flags >>= 1 ) {\n s -> pixel_ptr [ x ] = s -> pixel_ptr [ x + 1 ] = s -> pixel_ptr [ x + s -> stride ] = s -> pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 1 ] ;\n }\n s -> pixel_ptr += s -> stride * 2 ;\n }\n }\n return 0 ;\n }", "hash": -1983921383858884161, "project": "debian", "size": 32, "target": 0, "idx": 2748}
{"code": "static int ipvideo_decode_block_opcode_0x9 ( IpvideoContext * s , AVFrame * frame ) {\n int x , y ;\n unsigned char P [ 4 ] ;\n bytestream2_get_buffer ( & s -> stream_ptr , P , 4 ) ;\n if ( P [ 0 ] <= P [ 1 ] ) {\n if ( P [ 2 ] <= P [ 3 ] ) {\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n int flags = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n for ( x = 0 ;\n x < 8 ;\n x ++ , flags >>= 2 ) * s -> pixel_ptr ++ = P [ flags & 0x03 ] ;\n s -> pixel_ptr += s -> line_inc ;\n }\n }\n else {\n uint32_t flags ;\n flags = bytestream2_get_le32 ( & s -> stream_ptr ) ;\n for ( y = 0 ;\n y < 8 ;\n y += 2 ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 , flags >>= 2 ) {\n s -> pixel_ptr [ x ] = s -> pixel_ptr [ x + 1 ] = s -> pixel_ptr [ x + s -> stride ] = s -> pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 0x03 ] ;\n }\n s -> pixel_ptr += s -> stride * 2 ;\n }\n }\n }\n else {\n uint64_t flags ;\n flags = bytestream2_get_le64 ( & s -> stream_ptr ) ;\n if ( P [ 2 ] <= P [ 3 ] ) {\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 , flags >>= 2 ) {\n s -> pixel_ptr [ x ] = s -> pixel_ptr [ x + 1 ] = P [ flags & 0x03 ] ;\n }\n s -> pixel_ptr += s -> stride ;\n }\n }\n else {\n for ( y = 0 ;\n y < 8 ;\n y += 2 ) {\n for ( x = 0 ;\n x < 8 ;\n x ++ , flags >>= 2 ) {\n s -> pixel_ptr [ x ] = s -> pixel_ptr [ x + s -> stride ] = P [ flags & 0x03 ] ;\n }\n s -> pixel_ptr += s -> stride * 2 ;\n }\n }\n }\n return 0 ;\n }", "hash": -1983921383858884161, "project": "debian", "size": 61, "target": 0, "idx": 2749}
{"code": "static int ipvideo_decode_block_opcode_0xB_16 ( IpvideoContext * s , AVFrame * frame ) {\n int x , y ;\n uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n for ( x = 0 ;\n x < 8 ;\n x ++ ) pixel_ptr [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n pixel_ptr += s -> stride ;\n }\n return 0 ;\n }", "hash": -1983921383858884161, "project": "debian", "size": 13, "target": 0, "idx": 2757}
{"code": "static int ipvideo_decode_block_opcode_0xA_16 ( IpvideoContext * s , AVFrame * frame ) {\n int x , y ;\n uint16_t P [ 8 ] ;\n int flags = 0 ;\n uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;\n for ( x = 0 ;\n x < 4 ;\n x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n if ( ! ( P [ 0 ] & 0x8000 ) ) {\n for ( y = 0 ;\n y < 16 ;\n y ++ ) {\n if ( ! ( y & 3 ) ) {\n if ( y ) for ( x = 0 ;\n x < 4 ;\n x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n flags = bytestream2_get_le32 ( & s -> stream_ptr ) ;\n }\n for ( x = 0 ;\n x < 4 ;\n x ++ , flags >>= 2 ) * pixel_ptr ++ = P [ flags & 0x03 ] ;\n pixel_ptr += s -> stride - 4 ;\n if ( y == 7 ) pixel_ptr -= 8 * s -> stride - 4 ;\n }\n }\n else {\n int vert ;\n uint64_t flags = bytestream2_get_le64 ( & s -> stream_ptr ) ;\n for ( x = 4 ;\n x < 8 ;\n x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n vert = ! ( P [ 4 ] & 0x8000 ) ;\n for ( y = 0 ;\n y < 16 ;\n y ++ ) {\n for ( x = 0 ;\n x < 4 ;\n x ++ , flags >>= 2 ) * pixel_ptr ++ = P [ flags & 0x03 ] ;\n if ( vert ) {\n pixel_ptr += s -> stride - 4 ;\n if ( y == 7 ) pixel_ptr -= 8 * s -> stride - 4 ;\n }\n else if ( y & 1 ) pixel_ptr += s -> line_inc ;\n if ( y == 7 ) {\n memcpy ( P , P + 4 , 8 ) ;\n flags = bytestream2_get_le64 ( & s -> stream_ptr ) ;\n }\n }\n }\n return 0 ;\n }", "hash": -1983921383858884161, "project": "debian", "size": 51, "target": 0, "idx": 2761}
{"code": "static int arith2_get_prob ( ArithCoder * c , int16_t * probs ) {\n int range = c -> high - c -> low + 1 , n = * probs ;\n int scale = av_log2 ( range ) - av_log2 ( n ) ;\n int i = 0 , val ;\n if ( n << scale > range ) scale -- ;\n n <<= scale ;\n val = arith2_get_scaled_value ( c -> value - c -> low , n , range ) >> scale ;\n while ( probs [ ++ i ] > val ) ;\n arith2_rescale_interval ( c , range , probs [ i ] << scale , probs [ i - 1 ] << scale , n ) ;\n return i ;\n }", "hash": -6442559759273439153, "project": "debian", "size": 11, "target": 0, "idx": 2770}
{"code": "static int arith2_get_scaled_value ( int value , int n , int range ) {\n int split = ( n << 1 ) - range ;\n if ( value > split ) return split + ( value - split >> 1 ) ;\n else return value ;\n }", "hash": -6442559759273439153, "project": "debian", "size": 5, "target": 0, "idx": 2775}
{"code": "static int decode_555 ( GetByteContext * gB , uint16_t * dst , int stride , int keyframe , int w , int h ) {\n int last_symbol = 0 , repeat = 0 , prev_avail = 0 ;\n if ( ! keyframe ) {\n int x , y , endx , endy , t ;\n # define READ_PAIR ( a , b ) a = bytestream2_get_byte ( gB ) << 4 ;\n t = bytestream2_get_byte ( gB ) ;\n a |= t >> 4 ;\n b = ( t & 0xF ) << 8 ;\n b |= bytestream2_get_byte ( gB ) ;\n READ_PAIR ( x , endx ) READ_PAIR ( y , endy ) if ( endx >= w || endy >= h || x > endx || y > endy ) return AVERROR_INVALIDDATA ;\n dst += x + stride * y ;\n w = endx - x + 1 ;\n h = endy - y + 1 ;\n if ( y ) prev_avail = 1 ;\n }\n do {\n uint16_t * p = dst ;\n do {\n if ( repeat -- < 1 ) {\n int b = bytestream2_get_byte ( gB ) ;\n if ( b < 128 ) last_symbol = b << 8 | bytestream2_get_byte ( gB ) ;\n else if ( b > 129 ) {\n repeat = 0 ;\n while ( b -- > 130 ) repeat = ( repeat << 8 ) + bytestream2_get_byte ( gB ) + 1 ;\n if ( last_symbol == - 2 ) {\n int skip = FFMIN ( ( unsigned ) repeat , dst + w - p ) ;\n repeat -= skip ;\n p += skip ;\n }\n }\n else last_symbol = 127 - b ;\n }\n if ( last_symbol >= 0 ) * p = last_symbol ;\n else if ( last_symbol == - 1 && prev_avail ) * p = * ( p - stride ) ;\n }\n while ( ++ p < dst + w ) ;\n dst += stride ;\n prev_avail = 1 ;\n }\n while ( -- h ) ;\n return 0 ;\n }", "hash": -6442559759273439153, "project": "debian", "size": 42, "target": 0, "idx": 2777}
{"code": "static inline uint8_t quant ( G726Context * c , int d ) {\n int sign , exp , i , dln ;\n sign = i = 0 ;\n if ( d < 0 ) {\n sign = 1 ;\n d = - d ;\n }\n exp = av_log2_16bit ( d ) ;\n dln = ( ( exp << 7 ) + ( ( ( d << 7 ) >> exp ) & 0x7f ) ) - ( c -> y >> 2 ) ;\n while ( c -> tbls . quant [ i ] < INT_MAX && c -> tbls . quant [ i ] < dln ) ++ i ;\n if ( sign ) i = ~ i ;\n if ( c -> code_size != 2 && i == 0 ) i = 0xff ;\n return i ;\n }", "hash": -3231032419759162058, "project": "debian", "size": 14, "target": 0, "idx": 2780}
{"code": "static inline Float11 * i2f ( int i , Float11 * f ) {\n f -> sign = ( i < 0 ) ;\n if ( f -> sign ) i = - i ;\n f -> exp = av_log2_16bit ( i ) + ! ! i ;\n f -> mant = i ? ( i << 6 ) >> f -> exp : 1 << 5 ;\n return f ;\n }", "hash": -3231032419759162058, "project": "debian", "size": 7, "target": 0, "idx": 2782}
{"code": "static inline int16_t inverse_quant ( G726Context * c , int i ) {\n int dql , dex , dqt ;\n dql = c -> tbls . iquant [ i ] + ( c -> y >> 2 ) ;\n dex = ( dql >> 7 ) & 0xf ;\n dqt = ( 1 << 7 ) + ( dql & 0x7f ) ;\n return ( dql < 0 ) ? 0 : ( ( dqt << dex ) >> 7 ) ;\n }", "hash": -3231032419759162058, "project": "debian", "size": 7, "target": 0, "idx": 2783}
{"code": "static int16_t g726_decode ( G726Context * c , int I ) {\n int dq , re_signal , pk0 , fa1 , i , tr , ylint , ylfrac , thr2 , al , dq0 ;\n Float11 f ;\n int I_sig = I >> ( c -> code_size - 1 ) ;\n dq = inverse_quant ( c , I ) ;\n ylint = ( c -> yl >> 15 ) ;\n ylfrac = ( c -> yl >> 10 ) & 0x1f ;\n thr2 = ( ylint > 9 ) ? 0x1f << 10 : ( 0x20 + ylfrac ) << ylint ;\n tr = ( c -> td == 1 && dq > ( ( 3 * thr2 ) >> 2 ) ) ;\n if ( I_sig ) dq = - dq ;\n re_signal = c -> se + dq ;\n pk0 = ( c -> sez + dq ) ? sgn ( c -> sez + dq ) : 0 ;\n dq0 = dq ? sgn ( dq ) : 0 ;\n if ( tr ) {\n c -> a [ 0 ] = 0 ;\n c -> a [ 1 ] = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) c -> b [ i ] = 0 ;\n }\n else {\n fa1 = av_clip ( ( - c -> a [ 0 ] * c -> pk [ 0 ] * pk0 ) >> 5 , - 256 , 255 ) ;\n c -> a [ 1 ] += 128 * pk0 * c -> pk [ 1 ] + fa1 - ( c -> a [ 1 ] >> 7 ) ;\n c -> a [ 1 ] = av_clip ( c -> a [ 1 ] , - 12288 , 12288 ) ;\n c -> a [ 0 ] += 64 * 3 * pk0 * c -> pk [ 0 ] - ( c -> a [ 0 ] >> 8 ) ;\n c -> a [ 0 ] = av_clip ( c -> a [ 0 ] , - ( 15360 - c -> a [ 1 ] ) , 15360 - c -> a [ 1 ] ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) c -> b [ i ] += 128 * dq0 * sgn ( - c -> dq [ i ] . sign ) - ( c -> b [ i ] >> 8 ) ;\n }\n c -> pk [ 1 ] = c -> pk [ 0 ] ;\n c -> pk [ 0 ] = pk0 ? pk0 : 1 ;\n c -> sr [ 1 ] = c -> sr [ 0 ] ;\n i2f ( re_signal , & c -> sr [ 0 ] ) ;\n for ( i = 5 ;\n i > 0 ;\n i -- ) c -> dq [ i ] = c -> dq [ i - 1 ] ;\n i2f ( dq , & c -> dq [ 0 ] ) ;\n c -> dq [ 0 ] . sign = I_sig ;\n c -> td = c -> a [ 1 ] < - 11776 ;\n c -> dms += ( c -> tbls . F [ I ] << 4 ) + ( ( - c -> dms ) >> 5 ) ;\n c -> dml += ( c -> tbls . F [ I ] << 4 ) + ( ( - c -> dml ) >> 7 ) ;\n if ( tr ) c -> ap = 256 ;\n else {\n c -> ap += ( - c -> ap ) >> 4 ;\n if ( c -> y <= 1535 || c -> td || abs ( ( c -> dms << 2 ) - c -> dml ) >= ( c -> dml >> 3 ) ) c -> ap += 0x20 ;\n }\n c -> yu = av_clip ( c -> y + c -> tbls . W [ I ] + ( ( - c -> y ) >> 5 ) , 544 , 5120 ) ;\n c -> yl += c -> yu + ( ( - c -> yl ) >> 6 ) ;\n al = ( c -> ap >= 256 ) ? 1 << 6 : c -> ap >> 2 ;\n c -> y = ( c -> yl + ( c -> yu - ( c -> yl >> 6 ) ) * al ) >> 6 ;\n c -> se = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) c -> se += mult ( i2f ( c -> b [ i ] >> 2 , & f ) , & c -> dq [ i ] ) ;\n c -> sez = c -> se >> 1 ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) c -> se += mult ( i2f ( c -> a [ i ] >> 2 , & f ) , & c -> sr [ i ] ) ;\n c -> se >>= 1 ;\n return av_clip ( re_signal << 2 , - 0xffff , 0xffff ) ;\n }", "hash": -3231032419759162058, "project": "debian", "size": 62, "target": 0, "idx": 2784}
{"code": "static inline int16_t mult ( Float11 * f1 , Float11 * f2 ) {\n int res , exp ;\n exp = f1 -> exp + f2 -> exp ;\n res = ( ( ( f1 -> mant * f2 -> mant ) + 0x30 ) >> 4 ) ;\n res = exp > 19 ? res << ( exp - 19 ) : res >> ( 19 - exp ) ;\n return ( f1 -> sign ^ f2 -> sign ) ? - res : res ;\n }", "hash": -3231032419759162058, "project": "debian", "size": 7, "target": 0, "idx": 2785}
{"code": "static inline int sign_only ( int v ) {\n return v ? FFSIGN ( v ) : 0 ;\n }", "hash": -5602110576334023565, "project": "debian", "size": 3, "target": 0, "idx": 2792}
{"code": "static void append_extra_bits ( int32_t * buffer [ 2 ] , int32_t * extra_bits_buffer [ 2 ] , int extra_bits , int channels , int nb_samples ) {\n int i , ch ;\n for ( ch = 0 ;\n ch < channels ;\n ch ++ ) for ( i = 0 ;\n i < nb_samples ;\n i ++ ) buffer [ ch ] [ i ] = ( buffer [ ch ] [ i ] << extra_bits ) | extra_bits_buffer [ ch ] [ i ] ;\n }", "hash": -5602110576334023565, "project": "debian", "size": 8, "target": 0, "idx": 2794}
{"code": "static int alac_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n ALACContext * alac = avctx -> priv_data ;\n AVFrame * frame = data ;\n enum AlacRawDataBlockType element ;\n int channels ;\n int ch , ret , got_end ;\n init_get_bits ( & alac -> gb , avpkt -> data , avpkt -> size * 8 ) ;\n got_end = 0 ;\n alac -> nb_samples = 0 ;\n ch = 0 ;\n while ( get_bits_left ( & alac -> gb ) >= 3 ) {\n element = get_bits ( & alac -> gb , 3 ) ;\n if ( element == TYPE_END ) {\n got_end = 1 ;\n break ;\n }\n if ( element > TYPE_CPE && element != TYPE_LFE ) {\n av_log ( avctx , AV_LOG_ERROR , \"syntax element unsupported: %d\" , element ) ;\n return AVERROR_PATCHWELCOME ;\n }\n channels = ( element == TYPE_CPE ) ? 2 : 1 ;\n if ( ch + channels > alac -> channels ) {\n av_log ( avctx , AV_LOG_ERROR , \"invalid element channel count\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n ret = decode_element ( avctx , frame , ff_alac_channel_layout_offsets [ alac -> channels - 1 ] [ ch ] , channels ) ;\n if ( ret < 0 && get_bits_left ( & alac -> gb ) ) return ret ;\n ch += channels ;\n }\n if ( ! got_end ) {\n av_log ( avctx , AV_LOG_ERROR , \"no end tag found. incomplete packet.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( avpkt -> size * 8 - get_bits_count ( & alac -> gb ) > 8 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error : %d bits left\\n\" , avpkt -> size * 8 - get_bits_count ( & alac -> gb ) ) ;\n }\n * got_frame_ptr = 1 ;\n return avpkt -> size ;\n }", "hash": -5602110576334023565, "project": "debian", "size": 39, "target": 0, "idx": 2796}
{"code": "static int unpack_modes ( Vp3DecodeContext * s , GetBitContext * gb ) {\n int i , j , k , sb_x , sb_y ;\n int scheme ;\n int current_macroblock ;\n int current_fragment ;\n int coding_mode ;\n int custom_mode_alphabet [ CODING_MODE_COUNT ] ;\n const int * alphabet ;\n Vp3Fragment * frag ;\n if ( s -> keyframe ) {\n for ( i = 0 ;\n i < s -> fragment_count ;\n i ++ ) s -> all_fragments [ i ] . coding_method = MODE_INTRA ;\n }\n else {\n scheme = get_bits ( gb , 3 ) ;\n if ( scheme == 0 ) {\n for ( i = 0 ;\n i < 8 ;\n i ++ ) custom_mode_alphabet [ i ] = MODE_INTER_NO_MV ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) custom_mode_alphabet [ get_bits ( gb , 3 ) ] = i ;\n alphabet = custom_mode_alphabet ;\n }\n else alphabet = ModeAlphabet [ scheme - 1 ] ;\n for ( sb_y = 0 ;\n sb_y < s -> y_superblock_height ;\n sb_y ++ ) {\n for ( sb_x = 0 ;\n sb_x < s -> y_superblock_width ;\n sb_x ++ ) {\n if ( get_bits_left ( gb ) <= 0 ) return - 1 ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n int mb_x = 2 * sb_x + ( j >> 1 ) ;\n int mb_y = 2 * sb_y + ( ( ( j >> 1 ) + j ) & 1 ) ;\n current_macroblock = mb_y * s -> macroblock_width + mb_x ;\n if ( mb_x >= s -> macroblock_width || mb_y >= s -> macroblock_height ) continue ;\n # define BLOCK_X ( 2 * mb_x + ( k & 1 ) ) # define BLOCK_Y ( 2 * mb_y + ( k >> 1 ) ) for ( k = 0 ;\n k < 4 ;\n k ++ ) {\n current_fragment = BLOCK_Y * s -> fragment_width [ 0 ] + BLOCK_X ;\n if ( s -> all_fragments [ current_fragment ] . coding_method != MODE_COPY ) break ;\n }\n if ( k == 4 ) {\n s -> macroblock_coding [ current_macroblock ] = MODE_INTER_NO_MV ;\n continue ;\n }\n if ( scheme == 7 ) coding_mode = get_bits ( gb , 3 ) ;\n else coding_mode = alphabet [ get_vlc2 ( gb , s -> mode_code_vlc . table , 3 , 3 ) ] ;\n s -> macroblock_coding [ current_macroblock ] = coding_mode ;\n for ( k = 0 ;\n k < 4 ;\n k ++ ) {\n frag = s -> all_fragments + BLOCK_Y * s -> fragment_width [ 0 ] + BLOCK_X ;\n if ( frag -> coding_method != MODE_COPY ) frag -> coding_method = coding_mode ;\n }\n # define SET_CHROMA_MODES if ( frag [ s -> fragment_start [ 1 ] ] . coding_method != MODE_COPY ) frag [ s -> fragment_start [ 1 ] ] . coding_method = coding_mode ;\n if ( frag [ s -> fragment_start [ 2 ] ] . coding_method != MODE_COPY ) frag [ s -> fragment_start [ 2 ] ] . coding_method = coding_mode ;\n if ( s -> chroma_y_shift ) {\n frag = s -> all_fragments + mb_y * s -> fragment_width [ 1 ] + mb_x ;\n SET_CHROMA_MODES }\n else if ( s -> chroma_x_shift ) {\n frag = s -> all_fragments + 2 * mb_y * s -> fragment_width [ 1 ] + mb_x ;\n for ( k = 0 ;\n k < 2 ;\n k ++ ) {\n SET_CHROMA_MODES frag += s -> fragment_width [ 1 ] ;\n }\n }\n else {\n for ( k = 0 ;\n k < 4 ;\n k ++ ) {\n frag = s -> all_fragments + BLOCK_Y * s -> fragment_width [ 1 ] + BLOCK_X ;\n SET_CHROMA_MODES }\n }\n }\n }\n }\n }\n return 0 ;\n }", "hash": -7990991774694156606, "project": "debian", "size": 85, "target": 0, "idx": 2815}
{"code": "static int vp3_init_thread_copy ( AVCodecContext * avctx ) {\n Vp3DecodeContext * s = avctx -> priv_data ;\n s -> superblock_coding = NULL ;\n s -> all_fragments = NULL ;\n s -> coded_fragment_list [ 0 ] = NULL ;\n s -> dct_tokens_base = NULL ;\n s -> superblock_fragments = NULL ;\n s -> macroblock_coding = NULL ;\n s -> motion_val [ 0 ] = NULL ;\n s -> motion_val [ 1 ] = NULL ;\n s -> edge_emu_buffer = NULL ;\n return init_frames ( s ) ;\n }", "hash": -7990991774694156606, "project": "debian", "size": 13, "target": 0, "idx": 2816}
{"code": "static int vp3_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) {\n Vp3DecodeContext * s = dst -> priv_data , * s1 = src -> priv_data ;\n int qps_changed = 0 , i , err ;\n # define copy_fields ( to , from , start_field , end_field ) memcpy ( & to -> start_field , & from -> start_field , ( char * ) & to -> end_field - ( char * ) & to -> start_field ) if ( ! s1 -> current_frame . f -> data [ 0 ] || s -> width != s1 -> width || s -> height != s1 -> height ) {\n if ( s != s1 ) ref_frames ( s , s1 ) ;\n return - 1 ;\n }\n if ( s != s1 ) {\n if ( ! s -> current_frame . f -> data [ 0 ] ) {\n int y_fragment_count , c_fragment_count ;\n s -> avctx = dst ;\n err = allocate_tables ( dst ) ;\n if ( err ) return err ;\n y_fragment_count = s -> fragment_width [ 0 ] * s -> fragment_height [ 0 ] ;\n c_fragment_count = s -> fragment_width [ 1 ] * s -> fragment_height [ 1 ] ;\n memcpy ( s -> motion_val [ 0 ] , s1 -> motion_val [ 0 ] , y_fragment_count * sizeof ( * s -> motion_val [ 0 ] ) ) ;\n memcpy ( s -> motion_val [ 1 ] , s1 -> motion_val [ 1 ] , c_fragment_count * sizeof ( * s -> motion_val [ 1 ] ) ) ;\n }\n if ( ( err = ref_frames ( s , s1 ) ) < 0 ) return err ;\n s -> keyframe = s1 -> keyframe ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n if ( s -> qps [ i ] != s1 -> qps [ 1 ] ) {\n qps_changed = 1 ;\n memcpy ( & s -> qmat [ i ] , & s1 -> qmat [ i ] , sizeof ( s -> qmat [ i ] ) ) ;\n }\n }\n if ( s -> qps [ 0 ] != s1 -> qps [ 0 ] ) memcpy ( & s -> bounding_values_array , & s1 -> bounding_values_array , sizeof ( s -> bounding_values_array ) ) ;\n if ( qps_changed ) copy_fields ( s , s1 , qps , superblock_count ) ;\n # undef copy_fields }\n return update_frames ( dst ) ;\n }", "hash": -7990991774694156606, "project": "debian", "size": 33, "target": 0, "idx": 2822}
{"code": "static inline void tqi_idct_put ( TqiContext * t , AVFrame * frame , int16_t ( * block ) [ 64 ] ) {\n MpegEncContext * s = & t -> s ;\n int linesize = frame -> linesize [ 0 ] ;\n uint8_t * dest_y = frame -> data [ 0 ] + ( s -> mb_y * 16 * linesize ) + s -> mb_x * 16 ;\n uint8_t * dest_cb = frame -> data [ 1 ] + ( s -> mb_y * 8 * frame -> linesize [ 1 ] ) + s -> mb_x * 8 ;\n uint8_t * dest_cr = frame -> data [ 2 ] + ( s -> mb_y * 8 * frame -> linesize [ 2 ] ) + s -> mb_x * 8 ;\n ff_ea_idct_put_c ( dest_y , linesize , block [ 0 ] ) ;\n ff_ea_idct_put_c ( dest_y + 8 , linesize , block [ 1 ] ) ;\n ff_ea_idct_put_c ( dest_y + 8 * linesize , linesize , block [ 2 ] ) ;\n ff_ea_idct_put_c ( dest_y + 8 * linesize + 8 , linesize , block [ 3 ] ) ;\n if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) {\n ff_ea_idct_put_c ( dest_cb , frame -> linesize [ 1 ] , block [ 4 ] ) ;\n ff_ea_idct_put_c ( dest_cr , frame -> linesize [ 2 ] , block [ 5 ] ) ;\n }\n }", "hash": 5810614390175384347, "project": "debian", "size": 15, "target": 0, "idx": 2828}
{"code": "static inline unsigned make_16bit ( unsigned value ) {\n value &= 0xFFC0 ;\n return value + ( value >> 10 ) ;\n }", "hash": 3950861381020172342, "project": "debian", "size": 4, "target": 0, "idx": 2832}
{"code": "static int vcr1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n VCR1Context * const a = avctx -> priv_data ;\n AVFrame * const p = data ;\n const uint8_t * bytestream = buf ;\n int i , x , y , ret ;\n if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n p -> pict_type = AV_PICTURE_TYPE_I ;\n p -> key_frame = 1 ;\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n a -> delta [ i ] = * bytestream ++ ;\n bytestream ++ ;\n }\n for ( y = 0 ;\n y < avctx -> height ;\n y ++ ) {\n int offset ;\n uint8_t * luma = & p -> data [ 0 ] [ y * p -> linesize [ 0 ] ] ;\n if ( ( y & 3 ) == 0 ) {\n uint8_t * cb = & p -> data [ 1 ] [ ( y >> 2 ) * p -> linesize [ 1 ] ] ;\n uint8_t * cr = & p -> data [ 2 ] [ ( y >> 2 ) * p -> linesize [ 2 ] ] ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) a -> offset [ i ] = * bytestream ++ ;\n offset = a -> offset [ 0 ] - a -> delta [ bytestream [ 2 ] & 0xF ] ;\n for ( x = 0 ;\n x < avctx -> width ;\n x += 4 ) {\n luma [ 0 ] = offset += a -> delta [ bytestream [ 2 ] & 0xF ] ;\n luma [ 1 ] = offset += a -> delta [ bytestream [ 2 ] >> 4 ] ;\n luma [ 2 ] = offset += a -> delta [ bytestream [ 0 ] & 0xF ] ;\n luma [ 3 ] = offset += a -> delta [ bytestream [ 0 ] >> 4 ] ;\n luma += 4 ;\n * cb ++ = bytestream [ 3 ] ;\n * cr ++ = bytestream [ 1 ] ;\n bytestream += 4 ;\n }\n }\n else {\n offset = a -> offset [ y & 3 ] - a -> delta [ bytestream [ 2 ] & 0xF ] ;\n for ( x = 0 ;\n x < avctx -> width ;\n x += 8 ) {\n luma [ 0 ] = offset += a -> delta [ bytestream [ 2 ] & 0xF ] ;\n luma [ 1 ] = offset += a -> delta [ bytestream [ 2 ] >> 4 ] ;\n luma [ 2 ] = offset += a -> delta [ bytestream [ 3 ] & 0xF ] ;\n luma [ 3 ] = offset += a -> delta [ bytestream [ 3 ] >> 4 ] ;\n luma [ 4 ] = offset += a -> delta [ bytestream [ 0 ] & 0xF ] ;\n luma [ 5 ] = offset += a -> delta [ bytestream [ 0 ] >> 4 ] ;\n luma [ 6 ] = offset += a -> delta [ bytestream [ 1 ] & 0xF ] ;\n luma [ 7 ] = offset += a -> delta [ bytestream [ 1 ] >> 4 ] ;\n luma += 8 ;\n bytestream += 4 ;\n }\n }\n }\n * got_frame = 1 ;\n return buf_size ;\n }", "hash": -7974482744813045853, "project": "debian", "size": 65, "target": 0, "idx": 2835}
{"code": "static int parse_packet_header ( WMAVoiceContext * s ) {\n GetBitContext * gb = & s -> gb ;\n unsigned int res ;\n if ( get_bits_left ( gb ) < 11 ) return 1 ;\n skip_bits ( gb , 4 ) ;\n s -> has_residual_lsps = get_bits1 ( gb ) ;\n do {\n res = get_bits ( gb , 6 ) ;\n if ( get_bits_left ( gb ) < 6 * ( res == 0x3F ) + s -> spillover_bitsize ) return 1 ;\n }\n while ( res == 0x3F ) ;\n s -> spillover_nbits = get_bits ( gb , s -> spillover_bitsize ) ;\n return 0 ;\n }", "hash": 643387607984457432, "project": "debian", "size": 14, "target": 0, "idx": 2850}
{"code": "static int kalman_smoothen ( WMAVoiceContext * s , int pitch , const float * in , float * out , int size ) {\n int n ;\n float optimal_gain = 0 , dot ;\n const float * ptr = & in [ - FFMAX ( s -> min_pitch_val , pitch - 3 ) ] , * end = & in [ - FFMIN ( s -> max_pitch_val , pitch + 3 ) ] , * best_hist_ptr ;\n do {\n dot = avpriv_scalarproduct_float_c ( in , ptr , size ) ;\n if ( dot > optimal_gain ) {\n optimal_gain = dot ;\n best_hist_ptr = ptr ;\n }\n }\n while ( -- ptr >= end ) ;\n if ( optimal_gain <= 0 ) return - 1 ;\n dot = avpriv_scalarproduct_float_c ( best_hist_ptr , best_hist_ptr , size ) ;\n if ( dot <= 0 ) return - 1 ;\n if ( optimal_gain <= dot ) {\n dot = dot / ( dot + 0.6 * optimal_gain ) ;\n }\n else dot = 0.625 ;\n for ( n = 0 ;\n n < size ;\n n ++ ) out [ n ] = best_hist_ptr [ n ] + dot * ( in [ n ] - best_hist_ptr [ n ] ) ;\n return 0 ;\n }", "hash": 643387607984457432, "project": "debian", "size": 24, "target": 0, "idx": 2864}
{"code": "static void postfilter ( WMAVoiceContext * s , const float * synth , float * samples , int size , const float * lpcs , float * zero_exc_pf , int fcb_type , int pitch ) {\n float synth_filter_in_buf [ MAX_FRAMESIZE / 2 ] , * synth_pf = & s -> synth_filter_out_buf [ MAX_LSPS_ALIGN16 ] , * synth_filter_in = zero_exc_pf ;\n assert ( size <= MAX_FRAMESIZE / 2 ) ;\n ff_celp_lp_zero_synthesis_filterf ( zero_exc_pf , lpcs , synth , size , s -> lsps ) ;\n if ( fcb_type >= FCB_TYPE_AW_PULSES && ! kalman_smoothen ( s , pitch , zero_exc_pf , synth_filter_in_buf , size ) ) synth_filter_in = synth_filter_in_buf ;\n ff_celp_lp_synthesis_filterf ( synth_pf , lpcs , synth_filter_in , size , s -> lsps ) ;\n memcpy ( & synth_pf [ - s -> lsps ] , & synth_pf [ size - s -> lsps ] , sizeof ( synth_pf [ 0 ] ) * s -> lsps ) ;\n wiener_denoise ( s , fcb_type , synth_pf , size , lpcs ) ;\n adaptive_gain_control ( samples , synth_pf , synth , size , 0.99 , & s -> postfilter_agc ) ;\n if ( s -> dc_level > 8 ) {\n ff_acelp_apply_order_2_transfer_function ( samples , samples , ( const float [ 2 ] ) {\n - 1.99997 , 1.0 }\n , ( const float [ 2 ] ) {\n - 1.9330735188 , 0.93589198496 }\n , 0.93980580475 , s -> dcf_mem , size ) ;\n }\n }", "hash": 643387607984457432, "project": "debian", "size": 17, "target": 0, "idx": 2870}
{"code": "static void unpack_roq_qcell ( uint8_t cb2 [ ] , roq_qcell * qcell , uint8_t u [ 4 * 4 * 3 ] ) {\n int i , cp ;\n static const int offsets [ 4 ] = {\n 0 , 2 , 8 , 10 }\n ;\n for ( cp = 0 ;\n cp < 3 ;\n cp ++ ) for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n u [ 4 * 4 * cp + offsets [ i ] ] = cb2 [ qcell -> idx [ i ] * 2 * 2 * 3 + 4 * cp ] ;\n u [ 4 * 4 * cp + offsets [ i ] + 1 ] = cb2 [ qcell -> idx [ i ] * 2 * 2 * 3 + 4 * cp + 1 ] ;\n u [ 4 * 4 * cp + offsets [ i ] + 4 ] = cb2 [ qcell -> idx [ i ] * 2 * 2 * 3 + 4 * cp + 2 ] ;\n u [ 4 * 4 * cp + offsets [ i ] + 5 ] = cb2 [ qcell -> idx [ i ] * 2 * 2 * 3 + 4 * cp + 3 ] ;\n }\n }", "hash": -8046645508582876963, "project": "debian", "size": 16, "target": 0, "idx": 2903}
{"code": "static void motion_search ( RoqContext * enc , int blocksize ) {\n static const motion_vect offsets [ 8 ] = {\n {\n {\n 0 , - 1 }\n }\n , {\n {\n 0 , 1 }\n }\n , {\n {\n - 1 , 0 }\n }\n , {\n {\n 1 , 0 }\n }\n , {\n {\n - 1 , 1 }\n }\n , {\n {\n 1 , - 1 }\n }\n , {\n {\n - 1 , - 1 }\n }\n , {\n {\n 1 , 1 }\n }\n , }\n ;\n int diff , lowestdiff , oldbest ;\n int off [ 3 ] ;\n motion_vect bestpick = {\n {\n 0 , 0 }\n }\n ;\n int i , j , k , offset ;\n motion_vect * last_motion ;\n motion_vect * this_motion ;\n motion_vect vect , vect2 ;\n int max = ( enc -> width / blocksize ) * enc -> height / blocksize ;\n if ( blocksize == 4 ) {\n last_motion = enc -> last_motion4 ;\n this_motion = enc -> this_motion4 ;\n }\n else {\n last_motion = enc -> last_motion8 ;\n this_motion = enc -> this_motion8 ;\n }\n for ( i = 0 ;\n i < enc -> height ;\n i += blocksize ) for ( j = 0 ;\n j < enc -> width ;\n j += blocksize ) {\n lowestdiff = eval_motion_dist ( enc , j , i , ( motion_vect ) {\n {\n 0 , 0 }\n }\n , blocksize ) ;\n bestpick . d [ 0 ] = 0 ;\n bestpick . d [ 1 ] = 0 ;\n if ( blocksize == 4 ) EVAL_MOTION ( enc -> this_motion8 [ ( i / 8 ) * ( enc -> width / 8 ) + j / 8 ] ) ;\n offset = ( i / blocksize ) * enc -> width / blocksize + j / blocksize ;\n if ( offset < max && offset >= 0 ) EVAL_MOTION ( last_motion [ offset ] ) ;\n offset ++ ;\n if ( offset < max && offset >= 0 ) EVAL_MOTION ( last_motion [ offset ] ) ;\n offset = ( i / blocksize + 1 ) * enc -> width / blocksize + j / blocksize ;\n if ( offset < max && offset >= 0 ) EVAL_MOTION ( last_motion [ offset ] ) ;\n off [ 0 ] = ( i / blocksize ) * enc -> width / blocksize + j / blocksize - 1 ;\n off [ 1 ] = off [ 0 ] - enc -> width / blocksize + 1 ;\n off [ 2 ] = off [ 1 ] + 1 ;\n if ( i ) {\n for ( k = 0 ;\n k < 2 ;\n k ++ ) vect . d [ k ] = mid_pred ( this_motion [ off [ 0 ] ] . d [ k ] , this_motion [ off [ 1 ] ] . d [ k ] , this_motion [ off [ 2 ] ] . d [ k ] ) ;\n EVAL_MOTION ( vect ) ;\n for ( k = 0 ;\n k < 3 ;\n k ++ ) EVAL_MOTION ( this_motion [ off [ k ] ] ) ;\n }\n else if ( j ) EVAL_MOTION ( this_motion [ off [ 0 ] ] ) ;\n vect = bestpick ;\n oldbest = - 1 ;\n while ( oldbest != lowestdiff ) {\n oldbest = lowestdiff ;\n for ( k = 0 ;\n k < 8 ;\n k ++ ) {\n vect2 = vect ;\n vect2 . d [ 0 ] += offsets [ k ] . d [ 0 ] ;\n vect2 . d [ 1 ] += offsets [ k ] . d [ 1 ] ;\n EVAL_MOTION ( vect2 ) ;\n }\n vect = bestpick ;\n }\n offset = ( i / blocksize ) * enc -> width / blocksize + j / blocksize ;\n this_motion [ offset ] = bestpick ;\n }\n }", "hash": -8046645508582876963, "project": "debian", "size": 106, "target": 0, "idx": 2904}
{"code": "static void roq_write_video_info_chunk ( RoqContext * enc ) {\n bytestream_put_le16 ( & enc -> out_buf , RoQ_INFO ) ;\n bytestream_put_le32 ( & enc -> out_buf , 8 ) ;\n bytestream_put_byte ( & enc -> out_buf , 0x00 ) ;\n bytestream_put_byte ( & enc -> out_buf , 0x00 ) ;\n bytestream_put_le16 ( & enc -> out_buf , enc -> width ) ;\n bytestream_put_le16 ( & enc -> out_buf , enc -> height ) ;\n bytestream_put_byte ( & enc -> out_buf , 0x08 ) ;\n bytestream_put_byte ( & enc -> out_buf , 0x00 ) ;\n bytestream_put_byte ( & enc -> out_buf , 0x04 ) ;\n bytestream_put_byte ( & enc -> out_buf , 0x00 ) ;\n }", "hash": -8046645508582876963, "project": "debian", "size": 12, "target": 0, "idx": 2914}
{"code": "static void enlarge_roq_mb4 ( uint8_t base [ 3 * 16 ] , uint8_t u [ 3 * 64 ] ) {\n int x , y , cp ;\n for ( cp = 0 ;\n cp < 3 ;\n cp ++ ) for ( y = 0 ;\n y < 8 ;\n y ++ ) for ( x = 0 ;\n x < 8 ;\n x ++ ) * u ++ = base [ ( y / 2 ) * 4 + ( x / 2 ) + 16 * cp ] ;\n }", "hash": -8046645508582876963, "project": "debian", "size": 10, "target": 0, "idx": 2928}
{"code": "static void update_state ( AMRContext * p ) {\n memcpy ( p -> prev_lsp_sub4 , p -> lsp [ 3 ] , LP_FILTER_ORDER * sizeof ( p -> lsp [ 3 ] [ 0 ] ) ) ;\n memmove ( & p -> excitation_buf [ 0 ] , & p -> excitation_buf [ AMR_SUBFRAME_SIZE ] , ( PITCH_DELAY_MAX + LP_FILTER_ORDER + 1 ) * sizeof ( float ) ) ;\n memmove ( & p -> pitch_gain [ 0 ] , & p -> pitch_gain [ 1 ] , 4 * sizeof ( float ) ) ;\n memmove ( & p -> fixed_gain [ 0 ] , & p -> fixed_gain [ 1 ] , 4 * sizeof ( float ) ) ;\n memmove ( & p -> samples_in [ 0 ] , & p -> samples_in [ AMR_SUBFRAME_SIZE ] , LP_FILTER_ORDER * sizeof ( float ) ) ;\n }", "hash": -954364585377557207, "project": "debian", "size": 7, "target": 0, "idx": 2933}
{"code": "static int amrnb_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AMRContext * p = avctx -> priv_data ;\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n float * buf_out ;\n int i , subframe , ret ;\n float fixed_gain_factor ;\n AMRFixed fixed_sparse = {\n 0 }\n ;\n float spare_vector [ AMR_SUBFRAME_SIZE ] ;\n float synth_fixed_gain ;\n const float * synth_fixed_vector ;\n frame -> nb_samples = AMR_BLOCK_SIZE ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n buf_out = ( float * ) frame -> data [ 0 ] ;\n p -> cur_frame_mode = unpack_bitstream ( p , buf , buf_size ) ;\n if ( p -> cur_frame_mode == NO_DATA ) {\n av_log ( avctx , AV_LOG_ERROR , \"Corrupt bitstream\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( p -> cur_frame_mode == MODE_DTX ) {\n av_log_missing_feature ( avctx , \"dtx mode\" , 1 ) ;\n return AVERROR_PATCHWELCOME ;\n }\n if ( p -> cur_frame_mode == MODE_12k2 ) {\n lsf2lsp_5 ( p ) ;\n }\n else lsf2lsp_3 ( p ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) ff_acelp_lspd2lpc ( p -> lsp [ i ] , p -> lpc [ i ] , 5 ) ;\n for ( subframe = 0 ;\n subframe < 4 ;\n subframe ++ ) {\n const AMRNBSubframe * amr_subframe = & p -> frame . subframe [ subframe ] ;\n decode_pitch_vector ( p , amr_subframe , subframe ) ;\n decode_fixed_sparse ( & fixed_sparse , amr_subframe -> pulses , p -> cur_frame_mode , subframe ) ;\n decode_gains ( p , amr_subframe , p -> cur_frame_mode , subframe , & fixed_gain_factor ) ;\n pitch_sharpening ( p , subframe , p -> cur_frame_mode , & fixed_sparse ) ;\n if ( fixed_sparse . pitch_lag == 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"The file is corrupted, pitch_lag = 0 is not allowed\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n ff_set_fixed_vector ( p -> fixed_vector , & fixed_sparse , 1.0 , AMR_SUBFRAME_SIZE ) ;\n p -> fixed_gain [ 4 ] = ff_amr_set_fixed_gain ( fixed_gain_factor , avpriv_scalarproduct_float_c ( p -> fixed_vector , p -> fixed_vector , AMR_SUBFRAME_SIZE ) / AMR_SUBFRAME_SIZE , p -> prediction_error , energy_mean [ p -> cur_frame_mode ] , energy_pred_fac ) ;\n for ( i = 0 ;\n i < AMR_SUBFRAME_SIZE ;\n i ++ ) p -> excitation [ i ] *= p -> pitch_gain [ 4 ] ;\n ff_set_fixed_vector ( p -> excitation , & fixed_sparse , p -> fixed_gain [ 4 ] , AMR_SUBFRAME_SIZE ) ;\n for ( i = 0 ;\n i < AMR_SUBFRAME_SIZE ;\n i ++ ) p -> excitation [ i ] = truncf ( p -> excitation [ i ] ) ;\n synth_fixed_gain = fixed_gain_smooth ( p , p -> lsf_q [ subframe ] , p -> lsf_avg , p -> cur_frame_mode ) ;\n synth_fixed_vector = anti_sparseness ( p , & fixed_sparse , p -> fixed_vector , synth_fixed_gain , spare_vector ) ;\n if ( synthesis ( p , p -> lpc [ subframe ] , synth_fixed_gain , synth_fixed_vector , & p -> samples_in [ LP_FILTER_ORDER ] , 0 ) ) synthesis ( p , p -> lpc [ subframe ] , synth_fixed_gain , synth_fixed_vector , & p -> samples_in [ LP_FILTER_ORDER ] , 1 ) ;\n postfilter ( p , p -> lpc [ subframe ] , buf_out + subframe * AMR_SUBFRAME_SIZE ) ;\n ff_clear_fixed_vector ( p -> fixed_vector , & fixed_sparse , AMR_SUBFRAME_SIZE ) ;\n update_state ( p ) ;\n }\n ff_acelp_apply_order_2_transfer_function ( buf_out , buf_out , highpass_zeros , highpass_poles , highpass_gain * AMR_SAMPLE_SCALE , p -> high_pass_mem , AMR_BLOCK_SIZE ) ;\n ff_weighted_vector_sumf ( p -> lsf_avg , p -> lsf_avg , p -> lsf_q [ 3 ] , 0.84 , 0.16 , LP_FILTER_ORDER ) ;\n * got_frame_ptr = 1 ;\n return frame_sizes_nb [ p -> cur_frame_mode ] + 1 ;\n }", "hash": -954364585377557207, "project": "debian", "size": 69, "target": 0, "idx": 2941}
{"code": "static void decode_gains ( AMRContext * p , const AMRNBSubframe * amr_subframe , const enum Mode mode , const int subframe , float * fixed_gain_factor ) {\n if ( mode == MODE_12k2 || mode == MODE_7k95 ) {\n p -> pitch_gain [ 4 ] = qua_gain_pit [ amr_subframe -> p_gain ] * ( 1.0 / 16384.0 ) ;\n * fixed_gain_factor = qua_gain_code [ amr_subframe -> fixed_gain ] * ( 1.0 / 2048.0 ) ;\n }\n else {\n const uint16_t * gains ;\n if ( mode >= MODE_6k7 ) {\n gains = gains_high [ amr_subframe -> p_gain ] ;\n }\n else if ( mode >= MODE_5k15 ) {\n gains = gains_low [ amr_subframe -> p_gain ] ;\n }\n else {\n gains = gains_MODE_4k75 [ ( p -> frame . subframe [ subframe & 2 ] . p_gain << 1 ) + ( subframe & 1 ) ] ;\n }\n p -> pitch_gain [ 4 ] = gains [ 0 ] * ( 1.0 / 16384.0 ) ;\n * fixed_gain_factor = gains [ 1 ] * ( 1.0 / 4096.0 ) ;\n }\n }", "hash": -954364585377557207, "project": "debian", "size": 20, "target": 0, "idx": 2950}
{"code": "static int make_ydt15_entry ( int p1 , int p2 , int16_t * ydt ) # endif {\n int lo , hi ;\n lo = ydt [ p1 ] ;\n lo += ( lo << 5 ) + ( lo << 10 ) ;\n hi = ydt [ p2 ] ;\n hi += ( hi << 5 ) + ( hi << 10 ) ;\n return ( lo + ( hi << 16 ) ) << 1 ;\n }", "hash": 8472707559856742945, "project": "debian", "size": 8, "target": 0, "idx": 2970}
{"code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n ProresContext * ctx = avctx -> priv_data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int frame_hdr_size , pic_num , pic_data_size ;\n ctx -> frame = data ;\n ctx -> frame -> pict_type = AV_PICTURE_TYPE_I ;\n ctx -> frame -> key_frame = 1 ;\n if ( buf_size < 28 || buf_size < AV_RB32 ( buf ) || AV_RB32 ( buf + 4 ) != FRAME_ID ) {\n av_log ( avctx , AV_LOG_ERROR , \"invalid frame\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n MOVE_DATA_PTR ( 8 ) ;\n frame_hdr_size = decode_frame_header ( ctx , buf , buf_size , avctx ) ;\n if ( frame_hdr_size < 0 ) return AVERROR_INVALIDDATA ;\n MOVE_DATA_PTR ( frame_hdr_size ) ;\n if ( ff_get_buffer ( avctx , ctx -> frame , 0 ) < 0 ) return - 1 ;\n for ( pic_num = 0 ;\n ctx -> frame -> interlaced_frame - pic_num + 1 ;\n pic_num ++ ) {\n pic_data_size = decode_picture_header ( ctx , buf , buf_size , avctx ) ;\n if ( pic_data_size < 0 ) return AVERROR_INVALIDDATA ;\n if ( decode_picture ( ctx , pic_num , avctx ) ) return - 1 ;\n MOVE_DATA_PTR ( pic_data_size ) ;\n }\n ctx -> frame = NULL ;\n * got_frame = 1 ;\n return avpkt -> size ;\n }", "hash": -1594970847928262768, "project": "debian", "size": 29, "target": 0, "idx": 2973}
{"code": "static int get_consumed_bytes ( MpegEncContext * s , int buf_size ) {\n int pos = ( get_bits_count ( & s -> gb ) + 7 ) >> 3 ;\n if ( s -> divx_packed || s -> avctx -> hwaccel ) {\n return buf_size ;\n }\n else if ( s -> flags & CODEC_FLAG_TRUNCATED ) {\n pos -= s -> parse_context . last_index ;\n if ( pos < 0 ) pos = 0 ;\n return pos ;\n }\n else {\n if ( pos == 0 ) pos = 1 ;\n if ( pos + 10 > buf_size ) pos = buf_size ;\n return pos ;\n }\n }", "hash": 453825853695477219, "project": "debian", "size": 16, "target": 0, "idx": 2987}
{"code": "static void apply_pitch_filters ( QCELPContext * q , float * cdn_vector ) {\n int i ;\n const float * v_synthesis_filtered , * v_pre_filtered ;\n if ( q -> bitrate >= RATE_HALF || q -> bitrate == SILENCE || ( q -> bitrate == I_F_Q && ( q -> prev_bitrate >= RATE_HALF ) ) ) {\n if ( q -> bitrate >= RATE_HALF ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n q -> pitch_gain [ i ] = q -> frame . plag [ i ] ? ( q -> frame . pgain [ i ] + 1 ) * 0.25 : 0.0 ;\n q -> pitch_lag [ i ] = q -> frame . plag [ i ] + 16 ;\n }\n }\n else {\n float max_pitch_gain ;\n if ( q -> bitrate == I_F_Q ) {\n if ( q -> erasure_count < 3 ) max_pitch_gain = 0.9 - 0.3 * ( q -> erasure_count - 1 ) ;\n else max_pitch_gain = 0.0 ;\n }\n else {\n assert ( q -> bitrate == SILENCE ) ;\n max_pitch_gain = 1.0 ;\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) q -> pitch_gain [ i ] = FFMIN ( q -> pitch_gain [ i ] , max_pitch_gain ) ;\n memset ( q -> frame . pfrac , 0 , sizeof ( q -> frame . pfrac ) ) ;\n }\n v_synthesis_filtered = do_pitchfilter ( q -> pitch_synthesis_filter_mem , cdn_vector , q -> pitch_gain , q -> pitch_lag , q -> frame . pfrac ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) q -> pitch_gain [ i ] = 0.5 * FFMIN ( q -> pitch_gain [ i ] , 1.0 ) ;\n v_pre_filtered = do_pitchfilter ( q -> pitch_pre_filter_mem , v_synthesis_filtered , q -> pitch_gain , q -> pitch_lag , q -> frame . pfrac ) ;\n apply_gain_ctrl ( cdn_vector , v_synthesis_filtered , v_pre_filtered ) ;\n }\n else {\n memcpy ( q -> pitch_synthesis_filter_mem , cdn_vector + 17 , 143 * sizeof ( float ) ) ;\n memcpy ( q -> pitch_pre_filter_mem , cdn_vector + 17 , 143 * sizeof ( float ) ) ;\n memset ( q -> pitch_gain , 0 , sizeof ( q -> pitch_gain ) ) ;\n memset ( q -> pitch_lag , 0 , sizeof ( q -> pitch_lag ) ) ;\n }\n }", "hash": -7500496935464390622, "project": "debian", "size": 41, "target": 0, "idx": 3001}
{"code": "static int alloc_picture_tables ( MpegEncContext * s , Picture * pic ) {\n const int big_mb_num = s -> mb_stride * ( s -> mb_height + 1 ) + 1 ;\n const int mb_array_size = s -> mb_stride * s -> mb_height ;\n const int b8_array_size = s -> b8_stride * s -> mb_height * 2 ;\n int i ;\n pic -> mbskip_table_buf = av_buffer_allocz ( mb_array_size + 2 ) ;\n pic -> qscale_table_buf = av_buffer_allocz ( big_mb_num + s -> mb_stride ) ;\n pic -> mb_type_buf = av_buffer_allocz ( ( big_mb_num + s -> mb_stride ) * sizeof ( uint32_t ) ) ;\n if ( ! pic -> mbskip_table_buf || ! pic -> qscale_table_buf || ! pic -> mb_type_buf ) return AVERROR ( ENOMEM ) ;\n if ( s -> encoding ) {\n pic -> mb_var_buf = av_buffer_allocz ( mb_array_size * sizeof ( int16_t ) ) ;\n pic -> mc_mb_var_buf = av_buffer_allocz ( mb_array_size * sizeof ( int16_t ) ) ;\n pic -> mb_mean_buf = av_buffer_allocz ( mb_array_size ) ;\n if ( ! pic -> mb_var_buf || ! pic -> mc_mb_var_buf || ! pic -> mb_mean_buf ) return AVERROR ( ENOMEM ) ;\n }\n if ( s -> out_format == FMT_H263 || s -> encoding || ( s -> avctx -> debug & FF_DEBUG_MV ) || s -> avctx -> debug_mv ) {\n int mv_size = 2 * ( b8_array_size + 4 ) * sizeof ( int16_t ) ;\n int ref_index_size = 4 * mb_array_size ;\n for ( i = 0 ;\n mv_size && i < 2 ;\n i ++ ) {\n pic -> motion_val_buf [ i ] = av_buffer_allocz ( mv_size ) ;\n pic -> ref_index_buf [ i ] = av_buffer_allocz ( ref_index_size ) ;\n if ( ! pic -> motion_val_buf [ i ] || ! pic -> ref_index_buf [ i ] ) return AVERROR ( ENOMEM ) ;\n }\n }\n return 0 ;\n }", "hash": 2713698759296604855, "project": "debian", "size": 28, "target": 0, "idx": 3006}
{"code": "static void free_picture_tables ( Picture * pic ) {\n int i ;\n av_buffer_unref ( & pic -> mb_var_buf ) ;\n av_buffer_unref ( & pic -> mc_mb_var_buf ) ;\n av_buffer_unref ( & pic -> mb_mean_buf ) ;\n av_buffer_unref ( & pic -> mbskip_table_buf ) ;\n av_buffer_unref ( & pic -> qscale_table_buf ) ;\n av_buffer_unref ( & pic -> mb_type_buf ) ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n av_buffer_unref ( & pic -> motion_val_buf [ i ] ) ;\n av_buffer_unref ( & pic -> ref_index_buf [ i ] ) ;\n }\n }", "hash": 2713698759296604855, "project": "debian", "size": 15, "target": 0, "idx": 3009}
{"code": "static void backup_duplicate_context ( MpegEncContext * bak , MpegEncContext * src ) {\n # define COPY ( a ) bak -> a = src -> a COPY ( edge_emu_buffer ) ;\n COPY ( me . scratchpad ) ;\n COPY ( me . temp ) ;\n COPY ( rd_scratchpad ) ;\n COPY ( b_scratchpad ) ;\n COPY ( obmc_scratchpad ) ;\n COPY ( me . map ) ;\n COPY ( me . score_map ) ;\n COPY ( blocks ) ;\n COPY ( block ) ;\n COPY ( start_mb_y ) ;\n COPY ( end_mb_y ) ;\n COPY ( me . map_generation ) ;\n COPY ( pb ) ;\n COPY ( dct_error_sum ) ;\n COPY ( dct_count [ 0 ] ) ;\n COPY ( dct_count [ 1 ] ) ;\n COPY ( ac_val_base ) ;\n COPY ( ac_val [ 0 ] ) ;\n COPY ( ac_val [ 1 ] ) ;\n COPY ( ac_val [ 2 ] ) ;\n # undef COPY }", "hash": 2713698759296604855, "project": "debian", "size": 23, "target": 0, "idx": 3013}
{"code": "int ff_mpv_frame_size_alloc ( MpegEncContext * s , int linesize ) {\n int alloc_size = FFALIGN ( FFABS ( linesize ) + 32 , 32 ) ;\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> edge_emu_buffer , alloc_size * 2 * 24 , fail ) ;\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> me . scratchpad , alloc_size * 2 * 16 * 2 , fail ) s -> me . temp = s -> me . scratchpad ;\n s -> rd_scratchpad = s -> me . scratchpad ;\n s -> b_scratchpad = s -> me . scratchpad ;\n s -> obmc_scratchpad = s -> me . scratchpad + 16 ;\n return 0 ;\n fail : av_freep ( & s -> edge_emu_buffer ) ;\n return AVERROR ( ENOMEM ) ;\n }", "hash": 2713698759296604855, "project": "debian", "size": 11, "target": 0, "idx": 3040}
{"code": "void ff_draw_horiz_band ( AVCodecContext * avctx , DSPContext * dsp , Picture * cur , Picture * last , int y , int h , int picture_structure , int first_field , int draw_edges , int low_delay , int v_edge_pos , int h_edge_pos ) {\n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ;\n int hshift = desc -> log2_chroma_w ;\n int vshift = desc -> log2_chroma_h ;\n const int field_pic = picture_structure != PICT_FRAME ;\n if ( field_pic ) {\n h <<= 1 ;\n y <<= 1 ;\n }\n if ( ! avctx -> hwaccel && ! ( avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) && draw_edges && cur -> reference && ! ( avctx -> flags & CODEC_FLAG_EMU_EDGE ) ) {\n int * linesize = cur -> f . linesize ;\n int sides = 0 , edge_h ;\n if ( y == 0 ) sides |= EDGE_TOP ;\n if ( y + h >= v_edge_pos ) sides |= EDGE_BOTTOM ;\n edge_h = FFMIN ( h , v_edge_pos - y ) ;\n dsp -> draw_edges ( cur -> f . data [ 0 ] + y * linesize [ 0 ] , linesize [ 0 ] , h_edge_pos , edge_h , EDGE_WIDTH , EDGE_WIDTH , sides ) ;\n dsp -> draw_edges ( cur -> f . data [ 1 ] + ( y >> vshift ) * linesize [ 1 ] , linesize [ 1 ] , h_edge_pos >> hshift , edge_h >> vshift , EDGE_WIDTH >> hshift , EDGE_WIDTH >> vshift , sides ) ;\n dsp -> draw_edges ( cur -> f . data [ 2 ] + ( y >> vshift ) * linesize [ 2 ] , linesize [ 2 ] , h_edge_pos >> hshift , edge_h >> vshift , EDGE_WIDTH >> hshift , EDGE_WIDTH >> vshift , sides ) ;\n }\n h = FFMIN ( h , avctx -> height - y ) ;\n if ( field_pic && first_field && ! ( avctx -> slice_flags & SLICE_FLAG_ALLOW_FIELD ) ) return ;\n if ( avctx -> draw_horiz_band ) {\n AVFrame * src ;\n int offset [ AV_NUM_DATA_POINTERS ] ;\n int i ;\n if ( cur -> f . pict_type == AV_PICTURE_TYPE_B || low_delay || ( avctx -> slice_flags & SLICE_FLAG_CODED_ORDER ) ) src = & cur -> f ;\n else if ( last ) src = & last -> f ;\n else return ;\n if ( cur -> f . pict_type == AV_PICTURE_TYPE_B && picture_structure == PICT_FRAME && avctx -> codec_id != AV_CODEC_ID_H264 && avctx -> codec_id != AV_CODEC_ID_SVQ3 ) {\n for ( i = 0 ;\n i < AV_NUM_DATA_POINTERS ;\n i ++ ) offset [ i ] = 0 ;\n }\n else {\n offset [ 0 ] = y * src -> linesize [ 0 ] ;\n offset [ 1 ] = offset [ 2 ] = ( y >> vshift ) * src -> linesize [ 1 ] ;\n for ( i = 3 ;\n i < AV_NUM_DATA_POINTERS ;\n i ++ ) offset [ i ] = 0 ;\n }\n emms_c ( ) ;\n avctx -> draw_horiz_band ( avctx , src , offset , y , picture_structure , h ) ;\n }\n }", "hash": 2713698759296604855, "project": "debian", "size": 44, "target": 0, "idx": 3049}
{"code": "void ff_MPV_common_defaults ( MpegEncContext * s ) {\n s -> y_dc_scale_table = s -> c_dc_scale_table = ff_mpeg1_dc_scale_table ;\n s -> chroma_qscale_table = ff_default_chroma_qscale_table ;\n s -> progressive_frame = 1 ;\n s -> progressive_sequence = 1 ;\n s -> picture_structure = PICT_FRAME ;\n s -> coded_picture_number = 0 ;\n s -> picture_number = 0 ;\n s -> input_picture_number = 0 ;\n s -> picture_in_gop_number = 0 ;\n s -> f_code = 1 ;\n s -> b_code = 1 ;\n s -> slice_context_count = 1 ;\n }", "hash": 2713698759296604855, "project": "debian", "size": 14, "target": 0, "idx": 3050}
{"code": "static int init_context_frame ( MpegEncContext * s ) {\n int y_size , c_size , yc_size , i , mb_array_size , mv_table_size , x , y ;\n s -> mb_width = ( s -> width + 15 ) / 16 ;\n s -> mb_stride = s -> mb_width + 1 ;\n s -> b8_stride = s -> mb_width * 2 + 1 ;\n s -> b4_stride = s -> mb_width * 4 + 1 ;\n mb_array_size = s -> mb_height * s -> mb_stride ;\n mv_table_size = ( s -> mb_height + 2 ) * s -> mb_stride + 1 ;\n s -> h_edge_pos = s -> mb_width * 16 ;\n s -> v_edge_pos = s -> mb_height * 16 ;\n s -> mb_num = s -> mb_width * s -> mb_height ;\n s -> block_wrap [ 0 ] = s -> block_wrap [ 1 ] = s -> block_wrap [ 2 ] = s -> block_wrap [ 3 ] = s -> b8_stride ;\n s -> block_wrap [ 4 ] = s -> block_wrap [ 5 ] = s -> mb_stride ;\n y_size = s -> b8_stride * ( 2 * s -> mb_height + 1 ) ;\n c_size = s -> mb_stride * ( s -> mb_height + 1 ) ;\n yc_size = y_size + 2 * c_size ;\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> mb_index2xy , ( s -> mb_num + 1 ) * sizeof ( int ) , fail ) ;\n for ( y = 0 ;\n y < s -> mb_height ;\n y ++ ) for ( x = 0 ;\n x < s -> mb_width ;\n x ++ ) s -> mb_index2xy [ x + y * s -> mb_width ] = x + y * s -> mb_stride ;\n s -> mb_index2xy [ s -> mb_height * s -> mb_width ] = ( s -> mb_height - 1 ) * s -> mb_stride + s -> mb_width ;\n if ( s -> encoding ) {\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> p_mv_table_base , mv_table_size * 2 * sizeof ( int16_t ) , fail ) ;\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> b_forw_mv_table_base , mv_table_size * 2 * sizeof ( int16_t ) , fail ) ;\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> b_back_mv_table_base , mv_table_size * 2 * sizeof ( int16_t ) , fail ) ;\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> b_bidir_forw_mv_table_base , mv_table_size * 2 * sizeof ( int16_t ) , fail ) ;\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> b_bidir_back_mv_table_base , mv_table_size * 2 * sizeof ( int16_t ) , fail ) ;\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> b_direct_mv_table_base , mv_table_size * 2 * sizeof ( int16_t ) , fail ) ;\n s -> p_mv_table = s -> p_mv_table_base + s -> mb_stride + 1 ;\n s -> b_forw_mv_table = s -> b_forw_mv_table_base + s -> mb_stride + 1 ;\n s -> b_back_mv_table = s -> b_back_mv_table_base + s -> mb_stride + 1 ;\n s -> b_bidir_forw_mv_table = s -> b_bidir_forw_mv_table_base + s -> mb_stride + 1 ;\n s -> b_bidir_back_mv_table = s -> b_bidir_back_mv_table_base + s -> mb_stride + 1 ;\n s -> b_direct_mv_table = s -> b_direct_mv_table_base + s -> mb_stride + 1 ;\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> mb_type , mb_array_size * sizeof ( uint16_t ) , fail ) ;\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> lambda_table , mb_array_size * sizeof ( int ) , fail ) ;\n FF_ALLOC_OR_GOTO ( s -> avctx , s -> cplx_tab , mb_array_size * sizeof ( float ) , fail ) ;\n FF_ALLOC_OR_GOTO ( s -> avctx , s -> bits_tab , mb_array_size * sizeof ( float ) , fail ) ;\n }\n if ( s -> codec_id == AV_CODEC_ID_MPEG4 || ( s -> flags & CODEC_FLAG_INTERLACED_ME ) ) {\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n int j , k ;\n for ( j = 0 ;\n j < 2 ;\n j ++ ) {\n for ( k = 0 ;\n k < 2 ;\n k ++ ) {\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> b_field_mv_table_base [ i ] [ j ] [ k ] , mv_table_size * 2 * sizeof ( int16_t ) , fail ) ;\n s -> b_field_mv_table [ i ] [ j ] [ k ] = s -> b_field_mv_table_base [ i ] [ j ] [ k ] + s -> mb_stride + 1 ;\n }\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> b_field_select_table [ i ] [ j ] , mb_array_size * 2 * sizeof ( uint8_t ) , fail ) ;\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> p_field_mv_table_base [ i ] [ j ] , mv_table_size * 2 * sizeof ( int16_t ) , fail ) ;\n s -> p_field_mv_table [ i ] [ j ] = s -> p_field_mv_table_base [ i ] [ j ] + s -> mb_stride + 1 ;\n }\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> p_field_select_table [ i ] , mb_array_size * 2 * sizeof ( uint8_t ) , fail ) ;\n }\n }\n if ( s -> out_format == FMT_H263 ) {\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> coded_block_base , y_size , fail ) ;\n s -> coded_block = s -> coded_block_base + s -> b8_stride + 1 ;\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> cbp_table , mb_array_size * sizeof ( uint8_t ) , fail ) ;\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> pred_dir_table , mb_array_size * sizeof ( uint8_t ) , fail ) ;\n }\n if ( s -> h263_pred || s -> h263_plus || ! s -> encoding ) {\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> dc_val_base , yc_size * sizeof ( int16_t ) , fail ) ;\n s -> dc_val [ 0 ] = s -> dc_val_base + s -> b8_stride + 1 ;\n s -> dc_val [ 1 ] = s -> dc_val_base + y_size + s -> mb_stride + 1 ;\n s -> dc_val [ 2 ] = s -> dc_val [ 1 ] + c_size ;\n for ( i = 0 ;\n i < yc_size ;\n i ++ ) s -> dc_val_base [ i ] = 1024 ;\n }\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> mbintra_table , mb_array_size , fail ) ;\n memset ( s -> mbintra_table , 1 , mb_array_size ) ;\n FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> mbskip_table , mb_array_size + 2 , fail ) ;\n if ( ( s -> avctx -> debug & ( FF_DEBUG_VIS_QP | FF_DEBUG_VIS_MB_TYPE ) ) || s -> avctx -> debug_mv ) {\n s -> visualization_buffer [ 0 ] = av_malloc ( ( s -> mb_width * 16 + 2 * EDGE_WIDTH ) * s -> mb_height * 16 + 2 * EDGE_WIDTH ) ;\n s -> visualization_buffer [ 1 ] = av_malloc ( ( s -> mb_width * 16 + 2 * EDGE_WIDTH ) * s -> mb_height * 16 + 2 * EDGE_WIDTH ) ;\n s -> visualization_buffer [ 2 ] = av_malloc ( ( s -> mb_width * 16 + 2 * EDGE_WIDTH ) * s -> mb_height * 16 + 2 * EDGE_WIDTH ) ;\n }\n return init_er ( s ) ;\n fail : return AVERROR ( ENOMEM ) ;\n }", "hash": 2713698759296604855, "project": "debian", "size": 88, "target": 0, "idx": 3051}
{"code": "static void tgq_idct_put_mb_dconly ( TgqContext * s , AVFrame * frame , int mb_x , int mb_y , const int8_t * dc ) {\n int linesize = frame -> linesize [ 0 ] ;\n uint8_t * dest_y = frame -> data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;\n uint8_t * dest_cb = frame -> data [ 1 ] + ( mb_y * 8 * frame -> linesize [ 1 ] ) + mb_x * 8 ;\n uint8_t * dest_cr = frame -> data [ 2 ] + ( mb_y * 8 * frame -> linesize [ 2 ] ) + mb_x * 8 ;\n tgq_dconly ( s , dest_y , linesize , dc [ 0 ] ) ;\n tgq_dconly ( s , dest_y + 8 , linesize , dc [ 1 ] ) ;\n tgq_dconly ( s , dest_y + 8 * linesize , linesize , dc [ 2 ] ) ;\n tgq_dconly ( s , dest_y + 8 * linesize + 8 , linesize , dc [ 3 ] ) ;\n if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) {\n tgq_dconly ( s , dest_cb , frame -> linesize [ 1 ] , dc [ 4 ] ) ;\n tgq_dconly ( s , dest_cr , frame -> linesize [ 2 ] , dc [ 5 ] ) ;\n }\n }", "hash": 8588713512322173474, "project": "debian", "size": 14, "target": 0, "idx": 3061}
{"code": "static inline void ff_update_block_index ( MpegEncContext * s ) {\n const int block_size = 8 ;\n s -> block_index [ 0 ] += 2 ;\n s -> block_index [ 1 ] += 2 ;\n s -> block_index [ 2 ] += 2 ;\n s -> block_index [ 3 ] += 2 ;\n s -> block_index [ 4 ] ++ ;\n s -> block_index [ 5 ] ++ ;\n s -> dest [ 0 ] += 2 * block_size ;\n s -> dest [ 1 ] += block_size ;\n s -> dest [ 2 ] += block_size ;\n }", "hash": -9121264480768156147, "project": "debian", "size": 12, "target": 0, "idx": 3070}
{"code": "static inline int op ( uint8_t * * dst , const uint8_t * dst_end , GetByteContext * gb , int pixel , int count , int * x , int width , int linesize ) {\n int remaining = width - * x ;\n while ( count > 0 ) {\n int striplen = FFMIN ( count , remaining ) ;\n if ( gb ) {\n if ( bytestream2_get_bytes_left ( gb ) < striplen ) goto exhausted ;\n bytestream2_get_bufferu ( gb , * dst , striplen ) ;\n }\n else if ( pixel >= 0 ) memset ( * dst , pixel , striplen ) ;\n * dst += striplen ;\n remaining -= striplen ;\n count -= striplen ;\n if ( remaining <= 0 ) {\n * dst += linesize - width ;\n remaining = width ;\n }\n if ( linesize > 0 ) {\n if ( * dst >= dst_end ) goto exhausted ;\n }\n else {\n if ( * dst <= dst_end ) goto exhausted ;\n }\n }\n * x = width - remaining ;\n return 0 ;\n exhausted : * x = width - remaining ;\n return 1 ;\n }", "hash": -2343429046993510367, "project": "debian", "size": 28, "target": 0, "idx": 3088}
{"code": "static inline int get_coeff ( GetBitContext * gb , VLC * vlc ) {\n int val = get_vlc2 ( gb , vlc -> table , vlc -> bits , 2 ) ;\n return get_coeff_bits ( gb , val ) ;\n }", "hash": -5717349108307169967, "project": "debian", "size": 4, "target": 0, "idx": 3091}
{"code": "static inline void mss4_update_dc_cache ( MSS4Context * c , int mb_x ) {\n int i ;\n c -> dc_cache [ 0 ] [ TOP ] = c -> prev_dc [ 0 ] [ mb_x * 2 + 1 ] ;\n c -> dc_cache [ 0 ] [ LEFT ] = 0 ;\n c -> dc_cache [ 1 ] [ TOP ] = 0 ;\n c -> dc_cache [ 1 ] [ LEFT ] = 0 ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) c -> prev_dc [ 0 ] [ mb_x * 2 + i ] = 0 ;\n for ( i = 1 ;\n i < 3 ;\n i ++ ) {\n c -> dc_cache [ i + 1 ] [ TOP ] = c -> prev_dc [ i ] [ mb_x ] ;\n c -> dc_cache [ i + 1 ] [ LEFT ] = 0 ;\n c -> prev_dc [ i ] [ mb_x ] = 0 ;\n }\n }", "hash": -5717349108307169967, "project": "debian", "size": 17, "target": 0, "idx": 3092}
{"code": "static inline void loco_update_rice_param ( RICEContext * r , int val ) {\n r -> sum += val ;\n r -> count ++ ;\n if ( r -> count == 16 ) {\n r -> sum >>= 1 ;\n r -> count >>= 1 ;\n }\n }", "hash": -910422676404244037, "project": "debian", "size": 8, "target": 0, "idx": 3105}
{"code": "static int mp_decode_layer1 ( MPADecodeContext * s ) {\n int bound , i , v , n , ch , j , mant ;\n uint8_t allocation [ MPA_MAX_CHANNELS ] [ SBLIMIT ] ;\n uint8_t scale_factors [ MPA_MAX_CHANNELS ] [ SBLIMIT ] ;\n if ( s -> mode == MPA_JSTEREO ) bound = ( s -> mode_ext + 1 ) * 4 ;\n else bound = SBLIMIT ;\n for ( i = 0 ;\n i < bound ;\n i ++ ) {\n for ( ch = 0 ;\n ch < s -> nb_channels ;\n ch ++ ) {\n allocation [ ch ] [ i ] = get_bits ( & s -> gb , 4 ) ;\n }\n }\n for ( i = bound ;\n i < SBLIMIT ;\n i ++ ) allocation [ 0 ] [ i ] = get_bits ( & s -> gb , 4 ) ;\n for ( i = 0 ;\n i < bound ;\n i ++ ) {\n for ( ch = 0 ;\n ch < s -> nb_channels ;\n ch ++ ) {\n if ( allocation [ ch ] [ i ] ) scale_factors [ ch ] [ i ] = get_bits ( & s -> gb , 6 ) ;\n }\n }\n for ( i = bound ;\n i < SBLIMIT ;\n i ++ ) {\n if ( allocation [ 0 ] [ i ] ) {\n scale_factors [ 0 ] [ i ] = get_bits ( & s -> gb , 6 ) ;\n scale_factors [ 1 ] [ i ] = get_bits ( & s -> gb , 6 ) ;\n }\n }\n for ( j = 0 ;\n j < 12 ;\n j ++ ) {\n for ( i = 0 ;\n i < bound ;\n i ++ ) {\n for ( ch = 0 ;\n ch < s -> nb_channels ;\n ch ++ ) {\n n = allocation [ ch ] [ i ] ;\n if ( n ) {\n mant = get_bits ( & s -> gb , n + 1 ) ;\n v = l1_unscale ( n , mant , scale_factors [ ch ] [ i ] ) ;\n }\n else {\n v = 0 ;\n }\n s -> sb_samples [ ch ] [ j ] [ i ] = v ;\n }\n }\n for ( i = bound ;\n i < SBLIMIT ;\n i ++ ) {\n n = allocation [ 0 ] [ i ] ;\n if ( n ) {\n mant = get_bits ( & s -> gb , n + 1 ) ;\n v = l1_unscale ( n , mant , scale_factors [ 0 ] [ i ] ) ;\n s -> sb_samples [ 0 ] [ j ] [ i ] = v ;\n v = l1_unscale ( n , mant , scale_factors [ 1 ] [ i ] ) ;\n s -> sb_samples [ 1 ] [ j ] [ i ] = v ;\n }\n else {\n s -> sb_samples [ 0 ] [ j ] [ i ] = 0 ;\n s -> sb_samples [ 1 ] [ j ] [ i ] = 0 ;\n }\n }\n }\n return 12 ;\n }", "hash": -3591633859713840564, "project": "debian", "size": 74, "target": 0, "idx": 3114}
{"code": "static void switch_buffer ( MPADecodeContext * s , int * pos , int * end_pos , int * end_pos2 ) {\n if ( s -> in_gb . buffer && * pos >= s -> gb . size_in_bits ) {\n s -> gb = s -> in_gb ;\n s -> in_gb . buffer = NULL ;\n assert ( ( get_bits_count ( & s -> gb ) & 7 ) == 0 ) ;\n skip_bits_long ( & s -> gb , * pos - * end_pos ) ;\n * end_pos2 = * end_pos = * end_pos2 + get_bits_count ( & s -> gb ) - * pos ;\n * pos = get_bits_count ( & s -> gb ) ;\n }\n }", "hash": -3591633859713840564, "project": "debian", "size": 10, "target": 0, "idx": 3124}
{"code": "static void reorder_block ( MPADecodeContext * s , GranuleDef * g ) {\n int i , j , len ;\n INTFLOAT * ptr , * dst , * ptr1 ;\n INTFLOAT tmp [ 576 ] ;\n if ( g -> block_type != 2 ) return ;\n if ( g -> switch_point ) {\n if ( s -> sample_rate_index != 8 ) ptr = g -> sb_hybrid + 36 ;\n else ptr = g -> sb_hybrid + 72 ;\n }\n else {\n ptr = g -> sb_hybrid ;\n }\n for ( i = g -> short_start ;\n i < 13 ;\n i ++ ) {\n len = band_size_short [ s -> sample_rate_index ] [ i ] ;\n ptr1 = ptr ;\n dst = tmp ;\n for ( j = len ;\n j > 0 ;\n j -- ) {\n * dst ++ = ptr [ 0 * len ] ;\n * dst ++ = ptr [ 1 * len ] ;\n * dst ++ = ptr [ 2 * len ] ;\n ptr ++ ;\n }\n ptr += 2 * len ;\n memcpy ( ptr1 , tmp , len * 3 * sizeof ( * ptr1 ) ) ;\n }\n }", "hash": -3591633859713840564, "project": "debian", "size": 30, "target": 0, "idx": 3127}
{"code": "static void qtrle_decode_32bpp ( QtrleContext * s , int row_ptr , int lines_to_change ) {\n int rle_code ;\n int pixel_ptr ;\n int row_inc = s -> frame . linesize [ 0 ] ;\n unsigned int argb ;\n unsigned char * rgb = s -> frame . data [ 0 ] ;\n int pixel_limit = s -> frame . linesize [ 0 ] * s -> avctx -> height ;\n while ( lines_to_change -- ) {\n pixel_ptr = row_ptr + ( bytestream2_get_byte ( & s -> g ) - 1 ) * 4 ;\n CHECK_PIXEL_PTR ( 0 ) ;\n while ( ( rle_code = ( signed char ) bytestream2_get_byte ( & s -> g ) ) != - 1 ) {\n if ( rle_code == 0 ) {\n pixel_ptr += ( bytestream2_get_byte ( & s -> g ) - 1 ) * 4 ;\n CHECK_PIXEL_PTR ( 0 ) ;\n }\n else if ( rle_code < 0 ) {\n rle_code = - rle_code ;\n argb = bytestream2_get_be32 ( & s -> g ) ;\n CHECK_PIXEL_PTR ( rle_code * 4 ) ;\n while ( rle_code -- ) {\n AV_WN32A ( rgb + pixel_ptr , argb ) ;\n pixel_ptr += 4 ;\n }\n }\n else {\n CHECK_PIXEL_PTR ( rle_code * 4 ) ;\n while ( rle_code -- ) {\n argb = bytestream2_get_be32 ( & s -> g ) ;\n AV_WN32A ( rgb + pixel_ptr , argb ) ;\n pixel_ptr += 4 ;\n }\n }\n }\n row_ptr += row_inc ;\n }\n }", "hash": 5772289003363923137, "project": "debian", "size": 36, "target": 0, "idx": 3139}
{"code": "static inline void bit_copy ( PutBitContext * pb , GetBitContext * gb ) {\n int bits_left = get_bits_left ( gb ) ;\n while ( bits_left >= MIN_CACHE_BITS ) {\n put_bits ( pb , MIN_CACHE_BITS , get_bits ( gb , MIN_CACHE_BITS ) ) ;\n bits_left -= MIN_CACHE_BITS ;\n }\n if ( bits_left > 0 ) {\n put_bits ( pb , bits_left , get_bits ( gb , bits_left ) ) ;\n }\n }", "hash": 8952659721822029396, "project": "debian", "size": 10, "target": 0, "idx": 3159}
{"code": "static int lag_decode_prob ( GetBitContext * gb , uint32_t * value ) {\n static const uint8_t series [ ] = {\n 1 , 2 , 3 , 5 , 8 , 13 , 21 }\n ;\n int i ;\n int bit = 0 ;\n int bits = 0 ;\n int prevbit = 0 ;\n unsigned val ;\n for ( i = 0 ;\n i < 7 ;\n i ++ ) {\n if ( prevbit && bit ) break ;\n prevbit = bit ;\n bit = get_bits1 ( gb ) ;\n if ( bit && ! prevbit ) bits += series [ i ] ;\n }\n bits -- ;\n if ( bits < 0 || bits > 31 ) {\n * value = 0 ;\n return - 1 ;\n }\n else if ( bits == 0 ) {\n * value = 0 ;\n return 0 ;\n }\n val = get_bits_long ( gb , bits ) ;\n val |= 1 << bits ;\n * value = val - 1 ;\n return 0 ;\n }", "hash": 4722923622195275414, "project": "debian", "size": 31, "target": 0, "idx": 3170}
{"code": "static int lag_decode_arith_plane ( LagarithContext * l , uint8_t * dst , int width , int height , int stride , const uint8_t * src , int src_size ) {\n int i = 0 ;\n int read = 0 ;\n uint32_t length ;\n uint32_t offset = 1 ;\n int esc_count = src [ 0 ] ;\n GetBitContext gb ;\n lag_rac rac ;\n const uint8_t * src_end = src + src_size ;\n rac . avctx = l -> avctx ;\n l -> zeros = 0 ;\n if ( esc_count < 4 ) {\n length = width * height ;\n if ( esc_count && AV_RL32 ( src + 1 ) < length ) {\n length = AV_RL32 ( src + 1 ) ;\n offset += 4 ;\n }\n init_get_bits ( & gb , src + offset , src_size * 8 ) ;\n if ( lag_read_prob_header ( & rac , & gb ) < 0 ) return - 1 ;\n ff_lag_rac_init ( & rac , & gb , length - stride ) ;\n for ( i = 0 ;\n i < height ;\n i ++ ) read += lag_decode_line ( l , & rac , dst + ( i * stride ) , width , stride , esc_count ) ;\n if ( read > length ) av_log ( l -> avctx , AV_LOG_WARNING , \"Output more bytes than length (%d of %d)\\n\" , read , length ) ;\n }\n else if ( esc_count < 8 ) {\n esc_count -= 4 ;\n if ( esc_count > 0 ) {\n for ( i = 0 ;\n i < height ;\n i ++ ) {\n int res = lag_decode_zero_run_line ( l , dst + ( i * stride ) , src , src_end , width , esc_count ) ;\n if ( res < 0 ) return res ;\n src += res ;\n }\n }\n else {\n if ( src_size < width * height ) return AVERROR_INVALIDDATA ;\n for ( i = 0 ;\n i < height ;\n i ++ ) {\n memcpy ( dst + ( i * stride ) , src , width ) ;\n src += width ;\n }\n }\n }\n else if ( esc_count == 0xff ) {\n for ( i = 0 ;\n i < height ;\n i ++ ) memset ( dst + i * stride , src [ 1 ] , width ) ;\n return 0 ;\n }\n else {\n av_log ( l -> avctx , AV_LOG_ERROR , \"Invalid zero run escape code! (%#x)\\n\" , esc_count ) ;\n return - 1 ;\n }\n if ( l -> avctx -> pix_fmt != AV_PIX_FMT_YUV422P ) {\n for ( i = 0 ;\n i < height ;\n i ++ ) {\n lag_pred_line ( l , dst , width , stride , i ) ;\n dst += stride ;\n }\n }\n else {\n for ( i = 0 ;\n i < height ;\n i ++ ) {\n lag_pred_line_yuy2 ( l , dst , width , stride , i , width == l -> avctx -> width ) ;\n dst += stride ;\n }\n }\n return 0 ;\n }", "hash": 4722923622195275414, "project": "debian", "size": 74, "target": 0, "idx": 3178}
{"code": "static int lag_decode_line ( LagarithContext * l , lag_rac * rac , uint8_t * dst , int width , int stride , int esc_count ) {\n int i = 0 ;\n int ret = 0 ;\n if ( ! esc_count ) esc_count = - 1 ;\n handle_zeros : if ( l -> zeros_rem ) {\n int count = FFMIN ( l -> zeros_rem , width - i ) ;\n memset ( dst + i , 0 , count ) ;\n i += count ;\n l -> zeros_rem -= count ;\n }\n while ( i < width ) {\n dst [ i ] = lag_get_rac ( rac ) ;\n ret ++ ;\n if ( dst [ i ] ) l -> zeros = 0 ;\n else l -> zeros ++ ;\n i ++ ;\n if ( l -> zeros == esc_count ) {\n int index = lag_get_rac ( rac ) ;\n ret ++ ;\n l -> zeros = 0 ;\n l -> zeros_rem = lag_calc_zero_run ( index ) ;\n goto handle_zeros ;\n }\n }\n return ret ;\n }", "hash": 4722923622195275414, "project": "debian", "size": 26, "target": 0, "idx": 3179}
{"code": "static int decode_block_type ( RangeCoder * c , BlockTypeContext * bt ) {\n bt -> last_type = rac_get_model_sym ( c , & bt -> bt_model [ bt -> last_type ] ) ;\n return bt -> last_type ;\n }", "hash": -454486177854888036, "project": "debian", "size": 4, "target": 0, "idx": 3184}
{"code": "static void model256_reset ( Model256 * m ) {\n int i ;\n for ( i = 0 ;\n i < 255 ;\n i ++ ) m -> weights [ i ] = 1 ;\n m -> weights [ 255 ] = 0 ;\n m -> tot_weight = 0 ;\n m -> upd_val = 256 ;\n m -> till_rescale = 1 ;\n model256_update ( m , 255 ) ;\n m -> till_rescale = m -> upd_val = ( 256 + 6 ) >> 1 ;\n }", "hash": -454486177854888036, "project": "debian", "size": 12, "target": 0, "idx": 3202}
{"code": "static int decode_channel ( RALFContext * ctx , GetBitContext * gb , int ch , int length , int mode , int bits ) {\n int i , t ;\n int code_params ;\n VLCSet * set = ctx -> sets + mode ;\n VLC * code_vlc ;\n int range , range2 , add_bits ;\n int * dst = ctx -> channel_data [ ch ] ;\n ctx -> filter_params = get_vlc2 ( gb , set -> filter_params . table , 9 , 2 ) ;\n ctx -> filter_bits = ( ctx -> filter_params - 2 ) >> 6 ;\n ctx -> filter_length = ctx -> filter_params - ( ctx -> filter_bits << 6 ) - 1 ;\n if ( ctx -> filter_params == FILTER_RAW ) {\n for ( i = 0 ;\n i < length ;\n i ++ ) dst [ i ] = get_bits ( gb , bits ) ;\n ctx -> bias [ ch ] = 0 ;\n return 0 ;\n }\n ctx -> bias [ ch ] = get_vlc2 ( gb , set -> bias . table , 9 , 2 ) ;\n ctx -> bias [ ch ] = extend_code ( gb , ctx -> bias [ ch ] , 127 , 4 ) ;\n if ( ctx -> filter_params == FILTER_NONE ) {\n memset ( dst , 0 , sizeof ( * dst ) * length ) ;\n return 0 ;\n }\n if ( ctx -> filter_params > 1 ) {\n int cmode = 0 , coeff = 0 ;\n VLC * vlc = set -> filter_coeffs [ ctx -> filter_bits ] + 5 ;\n add_bits = ctx -> filter_bits ;\n for ( i = 0 ;\n i < ctx -> filter_length ;\n i ++ ) {\n t = get_vlc2 ( gb , vlc [ cmode ] . table , vlc [ cmode ] . bits , 2 ) ;\n t = extend_code ( gb , t , 21 , add_bits ) ;\n if ( ! cmode ) coeff -= 12 << add_bits ;\n coeff = t - coeff ;\n ctx -> filter [ i ] = coeff ;\n cmode = coeff >> add_bits ;\n if ( cmode < 0 ) {\n cmode = - 1 - av_log2 ( - cmode ) ;\n if ( cmode < - 5 ) cmode = - 5 ;\n }\n else if ( cmode > 0 ) {\n cmode = 1 + av_log2 ( cmode ) ;\n if ( cmode > 5 ) cmode = 5 ;\n }\n }\n }\n code_params = get_vlc2 ( gb , set -> coding_mode . table , set -> coding_mode . bits , 2 ) ;\n if ( code_params >= 15 ) {\n add_bits = av_clip ( ( code_params / 5 - 3 ) / 2 , 0 , 10 ) ;\n if ( add_bits > 9 && ( code_params % 5 ) != 2 ) add_bits -- ;\n range = 10 ;\n range2 = 21 ;\n code_vlc = set -> long_codes + code_params - 15 ;\n }\n else {\n add_bits = 0 ;\n range = 6 ;\n range2 = 13 ;\n code_vlc = set -> short_codes + code_params ;\n }\n for ( i = 0 ;\n i < length ;\n i += 2 ) {\n int code1 , code2 ;\n t = get_vlc2 ( gb , code_vlc -> table , code_vlc -> bits , 2 ) ;\n code1 = t / range2 ;\n code2 = t % range2 ;\n dst [ i ] = extend_code ( gb , code1 , range , 0 ) << add_bits ;\n dst [ i + 1 ] = extend_code ( gb , code2 , range , 0 ) << add_bits ;\n if ( add_bits ) {\n dst [ i ] |= get_bits ( gb , add_bits ) ;\n dst [ i + 1 ] |= get_bits ( gb , add_bits ) ;\n }\n }\n return 0 ;\n }", "hash": -2385618084223928445, "project": "debian", "size": 76, "target": 0, "idx": 3214}
{"code": "static inline int adjust_pred16 ( int itype , int up , int left ) {\n if ( ! up && ! left ) itype = DC_128_PRED8x8 ;\n else if ( ! up ) {\n if ( itype == PLANE_PRED8x8 ) itype = HOR_PRED8x8 ;\n if ( itype == VERT_PRED8x8 ) itype = HOR_PRED8x8 ;\n if ( itype == DC_PRED8x8 ) itype = LEFT_DC_PRED8x8 ;\n }\n else if ( ! left ) {\n if ( itype == PLANE_PRED8x8 ) itype = VERT_PRED8x8 ;\n if ( itype == HOR_PRED8x8 ) itype = VERT_PRED8x8 ;\n if ( itype == DC_PRED8x8 ) itype = TOP_DC_PRED8x8 ;\n }\n return itype ;\n }", "hash": 2335222688263906532, "project": "debian", "size": 14, "target": 0, "idx": 3221}
{"code": "static int is_mv_diff_gt_3 ( int16_t ( * motion_val ) [ 2 ] , int step ) {\n int d ;\n d = motion_val [ 0 ] [ 0 ] - motion_val [ - step ] [ 0 ] ;\n if ( d < - 3 || d > 3 ) return 1 ;\n d = motion_val [ 0 ] [ 1 ] - motion_val [ - step ] [ 1 ] ;\n if ( d < - 3 || d > 3 ) return 1 ;\n return 0 ;\n }", "hash": 2335222688263906532, "project": "debian", "size": 8, "target": 0, "idx": 3224}
{"code": "static void rv34_pred_mv ( RV34DecContext * r , int block_type , int subblock_no , int dmv_no ) {\n MpegEncContext * s = & r -> s ;\n int mv_pos = s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ;\n int A [ 2 ] = {\n 0 }\n , B [ 2 ] , C [ 2 ] ;\n int i , j ;\n int mx , my ;\n int * avail = r -> avail_cache + avail_indexes [ subblock_no ] ;\n int c_off = part_sizes_w [ block_type ] ;\n mv_pos += ( subblock_no & 1 ) + ( subblock_no >> 1 ) * s -> b8_stride ;\n if ( subblock_no == 3 ) c_off = - 1 ;\n if ( avail [ - 1 ] ) {\n A [ 0 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - 1 ] [ 0 ] ;\n A [ 1 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - 1 ] [ 1 ] ;\n }\n if ( avail [ - 4 ] ) {\n B [ 0 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - s -> b8_stride ] [ 0 ] ;\n B [ 1 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - s -> b8_stride ] [ 1 ] ;\n }\n else {\n B [ 0 ] = A [ 0 ] ;\n B [ 1 ] = A [ 1 ] ;\n }\n if ( ! avail [ c_off - 4 ] ) {\n if ( avail [ - 4 ] && ( avail [ - 1 ] || r -> rv30 ) ) {\n C [ 0 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - s -> b8_stride - 1 ] [ 0 ] ;\n C [ 1 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - s -> b8_stride - 1 ] [ 1 ] ;\n }\n else {\n C [ 0 ] = A [ 0 ] ;\n C [ 1 ] = A [ 1 ] ;\n }\n }\n else {\n C [ 0 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - s -> b8_stride + c_off ] [ 0 ] ;\n C [ 1 ] = s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos - s -> b8_stride + c_off ] [ 1 ] ;\n }\n mx = mid_pred ( A [ 0 ] , B [ 0 ] , C [ 0 ] ) ;\n my = mid_pred ( A [ 1 ] , B [ 1 ] , C [ 1 ] ) ;\n mx += r -> dmv [ dmv_no ] [ 0 ] ;\n my += r -> dmv [ dmv_no ] [ 1 ] ;\n for ( j = 0 ;\n j < part_sizes_h [ block_type ] ;\n j ++ ) {\n for ( i = 0 ;\n i < part_sizes_w [ block_type ] ;\n i ++ ) {\n s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos + i + j * s -> b8_stride ] [ 0 ] = mx ;\n s -> current_picture_ptr -> motion_val [ 0 ] [ mv_pos + i + j * s -> b8_stride ] [ 1 ] = my ;\n }\n }\n }", "hash": 2335222688263906532, "project": "debian", "size": 53, "target": 0, "idx": 3236}
{"code": "static void rv34_mc_2mv ( RV34DecContext * r , const int block_type ) {\n int weighted = ! r -> rv30 && block_type != RV34_MB_B_BIDIR && r -> weight1 != 8192 ;\n rv34_mc ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 , r -> rv30 , weighted , r -> rdsp . put_pixels_tab , r -> rdsp . put_chroma_pixels_tab ) ;\n if ( ! weighted ) {\n rv34_mc ( r , block_type , 0 , 0 , 0 , 2 , 2 , 1 , r -> rv30 , 0 , r -> rdsp . avg_pixels_tab , r -> rdsp . avg_chroma_pixels_tab ) ;\n }\n else {\n rv34_mc ( r , block_type , 0 , 0 , 0 , 2 , 2 , 1 , r -> rv30 , 1 , r -> rdsp . put_pixels_tab , r -> rdsp . put_chroma_pixels_tab ) ;\n rv4_weight ( r ) ;\n }\n }", "hash": 2335222688263906532, "project": "debian", "size": 11, "target": 0, "idx": 3237}
{"code": "static inline void decode_coeff ( int16_t * dst , int coef , int esc , GetBitContext * gb , VLC * vlc , int q ) {\n if ( coef ) {\n if ( coef == esc ) {\n coef = get_vlc2 ( gb , vlc -> table , 9 , 2 ) ;\n if ( coef > 23 ) {\n coef -= 23 ;\n coef = 22 + ( ( 1 << coef ) | get_bits ( gb , coef ) ) ;\n }\n coef += esc ;\n }\n if ( get_bits1 ( gb ) ) coef = - coef ;\n * dst = ( coef * q + 8 ) >> 4 ;\n }\n }", "hash": 2335222688263906532, "project": "debian", "size": 14, "target": 0, "idx": 3241}
{"code": "static inline RV34VLC * choose_vlc_set ( int quant , int mod , int type ) {\n if ( mod == 2 && quant < 19 ) quant += 10 ;\n else if ( mod && quant < 26 ) quant += 5 ;\n return type ? & inter_vlcs [ rv34_quant_to_vlc_set [ 1 ] [ av_clip ( quant , 0 , 30 ) ] ] : & intra_vlcs [ rv34_quant_to_vlc_set [ 0 ] [ av_clip ( quant , 0 , 30 ) ] ] ;\n }", "hash": 2335222688263906532, "project": "debian", "size": 5, "target": 0, "idx": 3249}
{"code": "int ff_h263_resync ( MpegEncContext * s ) {\n int left , pos , ret ;\n if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) {\n skip_bits1 ( & s -> gb ) ;\n align_get_bits ( & s -> gb ) ;\n }\n if ( show_bits ( & s -> gb , 16 ) == 0 ) {\n pos = get_bits_count ( & s -> gb ) ;\n if ( CONFIG_MPEG4_DECODER && s -> codec_id == AV_CODEC_ID_MPEG4 ) ret = ff_mpeg4_decode_video_packet_header ( s ) ;\n else ret = h263_decode_gob_header ( s ) ;\n if ( ret >= 0 ) return pos ;\n }\n s -> gb = s -> last_resync_gb ;\n align_get_bits ( & s -> gb ) ;\n left = get_bits_left ( & s -> gb ) ;\n for ( ;\n left > 16 + 1 + 5 + 5 ;\n left -= 8 ) {\n if ( show_bits ( & s -> gb , 16 ) == 0 ) {\n GetBitContext bak = s -> gb ;\n pos = get_bits_count ( & s -> gb ) ;\n if ( CONFIG_MPEG4_DECODER && s -> codec_id == AV_CODEC_ID_MPEG4 ) ret = ff_mpeg4_decode_video_packet_header ( s ) ;\n else ret = h263_decode_gob_header ( s ) ;\n if ( ret >= 0 ) return pos ;\n s -> gb = bak ;\n }\n skip_bits ( & s -> gb , 8 ) ;\n }\n return - 1 ;\n }", "hash": 2772622454795674000, "project": "debian", "size": 30, "target": 0, "idx": 3273}
{"code": "void ff_h263_decode_init_vlc ( void ) {\n static int done = 0 ;\n if ( ! done ) {\n done = 1 ;\n INIT_VLC_STATIC ( & ff_h263_intra_MCBPC_vlc , INTRA_MCBPC_VLC_BITS , 9 , ff_h263_intra_MCBPC_bits , 1 , 1 , ff_h263_intra_MCBPC_code , 1 , 1 , 72 ) ;\n INIT_VLC_STATIC ( & ff_h263_inter_MCBPC_vlc , INTER_MCBPC_VLC_BITS , 28 , ff_h263_inter_MCBPC_bits , 1 , 1 , ff_h263_inter_MCBPC_code , 1 , 1 , 198 ) ;\n INIT_VLC_STATIC ( & ff_h263_cbpy_vlc , CBPY_VLC_BITS , 16 , & ff_h263_cbpy_tab [ 0 ] [ 1 ] , 2 , 1 , & ff_h263_cbpy_tab [ 0 ] [ 0 ] , 2 , 1 , 64 ) ;\n INIT_VLC_STATIC ( & mv_vlc , MV_VLC_BITS , 33 , & ff_mvtab [ 0 ] [ 1 ] , 2 , 1 , & ff_mvtab [ 0 ] [ 0 ] , 2 , 1 , 538 ) ;\n ff_init_rl ( & ff_h263_rl_inter , ff_h263_static_rl_table_store [ 0 ] ) ;\n ff_init_rl ( & ff_rl_intra_aic , ff_h263_static_rl_table_store [ 1 ] ) ;\n INIT_VLC_RL ( ff_h263_rl_inter , 554 ) ;\n INIT_VLC_RL ( ff_rl_intra_aic , 554 ) ;\n INIT_VLC_STATIC ( & h263_mbtype_b_vlc , H263_MBTYPE_B_VLC_BITS , 15 , & ff_h263_mbtype_b_tab [ 0 ] [ 1 ] , 2 , 1 , & ff_h263_mbtype_b_tab [ 0 ] [ 0 ] , 2 , 1 , 80 ) ;\n INIT_VLC_STATIC ( & cbpc_b_vlc , CBPC_B_VLC_BITS , 4 , & ff_cbpc_b_tab [ 0 ] [ 1 ] , 2 , 1 , & ff_cbpc_b_tab [ 0 ] [ 0 ] , 2 , 1 , 8 ) ;\n }\n }", "hash": 2772622454795674000, "project": "debian", "size": 16, "target": 0, "idx": 3280}
{"code": "void proto_register_applemidi ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_applemidi_signature , {\n \"Signature\" , \"applemidi.signature\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_command , {\n \"Command\" , \"applemidi.command\" , FT_UINT16 , BASE_HEX , VALS ( applemidi_commands ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_protocol_version , {\n \"Protocol Version\" , \"applemidi.protocol_version\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_token , {\n \"Initiator Token\" , \"applemidi.initiator_token\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_ssrc , {\n \"Sender SSRC\" , \"applemidi.sender_ssrc\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_name , {\n \"Name\" , \"applemidi.name\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_count , {\n \"Count\" , \"applemidi.count\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_padding , {\n \"Padding\" , \"applemidi.padding\" , FT_UINT24 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_timestamp1 , {\n \"Timestamp 1\" , \"applemidi.timestamp1\" , FT_UINT64 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_timestamp2 , {\n \"Timestamp 2\" , \"applemidi.timestamp2\" , FT_UINT64 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_timestamp3 , {\n \"Timestamp 3\" , \"applemidi.timestamp3\" , FT_UINT64 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_sequence_num , {\n \"Sequence Number\" , \"applemidi.sequence_number\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_rtp_sequence_num , {\n \"RTP Sequence Number\" , \"applemidi.rtp_sequence_number\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_rtp_bitrate_limit , {\n \"Bitrate limit\" , \"applemidi.bitrate_limit\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_applemidi_unknown_data , {\n \"Unknown Data\" , \"applemidi.unknown_data\" , FT_BYTES , BASE_NONE , NULL , 0x00 , NULL , HFILL }\n }\n , }\n ;\n static gint * ett [ ] = {\n & ett_applemidi , & ett_applemidi_seq_num }\n ;\n proto_applemidi = proto_register_protocol ( APPLEMIDI_DISSECTOR_NAME , APPLEMIDI_DISSECTOR_SHORTNAME , APPLEMIDI_DISSECTOR_ABBREVIATION ) ;\n proto_register_field_array ( proto_applemidi , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n }", "hash": 5976900907644301719, "project": "debian", "size": 71, "target": 0, "idx": 3300}
{"code": "void proto_reg_handoff_rtp ( void ) {\n static gboolean rtp_prefs_initialized = FALSE ;\n static dissector_handle_t rtp_rfc2198_handle ;\n static dissector_handle_t rtp_hdr_ext_ed137_handle ;\n static dissector_handle_t rtp_hdr_ext_ed137a_handle ;\n static guint rtp_saved_rfc2198_pt ;\n if ( ! rtp_prefs_initialized ) {\n rtp_handle = find_dissector ( \"rtp\" ) ;\n rtp_rfc2198_handle = find_dissector ( \"rtp.rfc2198\" ) ;\n dissector_add_handle ( \"udp.port\" , rtp_handle ) ;\n dissector_add_string ( \"rtp_dyn_payload_type\" , \"red\" , rtp_rfc2198_handle ) ;\n heur_dissector_add ( \"udp\" , dissect_rtp_heur_udp , proto_rtp ) ;\n heur_dissector_add ( \"stun\" , dissect_rtp_heur_stun , proto_rtp ) ;\n rtp_hdr_ext_ed137_handle = find_dissector ( \"rtp.ext.ed137\" ) ;\n rtp_hdr_ext_ed137a_handle = find_dissector ( \"rtp.ext.ed137a\" ) ;\n dissector_add_uint ( \"rtp.hdr_ext\" , RTP_ED137_SIG , rtp_hdr_ext_ed137_handle ) ;\n dissector_add_uint ( \"rtp.hdr_ext\" , RTP_ED137A_SIG , rtp_hdr_ext_ed137a_handle ) ;\n rtcp_handle = find_dissector ( \"rtcp\" ) ;\n data_handle = find_dissector ( \"data\" ) ;\n stun_handle = find_dissector ( \"stun-udp\" ) ;\n classicstun_handle = find_dissector ( \"classicstun\" ) ;\n classicstun_heur_handle = find_dissector ( \"classicstun-heur\" ) ;\n stun_heur_handle = find_dissector ( \"stun-heur\" ) ;\n t38_handle = find_dissector ( \"t38\" ) ;\n zrtp_handle = find_dissector ( \"zrtp\" ) ;\n sprt_handle = find_dissector ( \"sprt\" ) ;\n v150fw_handle = find_dissector ( \"v150fw\" ) ;\n bta2dp_content_protection_header_scms_t = find_dissector ( \"bta2dp_content_protection_header_scms_t\" ) ;\n btvdp_content_protection_header_scms_t = find_dissector ( \"btvdp_content_protection_header_scms_t\" ) ;\n bta2dp_handle = find_dissector ( \"bta2dp\" ) ;\n btvdp_handle = find_dissector ( \"btvdp\" ) ;\n sbc_handle = find_dissector ( \"sbc\" ) ;\n dissector_add_string ( \"rtp_dyn_payload_type\" , \"v150fw\" , v150fw_handle ) ;\n dissector_add_handle ( \"btl2cap.cid\" , rtp_handle ) ;\n rtp_prefs_initialized = TRUE ;\n }\n else {\n dissector_delete_uint ( \"rtp.pt\" , rtp_saved_rfc2198_pt , rtp_rfc2198_handle ) ;\n }\n dissector_add_uint ( \"rtp.pt\" , rtp_rfc2198_pt , rtp_rfc2198_handle ) ;\n rtp_saved_rfc2198_pt = rtp_rfc2198_pt ;\n }", "hash": -6333668321124139371, "project": "debian", "size": 42, "target": 0, "idx": 3319}
{"code": "static guint32 calculate_extended_seqno ( guint32 previous_seqno , guint16 raw_seqno ) {\n guint32 seqno = ( previous_seqno & 0xffff0000 ) | raw_seqno ;\n if ( seqno + 0x8000 < previous_seqno ) {\n seqno += 0x10000 ;\n }\n else if ( previous_seqno + 0x8000 < seqno ) {\n seqno -= 0x10000 ;\n }\n return seqno ;\n }", "hash": -6333668321124139371, "project": "debian", "size": 10, "target": 0, "idx": 3333}
{"code": "void proto_reg_handoff_pkt_ccc ( void ) {\n static gboolean initialized = FALSE ;\n static dissector_handle_t pkt_ccc_handle ;\n static guint saved_pkt_ccc_udp_port ;\n if ( ! initialized ) {\n pkt_ccc_handle = find_dissector ( \"pkt_ccc\" ) ;\n dissector_add_handle ( \"udp.port\" , pkt_ccc_handle ) ;\n initialized = TRUE ;\n }\n else {\n if ( saved_pkt_ccc_udp_port != 0 ) {\n dissector_delete_uint ( \"udp.port\" , saved_pkt_ccc_udp_port , pkt_ccc_handle ) ;\n }\n }\n if ( global_pkt_ccc_udp_port != 0 ) {\n dissector_add_uint ( \"udp.port\" , global_pkt_ccc_udp_port , pkt_ccc_handle ) ;\n }\n saved_pkt_ccc_udp_port = global_pkt_ccc_udp_port ;\n }", "hash": -6333668321124139371, "project": "debian", "size": 19, "target": 0, "idx": 3336}
{"code": "static gboolean dissect_rtp_heur_udp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n return dissect_rtp_heur_common ( tvb , pinfo , tree , data , TRUE ) ;\n }", "hash": -6333668321124139371, "project": "debian", "size": 3, "target": 0, "idx": 3337}
{"code": "static void init_h245_packet_info ( h245_packet_info * pi ) {\n if ( pi == NULL ) {\n return ;\n }\n pi -> msg_type = H245_OTHER ;\n pi -> frame_label [ 0 ] = '\\0' ;\n g_snprintf ( pi -> comment , sizeof ( pi -> comment ) , \"H245 \" ) ;\n }", "hash": -4719501675862910941, "project": "debian", "size": 8, "target": 0, "idx": 3351}
{"code": "static void h223_lc_init ( void ) {\n h223_lc_init_dir ( P2P_DIR_SENT ) ;\n h223_lc_init_dir ( P2P_DIR_RECV ) ;\n h223_lc_params_temp = NULL ;\n h245_lc_dissector = NULL ;\n h223_fw_lc_num = 0 ;\n }", "hash": -4719501675862910941, "project": "debian", "size": 7, "target": 0, "idx": 3352}
{"code": "static void mgcpDialedDigits ( gchar * signalStr , gchar * * dialedDigits ) {\n gchar * tmpStr ;\n gchar * resultStr ;\n gint i , j ;\n guint resultStrLen = 1 ;\n if ( signalStr == NULL ) return ;\n tmpStr = g_strdup ( signalStr ) ;\n for ( i = 0 ;\n tmpStr [ i ] ;\n i ++ ) {\n switch ( tmpStr [ i ] ) {\n case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case '#' : case '*' : resultStrLen ++ ;\n break ;\n default : tmpStr [ i ] = '?' ;\n break ;\n }\n }\n if ( resultStrLen == 1 ) {\n g_free ( tmpStr ) ;\n return ;\n }\n resultStr = ( gchar * ) g_malloc ( resultStrLen ) ;\n for ( i = 0 , j = 0 ;\n tmpStr [ i ] ;\n i ++ ) {\n if ( tmpStr [ i ] != '?' ) resultStr [ j ++ ] = tmpStr [ i ] ;\n }\n resultStr [ j ] = '\\0' ;\n g_free ( * dialedDigits ) ;\n g_free ( tmpStr ) ;\n * dialedDigits = resultStr ;\n return ;\n }", "hash": -2928324134072492299, "project": "debian", "size": 33, "target": 0, "idx": 3380}
{"code": "static int VoIPcalls_packet ( void * ptr _U_ , packet_info * pinfo , epan_dissect_t * edt _U_ , const void * VoIPinfo ) {\n voip_calls_tapinfo_t * tapinfo = & the_tapinfo_struct ;\n voip_calls_info_t * callsinfo = NULL ;\n voip_calls_info_t * tmp_listinfo ;\n GList * list = NULL ;\n const voip_packet_info_t * pi = ( const voip_packet_info_t * ) VoIPinfo ;\n if ( pi -> call_id ) list = g_list_first ( tapinfo -> callsinfo_list ) ;\n while ( list ) {\n tmp_listinfo = ( voip_calls_info_t * ) list -> data ;\n if ( tmp_listinfo -> protocol == VOIP_COMMON ) {\n if ( ! strcmp ( pi -> call_id , tmp_listinfo -> call_id ) ) {\n callsinfo = ( voip_calls_info_t * ) ( list -> data ) ;\n break ;\n }\n }\n list = g_list_next ( list ) ;\n }\n if ( callsinfo == NULL ) {\n callsinfo = ( voip_calls_info_t * ) g_malloc0 ( sizeof ( voip_calls_info_t ) ) ;\n callsinfo -> call_active_state = pi -> call_active_state ;\n callsinfo -> call_state = pi -> call_state ;\n callsinfo -> call_id = g_strdup ( ( pi -> call_id ) ? pi -> call_id : \"\" ) ;\n callsinfo -> from_identity = g_strdup ( ( pi -> from_identity ) ? pi -> from_identity : \"\" ) ;\n callsinfo -> to_identity = g_strdup ( ( pi -> to_identity ) ? pi -> to_identity : \"\" ) ;\n COPY_ADDRESS ( & ( callsinfo -> initial_speaker ) , & ( pinfo -> src ) ) ;\n callsinfo -> selected = FALSE ;\n callsinfo -> start_fd = pinfo -> fd ;\n callsinfo -> start_rel_ts = pinfo -> rel_ts ;\n callsinfo -> protocol = VOIP_COMMON ;\n callsinfo -> protocol_name = g_strdup ( ( pi -> protocol_name ) ? pi -> protocol_name : \"\" ) ;\n callsinfo -> call_comment = g_strdup ( ( pi -> call_comment ) ? pi -> call_comment : \"\" ) ;\n callsinfo -> prot_info = NULL ;\n callsinfo -> free_prot_info = NULL ;\n callsinfo -> call_num = tapinfo -> ncalls ++ ;\n callsinfo -> npackets = 0 ;\n tapinfo -> callsinfo_list = g_list_prepend ( tapinfo -> callsinfo_list , callsinfo ) ;\n }\n callsinfo -> call_active_state = pi -> call_active_state ;\n if ( ( callsinfo -> call_state != VOIP_COMPLETED ) && ( pi -> call_state == VOIP_COMPLETED ) ) tapinfo -> completed_calls ++ ;\n if ( pi -> call_state != VOIP_NO_STATE ) callsinfo -> call_state = pi -> call_state ;\n if ( pi -> call_comment ) {\n g_free ( callsinfo -> call_comment ) ;\n callsinfo -> call_comment = g_strdup ( pi -> call_comment ) ;\n }\n callsinfo -> stop_fd = pinfo -> fd ;\n callsinfo -> stop_rel_ts = pinfo -> rel_ts ;\n ++ ( callsinfo -> npackets ) ;\n ++ ( tapinfo -> npackets ) ;\n add_to_graph ( tapinfo , pinfo , ( pi -> frame_label ) ? pi -> frame_label : \"VoIP msg\" , pi -> frame_comment , callsinfo -> call_num , & ( pinfo -> src ) , & ( pinfo -> dst ) , 1 ) ;\n tapinfo -> redraw = TRUE ;\n return 1 ;\n }", "hash": -2928324134072492299, "project": "debian", "size": 52, "target": 0, "idx": 3412}
{"code": "void t38_init_tap ( void ) {\n GString * error_string ;\n if ( have_T38_tap_listener == FALSE ) {\n error_string = register_tap_listener ( \"t38\" , & ( the_tapinfo_struct . t38_dummy ) , NULL , 0 , voip_calls_dlg_reset , T38_packet , voip_calls_dlg_draw ) ;\n if ( error_string != NULL ) {\n simple_dialog ( ESD_TYPE_ERROR , ESD_BTN_OK , \"%s\" , error_string -> str ) ;\n g_string_free ( error_string , TRUE ) ;\n exit ( 1 ) ;\n }\n have_T38_tap_listener = TRUE ;\n }\n }", "hash": -2928324134072492299, "project": "debian", "size": 12, "target": 0, "idx": 3413}
{"code": "void h245_add_to_graph ( guint32 new_frame_num ) {\n gint8 n ;\n if ( new_frame_num != h245_labels . frame_num ) return ;\n for ( n = 0 ;\n n < h245_labels . labels_count ;\n n ++ ) {\n append_to_frame_graph ( & the_tapinfo_struct , new_frame_num , h245_labels . labels [ n ] . frame_label , h245_labels . labels [ n ] . comment ) ;\n g_free ( h245_labels . labels [ n ] . frame_label ) ;\n h245_labels . labels [ n ] . frame_label = NULL ;\n g_free ( h245_labels . labels [ n ] . comment ) ;\n h245_labels . labels [ n ] . comment = NULL ;\n }\n h245_labels . frame_num = 0 ;\n h245_labels . labels_count = 0 ;\n }", "hash": -2928324134072492299, "project": "debian", "size": 15, "target": 0, "idx": 3426}
{"code": "voip_calls_tapinfo_t * voip_calls_get_info ( void ) {\n return & the_tapinfo_struct ;\n }", "hash": -2928324134072492299, "project": "debian", "size": 3, "target": 0, "idx": 3430}
{"code": "static int dissect_h245_IV8 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , 8 , 8 , FALSE , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3449}
{"code": "static int dissect_h245_MasterSlaveDeterminationReject ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MasterSlaveDeterminationReject , MasterSlaveDeterminationReject_sequence ) ;\n # line 536 \"../../asn1/h245/h245.cnf\" if ( h245_pi != NULL ) h245_pi -> msg_type = H245_MastSlvDetRjc ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 5, "target": 0, "idx": 3454}
{"code": "static int dissect_h245_VendorIdentification ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_VendorIdentification , VendorIdentification_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3461}
{"code": "static int dissect_h245_T_standardOid ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 727 \"../../asn1/h245/h245.cnf\" const gchar * standard_oid_str = NULL ;\n gef_ctx_t * gefx ;\n offset = dissect_per_object_identifier_str ( tvb , offset , actx , tree , hf_index , & standard_oid_str ) ;\n gefx = gef_ctx_get ( actx -> private_data ) ;\n if ( gefx ) gefx -> id = standard_oid_str ;\n if ( strcmp ( standard_oid_str , \"0.0.8.235.0.3.76\" ) == 0 ) {\n if ( upcoming_channel ) upcoming_channel -> srtp_flag = TRUE ;\n }\n if ( ! h245_lc_dissector && strcmp ( standard_oid_str , \"0.0.8.245.1.1.1\" ) == 0 ) h245_lc_dissector = amr_handle ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 12, "target": 0, "idx": 3473}
{"code": "static int dissect_h245_T_additionalPictureMemory ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_additionalPictureMemory , T_additionalPictureMemory_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3480}
{"code": "static int dissect_h245_H261VideoMode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_H261VideoMode , H261VideoMode_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3487}
{"code": "static int dissect_h245_T_t120SetupProcedure ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_t120SetupProcedure , T_t120SetupProcedure_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3491}
{"code": "static int dissect_h245_INTEGER_0_255 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 255U , NULL , FALSE ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3497}
{"code": "static int dissect_h245_CapabilityTableEntryNumber ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 65535U , NULL , FALSE ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3533}
{"code": "static int dissect_h245_ConferenceCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_ConferenceCapability , ConferenceCapability_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3540}
{"code": "static void dissect_OpenLogicalChannel_PDU ( tvbuff_t * tvb _U_ , packet_info * pinfo _U_ , proto_tree * tree _U_ ) {\n asn1_ctx_t asn1_ctx ;\n asn1_ctx_init ( & asn1_ctx , ASN1_ENC_PER , TRUE , pinfo ) ;\n dissect_h245_OpenLogicalChannel ( tvb , 0 , & asn1_ctx , tree , hf_h245_OpenLogicalChannel_PDU ) ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 5, "target": 0, "idx": 3557}
{"code": "static int dissect_h245_MaintenanceLoopOffCommand ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MaintenanceLoopOffCommand , MaintenanceLoopOffCommand_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3563}
{"code": "static int dissect_h245_T_t35CountryCode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 255U , & t35CountryCode , FALSE ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3564}
{"code": "static int dissect_h245_SET_SIZE_1_256_OF_CapabilityTableEntry ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_set_of ( tvb , offset , actx , tree , hf_index , ett_h245_SET_SIZE_1_256_OF_CapabilityTableEntry , SET_SIZE_1_256_OF_CapabilityTableEntry_set_of , 1 , 256 , FALSE ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3565}
{"code": "static int dissect_h245_INTEGER_1_255 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 255U , NULL , FALSE ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3568}
{"code": "static int dissect_h245_OpenLogicalChannelAck ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 218 \"../../asn1/h245/h245.cnf\" guint32 temp ;\n int p2p_dir ;\n h223_pending_olc * pend ;\n const gchar * olc_key ;\n olc_info_t * olc_req ;\n upcoming_olc = ( ! actx -> pinfo -> fd -> flags . visited ) ? wmem_new0 ( wmem_packet_scope ( ) , olc_info_t ) : NULL ;\n h223_fw_lc_num = 0 ;\n h223_rev_lc_num = 0 ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_OpenLogicalChannelAck , OpenLogicalChannelAck_sequence ) ;\n temp = h223_fw_lc_num ;\n p2p_dir = actx -> pinfo -> p2p_dir ;\n if ( actx -> pinfo -> p2p_dir == P2P_DIR_SENT ) actx -> pinfo -> p2p_dir = P2P_DIR_RECV ;\n else actx -> pinfo -> p2p_dir = P2P_DIR_SENT ;\n pend = ( h223_pending_olc * ) g_hash_table_lookup ( h223_pending_olc_reqs [ actx -> pinfo -> p2p_dir ] , GINT_TO_POINTER ( temp ) ) ;\n if ( pend ) {\n DISSECTOR_ASSERT ( ( h223_rev_lc_num && pend -> rev_channel_params ) || ( ! h223_rev_lc_num && ! pend -> rev_channel_params ) ) ;\n if ( h223_add_lc_handle ) {\n ( * h223_add_lc_handle ) ( actx -> pinfo , h223_fw_lc_num , pend -> fw_channel_params ) ;\n if ( h223_rev_lc_num ) ( * h223_add_lc_handle ) ( actx -> pinfo , h223_rev_lc_num , pend -> rev_channel_params ) ;\n }\n }\n else {\n }\n actx -> pinfo -> p2p_dir = p2p_dir ;\n if ( upcoming_olc ) {\n olc_key = gen_olc_key ( upcoming_olc -> fwd_lc_num , & actx -> pinfo -> src , & actx -> pinfo -> dst ) ;\n olc_req = ( olc_info_t * ) g_hash_table_lookup ( h245_pending_olc_reqs , olc_key ) ;\n if ( olc_req ) {\n update_unicast_addr ( & olc_req -> fwd_lc . media_addr , & upcoming_olc -> fwd_lc . media_addr ) ;\n update_unicast_addr ( & olc_req -> fwd_lc . media_control_addr , & upcoming_olc -> fwd_lc . media_control_addr ) ;\n update_unicast_addr ( & olc_req -> rev_lc . media_addr , & upcoming_olc -> rev_lc . media_addr ) ;\n update_unicast_addr ( & olc_req -> rev_lc . media_control_addr , & upcoming_olc -> rev_lc . media_control_addr ) ;\n h245_setup_channels ( actx -> pinfo , & olc_req -> fwd_lc ) ;\n h245_setup_channels ( actx -> pinfo , & olc_req -> rev_lc ) ;\n g_hash_table_remove ( h245_pending_olc_reqs , olc_key ) ;\n }\n else {\n h245_setup_channels ( actx -> pinfo , & upcoming_olc -> fwd_lc ) ;\n }\n }\n upcoming_olc = NULL ;\n if ( h245_pi != NULL ) h245_pi -> msg_type = H245_OpenLogChnAck ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 45, "target": 0, "idx": 3569}
{"code": "static int dissect_h245_T_al3_sendBufferSize ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 332 \"../../asn1/h245/h245.cnf\" guint32 value ;\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 16777215U , & value , FALSE ) ;\n if ( h223_lc_params_temp && h223_lc_params_temp -> al_params ) ( ( h223_al3_params * ) h223_lc_params_temp -> al_params ) -> send_buffer_size = value & 0xfffff ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 6, "target": 0, "idx": 3582}
{"code": "static int dissect_h245_IS11172AudioMode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_IS11172AudioMode , IS11172AudioMode_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3583}
{"code": "static int dissect_h245_OpenLogicalChannelConfirm ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_OpenLogicalChannelConfirm , OpenLogicalChannelConfirm_sequence ) ;\n # line 560 \"../../asn1/h245/h245.cnf\" if ( h245_pi != NULL ) h245_pi -> msg_type = H245_OpenLogChnCnf ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 5, "target": 0, "idx": 3588}
{"code": "static int dissect_h245_ArqType ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_ArqType , ArqType_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3598}
{"code": "static int dissect_h245_T_containedThreads ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h245_T_containedThreads , T_containedThreads_sequence_of , 1 , 256 , FALSE ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3604}
{"code": "static int dissect_h245_T_mode_rfc2733sameport ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_mode_rfc2733sameport , T_mode_rfc2733sameport_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3614}
{"code": "static int dissect_h245_EncryptionUpdateDirection ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_EncryptionUpdateDirection , EncryptionUpdateDirection_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3615}
{"code": "static int dissect_h245_SET_SIZE_1_15_OF_MultiplexTableEntryNumber ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_set_of ( tvb , offset , actx , tree , hf_index , ett_h245_SET_SIZE_1_15_OF_MultiplexTableEntryNumber , SET_SIZE_1_15_OF_MultiplexTableEntryNumber_set_of , 1 , 15 , FALSE ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3642}
{"code": "static int dissect_h245_T_cLC_source ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_cLC_source , T_cLC_source_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3660}
{"code": "static int dissect_h245_T_collapsing_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 671 \"../../asn1/h245/h245.cnf\" gef_ctx_t * parent_gefx ;\n parent_gefx = gef_ctx_get ( actx -> private_data ) ;\n actx -> private_data = gef_ctx_alloc ( parent_gefx , \"collapsing\" ) ;\n offset = dissect_h245_GenericParameter ( tvb , offset , actx , tree , hf_index ) ;\n # line 676 \"../../asn1/h245/h245.cnf\" actx -> private_data = parent_gefx ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 8, "target": 0, "idx": 3674}
{"code": "static int dissect_h245_NewATMVCIndication ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_NewATMVCIndication , NewATMVCIndication_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3675}
{"code": "static int dissect_h245_T_h233EncryptionReceiveCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_h233EncryptionReceiveCapability , T_h233EncryptionReceiveCapability_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3682}
{"code": "static int dissect_h245_ServicePriority ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_ServicePriority , ServicePriority_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3702}
{"code": "static int dissect_h245_TerminalCapabilitySetAck ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_TerminalCapabilitySetAck , TerminalCapabilitySetAck_sequence ) ;\n # line 566 \"../../asn1/h245/h245.cnf\" if ( h245_pi != NULL ) h245_pi -> msg_type = H245_TermCapSetAck ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 5, "target": 0, "idx": 3735}
{"code": "static int dissect_h245_SEQUENCE_OF_GenericInformation ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h245_SEQUENCE_OF_GenericInformation , SEQUENCE_OF_GenericInformation_sequence_of ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3737}
{"code": "static int dissect_h245_DialingInformationNumber ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_DialingInformationNumber , DialingInformationNumber_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3738}
{"code": "static int dissect_h245_Me_type ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_Me_type , Me_type_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3750}
{"code": "static int dissect_h245_ConferenceCommand ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_ConferenceCommand , ConferenceCommand_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3757}
{"code": "static int dissect_h245_T_t35Extension ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 255U , & t35Extension , FALSE ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3761}
{"code": "static int dissect_h245_T_iPAddress ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_iPAddress , T_iPAddress_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3762}
{"code": "static int dissect_h245_SubstituteConferenceIDCommand ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_SubstituteConferenceIDCommand , SubstituteConferenceIDCommand_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3796}
{"code": "static int dissect_h245_OLC_reverseLogicalChannelParameters ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 194 \"../../asn1/h245/h245.cnf\" upcoming_channel = ( upcoming_olc ) ? & upcoming_olc -> rev_lc : NULL ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_OLC_reverseLogicalChannelParameters , OLC_reverseLogicalChannelParameters_sequence ) ;\n if ( upcoming_channel && codec_type ) {\n g_strlcpy ( upcoming_channel -> data_type_str , codec_type , sizeof ( upcoming_channel -> data_type_str ) ) ;\n }\n upcoming_channel = NULL ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 9, "target": 0, "idx": 3802}
{"code": "static int dissect_h245_RefPictureSelection ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_RefPictureSelection , RefPictureSelection_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3804}
{"code": "static int dissect_h245_T_isdnOptions ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_isdnOptions , T_isdnOptions_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3835}
{"code": "static int dissect_h245_T_mobileMultilinkFrameCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_mobileMultilinkFrameCapability , T_mobileMultilinkFrameCapability_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3839}
{"code": "static int dissect_h245_T_mediaChannel ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 896 \"../../asn1/h245/h245.cnf\" if ( upcoming_channel ) upcoming_channel -> upcoming_addr = & upcoming_channel -> media_addr ;\n offset = dissect_h245_TransportAddress ( tvb , offset , actx , tree , hf_index ) ;\n # line 900 \"../../asn1/h245/h245.cnf\" if ( upcoming_channel ) upcoming_channel -> upcoming_addr = NULL ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 6, "target": 0, "idx": 3854}
{"code": "static int dissect_h245_T_sendThisSourceResponse ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_sendThisSourceResponse , T_sendThisSourceResponse_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3865}
{"code": "static int dissect_h245_MultiplexElement ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 82 \"../../asn1/h245/h245.cnf\" h223_mux_element * me = wmem_new ( wmem_file_scope ( ) , h223_mux_element ) ;\n h223_me -> next = me ;\n h223_me = me ;\n h223_me -> next = NULL ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MultiplexElement , MultiplexElement_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 8, "target": 0, "idx": 3884}
{"code": "static int dissect_h245_T_h223_al_type_al3 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 314 \"../../asn1/h245/h245.cnf\" if ( h223_lc_params_temp ) {\n h223_lc_params_temp -> al_type = al3 ;\n h223_lc_params_temp -> al_params = wmem_new ( wmem_file_scope ( ) , h223_al3_params ) ;\n }\n offset = dissect_h245_Al3 ( tvb , offset , actx , tree , hf_index ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 8, "target": 0, "idx": 3886}
{"code": "static int dissect_h245_T_reason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_reason , T_reason_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3901}
{"code": "static int dissect_h245_T_mediaControlChannel ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 914 \"../../asn1/h245/h245.cnf\" if ( upcoming_channel ) upcoming_channel -> upcoming_addr = & upcoming_channel -> media_control_addr ;\n offset = dissect_h245_TransportAddress ( tvb , offset , actx , tree , hf_index ) ;\n # line 918 \"../../asn1/h245/h245.cnf\" if ( upcoming_channel ) upcoming_channel -> upcoming_addr = NULL ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 6, "target": 0, "idx": 3931}
{"code": "static int dissect_h245_MultiplexEntrySendReject ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MultiplexEntrySendReject , MultiplexEntrySendReject_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3936}
{"code": "static int dissect_h245_TsapIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 877 \"../../asn1/h245/h245.cnf\" guint32 tsapIdentifier ;\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 65535U , & tsapIdentifier , FALSE ) ;\n if ( upcoming_channel && upcoming_channel -> upcoming_addr ) {\n upcoming_channel -> upcoming_addr -> port = tsapIdentifier ;\n }\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 8, "target": 0, "idx": 3937}
{"code": "static int dissect_h245_RequestMultiplexEntryRelease ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_RequestMultiplexEntryRelease , RequestMultiplexEntryRelease_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3940}
{"code": "static int dissect_h245_FEC_mode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_FEC_mode , FEC_mode_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3951}
{"code": "static int dissect_h245_T_pixelAspectInformation ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_pixelAspectInformation , T_pixelAspectInformation_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3952}
{"code": "static int dissect_h245_Ack_mediaChannel ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 887 \"../../asn1/h245/h245.cnf\" if ( upcoming_channel ) upcoming_channel -> upcoming_addr = & upcoming_channel -> media_addr ;\n offset = dissect_h245_TransportAddress ( tvb , offset , actx , tree , hf_index ) ;\n # line 891 \"../../asn1/h245/h245.cnf\" if ( upcoming_channel ) upcoming_channel -> upcoming_addr = NULL ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 6, "target": 0, "idx": 3971}
{"code": "static int dissect_h245_T_t84Restricted ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_t84Restricted , T_t84Restricted_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3974}
{"code": "static int dissect_h245_AudioCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 487 \"../../asn1/h245/h245.cnf\" gint32 value ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_AudioCapability , AudioCapability_choice , & value ) ;\n codec_type = val_to_str ( value , h245_AudioCapability_short_vals , \"<unknown>\" ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 6, "target": 0, "idx": 3981}
{"code": "static int dissect_h245_T_payloadDescriptor ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_payloadDescriptor , T_payloadDescriptor_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3996}
{"code": "static int dissect_h245_INTEGER_2_255 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 2U , 255U , NULL , FALSE ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 3998}
{"code": "static int dissect_h245_INTEGER_1_14 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 14U , NULL , FALSE ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 4005}
{"code": "static int dissect_h245_INTEGER_27_78 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 27U , 78U , NULL , FALSE ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 4011}
{"code": "static int dissect_h245_AL2HeaderFEC ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_AL2HeaderFEC , AL2HeaderFEC_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 4013}
{"code": "static int dissect_h245_T_terminalIDResponse ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_terminalIDResponse , T_terminalIDResponse_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 4017}
{"code": "static int dissect_h245_T_t84 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_t84 , T_t84_sequence ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 4036}
{"code": "static int dissect_h245_Clc_reason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_Clc_reason , Clc_reason_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 4038}
{"code": "static int dissect_h245_T_t38FaxUdpEC ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_t38FaxUdpEC , T_t38FaxUdpEC_choice , NULL ) ;\n return offset ;\n }", "hash": 7092216800726729686, "project": "debian", "size": 4, "target": 0, "idx": 4049}
{"code": "static void _slurm_rpc_dump_jobs_user ( slurm_msg_t * msg ) {\n DEF_TIMERS ;\n char * dump ;\n int dump_size ;\n slurm_msg_t response_msg ;\n job_user_id_msg_t * job_info_request_msg = ( job_user_id_msg_t * ) msg -> data ;\n slurmctld_lock_t job_read_lock = {\n READ_LOCK , READ_LOCK , NO_LOCK , READ_LOCK , READ_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n START_TIMER ;\n debug3 ( \"Processing RPC: REQUEST_JOB_USER_INFO from uid=%d\" , uid ) ;\n lock_slurmctld ( job_read_lock ) ;\n pack_all_jobs ( & dump , & dump_size , job_info_request_msg -> show_flags , uid , job_info_request_msg -> user_id , msg -> protocol_version ) ;\n unlock_slurmctld ( job_read_lock ) ;\n END_TIMER2 ( \"_slurm_rpc_dump_job_user\" ) ;\n # if 0 info ( \"_slurm_rpc_dump_user_jobs, size=%d %s\" , dump_size , TIME_STR ) ;\n # endif slurm_msg_t_init ( & response_msg ) ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n response_msg . address = msg -> address ;\n response_msg . conn = msg -> conn ;\n response_msg . msg_type = RESPONSE_JOB_INFO ;\n response_msg . data = dump ;\n response_msg . data_size = dump_size ;\n slurm_send_node_msg ( msg -> conn_fd , & response_msg ) ;\n xfree ( dump ) ;\n }", "hash": -1672864273235910388, "project": "debian", "size": 28, "target": 0, "idx": 4070}
{"code": "inline static void _slurm_rpc_set_debug_flags ( slurm_msg_t * msg ) {\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n slurmctld_lock_t config_write_lock = {\n WRITE_LOCK , READ_LOCK , READ_LOCK , READ_LOCK , READ_LOCK }\n ;\n set_debug_flags_msg_t * request_msg = ( set_debug_flags_msg_t * ) msg -> data ;\n uint64_t debug_flags ;\n char * flag_string ;\n debug2 ( \"Processing RPC: REQUEST_SET_DEBUG_FLAGS from uid=%d\" , uid ) ;\n if ( ! validate_super_user ( uid ) ) {\n error ( \"set debug flags request from non-super user uid=%d\" , uid ) ;\n slurm_send_rc_msg ( msg , EACCES ) ;\n return ;\n }\n lock_slurmctld ( config_write_lock ) ;\n debug_flags = slurmctld_conf . debug_flags ;\n debug_flags &= ( ~ request_msg -> debug_flags_minus ) ;\n debug_flags |= request_msg -> debug_flags_plus ;\n slurm_set_debug_flags ( debug_flags ) ;\n slurmctld_conf . last_update = time ( NULL ) ;\n log_set_debug_flags ( ) ;\n gs_reconfig ( ) ;\n gres_plugin_reconfig ( NULL ) ;\n acct_storage_g_reconfig ( acct_db_conn , 0 ) ;\n priority_g_reconfig ( false ) ;\n select_g_reconfigure ( ) ;\n ( void ) slurm_sched_g_reconfig ( ) ;\n ( void ) switch_g_reconfig ( ) ;\n unlock_slurmctld ( config_write_lock ) ;\n flag_string = debug_flags2str ( debug_flags ) ;\n info ( \"Set DebugFlags to %s\" , flag_string ? flag_string : \"none\" ) ;\n xfree ( flag_string ) ;\n slurm_send_rc_msg ( msg , SLURM_SUCCESS ) ;\n }", "hash": -1672864273235910388, "project": "debian", "size": 34, "target": 0, "idx": 4077}
{"code": "static void _pack_rpc_stats ( int resp , char * * buffer_ptr , int * buffer_size , uint16_t protocol_version ) {\n uint32_t i ;\n Buf buffer ;\n slurm_mutex_lock ( & rpc_mutex ) ;\n buffer = create_buf ( * buffer_ptr , * buffer_size ) ;\n set_buf_offset ( buffer , * buffer_size ) ;\n for ( i = 0 ;\n i < rpc_type_size ;\n i ++ ) {\n if ( rpc_type_id [ i ] == 0 ) break ;\n }\n pack32 ( i , buffer ) ;\n pack16_array ( rpc_type_id , i , buffer ) ;\n pack32_array ( rpc_type_cnt , i , buffer ) ;\n pack64_array ( rpc_type_time , i , buffer ) ;\n for ( i = 1 ;\n i < rpc_user_size ;\n i ++ ) {\n if ( rpc_user_id [ i ] == 0 ) break ;\n }\n pack32 ( i , buffer ) ;\n pack32_array ( rpc_user_id , i , buffer ) ;\n pack32_array ( rpc_user_cnt , i , buffer ) ;\n pack64_array ( rpc_user_time , i , buffer ) ;\n slurm_mutex_unlock ( & rpc_mutex ) ;\n * buffer_size = get_buf_offset ( buffer ) ;\n buffer_ptr [ 0 ] = xfer_buf_data ( buffer ) ;\n }", "hash": -1672864273235910388, "project": "debian", "size": 28, "target": 0, "idx": 4087}
{"code": "static int _route_msg_to_origin ( slurm_msg_t * msg , char * src_job_id_str , uint32_t src_job_id , uid_t uid ) {\n xassert ( msg ) ;\n if ( ! msg -> conn && fed_mgr_fed_rec ) {\n uint32_t job_id , origin_id ;\n if ( src_job_id_str ) job_id = strtol ( src_job_id_str , NULL , 10 ) ;\n else job_id = src_job_id ;\n origin_id = fed_mgr_get_cluster_id ( job_id ) ;\n if ( origin_id && ( origin_id != fed_mgr_cluster_rec -> fed . id ) ) {\n slurmdb_cluster_rec_t * dst = fed_mgr_get_cluster_by_id ( origin_id ) ;\n if ( ! dst ) {\n error ( \"couldn't find cluster by cluster id %d\" , origin_id ) ;\n slurm_send_rc_msg ( msg , SLURM_ERROR ) ;\n }\n else {\n slurm_send_reroute_msg ( msg , dst ) ;\n info ( \"%s: %s job %d uid %d routed to %s\" , __func__ , rpc_num2string ( msg -> msg_type ) , job_id , uid , dst -> name ) ;\n }\n return SLURM_SUCCESS ;\n }\n }\n return SLURM_ERROR ;\n }", "hash": -1672864273235910388, "project": "debian", "size": 22, "target": 0, "idx": 4089}
{"code": "static void _slurm_rpc_dump_jobs ( slurm_msg_t * msg ) {\n DEF_TIMERS ;\n char * dump ;\n int dump_size ;\n slurm_msg_t response_msg ;\n job_info_request_msg_t * job_info_request_msg = ( job_info_request_msg_t * ) msg -> data ;\n slurmctld_lock_t job_read_lock = {\n READ_LOCK , READ_LOCK , NO_LOCK , READ_LOCK , READ_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n START_TIMER ;\n debug3 ( \"Processing RPC: REQUEST_JOB_INFO from uid=%d\" , uid ) ;\n lock_slurmctld ( job_read_lock ) ;\n if ( ( job_info_request_msg -> last_update - 1 ) >= last_job_update ) {\n unlock_slurmctld ( job_read_lock ) ;\n debug3 ( \"_slurm_rpc_dump_jobs, no change\" ) ;\n slurm_send_rc_msg ( msg , SLURM_NO_CHANGE_IN_DATA ) ;\n }\n else {\n if ( job_info_request_msg -> job_ids ) {\n pack_spec_jobs ( & dump , & dump_size , job_info_request_msg -> job_ids , job_info_request_msg -> show_flags , uid , NO_VAL , msg -> protocol_version ) ;\n }\n else {\n pack_all_jobs ( & dump , & dump_size , job_info_request_msg -> show_flags , uid , NO_VAL , msg -> protocol_version ) ;\n }\n unlock_slurmctld ( job_read_lock ) ;\n END_TIMER2 ( \"_slurm_rpc_dump_jobs\" ) ;\n # if 0 info ( \"_slurm_rpc_dump_jobs, size=%d %s\" , dump_size , TIME_STR ) ;\n # endif slurm_msg_t_init ( & response_msg ) ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n response_msg . address = msg -> address ;\n response_msg . conn = msg -> conn ;\n response_msg . msg_type = RESPONSE_JOB_INFO ;\n response_msg . data = dump ;\n response_msg . data_size = dump_size ;\n slurm_send_node_msg ( msg -> conn_fd , & response_msg ) ;\n xfree ( dump ) ;\n }\n }", "hash": -1672864273235910388, "project": "debian", "size": 40, "target": 0, "idx": 4094}
{"code": "inline static void _slurm_rpc_job_notify ( slurm_msg_t * msg ) {\n int error_code ;\n slurmctld_lock_t job_read_lock = {\n NO_LOCK , READ_LOCK , NO_LOCK , NO_LOCK , READ_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n job_notify_msg_t * notify_msg = ( job_notify_msg_t * ) msg -> data ;\n struct job_record * job_ptr ;\n DEF_TIMERS ;\n START_TIMER ;\n debug ( \"Processing RPC: REQUEST_JOB_NOTIFY from uid=%d\" , uid ) ;\n lock_slurmctld ( job_read_lock ) ;\n job_ptr = find_job_record ( notify_msg -> job_id ) ;\n if ( ! job_ptr && ! _route_msg_to_origin ( msg , NULL , notify_msg -> job_id , uid ) ) {\n unlock_slurmctld ( job_read_lock ) ;\n return ;\n }\n if ( ! job_ptr ) error_code = ESLURM_INVALID_JOB_ID ;\n else if ( job_ptr -> batch_flag && fed_mgr_cluster_rec && job_ptr -> fed_details && fed_mgr_is_origin_job ( job_ptr ) && IS_JOB_REVOKED ( job_ptr ) && job_ptr -> fed_details -> cluster_lock && ( job_ptr -> fed_details -> cluster_lock != fed_mgr_cluster_rec -> fed . id ) ) {\n slurmdb_cluster_rec_t * dst = fed_mgr_get_cluster_by_id ( job_ptr -> fed_details -> cluster_lock ) ;\n if ( dst ) {\n slurm_send_reroute_msg ( msg , dst ) ;\n info ( \"%s: %s job %d uid %d routed to %s\" , __func__ , rpc_num2string ( msg -> msg_type ) , job_ptr -> job_id , uid , dst -> name ) ;\n unlock_slurmctld ( job_read_lock ) ;\n END_TIMER2 ( \"_slurm_rpc_job_notify\" ) ;\n return ;\n }\n error ( \"couldn't find cluster by cluster id %d\" , job_ptr -> fed_details -> cluster_lock ) ;\n error_code = ESLURM_INVALID_CLUSTER_NAME ;\n }\n else if ( ( job_ptr -> user_id == uid ) || validate_slurm_user ( uid ) ) error_code = srun_user_message ( job_ptr , notify_msg -> message ) ;\n else {\n error_code = ESLURM_USER_ID_MISSING ;\n error ( \"Security violation, REQUEST_JOB_NOTIFY RPC \" \"from uid=%d for jobid %u owner %d\" , uid , notify_msg -> job_id , job_ptr -> user_id ) ;\n }\n unlock_slurmctld ( job_read_lock ) ;\n END_TIMER2 ( \"_slurm_rpc_job_notify\" ) ;\n slurm_send_rc_msg ( msg , error_code ) ;\n }", "hash": -1672864273235910388, "project": "debian", "size": 39, "target": 0, "idx": 4108}
{"code": "inline static void _slurm_rpc_requeue ( slurm_msg_t * msg ) {\n int error_code = SLURM_SUCCESS ;\n DEF_TIMERS ;\n requeue_msg_t * req_ptr = ( requeue_msg_t * ) msg -> data ;\n slurmctld_lock_t fed_read_lock = {\n NO_LOCK , NO_LOCK , NO_LOCK , NO_LOCK , READ_LOCK }\n ;\n slurmctld_lock_t job_write_lock = {\n NO_LOCK , WRITE_LOCK , WRITE_LOCK , NO_LOCK , READ_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n lock_slurmctld ( fed_read_lock ) ;\n if ( ! _route_msg_to_origin ( msg , req_ptr -> job_id_str , req_ptr -> job_id , uid ) ) {\n unlock_slurmctld ( fed_read_lock ) ;\n return ;\n }\n unlock_slurmctld ( fed_read_lock ) ;\n START_TIMER ;\n info ( \"%s: Processing RPC: REQUEST_JOB_REQUEUE from uid=%d\" , __func__ , uid ) ;\n lock_slurmctld ( job_write_lock ) ;\n if ( req_ptr -> job_id_str ) {\n error_code = job_requeue2 ( uid , req_ptr , msg , false ) ;\n }\n else {\n error_code = job_requeue ( uid , req_ptr -> job_id , msg , false , req_ptr -> state ) ;\n }\n unlock_slurmctld ( job_write_lock ) ;\n END_TIMER2 ( \"_slurm_rpc_requeue\" ) ;\n if ( error_code ) {\n if ( ! req_ptr -> job_id_str ) xstrfmtcat ( req_ptr -> job_id_str , \"%u\" , req_ptr -> job_id ) ;\n info ( \"%s: %s: %s\" , __func__ , req_ptr -> job_id_str , slurm_strerror ( error_code ) ) ;\n }\n schedule_job_save ( ) ;\n }", "hash": -1672864273235910388, "project": "debian", "size": 34, "target": 0, "idx": 4111}
{"code": "static void _slurm_rpc_reconfigure_controller ( slurm_msg_t * msg ) {\n int error_code = SLURM_SUCCESS ;\n static bool in_progress = false ;\n DEF_TIMERS ;\n slurmctld_lock_t config_write_lock = {\n WRITE_LOCK , WRITE_LOCK , WRITE_LOCK , WRITE_LOCK , NO_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n START_TIMER ;\n info ( \"Processing RPC: REQUEST_RECONFIGURE from uid=%d\" , uid ) ;\n if ( ! validate_super_user ( uid ) ) {\n error ( \"Security violation, RECONFIGURE RPC from uid=%d\" , uid ) ;\n error_code = ESLURM_USER_ID_MISSING ;\n }\n if ( in_progress || slurmctld_config . shutdown_time ) error_code = EINPROGRESS ;\n if ( error_code == SLURM_SUCCESS ) {\n debug ( \"sched: begin reconfiguration\" ) ;\n lock_slurmctld ( config_write_lock ) ;\n in_progress = true ;\n error_code = read_slurm_conf ( 1 , true ) ;\n if ( error_code == SLURM_SUCCESS ) {\n _update_cred_key ( ) ;\n set_slurmctld_state_loc ( ) ;\n msg_to_slurmd ( REQUEST_RECONFIGURE ) ;\n }\n in_progress = false ;\n gs_reconfig ( ) ;\n unlock_slurmctld ( config_write_lock ) ;\n assoc_mgr_set_missing_uids ( ) ;\n start_power_mgr ( & slurmctld_config . thread_id_power ) ;\n trigger_reconfig ( ) ;\n }\n END_TIMER2 ( \"_slurm_rpc_reconfigure_controller\" ) ;\n if ( error_code ) {\n error ( \"_slurm_rpc_reconfigure_controller: %s\" , slurm_strerror ( error_code ) ) ;\n slurm_send_rc_msg ( msg , error_code ) ;\n }\n else {\n info ( \"_slurm_rpc_reconfigure_controller: completed %s\" , TIME_STR ) ;\n slurm_send_rc_msg ( msg , SLURM_SUCCESS ) ;\n acct_storage_g_reconfig ( acct_db_conn , 0 ) ;\n priority_g_reconfig ( false ) ;\n save_all_state ( ) ;\n queue_job_scheduler ( ) ;\n }\n }", "hash": -1672864273235910388, "project": "debian", "size": 46, "target": 0, "idx": 4151}
{"code": "static Buf _build_rc_buf ( int rc , uint16_t rpc_version ) {\n Buf buf = NULL ;\n slurm_msg_t msg ;\n return_code_msg_t data ;\n data . return_code = rc ;\n slurm_msg_t_init ( & msg ) ;\n msg . msg_type = RESPONSE_SLURM_RC ;\n msg . data = & data ;\n buf = init_buf ( 128 ) ;\n pack16 ( msg . msg_type , buf ) ;\n if ( pack_msg ( & msg , buf ) != SLURM_SUCCESS ) FREE_NULL_BUFFER ( buf ) ;\n return buf ;\n }", "hash": -1672864273235910388, "project": "debian", "size": 13, "target": 0, "idx": 4153}
{"code": "static void _slurm_rpc_step_complete ( slurm_msg_t * msg , bool running_composite ) {\n static int active_rpc_cnt = 0 ;\n int error_code = SLURM_SUCCESS , rc , rem ;\n uint32_t step_rc ;\n DEF_TIMERS ;\n step_complete_msg_t * req = ( step_complete_msg_t * ) msg -> data ;\n slurmctld_lock_t job_write_lock = {\n NO_LOCK , WRITE_LOCK , WRITE_LOCK , NO_LOCK , READ_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n bool dump_job = false ;\n START_TIMER ;\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_STEPS ) info ( \"Processing RPC: REQUEST_STEP_COMPLETE for %u.%u \" \"nodes %u-%u rc=%u uid=%d\" , req -> job_id , req -> job_step_id , req -> range_first , req -> range_last , req -> step_rc , uid ) ;\n if ( ! running_composite ) {\n _throttle_start ( & active_rpc_cnt ) ;\n lock_slurmctld ( job_write_lock ) ;\n }\n rc = step_partial_comp ( req , uid , & rem , & step_rc ) ;\n if ( rc || rem ) {\n if ( ! running_composite ) {\n unlock_slurmctld ( job_write_lock ) ;\n _throttle_fini ( & active_rpc_cnt ) ;\n }\n slurm_send_rc_msg ( msg , rc ) ;\n if ( ! rc ) schedule_job_save ( ) ;\n return ;\n }\n if ( req -> job_step_id == SLURM_BATCH_SCRIPT ) {\n error_code = job_complete ( req -> job_id , uid , false , false , step_rc ) ;\n if ( ! running_composite ) {\n unlock_slurmctld ( job_write_lock ) ;\n _throttle_fini ( & active_rpc_cnt ) ;\n }\n END_TIMER2 ( \"_slurm_rpc_step_complete\" ) ;\n if ( error_code ) {\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_STEPS ) info ( \"%s JobId=%u: %s\" , __func__ , req -> job_id , slurm_strerror ( error_code ) ) ;\n slurm_send_rc_msg ( msg , error_code ) ;\n }\n else {\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_STEPS ) info ( \"sched: %s JobId=%u: %s\" , __func__ , req -> job_id , TIME_STR ) ;\n slurm_send_rc_msg ( msg , SLURM_SUCCESS ) ;\n dump_job = true ;\n }\n }\n else {\n error_code = job_step_complete ( req -> job_id , req -> job_step_id , uid , false , step_rc ) ;\n if ( ! running_composite ) {\n unlock_slurmctld ( job_write_lock ) ;\n _throttle_fini ( & active_rpc_cnt ) ;\n }\n END_TIMER2 ( \"_slurm_rpc_step_complete\" ) ;\n if ( error_code ) {\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_STEPS ) info ( \"%s 1 StepId=%u.%u %s\" , __func__ , req -> job_id , req -> job_step_id , slurm_strerror ( error_code ) ) ;\n slurm_send_rc_msg ( msg , error_code ) ;\n }\n else {\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_STEPS ) info ( \"sched: %s StepId=%u.%u %s\" , __func__ , req -> job_id , req -> job_step_id , TIME_STR ) ;\n slurm_send_rc_msg ( msg , SLURM_SUCCESS ) ;\n dump_job = true ;\n }\n }\n if ( dump_job ) ( void ) schedule_job_save ( ) ;\n }", "hash": -1672864273235910388, "project": "debian", "size": 63, "target": 0, "idx": 4157}
{"code": "static void _slurm_rpc_end_time ( slurm_msg_t * msg ) {\n DEF_TIMERS ;\n job_alloc_info_msg_t * time_req_msg = ( job_alloc_info_msg_t * ) msg -> data ;\n srun_timeout_msg_t timeout_msg ;\n slurm_msg_t response_msg ;\n int rc ;\n slurmctld_lock_t job_read_lock = {\n NO_LOCK , READ_LOCK , NO_LOCK , NO_LOCK , NO_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n START_TIMER ;\n debug2 ( \"Processing RPC: REQUEST_JOB_END_TIME from uid=%d\" , uid ) ;\n lock_slurmctld ( job_read_lock ) ;\n rc = job_end_time ( time_req_msg , & timeout_msg ) ;\n unlock_slurmctld ( job_read_lock ) ;\n END_TIMER2 ( \"_slurm_rpc_end_time\" ) ;\n if ( rc != SLURM_SUCCESS ) {\n slurm_send_rc_msg ( msg , rc ) ;\n }\n else {\n slurm_msg_t_init ( & response_msg ) ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n response_msg . address = msg -> address ;\n response_msg . conn = msg -> conn ;\n response_msg . msg_type = SRUN_TIMEOUT ;\n response_msg . data = & timeout_msg ;\n slurm_send_node_msg ( msg -> conn_fd , & response_msg ) ;\n }\n debug2 ( \"_slurm_rpc_end_time jobid=%u %s\" , time_req_msg -> job_id , TIME_STR ) ;\n }", "hash": -1672864273235910388, "project": "debian", "size": 31, "target": 0, "idx": 4162}
{"code": "static void main_get_appheader_params ( main_file * file , char * * parsed , int output , const char * type , main_file * other ) {\n if ( file -> filename == NULL && ! ( output && option_stdout ) && strcmp ( parsed [ 0 ] , \"-\" ) != 0 ) {\n file -> filename = parsed [ 0 ] ;\n if ( other -> filename != NULL ) {\n const char * last_slash = strrchr ( other -> filename , '/' ) ;\n if ( last_slash != NULL ) {\n usize_t dlen = ( usize_t ) ( last_slash - other -> filename ) ;\n XD3_ASSERT ( file -> filename_copy == NULL ) ;\n file -> filename_copy = ( char * ) main_malloc ( dlen + 2 + ( usize_t ) strlen ( file -> filename ) ) ;\n strncpy ( file -> filename_copy , other -> filename , dlen ) ;\n file -> filename_copy [ dlen ] = '/' ;\n strcpy ( file -> filename_copy + dlen + 1 , parsed [ 0 ] ) ;\n file -> filename = file -> filename_copy ;\n }\n }\n if ( ! option_quiet ) {\n XPR ( NT \"using default %s filename: %s\\n\" , type , file -> filename ) ;\n }\n }\n if ( file -> compressor == NULL && * parsed [ 1 ] != 0 ) {\n file -> flags |= RD_DECOMPSET ;\n file -> compressor = main_get_compressor ( parsed [ 1 ] ) ;\n }\n }", "hash": 914926989019402478, "project": "debian", "size": 24, "target": 0, "idx": 4196}
{"code": "int main_file_isopen ( main_file * xfile ) {\n # if XD3_STDIO return xfile -> file != NULL ;\n # elif XD3_POSIX return xfile -> file != - 1 ;\n # elif XD3_WIN32 return xfile -> file != INVALID_HANDLE_VALUE ;\n # endif }", "hash": 914926989019402478, "project": "debian", "size": 5, "target": 0, "idx": 4202}
{"code": "static int main_external_compression_finish ( void ) {\n int i ;\n int ret ;\n for ( i = 0 ;\n i < num_subprocs ;\n i += 1 ) {\n if ( ! ext_subprocs [ i ] ) {\n continue ;\n }\n if ( ( ret = main_waitpid_check ( ext_subprocs [ i ] ) ) ) {\n return ret ;\n }\n ext_subprocs [ i ] = 0 ;\n }\n return 0 ;\n }", "hash": 914926989019402478, "project": "debian", "size": 16, "target": 0, "idx": 4209}
{"code": "static void reset_defaults ( void ) {\n option_stdout = 0 ;\n option_force = 0 ;\n option_verbose = DEFAULT_VERBOSE ;\n option_quiet = 0 ;\n option_appheader = NULL ;\n option_use_secondary = 0 ;\n option_secondary = NULL ;\n option_use_altcodetable = 0 ;\n option_smatch_config = NULL ;\n option_no_compress = 0 ;\n option_no_output = 0 ;\n option_source_filename = NULL ;\n program_name = NULL ;\n appheader_used = NULL ;\n main_bdata = NULL ;\n main_bsize = 0 ;\n allow_fake_source = 0 ;\n option_smatch_config = NULL ;\n main_lru_reset ( ) ;\n option_use_appheader = 1 ;\n option_use_checksum = 1 ;\n # if EXTERNAL_COMPRESSION option_force2 = 0 ;\n option_decompress_inputs = 1 ;\n option_recompress_outputs = 1 ;\n num_subprocs = 0 ;\n # endif # if VCDIFF_TOOLS option_print_cpymode = 1 ;\n # endif option_level = XD3_DEFAULT_LEVEL ;\n option_iopt_size = XD3_DEFAULT_IOPT_SIZE ;\n option_winsize = XD3_DEFAULT_WINSIZE ;\n option_srcwinsz = XD3_DEFAULT_SRCWINSZ ;\n option_sprevsz = XD3_DEFAULT_SPREVSZ ;\n }", "hash": 914926989019402478, "project": "debian", "size": 33, "target": 0, "idx": 4217}
{"code": "static int main_config ( void ) {\n main_version ( ) ;\n XPR ( NTR \"EXTERNAL_COMPRESSION=%d\\n\" , EXTERNAL_COMPRESSION ) ;\n XPR ( NTR \"GENERIC_ENCODE_TABLES=%d\\n\" , GENERIC_ENCODE_TABLES ) ;\n XPR ( NTR \"GENERIC_ENCODE_TABLES_COMPUTE=%d\\n\" , GENERIC_ENCODE_TABLES_COMPUTE ) ;\n XPR ( NTR \"REGRESSION_TEST=%d\\n\" , REGRESSION_TEST ) ;\n XPR ( NTR \"SECONDARY_DJW=%d\\n\" , SECONDARY_DJW ) ;\n XPR ( NTR \"SECONDARY_FGK=%d\\n\" , SECONDARY_FGK ) ;\n XPR ( NTR \"SECONDARY_LZMA=%d\\n\" , SECONDARY_LZMA ) ;\n XPR ( NTR \"UNALIGNED_OK=%d\\n\" , UNALIGNED_OK ) ;\n XPR ( NTR \"VCDIFF_TOOLS=%d\\n\" , VCDIFF_TOOLS ) ;\n XPR ( NTR \"XD3_ALLOCSIZE=%d\\n\" , XD3_ALLOCSIZE ) ;\n XPR ( NTR \"XD3_DEBUG=%d\\n\" , XD3_DEBUG ) ;\n XPR ( NTR \"XD3_ENCODER=%d\\n\" , XD3_ENCODER ) ;\n XPR ( NTR \"XD3_POSIX=%d\\n\" , XD3_POSIX ) ;\n XPR ( NTR \"XD3_STDIO=%d\\n\" , XD3_STDIO ) ;\n XPR ( NTR \"XD3_WIN32=%d\\n\" , XD3_WIN32 ) ;\n XPR ( NTR \"XD3_USE_LARGEFILE64=%d\\n\" , XD3_USE_LARGEFILE64 ) ;\n XPR ( NTR \"XD3_DEFAULT_LEVEL=%d\\n\" , XD3_DEFAULT_LEVEL ) ;\n XPR ( NTR \"XD3_DEFAULT_IOPT_SIZE=%d\\n\" , XD3_DEFAULT_IOPT_SIZE ) ;\n XPR ( NTR \"XD3_DEFAULT_SPREVSZ=%d\\n\" , XD3_DEFAULT_SPREVSZ ) ;\n XPR ( NTR \"XD3_DEFAULT_SRCWINSZ=%d\\n\" , XD3_DEFAULT_SRCWINSZ ) ;\n XPR ( NTR \"XD3_DEFAULT_WINSIZE=%d\\n\" , XD3_DEFAULT_WINSIZE ) ;\n XPR ( NTR \"XD3_HARDMAXWINSIZE=%d\\n\" , XD3_HARDMAXWINSIZE ) ;\n XPR ( NTR \"sizeof(void*)=%d\\n\" , ( int ) sizeof ( void * ) ) ;\n XPR ( NTR \"sizeof(int)=%d\\n\" , ( int ) sizeof ( int ) ) ;\n XPR ( NTR \"sizeof(size_t)=%d\\n\" , ( int ) sizeof ( size_t ) ) ;\n XPR ( NTR \"sizeof(uint32_t)=%d\\n\" , ( int ) sizeof ( uint32_t ) ) ;\n XPR ( NTR \"sizeof(uint64_t)=%d\\n\" , ( int ) sizeof ( uint64_t ) ) ;\n XPR ( NTR \"sizeof(usize_t)=%d\\n\" , ( int ) sizeof ( usize_t ) ) ;\n XPR ( NTR \"sizeof(xoff_t)=%d\\n\" , ( int ) sizeof ( xoff_t ) ) ;\n return EXIT_SUCCESS ;\n }", "hash": 914926989019402478, "project": "debian", "size": 33, "target": 0, "idx": 4218}
{"code": "static void main_get_appheader ( xd3_stream * stream , main_file * ifile , main_file * output , main_file * sfile ) {\n uint8_t * apphead ;\n usize_t appheadsz ;\n int ret ;\n if ( ! option_use_appheader ) {\n return ;\n }\n ret = xd3_get_appheader ( stream , & apphead , & appheadsz ) ;\n if ( ret != 0 ) {\n return ;\n }\n if ( appheadsz > 0 ) {\n const int kMaxArgs = 4 ;\n char * start = ( char * ) apphead ;\n char * slash ;\n int place = 0 ;\n char * parsed [ kMaxArgs ] ;\n memset ( parsed , 0 , sizeof ( parsed ) ) ;\n while ( ( slash = strchr ( start , '/' ) ) != NULL && place < ( kMaxArgs - 1 ) ) {\n * slash = 0 ;\n parsed [ place ++ ] = start ;\n start = slash + 1 ;\n }\n parsed [ place ++ ] = start ;\n if ( place == 2 || place == 4 ) {\n main_get_appheader_params ( output , parsed , 1 , \"output\" , ifile ) ;\n }\n if ( place == 4 ) {\n main_get_appheader_params ( sfile , parsed + 2 , 0 , \"source\" , ifile ) ;\n }\n }\n option_use_appheader = 0 ;\n return ;\n }", "hash": 914926989019402478, "project": "debian", "size": 34, "target": 0, "idx": 4220}
{"code": "static const main_extcomp * main_get_compressor ( const char * ident ) {\n const main_extcomp * ext = main_ident_compressor ( ident ) ;\n if ( ext == NULL ) {\n if ( ! option_quiet ) {\n XPR ( NT \"warning: cannot recompress output: \" \"unrecognized external compression ID: %s\\n\" , ident ) ;\n }\n return NULL ;\n }\n else if ( ! EXTERNAL_COMPRESSION ) {\n if ( ! option_quiet ) {\n XPR ( NT \"warning: external support not compiled: \" \"original input was compressed: %s\\n\" , ext -> recomp_cmdname ) ;\n }\n return NULL ;\n }\n else {\n return ext ;\n }\n }", "hash": 914926989019402478, "project": "debian", "size": 18, "target": 0, "idx": 4227}
{"code": "static int main_pipe_copier ( uint8_t * pipe_buf , usize_t pipe_bufsize , size_t nread , main_file * ifile , int outfd ) {\n int ret ;\n xoff_t skipped = 0 ;\n struct sigaction sa ;\n sa . sa_handler = SIG_IGN ;\n sigaction ( SIGPIPE , & sa , NULL ) ;\n for ( ;\n ;\n ) {\n int force_drain = 0 ;\n if ( nread > 0 && ( ret = main_pipe_write ( outfd , pipe_buf , nread ) ) ) {\n if ( ret == EPIPE ) {\n skipped += nread ;\n force_drain = 1 ;\n }\n else {\n XPR ( NT \"pipe write failed: %s\\n\" , xd3_mainerror ( ret ) ) ;\n return ret ;\n }\n }\n if ( nread < pipe_bufsize && ! force_drain ) {\n break ;\n }\n if ( ( ret = main_file_read ( ifile , pipe_buf , pipe_bufsize , & nread , \"pipe read failed\" ) ) < 0 ) {\n return ret ;\n }\n }\n if ( option_verbose && skipped != 0 ) {\n XPR ( NT \"skipping %\" Q \"u bytes in %s\\n\" , skipped , ifile -> filename ) ;\n }\n return 0 ;\n }", "hash": 914926989019402478, "project": "debian", "size": 32, "target": 0, "idx": 4232}
{"code": "static int main_set_secondary_flags ( xd3_config * config ) {\n int ret ;\n if ( option_use_secondary ) {\n if ( option_secondary == NULL ) {\n if ( SECONDARY_DJW ) {\n config -> flags |= XD3_SEC_DJW ;\n }\n }\n else {\n if ( strcmp ( option_secondary , \"fgk\" ) == 0 && SECONDARY_FGK ) {\n config -> flags |= XD3_SEC_FGK ;\n }\n else if ( strcmp ( option_secondary , \"lzma\" ) == 0 && SECONDARY_LZMA ) {\n config -> flags |= XD3_SEC_LZMA ;\n }\n else if ( strncmp ( option_secondary , \"djw\" , 3 ) == 0 && SECONDARY_DJW ) {\n usize_t level = XD3_DEFAULT_SECONDARY_LEVEL ;\n config -> flags |= XD3_SEC_DJW ;\n if ( strlen ( option_secondary ) > 3 && ( ret = main_atou ( option_secondary + 3 , & level , 0 , 9 , 'S' ) ) != 0 && ! option_quiet ) {\n return XD3_INVALID ;\n }\n if ( level < 1 ) {\n config -> flags |= XD3_SEC_NODATA ;\n }\n if ( level < 7 ) {\n config -> sec_data . ngroups = 1 ;\n }\n else {\n config -> sec_data . ngroups = 0 ;\n }\n if ( level < 3 ) {\n config -> flags |= XD3_SEC_NOINST ;\n }\n if ( level < 8 ) {\n config -> sec_inst . ngroups = 1 ;\n }\n else {\n config -> sec_inst . ngroups = 0 ;\n }\n if ( level < 5 ) {\n config -> flags |= XD3_SEC_NOADDR ;\n }\n if ( level < 9 ) {\n config -> sec_addr . ngroups = 1 ;\n }\n else {\n config -> sec_addr . ngroups = 0 ;\n }\n }\n else if ( strcmp ( option_secondary , \"none\" ) == 0 && SECONDARY_DJW ) {\n }\n else {\n if ( ! option_quiet ) {\n XPR ( NT \"unrecognized secondary compressor type: %s\\n\" , option_secondary ) ;\n return XD3_INVALID ;\n }\n }\n }\n }\n return 0 ;\n }", "hash": 914926989019402478, "project": "debian", "size": 61, "target": 0, "idx": 4234}
{"code": "static int test_decompress_text ( xd3_stream * stream , uint8_t * enc , usize_t enc_size , usize_t test_desize ) {\n xd3_config cfg ;\n char decoded [ sizeof ( test_text ) ] ;\n uint8_t * apphead ;\n usize_t apphead_size ;\n usize_t decoded_size ;\n const char * msg ;\n int ret ;\n usize_t pos = 0 ;\n int flags = stream -> flags ;\n usize_t take ;\n input : take = min ( enc_size - pos , test_desize ) ;\n CHECK ( take > 0 ) ;\n xd3_avail_input ( stream , enc + pos , take ) ;\n again : ret = xd3_decode_input ( stream ) ;\n pos += take ;\n take = 0 ;\n switch ( ret ) {\n case XD3_OUTPUT : break ;\n case XD3_WINSTART : case XD3_GOTHEADER : goto again ;\n case XD3_INPUT : if ( pos < enc_size ) {\n goto input ;\n }\n case XD3_WINFINISH : default : goto fail ;\n }\n CHECK ( ret == XD3_OUTPUT ) ;\n CHECK ( pos == enc_size ) ;\n if ( stream -> avail_out != sizeof ( test_text ) ) {\n stream -> msg = \"incorrect output size\" ;\n ret = XD3_INTERNAL ;\n goto fail ;\n }\n decoded_size = stream -> avail_out ;\n memcpy ( decoded , stream -> next_out , stream -> avail_out ) ;\n xd3_consume_output ( stream ) ;\n if ( ( ret = xd3_get_appheader ( stream , & apphead , & apphead_size ) ) ) {\n goto fail ;\n }\n if ( apphead_size != strlen ( ( char * ) test_apphead ) || memcmp ( apphead , test_apphead , strlen ( ( char * ) test_apphead ) ) != 0 ) {\n stream -> msg = \"incorrect appheader\" ;\n ret = XD3_INTERNAL ;\n goto fail ;\n }\n if ( ( ret = xd3_decode_input ( stream ) ) != XD3_WINFINISH || ( ret = xd3_close_stream ( stream ) ) != 0 ) {\n goto fail ;\n }\n if ( decoded_size != sizeof ( test_text ) || memcmp ( decoded , test_text , sizeof ( test_text ) ) != 0 ) {\n stream -> msg = \"incorrect output text\" ;\n ret = EIO ;\n }\n fail : msg = stream -> msg ;\n xd3_free_stream ( stream ) ;\n xd3_init_config ( & cfg , flags ) ;\n xd3_config_stream ( stream , & cfg ) ;\n stream -> msg = msg ;\n return ret ;\n }", "hash": 7749168290238234888, "project": "debian", "size": 57, "target": 0, "idx": 4243}
{"code": "static int test_decompress_single_bit_error ( xd3_stream * stream , int expected_non_failures ) {\n int ret ;\n usize_t i ;\n uint8_t encoded [ 4 * sizeof ( test_text ) ] ;\n usize_t encoded_size ;\n int non_failures = 0 ;\n int cksum = ( stream -> flags & XD3_ADLER32 ) != 0 ;\n # ifndef DEBUG_TEST_FAILURES # define TEST_FAILURES ( ) # else system ( \"rm -rf test_text.*\" ) ;\n {\n char buf [ TESTBUFSIZE ] ;\n FILE * f ;\n snprintf_func ( buf , TESTBUFSIZE , \"test_text\" ) ;\n f = fopen ( buf , \"w\" ) ;\n fwrite ( test_text , 1 , sizeof ( test_text ) , f ) ;\n fclose ( f ) ;\n }\n # define TEST_FAILURES ( ) do {\n char buf [ TESTBUFSIZE ] ;\n FILE * f ;\n snprintf_func ( buf , TESTBUFSIZE , \"test_text.xz.%d\" , non_failures ) ;\n f = fopen ( buf , \"w\" ) ;\n fwrite ( encoded , 1 , encoded_size , f ) ;\n fclose ( f ) ;\n }\n while ( 0 ) # endif stream -> sec_data . inefficient = 1 ;\n stream -> sec_inst . inefficient = 1 ;\n stream -> sec_addr . inefficient = 1 ;\n if ( ( ret = test_compress_text ( stream , encoded , & encoded_size ) ) ) {\n return ret ;\n }\n if ( ( ret = test_decompress_text ( stream , encoded , encoded_size , sizeof ( test_text ) / 4 ) ) ) {\n return ret ;\n }\n TEST_FAILURES ( ) ;\n for ( i = 0 ;\n i < encoded_size * 8 ;\n i += 1 ) {\n encoded [ i / 8 ] ^= 1 << ( i % 8 ) ;\n if ( ( ret = test_decompress_text ( stream , encoded , encoded_size , sizeof ( test_text ) ) ) == 0 ) {\n non_failures += 1 ;\n # ifdef DEBUG_TEST_FAILURES XPR ( NT \"%u[%u] non-failure %u\\n\" , i / 8 , i % 8 , non_failures ) ;\n # endif TEST_FAILURES ( ) ;\n }\n else {\n }\n if ( cksum && ret == EIO ) {\n stream -> msg = \"checksum mismatch\" ;\n return XD3_INTERNAL ;\n }\n encoded [ i / 8 ] ^= 1 << ( i % 8 ) ;\n }\n if ( ( ret = test_decompress_text ( stream , encoded , encoded_size , 1 ) ) ) {\n return ret ;\n }\n if ( non_failures != expected_non_failures ) {\n XPR ( NT \"non-failures %u;\n expected %u\" , non_failures , expected_non_failures ) ;\n stream -> msg = \"incorrect\" ;\n return XD3_INTERNAL ;\n }\n DOT ( ) ;\n return 0 ;\n }", "hash": 7749168290238234888, "project": "debian", "size": 63, "target": 0, "idx": 4253}
{"code": "static void passphrase_free ( char * ppbuff ) {\n if ( ppbuff != NULL ) {\n memset ( ppbuff , 0 , PPBUFF_SIZE ) ;\n free ( ppbuff ) ;\n }\n }", "hash": -6704066512670389306, "project": "debian", "size": 6, "target": 0, "idx": 4285}
{"code": "WRITE_CLASS_ENCODER ( AuthCapsInfo ) struct AuthTicket {\n EntityName name ;\n uint64_t global_id ;\n uint64_t auid ;\n utime_t created , renew_after , expires ;\n AuthCapsInfo caps ;\n __u32 flags ;\n AuthTicket ( ) : global_id ( 0 ) , auid ( CEPH_AUTH_UID_DEFAULT ) , flags ( 0 ) {\n }\n void init_timestamps ( utime_t now , double ttl ) {\n created = now ;\n expires = now ;\n expires += ttl ;\n renew_after = now ;\n renew_after += ttl / 2.0 ;\n }\n void encode ( bufferlist & bl ) const {\n __u8 struct_v = 2 ;\n : : encode ( struct_v , bl ) ;\n : : encode ( name , bl ) ;\n : : encode ( global_id , bl ) ;\n : : encode ( auid , bl ) ;\n : : encode ( created , bl ) ;\n : : encode ( expires , bl ) ;\n : : encode ( caps , bl ) ;\n : : encode ( flags , bl ) ;\n }\n void decode ( bufferlist : : iterator & bl ) {\n __u8 struct_v ;\n : : decode ( struct_v , bl ) ;\n : : decode ( name , bl ) ;\n : : decode ( global_id , bl ) ;\n if ( struct_v >= 2 ) : : decode ( auid , bl ) ;\n else auid = CEPH_AUTH_UID_DEFAULT ;\n : : decode ( created , bl ) ;\n : : decode ( expires , bl ) ;\n : : decode ( caps , bl ) ;\n : : decode ( flags , bl ) ;\n }\n }\n ;\n WRITE_CLASS_ENCODER ( AuthTicket ) struct AuthAuthorizer {\n __u32 protocol ;\n bufferlist bl ;\n CryptoKey session_key ;\n explicit AuthAuthorizer ( __u32 p ) : protocol ( p ) {\n }\n virtual ~ AuthAuthorizer ( ) {\n }\n virtual bool verify_reply ( bufferlist : : iterator & reply ) = 0 ;\n virtual bool add_challenge ( CephContext * cct , bufferlist & challenge ) = 0 ;\n }", "hash": -6063487367164326236, "project": "debian", "size": 52, "target": 0, "idx": 4309}
{"code": "int mbfl_oddlen ( mbfl_string * string ) {\n int len , n , m , k ;\n unsigned char * p ;\n const unsigned char * mbtab ;\n const mbfl_encoding * encoding ;\n if ( string == NULL ) {\n return - 1 ;\n }\n encoding = mbfl_no2encoding ( string -> no_encoding ) ;\n if ( encoding == NULL ) {\n return - 1 ;\n }\n len = 0 ;\n if ( encoding -> flag & MBFL_ENCTYPE_SBCS ) {\n return 0 ;\n }\n else if ( encoding -> flag & ( MBFL_ENCTYPE_WCS2BE | MBFL_ENCTYPE_WCS2LE ) ) {\n return len % 2 ;\n }\n else if ( encoding -> flag & ( MBFL_ENCTYPE_WCS4BE | MBFL_ENCTYPE_WCS4LE ) ) {\n return len % 4 ;\n }\n else if ( encoding -> mblen_table != NULL ) {\n mbtab = encoding -> mblen_table ;\n n = 0 ;\n p = string -> val ;\n k = string -> len ;\n if ( p != NULL ) {\n while ( n < k ) {\n m = mbtab [ * p ] ;\n n += m ;\n p += m ;\n }\n ;\n }\n return n - k ;\n }\n else {\n return 0 ;\n }\n }", "hash": 5991533509192663951, "project": "debian", "size": 41, "target": 0, "idx": 4330}
{"code": "void mbfl_buffer_converter_delete ( mbfl_buffer_converter * convd ) {\n if ( convd != NULL ) {\n if ( convd -> filter1 ) {\n mbfl_convert_filter_delete ( convd -> filter1 ) ;\n }\n if ( convd -> filter2 ) {\n mbfl_convert_filter_delete ( convd -> filter2 ) ;\n }\n mbfl_memory_device_clear ( & convd -> device ) ;\n mbfl_free ( ( void * ) convd ) ;\n }\n }", "hash": 5991533509192663951, "project": "debian", "size": 12, "target": 0, "idx": 4333}
{"code": "static int collector_strpos ( int c , void * data ) {\n int * p , * h , * m , n ;\n struct collector_strpos_data * pc = ( struct collector_strpos_data * ) data ;\n if ( pc -> output >= pc -> start ) {\n if ( c == ( int ) pc -> needle . buffer [ pc -> needle_pos ] ) {\n if ( pc -> needle_pos == 0 ) {\n pc -> found_pos = pc -> output ;\n }\n pc -> needle_pos ++ ;\n if ( pc -> needle_pos >= pc -> needle_len ) {\n pc -> matched_pos = pc -> found_pos ;\n pc -> needle_pos -- ;\n goto retry ;\n }\n }\n else if ( pc -> needle_pos != 0 ) {\n retry : h = ( int * ) pc -> needle . buffer ;\n h ++ ;\n for ( ;\n ;\n ) {\n pc -> found_pos ++ ;\n p = h ;\n m = ( int * ) pc -> needle . buffer ;\n n = pc -> needle_pos - 1 ;\n while ( n > 0 && * p == * m ) {\n n -- ;\n p ++ ;\n m ++ ;\n }\n if ( n <= 0 ) {\n if ( * m != c ) {\n pc -> needle_pos = 0 ;\n }\n break ;\n }\n else {\n h ++ ;\n pc -> needle_pos -- ;\n }\n }\n }\n }\n pc -> output ++ ;\n return c ;\n }", "hash": 5991533509192663951, "project": "debian", "size": 46, "target": 0, "idx": 4346}
{"code": "int mbfl_buffer_illegalchars ( mbfl_buffer_converter * convd ) {\n int num_illegalchars = 0 ;\n if ( convd == NULL ) {\n return 0 ;\n }\n if ( convd -> filter1 != NULL ) {\n num_illegalchars += convd -> filter1 -> num_illegalchar ;\n }\n if ( convd -> filter2 != NULL ) {\n num_illegalchars += convd -> filter2 -> num_illegalchar ;\n }\n return ( num_illegalchars ) ;\n }", "hash": 5991533509192663951, "project": "debian", "size": 13, "target": 0, "idx": 4348}
{"code": "static int is_fullwidth ( int c ) {\n int i ;\n if ( c < mbfl_eaw_table [ 0 ] . begin ) {\n return 0 ;\n }\n for ( i = 0 ;\n i < sizeof ( mbfl_eaw_table ) / sizeof ( mbfl_eaw_table [ 0 ] ) ;\n i ++ ) {\n if ( mbfl_eaw_table [ i ] . begin <= c && c <= mbfl_eaw_table [ i ] . end ) {\n return 1 ;\n }\n }\n return 0 ;\n }", "hash": 5991533509192663951, "project": "debian", "size": 14, "target": 0, "idx": 4356}
{"code": "void mime_header_decoder_delete ( struct mime_header_decoder_data * pd ) {\n if ( pd ) {\n mbfl_convert_filter_delete ( pd -> conv2_filter ) ;\n mbfl_convert_filter_delete ( pd -> conv1_filter ) ;\n mbfl_convert_filter_delete ( pd -> deco_filter ) ;\n mbfl_memory_device_clear ( & pd -> outdev ) ;\n mbfl_memory_device_clear ( & pd -> tmpdev ) ;\n mbfl_free ( ( void * ) pd ) ;\n }\n }", "hash": 5991533509192663951, "project": "debian", "size": 10, "target": 0, "idx": 4358}
{"code": "mbfl_string * mbfl_strcut ( mbfl_string * string , mbfl_string * result , int from , int length ) {\n const mbfl_encoding * encoding ;\n mbfl_memory_device device ;\n if ( string == NULL || string -> val == NULL || result == NULL ) {\n return NULL ;\n }\n if ( from < 0 || length < 0 ) {\n return NULL ;\n }\n if ( from >= string -> len ) {\n from = string -> len ;\n }\n encoding = mbfl_no2encoding ( string -> no_encoding ) ;\n if ( encoding == NULL ) {\n return NULL ;\n }\n mbfl_string_init ( result ) ;\n result -> no_language = string -> no_language ;\n result -> no_encoding = string -> no_encoding ;\n if ( ( encoding -> flag & ( MBFL_ENCTYPE_SBCS | MBFL_ENCTYPE_WCS2BE | MBFL_ENCTYPE_WCS2LE | MBFL_ENCTYPE_WCS4BE | MBFL_ENCTYPE_WCS4LE ) ) || encoding -> mblen_table != NULL ) {\n const unsigned char * start = NULL ;\n const unsigned char * end = NULL ;\n unsigned char * w ;\n unsigned int sz ;\n if ( encoding -> flag & ( MBFL_ENCTYPE_WCS2BE | MBFL_ENCTYPE_WCS2LE ) ) {\n from &= - 2 ;\n if ( length >= string -> len - from ) {\n length = string -> len - from ;\n }\n start = string -> val + from ;\n end = start + ( length & - 2 ) ;\n }\n else if ( encoding -> flag & ( MBFL_ENCTYPE_WCS4BE | MBFL_ENCTYPE_WCS4LE ) ) {\n from &= - 4 ;\n if ( length >= string -> len - from ) {\n length = string -> len - from ;\n }\n start = string -> val + from ;\n end = start + ( length & - 4 ) ;\n }\n else if ( ( encoding -> flag & MBFL_ENCTYPE_SBCS ) ) {\n if ( length >= string -> len - from ) {\n length = string -> len - from ;\n }\n start = string -> val + from ;\n end = start + length ;\n }\n else if ( encoding -> mblen_table != NULL ) {\n const unsigned char * mbtab = encoding -> mblen_table ;\n const unsigned char * p , * q ;\n int m ;\n for ( m = 0 , p = string -> val , q = p + from ;\n p < q ;\n p += ( m = mbtab [ * p ] ) ) ;\n if ( p > q ) {\n p -= m ;\n }\n start = p ;\n if ( length >= ( int ) string -> len - ( start - string -> val ) ) {\n end = string -> val + string -> len ;\n }\n else {\n for ( q = p + length ;\n p < q ;\n p += ( m = mbtab [ * p ] ) ) ;\n if ( p > q ) {\n p -= m ;\n }\n end = p ;\n }\n }\n else {\n return NULL ;\n }\n sz = end - start ;\n if ( ( w = ( unsigned char * ) mbfl_calloc ( sz + 8 , sizeof ( unsigned char ) ) ) == NULL ) {\n return NULL ;\n }\n memcpy ( w , start , sz ) ;\n w [ sz ] = '\\0' ;\n w [ sz + 1 ] = '\\0' ;\n w [ sz + 2 ] = '\\0' ;\n w [ sz + 3 ] = '\\0' ;\n result -> val = w ;\n result -> len = sz ;\n }\n else {\n mbfl_convert_filter * encoder = NULL ;\n mbfl_convert_filter * decoder = NULL ;\n const unsigned char * p , * q , * r ;\n struct {\n mbfl_convert_filter encoder ;\n mbfl_convert_filter decoder ;\n const unsigned char * p ;\n int pos ;\n }\n bk , _bk ;\n if ( ! ( decoder = mbfl_convert_filter_new ( mbfl_no_encoding_wchar , string -> no_encoding , mbfl_memory_device_output , 0 , & device ) ) ) {\n return NULL ;\n }\n if ( ! ( encoder = mbfl_convert_filter_new ( string -> no_encoding , mbfl_no_encoding_wchar , mbfl_filter_output_null , NULL , NULL ) ) ) {\n mbfl_convert_filter_delete ( decoder ) ;\n return NULL ;\n }\n mbfl_memory_device_init ( & device , length + 8 , 0 ) ;\n p = string -> val ;\n for ( q = string -> val + from ;\n p < q ;\n p ++ ) {\n ( * encoder -> filter_function ) ( * p , encoder ) ;\n }\n encoder -> output_function = ( int ( * ) ( int , void * ) ) decoder -> filter_function ;\n encoder -> flush_function = ( int ( * ) ( void * ) ) decoder -> filter_flush ;\n encoder -> data = decoder ;\n q = string -> val + string -> len ;\n mbfl_convert_filter_copy ( decoder , & _bk . decoder ) ;\n mbfl_convert_filter_copy ( encoder , & _bk . encoder ) ;\n _bk . p = p ;\n _bk . pos = device . pos ;\n if ( length > q - p ) {\n length = q - p ;\n }\n if ( length >= 20 ) {\n for ( r = p + length - 20 ;\n p < r ;\n p ++ ) {\n ( * encoder -> filter_function ) ( * p , encoder ) ;\n }\n if ( device . pos > length ) {\n p = _bk . p ;\n device . pos = _bk . pos ;\n decoder -> filter_dtor ( decoder ) ;\n encoder -> filter_dtor ( encoder ) ;\n mbfl_convert_filter_copy ( & _bk . decoder , decoder ) ;\n mbfl_convert_filter_copy ( & _bk . encoder , encoder ) ;\n bk = _bk ;\n }\n else {\n mbfl_convert_filter_copy ( decoder , & bk . decoder ) ;\n mbfl_convert_filter_copy ( encoder , & bk . encoder ) ;\n bk . p = p ;\n bk . pos = device . pos ;\n ( * encoder -> filter_flush ) ( encoder ) ;\n if ( device . pos > length ) {\n bk . decoder . filter_dtor ( & bk . decoder ) ;\n bk . encoder . filter_dtor ( & bk . encoder ) ;\n p = _bk . p ;\n device . pos = _bk . pos ;\n decoder -> filter_dtor ( decoder ) ;\n encoder -> filter_dtor ( encoder ) ;\n mbfl_convert_filter_copy ( & _bk . decoder , decoder ) ;\n mbfl_convert_filter_copy ( & _bk . encoder , encoder ) ;\n bk = _bk ;\n }\n else {\n _bk . decoder . filter_dtor ( & _bk . decoder ) ;\n _bk . encoder . filter_dtor ( & _bk . encoder ) ;\n p = bk . p ;\n device . pos = bk . pos ;\n decoder -> filter_dtor ( decoder ) ;\n encoder -> filter_dtor ( encoder ) ;\n mbfl_convert_filter_copy ( & bk . decoder , decoder ) ;\n mbfl_convert_filter_copy ( & bk . encoder , encoder ) ;\n }\n }\n }\n else {\n bk = _bk ;\n }\n while ( p < q ) {\n ( * encoder -> filter_function ) ( * p , encoder ) ;\n if ( device . pos > length ) {\n p = bk . p ;\n device . pos = bk . pos ;\n decoder -> filter_dtor ( decoder ) ;\n encoder -> filter_dtor ( encoder ) ;\n mbfl_convert_filter_copy ( & bk . decoder , decoder ) ;\n mbfl_convert_filter_copy ( & bk . encoder , encoder ) ;\n break ;\n }\n p ++ ;\n mbfl_convert_filter_copy ( decoder , & _bk . decoder ) ;\n mbfl_convert_filter_copy ( encoder , & _bk . encoder ) ;\n _bk . pos = device . pos ;\n _bk . p = p ;\n ( * encoder -> filter_flush ) ( encoder ) ;\n if ( device . pos > length ) {\n _bk . decoder . filter_dtor ( & _bk . decoder ) ;\n _bk . encoder . filter_dtor ( & _bk . encoder ) ;\n p = bk . p ;\n device . pos = bk . pos ;\n decoder -> filter_dtor ( decoder ) ;\n encoder -> filter_dtor ( encoder ) ;\n mbfl_convert_filter_copy ( & bk . decoder , decoder ) ;\n mbfl_convert_filter_copy ( & bk . encoder , encoder ) ;\n break ;\n }\n bk . decoder . filter_dtor ( & bk . decoder ) ;\n bk . encoder . filter_dtor ( & bk . encoder ) ;\n p = _bk . p ;\n device . pos = _bk . pos ;\n decoder -> filter_dtor ( decoder ) ;\n encoder -> filter_dtor ( encoder ) ;\n mbfl_convert_filter_copy ( & _bk . decoder , decoder ) ;\n mbfl_convert_filter_copy ( & _bk . encoder , encoder ) ;\n bk = _bk ;\n }\n ( * encoder -> filter_flush ) ( encoder ) ;\n bk . decoder . filter_dtor ( & bk . decoder ) ;\n bk . encoder . filter_dtor ( & bk . encoder ) ;\n result = mbfl_memory_device_result ( & device , result ) ;\n mbfl_convert_filter_delete ( encoder ) ;\n mbfl_convert_filter_delete ( decoder ) ;\n }\n return result ;\n }", "hash": 5991533509192663951, "project": "debian", "size": 216, "target": 0, "idx": 4370}
{"code": "static void abort_sasl_exit ( hook_data_client_exit * data ) {\n if ( data -> target -> localClient ) abort_sasl ( data -> target ) ;\n }", "hash": 367231654042118631, "project": "debian", "size": 3, "target": 0, "idx": 4378}
{"code": "void gs_make_null_device ( gx_device_null * dev_null , gx_device * dev , gs_memory_t * mem ) {\n gx_device_init ( ( gx_device * ) dev_null , ( const gx_device * ) & gs_null_device , mem , true ) ;\n gx_device_set_target ( ( gx_device_forward * ) dev_null , dev ) ;\n if ( dev ) {\n gx_device * dn = ( gx_device * ) dev_null ;\n set_dev_proc ( dn , get_color_mapping_procs , gx_forward_get_color_mapping_procs ) ;\n set_dev_proc ( dn , get_color_comp_index , gx_forward_get_color_comp_index ) ;\n set_dev_proc ( dn , encode_color , gx_forward_encode_color ) ;\n set_dev_proc ( dn , decode_color , gx_forward_decode_color ) ;\n set_dev_proc ( dn , get_profile , gx_forward_get_profile ) ;\n set_dev_proc ( dn , set_graphics_type_tag , gx_forward_set_graphics_type_tag ) ;\n set_dev_proc ( dn , begin_transparency_group , gx_default_begin_transparency_group ) ;\n set_dev_proc ( dn , end_transparency_group , gx_default_end_transparency_group ) ;\n set_dev_proc ( dn , begin_transparency_mask , gx_default_begin_transparency_mask ) ;\n set_dev_proc ( dn , end_transparency_mask , gx_default_end_transparency_mask ) ;\n set_dev_proc ( dn , discard_transparency_layer , gx_default_discard_transparency_layer ) ;\n set_dev_proc ( dn , pattern_manage , gx_default_pattern_manage ) ;\n set_dev_proc ( dn , push_transparency_state , gx_default_push_transparency_state ) ;\n set_dev_proc ( dn , pop_transparency_state , gx_default_pop_transparency_state ) ;\n set_dev_proc ( dn , put_image , gx_default_put_image ) ;\n set_dev_proc ( dn , copy_planes , gx_default_copy_planes ) ;\n set_dev_proc ( dn , copy_alpha_hl_color , gx_default_no_copy_alpha_hl_color ) ;\n dn -> graphics_type_tag = dev -> graphics_type_tag ;\n gx_device_copy_color_params ( dn , dev ) ;\n }\n }", "hash": -6126432314261451839, "project": "debian", "size": 26, "target": 0, "idx": 4384}
{"code": "bool gx_color_info_equal ( const gx_device_color_info * p1 , const gx_device_color_info * p2 ) {\n if ( p1 -> anti_alias . graphics_bits != p2 -> anti_alias . graphics_bits ) return false ;\n if ( p1 -> anti_alias . text_bits != p2 -> anti_alias . text_bits ) return false ;\n if ( p1 -> black_component != p2 -> black_component ) return false ;\n if ( strcmp ( p1 -> cm_name , p2 -> cm_name ) != 0 ) return false ;\n if ( p1 -> depth != p2 -> depth ) return false ;\n if ( p1 -> dither_colors != p2 -> dither_colors ) return false ;\n if ( p1 -> dither_grays != p2 -> dither_grays ) return false ;\n if ( p1 -> gray_index != p2 -> gray_index ) return false ;\n if ( p1 -> max_color != p2 -> max_color ) return false ;\n if ( p1 -> max_components != p2 -> max_components ) return false ;\n if ( p1 -> opmode != p2 -> opmode ) return false ;\n if ( p1 -> polarity != p2 -> polarity ) return false ;\n if ( p1 -> process_comps != p2 -> process_comps ) return false ;\n if ( p1 -> separable_and_linear != p2 -> separable_and_linear ) return false ;\n if ( p1 -> use_antidropout_downscaler != p2 -> use_antidropout_downscaler ) return false ;\n return true ;\n }", "hash": -6126432314261451839, "project": "debian", "size": 18, "target": 0, "idx": 4397}
{"code": "const gx_device * gs_getdevice ( int index ) {\n const gx_device * const * list ;\n int count = gs_lib_device_list ( & list , NULL ) ;\n if ( index < 0 || index >= count ) return 0 ;\n return list [ index ] ;\n }", "hash": -6126432314261451839, "project": "debian", "size": 6, "target": 0, "idx": 4403}
{"code": "int gs_copypage ( gs_gstate * pgs ) {\n return gs_output_page ( pgs , 1 , 0 ) ;\n }", "hash": -6126432314261451839, "project": "debian", "size": 3, "target": 0, "idx": 4406}
{"code": "int gs_gstate_putdeviceparams ( gs_gstate * pgs , gx_device * dev , gs_param_list * plist ) {\n int code ;\n gx_device * dev2 ;\n if ( dev ) dev2 = dev ;\n else dev2 = pgs -> device ;\n code = gs_putdeviceparams ( dev2 , plist ) ;\n if ( code >= 0 ) gs_gstate_update_device ( pgs , dev2 ) ;\n return code ;\n }", "hash": -6126432314261451839, "project": "debian", "size": 9, "target": 0, "idx": 4416}
{"code": "int gx_parse_output_file_name ( gs_parsed_file_name_t * pfn , const char * * pfmt , const char * fname , uint fnlen , gs_memory_t * memory ) {\n int code ;\n * pfmt = 0 ;\n pfn -> memory = 0 ;\n pfn -> iodev = NULL ;\n pfn -> fname = NULL ;\n pfn -> len = 0 ;\n if ( fnlen == 0 ) return 0 ;\n code = gs_parse_file_name ( pfn , fname , fnlen , memory ) ;\n if ( code < 0 ) {\n if ( fname [ 0 ] == '%' ) {\n pfn -> len = fnlen ;\n pfn -> fname = fname ;\n code = gx_parse_output_format ( pfn , pfmt ) ;\n }\n if ( code < 0 ) return code ;\n }\n if ( ! pfn -> iodev ) {\n if ( ( pfn -> len == 1 ) && ( pfn -> fname [ 0 ] == '-' ) ) {\n pfn -> iodev = gs_findiodevice ( memory , ( const byte * ) \"%stdout\" , 7 ) ;\n pfn -> fname = NULL ;\n }\n else if ( pfn -> fname [ 0 ] == '|' ) {\n pfn -> iodev = gs_findiodevice ( memory , ( const byte * ) \"%pipe\" , 5 ) ;\n pfn -> fname ++ , pfn -> len -- ;\n }\n else pfn -> iodev = iodev_default ( memory ) ;\n if ( ! pfn -> iodev ) return_error ( gs_error_undefinedfilename ) ;\n }\n if ( ! pfn -> fname ) return 0 ;\n code = gx_parse_output_format ( pfn , pfmt ) ;\n if ( code < 0 ) return code ;\n if ( strlen ( pfn -> iodev -> dname ) + pfn -> len + code >= gp_file_name_sizeof ) return_error ( gs_error_undefinedfilename ) ;\n return 0 ;\n }", "hash": -6126432314261451839, "project": "debian", "size": 35, "target": 0, "idx": 4417}
{"code": "void gx_device_init_on_stack ( gx_device * dev , const gx_device * proto , gs_memory_t * mem ) {\n memcpy ( dev , proto , proto -> params_size ) ;\n dev -> memory = mem ;\n dev -> retained = 0 ;\n dev -> pad = proto -> pad ;\n dev -> log2_align_mod = proto -> log2_align_mod ;\n dev -> is_planar = proto -> is_planar ;\n rc_init ( dev , NULL , 0 ) ;\n }", "hash": -6126432314261451839, "project": "debian", "size": 9, "target": 0, "idx": 4418}
{"code": "int gx_device_delete_output_file ( const gx_device * dev , const char * fname ) {\n gs_parsed_file_name_t parsed ;\n const char * fmt ;\n char * pfname = ( char * ) gs_alloc_bytes ( dev -> memory , gp_file_name_sizeof , \"gx_device_delete_output_file(pfname)\" ) ;\n int code ;\n if ( pfname == NULL ) {\n code = gs_note_error ( gs_error_VMerror ) ;\n goto done ;\n }\n code = gx_parse_output_file_name ( & parsed , & fmt , fname , strlen ( fname ) , dev -> memory ) ;\n if ( code < 0 ) {\n goto done ;\n }\n if ( parsed . iodev && ! strcmp ( parsed . iodev -> dname , \"%stdout%\" ) ) goto done ;\n if ( fmt ) {\n long count1 = dev -> PageCount + 1 ;\n while ( * fmt != 'l' && * fmt != '%' ) -- fmt ;\n if ( * fmt == 'l' ) gs_sprintf ( pfname , parsed . fname , count1 ) ;\n else gs_sprintf ( pfname , parsed . fname , ( int ) count1 ) ;\n }\n else if ( parsed . len && strchr ( parsed . fname , '%' ) ) gs_sprintf ( pfname , parsed . fname ) ;\n else pfname [ 0 ] = 0 ;\n if ( pfname [ 0 ] ) {\n parsed . fname = pfname ;\n parsed . len = strlen ( parsed . fname ) ;\n }\n if ( parsed . iodev ) code = parsed . iodev -> procs . delete_file ( ( gx_io_device * ) ( & parsed . iodev ) , ( const char * ) parsed . fname ) ;\n else code = gs_note_error ( gs_error_invalidfileaccess ) ;\n done : if ( pfname != NULL ) gs_free_object ( dev -> memory , pfname , \"gx_device_delete_output_file(pfname)\" ) ;\n return ( code ) ;\n }", "hash": -6126432314261451839, "project": "debian", "size": 31, "target": 0, "idx": 4419}
{"code": "int gs_setdevice_no_erase ( gs_gstate * pgs , gx_device * dev ) {\n int open_code = 0 , code ;\n gs_lib_ctx_t * libctx = gs_lib_ctx_get_interp_instance ( pgs -> memory ) ;\n if ( libctx -> io_device_table != NULL ) {\n cmm_dev_profile_t * dev_profile ;\n if ( pgs -> icc_manager -> lab_profile == NULL ) {\n gsicc_init_iccmanager ( pgs ) ;\n }\n if ( dev -> procs . get_profile != NULL ) {\n code = dev_proc ( dev , get_profile ) ( dev , & dev_profile ) ;\n if ( code < 0 ) {\n return ( code ) ;\n }\n if ( dev_profile == NULL || dev_profile -> device_profile [ gsDEFAULTPROFILE ] == NULL ) {\n if ( ( code = gsicc_init_device_profile_struct ( dev , NULL , gsDEFAULTPROFILE ) ) < 0 ) return ( code ) ;\n if ( ( code = gsicc_set_device_profile_intent ( dev , gsRINOTSPECIFIED , gsDEFAULTPROFILE ) ) < 0 ) return ( code ) ;\n }\n }\n }\n if ( ! dev -> is_open ) {\n gx_device_fill_in_procs ( dev ) ;\n if ( libctx -> io_device_table != NULL ) {\n cmm_dev_profile_t * dev_profile ;\n if ( dev -> procs . get_profile != NULL ) {\n code = dev_proc ( dev , get_profile ) ( dev , & dev_profile ) ;\n if ( code < 0 ) {\n return ( code ) ;\n }\n if ( dev_profile == NULL || dev_profile -> device_profile [ gsDEFAULTPROFILE ] == NULL ) {\n if ( ( code = gsicc_init_device_profile_struct ( dev , NULL , gsDEFAULTPROFILE ) ) < 0 ) return ( code ) ;\n }\n }\n }\n if ( gs_device_is_memory ( dev ) ) {\n gx_device * odev = gs_currentdevice_inline ( pgs ) ;\n while ( odev != 0 && gs_device_is_memory ( odev ) ) odev = ( ( gx_device_memory * ) odev ) -> target ;\n gx_device_set_target ( ( ( gx_device_forward * ) dev ) , odev ) ;\n }\n code = open_code = gs_opendevice ( dev ) ;\n if ( code < 0 ) return code ;\n }\n gs_setdevice_no_init ( pgs , dev ) ;\n pgs -> ctm_default_set = false ;\n if ( ( code = gs_initmatrix ( pgs ) ) < 0 || ( code = gs_initclip ( pgs ) ) < 0 ) return code ;\n pgs -> in_cachedevice = 0 ;\n pgs -> in_charpath = ( gs_char_path_mode ) 0 ;\n return open_code ;\n }", "hash": -6126432314261451839, "project": "debian", "size": 48, "target": 0, "idx": 4420}
{"code": "void gx_device_set_resolution ( gx_device * dev , double x_dpi , double y_dpi ) {\n dev -> HWResolution [ 0 ] = x_dpi ;\n dev -> HWResolution [ 1 ] = y_dpi ;\n gx_device_set_hwsize_from_media ( dev ) ;\n }", "hash": -6126432314261451839, "project": "debian", "size": 5, "target": 0, "idx": 4424}
{"code": "void SSL_CTX_set_default_read_buffer_len ( SSL_CTX * ctx , size_t len ) {\n ctx -> default_read_buf_len = len ;\n }", "hash": 561876472800374387, "project": "debian", "size": 3, "target": 0, "idx": 4449}
{"code": "static int archive_read_format_cpio_skip ( struct archive_read * a ) {\n struct cpio * cpio = ( struct cpio * ) ( a -> format -> data ) ;\n int64_t to_skip = cpio -> entry_bytes_remaining + cpio -> entry_padding + cpio -> entry_bytes_unconsumed ;\n if ( to_skip != __archive_read_consume ( a , to_skip ) ) {\n return ( ARCHIVE_FATAL ) ;\n }\n cpio -> entry_bytes_remaining = 0 ;\n cpio -> entry_padding = 0 ;\n cpio -> entry_bytes_unconsumed = 0 ;\n return ( ARCHIVE_OK ) ;\n }", "hash": 1504508151056681409, "project": "debian", "size": 11, "target": 0, "idx": 4465}
{"code": "static int archive_read_format_cpio_cleanup ( struct archive_read * a ) {\n struct cpio * cpio ;\n cpio = ( struct cpio * ) ( a -> format -> data ) ;\n while ( cpio -> links_head != NULL ) {\n struct links_entry * lp = cpio -> links_head -> next ;\n if ( cpio -> links_head -> name ) free ( cpio -> links_head -> name ) ;\n free ( cpio -> links_head ) ;\n cpio -> links_head = lp ;\n }\n free ( cpio ) ;\n ( a -> format -> data ) = NULL ;\n return ( ARCHIVE_OK ) ;\n }", "hash": 1504508151056681409, "project": "debian", "size": 13, "target": 0, "idx": 4475}
{"code": "static int archive_read_format_cpio_bid ( struct archive_read * a , int best_bid ) {\n const unsigned char * p ;\n struct cpio * cpio ;\n int bid ;\n ( void ) best_bid ;\n cpio = ( struct cpio * ) ( a -> format -> data ) ;\n if ( ( p = __archive_read_ahead ( a , 6 , NULL ) ) == NULL ) return ( - 1 ) ;\n bid = 0 ;\n if ( memcmp ( p , \"070707\" , 6 ) == 0 ) {\n cpio -> read_header = header_odc ;\n bid += 48 ;\n }\n else if ( memcmp ( p , \"070727\" , 6 ) == 0 ) {\n cpio -> read_header = header_odc ;\n bid += 48 ;\n }\n else if ( memcmp ( p , \"070701\" , 6 ) == 0 ) {\n cpio -> read_header = header_newc ;\n bid += 48 ;\n }\n else if ( memcmp ( p , \"070702\" , 6 ) == 0 ) {\n cpio -> read_header = header_newc ;\n bid += 48 ;\n }\n else if ( p [ 0 ] * 256 + p [ 1 ] == 070707 ) {\n cpio -> read_header = header_bin_be ;\n bid += 16 ;\n }\n else if ( p [ 0 ] + p [ 1 ] * 256 == 070707 ) {\n cpio -> read_header = header_bin_le ;\n bid += 16 ;\n }\n else return ( ARCHIVE_WARN ) ;\n return ( bid ) ;\n }", "hash": 1504508151056681409, "project": "debian", "size": 35, "target": 0, "idx": 4481}
{"code": "kadm5_ret_t kadm5_randkey_principal ( void * server_handle , krb5_principal principal , krb5_keyblock * * keyblocks , int * n_keys ) {\n return kadm5_randkey_principal_3 ( server_handle , principal , FALSE , 0 , NULL , keyblocks , n_keys ) ;\n }", "hash": 4704178797381506498, "project": "debian", "size": 3, "target": 0, "idx": 4487}
{"code": "kadm5_ret_t kadm5_get_principal ( void * server_handle , krb5_principal principal , kadm5_principal_ent_t entry , long in_mask ) {\n krb5_db_entry * kdb ;\n osa_princ_ent_rec adb ;\n krb5_error_code ret = 0 ;\n long mask ;\n int i ;\n kadm5_server_handle_t handle = server_handle ;\n CHECK_HANDLE ( server_handle ) ;\n krb5_clear_error_message ( handle -> context ) ;\n mask = in_mask ;\n memset ( entry , 0 , sizeof ( * entry ) ) ;\n if ( principal == NULL ) return EINVAL ;\n if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ret ;\n if ( ( mask & KADM5_POLICY ) && adb . policy && ( adb . aux_attributes & KADM5_POLICY ) ) {\n if ( ( entry -> policy = strdup ( adb . policy ) ) == NULL ) {\n ret = ENOMEM ;\n goto done ;\n }\n }\n if ( mask & KADM5_AUX_ATTRIBUTES ) entry -> aux_attributes = adb . aux_attributes ;\n if ( ( mask & KADM5_PRINCIPAL ) && ( ret = krb5_copy_principal ( handle -> context , kdb -> princ , & entry -> principal ) ) ) {\n goto done ;\n }\n if ( mask & KADM5_PRINC_EXPIRE_TIME ) entry -> princ_expire_time = kdb -> expiration ;\n if ( ( mask & KADM5_LAST_PWD_CHANGE ) && ( ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & ( entry -> last_pwd_change ) ) ) ) {\n goto done ;\n }\n if ( mask & KADM5_PW_EXPIRATION ) entry -> pw_expiration = kdb -> pw_expiration ;\n if ( mask & KADM5_MAX_LIFE ) entry -> max_life = kdb -> max_life ;\n if ( ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) ) {\n ret = krb5_dbe_lookup_mod_princ_data ( handle -> context , kdb , & ( entry -> mod_date ) , & ( entry -> mod_name ) ) ;\n if ( ret ) {\n goto done ;\n }\n if ( ! ( mask & KADM5_MOD_TIME ) ) entry -> mod_date = 0 ;\n if ( ! ( mask & KADM5_MOD_NAME ) ) {\n krb5_free_principal ( handle -> context , entry -> mod_name ) ;\n entry -> mod_name = NULL ;\n }\n }\n if ( mask & KADM5_ATTRIBUTES ) entry -> attributes = kdb -> attributes ;\n if ( mask & KADM5_KVNO ) for ( entry -> kvno = 0 , i = 0 ;\n i < kdb -> n_key_data ;\n i ++ ) if ( ( krb5_kvno ) kdb -> key_data [ i ] . key_data_kvno > entry -> kvno ) entry -> kvno = kdb -> key_data [ i ] . key_data_kvno ;\n if ( mask & KADM5_MKVNO ) {\n ret = krb5_dbe_get_mkvno ( handle -> context , kdb , & entry -> mkvno ) ;\n if ( ret ) goto done ;\n }\n if ( mask & KADM5_MAX_RLIFE ) entry -> max_renewable_life = kdb -> max_renewable_life ;\n if ( mask & KADM5_LAST_SUCCESS ) entry -> last_success = kdb -> last_success ;\n if ( mask & KADM5_LAST_FAILED ) entry -> last_failed = kdb -> last_failed ;\n if ( mask & KADM5_FAIL_AUTH_COUNT ) entry -> fail_auth_count = kdb -> fail_auth_count ;\n if ( mask & KADM5_TL_DATA ) {\n krb5_tl_data * tl , * tl2 ;\n entry -> tl_data = NULL ;\n tl = kdb -> tl_data ;\n while ( tl ) {\n if ( tl -> tl_data_type > 255 ) {\n if ( ( tl2 = dup_tl_data ( tl ) ) == NULL ) {\n ret = ENOMEM ;\n goto done ;\n }\n tl2 -> tl_data_next = entry -> tl_data ;\n entry -> tl_data = tl2 ;\n entry -> n_tl_data ++ ;\n }\n tl = tl -> tl_data_next ;\n }\n }\n if ( mask & KADM5_KEY_DATA ) {\n entry -> n_key_data = kdb -> n_key_data ;\n if ( entry -> n_key_data ) {\n entry -> key_data = k5calloc ( entry -> n_key_data , sizeof ( krb5_key_data ) , & ret ) ;\n if ( entry -> key_data == NULL ) goto done ;\n }\n else entry -> key_data = NULL ;\n for ( i = 0 ;\n i < entry -> n_key_data ;\n i ++ ) ret = krb5_copy_key_data_contents ( handle -> context , & kdb -> key_data [ i ] , & entry -> key_data [ i ] ) ;\n if ( ret ) goto done ;\n }\n ret = KADM5_OK ;\n done : if ( ret && entry -> principal ) {\n krb5_free_principal ( handle -> context , entry -> principal ) ;\n entry -> principal = NULL ;\n }\n kdb_free_entry ( handle , kdb , & adb ) ;\n return ret ;\n }", "hash": 4704178797381506498, "project": "debian", "size": 89, "target": 0, "idx": 4493}
{"code": "static void free_history_entry ( krb5_context context , osa_pw_hist_ent * hist ) {\n int i ;\n for ( i = 0 ;\n i < hist -> n_key_data ;\n i ++ ) krb5_free_key_data_contents ( context , & hist -> key_data [ i ] ) ;\n free ( hist -> key_data ) ;\n }", "hash": 4704178797381506498, "project": "debian", "size": 7, "target": 0, "idx": 4499}
{"code": "kadm5_ret_t krb5_copy_key_data_contents ( context , from , to ) krb5_context context ;\n krb5_key_data * from , * to ;\n {\n int i , idx ;\n * to = * from ;\n idx = ( from -> key_data_ver == 1 ? 1 : 2 ) ;\n for ( i = 0 ;\n i < idx ;\n i ++ ) {\n if ( from -> key_data_length [ i ] ) {\n to -> key_data_contents [ i ] = malloc ( from -> key_data_length [ i ] ) ;\n if ( to -> key_data_contents [ i ] == NULL ) {\n for ( i = 0 ;\n i < idx ;\n i ++ ) {\n if ( to -> key_data_contents [ i ] ) {\n memset ( to -> key_data_contents [ i ] , 0 , to -> key_data_length [ i ] ) ;\n free ( to -> key_data_contents [ i ] ) ;\n }\n }\n return ENOMEM ;\n }\n memcpy ( to -> key_data_contents [ i ] , from -> key_data_contents [ i ] , from -> key_data_length [ i ] ) ;\n }\n }\n return 0 ;\n }", "hash": 4704178797381506498, "project": "debian", "size": 27, "target": 0, "idx": 4506}
{"code": "kadm5_ret_t kadm5_rename_principal ( void * server_handle , krb5_principal source , krb5_principal target ) {\n krb5_db_entry * kdb ;\n osa_princ_ent_rec adb ;\n krb5_error_code ret ;\n kadm5_server_handle_t handle = server_handle ;\n krb5_int16 stype , i ;\n krb5_data * salt = NULL ;\n krb5_tl_data tl ;\n CHECK_HANDLE ( server_handle ) ;\n krb5_clear_error_message ( handle -> context ) ;\n if ( source == NULL || target == NULL ) return EINVAL ;\n if ( ( ret = kdb_get_entry ( handle , target , & kdb , & adb ) ) == 0 ) {\n kdb_free_entry ( handle , kdb , & adb ) ;\n return ( KADM5_DUP ) ;\n }\n if ( ( ret = kdb_get_entry ( handle , source , & kdb , & adb ) ) ) return ret ;\n tl . tl_data_type = 0x7FFE ;\n if ( krb5_dbe_lookup_tl_data ( handle -> context , kdb , & tl ) == 0 && tl . tl_data_length > 0 ) {\n ret = KRB5_PLUGIN_OP_NOTSUPP ;\n goto done ;\n }\n for ( i = 0 ;\n i < kdb -> n_key_data ;\n i ++ ) {\n ret = krb5_dbe_compute_salt ( handle -> context , & kdb -> key_data [ i ] , kdb -> princ , & stype , & salt ) ;\n if ( ret == KRB5_KDB_BAD_SALTTYPE ) ret = KADM5_NO_RENAME_SALT ;\n if ( ret ) goto done ;\n kdb -> key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_SPECIAL ;\n free ( kdb -> key_data [ i ] . key_data_contents [ 1 ] ) ;\n kdb -> key_data [ i ] . key_data_contents [ 1 ] = ( krb5_octet * ) salt -> data ;\n kdb -> key_data [ i ] . key_data_length [ 1 ] = salt -> length ;\n kdb -> key_data [ i ] . key_data_ver = 2 ;\n free ( salt ) ;\n salt = NULL ;\n }\n kadm5_free_principal ( handle -> context , kdb -> princ ) ;\n ret = kadm5_copy_principal ( handle -> context , target , & kdb -> princ ) ;\n if ( ret ) {\n kdb -> princ = NULL ;\n goto done ;\n }\n ret = k5_kadm5_hook_rename ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , source , target ) ;\n if ( ret ) goto done ;\n if ( ( ret = kdb_put_entry ( handle , kdb , & adb ) ) ) goto done ;\n ( void ) k5_kadm5_hook_rename ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , source , target ) ;\n ret = kdb_delete_entry ( handle , source ) ;\n done : krb5_free_data ( handle -> context , salt ) ;\n kdb_free_entry ( handle , kdb , & adb ) ;\n return ret ;\n }", "hash": 4704178797381506498, "project": "debian", "size": 50, "target": 0, "idx": 4515}
{"code": "static kadm5_ret_t apply_keysalt_policy ( kadm5_server_handle_t handle , const char * policy , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , int * new_n_kstp , krb5_key_salt_tuple * * new_kstp ) {\n kadm5_ret_t ret ;\n kadm5_policy_ent_rec polent ;\n krb5_boolean have_polent ;\n int ak_n_ks_tuple = 0 ;\n int new_n_ks_tuple = 0 ;\n krb5_key_salt_tuple * ak_ks_tuple = NULL ;\n krb5_key_salt_tuple * new_ks_tuple = NULL ;\n krb5_key_salt_tuple * subset ;\n int i , m ;\n if ( new_n_kstp != NULL ) {\n * new_n_kstp = 0 ;\n * new_kstp = NULL ;\n }\n memset ( & polent , 0 , sizeof ( polent ) ) ;\n ret = get_policy ( handle , policy , & polent , & have_polent ) ;\n if ( ret ) goto cleanup ;\n if ( polent . allowed_keysalts == NULL ) {\n if ( n_ks_tuple == 0 ) {\n n_ks_tuple = handle -> params . num_keysalts ;\n ks_tuple = handle -> params . keysalts ;\n }\n new_ks_tuple = malloc ( n_ks_tuple * sizeof ( * new_ks_tuple ) ) ;\n if ( new_ks_tuple == NULL ) {\n ret = ENOMEM ;\n goto cleanup ;\n }\n memcpy ( new_ks_tuple , ks_tuple , n_ks_tuple * sizeof ( * new_ks_tuple ) ) ;\n new_n_ks_tuple = n_ks_tuple ;\n ret = 0 ;\n goto cleanup ;\n }\n ret = krb5_string_to_keysalts ( polent . allowed_keysalts , \",\" , NULL , 0 , & ak_ks_tuple , & ak_n_ks_tuple ) ;\n if ( ret ) goto cleanup ;\n for ( i = 0 ;\n i < n_ks_tuple ;\n i ++ ) {\n if ( ! ks_tuple_present ( ak_n_ks_tuple , ak_ks_tuple , & ks_tuple [ i ] ) ) {\n ret = KADM5_BAD_KEYSALTS ;\n goto cleanup ;\n }\n }\n if ( n_ks_tuple == 0 ) {\n new_n_ks_tuple = ak_n_ks_tuple ;\n new_ks_tuple = ak_ks_tuple ;\n ak_ks_tuple = NULL ;\n goto cleanup ;\n }\n subset = calloc ( n_ks_tuple , sizeof ( * subset ) ) ;\n if ( subset == NULL ) {\n ret = ENOMEM ;\n goto cleanup ;\n }\n for ( m = 0 , i = 0 ;\n i < ak_n_ks_tuple && m < n_ks_tuple ;\n i ++ ) {\n if ( ks_tuple_present ( n_ks_tuple , ks_tuple , & ak_ks_tuple [ i ] ) ) subset [ m ++ ] = ak_ks_tuple [ i ] ;\n }\n new_ks_tuple = subset ;\n new_n_ks_tuple = m ;\n ret = 0 ;\n cleanup : if ( have_polent ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ;\n free ( ak_ks_tuple ) ;\n if ( new_n_kstp != NULL ) {\n * new_n_kstp = new_n_ks_tuple ;\n * new_kstp = new_ks_tuple ;\n }\n else {\n free ( new_ks_tuple ) ;\n }\n return ret ;\n }", "hash": 4704178797381506498, "project": "debian", "size": 72, "target": 0, "idx": 4516}
{"code": "static unsigned int _warc_rdver ( const char * buf , size_t bsz ) {\n static const char magic [ ] = \"WARC/\" ;\n const char * c ;\n unsigned int ver = 0U ;\n unsigned int end = 0U ;\n if ( bsz < 12 || memcmp ( buf , magic , sizeof ( magic ) - 1U ) != 0 ) {\n return ver ;\n }\n buf += sizeof ( magic ) - 1U ;\n if ( isdigit ( ( unsigned char ) buf [ 0U ] ) && ( buf [ 1U ] == '.' ) && isdigit ( ( unsigned char ) buf [ 2U ] ) ) {\n if ( isdigit ( ( unsigned char ) buf [ 3U ] ) ) end = 1U ;\n ver = ( buf [ 0U ] - '0' ) * 10000U ;\n if ( end == 1U ) {\n ver += ( buf [ 2U ] - '0' ) * 1000U ;\n ver += ( buf [ 3U ] - '0' ) * 100U ;\n }\n else ver += ( buf [ 2U ] - '0' ) * 100U ;\n c = buf + 3U + end ;\n if ( ver >= 1200U ) {\n if ( memcmp ( c , \"\\r\\n\" , 2U ) != 0 ) ver = 0U ;\n }\n else if ( ver < 1200U ) {\n if ( * c != ' ' && * c != '\\t' ) ver = 0U ;\n }\n }\n return ver ;\n }", "hash": 5605949879237783359, "project": "debian", "size": 27, "target": 0, "idx": 4527}
{"code": "static ssize_t _warc_rdlen ( const char * buf , size_t bsz ) {\n static const char _key [ ] = \"\\r\\nContent-Length:\" ;\n const char * val , * eol ;\n char * on = NULL ;\n long int len ;\n if ( ( val = xmemmem ( buf , bsz , _key , sizeof ( _key ) - 1U ) ) == NULL ) {\n return - 1 ;\n }\n val += sizeof ( _key ) - 1U ;\n if ( ( eol = _warc_find_eol ( val , buf + bsz - val ) ) == NULL ) {\n return - 1 ;\n }\n while ( val < eol && ( * val == ' ' || * val == '\\t' ) ) val ++ ;\n if ( ! isdigit ( ( unsigned char ) * val ) ) return - 1 ;\n len = strtol ( val , & on , 10 ) ;\n if ( on != eol ) {\n return - 1 ;\n }\n return ( size_t ) len ;\n }", "hash": 5605949879237783359, "project": "debian", "size": 20, "target": 0, "idx": 4532}
{"code": "int upx_inflate2e ( const char * src , uint32_t ssize , char * dst , uint32_t * dsize , uint32_t upx0 , uint32_t upx1 , uint32_t ep ) {\n int32_t backbytes , unp_offset = - 1 ;\n uint32_t backsize , myebx = 0 , scur = 0 , dcur = 0 , i , magic [ ] = {\n 0x128 , 0x130 , 0 }\n ;\n int oob ;\n for ( ;\n ;\n ) {\n while ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) ) {\n if ( oob == - 1 ) return - 1 ;\n if ( scur >= ssize || dcur >= * dsize ) return - 1 ;\n dst [ dcur ++ ] = src [ scur ++ ] ;\n }\n backbytes = 1 ;\n for ( ;\n ;\n ) {\n if ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) == - 1 ) return - 1 ;\n backbytes = backbytes * 2 + oob ;\n if ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) == - 1 ) return - 1 ;\n if ( oob ) break ;\n backbytes -- ;\n if ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) == - 1 ) return - 1 ;\n backbytes = backbytes * 2 + oob ;\n }\n backbytes -= 3 ;\n if ( backbytes >= 0 ) {\n if ( scur >= ssize ) return - 1 ;\n backbytes <<= 8 ;\n backbytes += ( unsigned char ) ( src [ scur ++ ] ) ;\n backbytes ^= 0xffffffff ;\n if ( ! backbytes ) break ;\n backsize = backbytes & 1 ;\n CLI_SAR ( backbytes , 1 ) ;\n unp_offset = backbytes ;\n }\n else {\n if ( ( backsize = ( uint32_t ) doubleebx ( src , & myebx , & scur , ssize ) ) == 0xffffffff ) return - 1 ;\n }\n if ( backsize ) {\n if ( ( backsize = ( uint32_t ) doubleebx ( src , & myebx , & scur , ssize ) ) == 0xffffffff ) return - 1 ;\n }\n else {\n backsize = 1 ;\n if ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) == - 1 ) return - 1 ;\n if ( oob ) {\n if ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) == - 1 ) return - 1 ;\n backsize = 2 + oob ;\n }\n else {\n do {\n if ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) == - 1 ) return - 1 ;\n backsize = backsize * 2 + oob ;\n }\n while ( ( oob = doubleebx ( src , & myebx , & scur , ssize ) ) == 0 ) ;\n if ( oob == - 1 ) return - 1 ;\n backsize += 2 ;\n }\n }\n if ( ( uint32_t ) unp_offset < 0xfffffb00 ) backsize ++ ;\n backsize += 2 ;\n if ( ! CLI_ISCONTAINED ( dst , * dsize , dst + dcur + unp_offset , backsize ) || ! CLI_ISCONTAINED ( dst , * dsize , dst + dcur , backsize ) || unp_offset >= 0 ) return - 1 ;\n for ( i = 0 ;\n i < backsize ;\n i ++ ) dst [ dcur + i ] = dst [ dcur + unp_offset + i ] ;\n dcur += backsize ;\n }\n return pefromupx ( src , ssize , dst , dsize , ep , upx0 , upx1 , magic , dcur ) ;\n }", "hash": -8745685032143262400, "project": "debian", "size": 70, "target": 0, "idx": 4544}
{"code": "gpg_err_code_t _gcry_ecc_fill_in_curve ( unsigned int nbits , const char * name , elliptic_curve_t * curve , unsigned int * r_nbits ) {\n int idx , aliasno ;\n const char * resname = NULL ;\n if ( name ) {\n for ( idx = 0 ;\n domain_parms [ idx ] . desc ;\n idx ++ ) if ( ! strcmp ( name , domain_parms [ idx ] . desc ) ) {\n resname = domain_parms [ idx ] . desc ;\n break ;\n }\n if ( ! domain_parms [ idx ] . desc ) {\n for ( aliasno = 0 ;\n curve_aliases [ aliasno ] . name ;\n aliasno ++ ) if ( ! strcmp ( name , curve_aliases [ aliasno ] . other ) ) break ;\n if ( curve_aliases [ aliasno ] . name ) {\n for ( idx = 0 ;\n domain_parms [ idx ] . desc ;\n idx ++ ) if ( ! strcmp ( curve_aliases [ aliasno ] . name , domain_parms [ idx ] . desc ) ) {\n resname = domain_parms [ idx ] . desc ;\n break ;\n }\n }\n }\n }\n else {\n for ( idx = 0 ;\n domain_parms [ idx ] . desc ;\n idx ++ ) if ( nbits == domain_parms [ idx ] . nbits && domain_parms [ idx ] . model == MPI_EC_WEIERSTRASS ) break ;\n }\n if ( ! domain_parms [ idx ] . desc ) return GPG_ERR_UNKNOWN_CURVE ;\n if ( fips_mode ( ) && ! domain_parms [ idx ] . fips ) return GPG_ERR_NOT_SUPPORTED ;\n switch ( domain_parms [ idx ] . model ) {\n case MPI_EC_WEIERSTRASS : case MPI_EC_TWISTEDEDWARDS : break ;\n case MPI_EC_MONTGOMERY : return GPG_ERR_NOT_SUPPORTED ;\n default : return GPG_ERR_BUG ;\n }\n if ( r_nbits ) * r_nbits = domain_parms [ idx ] . nbits ;\n curve -> model = domain_parms [ idx ] . model ;\n curve -> p = scanval ( domain_parms [ idx ] . p ) ;\n curve -> a = scanval ( domain_parms [ idx ] . a ) ;\n curve -> b = scanval ( domain_parms [ idx ] . b ) ;\n curve -> n = scanval ( domain_parms [ idx ] . n ) ;\n curve -> G . x = scanval ( domain_parms [ idx ] . g_x ) ;\n curve -> G . y = scanval ( domain_parms [ idx ] . g_y ) ;\n curve -> G . z = mpi_alloc_set_ui ( 1 ) ;\n curve -> name = resname ;\n return 0 ;\n }", "hash": -8863722328038948117, "project": "debian", "size": 48, "target": 0, "idx": 4546}
{"code": "gcry_err_code_t _gcry_ecc_get_param ( const char * name , gcry_mpi_t * pkey ) {\n gpg_err_code_t err ;\n unsigned int nbits ;\n elliptic_curve_t E ;\n mpi_ec_t ctx ;\n gcry_mpi_t g_x , g_y ;\n err = _gcry_ecc_fill_in_curve ( 0 , name , & E , & nbits ) ;\n if ( err ) return err ;\n g_x = mpi_new ( 0 ) ;\n g_y = mpi_new ( 0 ) ;\n ctx = _gcry_mpi_ec_p_internal_new ( 0 , E . p , E . a , NULL ) ;\n if ( _gcry_mpi_ec_get_affine ( g_x , g_y , & E . G , ctx ) ) log_fatal ( \"ecc get param: Failed to get affine coordinates\\n\" ) ;\n _gcry_mpi_ec_free ( ctx ) ;\n _gcry_mpi_point_free_parts ( & E . G ) ;\n pkey [ 0 ] = E . p ;\n pkey [ 1 ] = E . a ;\n pkey [ 2 ] = E . b ;\n pkey [ 3 ] = _gcry_ecc_ec2os ( g_x , g_y , E . p ) ;\n pkey [ 4 ] = E . n ;\n pkey [ 5 ] = NULL ;\n mpi_free ( g_x ) ;\n mpi_free ( g_y ) ;\n return 0 ;\n }", "hash": -8863722328038948117, "project": "debian", "size": 24, "target": 0, "idx": 4551}
{"code": "static int get_and_cmp_point ( const char * name , const char * mpi_x_string , const char * mpi_y_string , const char * desc , gcry_ctx_t ctx ) {\n gcry_mpi_point_t point ;\n gcry_mpi_t x , y , z ;\n int result = 0 ;\n point = gcry_mpi_ec_get_point ( name , ctx , 1 ) ;\n if ( ! point ) {\n fail ( \"error getting point parameter '%s' of curve '%s'\\n\" , name , desc ) ;\n return 1 ;\n }\n if ( debug ) print_point ( name , point ) ;\n x = gcry_mpi_new ( 0 ) ;\n y = gcry_mpi_new ( 0 ) ;\n z = gcry_mpi_new ( 0 ) ;\n gcry_mpi_point_snatch_get ( x , y , z , point ) ;\n if ( cmp_mpihex ( x , mpi_x_string ) ) {\n fail ( \"x coordinate of '%s' of curve '%s' does not match\\n\" , name , desc ) ;\n result = 1 ;\n }\n if ( cmp_mpihex ( y , mpi_y_string ) ) {\n fail ( \"y coordinate of '%s' of curve '%s' does not match\\n\" , name , desc ) ;\n result = 1 ;\n }\n if ( cmp_mpihex ( z , \"01\" ) ) {\n fail ( \"z coordinate of '%s' of curve '%s' is not 1\\n\" , name , desc ) ;\n result = 1 ;\n }\n gcry_mpi_release ( x ) ;\n gcry_mpi_release ( y ) ;\n gcry_mpi_release ( z ) ;\n return result ;\n }", "hash": -6474315190511670247, "project": "debian", "size": 31, "target": 0, "idx": 4553}
{"code": "static int cmp_mpihex ( gcry_mpi_t a , const char * b ) {\n gcry_mpi_t bval ;\n int res ;\n bval = hex2mpi ( b ) ;\n res = gcry_mpi_cmp ( a , bval ) ;\n gcry_mpi_release ( bval ) ;\n return res ;\n }", "hash": -6474315190511670247, "project": "debian", "size": 8, "target": 0, "idx": 4561}
{"code": "static void die ( const char * format , ... ) {\n va_list arg_ptr ;\n fflush ( stdout ) ;\n fprintf ( stderr , \"%s: \" , PGM ) ;\n if ( wherestr ) fprintf ( stderr , \"%s: \" , wherestr ) ;\n va_start ( arg_ptr , format ) ;\n vfprintf ( stderr , format , arg_ptr ) ;\n va_end ( arg_ptr ) ;\n exit ( 1 ) ;\n }", "hash": -6474315190511670247, "project": "debian", "size": 10, "target": 0, "idx": 4563}
{"code": "static void print_mpi ( const char * text , gcry_mpi_t a ) {\n print_mpi_2 ( text , NULL , a ) ;\n }", "hash": -6474315190511670247, "project": "debian", "size": 3, "target": 0, "idx": 4567}
{"code": "gcry_error_t gcry_mpi_scan ( struct gcry_mpi * * ret_mpi , enum gcry_mpi_format format , const void * buffer_arg , size_t buflen , size_t * nscanned ) {\n const unsigned char * buffer = ( const unsigned char * ) buffer_arg ;\n struct gcry_mpi * a = NULL ;\n unsigned int len ;\n int secure = ( buffer && gcry_is_secure ( buffer ) ) ;\n if ( format == GCRYMPI_FMT_SSH ) len = 0 ;\n else len = buflen ;\n if ( format == GCRYMPI_FMT_STD ) {\n const unsigned char * s = buffer ;\n a = secure ? mpi_alloc_secure ( ( len + BYTES_PER_MPI_LIMB - 1 ) / BYTES_PER_MPI_LIMB ) : mpi_alloc ( ( len + BYTES_PER_MPI_LIMB - 1 ) / BYTES_PER_MPI_LIMB ) ;\n if ( len ) {\n a -> sign = ! ! ( * s & 0x80 ) ;\n if ( a -> sign ) {\n mpi_free ( a ) ;\n return gcry_error ( GPG_ERR_INTERNAL ) ;\n }\n else _gcry_mpi_set_buffer ( a , s , len , 0 ) ;\n }\n if ( ret_mpi ) {\n mpi_normalize ( a ) ;\n * ret_mpi = a ;\n }\n else mpi_free ( a ) ;\n return 0 ;\n }\n else if ( format == GCRYMPI_FMT_USG ) {\n a = secure ? mpi_alloc_secure ( ( len + BYTES_PER_MPI_LIMB - 1 ) / BYTES_PER_MPI_LIMB ) : mpi_alloc ( ( len + BYTES_PER_MPI_LIMB - 1 ) / BYTES_PER_MPI_LIMB ) ;\n if ( len ) _gcry_mpi_set_buffer ( a , buffer , len , 0 ) ;\n if ( ret_mpi ) {\n mpi_normalize ( a ) ;\n * ret_mpi = a ;\n }\n else mpi_free ( a ) ;\n return 0 ;\n }\n else if ( format == GCRYMPI_FMT_PGP ) {\n a = mpi_read_from_buffer ( buffer , & len , secure ) ;\n if ( nscanned ) * nscanned = len ;\n if ( ret_mpi && a ) {\n mpi_normalize ( a ) ;\n * ret_mpi = a ;\n }\n else if ( a ) {\n mpi_free ( a ) ;\n a = NULL ;\n }\n return a ? 0 : gcry_error ( GPG_ERR_INV_OBJ ) ;\n }\n else if ( format == GCRYMPI_FMT_SSH ) {\n const unsigned char * s = buffer ;\n size_t n ;\n if ( len && len < 4 ) return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n n = ( s [ 0 ] << 24 | s [ 1 ] << 16 | s [ 2 ] << 8 | s [ 3 ] ) ;\n s += 4 ;\n if ( len ) len -= 4 ;\n if ( len && n > len ) return gcry_error ( GPG_ERR_TOO_LARGE ) ;\n a = secure ? mpi_alloc_secure ( ( n + BYTES_PER_MPI_LIMB - 1 ) / BYTES_PER_MPI_LIMB ) : mpi_alloc ( ( n + BYTES_PER_MPI_LIMB - 1 ) / BYTES_PER_MPI_LIMB ) ;\n if ( n ) {\n a -> sign = ! ! ( * s & 0x80 ) ;\n if ( a -> sign ) {\n mpi_free ( a ) ;\n return gcry_error ( GPG_ERR_INTERNAL ) ;\n }\n else _gcry_mpi_set_buffer ( a , s , n , 0 ) ;\n }\n if ( nscanned ) * nscanned = n + 4 ;\n if ( ret_mpi ) {\n mpi_normalize ( a ) ;\n * ret_mpi = a ;\n }\n else mpi_free ( a ) ;\n return 0 ;\n }\n else if ( format == GCRYMPI_FMT_HEX ) {\n if ( buflen ) return gcry_error ( GPG_ERR_INV_ARG ) ;\n a = secure ? mpi_alloc_secure ( 0 ) : mpi_alloc ( 0 ) ;\n if ( mpi_fromstr ( a , ( const char * ) buffer ) ) {\n mpi_free ( a ) ;\n return gcry_error ( GPG_ERR_INV_OBJ ) ;\n }\n if ( ret_mpi ) {\n mpi_normalize ( a ) ;\n * ret_mpi = a ;\n }\n else mpi_free ( a ) ;\n return 0 ;\n }\n else return gcry_error ( GPG_ERR_INV_ARG ) ;\n }", "hash": 1460203986417252430, "project": "debian", "size": 89, "target": 0, "idx": 4576}
{"code": "gcry_error_t gcry_mpi_aprint ( enum gcry_mpi_format format , unsigned char * * buffer , size_t * nwritten , struct gcry_mpi * a ) {\n size_t n ;\n gcry_error_t rc ;\n * buffer = NULL ;\n rc = gcry_mpi_print ( format , NULL , 0 , & n , a ) ;\n if ( rc ) return rc ;\n * buffer = mpi_is_secure ( a ) ? gcry_malloc_secure ( n ? n : 1 ) : gcry_malloc ( n ? n : 1 ) ;\n if ( ! * buffer ) return gpg_error_from_syserror ( ) ;\n rc = gcry_mpi_print ( format , * buffer , n , & n , a ) ;\n if ( rc ) {\n gcry_free ( * buffer ) ;\n * buffer = NULL ;\n }\n else if ( nwritten ) * nwritten = n ;\n return rc ;\n }", "hash": 1460203986417252430, "project": "debian", "size": 16, "target": 0, "idx": 4579}
{"code": "static gcry_err_code_t dummy_decrypt ( int algorithm , gcry_mpi_t * result , gcry_mpi_t * data , gcry_mpi_t * skey , int flags ) {\n ( void ) algorithm ;\n ( void ) result ;\n ( void ) data ;\n ( void ) skey ;\n ( void ) flags ;\n fips_signal_error ( \"using dummy public key function\" ) ;\n return GPG_ERR_NOT_IMPLEMENTED ;\n }", "hash": -7795592811940874822, "project": "debian", "size": 9, "target": 0, "idx": 4584}
{"code": "static gcry_err_code_t pss_verify ( gcry_mpi_t value , gcry_mpi_t encoded , unsigned int nbits , int algo , size_t saltlen ) {\n gcry_err_code_t rc = 0 ;\n size_t hlen ;\n unsigned char * em = NULL ;\n size_t emlen = ( nbits + 7 ) / 8 ;\n unsigned char * salt ;\n unsigned char * h ;\n unsigned char * buf = NULL ;\n size_t buflen ;\n unsigned char * dbmask ;\n unsigned char * mhash ;\n unsigned char * p ;\n size_t n ;\n hlen = gcry_md_get_algo_dlen ( algo ) ;\n gcry_assert ( hlen ) ;\n buflen = 8 + hlen + saltlen ;\n if ( buflen < emlen - hlen - 1 ) buflen = emlen - hlen - 1 ;\n buflen += hlen ;\n buf = gcry_malloc ( buflen ) ;\n if ( ! buf ) {\n rc = gpg_err_code_from_syserror ( ) ;\n goto leave ;\n }\n dbmask = buf ;\n mhash = buf + buflen - hlen ;\n rc = octet_string_from_mpi ( NULL , mhash , value , hlen ) ;\n if ( rc ) goto leave ;\n rc = octet_string_from_mpi ( & em , NULL , encoded , emlen ) ;\n if ( rc ) goto leave ;\n if ( emlen < hlen + saltlen + 2 ) {\n rc = GPG_ERR_TOO_SHORT ;\n goto leave ;\n }\n if ( em [ emlen - 1 ] != 0xbc ) {\n rc = GPG_ERR_BAD_SIGNATURE ;\n goto leave ;\n }\n h = em + emlen - 1 - hlen ;\n if ( ( em [ 0 ] & ~ ( 0xFF >> ( 8 * emlen - nbits ) ) ) ) {\n rc = GPG_ERR_BAD_SIGNATURE ;\n goto leave ;\n }\n mgf1 ( dbmask , emlen - hlen - 1 , h , hlen , algo ) ;\n for ( n = 0 , p = dbmask ;\n n < emlen - hlen - 1 ;\n n ++ , p ++ ) em [ n ] ^= * p ;\n em [ 0 ] &= 0xFF >> ( 8 * emlen - nbits ) ;\n for ( n = 0 ;\n n < emlen - hlen - saltlen - 2 && ! em [ n ] ;\n n ++ ) ;\n if ( n != emlen - hlen - saltlen - 2 || em [ n ++ ] != 1 ) {\n rc = GPG_ERR_BAD_SIGNATURE ;\n goto leave ;\n }\n salt = em + n ;\n memset ( buf , 0 , 8 ) ;\n memcpy ( buf + 8 , mhash , hlen ) ;\n memcpy ( buf + 8 + hlen , salt , saltlen ) ;\n gcry_md_hash_buffer ( algo , buf , buf , 8 + hlen + saltlen ) ;\n rc = memcmp ( h , buf , hlen ) ? GPG_ERR_BAD_SIGNATURE : GPG_ERR_NO_ERROR ;\n leave : if ( em ) {\n wipememory ( em , emlen ) ;\n gcry_free ( em ) ;\n }\n if ( buf ) {\n wipememory ( buf , buflen ) ;\n gcry_free ( buf ) ;\n }\n return rc ;\n }", "hash": -7795592811940874822, "project": "debian", "size": 70, "target": 0, "idx": 4589}
{"code": "static gcry_err_code_t sexp_data_to_mpi ( gcry_sexp_t input , gcry_mpi_t * ret_mpi , struct pk_encoding_ctx * ctx ) {\n gcry_err_code_t rc = 0 ;\n gcry_sexp_t ldata , lhash , lvalue ;\n int i ;\n size_t n ;\n const char * s ;\n int unknown_flag = 0 ;\n int parsed_flags = 0 ;\n int explicit_raw = 0 ;\n * ret_mpi = NULL ;\n ldata = gcry_sexp_find_token ( input , \"data\" , 0 ) ;\n if ( ! ldata ) {\n * ret_mpi = gcry_sexp_nth_mpi ( input , 0 , 0 ) ;\n return * ret_mpi ? GPG_ERR_NO_ERROR : GPG_ERR_INV_OBJ ;\n }\n {\n gcry_sexp_t lflags = gcry_sexp_find_token ( ldata , \"flags\" , 0 ) ;\n if ( lflags ) {\n for ( i = gcry_sexp_length ( lflags ) - 1 ;\n i > 0 ;\n i -- ) {\n s = gcry_sexp_nth_data ( lflags , i , & n ) ;\n if ( ! s ) ;\n else if ( n == 7 && ! memcmp ( s , \"rfc6979\" , 7 ) ) parsed_flags |= PUBKEY_FLAG_RFC6979 ;\n else if ( n == 5 && ! memcmp ( s , \"eddsa\" , 5 ) ) {\n ctx -> encoding = PUBKEY_ENC_RAW ;\n parsed_flags |= PUBKEY_FLAG_EDDSA ;\n }\n else if ( n == 3 && ! memcmp ( s , \"raw\" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) {\n ctx -> encoding = PUBKEY_ENC_RAW ;\n explicit_raw = 1 ;\n }\n else if ( n == 5 && ! memcmp ( s , \"pkcs1\" , 5 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PKCS1 ;\n else if ( n == 4 && ! memcmp ( s , \"oaep\" , 4 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_OAEP ;\n else if ( n == 3 && ! memcmp ( s , \"pss\" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PSS ;\n else if ( n == 11 && ! memcmp ( s , \"no-blinding\" , 11 ) ) parsed_flags |= PUBKEY_FLAG_NO_BLINDING ;\n else unknown_flag = 1 ;\n }\n gcry_sexp_release ( lflags ) ;\n }\n }\n if ( ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_RAW ;\n lhash = gcry_sexp_find_token ( ldata , \"hash\" , 0 ) ;\n lvalue = lhash ? NULL : gcry_sexp_find_token ( ldata , \"value\" , 0 ) ;\n if ( ! ( ! lhash ^ ! lvalue ) ) rc = GPG_ERR_INV_OBJ ;\n else if ( unknown_flag ) rc = GPG_ERR_INV_FLAG ;\n else if ( ctx -> encoding == PUBKEY_ENC_RAW && ( parsed_flags & PUBKEY_FLAG_EDDSA ) ) {\n gcry_sexp_t list ;\n void * value ;\n size_t valuelen ;\n if ( ! lvalue ) {\n rc = GPG_ERR_INV_OBJ ;\n goto leave ;\n }\n list = gcry_sexp_find_token ( ldata , \"hash-algo\" , 0 ) ;\n if ( list ) {\n s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n else {\n ctx -> hash_algo = get_hash_algo ( s , n ) ;\n if ( ! ctx -> hash_algo ) rc = GPG_ERR_DIGEST_ALGO ;\n }\n gcry_sexp_release ( list ) ;\n }\n else rc = GPG_ERR_INV_OBJ ;\n if ( rc ) goto leave ;\n value = gcry_sexp_nth_buffer ( lvalue , 1 , & valuelen ) ;\n if ( ! value ) {\n valuelen = 0 ;\n value = gcry_malloc ( 1 ) ;\n if ( ! value ) rc = gpg_err_code_from_syserror ( ) ;\n }\n else if ( ( valuelen * 8 ) < valuelen ) {\n gcry_free ( value ) ;\n rc = GPG_ERR_TOO_LARGE ;\n }\n if ( rc ) goto leave ;\n * ret_mpi = gcry_mpi_set_opaque ( NULL , value , valuelen * 8 ) ;\n }\n else if ( ctx -> encoding == PUBKEY_ENC_RAW && lhash && ( explicit_raw || ( parsed_flags & PUBKEY_FLAG_RFC6979 ) ) ) {\n if ( gcry_sexp_length ( lhash ) != 3 ) rc = GPG_ERR_INV_OBJ ;\n else if ( ! ( s = gcry_sexp_nth_data ( lhash , 1 , & n ) ) || ! n ) rc = GPG_ERR_INV_OBJ ;\n else {\n void * value ;\n size_t valuelen ;\n ctx -> hash_algo = get_hash_algo ( s , n ) ;\n if ( ! ctx -> hash_algo ) rc = GPG_ERR_DIGEST_ALGO ;\n else if ( ! ( value = gcry_sexp_nth_buffer ( lhash , 2 , & valuelen ) ) ) rc = GPG_ERR_INV_OBJ ;\n else if ( ( valuelen * 8 ) < valuelen ) {\n gcry_free ( value ) ;\n rc = GPG_ERR_TOO_LARGE ;\n }\n else * ret_mpi = gcry_mpi_set_opaque ( NULL , value , valuelen * 8 ) ;\n }\n }\n else if ( ctx -> encoding == PUBKEY_ENC_RAW && lvalue ) {\n if ( parsed_flags & PUBKEY_FLAG_RFC6979 ) {\n rc = GPG_ERR_CONFLICT ;\n goto leave ;\n }\n * ret_mpi = gcry_sexp_nth_mpi ( lvalue , 1 , GCRYMPI_FMT_USG ) ;\n if ( ! * ret_mpi ) rc = GPG_ERR_INV_OBJ ;\n }\n else if ( ctx -> encoding == PUBKEY_ENC_PKCS1 && lvalue && ctx -> op == PUBKEY_OP_ENCRYPT ) {\n const void * value ;\n size_t valuelen ;\n gcry_sexp_t list ;\n void * random_override = NULL ;\n size_t random_override_len = 0 ;\n if ( ! ( value = gcry_sexp_nth_data ( lvalue , 1 , & valuelen ) ) || ! valuelen ) rc = GPG_ERR_INV_OBJ ;\n else {\n list = gcry_sexp_find_token ( ldata , \"random-override\" , 0 ) ;\n if ( list ) {\n s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n else if ( n > 0 ) {\n random_override = gcry_malloc ( n ) ;\n if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n else {\n memcpy ( random_override , s , n ) ;\n random_override_len = n ;\n }\n }\n gcry_sexp_release ( list ) ;\n if ( rc ) goto leave ;\n }\n rc = pkcs1_encode_for_encryption ( ret_mpi , ctx -> nbits , value , valuelen , random_override , random_override_len ) ;\n gcry_free ( random_override ) ;\n }\n }\n else if ( ctx -> encoding == PUBKEY_ENC_PKCS1 && lhash && ( ctx -> op == PUBKEY_OP_SIGN || ctx -> op == PUBKEY_OP_VERIFY ) ) {\n if ( gcry_sexp_length ( lhash ) != 3 ) rc = GPG_ERR_INV_OBJ ;\n else if ( ! ( s = gcry_sexp_nth_data ( lhash , 1 , & n ) ) || ! n ) rc = GPG_ERR_INV_OBJ ;\n else {\n const void * value ;\n size_t valuelen ;\n ctx -> hash_algo = get_hash_algo ( s , n ) ;\n if ( ! ctx -> hash_algo ) rc = GPG_ERR_DIGEST_ALGO ;\n else if ( ! ( value = gcry_sexp_nth_data ( lhash , 2 , & valuelen ) ) || ! valuelen ) rc = GPG_ERR_INV_OBJ ;\n else rc = pkcs1_encode_for_signature ( ret_mpi , ctx -> nbits , value , valuelen , ctx -> hash_algo ) ;\n }\n }\n else if ( ctx -> encoding == PUBKEY_ENC_OAEP && lvalue && ctx -> op == PUBKEY_OP_ENCRYPT ) {\n const void * value ;\n size_t valuelen ;\n if ( ! ( value = gcry_sexp_nth_data ( lvalue , 1 , & valuelen ) ) || ! valuelen ) rc = GPG_ERR_INV_OBJ ;\n else {\n gcry_sexp_t list ;\n void * random_override = NULL ;\n size_t random_override_len = 0 ;\n list = gcry_sexp_find_token ( ldata , \"hash-algo\" , 0 ) ;\n if ( list ) {\n s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n else {\n ctx -> hash_algo = get_hash_algo ( s , n ) ;\n if ( ! ctx -> hash_algo ) rc = GPG_ERR_DIGEST_ALGO ;\n }\n gcry_sexp_release ( list ) ;\n if ( rc ) goto leave ;\n }\n list = gcry_sexp_find_token ( ldata , \"label\" , 0 ) ;\n if ( list ) {\n s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n else if ( n > 0 ) {\n ctx -> label = gcry_malloc ( n ) ;\n if ( ! ctx -> label ) rc = gpg_err_code_from_syserror ( ) ;\n else {\n memcpy ( ctx -> label , s , n ) ;\n ctx -> labellen = n ;\n }\n }\n gcry_sexp_release ( list ) ;\n if ( rc ) goto leave ;\n }\n list = gcry_sexp_find_token ( ldata , \"random-override\" , 0 ) ;\n if ( list ) {\n s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n else if ( n > 0 ) {\n random_override = gcry_malloc ( n ) ;\n if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n else {\n memcpy ( random_override , s , n ) ;\n random_override_len = n ;\n }\n }\n gcry_sexp_release ( list ) ;\n if ( rc ) goto leave ;\n }\n rc = oaep_encode ( ret_mpi , ctx -> nbits , ctx -> hash_algo , value , valuelen , ctx -> label , ctx -> labellen , random_override , random_override_len ) ;\n gcry_free ( random_override ) ;\n }\n }\n else if ( ctx -> encoding == PUBKEY_ENC_PSS && lhash && ctx -> op == PUBKEY_OP_SIGN ) {\n if ( gcry_sexp_length ( lhash ) != 3 ) rc = GPG_ERR_INV_OBJ ;\n else if ( ! ( s = gcry_sexp_nth_data ( lhash , 1 , & n ) ) || ! n ) rc = GPG_ERR_INV_OBJ ;\n else {\n const void * value ;\n size_t valuelen ;\n void * random_override = NULL ;\n size_t random_override_len = 0 ;\n ctx -> hash_algo = get_hash_algo ( s , n ) ;\n if ( ! ctx -> hash_algo ) rc = GPG_ERR_DIGEST_ALGO ;\n else if ( ! ( value = gcry_sexp_nth_data ( lhash , 2 , & valuelen ) ) || ! valuelen ) rc = GPG_ERR_INV_OBJ ;\n else {\n gcry_sexp_t list ;\n list = gcry_sexp_find_token ( ldata , \"salt-length\" , 0 ) ;\n if ( list ) {\n s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n if ( ! s ) {\n rc = GPG_ERR_NO_OBJ ;\n goto leave ;\n }\n ctx -> saltlen = ( unsigned int ) strtoul ( s , NULL , 10 ) ;\n gcry_sexp_release ( list ) ;\n }\n list = gcry_sexp_find_token ( ldata , \"random-override\" , 0 ) ;\n if ( list ) {\n s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n else if ( n > 0 ) {\n random_override = gcry_malloc ( n ) ;\n if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n else {\n memcpy ( random_override , s , n ) ;\n random_override_len = n ;\n }\n }\n gcry_sexp_release ( list ) ;\n if ( rc ) goto leave ;\n }\n rc = pss_encode ( ret_mpi , ctx -> nbits - 1 , ctx -> hash_algo , value , valuelen , ctx -> saltlen , random_override , random_override_len ) ;\n gcry_free ( random_override ) ;\n }\n }\n }\n else if ( ctx -> encoding == PUBKEY_ENC_PSS && lhash && ctx -> op == PUBKEY_OP_VERIFY ) {\n if ( gcry_sexp_length ( lhash ) != 3 ) rc = GPG_ERR_INV_OBJ ;\n else if ( ! ( s = gcry_sexp_nth_data ( lhash , 1 , & n ) ) || ! n ) rc = GPG_ERR_INV_OBJ ;\n else {\n ctx -> hash_algo = get_hash_algo ( s , n ) ;\n if ( ! ctx -> hash_algo ) rc = GPG_ERR_DIGEST_ALGO ;\n else {\n * ret_mpi = gcry_sexp_nth_mpi ( lhash , 2 , GCRYMPI_FMT_USG ) ;\n if ( ! * ret_mpi ) rc = GPG_ERR_INV_OBJ ;\n ctx -> verify_cmp = pss_verify_cmp ;\n ctx -> verify_arg = * ret_mpi ;\n }\n }\n }\n else rc = GPG_ERR_CONFLICT ;\n leave : gcry_sexp_release ( ldata ) ;\n gcry_sexp_release ( lhash ) ;\n gcry_sexp_release ( lvalue ) ;\n if ( ! rc ) ctx -> flags = parsed_flags ;\n else {\n gcry_free ( ctx -> label ) ;\n ctx -> label = NULL ;\n }\n return rc ;\n }", "hash": -7795592811940874822, "project": "debian", "size": 263, "target": 0, "idx": 4609}
{"code": "static void release_mpi_array ( gcry_mpi_t * array ) {\n for ( ;\n * array ;\n array ++ ) {\n mpi_free ( * array ) ;\n * array = NULL ;\n }\n }", "hash": -7795592811940874822, "project": "debian", "size": 8, "target": 0, "idx": 4617}
{"code": "void * gcry_sexp_nth_buffer ( const gcry_sexp_t list , int number , size_t * rlength ) {\n const char * s ;\n size_t n ;\n char * buf ;\n * rlength = 0 ;\n s = sexp_nth_data ( list , number , & n ) ;\n if ( ! s || ! n ) return NULL ;\n buf = gcry_malloc ( n ) ;\n if ( ! buf ) return NULL ;\n memcpy ( buf , s , n ) ;\n * rlength = n ;\n return buf ;\n }", "hash": -16551315108292821, "project": "debian", "size": 13, "target": 0, "idx": 4653}
{"code": "void gcry_sexp_dump ( const gcry_sexp_t a ) {\n const byte * p ;\n int indent = 0 ;\n int type ;\n if ( ! a ) {\n log_printf ( \"[nil]\\n\" ) ;\n return ;\n }\n p = a -> d ;\n while ( ( type = * p ) != ST_STOP ) {\n p ++ ;\n switch ( type ) {\n case ST_OPEN : log_printf ( \"%*s[open]\\n\" , 2 * indent , \"\" ) ;\n indent ++ ;\n break ;\n case ST_CLOSE : if ( indent ) indent -- ;\n log_printf ( \"%*s[close]\\n\" , 2 * indent , \"\" ) ;\n break ;\n case ST_DATA : {\n DATALEN n ;\n memcpy ( & n , p , sizeof n ) ;\n p += sizeof n ;\n log_printf ( \"%*s[data=\\\"\" , 2 * indent , \"\" ) ;\n dump_string ( p , n , '\\\"' ) ;\n log_printf ( \"\\\"]\\n\" ) ;\n p += n ;\n }\n break ;\n default : log_printf ( \"%*s[unknown tag %d]\\n\" , 2 * indent , \"\" , type ) ;\n break ;\n }\n }\n }", "hash": -16551315108292821, "project": "debian", "size": 33, "target": 0, "idx": 4665}
{"code": "const char * gcry_sexp_nth_data ( const gcry_sexp_t list , int number , size_t * datalen ) {\n return sexp_nth_data ( list , number , datalen ) ;\n }", "hash": -16551315108292821, "project": "debian", "size": 3, "target": 0, "idx": 4675}
{"code": "static guint32 dissect_netb_name_resp ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {\n guint8 local_session_number = tvb_get_guint8 ( tvb , offset + NB_DATA2 ) ;\n switch ( local_session_number ) {\n case 0x00 : proto_tree_add_uint_format_value ( tree , hf_netb_state_of_name , tvb , offset + NB_DATA2 , 1 , local_session_number , \"No LISTEN pending, or FIND.NAME response\" ) ;\n break ;\n case 0xFF : proto_tree_add_uint_format_value ( tree , hf_netb_state_of_name , tvb , offset + NB_DATA2 , 1 , local_session_number , \"LISTEN pending, but insufficient resources to establish session\" ) ;\n break ;\n default : proto_tree_add_item ( tree , hf_netb_local_session_no , tvb , offset + NB_DATA2 , 1 , ENC_LITTLE_ENDIAN ) ;\n break ;\n }\n nb_call_name_type ( tvb , offset , tree ) ;\n nb_xmit_corrl ( tvb , offset , tree ) ;\n if ( local_session_number != 0x00 && local_session_number != 0xFF ) nb_resp_corrl ( tvb , offset , tree ) ;\n netbios_add_name ( \"Receiver's Name\" , tvb , offset + NB_RECVER_NAME , tree ) ;\n if ( local_session_number != 0x00 && local_session_number != 0xFF ) {\n netbios_add_name ( \"Sender's Name\" , tvb , offset + NB_SENDER_NAME , tree ) ;\n }\n return 0 ;\n }", "hash": -3135212895432241239, "project": "debian", "size": 19, "target": 0, "idx": 4695}
{"code": "static guint32 dissect_netb_add_name ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {\n nb_resp_corrl ( tvb , offset , tree ) ;\n netbios_add_name ( \"Name to add\" , tvb , offset + NB_SENDER_NAME , tree ) ;\n return 0 ;\n }", "hash": -3135212895432241239, "project": "debian", "size": 5, "target": 0, "idx": 4696}
{"code": "static guint32 dissect_netb_name_in_conflict ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {\n netbios_add_name ( \"Name In Conflict\" , tvb , offset + NB_RECVER_NAME , tree ) ;\n netbios_add_name ( \"Sender's Name\" , tvb , offset + NB_SENDER_NAME , tree ) ;\n return 0 ;\n }", "hash": -3135212895432241239, "project": "debian", "size": 5, "target": 0, "idx": 4708}
{"code": "int get_netbios_name ( tvbuff_t * tvb , int offset , char * name_ret , int name_ret_len ) {\n return process_netbios_name ( tvb_get_ptr ( tvb , offset , NETBIOS_NAME_LEN ) , name_ret , name_ret_len ) ;\n }", "hash": -3135212895432241239, "project": "debian", "size": 3, "target": 0, "idx": 4719}
{"code": "static int config_filters_request ( struct config_connection * conn ) {\n struct config_filter_parser * const * filters = config_filter_get_all ( config_filter ) ;\n o_stream_cork ( conn -> output ) ;\n while ( * filters != NULL ) {\n const struct config_filter * filter = & ( * filters ) -> filter ;\n o_stream_nsend_str ( conn -> output , \"FILTER\" ) ;\n if ( filter -> service != NULL ) o_stream_nsend_str ( conn -> output , t_strdup_printf ( \"\\tservice=%s\" , filter -> service ) ) ;\n if ( filter -> local_name != NULL ) o_stream_nsend_str ( conn -> output , t_strdup_printf ( \"\\tlocal-name=%s\" , filter -> local_name ) ) ;\n if ( filter -> local_bits > 0 ) o_stream_nsend_str ( conn -> output , t_strdup_printf ( \"\\tlocal-net=%s/%u\" , net_ip2addr ( & filter -> local_net ) , filter -> local_bits ) ) ;\n if ( filter -> remote_bits > 0 ) o_stream_nsend_str ( conn -> output , t_strdup_printf ( \"\\tremote-net=%s/%u\" , net_ip2addr ( & filter -> remote_net ) , filter -> remote_bits ) ) ;\n o_stream_nsend_str ( conn -> output , \"\\n\" ) ;\n filters ++ ;\n }\n o_stream_nsend_str ( conn -> output , \"\\n\" ) ;\n o_stream_uncork ( conn -> output ) ;\n return 0 ;\n }", "hash": 6099731296275586910, "project": "debian", "size": 17, "target": 0, "idx": 4727}
{"code": "static int config_connection_request ( struct config_connection * conn , const char * const * args ) {\n struct config_export_context * ctx ;\n struct master_service_settings_output output ;\n struct config_filter filter ;\n const char * path , * error , * module , * const * wanted_modules ;\n ARRAY ( const char * ) modules ;\n bool is_master = FALSE ;\n t_array_init ( & modules , 4 ) ;\n i_zero ( & filter ) ;\n for ( ;\n * args != NULL ;\n args ++ ) {\n if ( strncmp ( * args , \"service=\" , 8 ) == 0 ) filter . service = * args + 8 ;\n else if ( strncmp ( * args , \"module=\" , 7 ) == 0 ) {\n module = * args + 7 ;\n if ( strcmp ( module , \"master\" ) == 0 ) is_master = TRUE ;\n array_append ( & modules , & module , 1 ) ;\n }\n else if ( strncmp ( * args , \"lname=\" , 6 ) == 0 ) filter . local_name = * args + 6 ;\n else if ( strncmp ( * args , \"lip=\" , 4 ) == 0 ) {\n if ( net_addr2ip ( * args + 4 , & filter . local_net ) == 0 ) {\n filter . local_bits = IPADDR_IS_V4 ( & filter . local_net ) ? : 128 ;\n }\n }\n else if ( strncmp ( * args , \"rip=\" , 4 ) == 0 ) {\n if ( net_addr2ip ( * args + 4 , & filter . remote_net ) == 0 ) {\n filter . remote_bits = IPADDR_IS_V4 ( & filter . remote_net ) ? : 128 ;\n }\n }\n }\n array_append_zero ( & modules ) ;\n wanted_modules = array_count ( & modules ) == 1 ? NULL : array_idx ( & modules , 0 ) ;\n if ( is_master ) {\n path = master_service_get_config_path ( master_service ) ;\n if ( config_parse_file ( path , TRUE , NULL , & error ) <= 0 ) {\n o_stream_nsend_str ( conn -> output , t_strconcat ( \"\\nERROR \" , error , \"\\n\" , NULL ) ) ;\n config_connection_destroy ( conn ) ;\n return - 1 ;\n }\n }\n o_stream_cork ( conn -> output ) ;\n ctx = config_export_init ( wanted_modules , CONFIG_DUMP_SCOPE_SET , 0 , config_request_output , conn -> output ) ;\n config_export_by_filter ( ctx , & filter ) ;\n config_export_get_output ( ctx , & output ) ;\n if ( output . specific_services != NULL ) {\n const char * const * s ;\n for ( s = output . specific_services ;\n * s != NULL ;\n s ++ ) {\n o_stream_nsend_str ( conn -> output , t_strdup_printf ( \"service=%s\\t\" , * s ) ) ;\n }\n }\n if ( output . service_uses_local ) o_stream_nsend_str ( conn -> output , \"service-uses-local\\t\" ) ;\n if ( output . service_uses_remote ) o_stream_nsend_str ( conn -> output , \"service-uses-remote\\t\" ) ;\n if ( output . used_local ) o_stream_nsend_str ( conn -> output , \"used-local\\t\" ) ;\n if ( output . used_remote ) o_stream_nsend_str ( conn -> output , \"used-remote\\t\" ) ;\n o_stream_nsend_str ( conn -> output , \"\\n\" ) ;\n if ( config_export_finish ( & ctx ) < 0 ) {\n config_connection_destroy ( conn ) ;\n return - 1 ;\n }\n o_stream_nsend_str ( conn -> output , \"\\n\" ) ;\n o_stream_uncork ( conn -> output ) ;\n return 0 ;\n }", "hash": 6099731296275586910, "project": "debian", "size": 65, "target": 0, "idx": 4733}
{"code": "static int s_aos_seek ( register stream * s , gs_offset_t pos ) {\n uint end = s -> srlimit - s -> cbuf + 1 ;\n long offset = pos - s -> position ;\n if ( offset >= 0 && offset <= end ) {\n s -> srptr = s -> cbuf + offset - 1 ;\n return 0 ;\n }\n if ( pos < 0 || pos > s -> file_limit ) return ERRC ;\n s -> srptr = s -> srlimit = s -> cbuf - 1 ;\n s -> end_status = 0 ;\n s -> position = pos ;\n return 0 ;\n }", "hash": 6451388340908334697, "project": "debian", "size": 13, "target": 0, "idx": 4737}
{"code": "static int make_rfs ( i_ctx_t * i_ctx_p , os_ptr op , stream * fs , long offset , long length ) {\n uint save_space = icurrent_space ;\n uint stream_space = imemory_space ( ( const gs_ref_memory_t * ) fs -> memory ) ;\n gs_const_string fname ;\n gs_parsed_file_name_t pname ;\n stream * s ;\n int code ;\n if ( sfilename ( fs , & fname ) < 0 ) return_error ( gs_error_ioerror ) ;\n code = gs_parse_file_name ( & pname , ( const char * ) fname . data , fname . size , imemory ) ;\n if ( code < 0 ) return code ;\n if ( pname . len == 0 ) return_error ( gs_error_invalidfileaccess ) ;\n if ( pname . iodev == NULL ) pname . iodev = iodev_default ( imemory ) ;\n ialloc_set_space ( idmemory , stream_space ) ;\n code = zopen_file ( i_ctx_p , & pname , \"r\" , & s , imemory ) ;\n ialloc_set_space ( idmemory , save_space ) ;\n if ( code < 0 ) return code ;\n if ( sread_subfile ( s , offset , length ) < 0 ) {\n sclose ( s ) ;\n return_error ( gs_error_ioerror ) ;\n }\n s -> close_at_eod = false ;\n make_stream_file ( op , s , \"r\" ) ;\n return 0 ;\n }", "hash": 6451388340908334697, "project": "debian", "size": 24, "target": 0, "idx": 4742}
{"code": "int qemuAssignDeviceRNGAlias ( virDomainDefPtr def , virDomainRNGDefPtr rng ) {\n size_t i ;\n int maxidx = 0 ;\n int idx ;\n for ( i = 0 ;\n i < def -> nrngs ;\n i ++ ) {\n if ( ( idx = qemuDomainDeviceAliasIndex ( & def -> rngs [ i ] -> info , \"rng\" ) ) >= maxidx ) maxidx = idx + 1 ;\n }\n if ( virAsprintf ( & rng -> info . alias , \"rng%d\" , maxidx ) < 0 ) return - 1 ;\n return 0 ;\n }", "hash": -7775977291865552483, "project": "debian", "size": 12, "target": 0, "idx": 4750}
{"code": "static int parse_CRowSeekByBookmark ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , const char * fmt , ... ) {\n proto_tree * tree ;\n proto_item * item ;\n guint32 num ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CRowsSeekByBookmark , & item , txt ) ;\n num = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_mswsp_crowseekbybookmark_cbookmarks , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n offset = parse_UInt32Array ( tvb , offset , tree , num , \"abookmark\" , \"abookmarks\" ) ;\n num = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_mswsp_crowseekbybookmark_maxret , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n offset = parse_UInt32Array ( tvb , offset , tree , num , \"ascret\" , \"ascret\" ) ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "hash": 3584320764213684062, "project": "debian", "size": 21, "target": 0, "idx": 4827}
{"code": "static int dissect_CPMDisconnect ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree _U_ , gboolean in _U_ , void * data _U_ ) {\n col_append_str ( pinfo -> cinfo , COL_INFO , \"Disconnect\" ) ;\n return tvb_reported_length ( tvb ) ;\n }", "hash": 3584320764213684062, "project": "debian", "size": 4, "target": 0, "idx": 4833}
{"code": "static void vvalue_strbuf_append_blob ( wmem_strbuf_t * strbuf , void * ptr ) {\n struct data_blob * blob = ( struct data_blob * ) ptr ;\n wmem_strbuf_append_printf ( strbuf , \"size: %d\" , ( int ) blob -> size ) ;\n }", "hash": 3584320764213684062, "project": "debian", "size": 4, "target": 0, "idx": 4852}
{"code": "static int vvalue_tvb_blob ( tvbuff_t * tvb , int offset , void * val ) {\n struct data_blob * blob = ( struct data_blob * ) val ;\n guint32 len = tvb_get_letohl ( tvb , offset ) ;\n blob -> size = len ;\n blob -> data = ( guint8 * ) tvb_memdup ( wmem_packet_scope ( ) , tvb , offset + 4 , len ) ;\n return 4 + len ;\n }", "hash": 3584320764213684062, "project": "debian", "size": 7, "target": 0, "idx": 4853}
{"code": "static int parse_CSort ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree _U_ , const char * fmt , ... ) {\n guint32 col , ord , ind ;\n proto_item * item ;\n proto_tree * tree ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CSort , & item , txt ) ;\n col = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_cscort_column , tvb , offset , 4 , col ) ;\n offset += 4 ;\n ord = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_cscort_order , tvb , offset , 4 , ord ) ;\n offset += 4 ;\n ind = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_cscort_individual , tvb , offset , 4 , ind ) ;\n offset += 4 ;\n offset = parse_lcid ( tvb , offset , tree , \"lcid\" ) ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "hash": 3584320764213684062, "project": "debian", "size": 23, "target": 0, "idx": 4859}
{"code": "static int parse_CRowVariantArrayInfo ( tvbuff_t * tvb , int offset , proto_tree * tree , gboolean is_64bit , struct CRowVariant * variant ) {\n if ( is_64bit ) {\n variant -> content . array_vector . i64 . count = tvb_get_letoh64 ( tvb , offset ) ;\n proto_tree_add_uint64 ( tree , hf_mswsp_crowvariantinfo_count64 , tvb , offset , 8 , variant -> content . array_vector . i64 . count ) ;\n offset += 8 ;\n variant -> content . array_vector . i64 . array_address = tvb_get_letoh64 ( tvb , offset ) ;\n proto_tree_add_uint64 ( tree , hf_mswsp_arrayvector_address64 , tvb , offset , 8 , variant -> content . array_vector . i64 . array_address ) ;\n offset += 8 ;\n }\n else {\n variant -> content . array_vector . i32 . count = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_crowvariantinfo_count32 , tvb , offset , 4 , variant -> content . array_vector . i32 . count ) ;\n offset += 4 ;\n variant -> content . array_vector . i32 . array_address = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_arrayvector_address32 , tvb , offset , 4 , variant -> content . array_vector . i32 . array_address ) ;\n offset += 4 ;\n }\n return offset ;\n }", "hash": 3584320764213684062, "project": "debian", "size": 19, "target": 0, "idx": 4862}
{"code": "static int dissect_btgatt_microbit_client_event ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , void * data ) {\n btatt_data_t * att_data = ( btatt_data_t * ) data ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return - 1 ;\n proto_tree_add_item ( tree , hf_gatt_microbit_client_event , tvb , 0 , tvb_captured_length ( tvb ) , ENC_NA ) ;\n return tvb_captured_length ( tvb ) ;\n }", "hash": 5045872831385413038, "project": "debian", "size": 6, "target": 0, "idx": 4892}
{"code": "static guint8 * get_value ( packet_info * pinfo , guint32 handle , bluetooth_data_t * bluetooth_data , guint * length ) {\n wmem_tree_key_t key [ 4 ] ;\n guint32 frame_number ;\n fragment_data_t * fragment_data ;\n wmem_tree_t * sub_wmemtree ;\n guint last_offset = G_MAXUINT ;\n guint size ;\n gboolean first = TRUE ;\n guint8 * data = NULL ;\n frame_number = pinfo -> num ;\n key [ 0 ] . length = 1 ;\n key [ 0 ] . key = & bluetooth_data -> interface_id ;\n key [ 1 ] . length = 1 ;\n key [ 1 ] . key = & bluetooth_data -> adapter_id ;\n key [ 2 ] . length = 1 ;\n key [ 2 ] . key = & handle ;\n key [ 3 ] . length = 0 ;\n key [ 3 ] . key = NULL ;\n sub_wmemtree = ( wmem_tree_t * ) wmem_tree_lookup32_array ( fragments , key ) ;\n while ( 1 ) {\n fragment_data = ( sub_wmemtree ) ? ( fragment_data_t * ) wmem_tree_lookup32_le ( sub_wmemtree , frame_number ) : NULL ;\n if ( ! fragment_data || ( fragment_data && fragment_data -> offset >= last_offset ) ) break ;\n if ( first ) {\n size = fragment_data -> offset + fragment_data -> length ;\n data = ( guint8 * ) wmem_alloc ( pinfo -> pool , size ) ;\n if ( length ) * length = size ;\n first = FALSE ;\n }\n else if ( fragment_data -> offset + fragment_data -> length != last_offset ) {\n break ;\n }\n memcpy ( data + fragment_data -> offset , fragment_data -> data , fragment_data -> length ) ;\n if ( fragment_data -> offset == 0 ) return data ;\n frame_number = fragment_data -> data_in_frame - 1 ;\n last_offset = fragment_data -> offset ;\n }\n if ( length ) * length = 0 ;\n return NULL ;\n }", "hash": 5045872831385413038, "project": "debian", "size": 39, "target": 0, "idx": 4897}
{"code": "static void save_mtu ( packet_info * pinfo , bluetooth_data_t * bluetooth_data , guint mtu ) {\n wmem_tree_key_t key [ 4 ] ;\n guint32 frame_number ;\n mtu_data_t * mtu_data ;\n frame_number = pinfo -> num ;\n key [ 0 ] . length = 1 ;\n key [ 0 ] . key = & bluetooth_data -> interface_id ;\n key [ 1 ] . length = 1 ;\n key [ 1 ] . key = & bluetooth_data -> adapter_id ;\n key [ 2 ] . length = 1 ;\n key [ 2 ] . key = & frame_number ;\n key [ 3 ] . length = 0 ;\n key [ 3 ] . key = NULL ;\n mtu_data = wmem_new ( wmem_file_scope ( ) , mtu_data_t ) ;\n mtu_data -> mtu = mtu ;\n wmem_tree_insert32_array ( mtus , key , mtu_data ) ;\n }", "hash": 5045872831385413038, "project": "debian", "size": 17, "target": 0, "idx": 4905}
{"code": "static gboolean is_readable_response ( guint8 opcode ) {\n return ( opcode == ATT_OPCODE_READ_RESPONSE || opcode == ATT_OPCODE_READ_BLOB_RESPONSE || opcode == ATT_OPCODE_READ_BY_TYPE_RESPONSE || opcode == ATT_OPCODE_READ_MULTIPLE_RESPONSE ) ;\n }", "hash": 5045872831385413038, "project": "debian", "size": 3, "target": 0, "idx": 4908}
{"code": "static bluetooth_uuid_t get_uuid_from_handle ( packet_info * pinfo , guint32 handle , bluetooth_data_t * bluetooth_data ) {\n wmem_tree_key_t key [ 4 ] ;\n guint32 frame_number ;\n handle_data_t * handle_data ;\n wmem_tree_t * sub_wmemtree ;\n bluetooth_uuid_t uuid ;\n memset ( & uuid , 0 , sizeof uuid ) ;\n frame_number = pinfo -> num ;\n key [ 0 ] . length = 1 ;\n key [ 0 ] . key = & bluetooth_data -> interface_id ;\n key [ 1 ] . length = 1 ;\n key [ 1 ] . key = & bluetooth_data -> adapter_id ;\n key [ 2 ] . length = 1 ;\n key [ 2 ] . key = & handle ;\n key [ 3 ] . length = 0 ;\n key [ 3 ] . key = NULL ;\n sub_wmemtree = ( wmem_tree_t * ) wmem_tree_lookup32_array ( handle_to_uuid , key ) ;\n handle_data = ( sub_wmemtree ) ? ( handle_data_t * ) wmem_tree_lookup32_le ( sub_wmemtree , frame_number ) : NULL ;\n if ( handle_data ) uuid = handle_data -> uuid ;\n return uuid ;\n }", "hash": 5045872831385413038, "project": "debian", "size": 21, "target": 0, "idx": 4916}
{"code": "static int dissect_btgatt_microbit_microbit_event ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , void * data ) {\n btatt_data_t * att_data = ( btatt_data_t * ) data ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return - 1 ;\n proto_tree_add_item ( tree , hf_gatt_microbit_microbit_event , tvb , 0 , tvb_captured_length ( tvb ) , ENC_NA ) ;\n return tvb_captured_length ( tvb ) ;\n }", "hash": 5045872831385413038, "project": "debian", "size": 6, "target": 0, "idx": 4923}
{"code": "static int dissect_btgatt_microbit_client_requirements ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , void * data ) {\n btatt_data_t * att_data = ( btatt_data_t * ) data ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return - 1 ;\n proto_tree_add_item ( tree , hf_gatt_microbit_client_requirements , tvb , 0 , tvb_captured_length ( tvb ) , ENC_NA ) ;\n return tvb_captured_length ( tvb ) ;\n }", "hash": 5045872831385413038, "project": "debian", "size": 6, "target": 0, "idx": 4925}
{"code": "static int dissect_btgatt_microbit_led_matrix ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , void * data ) {\n btatt_data_t * att_data = ( btatt_data_t * ) data ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return - 1 ;\n proto_tree_add_item ( tree , hf_gatt_microbit_led_matrix , tvb , 0 , tvb_captured_length ( tvb ) , ENC_NA ) ;\n return tvb_captured_length ( tvb ) ;\n }", "hash": 5045872831385413038, "project": "debian", "size": 6, "target": 0, "idx": 4926}
{"code": "static bluetooth_uuid_t get_service_uuid_from_handle ( packet_info * pinfo , guint32 handle , bluetooth_data_t * bluetooth_data ) {\n wmem_tree_key_t key [ 4 ] ;\n guint32 frame_number ;\n handle_data_t * handle_data ;\n wmem_tree_t * sub_wmemtree ;\n bluetooth_uuid_t uuid ;\n memset ( & uuid , 0 , sizeof uuid ) ;\n frame_number = pinfo -> num ;\n key [ 0 ] . length = 1 ;\n key [ 0 ] . key = & bluetooth_data -> interface_id ;\n key [ 1 ] . length = 1 ;\n key [ 1 ] . key = & bluetooth_data -> adapter_id ;\n key [ 2 ] . length = 1 ;\n key [ 2 ] . key = & handle ;\n key [ 3 ] . length = 0 ;\n key [ 3 ] . key = NULL ;\n while ( handle > 0 ) {\n sub_wmemtree = ( wmem_tree_t * ) wmem_tree_lookup32_array ( handle_to_uuid , key ) ;\n handle_data = ( sub_wmemtree ) ? ( handle_data_t * ) wmem_tree_lookup32_le ( sub_wmemtree , frame_number ) : NULL ;\n if ( handle_data && handle_data -> type == ATTRIBUTE_TYPE_SERVICE ) {\n uuid = handle_data -> uuid ;\n return uuid ;\n }\n handle -= 1 ;\n }\n return uuid ;\n }", "hash": 5045872831385413038, "project": "debian", "size": 27, "target": 0, "idx": 4927}
{"code": "static gint dissect_attribute_value ( proto_tree * tree , proto_item * patron_item , packet_info * pinfo , tvbuff_t * old_tvb , gint old_offset , gint length , guint16 handle , bluetooth_uuid_t uuid , btatt_data_t * att_data ) {\n proto_item * sub_item ;\n proto_tree * sub_tree = NULL ;\n tvbuff_t * tvb ;\n gint offset = 0 ;\n bluetooth_uuid_t sub_uuid ;\n bluetooth_uuid_t service_uuid ;\n guint16 sub_handle ;\n guint32 value ;\n guint32 flags ;\n guint32 operator_value ;\n guint32 opcode ;\n guint32 operand_offset ;\n const gint * * hfs ;\n bluetooth_data_t * bluetooth_data = NULL ;\n tvb = tvb_new_subset_length_caplen ( old_tvb , old_offset , length , length ) ;\n DISSECTOR_ASSERT ( att_data ) ;\n bluetooth_data = att_data -> bluetooth_data ;\n if ( p_get_proto_data ( pinfo -> pool , pinfo , proto_btatt , PROTO_DATA_BTATT_HANDLE ) == NULL ) {\n guint16 * value_data ;\n value_data = wmem_new ( wmem_file_scope ( ) , guint16 ) ;\n * value_data = handle ;\n p_add_proto_data ( pinfo -> pool , pinfo , proto_btatt , PROTO_DATA_BTATT_HANDLE , value_data ) ;\n }\n if ( btatt_dissect_attribute_handle ( handle , tvb , pinfo , tree , att_data ) ) return old_offset + length ;\n if ( p_get_proto_data ( pinfo -> pool , pinfo , proto_bluetooth , PROTO_DATA_BLUETOOTH_SERVICE_UUID ) == NULL ) {\n guint8 * value_data ;\n value_data = wmem_strdup ( wmem_file_scope ( ) , print_numeric_uuid ( & uuid ) ) ;\n p_add_proto_data ( pinfo -> pool , pinfo , proto_bluetooth , PROTO_DATA_BLUETOOTH_SERVICE_UUID , value_data ) ;\n }\n if ( dissector_try_string ( bluetooth_uuid_table , print_numeric_uuid ( & uuid ) , tvb , pinfo , tree , att_data ) ) return old_offset + length ;\n else if ( ! uuid . bt_uuid ) {\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return old_offset ;\n proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n return old_offset + tvb_captured_length ( tvb ) ;\n }\n service_uuid = get_service_uuid_from_handle ( pinfo , handle , bluetooth_data ) ;\n switch ( uuid . bt_uuid ) {\n case 0x2800 : case 0x2801 : if ( is_readable_request ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_READ_BY_GROUP_TYPE_REQUEST ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_READ_BY_GROUP_TYPE_RESPONSE ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n if ( tvb_reported_length_remaining ( tvb , offset ) == 2 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid16 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n sub_uuid = get_uuid ( tvb , offset , 2 ) ;\n proto_item_append_text ( patron_item , \", UUID: %s\" , print_uuid ( & sub_uuid ) ) ;\n offset += 2 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , print_uuid ( & sub_uuid ) ) ;\n save_handle ( pinfo , sub_uuid , handle , ATTRIBUTE_TYPE_SERVICE , bluetooth_data ) ;\n }\n else if ( tvb_reported_length_remaining ( tvb , offset ) == 16 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid128 , tvb , offset , 16 , ENC_NA ) ;\n sub_uuid = get_uuid ( tvb , offset , 16 ) ;\n proto_item_append_text ( patron_item , \", UUID128: %s\" , print_uuid ( & sub_uuid ) ) ;\n offset += 16 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , print_uuid ( & sub_uuid ) ) ;\n save_handle ( pinfo , sub_uuid , handle , ATTRIBUTE_TYPE_SERVICE , bluetooth_data ) ;\n }\n else {\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_bad_data ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n break ;\n case 0x2802 : if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n offset = dissect_handle ( tree , pinfo , hf_btatt_included_service_handle , tvb , offset , bluetooth_data , NULL , HANDLE_TVB ) ;\n sub_handle = tvb_get_guint16 ( tvb , offset - 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_btatt_ending_handle , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_uuid16 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n sub_uuid = get_uuid ( tvb , offset , 2 ) ;\n proto_item_append_text ( patron_item , \", Included Handle: 0x%04x, UUID: %s\" , sub_handle , print_uuid ( & sub_uuid ) ) ;\n offset += 2 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , print_uuid ( & sub_uuid ) ) ;\n save_handle ( pinfo , sub_uuid , sub_handle , ATTRIBUTE_TYPE_OTHER , bluetooth_data ) ;\n break ;\n case 0x2803 : if ( is_readable_request ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_READ_BY_TYPE_REQUEST ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_READ_BY_TYPE_RESPONSE ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_characteristic_properties , ett_btatt_characteristic_properties , hfx_btatt_characteristic_properties , ENC_NA ) ;\n offset += 1 ;\n offset = dissect_handle ( tree , pinfo , hf_btatt_characteristic_value_handle , tvb , offset , bluetooth_data , NULL , HANDLE_TVB ) ;\n sub_handle = tvb_get_guint16 ( tvb , offset - 2 , ENC_LITTLE_ENDIAN ) ;\n if ( tvb_reported_length_remaining ( tvb , offset ) == 16 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid128 , tvb , offset , 16 , ENC_NA ) ;\n sub_uuid = get_uuid ( tvb , offset , 16 ) ;\n proto_item_append_text ( patron_item , \", Characteristic Handle: 0x%04x, UUID128: %s\" , tvb_get_guint16 ( tvb , offset - 2 , ENC_LITTLE_ENDIAN ) , print_uuid ( & sub_uuid ) ) ;\n offset += 16 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , print_uuid ( & sub_uuid ) ) ;\n save_handle ( pinfo , sub_uuid , sub_handle , ATTRIBUTE_TYPE_CHARACTERISTIC , bluetooth_data ) ;\n }\n else if ( tvb_reported_length_remaining ( tvb , offset ) == 2 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid16 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n sub_uuid = get_uuid ( tvb , offset , 2 ) ;\n proto_item_append_text ( patron_item , \", Characteristic Handle: 0x%04x, UUID: %s\" , sub_handle , print_uuid ( & sub_uuid ) ) ;\n offset += 2 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", %s\" , print_uuid ( & sub_uuid ) ) ;\n save_handle ( pinfo , sub_uuid , sub_handle , ATTRIBUTE_TYPE_CHARACTERISTIC , bluetooth_data ) ;\n }\n else {\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_bad_data ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n break ;\n case 0x2900 : if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_characteristic_extended_properties , ett_btatt_value , hfx_btatt_characteristic_extended_properties , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2901 : if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_characteristic_user_description , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2902 : if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_characteristic_configuration_client , ett_btatt_value , hfx_btatt_characteristic_configuration_client , ENC_LITTLE_ENDIAN ) ;\n value = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n {\n bluetooth_uuid_t characteristic_uuid ;\n characteristic_uuid = get_characteristic_uuid_from_handle ( pinfo , handle , bluetooth_data ) ;\n if ( value & 0x1 ) switch ( characteristic_uuid . bt_uuid ) {\n case 0x2A05 : case 0x2A1C : case 0x2A21 : case 0x2A35 : case 0x2A52 : case 0x2A55 : case 0x2A66 : case 0x2A6B : case 0x2A99 : case 0x2A9C : case 0x2A9D : case 0x2A9F : case 0x2ABC : case 0x2AC5 : case 0x2AC6 : case 0x2AC8 : case 0x2AC9 : case 0x2ACC : case 0x2AD4 : case 0x2AD5 : case 0x2AD6 : case 0x2AD7 : case 0x2AD8 : case 0x2AD9 : expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n break ;\n case 0x2A18 : case 0x2A19 : case 0x2A1E : case 0x2A22 : case 0x2A2C : case 0x2A2B : case 0x2A31 : case 0x2A33 : case 0x2A34 : case 0x2A36 : case 0x2A37 : case 0x2A3F : case 0x2A45 : case 0x2A46 : case 0x2A4D : case 0x2A53 : case 0x2A56 : case 0x2A58 : case 0x2A5A : case 0x2A5B : case 0x2A63 : case 0x2A64 : case 0x2A67 : case 0x2A68 : case 0x2A6C : case 0x2A6D : case 0x2A6E : case 0x2A6F : case 0x2A70 : case 0x2A71 : case 0x2A72 : case 0x2A73 : case 0x2A74 : case 0x2A75 : case 0x2A76 : case 0x2A77 : case 0x2A78 : case 0x2A79 : case 0x2A7A : case 0x2A7B : case 0x2AA0 : case 0x2AA1 : case 0x2AA3 : case 0x2AA7 : case 0x2AB8 : case 0x2ACD : case 0x2ACE : case 0x2ACF : case 0x2AD0 : case 0x2AD1 : case 0x2AD2 : case 0x2AD3 : case 0x2ADA : default : break ;\n }\n if ( value & 0x2 ) switch ( characteristic_uuid . bt_uuid ) {\n case 0x2A18 : case 0x2A19 : case 0x2A1E : case 0x2A22 : case 0x2A2B : case 0x2A2C : case 0x2A31 : case 0x2A33 : case 0x2A34 : case 0x2A36 : case 0x2A37 : case 0x2A3F : case 0x2A45 : case 0x2A46 : case 0x2A4D : case 0x2A53 : case 0x2A5B : case 0x2A63 : case 0x2A64 : case 0x2A67 : case 0x2A68 : case 0x2A6C : case 0x2A6D : case 0x2A6E : case 0x2A6F : case 0x2A70 : case 0x2A71 : case 0x2A72 : case 0x2A73 : case 0x2A74 : case 0x2A75 : case 0x2A76 : case 0x2A77 : case 0x2A78 : case 0x2A79 : case 0x2A7A : case 0x2A7B : case 0x2AA0 : case 0x2AA1 : case 0x2AA3 : case 0x2AA7 : case 0x2AB8 : case 0x2AC9 : case 0x2ACC : case 0x2ACD : case 0x2ACE : case 0x2ACF : case 0x2AD0 : case 0x2AD1 : case 0x2AD2 : case 0x2AD3 : case 0x2AD4 : case 0x2AD5 : case 0x2AD6 : case 0x2AD7 : case 0x2AD8 : case 0x2ADA : expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n break ;\n case 0x2A05 : case 0x2A1C : case 0x2A21 : case 0x2A35 : case 0x2A52 : case 0x2A55 : case 0x2A56 : case 0x2A58 : case 0x2A5A : case 0x2A66 : case 0x2A6B : case 0x2A99 : case 0x2A9C : case 0x2A9D : case 0x2A9F : case 0x2ABC : case 0x2AC5 : case 0x2AC6 : case 0x2AC8 : case 0x2AD9 : default : break ;\n }\n if ( value > 0x3 ) expert_add_info ( pinfo , tree , & ei_btatt_bad_data ) ;\n }\n break ;\n case 0x2903 : if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_characteristic_configuration_server , ett_btatt_value , hfx_btatt_characteristic_configuration_server , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2904 : if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_characteristic_presentation_format , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_characteristic_presentation_exponent , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_characteristic_presentation_unit , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_characteristic_presentation_namespace , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( value == 0x01 ) proto_tree_add_item ( tree , hf_btatt_characteristic_presentation_namespace_description_btsig , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( tree , hf_btatt_characteristic_presentation_namespace_description , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2905 : if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_none_format ( tree , hf_btatt_handles_info , tvb , offset , tvb_captured_length ( tvb ) , \"Handles (%i items)\" , tvb_captured_length ( tvb ) / 2 ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n while ( offset < ( gint64 ) tvb_captured_length ( tvb ) ) {\n offset = dissect_handle ( sub_tree , pinfo , hf_btatt_handle , tvb , offset , bluetooth_data , NULL , HANDLE_TVB ) ;\n }\n break ;\n case 0x2906 : {\n bluetooth_uuid_t characteristic_uuid ;\n guint8 * characteristic_dissector_name ;\n dissector_handle_t characteristic_dissector ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n characteristic_uuid = get_characteristic_uuid_from_handle ( pinfo , handle , bluetooth_data ) ;\n characteristic_dissector_name = wmem_strdup_printf ( wmem_packet_scope ( ) , \"btgatt.uuid0x%s\" , print_numeric_uuid ( & characteristic_uuid ) ) ;\n characteristic_dissector = find_dissector ( characteristic_dissector_name ) ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_valid_range_lower_inclusive_value , tvb , offset , tvb_reported_length_remaining ( tvb , offset ) / 2 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n if ( characteristic_dissector ) call_dissector_with_data ( characteristic_dissector , tvb_new_subset_length_caplen ( tvb , offset , tvb_reported_length_remaining ( tvb , offset ) / 2 , tvb_reported_length_remaining ( tvb , offset ) / 2 ) , pinfo , sub_tree , att_data ) ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_valid_range_upper_inclusive_value , tvb , offset + tvb_reported_length_remaining ( tvb , offset ) / 2 , tvb_reported_length_remaining ( tvb , offset ) / 2 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n if ( characteristic_dissector ) call_dissector_with_data ( characteristic_dissector , tvb_new_subset_length_caplen ( tvb , offset + tvb_reported_length_remaining ( tvb , offset ) / 2 , tvb_reported_length_remaining ( tvb , offset ) / 2 , tvb_reported_length_remaining ( tvb , offset ) / 2 ) , pinfo , sub_tree , att_data ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n }\n break ;\n case 0x2907 : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n if ( tvb_reported_length_remaining ( tvb , offset ) == 2 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid16 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else if ( tvb_reported_length_remaining ( tvb , offset ) == 16 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid128 , tvb , offset , 16 , ENC_NA ) ;\n offset += 16 ;\n }\n else {\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_bad_data ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n break ;\n case 0x2908 : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_report_reference_report_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_report_reference_report_type , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2909 : if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_number_of_digitals , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x290A : if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_value_trigger_setting_condition , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( value >= 1 && value <= 3 ) {\n proto_tree_add_item ( tree , hf_btatt_value_trigger_setting_analog , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else if ( value == 4 ) {\n btatt_call_dissector_by_dissector_name_with_data ( \"btgatt.uuid0x2a56\" , tvb_new_subset_length_caplen ( tvb , offset , 1 , 1 ) , pinfo , tree , att_data ) ;\n offset += 1 ;\n }\n else if ( value == 5 || value == 6 ) {\n proto_tree_add_item ( tree , hf_btatt_value_trigger_setting_analog_one , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_value_trigger_setting_analog_two , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x290B : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_esp_trigger_logic , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x290C : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_esp_flags , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_esp_sampling_function , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_esp_measurement_period , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n proto_tree_add_item ( tree , hf_btatt_esp_update_interval , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n proto_tree_add_item ( tree , hf_btatt_esp_application , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_esp_measurement_uncertainty , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x290D : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_esp_condition , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_esp_operand , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x290E : if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_time_trigger_setting_condition , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( value == 0 ) {\n proto_tree_add_item ( tree , hf_btatt_time_trigger_setting_value , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n else if ( value == 1 || value == 2 ) {\n proto_tree_add_item ( tree , hf_btatt_time_trigger_setting_value_time_interval , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n else if ( value == 3 ) {\n proto_tree_add_item ( tree , hf_btatt_time_trigger_setting_value_count , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A00 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_device_name , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A01 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n switch ( ( tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) & 0xFFC0 ) >> 6 ) {\n case 0x003 : hfs = hfx_btatt_appearance_watch ;\n break ;\n case 0x00C : hfs = hfx_btatt_appearance_thermometer ;\n break ;\n case 0x00D : hfs = hfx_btatt_appearance_heart_rate ;\n break ;\n case 0x00E : hfs = hfx_btatt_appearance_blood_pressure ;\n break ;\n case 0x00F : hfs = hfx_btatt_appearance_hid ;\n break ;\n case 0x011 : hfs = hfx_btatt_appearance_running_walking_sensor ;\n break ;\n case 0x012 : hfs = hfx_btatt_appearance_cycling ;\n break ;\n case 0x031 : hfs = hfx_btatt_appearance_pulse_oximeter ;\n break ;\n case 0x033 : hfs = hfx_btatt_appearance_personal_mobility_device ;\n break ;\n case 0x035 : hfs = hfx_btatt_appearance_insulin_pump ;\n break ;\n case 0x051 : hfs = hfx_btatt_appearance_outdoor_sports_activity ;\n break ;\n default : hfs = hfx_btatt_appearance ;\n }\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_appearance , ett_btatt_value , hfs , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A02 : if ( service_uuid . bt_uuid == GATT_SERVICE_GENERIC_ACCESS_PROFILE ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_peripheral_privacy_flag , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A03 : if ( service_uuid . bt_uuid == GATT_SERVICE_GENERIC_ACCESS_PROFILE ) {\n if ( is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n offset = dissect_bd_addr ( hf_btatt_reconnection_address , pinfo , tree , tvb , offset , FALSE , bluetooth_data -> interface_id , bluetooth_data -> adapter_id , NULL ) ;\n break ;\n case 0x2A04 : if ( service_uuid . bt_uuid == GATT_SERVICE_GENERIC_ACCESS_PROFILE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_minimum_connection_interval , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_maximum_connection_interval , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_slave_latency , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_connection_supervision_timeout_multiplier , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A05 : if ( service_uuid . bt_uuid == GATT_SERVICE_GENERIC_ATTRIBUTE_PROFILE ) {\n if ( att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_starting_handle , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_ending_handle , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A06 : if ( service_uuid . bt_uuid == GATT_SERVICE_IMMEDIATE_ALERT ) {\n if ( att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n else if ( service_uuid . bt_uuid == GATT_SERVICE_LINK_LOSS ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_alert_level , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A07 : if ( service_uuid . bt_uuid == GATT_SERVICE_TX_POWER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_tx_power_level , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A08 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A09 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_day_of_week , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A0A : case 0x2A0B : case 0x2A0C : case 0x2A2B : if ( uuid . bt_uuid == 0x2A2B ) {\n if ( service_uuid . bt_uuid == GATT_SERVICE_CURRENT_TIME_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_day_of_week , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( uuid . bt_uuid == 0x2A0C || uuid . bt_uuid == 0x2A2B ) {\n proto_tree_add_item ( tree , hf_btatt_fractions256 , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n else if ( uuid . bt_uuid == 0x2A0B ) {\n proto_tree_add_item ( tree , hf_btatt_fractions100 , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( uuid . bt_uuid == 0x2A2B ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_time_adjust_reason , ett_btatt_value , hfx_btatt_time_adjust_reason , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n case 0x2A0D : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_dst_offset , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A0E : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_timezone , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A0F : case 0x2A10 : if ( service_uuid . bt_uuid == GATT_SERVICE_CURRENT_TIME_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n if ( uuid . bt_uuid == 0x2A10 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_timezone_information , ett_btatt_value , hfx_btatt_timezone_information , ENC_NA ) ;\n offset += 1 ;\n }\n proto_tree_add_item ( tree , hf_btatt_timezone , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_dst_offset , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A11 : if ( service_uuid . bt_uuid == GATT_SERVICE_NEXT_DST_CHANGE_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_dst_offset , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A12 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_time_accuracy , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A13 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_time_source , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A14 : if ( service_uuid . bt_uuid == GATT_SERVICE_CURRENT_TIME_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_time_source , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_time_accuracy , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_time_days_since_update , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_time_hours_since_update , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A15 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n btatt_call_dissector_by_dissector_name_with_data ( \"btgatt.uuid0x2A0C\" , tvb_new_subset_length_caplen ( tvb , offset , 9 , 9 ) , pinfo , tree , att_data ) ;\n offset += 9 ;\n btatt_call_dissector_by_dissector_name_with_data ( \"btgatt.uuid0x2A0F\" , tvb_new_subset_length_caplen ( tvb , offset , 2 , 2 ) , pinfo , tree , att_data ) ;\n offset += 2 ;\n btatt_call_dissector_by_dissector_name_with_data ( \"btgatt.uuid0x2A14\" , tvb_new_subset_length_caplen ( tvb , offset , 4 , 4 ) , pinfo , tree , att_data ) ;\n offset += 4 ;\n break ;\n case 0x2A16 : if ( service_uuid . bt_uuid == GATT_SERVICE_REFERENCE_TIME_UPDATE_SERVICE ) {\n if ( att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_time_update_control_point , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A17 : if ( service_uuid . bt_uuid == GATT_SERVICE_REFERENCE_TIME_UPDATE_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_time_current_state , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_time_result , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A18 : if ( service_uuid . bt_uuid == GATT_SERVICE_GLUCOSE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_glucose_measurement_flags , ett_btatt_value , hfx_btatt_glucose_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_sequence_number , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_glucose_measurement_base_time , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_time_offset , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( ( flags & 0x02 ) && ! ( flags & 0x04 ) ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_glucose_concentration_kg_per_l , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( ( flags & 0x02 ) && ( flags & 0x04 ) ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_glucose_concentration_mol_per_l , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_glucose_measurement_type_and_sample_location , ett_btatt_value , hfx_btatt_glucose_measurement_type_and_sample_location , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_glucose_measurement_sensor_status_annunciation , ett_btatt_value , hfx_btatt_glucose_measurement_sensor_status_annunciation , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A19 : {\n if ( service_uuid . bt_uuid == GATT_SERVICE_BATTERY_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n guint32 battery_level ;\n sub_item = proto_tree_add_item_ret_uint ( tree , hf_btatt_battery_level , tvb , offset , 1 , ENC_NA , & battery_level ) ;\n if ( battery_level > 100 ) expert_add_info ( pinfo , sub_item , & ei_btatt_bad_data ) ;\n offset += 1 ;\n }\n break ;\n case 0x2A1A : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_battery_power_state , ett_btatt_value , hfx_btatt_battery_power_state , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A1B : {\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n guint32 battery_level ;\n sub_item = proto_tree_add_item_ret_uint ( tree , hf_btatt_battery_level , tvb , offset , 1 , ENC_NA , & battery_level ) ;\n if ( battery_level > 100 ) expert_add_info ( pinfo , sub_item , & ei_btatt_bad_data ) ;\n offset += 1 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) >= 1 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_battery_power_state , ett_btatt_value , hfx_btatt_battery_power_state , ENC_NA ) ;\n offset += 1 ;\n }\n }\n break ;\n case 0x2A1C : case 0x2A1E : if ( uuid . bt_uuid == 0x2A1C ) {\n if ( service_uuid . bt_uuid == GATT_SERVICE_HEALTH_THERMOMETER ) {\n if ( att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n }\n else if ( uuid . bt_uuid == 0x2A1E ) {\n if ( service_uuid . bt_uuid == GATT_SERVICE_HEALTH_THERMOMETER ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_temperature_measurement_flags , ett_btatt_value , hfx_btatt_temperature_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_temperature_measurement_value_celsius , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n else {\n proto_tree_add_item ( tree , hf_btatt_temperature_measurement_value_fahrenheit , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n if ( flags & 0x02 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_temperature_measurement_timestamp , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_item ( tree , hf_btatt_temperature_type , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n case 0x2A1D : if ( service_uuid . bt_uuid == GATT_SERVICE_HEALTH_THERMOMETER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_temperature_type , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A21 : if ( service_uuid . bt_uuid == GATT_SERVICE_HEALTH_THERMOMETER ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_measurement_interval , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A22 : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n call_dissector_with_data ( usb_hid_boot_keyboard_input_report_handle , tvb_new_subset_remaining ( tvb , offset ) , pinfo , tree , NULL ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A23 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_system_id_manufacturer_identifier , tvb , offset , 5 , ENC_LITTLE_ENDIAN ) ;\n offset += 5 ;\n proto_tree_add_item ( tree , hf_btatt_system_id_organizationally_unique_identifier , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n break ;\n case 0x2A24 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_model_number_string , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A25 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_serial_number_string , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A26 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_firmware_revision_string , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A27 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_hardware_revision_string , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A28 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_software_revision_string , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A29 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_manufacturer_string , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A2A : {\n guint16 count ;\n guint16 list_length = 0 ;\n if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_regulatory_certification_data_list_count , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n count = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n list_length += 2 ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_regulatory_certification_data_list_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n list_length += 2 ;\n offset += 2 ;\n while ( count -- ) {\n proto_item * authorizing_body_data_item ;\n proto_tree * authorizing_body_data_tree ;\n guint8 item_type ;\n guint16 item_length ;\n guint16 certification_data_list_count = 0 ;\n guint16 certification_data_list_length = 0 ;\n proto_item * list_length_item ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_regulatory_certification_data_list_item , tvb , offset , 0 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_regulatory_certification_data_list_item_body , tvb , offset , 1 , ENC_NA ) ;\n list_length += 1 ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_regulatory_certification_data_list_item_body_structure_type , tvb , offset , 1 , ENC_NA ) ;\n item_type = tvb_get_guint8 ( tvb , offset ) ;\n list_length += 1 ;\n offset += 1 ;\n list_length_item = proto_tree_add_item ( sub_tree , hf_btatt_regulatory_certification_data_list_item_body_structure_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n item_length = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n list_length += 2 + item_length ;\n offset += 2 ;\n if ( item_type == 0x01 ) {\n authorizing_body_data_item = proto_tree_add_item ( sub_tree , hf_btatt_regulatory_certification_data_list_item_authorizing_body_data , tvb , offset , item_length , ENC_NA ) ;\n authorizing_body_data_tree = proto_item_add_subtree ( authorizing_body_data_item , ett_btatt_list ) ;\n if ( item_length > 0 ) {\n proto_tree_add_item ( authorizing_body_data_tree , hf_btatt_regulatory_certification_data_list_item_authorizing_body_data_major_ig_version , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( item_length > 1 ) {\n proto_tree_add_item ( authorizing_body_data_tree , hf_btatt_regulatory_certification_data_list_item_authorizing_body_data_minor_ig_version , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( item_length > 2 ) {\n proto_tree_add_item ( authorizing_body_data_tree , hf_btatt_regulatory_certification_data_list_item_authorizing_body_data_certification_data_list_count , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n certification_data_list_count = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( item_length > 4 ) {\n proto_tree_add_item ( authorizing_body_data_tree , hf_btatt_regulatory_certification_data_list_item_authorizing_body_data_certification_data_list_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n certification_data_list_length = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( item_length > 6 && certification_data_list_count ) {\n proto_item * certification_data_list_item ;\n proto_tree * certification_data_list_tree ;\n certification_data_list_item = proto_tree_add_item ( sub_tree , hf_btatt_regulatory_certification_data_list_item_authorizing_body_data_certification_data_list , tvb , offset , certification_data_list_length , ENC_NA ) ;\n certification_data_list_tree = proto_item_add_subtree ( certification_data_list_item , ett_btatt_list ) ;\n while ( certification_data_list_count -- ) {\n proto_tree_add_item ( certification_data_list_tree , hf_btatt_regulatory_certification_data_list_item_authorizing_body_data_certified_device_class , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n }\n }\n else if ( item_type == 0x02 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_regulatory_certification_data_list_item_regulation_bit_field_type , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else {\n proto_tree_add_item ( sub_tree , hf_btatt_regulatory_certification_data_list_item_data , tvb , offset , item_length , ENC_NA ) ;\n offset += item_length ;\n }\n proto_item_set_len ( sub_item , 1 + 1 + 2 + item_length ) ;\n if ( list_length != length ) expert_add_info ( pinfo , list_length_item , & ei_btatt_invalid_length ) ;\n }\n }\n break ;\n case 0x2A2C : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_magnetic_declination , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A31 : if ( service_uuid . bt_uuid == GATT_SERVICE_SCAN_PARAMETERS ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_scan_refresh , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A32 : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n call_dissector_with_data ( usb_hid_boot_keyboard_output_report_handle , tvb_new_subset_remaining ( tvb , offset ) , pinfo , tree , NULL ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A33 : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n call_dissector_with_data ( usb_hid_boot_mouse_input_report_handle , tvb_new_subset_remaining ( tvb , offset ) , pinfo , tree , NULL ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A34 : if ( service_uuid . bt_uuid == GATT_SERVICE_GLUCOSE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_glucose_measurement_context_flags , ett_btatt_value , hfx_btatt_glucose_measurement_context_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_sequence_number , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x80 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_glucose_measurement_context_extended_flags , ett_btatt_value , hfx_btatt_glucose_measurement_context_extended_flags , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_carbohydrate_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_carbohydrate_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_meal , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_glucose_measurement_context_tester_health , ett_btatt_value , hfx_btatt_glucose_measurement_context_tester_health , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_exercise_duration , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_exercise_intensity , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x10 ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_medication_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( flags & 0x20 ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_medication_l , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_medication_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n }\n if ( flags & 0x40 ) {\n proto_tree_add_item ( tree , hf_btatt_glucose_measurement_context_hba1c , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A35 : case 0x2A36 : if ( uuid . bt_uuid == 0x2A35 ) {\n if ( service_uuid . bt_uuid == GATT_SERVICE_BLOOD_PRESSURE ) {\n if ( att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n }\n else if ( uuid . bt_uuid == 0x2A36 ) {\n if ( service_uuid . bt_uuid == GATT_SERVICE_BLOOD_PRESSURE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_blood_pressure_measurement_flags , ett_btatt_value , hfx_btatt_blood_pressure_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_compound_value_systolic_kpa , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_compound_value_diastolic_kpa , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_compound_value_mean_arterial_pressure_kpa , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else {\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_compound_value_systolic_mmhg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_compound_value_diastolic_mmhg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_compound_value_mean_arterial_pressure_mmhg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_timestamp , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_pulse_rate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( tree , hf_btatt_blood_pressure_measurement_user_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x10 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_blood_pressure_measurement_status , ett_btatt_value , hfx_btatt_blood_pressure_measurement_status , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A37 : if ( service_uuid . bt_uuid == GATT_SERVICE_HEART_RATE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_heart_rate_measurement_flags , ett_btatt_value , hfx_btatt_heart_rate_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_heart_rate_measurement_value_16 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else {\n proto_tree_add_item ( tree , hf_btatt_heart_rate_measurement_value_8 , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( tree , hf_btatt_heart_rate_measurement_energy_expended , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x10 ) {\n guint interval_count = 0 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_heart_rate_measurement_rr_intervals , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n while ( tvb_reported_length_remaining ( tvb , offset ) ) {\n proto_tree_add_item ( sub_tree , hf_btatt_heart_rate_measurement_rr_interval , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n interval_count += 1 ;\n }\n proto_item_append_text ( sub_item , \" [count = %2u]\" , interval_count ) ;\n }\n break ;\n case 0x2A38 : if ( service_uuid . bt_uuid == GATT_SERVICE_HEART_RATE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_body_sensor_location , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A39 : if ( service_uuid . bt_uuid == GATT_SERVICE_HEART_RATE ) {\n if ( is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_heart_rate_control_point , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A3F : if ( service_uuid . bt_uuid == GATT_SERVICE_PHONE_ALERT_STATUS_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_alert_status , ett_btatt_value , hfx_btatt_alert_status , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A40 : if ( service_uuid . bt_uuid == GATT_SERVICE_PHONE_ALERT_STATUS_SERVICE ) {\n if ( att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ringer_control_point , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A41 : if ( service_uuid . bt_uuid == GATT_SERVICE_PHONE_ALERT_STATUS_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ringer_setting , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A42 : case 0x2A47 : case 0x2A48 : if ( uuid . bt_uuid == 0x2A47 || uuid . bt_uuid == 0x2A48 ) {\n if ( service_uuid . bt_uuid == GATT_SERVICE_ALERT_NOTIFICATION_SERVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_alert_category_id_bitmask_1 , ett_btatt_value , hfx_btatt_alert_category_id_bitmask_1 , ENC_NA ) ;\n offset += 1 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) >= 1 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_alert_category_id_bitmask_2 , ett_btatt_value , hfx_btatt_alert_category_id_bitmask_2 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n case 0x2A43 : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_alert_category_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A44 : if ( service_uuid . bt_uuid == GATT_SERVICE_ALERT_NOTIFICATION_SERVICE ) {\n if ( is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_alert_command_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_alert_category_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A45 : if ( service_uuid . bt_uuid == GATT_SERVICE_ALERT_NOTIFICATION_SERVICE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_alert_category_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_alert_unread_count , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A46 : if ( service_uuid . bt_uuid == GATT_SERVICE_ALERT_NOTIFICATION_SERVICE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_alert_category_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_alert_number_of_new_alert , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n proto_tree_add_item ( tree , hf_btatt_alert_text_string_information , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n }\n break ;\n case 0x2A49 : if ( service_uuid . bt_uuid == GATT_SERVICE_BLOOD_PRESSURE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_blood_pressure_feature , ett_btatt_value , hfx_btatt_blood_pressure_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A4A : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_hogp_bcd_hid , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_hogp_b_country_code , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_hogp_flags , ett_btatt_value , hfx_btatt_hogp_flags , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A4B : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n offset = dissect_usb_hid_get_report_descriptor ( pinfo , tree , tvb , offset , NULL ) ;\n break ;\n case 0x2A4C : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_hogp_hid_control_point_command , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A4D : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2A4E : if ( service_uuid . bt_uuid == GATT_SERVICE_HUMAN_INTERFACE_DEVICE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_hogp_protocol_mode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A4F : if ( service_uuid . bt_uuid == GATT_SERVICE_SCAN_PARAMETERS ) {\n if ( att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_le_scan_interval , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_le_scan_window , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A50 : if ( service_uuid . bt_uuid == GATT_SERVICE_DEVICE_INFORMATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_pnp_id_vendor_id_source , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( value == 1 ) proto_tree_add_item ( tree , hf_btatt_pnp_id_vendor_id_bluetooth_sig , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else if ( value == 2 ) proto_tree_add_item ( tree , hf_btatt_pnp_id_vendor_id_usb_forum , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( tree , hf_btatt_pnp_id_vendor_id , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_pnp_id_product_id , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_pnp_id_product_version , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A51 : if ( service_uuid . bt_uuid == GATT_SERVICE_GLUCOSE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_glucose_feature , ett_btatt_value , hfx_btatt_glucose_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A52 : if ( service_uuid . bt_uuid == GATT_SERVICE_GLUCOSE || service_uuid . bt_uuid == GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING || service_uuid . bt_uuid == GATT_SERVICE_PULSE_OXIMETER ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_record_access_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_record_access_control_point_operator , tvb , offset , 1 , ENC_NA ) ;\n operator_value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_record_access_control_point_operand , tvb , offset , 0 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n operand_offset = offset ;\n switch ( opcode ) {\n case 1 : case 2 : case 4 : switch ( operator_value ) {\n case 0 : case 1 : case 5 : case 6 : break ;\n case 2 : proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_filter_type , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( value == 0x01 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_max_time_offset , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else {\n proto_tree_add_item ( sub_tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n break ;\n case 3 : proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_filter_type , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( value == 0x01 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_min_time_offset , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else {\n proto_tree_add_item ( sub_tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n break ;\n case 4 : proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_filter_type , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( value == 0x01 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_min_time_offset , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_max_time_offset , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else {\n proto_tree_add_item ( sub_tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n break ;\n }\n break ;\n case 3 : break ;\n case 5 : proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_operand_number_of_records , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 6 : proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_request_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_record_access_control_point_response_code , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n }\n ;\n proto_item_set_len ( sub_item , offset - operand_offset ) ;\n break ;\n case 0x2A53 : if ( service_uuid . bt_uuid == GATT_SERVICE_RUNNING_SPEED_AND_CADENCE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_rsc_measurement_flags , ett_btatt_value , hfx_btatt_rsc_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_rsc_measurement_instantaneous_speed , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_rsc_measurement_instantaneous_cadence , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_rsc_measurement_instantaneous_stride_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_rsc_measurement_total_distance , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n break ;\n case 0x2A54 : if ( service_uuid . bt_uuid == GATT_SERVICE_RUNNING_SPEED_AND_CADENCE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_rsc_feature , ett_btatt_value , hfx_btatt_rsc_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A55 : if ( service_uuid . bt_uuid == GATT_SERVICE_RUNNING_SPEED_AND_CADENCE || service_uuid . bt_uuid == GATT_SERVICE_CYCLING_SPEED_AND_CADENCE ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_sc_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n switch ( opcode ) {\n case 1 : proto_tree_add_item ( tree , hf_btatt_sc_control_point_cumulative_value , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 3 : proto_tree_add_item ( tree , hf_btatt_sensor_location , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 16 : proto_tree_add_item ( tree , hf_btatt_sc_control_point_request_opcode , tvb , offset , 1 , ENC_NA ) ;\n value = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_sc_control_point_response_value , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( value == 0x04 && tvb_get_guint8 ( tvb , offset ) == 0x01 ) {\n while ( tvb_captured_length_remaining ( tvb , offset ) ) {\n proto_tree_add_item ( tree , hf_btatt_sensor_location , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n }\n break ;\n case 2 : case 4 : break ;\n }\n break ;\n case 0x2A56 : if ( service_uuid . bt_uuid == GATT_SERVICE_AUTOMATION_IO ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_digital , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A58 : if ( service_uuid . bt_uuid == GATT_SERVICE_AUTOMATION_IO ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_analog , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A5A : if ( service_uuid . bt_uuid == GATT_SERVICE_AUTOMATION_IO ) {\n if ( is_readable_request ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n btatt_call_dissector_by_dissector_name_with_data ( \"btgatt.uuid0x2a56\" , tvb_new_subset_length_caplen ( tvb , offset , 1 , 1 ) , pinfo , tree , att_data ) ;\n offset += 1 ;\n btatt_call_dissector_by_dissector_name_with_data ( \"btgatt.uuid0x2a58\" , tvb_new_subset_length_caplen ( tvb , offset , 2 , 2 ) , pinfo , tree , att_data ) ;\n offset += 2 ;\n break ;\n case 0x2A5B : if ( service_uuid . bt_uuid == GATT_SERVICE_CYCLING_SPEED_AND_CADENCE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_csc_measurement_flags , ett_btatt_value , hfx_btatt_csc_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_csc_measurement_cumulative_wheel_revolutions , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_btatt_csc_measurement_last_event_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_csc_measurement_cumulative_crank_revolutions , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_csc_measurement_last_event_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A5C : if ( service_uuid . bt_uuid == GATT_SERVICE_CYCLING_SPEED_AND_CADENCE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_csc_feature , ett_btatt_value , hfx_btatt_csc_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A5D : if ( service_uuid . bt_uuid == GATT_SERVICE_RUNNING_SPEED_AND_CADENCE || service_uuid . bt_uuid == GATT_SERVICE_CYCLING_SPEED_AND_CADENCE || service_uuid . bt_uuid == GATT_SERVICE_CYCLING_POWER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_sensor_location , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A5E : if ( service_uuid . bt_uuid == GATT_SERVICE_PULSE_OXIMETER ) {\n if ( att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_spot_check_measurement_flags , ett_btatt_value , hfx_btatt_plx_spot_check_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_plx_spo2pr_spot_check , tvb , offset , 4 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_spo2 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_pulse_rate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_plx_spot_check_measurement_timestamp , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n btatt_call_dissector_by_dissector_name_with_data ( \"btgatt.uuid0x2a08\" , tvb_new_subset_length_caplen ( tvb , offset , 7 , 7 ) , pinfo , sub_tree , att_data ) ;\n offset += 7 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_measurement_status , ett_btatt_value , hfx_btatt_plx_measurement_status , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_device_and_sensor_status , ett_btatt_value , hfx_btatt_plx_device_and_sensor_status , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( tree , hf_btatt_plx_pulse_amplitude_index , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A5F : if ( service_uuid . bt_uuid == GATT_SERVICE_PULSE_OXIMETER ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_continuous_measurement_flags , ett_btatt_value , hfx_btatt_plx_continuous_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_plx_spo2pr_normal , tvb , offset , 4 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_spo2 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_pulse_rate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_plx_spo2pr_fast , tvb , offset , 4 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_spo2 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_pulse_rate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_plx_spo2pr_slow , tvb , offset , 4 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_spo2 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_plx_pulse_rate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_measurement_status , ett_btatt_value , hfx_btatt_plx_measurement_status , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_device_and_sensor_status , ett_btatt_value , hfx_btatt_plx_device_and_sensor_status , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n if ( flags & 0x10 ) {\n proto_tree_add_item ( tree , hf_btatt_plx_pulse_amplitude_index , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A60 : if ( service_uuid . bt_uuid == GATT_SERVICE_PULSE_OXIMETER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_features_supported_features , ett_btatt_value , hfx_btatt_plx_features_supported_features , ENC_LITTLE_ENDIAN ) ;\n flags = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_measurement_status , ett_btatt_value , hfx_btatt_plx_measurement_status , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_plx_device_and_sensor_status , ett_btatt_value , hfx_btatt_plx_device_and_sensor_status , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n break ;\n case 0x2A63 : if ( service_uuid . bt_uuid == GATT_SERVICE_CYCLING_POWER ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cycling_power_measurement_flags , ett_btatt_value , hfx_btatt_cycling_power_measurement_flags , ENC_LITTLE_ENDIAN ) ;\n flags = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_instantaneous_power , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_pedal_power_balance , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_accumulated_torque , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x10 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_wheel_revolution_data_cumulative_wheel_revolutions , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_wheel_revolution_data_last_wheel_event_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x20 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_crank_revolution_data_cumulative_crank_revolutions , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_crank_revolution_data_last_crank_event_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x40 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_extreme_force_magnitudes_maximum_force_magnitude , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_extreme_force_magnitudes_minimum_force_magnitude , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x80 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_extreme_torque_magnitudes_maximum_torque_magnitude , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_extreme_torque_magnitudes_minimum_torque_magnitude , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x100 ) {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cycling_power_measurement_extreme_angles , ett_btatt_value , hfx_btatt_cycling_power_measurement_extreme_angles , ENC_NA ) ;\n offset += 3 ;\n }\n if ( flags & 0x200 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_top_dead_spot_angle , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x400 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_bottom_dead_spot_angle , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x800 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_measurement_accumulated_energy , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A64 : if ( service_uuid . bt_uuid == GATT_SERVICE_CYCLING_POWER ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cycling_power_vector_flags , ett_btatt_value , hfx_btatt_cycling_power_vector_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_vector_crank_revolution_data_cumulative_crank_revolutions , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_vector_crank_revolution_data_last_crank_event_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_vector_first_crank_measurement_angle , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x04 ) {\n while ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_vector_instantaneous_force_magnitude_array , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n }\n if ( flags & 0x08 ) {\n while ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_vector_instantaneous_torque_magnitude_array , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n }\n break ;\n case 0x2A65 : if ( service_uuid . bt_uuid == GATT_SERVICE_CYCLING_POWER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cycling_power_feature , ett_btatt_value , hfx_btatt_cycling_power_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2A66 : if ( service_uuid . bt_uuid == GATT_SERVICE_CYCLING_POWER ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n switch ( opcode ) {\n case 1 : proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_cumulative_value , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 2 : proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_sensor_location , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 4 : proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_crank_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 6 : proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_chain_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 8 : proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_chain_weight , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 10 : proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_span_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 13 : proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cycling_power_control_point_content_mask , ett_btatt_value , hfx_btatt_cycling_power_control_point_content_mask , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 3 : case 5 : case 7 : case 9 : case 11 : case 12 : case 14 : case 15 : break ;\n case 32 : proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_request_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_response_value , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n switch ( tvb_get_guint8 ( tvb , offset - 2 ) ) {\n case 1 : case 2 : case 4 : case 6 : case 8 : case 10 : case 13 : break ;\n case 3 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n while ( tvb_captured_length_remaining ( tvb , offset ) ) {\n proto_tree_add_item ( tree , hf_btatt_sensor_location , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n }\n break ;\n case 5 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_crank_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 7 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_chain_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 9 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_chain_weight , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 11 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_span_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 12 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_start_offset_compensation , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 14 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_sampling_rate , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n case 15 : if ( tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_cycling_power_control_point_factory_calibration_date , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n }\n break ;\n }\n break ;\n case 0x2A67 : if ( service_uuid . bt_uuid == GATT_SERVICE_LOCATION_AND_NAVIGATION ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_location_and_speed_flags , ett_btatt_value , hfx_btatt_location_and_speed_flags , ENC_LITTLE_ENDIAN ) ;\n flags = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_location_and_speed_instantaneous_speed , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_location_and_speed_total_distance , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_item ( tree , hf_btatt_location_and_speed_location_latitude , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_btatt_location_and_speed_location_longitude , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( tree , hf_btatt_location_and_speed_elevation , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n if ( flags & 0x10 ) {\n proto_tree_add_item ( tree , hf_btatt_location_and_speed_heading , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x20 ) {\n proto_tree_add_item ( tree , hf_btatt_location_and_speed_rolling_time , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x40 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_location_and_speed_utc_time , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n case 0x2A68 : if ( service_uuid . bt_uuid == GATT_SERVICE_LOCATION_AND_NAVIGATION ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_navigation_flags , ett_btatt_value , hfx_btatt_navigation_flags , ENC_LITTLE_ENDIAN ) ;\n flags = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_navigation_bearing , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_navigation_heading , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_navigation_remaining_distance , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_navigation_remaining_vertical_distance , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n }\n if ( flags & 0x04 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_navigation_estimated_time_of_arrival , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n case 0x2A69 : if ( service_uuid . bt_uuid == GATT_SERVICE_LOCATION_AND_NAVIGATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_position_quality_flags , ett_btatt_value , hfx_btatt_position_quality_flags , ENC_LITTLE_ENDIAN ) ;\n flags = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_position_quality_number_of_beacons_in_solution , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_position_quality_number_of_beacons_in_view , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_item ( tree , hf_btatt_position_quality_time_to_first_fix , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( tree , hf_btatt_position_quality_ehpe , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n if ( flags & 0x10 ) {\n proto_tree_add_item ( tree , hf_btatt_position_quality_evpe , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n if ( flags & 0x20 ) {\n proto_tree_add_item ( tree , hf_btatt_position_quality_hdop , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x40 ) {\n proto_tree_add_item ( tree , hf_btatt_position_quality_vdop , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n case 0x2A6A : if ( service_uuid . bt_uuid == GATT_SERVICE_LOCATION_AND_NAVIGATION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_ln_feature , ett_btatt_value , hfx_btatt_ln_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2A6B : if ( service_uuid . bt_uuid == GATT_SERVICE_LOCATION_AND_NAVIGATION ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ln_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n switch ( opcode ) {\n case 1 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_cumulative_value , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n break ;\n case 2 : proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_ln_control_point_content_mask , ett_btatt_value , hfx_btatt_ln_control_point_content_mask , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 3 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_navigation_control , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 4 : break ;\n case 5 : case 6 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_route_number , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 7 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_fix_rate , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 8 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_elevation , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n break ;\n case 32 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_request_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_ln_control_point_response_value , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n switch ( tvb_get_guint8 ( tvb , offset - 2 ) ) {\n case 1 : case 2 : case 3 : case 6 : case 7 : case 8 : break ;\n case 4 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_response_value_number_of_routes , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 5 : proto_tree_add_item ( tree , hf_btatt_ln_control_point_response_value_name_of_route , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n }\n break ;\n }\n break ;\n case 0x2A6C : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_elevation , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n break ;\n case 0x2A6D : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_pressure , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2A6E : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_temperature , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A6F : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_humidity , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A70 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_true_wind_speed , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A71 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_true_wind_direction , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A72 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_apparent_wind_speed , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A73 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_apparent_wind_direction , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A74 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_gust_factor , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A75 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_pollen_concentration , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n break ;\n case 0x2A76 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_uv_index , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A77 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_irradiance , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A78 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_rainfall , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A79 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_wind_chill , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A7A : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_heart_index , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A7B : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_dew_point , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A7D : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_descriptor_value_changed_flags , ett_btatt_value , hfx_btatt_descriptor_value_changed_flags , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) == 2 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid16 , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n else if ( tvb_reported_length_remaining ( tvb , offset ) == 16 ) {\n proto_tree_add_item ( tree , hf_btatt_uuid128 , tvb , offset , 16 , ENC_NA ) ;\n offset += 16 ;\n }\n else {\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_bad_data ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n break ;\n case 0x2A7E : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_aerobic_heart_rate_lower_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A7F : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_aerobic_threshold , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A80 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_age , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A81 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_anaerobic_heart_rate_lower_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A82 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_anaerobic_heart_rate_upper_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A83 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_anaerobic_threshold , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A84 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_aerobic_heart_rate_upper_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A85 : case 0x2A86 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A87 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_email_address , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A88 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_fat_burn_heart_rate_lower_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A89 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_fat_burn_heart_rate_upper_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A8A : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_first_name , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A8B : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_five_zone_heart_rate_limits_very_light_light_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_five_zone_heart_rate_limits_light_moderate_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_five_zone_heart_rate_limits_moderate_hard_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_five_zone_heart_rate_limits_hard_maximum_limit , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A8C : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_gender , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A8D : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_heart_rate_max , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A8E : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_height , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A8F : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_hip_circumference , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A90 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_last_name , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2A91 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_maximum_recommended_heart_rate , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A92 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_resting_heart_rate , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A93 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_sport_type_for_aerobic_and_anaerobic_thresholds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A94 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_three_zone_heart_rate_limits_light_moderate , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_three_zone_heart_rate_limits_moderate_hard , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A95 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_two_zone_heart_rate_limit_fat_burn_fitness , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A96 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_vo2_max , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A97 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_waist_circumference , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A98 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_weight , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2A99 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_database_change_increment , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2A9A : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_user_index , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2A9B : if ( service_uuid . bt_uuid == GATT_SERVICE_BODY_COMPOSITION ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_body_composition_feature , ett_btatt_value , hfx_btatt_body_composition_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2A9C : if ( service_uuid . bt_uuid == GATT_SERVICE_BODY_COMPOSITION ) {\n if ( att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_body_composition_measurement_flags , ett_btatt_value , hfx_btatt_body_composition_measurement_flags , ENC_LITTLE_ENDIAN ) ;\n flags = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_body_composition_measurement_body_fat_percentage , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x02 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_body_composition_measurement_timestamp , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_item ( tree , hf_btatt_body_composition_measurement_user_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_basal_metabolism , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x10 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_muscle_percentage , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x20 ) {\n if ( flags & 0x01 ) proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_muscle_mass_lb , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_muscle_mass_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x40 ) {\n if ( flags & 0x01 ) proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_fat_free_mass_lb , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_fat_free_mass_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x80 ) {\n if ( flags & 0x01 ) proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_soft_lean_mass_lb , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_soft_lean_mass_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x100 ) {\n if ( flags & 0x01 ) proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_body_water_mass_lb , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_body_water_mass_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x200 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_impedance , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x400 ) {\n if ( flags & 0x01 ) proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_weight_lb , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_weight_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x800 ) {\n if ( flags & 0x01 ) proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_height_inches , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( sub_tree , hf_btatt_body_composition_measurement_height_meter , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A9D : if ( service_uuid . bt_uuid == GATT_SERVICE_WEIGHT_SCALE ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_weight_measurement_flags , ett_btatt_value , hfx_btatt_weight_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n if ( flags & 0x01 ) proto_tree_add_item ( tree , hf_btatt_weight_measurement_weight_lb , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( tree , hf_btatt_weight_measurement_weight_kg , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x02 ) {\n sub_item = proto_tree_add_item ( tree , hf_btatt_weight_measurement_timestamp , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x04 ) {\n proto_tree_add_item ( tree , hf_btatt_weight_measurement_user_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x08 ) {\n proto_tree_add_item ( sub_tree , hf_btatt_weight_measurement_bmi , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0x01 ) proto_tree_add_item ( sub_tree , hf_btatt_weight_measurement_height_in , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n else proto_tree_add_item ( sub_tree , hf_btatt_weight_measurement_height_m , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2A9E : if ( service_uuid . bt_uuid == GATT_SERVICE_WEIGHT_SCALE ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_weight_scale_feature , ett_btatt_value , hfx_btatt_weight_scale_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2A9F : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_user_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n switch ( opcode ) {\n case 0x01 : sub_item = proto_tree_add_item ( tree , hf_btatt_user_control_point_consent_code , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n value = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n if ( value > 9999 ) expert_add_info ( pinfo , sub_item , & ei_btatt_consent_out_of_bounds ) ;\n offset += 2 ;\n break ;\n case 0x02 : proto_tree_add_item ( tree , hf_btatt_user_index , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_user_control_point_consent_code , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n value = tvb_get_guint16 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n if ( value > 9999 ) expert_add_info ( pinfo , sub_item , & ei_btatt_consent_out_of_bounds ) ;\n offset += 2 ;\n break ;\n case 0x03 : break ;\n case 0x20 : proto_tree_add_item ( tree , hf_btatt_user_control_point_request_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_user_control_point_response_value , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( tvb_get_guint8 ( tvb , offset - 2 ) == 0x01 && tvb_get_guint8 ( tvb , offset - 1 ) == 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_user_index , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n break ;\n }\n break ;\n case 0x2AA0 : case 0x2AA1 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_magnetic_flux_density_x , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_magnetic_flux_density_y , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( uuid . bt_uuid == 0x2AA1 ) {\n proto_tree_add_item ( tree , hf_btatt_magnetic_flux_density_z , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2AA2 : if ( service_uuid . bt_uuid == GATT_SERVICE_USER_DATA ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_language , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2AA3 : if ( service_uuid . bt_uuid == GATT_SERVICE_ENVIRONMENTAL_SENSING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_barometric_pressure_trend , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2AA4 : if ( service_uuid . bt_uuid == GATT_SERVICE_BOND_MANAGEMENT ) {\n if ( is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_bond_management_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n proto_tree_add_item ( tree , hf_btatt_bond_management_control_point_authorization_code , tvb , offset , length - 1 , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n }\n break ;\n case 0x2AA5 : if ( service_uuid . bt_uuid == GATT_SERVICE_BOND_MANAGEMENT ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_bond_management_feature , ett_btatt_value , hfx_btatt_bond_management_feature , ENC_LITTLE_ENDIAN ) ;\n flags = tvb_get_guint24 ( tvb , offset , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n if ( flags & 0x800000 ) {\n do {\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_bond_management_feature_nth , ett_btatt_value , hfx_btatt_bond_management_feature_nth , ENC_LITTLE_ENDIAN ) ;\n offset += 1 ;\n }\n while ( tvb_get_guint8 ( tvb , offset - 1 ) & 0x80 ) ;\n }\n break ;\n case 0x2AA6 : if ( service_uuid . bt_uuid == GATT_SERVICE_GENERIC_ACCESS_PROFILE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_central_address_resolution , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2AA7 : if ( service_uuid . bt_uuid == GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_cgm_measurement_size , tvb , offset , 1 , ENC_NA ) ;\n if ( tvb_get_guint8 ( tvb , offset ) >= 6 ) expert_add_info ( pinfo , sub_item , & ei_btatt_cgm_size_too_small ) ;\n offset += 1 ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cgm_measurement_flags , ett_btatt_value , hfx_btatt_cgm_measurement_flags , ENC_NA ) ;\n flags = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_cgm_measurement_glucose_concentration , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( tree , hf_btatt_cgm_measurement_time_offset , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( flags & 0xE0 ) {\n value = 0 ;\n if ( flags & 0x80 ) value += 1 ;\n if ( flags & 0x40 ) value += 1 ;\n if ( flags & 0x20 ) value += 1 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_cgm_sensor_status_annunciation , tvb , offset , value , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n }\n if ( flags & 0x80 ) {\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_sensor_status_annunciation_status , ett_btatt_value , hfx_btatt_cgm_sensor_status_annunciation_status , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x40 ) {\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_sensor_status_annunciation_cal_temp , ett_btatt_value , hfx_btatt_cgm_sensor_status_annunciation_cal_temp , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x20 ) {\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_sensor_status_annunciation_warning , ett_btatt_value , hfx_btatt_cgm_sensor_status_annunciation_warning , ENC_NA ) ;\n offset += 1 ;\n }\n if ( flags & 0x01 ) {\n proto_tree_add_item ( tree , hf_btatt_cgm_measurement_trend_information , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( flags & 0x02 ) {\n proto_tree_add_item ( tree , hf_btatt_cgm_measurement_quality , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n if ( tvb_reported_length_remaining ( tvb , offset ) >= 2 ) {\n proto_tree_add_item ( tree , hf_btatt_cgm_e2e_crc , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2AA8 : if ( service_uuid . bt_uuid == GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cgm_feature_feature , ett_btatt_value , hfx_btatt_cgm_feature_feature , ENC_LITTLE_ENDIAN ) ;\n offset += 3 ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_cgm_type_and_sample_location , ett_btatt_value , hfx_btatt_cgm_type_and_sample_location , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_cgm_e2e_crc , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2AA9 : if ( service_uuid . bt_uuid == GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_cgm_time_offset , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_cgm_status , tvb , offset , 3 , ENC_LITTLE_ENDIAN ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_sensor_status_annunciation_status , ett_btatt_value , hfx_btatt_cgm_sensor_status_annunciation_status , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_sensor_status_annunciation_cal_temp , ett_btatt_value , hfx_btatt_cgm_sensor_status_annunciation_cal_temp , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_sensor_status_annunciation_warning , ett_btatt_value , hfx_btatt_cgm_sensor_status_annunciation_warning , ENC_NA ) ;\n offset += 1 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) >= 2 ) {\n proto_tree_add_item ( tree , hf_btatt_cgm_e2e_crc , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2AAA : if ( service_uuid . bt_uuid == GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_cgm_session_start_time , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n proto_tree_add_item ( sub_tree , hf_btatt_year , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_month , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_day , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_hours , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_minutes , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_seconds , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_timezone , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_dst_offset , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) >= 2 ) {\n proto_tree_add_item ( tree , hf_btatt_cgm_e2e_crc , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2AAB : if ( service_uuid . bt_uuid == GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_cgm_session_run_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n if ( tvb_reported_length_remaining ( tvb , offset ) >= 2 ) {\n proto_tree_add_item ( tree , hf_btatt_cgm_e2e_crc , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2AAC : if ( service_uuid . bt_uuid == GATT_SERVICE_CONTINUOUS_GLUCOSE_MONITORING ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_cgm_specific_ops_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_cgm_specific_ops_control_point_operand , tvb , offset , 0 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_list ) ;\n operand_offset = offset ;\n switch ( opcode ) {\n case 1 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_operand_communication_interval , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 2 : case 8 : case 11 : case 14 : case 17 : case 20 : case 23 : case 25 : case 26 : case 27 : break ;\n case 4 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_calibration_glucose_concentration , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_calibration_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_type_and_sample_location , ett_btatt_value , hfx_btatt_cgm_type_and_sample_location , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_next_calibration_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_calibration_data_record_number , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_specific_ops_control_point_calibration_status , ett_btatt_value , hfx_btatt_cgm_specific_ops_control_point_calibration_status , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 5 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_operand_calibration_data_record_number , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 7 : case 10 : case 13 : case 16 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_operand_alert_level , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 19 : case 22 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_operand_alert_level_rate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 3 : case 6 : case 9 : case 12 : case 15 : case 18 : case 21 : case 24 : expert_add_info ( pinfo , sub_item , & ei_btatt_opcode_invalid_request ) ;\n break ;\n case 28 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_request_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_response_code , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n switch ( tvb_get_guint8 ( tvb , offset - 2 ) ) {\n case 1 : case 2 : case 4 : case 5 : case 7 : case 8 : case 10 : case 11 : case 13 : case 14 : case 16 : case 17 : case 19 : case 20 : case 22 : case 23 : case 25 : case 26 : case 27 : expert_add_info ( pinfo , sub_item , & ei_btatt_opcode_invalid_response ) ;\n break ;\n case 3 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_operand_communication_interval , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 6 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_calibration_glucose_concentration , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_calibration_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_type_and_sample_location , ett_btatt_value , hfx_btatt_cgm_type_and_sample_location , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_next_calibration_time , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_calibration_data_record_number , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_bitmask ( sub_tree , tvb , offset , hf_btatt_cgm_specific_ops_control_point_calibration_status , ett_btatt_value , hfx_btatt_cgm_specific_ops_control_point_calibration_status , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 9 : case 12 : case 15 : case 18 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_operand_alert_level , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 21 : case 24 : proto_tree_add_item ( sub_tree , hf_btatt_cgm_specific_ops_control_point_operand_alert_level_rate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n }\n break ;\n }\n ;\n proto_item_set_len ( sub_item , offset - operand_offset ) ;\n if ( tvb_reported_length_remaining ( tvb , offset ) >= 2 ) {\n proto_tree_add_item ( tree , hf_btatt_cgm_e2e_crc , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n }\n break ;\n case 0x2AAD : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_indoor_positioning_configuration , ett_btatt_value , hfx_btatt_indoor_positioning_configuration , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2AAE : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_latitude , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2AAF : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_longitude , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2AB0 : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_local_north_coordinate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2AB1 : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_local_east_coordinate , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2AB2 : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_floor_number , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2AB3 : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_altitude , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n break ;\n case 0x2AB4 : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_uncertainty , ett_btatt_value , hfx_btatt_uncertainty , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2AB5 : if ( service_uuid . bt_uuid == GATT_SERVICE_INDOOR_POSITIONING ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_WRITE_COMMAND ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_location_name , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2AB6 : if ( service_uuid . bt_uuid == GATT_SERVICE_HTTP_PROXY ) {\n if ( is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_uri , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2AB7 : if ( service_uuid . bt_uuid == GATT_SERVICE_HTTP_PROXY ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_http_headers , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n call_dissector ( http_handle , tvb_new_subset_remaining ( tvb , offset ) , pinfo , sub_tree ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2AB8 : if ( service_uuid . bt_uuid == GATT_SERVICE_HTTP_PROXY ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_http_status_code , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n offset += 2 ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_http_data_status , ett_btatt_value , hfx_btatt_http_data_status , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2AB9 : if ( service_uuid . bt_uuid == GATT_SERVICE_HTTP_PROXY ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_http_entity_body , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2ABA : if ( service_uuid . bt_uuid == GATT_SERVICE_HTTP_PROXY ) {\n if ( is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_http_control_point_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2ABB : if ( service_uuid . bt_uuid == GATT_SERVICE_HTTP_PROXY ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_https_security , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2ABC : if ( service_uuid . bt_uuid == GATT_SERVICE_TRANSPORT_DISCOVERY ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_tds_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n if ( att_data -> opcode == 0x1B || att_data -> opcode == 0x1D ) {\n proto_tree_add_item ( tree , hf_btatt_tds_result_code , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n else {\n proto_tree_add_item ( tree , hf_btatt_tds_organization_id , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n }\n if ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n proto_tree_add_item ( tree , hf_btatt_tds_data , tvb , offset , tvb_reported_length_remaining ( tvb , offset ) , ENC_NA ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n }\n break ;\n case 0x2ABD : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_ots_feature_oacp , ett_btatt_value , hfx_btatt_ots_feature_oacp , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_ots_feature_olcp , ett_btatt_value , hfx_btatt_ots_feature_olcp , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2ABE : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ots_object_name , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_captured_length_remaining ( tvb , offset ) ;\n break ;\n case 0x2ABF : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n offset = dissect_gatt_uuid ( tree , pinfo , tvb , offset ) ;\n break ;\n case 0x2AC0 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ots_current_size , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_btatt_ots_allocated_size , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2AC1 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_ots_object_first_created , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n btatt_call_dissector_by_dissector_name_with_data ( \"btgatt.uuid0x2a08\" , tvb_new_subset_length_caplen ( tvb , offset , 7 , 7 ) , pinfo , sub_tree , att_data ) ;\n offset += 7 ;\n break ;\n case 0x2AC2 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_ots_object_last_modified , tvb , offset , 7 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btatt_value ) ;\n btatt_call_dissector_by_dissector_name_with_data ( \"btgatt.uuid0x2a08\" , tvb_new_subset_length_caplen ( tvb , offset , 7 , 7 ) , pinfo , sub_tree , att_data ) ;\n offset += 7 ;\n break ;\n case 0x2AC3 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ots_object_id , tvb , offset , 6 , ENC_LITTLE_ENDIAN ) ;\n offset += 6 ;\n break ;\n case 0x2AC4 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_ots_properties , ett_btatt_value , hfx_btatt_ots_properties , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x2AC5 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ots_action_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n switch ( opcode ) {\n case 0x01 : proto_tree_add_item ( tree , hf_btatt_ots_size , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n offset = dissect_gatt_uuid ( tree , pinfo , tvb , offset ) ;\n break ;\n case 0x02 : case 0x07 : break ;\n case 0x03 : case 0x05 : case 0x06 : proto_tree_add_item ( tree , hf_btatt_ots_offset , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_btatt_ots_length , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n case 0x04 : if ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n proto_tree_add_item ( tree , hf_btatt_ots_execute_data , tvb , offset , tvb_reported_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n }\n break ;\n case 0x60 : proto_tree_add_item ( tree , hf_btatt_ots_action_response_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_ots_action_result_code , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n switch ( tvb_get_guint8 ( tvb , offset ) ) {\n case 0x01 : case 0x02 : case 0x05 : case 0x06 : case 0x07 : case 0x60 : break ;\n case 0x03 : proto_tree_add_checksum ( tree , tvb , offset , hf_btatt_ots_checksum , - 1 , NULL , pinfo , 0 , ENC_BIG_ENDIAN , PROTO_CHECKSUM_NO_FLAGS ) ;\n offset += 4 ;\n break ;\n case 0x04 : if ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n proto_tree_add_item ( tree , hf_btatt_ots_execute_data , tvb , offset , tvb_reported_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n }\n break ;\n }\n }\n break ;\n case 0x2AC6 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ots_list_opcode , tvb , offset , 1 , ENC_NA ) ;\n opcode = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n switch ( opcode ) {\n case 0x01 : case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x08 : break ;\n case 0x05 : proto_tree_add_item ( tree , hf_btatt_ots_object_id , tvb , offset , 6 , ENC_LITTLE_ENDIAN ) ;\n offset += 6 ;\n break ;\n case 0x06 : proto_tree_add_item ( tree , hf_btatt_ots_list_order , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x70 : proto_tree_add_item ( tree , hf_btatt_ots_list_response_opcode , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_ots_list_result_code , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n switch ( tvb_get_guint8 ( tvb , offset - 2 ) ) {\n case 0x01 : case 0x02 : case 0x03 : case 0x04 : case 0x05 : case 0x06 : case 0x08 : case 0x70 : break ;\n case 0x07 : proto_tree_add_item ( tree , hf_btatt_ots_list_total_number_of_objects , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n }\n }\n break ;\n case 0x2AC7 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( is_readable_request ( att_data -> opcode ) || is_writeable_response ( att_data -> opcode ) ) break ;\n if ( ! is_readable_response ( att_data -> opcode ) && ! is_writeable_request ( att_data -> opcode ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_ots_filter , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n switch ( tvb_get_guint8 ( tvb , offset - 1 ) ) {\n case 0x00 : case 0x0A : break ;\n case 0x01 : case 0x02 : case 0x03 : case 0x04 : proto_tree_add_item ( tree , hf_btatt_ots_name_string , tvb , offset , tvb_reported_length_remaining ( tvb , offset ) , ENC_NA | ENC_UTF_8 ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n break ;\n case 0x05 : offset = dissect_gatt_uuid ( tree , pinfo , tvb , offset ) ;\n break ;\n case 0x06 : case 0x07 : btatt_call_dissector_by_dissector_name_with_data ( \"btgatt.uuid0x2a08\" , tvb_new_subset_length_caplen ( tvb , offset , 7 , 7 ) , pinfo , tree , att_data ) ;\n offset += 7 ;\n btatt_call_dissector_by_dissector_name_with_data ( \"btgatt.uuid0x2a08\" , tvb_new_subset_length_caplen ( tvb , offset , 7 , 7 ) , pinfo , tree , att_data ) ;\n offset += 7 ;\n break ;\n case 0x08 : case 0x09 : proto_tree_add_item ( tree , hf_btatt_ots_size_from , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_btatt_ots_size_to , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n break ;\n }\n break ;\n case 0x2AC8 : if ( service_uuid . bt_uuid == GATT_SERVICE_OBJECT_TRANSFER ) {\n if ( att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_btatt_ots_flags , ett_btatt_value , hfx_btatt_ots_flags , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_btatt_ots_object_id , tvb , offset , 6 , ENC_LITTLE_ENDIAN ) ;\n offset += 6 ;\n break ;\n case 0x2AC9 : if ( service_uuid . bt_uuid == GATT_SERVICE_GENERIC_ACCESS_PROFILE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_resolvable_private_address , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n break ;\n case 0x2ACC : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2ACD : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2ACE : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2ACF : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD0 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD1 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD2 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD3 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD4 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD5 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD6 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD7 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD8 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( ! ( is_readable_request ( att_data -> opcode ) || is_readable_response ( att_data -> opcode ) ) ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2AD9 : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( is_writeable_response ( att_data -> opcode ) || att_data -> opcode == ATT_OPCODE_HANDLE_VALUE_CONFIRMATION ) break ;\n if ( ! is_writeable_request ( att_data -> opcode ) && att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_INDICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2ADA : if ( service_uuid . bt_uuid == GATT_SERVICE_FITNESS_MACHINE ) {\n if ( att_data -> opcode != ATT_OPCODE_HANDLE_VALUE_NOTIFICATION ) expert_add_info ( pinfo , tree , & ei_btatt_invalid_usage ) ;\n }\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n sub_item = proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n expert_add_info ( pinfo , sub_item , & ei_btatt_undecoded ) ;\n offset = tvb_captured_length ( tvb ) ;\n break ;\n case 0x2A1F : case 0x2A20 : case 0x2A2F : case 0x2A30 : case 0x2A3A : case 0x2A3B : case 0x2A3C : case 0x2A3D : case 0x2A3E : case 0x2A57 : case 0x2A59 : case 0x2ADB : case 0x2ADC : case 0x2ADD : case 0x2ADE : case 0x2AE0 : case 0x2AE1 : case 0x2AE2 : case 0x2AE3 : case 0x2AE4 : case 0x2AE5 : case 0x2AE6 : case 0x2AE7 : case 0x2AE8 : case 0x2AE9 : case 0x2AEA : case 0x2AEB : case 0x2AEC : case 0x2AED : case 0x2AEE : case 0x2AEF : case 0x2AF0 : case 0x2AF1 : case 0x2AF2 : case 0x2AF3 : case 0x2AF4 : case 0x2AF5 : case 0x2AF6 : case 0x2AF7 : case 0x2AF8 : case 0x2AF9 : case 0x2AFA : case 0x2AFB : case 0x2AFC : case 0x2AFD : case 0x2AFE : case 0x2AFF : case 0x2B00 : case 0x2B01 : case 0x2B02 : case 0x2B03 : case 0x2B04 : case 0x2B05 : case 0x2B06 : case 0x2B07 : case 0x2B08 : case 0x2B09 : case 0x2B0A : case 0x2B0B : case 0x2B0C : case 0x2B0D : case 0x2B0E : case 0x2B0F : case 0x2B10 : case 0x2B11 : case 0x2B12 : case 0x2B13 : case 0x2B14 : case 0x2B15 : case 0x2B16 : case 0x2B17 : case 0x2B18 : case 0x2B19 : case 0x2B1A : case 0x2B1B : case 0x2B1C : case 0x2B1D : case 0x2B1E : case 0x2B1F : default : if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) break ;\n proto_tree_add_item ( tree , hf_btatt_value , tvb , offset , - 1 , ENC_NA ) ;\n offset = tvb_captured_length ( tvb ) ;\n }\n return old_offset + offset ;\n }", "hash": 5045872831385413038, "project": "debian", "size": 3048, "target": 0, "idx": 4931}
{"code": "static int dissect_btgatt_microbit_button_b_state ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , void * data ) {\n btatt_data_t * att_data = ( btatt_data_t * ) data ;\n gint offset = 0 ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return - 1 ;\n proto_tree_add_item ( tree , hf_gatt_microbit_button_b_state , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n return offset ;\n }", "hash": 5045872831385413038, "project": "debian", "size": 8, "target": 0, "idx": 4934}
{"code": "static gboolean is_long_attribute_value ( bluetooth_uuid_t uuid ) {\n switch ( uuid . bt_uuid ) {\n case 0x2901 : case 0x2A00 : case 0x2A24 : case 0x2A25 : case 0x2A26 : case 0x2A27 : case 0x2A28 : case 0x2A29 : case 0x2A4B : case 0x2A87 : case 0x2A90 : case 0x2AA4 : case 0x2AB5 : case 0x2AB6 : case 0x2AB7 : case 0x2AB9 : case 0x2ABE : return TRUE ;\n }\n return FALSE ;\n }", "hash": 5045872831385413038, "project": "debian", "size": 6, "target": 0, "idx": 4936}
{"code": "static void save_value_fragment ( packet_info * pinfo , tvbuff_t * tvb , gint offset , guint32 handle , guint data_offset , bluetooth_data_t * bluetooth_data ) {\n wmem_tree_key_t key [ 5 ] ;\n guint32 frame_number ;\n fragment_data_t * fragment_data ;\n frame_number = pinfo -> num ;\n key [ 0 ] . length = 1 ;\n key [ 0 ] . key = & bluetooth_data -> interface_id ;\n key [ 1 ] . length = 1 ;\n key [ 1 ] . key = & bluetooth_data -> adapter_id ;\n key [ 2 ] . length = 1 ;\n key [ 2 ] . key = & handle ;\n key [ 3 ] . length = 1 ;\n key [ 3 ] . key = & frame_number ;\n key [ 4 ] . length = 0 ;\n key [ 4 ] . key = NULL ;\n fragment_data = wmem_new ( wmem_file_scope ( ) , fragment_data_t ) ;\n fragment_data -> length = tvb_captured_length_remaining ( tvb , offset ) ;\n fragment_data -> offset = data_offset ;\n fragment_data -> data_in_frame = frame_number ;\n fragment_data -> data = ( guint8 * ) tvb_memdup ( wmem_file_scope ( ) , tvb , offset , fragment_data -> length ) ;\n wmem_tree_insert32_array ( fragments , key , fragment_data ) ;\n }", "hash": 5045872831385413038, "project": "debian", "size": 22, "target": 0, "idx": 4937}
{"code": "static guint16 dissect_mpa_fpdu ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , mpa_state_t * state , struct tcpinfo * tcpinfo , guint8 endpoint ) {\n proto_item * mpa_item = NULL ;\n proto_item * mpa_header_item = NULL ;\n proto_tree * mpa_tree = NULL ;\n proto_tree * mpa_header_tree = NULL ;\n guint8 pad_length ;\n guint16 ulpdu_length , exp_ulpdu_length ;\n guint32 offset , total_length ;\n guint32 num_of_m = 0 ;\n if ( state -> minfo [ endpoint ] . valid && get_first_marker_offset ( state , tcpinfo , endpoint ) == 0 ) {\n offset = MPA_MARKER_LEN ;\n }\n else {\n offset = 0 ;\n }\n ulpdu_length = ( guint16 ) tvb_get_ntohs ( tvb , offset ) ;\n if ( state -> minfo [ endpoint ] . valid ) {\n num_of_m = number_of_markers ( state , tcpinfo , endpoint ) ;\n }\n pad_length = fpdu_pad_length ( ulpdu_length ) ;\n exp_ulpdu_length = expected_ulpdu_length ( state , tcpinfo , endpoint ) ;\n if ( ! exp_ulpdu_length || exp_ulpdu_length != ( ulpdu_length + pad_length ) ) {\n return 0 ;\n }\n mpa_packetlist ( pinfo , MPA_FPDU ) ;\n mpa_item = proto_tree_add_item ( tree , proto_iwarp_mpa , tvb , 0 , - 1 , ENC_NA ) ;\n mpa_tree = proto_item_add_subtree ( mpa_item , ett_mpa ) ;\n mpa_header_item = proto_tree_add_item ( mpa_tree , hf_mpa_fpdu , tvb , offset , - 1 , ENC_NA ) ;\n mpa_header_tree = proto_item_add_subtree ( mpa_header_item , ett_mpa ) ;\n proto_tree_add_uint ( mpa_header_tree , hf_mpa_ulpdu_length , tvb , offset , MPA_ULPDU_LENGTH_LEN , ulpdu_length ) ;\n if ( state -> minfo [ endpoint ] . valid && num_of_m > 0 ) {\n total_length = fpdu_total_length ( tcpinfo ) ;\n if ( pad_length > 0 ) {\n proto_tree_add_item ( mpa_header_tree , hf_mpa_pad , tvb , pad_offset ( tcpinfo , total_length , pad_length ) , pad_length , ENC_NA ) ;\n }\n dissect_fpdu_crc ( tvb , mpa_header_tree , state , total_length - MPA_CRC_LEN , num_of_m * MPA_MARKER_LEN + ulpdu_length + pad_length + MPA_ULPDU_LENGTH_LEN ) ;\n dissect_fpdu_markers ( tvb , mpa_tree , state , tcpinfo , endpoint ) ;\n }\n else {\n offset += MPA_ULPDU_LENGTH_LEN + ulpdu_length ;\n if ( pad_length > 0 ) {\n proto_tree_add_item ( mpa_header_tree , hf_mpa_pad , tvb , offset , pad_length , ENC_NA ) ;\n offset += pad_length ;\n }\n dissect_fpdu_crc ( tvb , mpa_header_tree , state , offset , ulpdu_length + pad_length + MPA_ULPDU_LENGTH_LEN ) ;\n }\n return ulpdu_length ;\n }", "hash": -8178805850432684665, "project": "debian", "size": 48, "target": 0, "idx": 4951}
{"code": "static void dissect_fpdu_crc ( tvbuff_t * tvb , proto_tree * tree , mpa_state_t * state , guint32 offset , guint32 length ) {\n guint32 crc = 0 ;\n guint32 sent_crc = 0 ;\n if ( state -> crc ) {\n crc = ~ crc32c_tvb_offset_calculate ( tvb , 0 , length , CRC32C_PRELOAD ) ;\n sent_crc = tvb_get_ntohl ( tvb , offset ) ;\n if ( crc == sent_crc ) {\n proto_tree_add_uint_format_value ( tree , hf_mpa_crc_check , tvb , offset , MPA_CRC_LEN , sent_crc , \"0x%08x (Good CRC32)\" , sent_crc ) ;\n }\n else {\n proto_tree_add_uint_format_value ( tree , hf_mpa_crc_check , tvb , offset , MPA_CRC_LEN , sent_crc , \"0x%08x (Bad CRC32, should be 0x%08x)\" , sent_crc , crc ) ;\n }\n }\n else {\n proto_tree_add_item ( tree , hf_mpa_crc , tvb , offset , MPA_CRC_LEN , ENC_BIG_ENDIAN ) ;\n }\n }", "hash": -8178805850432684665, "project": "debian", "size": 17, "target": 0, "idx": 4960}
{"code": "bool vmxnet_tx_pkt_parse ( struct VmxnetTxPkt * pkt ) {\n return vmxnet_tx_pkt_parse_headers ( pkt ) && vmxnet_tx_pkt_rebuild_payload ( pkt ) ;\n }", "hash": -282365232561056844, "project": "debian", "size": 3, "target": 0, "idx": 4976}
{"code": "void vmxnet_tx_pkt_dump ( struct VmxnetTxPkt * pkt ) {\n # ifdef VMXNET_TX_PKT_DEBUG assert ( pkt ) ;\n printf ( \"TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, \" \"l3hdr_len: %lu, payload_len: %u\\n\" , pkt -> hdr_len , pkt -> packet_type , pkt -> vec [ VMXNET_TX_PKT_L2HDR_FRAG ] . iov_len , pkt -> vec [ VMXNET_TX_PKT_L3HDR_FRAG ] . iov_len , pkt -> payload_len ) ;\n # endif }", "hash": -282365232561056844, "project": "debian", "size": 4, "target": 0, "idx": 4981}
{"code": "inline static bool is_localhost ( const char * name , int len ) {\n static const char local [ ] = \"127.0.0.1\" ;\n return ( len == ( sizeof ( local ) - 1 ) ) && ( memcmp ( name , local , len ) == 0 ) ;\n }", "hash": -8934524072451888241, "project": "debian", "size": 4, "target": 0, "idx": 4986}
{"code": "static inline bool is_port_in_range ( int port , HttpConfigPortRange * pr ) {\n while ( pr ) {\n if ( pr -> low == - 1 ) {\n return true ;\n }\n else if ( ( pr -> low <= port ) && ( pr -> high >= port ) ) {\n return true ;\n }\n pr = pr -> next ;\n }\n return false ;\n }", "hash": -8934524072451888241, "project": "debian", "size": 12, "target": 0, "idx": 4991}
{"code": "inline static bool does_method_require_cache_copy_deletion ( const HttpConfigParams * http_config_param , const int method ) {\n return ( ( method != HTTP_WKSIDX_GET ) && ( method == HTTP_WKSIDX_DELETE || method == HTTP_WKSIDX_PURGE || method == HTTP_WKSIDX_PUT || ( http_config_param -> cache_post_method != 1 && method == HTTP_WKSIDX_POST ) ) ) ;\n }", "hash": -8934524072451888241, "project": "debian", "size": 3, "target": 0, "idx": 4996}
{"code": "int MDC2_Init ( MDC2_CTX * c ) {\n c -> num = 0 ;\n c -> pad_type = 1 ;\n memset ( & ( c -> h [ 0 ] ) , 0x52 , MDC2_BLOCK ) ;\n memset ( & ( c -> hh [ 0 ] ) , 0x25 , MDC2_BLOCK ) ;\n return 1 ;\n }", "hash": -1361752047994420669, "project": "debian", "size": 7, "target": 0, "idx": 5000}
{"code": "static inline krb5_error_code data_to_gss ( krb5_data * input_k5data , gss_buffer_t output_buffer ) {\n krb5_error_code code = 0 ;\n output_buffer -> length = input_k5data -> length ;\n # if defined ( _WIN32 ) || defined ( DEBUG_GSSALLOC ) if ( output_buffer -> length > 0 ) {\n output_buffer -> value = gssalloc_malloc ( output_buffer -> length ) ;\n if ( output_buffer -> value ) memcpy ( output_buffer -> value , input_k5data -> data , output_buffer -> length ) ;\n else code = ENOMEM ;\n }\n else {\n output_buffer -> value = NULL ;\n }\n free ( input_k5data -> data ) ;\n # else output_buffer -> value = input_k5data -> data ;\n # endif * input_k5data = empty_data ( ) ;\n return code ;\n }", "hash": -2161707065154251694, "project": "debian", "size": 16, "target": 0, "idx": 5003}
{"code": "static float * calc_distr ( const float * p , int n , int m , float rest ) {\n float * row , * prev_row , * tmp ;\n int i , j ;\n row = ( float * ) palloc ( ( m + 1 ) * sizeof ( float ) ) ;\n prev_row = ( float * ) palloc ( ( m + 1 ) * sizeof ( float ) ) ;\n row [ 0 ] = 1.0f ;\n for ( i = 1 ;\n i <= n ;\n i ++ ) {\n float t = p [ i - 1 ] ;\n tmp = row ;\n row = prev_row ;\n prev_row = tmp ;\n for ( j = 0 ;\n j <= i && j <= m ;\n j ++ ) {\n float val = 0.0f ;\n if ( j < i ) val += prev_row [ j ] * ( 1.0f - t ) ;\n if ( j > 0 ) val += prev_row [ j - 1 ] * t ;\n row [ j ] = val ;\n }\n }\n if ( rest > DEFAULT_CONTAIN_SEL ) {\n float t ;\n tmp = row ;\n row = prev_row ;\n prev_row = tmp ;\n for ( i = 0 ;\n i <= m ;\n i ++ ) row [ i ] = 0.0f ;\n t = exp ( - rest ) ;\n for ( i = 0 ;\n i <= m ;\n i ++ ) {\n for ( j = 0 ;\n j <= m - i ;\n j ++ ) row [ j + i ] += prev_row [ j ] * t ;\n t *= rest / ( float ) ( i + 1 ) ;\n }\n }\n pfree ( prev_row ) ;\n return row ;\n }", "hash": -5241093592682744127, "project": "debian", "size": 43, "target": 0, "idx": 5018}
{"code": "static double patternjoinsel ( PG_FUNCTION_ARGS , Pattern_Type ptype , bool negate ) {\n return negate ? ( 1.0 - DEFAULT_MATCH_SEL ) : DEFAULT_MATCH_SEL ;\n }", "hash": 355220887711506893, "project": "debian", "size": 3, "target": 0, "idx": 5058}
{"code": "static Node * strip_array_coercion ( Node * node ) {\n for ( ;\n ;\n ) {\n if ( node && IsA ( node , ArrayCoerceExpr ) && ( ( ArrayCoerceExpr * ) node ) -> elemfuncid == InvalidOid ) {\n node = ( Node * ) ( ( ArrayCoerceExpr * ) node ) -> arg ;\n }\n else if ( node && IsA ( node , RelabelType ) ) {\n node = ( Node * ) ( ( RelabelType * ) node ) -> arg ;\n }\n else break ;\n }\n return node ;\n }", "hash": 355220887711506893, "project": "debian", "size": 14, "target": 0, "idx": 5060}
{"code": "static bool gincost_scalararrayopexpr ( PlannerInfo * root , IndexOptInfo * index , IndexQualInfo * qinfo , double numIndexEntries , GinQualCounts * counts ) {\n int indexcol = qinfo -> indexcol ;\n Oid clause_op = qinfo -> clause_op ;\n Node * rightop = qinfo -> other_operand ;\n ArrayType * arrayval ;\n int16 elmlen ;\n bool elmbyval ;\n char elmalign ;\n int numElems ;\n Datum * elemValues ;\n bool * elemNulls ;\n GinQualCounts arraycounts ;\n int numPossible = 0 ;\n int i ;\n Assert ( ( ( ScalarArrayOpExpr * ) qinfo -> rinfo -> clause ) -> useOr ) ;\n rightop = estimate_expression_value ( root , rightop ) ;\n if ( IsA ( rightop , RelabelType ) ) rightop = ( Node * ) ( ( RelabelType * ) rightop ) -> arg ;\n if ( ! IsA ( rightop , Const ) ) {\n counts -> exactEntries ++ ;\n counts -> searchEntries ++ ;\n counts -> arrayScans *= estimate_array_length ( rightop ) ;\n return true ;\n }\n if ( ( ( Const * ) rightop ) -> constisnull ) return false ;\n arrayval = DatumGetArrayTypeP ( ( ( Const * ) rightop ) -> constvalue ) ;\n get_typlenbyvalalign ( ARR_ELEMTYPE ( arrayval ) , & elmlen , & elmbyval , & elmalign ) ;\n deconstruct_array ( arrayval , ARR_ELEMTYPE ( arrayval ) , elmlen , elmbyval , elmalign , & elemValues , & elemNulls , & numElems ) ;\n memset ( & arraycounts , 0 , sizeof ( arraycounts ) ) ;\n for ( i = 0 ;\n i < numElems ;\n i ++ ) {\n GinQualCounts elemcounts ;\n if ( elemNulls [ i ] ) continue ;\n memset ( & elemcounts , 0 , sizeof ( elemcounts ) ) ;\n if ( gincost_pattern ( index , indexcol , clause_op , elemValues [ i ] , & elemcounts ) ) {\n numPossible ++ ;\n if ( elemcounts . haveFullScan ) {\n elemcounts . partialEntries = 0 ;\n elemcounts . exactEntries = numIndexEntries ;\n elemcounts . searchEntries = numIndexEntries ;\n }\n arraycounts . partialEntries += elemcounts . partialEntries ;\n arraycounts . exactEntries += elemcounts . exactEntries ;\n arraycounts . searchEntries += elemcounts . searchEntries ;\n }\n }\n if ( numPossible == 0 ) {\n return false ;\n }\n counts -> partialEntries += arraycounts . partialEntries / numPossible ;\n counts -> exactEntries += arraycounts . exactEntries / numPossible ;\n counts -> searchEntries += arraycounts . searchEntries / numPossible ;\n counts -> arrayScans *= numPossible ;\n return true ;\n }", "hash": 355220887711506893, "project": "debian", "size": 55, "target": 0, "idx": 5076}
{"code": "static double eqjoinsel_inner ( Oid operator , VariableStatData * vardata1 , VariableStatData * vardata2 ) {\n double selec ;\n double nd1 ;\n double nd2 ;\n bool isdefault1 ;\n bool isdefault2 ;\n Oid opfuncoid ;\n Form_pg_statistic stats1 = NULL ;\n Form_pg_statistic stats2 = NULL ;\n bool have_mcvs1 = false ;\n Datum * values1 = NULL ;\n int nvalues1 = 0 ;\n float4 * numbers1 = NULL ;\n int nnumbers1 = 0 ;\n bool have_mcvs2 = false ;\n Datum * values2 = NULL ;\n int nvalues2 = 0 ;\n float4 * numbers2 = NULL ;\n int nnumbers2 = 0 ;\n nd1 = get_variable_numdistinct ( vardata1 , & isdefault1 ) ;\n nd2 = get_variable_numdistinct ( vardata2 , & isdefault2 ) ;\n opfuncoid = get_opcode ( operator ) ;\n if ( HeapTupleIsValid ( vardata1 -> statsTuple ) ) {\n stats1 = ( Form_pg_statistic ) GETSTRUCT ( vardata1 -> statsTuple ) ;\n if ( statistic_proc_security_check ( vardata1 , opfuncoid ) ) have_mcvs1 = get_attstatsslot ( vardata1 -> statsTuple , vardata1 -> atttype , vardata1 -> atttypmod , STATISTIC_KIND_MCV , InvalidOid , NULL , & values1 , & nvalues1 , & numbers1 , & nnumbers1 ) ;\n }\n if ( HeapTupleIsValid ( vardata2 -> statsTuple ) ) {\n stats2 = ( Form_pg_statistic ) GETSTRUCT ( vardata2 -> statsTuple ) ;\n if ( statistic_proc_security_check ( vardata2 , opfuncoid ) ) have_mcvs2 = get_attstatsslot ( vardata2 -> statsTuple , vardata2 -> atttype , vardata2 -> atttypmod , STATISTIC_KIND_MCV , InvalidOid , NULL , & values2 , & nvalues2 , & numbers2 , & nnumbers2 ) ;\n }\n if ( have_mcvs1 && have_mcvs2 ) {\n FmgrInfo eqproc ;\n bool * hasmatch1 ;\n bool * hasmatch2 ;\n double nullfrac1 = stats1 -> stanullfrac ;\n double nullfrac2 = stats2 -> stanullfrac ;\n double matchprodfreq , matchfreq1 , matchfreq2 , unmatchfreq1 , unmatchfreq2 , otherfreq1 , otherfreq2 , totalsel1 , totalsel2 ;\n int i , nmatches ;\n fmgr_info ( opfuncoid , & eqproc ) ;\n hasmatch1 = ( bool * ) palloc0 ( nvalues1 * sizeof ( bool ) ) ;\n hasmatch2 = ( bool * ) palloc0 ( nvalues2 * sizeof ( bool ) ) ;\n matchprodfreq = 0.0 ;\n nmatches = 0 ;\n for ( i = 0 ;\n i < nvalues1 ;\n i ++ ) {\n int j ;\n for ( j = 0 ;\n j < nvalues2 ;\n j ++ ) {\n if ( hasmatch2 [ j ] ) continue ;\n if ( DatumGetBool ( FunctionCall2Coll ( & eqproc , DEFAULT_COLLATION_OID , values1 [ i ] , values2 [ j ] ) ) ) {\n hasmatch1 [ i ] = hasmatch2 [ j ] = true ;\n matchprodfreq += numbers1 [ i ] * numbers2 [ j ] ;\n nmatches ++ ;\n break ;\n }\n }\n }\n CLAMP_PROBABILITY ( matchprodfreq ) ;\n matchfreq1 = unmatchfreq1 = 0.0 ;\n for ( i = 0 ;\n i < nvalues1 ;\n i ++ ) {\n if ( hasmatch1 [ i ] ) matchfreq1 += numbers1 [ i ] ;\n else unmatchfreq1 += numbers1 [ i ] ;\n }\n CLAMP_PROBABILITY ( matchfreq1 ) ;\n CLAMP_PROBABILITY ( unmatchfreq1 ) ;\n matchfreq2 = unmatchfreq2 = 0.0 ;\n for ( i = 0 ;\n i < nvalues2 ;\n i ++ ) {\n if ( hasmatch2 [ i ] ) matchfreq2 += numbers2 [ i ] ;\n else unmatchfreq2 += numbers2 [ i ] ;\n }\n CLAMP_PROBABILITY ( matchfreq2 ) ;\n CLAMP_PROBABILITY ( unmatchfreq2 ) ;\n pfree ( hasmatch1 ) ;\n pfree ( hasmatch2 ) ;\n otherfreq1 = 1.0 - nullfrac1 - matchfreq1 - unmatchfreq1 ;\n otherfreq2 = 1.0 - nullfrac2 - matchfreq2 - unmatchfreq2 ;\n CLAMP_PROBABILITY ( otherfreq1 ) ;\n CLAMP_PROBABILITY ( otherfreq2 ) ;\n totalsel1 = matchprodfreq ;\n if ( nd2 > nvalues2 ) totalsel1 += unmatchfreq1 * otherfreq2 / ( nd2 - nvalues2 ) ;\n if ( nd2 > nmatches ) totalsel1 += otherfreq1 * ( otherfreq2 + unmatchfreq2 ) / ( nd2 - nmatches ) ;\n totalsel2 = matchprodfreq ;\n if ( nd1 > nvalues1 ) totalsel2 += unmatchfreq2 * otherfreq1 / ( nd1 - nvalues1 ) ;\n if ( nd1 > nmatches ) totalsel2 += otherfreq2 * ( otherfreq1 + unmatchfreq1 ) / ( nd1 - nmatches ) ;\n selec = ( totalsel1 < totalsel2 ) ? totalsel1 : totalsel2 ;\n }\n else {\n double nullfrac1 = stats1 ? stats1 -> stanullfrac : 0.0 ;\n double nullfrac2 = stats2 ? stats2 -> stanullfrac : 0.0 ;\n selec = ( 1.0 - nullfrac1 ) * ( 1.0 - nullfrac2 ) ;\n if ( nd1 > nd2 ) selec /= nd1 ;\n else selec /= nd2 ;\n }\n if ( have_mcvs1 ) free_attstatsslot ( vardata1 -> atttype , values1 , nvalues1 , numbers1 , nnumbers1 ) ;\n if ( have_mcvs2 ) free_attstatsslot ( vardata2 -> atttype , values2 , nvalues2 , numbers2 , nnumbers2 ) ;\n return selec ;\n }", "hash": 355220887711506893, "project": "debian", "size": 103, "target": 0, "idx": 5093}
{"code": "static int netstat_seq_show ( struct seq_file * seq , void * v ) {\n int i ;\n struct net * net = seq -> private ;\n seq_puts ( seq , \"TcpExt:\" ) ;\n for ( i = 0 ;\n snmp4_net_list [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" %s\" , snmp4_net_list [ i ] . name ) ;\n seq_puts ( seq , \"\\nTcpExt:\" ) ;\n for ( i = 0 ;\n snmp4_net_list [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" %lu\" , snmp_fold_field ( ( void __percpu * * ) net -> mib . net_statistics , snmp4_net_list [ i ] . entry ) ) ;\n seq_puts ( seq , \"\\nIpExt:\" ) ;\n for ( i = 0 ;\n snmp4_ipextstats_list [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" %s\" , snmp4_ipextstats_list [ i ] . name ) ;\n seq_puts ( seq , \"\\nIpExt:\" ) ;\n for ( i = 0 ;\n snmp4_ipextstats_list [ i ] . name != NULL ;\n i ++ ) seq_printf ( seq , \" %llu\" , snmp_fold_field64 ( ( void __percpu * * ) net -> mib . ip_statistics , snmp4_ipextstats_list [ i ] . entry , offsetof ( struct ipstats_mib , syncp ) ) ) ;\n seq_putc ( seq , '\\n' ) ;\n return 0 ;\n }", "hash": -7690167309709817279, "project": "debian", "size": 22, "target": 0, "idx": 5122}
{"code": "static int ipv4_local_port_range ( ctl_table * table , int write , void __user * buffer , size_t * lenp , loff_t * ppos ) {\n int ret ;\n int range [ 2 ] ;\n ctl_table tmp = {\n . data = & range , . maxlen = sizeof ( range ) , . mode = table -> mode , . extra1 = & ip_local_port_range_min , . extra2 = & ip_local_port_range_max , }\n ;\n inet_get_local_port_range ( range , range + 1 ) ;\n ret = proc_dointvec_minmax ( & tmp , write , buffer , lenp , ppos ) ;\n if ( write && ret == 0 ) {\n if ( range [ 1 ] < range [ 0 ] ) ret = - EINVAL ;\n else set_local_port_range ( range ) ;\n }\n return ret ;\n }", "hash": 4365405643121995465, "project": "debian", "size": 14, "target": 0, "idx": 5133}
{"code": "static void pk_transaction_init ( PkTransaction * transaction ) {\n gboolean ret ;\n g_autoptr ( GError ) error = NULL ;\n transaction -> priv = PK_TRANSACTION_GET_PRIVATE ( transaction ) ;\n transaction -> priv -> allow_cancel = TRUE ;\n transaction -> priv -> caller_active = TRUE ;\n transaction -> priv -> cached_transaction_flags = PK_TRANSACTION_FLAG_ENUM_NONE ;\n transaction -> priv -> cached_filters = PK_FILTER_ENUM_NONE ;\n transaction -> priv -> uid = PK_TRANSACTION_UID_INVALID ;\n transaction -> priv -> role = PK_ROLE_ENUM_UNKNOWN ;\n transaction -> priv -> status = PK_STATUS_ENUM_WAIT ;\n transaction -> priv -> percentage = PK_BACKEND_PERCENTAGE_INVALID ;\n transaction -> priv -> state = PK_TRANSACTION_STATE_UNKNOWN ;\n transaction -> priv -> dbus = pk_dbus_new ( ) ;\n transaction -> priv -> results = pk_results_new ( ) ;\n transaction -> priv -> supported_content_types = g_ptr_array_new_with_free_func ( g_free ) ;\n transaction -> priv -> authority = polkit_authority_get_sync ( NULL , & error ) ;\n if ( transaction -> priv -> authority == NULL ) g_error ( \"failed to get pokit authority: %s\" , error -> message ) ;\n transaction -> priv -> cancellable = g_cancellable_new ( ) ;\n transaction -> priv -> transaction_db = pk_transaction_db_new ( ) ;\n ret = pk_transaction_db_load ( transaction -> priv -> transaction_db , & error ) ;\n if ( ! ret ) g_error ( \"PkEngine: failed to load transaction db: %s\" , error -> message ) ;\n }", "hash": 6755873269946787742, "project": "debian", "size": 23, "target": 0, "idx": 5150}
{"code": "void pk_transaction_get_updates ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {\n PkBitfield filter ;\n g_autoptr ( GError ) error = NULL ;\n g_return_if_fail ( PK_IS_TRANSACTION ( transaction ) ) ;\n g_return_if_fail ( transaction -> priv -> tid != NULL ) ;\n g_variant_get ( params , \"(t)\" , & filter ) ;\n g_debug ( \"GetUpdates method called\" ) ;\n if ( ! pk_backend_is_implemented ( transaction -> priv -> backend , PK_ROLE_ENUM_GET_UPDATES ) ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NOT_SUPPORTED , \"GetUpdates not supported by backend\" ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n transaction -> priv -> cached_filters = filter ;\n pk_transaction_set_role ( transaction , PK_ROLE_ENUM_GET_UPDATES ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_READY ) ;\n out : pk_transaction_dbus_return ( context , error ) ;\n }", "hash": 6755873269946787742, "project": "debian", "size": 17, "target": 0, "idx": 5155}
{"code": "static gboolean pk_transaction_obtain_authorization ( PkTransaction * transaction , PkRoleEnum role , GError * * error ) {\n g_autoptr ( GPtrArray ) actions = NULL ;\n PkTransactionPrivate * priv = transaction -> priv ;\n g_autofree gchar * package_ids = NULL ;\n g_autoptr ( PolkitDetails ) details = NULL ;\n g_autoptr ( GString ) string = NULL ;\n g_return_val_if_fail ( priv -> sender != NULL , FALSE ) ;\n if ( pk_bitfield_contain ( transaction -> priv -> cached_transaction_flags , PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD ) || pk_bitfield_contain ( transaction -> priv -> cached_transaction_flags , PK_TRANSACTION_FLAG_ENUM_SIMULATE ) || priv -> skip_auth_check == TRUE ) {\n g_debug ( \"No authentication required\" ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_READY ) ;\n return TRUE ;\n }\n if ( priv -> subject == NULL ) {\n g_set_error ( error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_REFUSED_BY_POLICY , \"subject %s not found\" , priv -> sender ) ;\n return FALSE ;\n }\n actions = pk_transaction_role_to_actions ( role , priv -> cached_transaction_flags ) ;\n if ( actions == NULL ) return FALSE ;\n return pk_transaction_authorize_actions ( transaction , role , actions ) ;\n }", "hash": 6755873269946787742, "project": "debian", "size": 20, "target": 0, "idx": 5161}
{"code": "void pk_transaction_install_packages ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {\n gboolean ret ;\n guint length ;\n PkBitfield transaction_flags ;\n g_autoptr ( GError ) error = NULL ;\n g_autofree gchar * * package_ids = NULL ;\n g_autofree gchar * package_ids_temp = NULL ;\n g_autofree gchar * transaction_flags_temp = NULL ;\n g_return_if_fail ( PK_IS_TRANSACTION ( transaction ) ) ;\n g_return_if_fail ( transaction -> priv -> tid != NULL ) ;\n g_variant_get ( params , \"(t^a&s)\" , & transaction_flags , & package_ids ) ;\n package_ids_temp = pk_package_ids_to_string ( package_ids ) ;\n transaction_flags_temp = pk_transaction_flag_bitfield_to_string ( transaction_flags ) ;\n g_debug ( \"InstallPackages method called: %s (transaction_flags: %s)\" , package_ids_temp , transaction_flags_temp ) ;\n if ( ! pk_backend_is_implemented ( transaction -> priv -> backend , PK_ROLE_ENUM_INSTALL_PACKAGES ) ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NOT_SUPPORTED , \"InstallPackages not supported by backend\" ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n length = g_strv_length ( package_ids ) ;\n if ( length > PK_TRANSACTION_MAX_PACKAGES_TO_PROCESS ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NUMBER_OF_PACKAGES_INVALID , \"Too many packages to process (%i/%i)\" , length , PK_TRANSACTION_MAX_PACKAGES_TO_PROCESS ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n ret = pk_package_ids_check ( package_ids ) ;\n if ( ! ret ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID , \"The package id's '%s' are not valid\" , package_ids_temp ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n transaction -> priv -> cached_transaction_flags = transaction_flags ;\n transaction -> priv -> cached_package_ids = g_strdupv ( package_ids ) ;\n pk_transaction_set_role ( transaction , PK_ROLE_ENUM_INSTALL_PACKAGES ) ;\n pk_transaction_emit_property_changed ( transaction , \"TransactionFlags\" , g_variant_new_uint64 ( transaction_flags ) ) ;\n ret = pk_transaction_obtain_authorization ( transaction , PK_ROLE_ENUM_INSTALL_PACKAGES , & error ) ;\n if ( ! ret ) {\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n out : pk_transaction_dbus_return ( context , error ) ;\n }", "hash": 6755873269946787742, "project": "debian", "size": 42, "target": 0, "idx": 5166}
{"code": "static gchar * pk_transaction_get_content_type_for_file ( const gchar * filename , GError * * error ) {\n g_autoptr ( GError ) error_local = NULL ;\n g_autoptr ( GFile ) file = NULL ;\n g_autoptr ( GFileInfo ) info = NULL ;\n file = g_file_new_for_path ( filename ) ;\n info = g_file_query_info ( file , \"standard::content-type\" , G_FILE_QUERY_INFO_NONE , NULL , & error_local ) ;\n if ( info == NULL ) {\n g_set_error ( error , 1 , 0 , \"failed to get file attributes for %s: %s\" , filename , error_local -> message ) ;\n return NULL ;\n }\n return g_file_info_get_attribute_as_string ( info , \"standard::content-type\" ) ;\n }", "hash": 6755873269946787742, "project": "debian", "size": 12, "target": 0, "idx": 5167}
{"code": "static void pk_transaction_cancel ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {\n gboolean ret ;\n const gchar * sender ;\n guint uid ;\n g_autoptr ( GError ) error = NULL ;\n g_return_if_fail ( PK_IS_TRANSACTION ( transaction ) ) ;\n g_return_if_fail ( transaction -> priv -> tid != NULL ) ;\n g_debug ( \"Cancel method called on %s\" , transaction -> priv -> tid ) ;\n if ( transaction -> priv -> state == PK_TRANSACTION_STATE_FINISHED ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NOT_RUNNING , \"Transaction is already finished\" ) ;\n goto out ;\n }\n if ( ! pk_backend_is_implemented ( transaction -> priv -> backend , PK_ROLE_ENUM_CANCEL ) ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NOT_SUPPORTED , \"Cancel not supported by backend\" ) ;\n goto out ;\n }\n if ( transaction -> priv -> finished ) {\n g_debug ( \"No point trying to cancel a finished transaction, ignoring\" ) ;\n pk_transaction_dbus_return ( context , NULL ) ;\n goto out ;\n }\n if ( transaction -> priv -> role == PK_ROLE_ENUM_UNKNOWN ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NO_ROLE , \"No role\" ) ;\n goto out ;\n }\n sender = g_dbus_method_invocation_get_sender ( context ) ;\n ret = ( g_strcmp0 ( transaction -> priv -> sender , sender ) == 0 ) ;\n if ( ret ) {\n g_debug ( \"same sender, no need to check uid\" ) ;\n goto skip_uid ;\n }\n if ( transaction -> priv -> uid == PK_TRANSACTION_UID_INVALID ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_CANNOT_CANCEL , \"No context from caller to get UID from\" ) ;\n goto out ;\n }\n uid = pk_dbus_get_uid ( transaction -> priv -> dbus , sender ) ;\n if ( uid == PK_TRANSACTION_UID_INVALID ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_INVALID_STATE , \"unable to get uid of caller\" ) ;\n goto out ;\n }\n if ( transaction -> priv -> uid != uid ) {\n g_debug ( \"uid does not match (%i vs. %i)\" , transaction -> priv -> uid , uid ) ;\n ret = pk_transaction_obtain_authorization ( transaction , PK_ROLE_ENUM_CANCEL , & error ) ;\n if ( ! ret ) goto out ;\n }\n skip_uid : if ( transaction -> priv -> state <= PK_TRANSACTION_STATE_READY ) {\n g_autofree gchar * msg = NULL ;\n msg = g_strdup_printf ( \"%s was cancelled and was never run\" , transaction -> priv -> tid ) ;\n pk_transaction_error_code_emit ( transaction , PK_ERROR_ENUM_TRANSACTION_CANCELLED , msg ) ;\n pk_transaction_finished_emit ( transaction , PK_EXIT_ENUM_CANCELLED , 0 ) ;\n goto out ;\n }\n pk_backend_job_set_status ( transaction -> priv -> job , PK_STATUS_ENUM_CANCEL ) ;\n pk_backend_job_set_allow_cancel ( transaction -> priv -> job , FALSE ) ;\n pk_backend_job_set_exit_code ( transaction -> priv -> job , PK_EXIT_ENUM_CANCELLED ) ;\n pk_backend_cancel ( transaction -> priv -> backend , transaction -> priv -> job ) ;\n out : pk_transaction_dbus_return ( context , error ) ;\n }", "hash": 6755873269946787742, "project": "debian", "size": 58, "target": 0, "idx": 5170}
{"code": "static void pk_transaction_class_init ( PkTransactionClass * klass ) {\n GObjectClass * object_class = G_OBJECT_CLASS ( klass ) ;\n object_class -> dispose = pk_transaction_dispose ;\n object_class -> finalize = pk_transaction_finalize ;\n signals [ SIGNAL_FINISHED ] = g_signal_new ( \"finished\" , G_TYPE_FROM_CLASS ( object_class ) , G_SIGNAL_RUN_LAST , 0 , NULL , NULL , g_cclosure_marshal_VOID__VOID , G_TYPE_NONE , 0 ) ;\n signals [ SIGNAL_STATE_CHANGED ] = g_signal_new ( \"state-changed\" , G_TYPE_FROM_CLASS ( object_class ) , G_SIGNAL_RUN_LAST , 0 , NULL , NULL , g_cclosure_marshal_VOID__UINT , G_TYPE_NONE , 1 , G_TYPE_UINT ) ;\n signals [ SIGNAL_ALLOW_CANCEL_CHANGED ] = g_signal_new ( \"allow-cancel-changed\" , G_TYPE_FROM_CLASS ( object_class ) , G_SIGNAL_RUN_LAST , 0 , NULL , NULL , g_cclosure_marshal_VOID__UINT , G_TYPE_NONE , 1 , G_TYPE_UINT ) ;\n g_type_class_add_private ( klass , sizeof ( PkTransactionPrivate ) ) ;\n }", "hash": 6755873269946787742, "project": "debian", "size": 9, "target": 0, "idx": 5174}
{"code": "static void pk_transaction_dispose ( GObject * object ) {\n PkTransaction * transaction ;\n g_return_if_fail ( PK_IS_TRANSACTION ( object ) ) ;\n transaction = PK_TRANSACTION ( object ) ;\n if ( transaction -> priv -> waiting_for_auth ) {\n g_cancellable_cancel ( transaction -> priv -> cancellable ) ;\n pk_transaction_error_code_emit ( transaction , PK_ERROR_ENUM_NOT_AUTHORIZED , \"client did not authorize action\" ) ;\n pk_transaction_finished_emit ( transaction , PK_EXIT_ENUM_FAILED , 0 ) ;\n }\n if ( transaction -> priv -> registration_id > 0 ) {\n g_dbus_connection_unregister_object ( transaction -> priv -> connection , transaction -> priv -> registration_id ) ;\n transaction -> priv -> registration_id = 0 ;\n }\n if ( transaction -> priv -> connection != NULL ) {\n g_debug ( \"emitting destroy %s\" , transaction -> priv -> tid ) ;\n g_dbus_connection_emit_signal ( transaction -> priv -> connection , NULL , transaction -> priv -> tid , PK_DBUS_INTERFACE_TRANSACTION , \"Destroy\" , NULL , NULL ) ;\n }\n G_OBJECT_CLASS ( pk_transaction_parent_class ) -> dispose ( object ) ;\n }", "hash": 6755873269946787742, "project": "debian", "size": 19, "target": 0, "idx": 5189}
{"code": "static enum nss_status gaih_getanswer ( const querybuf * answer1 , int anslen1 , const querybuf * answer2 , int anslen2 , const char * qname , struct gaih_addrtuple * * pat , char * buffer , size_t buflen , int * errnop , int * h_errnop , int32_t * ttlp ) {\n int first = 1 ;\n enum nss_status status = NSS_STATUS_NOTFOUND ;\n if ( anslen1 > 0 ) status = gaih_getanswer_slice ( answer1 , anslen1 , qname , & pat , & buffer , & buflen , errnop , h_errnop , ttlp , & first ) ;\n if ( ( status == NSS_STATUS_SUCCESS || status == NSS_STATUS_NOTFOUND || ( status == NSS_STATUS_TRYAGAIN && ( * errnop != ERANGE || * h_errnop == NO_RECOVERY ) ) ) && answer2 != NULL && anslen2 > 0 ) {\n enum nss_status status2 = gaih_getanswer_slice ( answer2 , anslen2 , qname , & pat , & buffer , & buflen , errnop , h_errnop , ttlp , & first ) ;\n if ( status != NSS_STATUS_SUCCESS && status2 != NSS_STATUS_NOTFOUND ) status = status2 ;\n }\n return status ;\n }", "hash": 155037296040076635, "project": "debian", "size": 10, "target": 0, "idx": 5201}
{"code": "static void dissect_q931_IEs ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * root_tree , proto_tree * q931_tree , gboolean is_over_ip , int offset , int initial_codeset , q931_packet_info * q931_pi ) {\n proto_item * ti ;\n proto_tree * ie_tree = NULL ;\n guint8 info_element ;\n guint8 dummy ;\n guint16 info_element_len ;\n int codeset , locked_codeset ;\n gboolean non_locking_shift , first_segment ;\n tvbuff_t * h225_tvb , * next_tvb ;\n e164_info_t e164_info ;\n e164_info . e164_number_type = NONE ;\n e164_info . nature_of_address = NONE ;\n e164_info . E164_number_str = \"\" ;\n e164_info . E164_number_length = NONE ;\n codeset = locked_codeset = initial_codeset ;\n first_segment = FALSE ;\n while ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n info_element = tvb_get_guint8 ( tvb , offset ) ;\n if ( ( info_element & Q931_IE_SO_MASK ) && ( ( info_element & Q931_IE_SO_IDENTIFIER_MASK ) == Q931_IE_SHIFT ) ) {\n non_locking_shift = info_element & Q931_IE_SHIFT_NON_LOCKING ;\n codeset = info_element & Q931_IE_SHIFT_CODESET ;\n if ( ! non_locking_shift ) locked_codeset = codeset ;\n if ( q931_tree != NULL ) {\n proto_tree_add_uint_format ( q931_tree , hf_q931_locking_codeset , tvb , offset , 1 , codeset , \"%s shift to codeset %u: %s\" , ( non_locking_shift ? \"Non-locking\" : \"Locking\" ) , codeset , val_to_str ( codeset , q931_codeset_vals , \"Unknown (0x%02X)\" ) ) ;\n }\n offset += 1 ;\n continue ;\n }\n if ( info_element & Q931_IE_SO_MASK ) {\n if ( dissector_get_uint_handle ( codeset_dissector_table , codeset ) || dissector_get_uint_handle ( ie_dissector_table , ( codeset << 8 ) | ( info_element & Q931_IE_SO_IDENTIFIER_MASK ) ) ) {\n next_tvb = tvb_new_subset_length ( tvb , offset , 1 ) ;\n if ( dissector_try_uint ( ie_dissector_table , ( codeset << 8 ) | ( info_element & Q931_IE_SO_IDENTIFIER_MASK ) , next_tvb , pinfo , q931_tree ) || dissector_try_uint ( codeset_dissector_table , codeset , next_tvb , pinfo , q931_tree ) ) {\n offset += 1 ;\n codeset = locked_codeset ;\n continue ;\n }\n }\n switch ( ( codeset << 8 ) | ( info_element & Q931_IE_SO_IDENTIFIER_MASK ) ) {\n case CS0 | Q931_IE_MORE_DATA_OR_SEND_COMP : switch ( info_element ) {\n case Q931_IE_MORE_DATA : proto_tree_add_item ( q931_tree , hf_q931_more_data , tvb , offset , 1 , ENC_NA ) ;\n break ;\n case Q931_IE_SENDING_COMPLETE : proto_tree_add_item ( q931_tree , hf_q931_sending_complete , tvb , offset , 1 , ENC_NA ) ;\n break ;\n default : proto_tree_add_expert_format ( q931_tree , pinfo , & ei_q931_information_element , tvb , offset , 1 , \"Unknown information element (0x%02X)\" , info_element ) ;\n break ;\n }\n break ;\n case CS0 | Q931_IE_CONGESTION_LEVEL : proto_tree_add_item ( q931_tree , hf_q931_congestion_level , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n break ;\n case CS0 | Q931_IE_REPEAT_INDICATOR : proto_tree_add_item ( q931_tree , hf_q931_repeat_indicator , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n break ;\n default : proto_tree_add_expert_format ( q931_tree , pinfo , & ei_q931_information_element , tvb , offset , 1 , \"Unknown information element (0x%02X)\" , info_element ) ;\n break ;\n }\n offset += 1 ;\n codeset = locked_codeset ;\n continue ;\n }\n if ( is_over_ip && tvb_bytes_exist ( tvb , offset , 4 ) && codeset == 0 && tvb_get_guint8 ( tvb , offset ) == Q931_IE_USER_USER && tvb_get_guint8 ( tvb , offset + 3 ) == Q931_PROTOCOL_DISCRIMINATOR_ASN1 ) {\n info_element_len = tvb_get_ntohs ( tvb , offset + 1 ) ;\n if ( q931_tree != NULL ) {\n ie_tree = proto_tree_add_subtree ( q931_tree , tvb , offset , 1 + 2 + info_element_len , ett_q931_ie [ info_element ] , NULL , val_to_str ( info_element , q931_info_element_vals [ codeset ] , \"Unknown information element (0x%02X)\" ) ) ;\n proto_tree_add_uint_format_value ( ie_tree , hf_q931_information_element , tvb , offset , 1 , info_element , \"%s\" , val_to_str ( info_element , q931_info_element_vals [ codeset ] , \"Unknown (0x%02X)\" ) ) ;\n proto_tree_add_item ( ie_tree , hf_q931_information_element_len , tvb , offset + 1 , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( ie_tree , hf_q931_user_protocol_discriminator , tvb , offset + 3 , 1 , ENC_NA ) ;\n }\n if ( info_element_len > 1 ) {\n if ( ! pinfo -> can_desegment ) {\n info_element_len = MIN ( info_element_len , tvb_captured_length_remaining ( tvb , offset + 3 ) ) ;\n }\n if ( h225_handle != NULL ) {\n h225_tvb = tvb_new_subset_length ( tvb , offset + 4 , info_element_len - 1 ) ;\n call_dissector ( h225_handle , h225_tvb , pinfo , root_tree ) ;\n }\n else {\n proto_tree_add_item ( ie_tree , hf_q931_user_information_bytes , tvb , offset + 4 , info_element_len - 1 , ENC_NA ) ;\n }\n }\n offset += 1 + 2 + info_element_len ;\n }\n else {\n info_element_len = tvb_get_guint8 ( tvb , offset + 1 ) ;\n if ( first_segment && ( tvb_reported_length_remaining ( tvb , offset + 2 ) < info_element_len ) ) {\n proto_tree_add_expert ( q931_tree , pinfo , & ei_q931_incomplete_ie , tvb , offset , - 1 ) ;\n break ;\n }\n if ( dissector_get_uint_handle ( codeset_dissector_table , codeset ) || dissector_get_uint_handle ( ie_dissector_table , ( codeset << 8 ) | info_element ) ) {\n next_tvb = tvb_new_subset_length ( tvb , offset , info_element_len + 2 ) ;\n if ( dissector_try_uint ( ie_dissector_table , ( codeset << 8 ) | info_element , next_tvb , pinfo , q931_tree ) || dissector_try_uint ( codeset_dissector_table , codeset , next_tvb , pinfo , q931_tree ) ) {\n offset += 2 + info_element_len ;\n codeset = locked_codeset ;\n continue ;\n }\n }\n ie_tree = proto_tree_add_subtree ( q931_tree , tvb , offset , 1 + 1 + info_element_len , ett_q931_ie [ info_element ] , & ti , val_to_str ( info_element , q931_info_element_vals [ codeset ] , \"Unknown information element (0x%02X)\" ) ) ;\n proto_tree_add_uint_format_value ( ie_tree , hf_q931_information_element , tvb , offset , 1 , info_element , \"%s\" , val_to_str ( info_element , q931_info_element_vals [ codeset ] , \"Unknown (0x%02X)\" ) ) ;\n proto_tree_add_uint ( ie_tree , hf_q931_information_element_len , tvb , offset + 1 , 1 , info_element_len ) ;\n if ( ( ( codeset << 8 ) | info_element ) == ( CS0 | Q931_IE_SEGMENTED_MESSAGE ) ) {\n dissect_q931_segmented_message_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree , ti ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" of %s\" , val_to_str_ext ( tvb_get_guint8 ( tvb , offset + 3 ) , & q931_message_type_vals_ext , \"Unknown message type (0x%02X)\" ) ) ;\n if ( tvb_get_guint8 ( tvb , offset + 2 ) & 0x80 ) {\n first_segment = TRUE ;\n }\n else {\n proto_tree_add_item ( q931_tree , hf_q931_message_segment , tvb , offset + 4 , - 1 , ENC_NA ) ;\n info_element_len += tvb_reported_length_remaining ( tvb , offset + 4 ) ;\n }\n }\n else {\n switch ( ( codeset << 8 ) | info_element ) {\n case CS0 | Q931_IE_BEARER_CAPABILITY : case CS0 | Q931_IE_LOW_LAYER_COMPAT : if ( q931_tree != NULL ) {\n dissect_q931_bearer_capability_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_CAUSE : dissect_q931_cause_ie_with_info ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_cause_value , & dummy , q931_info_element_vals0 , q931_pi ) ;\n break ;\n case CS0 | Q931_IE_CHANGE_STATUS : if ( q931_tree != NULL ) {\n dissect_q931_change_status_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_CALL_STATE : if ( q931_tree != NULL ) {\n dissect_q931_call_state_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_CHANNEL_IDENTIFICATION : if ( q931_tree != NULL ) {\n dissect_q931_channel_identification_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_PROGRESS_INDICATOR : if ( q931_tree != NULL ) {\n dissect_q931_progress_indicator_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_NETWORK_SPECIFIC_FACIL : case CS0 | Q931_IE_TRANSIT_NETWORK_SEL : if ( q931_tree != NULL ) {\n dissect_q931_ns_facilities_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_NOTIFICATION_INDICATOR : if ( q931_tree != NULL ) {\n dissect_q931_notification_indicator_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_DISPLAY : if ( q931_tree != NULL ) {\n dissect_q931_ia5_ie ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_display_information ) ;\n }\n break ;\n case CS0 | Q931_IE_DATE_TIME : dissect_q931_date_time_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree ) ;\n break ;\n case CS0 | Q931_IE_KEYPAD_FACILITY : if ( q931_tree != NULL ) {\n dissect_q931_ia5_ie ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_keypad_facility ) ;\n }\n break ;\n case CS0 | Q931_IE_SIGNAL : dissect_q931_signal_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree , ti ) ;\n break ;\n case CS0 | Q931_IE_INFORMATION_RATE : dissect_q931_information_rate_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree , ti ) ;\n break ;\n case CS0 | Q931_IE_E2E_TRANSIT_DELAY : dissect_q931_e2e_transit_delay_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree , ti ) ;\n break ;\n case CS0 | Q931_IE_TD_SELECTION_AND_INT : dissect_q931_td_selection_and_int_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree , ti ) ;\n break ;\n case CS0 | Q931_IE_PL_BINARY_PARAMETERS : if ( q931_tree != NULL ) {\n dissect_q931_pl_binary_parameters_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_PL_WINDOW_SIZE : if ( q931_tree != NULL ) {\n dissect_q931_pl_window_size_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_PACKET_SIZE : if ( q931_tree != NULL ) {\n dissect_q931_packet_size_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_CUG : if ( q931_tree != NULL ) {\n dissect_q931_cug_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_REVERSE_CHARGE_IND : if ( q931_tree != NULL ) {\n dissect_q931_reverse_charge_ind_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_CONNECTED_NUMBER_DEFAULT : if ( q931_tree != NULL ) {\n dissect_q931_number_ie ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_connected_number , e164_info , q931_pi ) ;\n }\n break ;\n case CS0 | Q931_IE_CALLING_PARTY_NUMBER : e164_info . e164_number_type = CALLING_PARTY_NUMBER ;\n dissect_q931_number_ie ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_calling_party_number , e164_info , q931_pi ) ;\n break ;\n case CS0 | Q931_IE_CALLED_PARTY_NUMBER : e164_info . e164_number_type = CALLED_PARTY_NUMBER ;\n dissect_q931_number_ie ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_called_party_number , e164_info , q931_pi ) ;\n break ;\n case CS0 | Q931_IE_CALLING_PARTY_SUBADDR : case CS0 | Q931_IE_CALLED_PARTY_SUBADDR : if ( q931_tree != NULL ) {\n dissect_q931_party_subaddr_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_REDIRECTING_NUMBER : if ( q931_tree != NULL ) {\n dissect_q931_number_ie ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_redirecting_number , e164_info , q931_pi ) ;\n }\n break ;\n case CS0 | Q931_IE_RESTART_INDICATOR : dissect_q931_restart_indicator_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree , ti ) ;\n break ;\n case CS0 | Q931_IE_HIGH_LAYER_COMPAT : if ( q931_tree != NULL ) {\n dissect_q931_high_layer_compat_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS0 | Q931_IE_USER_USER : if ( q931_tree != NULL ) {\n dissect_q931_user_user_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS5 | Q931_IE_PARTY_CATEGORY : if ( q931_tree != NULL ) {\n dissect_q931_party_category_ie ( tvb , offset + 2 , info_element_len , ie_tree ) ;\n }\n break ;\n case CS6 | Q931_IE_DISPLAY : if ( q931_tree != NULL ) {\n dissect_q931_ia5_ie ( tvb , offset + 2 , info_element_len , ie_tree , hf_q931_avaya_display ) ;\n }\n break ;\n default : if ( q931_tree != NULL ) {\n proto_tree_add_item ( ie_tree , hf_q931_data , tvb , offset + 2 , info_element_len , ENC_NA ) ;\n }\n break ;\n }\n }\n offset += 1 + 1 + info_element_len ;\n }\n codeset = locked_codeset ;\n }\n tap_queue_packet ( q931_tap , pinfo , q931_pi ) ;\n }", "hash": -1338403456839869183, "project": "debian", "size": 226, "target": 0, "idx": 5205}
{"code": "static void dissect_q931_date_time_ie ( tvbuff_t * tvb , packet_info * pinfo , int offset , int len , proto_tree * tree ) {\n if ( len == 6 ) {\n proto_tree_add_bytes_format_value ( tree , hf_q931_date_time , tvb , offset , 6 , NULL , \"%02u-%02u-%02u %02u:%02u:%02u\" , tvb_get_guint8 ( tvb , offset + 0 ) , tvb_get_guint8 ( tvb , offset + 1 ) , tvb_get_guint8 ( tvb , offset + 2 ) , tvb_get_guint8 ( tvb , offset + 3 ) , tvb_get_guint8 ( tvb , offset + 4 ) , tvb_get_guint8 ( tvb , offset + 5 ) ) ;\n }\n else if ( len == 5 ) {\n proto_tree_add_bytes_format_value ( tree , hf_q931_date_time , tvb , offset , 5 , NULL , \"%02u-%02u-%02u %02u:%02u:00\" , tvb_get_guint8 ( tvb , offset + 0 ) , tvb_get_guint8 ( tvb , offset + 1 ) , tvb_get_guint8 ( tvb , offset + 2 ) , tvb_get_guint8 ( tvb , offset + 3 ) , tvb_get_guint8 ( tvb , offset + 4 ) ) ;\n }\n else {\n proto_tree_add_expert_format ( tree , pinfo , & ei_q931_date_time , tvb , offset , len , \"Date/time: length is %d, should be 5 or 6\" , len ) ;\n }\n }", "hash": -1338403456839869183, "project": "debian", "size": 11, "target": 0, "idx": 5212}
{"code": "static int dissect_q931_ie_cs7 ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n dissect_q931_IEs ( tvb , pinfo , NULL , tree , FALSE , 0 , 7 , NULL ) ;\n return tvb_captured_length ( tvb ) ;\n }", "hash": -1338403456839869183, "project": "debian", "size": 4, "target": 0, "idx": 5216}
{"code": "void dissect_q931_cause_ie ( tvbuff_t * tvb , int offset , int len , proto_tree * tree , int hf_cause_value , guint8 * cause_value , const value_string * ie_vals ) {\n dissect_q931_cause_ie_with_info ( tvb , offset , len , tree , hf_cause_value , cause_value , ie_vals , NULL ) ;\n }", "hash": -1338403456839869183, "project": "debian", "size": 3, "target": 0, "idx": 5240}
{"code": "static gint rtmpt_message_header_length ( gint id ) {\n switch ( ( id >> 6 ) & 3 ) {\n case 0 : return 11 ;\n case 1 : return 7 ;\n case 2 : return 3 ;\n default : return 0 ;\n }\n }", "hash": -8199454075838226273, "project": "debian", "size": 8, "target": 0, "idx": 5266}
{"code": "static void matroska_execute_seekhead ( MatroskaDemuxContext * matroska ) {\n EbmlList * seekhead_list = & matroska -> seekhead ;\n int64_t before_pos = avio_tell ( matroska -> ctx -> pb ) ;\n int i ;\n if ( ! matroska -> ctx -> pb -> seekable || ( matroska -> ctx -> flags & AVFMT_FLAG_IGNIDX ) ) return ;\n for ( i = 0 ;\n i < seekhead_list -> nb_elem ;\n i ++ ) {\n MatroskaSeekhead * seekhead = seekhead_list -> elem ;\n if ( seekhead [ i ] . pos <= before_pos ) continue ;\n if ( seekhead [ i ] . id == MATROSKA_ID_CUES ) {\n matroska -> cues_parsing_deferred = 1 ;\n continue ;\n }\n if ( matroska_parse_seekhead_entry ( matroska , i ) < 0 ) break ;\n }\n }", "hash": 2064081176034684128, "project": "debian", "size": 17, "target": 0, "idx": 5277}
{"code": "static int ebml_read_num ( MatroskaDemuxContext * matroska , AVIOContext * pb , int max_size , uint64_t * number ) {\n int read = 1 , n = 1 ;\n uint64_t total = 0 ;\n if ( ! ( total = avio_r8 ( pb ) ) ) {\n if ( ! pb -> eof_reached ) {\n int64_t pos = avio_tell ( pb ) ;\n av_log ( matroska -> ctx , AV_LOG_ERROR , \"Read error at pos. %\" PRIu64 \" (0x%\" PRIx64 \")\\n\" , pos , pos ) ;\n return pb -> error ? pb -> error : AVERROR ( EIO ) ;\n }\n return AVERROR_EOF ;\n }\n read = 8 - ff_log2_tab [ total ] ;\n if ( read > max_size ) {\n int64_t pos = avio_tell ( pb ) - 1 ;\n av_log ( matroska -> ctx , AV_LOG_ERROR , \"Invalid EBML number size tag 0x%02x at pos %\" PRIu64 \" (0x%\" PRIx64 \")\\n\" , ( uint8_t ) total , pos , pos ) ;\n return AVERROR_INVALIDDATA ;\n }\n total ^= 1 << ff_log2_tab [ total ] ;\n while ( n ++ < read ) total = ( total << 8 ) | avio_r8 ( pb ) ;\n * number = total ;\n return read ;\n }", "hash": 2064081176034684128, "project": "debian", "size": 22, "target": 0, "idx": 5280}
{"code": "static MatroskaTrack * matroska_find_track_by_num ( MatroskaDemuxContext * matroska , int num ) {\n MatroskaTrack * tracks = matroska -> tracks . elem ;\n int i ;\n for ( i = 0 ;\n i < matroska -> tracks . nb_elem ;\n i ++ ) if ( tracks [ i ] . num == num ) return & tracks [ i ] ;\n av_log ( matroska -> ctx , AV_LOG_ERROR , \"Invalid track number %d\\n\" , num ) ;\n return NULL ;\n }", "hash": 2064081176034684128, "project": "debian", "size": 9, "target": 0, "idx": 5282}
{"code": "static int matroska_read_close ( AVFormatContext * s ) {\n MatroskaDemuxContext * matroska = s -> priv_data ;\n MatroskaTrack * tracks = matroska -> tracks . elem ;\n int n ;\n matroska_clear_queue ( matroska ) ;\n for ( n = 0 ;\n n < matroska -> tracks . nb_elem ;\n n ++ ) if ( tracks [ n ] . type == MATROSKA_TRACK_TYPE_AUDIO ) av_free ( tracks [ n ] . audio . buf ) ;\n ebml_free ( matroska_cluster , & matroska -> current_cluster ) ;\n ebml_free ( matroska_segment , matroska ) ;\n return 0 ;\n }", "hash": 2064081176034684128, "project": "debian", "size": 12, "target": 0, "idx": 5297}
{"code": "static int matroska_parse_flac ( AVFormatContext * s , MatroskaTrack * track , int * offset ) {\n AVStream * st = track -> stream ;\n uint8_t * p = track -> codec_priv . data ;\n int size = track -> codec_priv . size ;\n if ( size < 8 + FLAC_STREAMINFO_SIZE || p [ 4 ] & 0x7f ) {\n av_log ( s , AV_LOG_WARNING , \"Invalid FLAC private data\\n\" ) ;\n track -> codec_priv . size = 0 ;\n return 0 ;\n }\n * offset = 8 ;\n track -> codec_priv . size = 8 + FLAC_STREAMINFO_SIZE ;\n p += track -> codec_priv . size ;\n size -= track -> codec_priv . size ;\n while ( size >= 4 ) {\n int block_last , block_type , block_size ;\n flac_parse_block_header ( p , & block_last , & block_type , & block_size ) ;\n p += 4 ;\n size -= 4 ;\n if ( block_size > size ) return 0 ;\n if ( block_type == FLAC_METADATA_TYPE_VORBIS_COMMENT ) {\n AVDictionary * dict = NULL ;\n AVDictionaryEntry * chmask ;\n ff_vorbis_comment ( s , & dict , p , block_size , 0 ) ;\n chmask = av_dict_get ( dict , \"WAVEFORMATEXTENSIBLE_CHANNEL_MASK\" , NULL , 0 ) ;\n if ( chmask ) {\n uint64_t mask = strtol ( chmask -> value , NULL , 0 ) ;\n if ( ! mask || mask & ~ 0x3ffffULL ) {\n av_log ( s , AV_LOG_WARNING , \"Invalid value of WAVEFORMATEXTENSIBLE_CHANNEL_MASK\\n\" ) ;\n }\n else st -> codec -> channel_layout = mask ;\n }\n av_dict_free ( & dict ) ;\n }\n p += block_size ;\n size -= block_size ;\n }\n return 0 ;\n }", "hash": 2064081176034684128, "project": "debian", "size": 38, "target": 0, "idx": 5298}
{"code": "static int ebml_parse_nest ( MatroskaDemuxContext * matroska , EbmlSyntax * syntax , void * data ) {\n int i , res = 0 ;\n for ( i = 0 ;\n syntax [ i ] . id ;\n i ++ ) switch ( syntax [ i ] . type ) {\n case EBML_UINT : * ( uint64_t * ) ( ( char * ) data + syntax [ i ] . data_offset ) = syntax [ i ] . def . u ;\n break ;\n case EBML_FLOAT : * ( double * ) ( ( char * ) data + syntax [ i ] . data_offset ) = syntax [ i ] . def . f ;\n break ;\n case EBML_STR : case EBML_UTF8 : if ( syntax [ i ] . def . s ) {\n uint8_t * * dst = ( uint8_t * * ) ( ( uint8_t * ) data + syntax [ i ] . data_offset ) ;\n * dst = av_strdup ( syntax [ i ] . def . s ) ;\n if ( ! * dst ) return AVERROR ( ENOMEM ) ;\n }\n break ;\n }\n while ( ! res && ! ebml_level_end ( matroska ) ) res = ebml_parse ( matroska , syntax , data ) ;\n return res ;\n }", "hash": 2064081176034684128, "project": "debian", "size": 19, "target": 0, "idx": 5300}
{"code": "static void matroska_fix_ass_packet ( MatroskaDemuxContext * matroska , AVPacket * pkt , uint64_t display_duration ) {\n AVBufferRef * line ;\n char * layer , * ptr = pkt -> data , * end = ptr + pkt -> size ;\n for ( ;\n * ptr != ',' && ptr < end - 1 ;\n ptr ++ ) ;\n if ( * ptr == ',' ) layer = ++ ptr ;\n for ( ;\n * ptr != ',' && ptr < end - 1 ;\n ptr ++ ) ;\n if ( * ptr == ',' ) {\n int64_t end_pts = pkt -> pts + display_duration ;\n int sc = matroska -> time_scale * pkt -> pts / 10000000 ;\n int ec = matroska -> time_scale * end_pts / 10000000 ;\n int sh , sm , ss , eh , em , es , len ;\n sh = sc / 360000 ;\n sc -= 360000 * sh ;\n sm = sc / 6000 ;\n sc -= 6000 * sm ;\n ss = sc / 100 ;\n sc -= 100 * ss ;\n eh = ec / 360000 ;\n ec -= 360000 * eh ;\n em = ec / 6000 ;\n ec -= 6000 * em ;\n es = ec / 100 ;\n ec -= 100 * es ;\n * ptr ++ = '\\0' ;\n len = 50 + end - ptr + FF_INPUT_BUFFER_PADDING_SIZE ;\n if ( ! ( line = av_buffer_alloc ( len ) ) ) return ;\n snprintf ( line -> data , len , \"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s\\r\\n\" , layer , sh , sm , ss , sc , eh , em , es , ec , ptr ) ;\n av_buffer_unref ( & pkt -> buf ) ;\n pkt -> buf = line ;\n pkt -> data = line -> data ;\n pkt -> size = strlen ( line -> data ) ;\n }\n }", "hash": 2064081176034684128, "project": "debian", "size": 37, "target": 0, "idx": 5307}
{"code": "static void ebml_free ( EbmlSyntax * syntax , void * data ) {\n int i , j ;\n for ( i = 0 ;\n syntax [ i ] . id ;\n i ++ ) {\n void * data_off = ( char * ) data + syntax [ i ] . data_offset ;\n switch ( syntax [ i ] . type ) {\n case EBML_STR : case EBML_UTF8 : av_freep ( data_off ) ;\n break ;\n case EBML_BIN : av_freep ( & ( ( EbmlBin * ) data_off ) -> data ) ;\n break ;\n case EBML_NEST : if ( syntax [ i ] . list_elem_size ) {\n EbmlList * list = data_off ;\n char * ptr = list -> elem ;\n for ( j = 0 ;\n j < list -> nb_elem ;\n j ++ , ptr += syntax [ i ] . list_elem_size ) ebml_free ( syntax [ i ] . def . n , ptr ) ;\n av_free ( list -> elem ) ;\n }\n else ebml_free ( syntax [ i ] . def . n , data_off ) ;\n default : break ;\n }\n }\n }", "hash": 2064081176034684128, "project": "debian", "size": 24, "target": 0, "idx": 5311}
{"code": "static int matroska_aac_profile ( char * codec_id ) {\n static const char * const aac_profiles [ ] = {\n \"MAIN\" , \"LC\" , \"SSR\" }\n ;\n int profile ;\n for ( profile = 0 ;\n profile < FF_ARRAY_ELEMS ( aac_profiles ) ;\n profile ++ ) if ( strstr ( codec_id , aac_profiles [ profile ] ) ) break ;\n return profile + 1 ;\n }", "hash": 2064081176034684128, "project": "debian", "size": 10, "target": 0, "idx": 5313}
{"code": "static int matroska_deliver_packet ( MatroskaDemuxContext * matroska , AVPacket * pkt ) {\n if ( matroska -> num_packets > 0 ) {\n memcpy ( pkt , matroska -> packets [ 0 ] , sizeof ( AVPacket ) ) ;\n av_free ( matroska -> packets [ 0 ] ) ;\n if ( matroska -> num_packets > 1 ) {\n void * newpackets ;\n memmove ( & matroska -> packets [ 0 ] , & matroska -> packets [ 1 ] , ( matroska -> num_packets - 1 ) * sizeof ( AVPacket * ) ) ;\n newpackets = av_realloc ( matroska -> packets , ( matroska -> num_packets - 1 ) * sizeof ( AVPacket * ) ) ;\n if ( newpackets ) matroska -> packets = newpackets ;\n }\n else {\n av_freep ( & matroska -> packets ) ;\n matroska -> prev_pkt = NULL ;\n }\n matroska -> num_packets -- ;\n return 0 ;\n }\n return - 1 ;\n }", "hash": 2064081176034684128, "project": "debian", "size": 19, "target": 0, "idx": 5314}
{"code": "PHP_FUNCTION ( locale_get_display_variant ) {\n get_icu_disp_value_src_php ( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ;\n }", "hash": -1487877838474751244, "project": "debian", "size": 3, "target": 0, "idx": 5335}
{"code": "ZEND_EXTERN_MODULE_GLOBALS ( intl ) # define SEPARATOR \"_\" # define SEPARATOR1 \"-\" # define DELIMITER \"-_\" # define EXTLANG_PREFIX \"a\" # define PRIVATE_PREFIX \"x\" # define DISP_NAME \"name\" # define MAX_NO_VARIANT 15 # define MAX_NO_EXTLANG 3 # define MAX_NO_PRIVATE 15 # define MAX_NO_LOOKUP_LANG_TAG 100 # define LOC_NOT_FOUND 1 # define VARIANT_KEYNAME_LEN 11 # define EXTLANG_KEYNAME_LEN 10 # define PRIVATE_KEYNAME_LEN 11 static const char * const LOC_GRANDFATHERED [ ] = {\n \"art-lojban\" , \"i-klingon\" , \"i-lux\" , \"i-navajo\" , \"no-bok\" , \"no-nyn\" , \"cel-gaulish\" , \"en-GB-oed\" , \"i-ami\" , \"i-bnn\" , \"i-default\" , \"i-enochian\" , \"i-mingo\" , \"i-pwn\" , \"i-tao\" , \"i-tay\" , \"i-tsu\" , \"sgn-BE-fr\" , \"sgn-BE-nl\" , \"sgn-CH-de\" , \"zh-cmn\" , \"zh-cmn-Hans\" , \"zh-cmn-Hant\" , \"zh-gan\" , \"zh-guoyu\" , \"zh-hakka\" , \"zh-min\" , \"zh-min-nan\" , \"zh-wuu\" , \"zh-xiang\" , \"zh-yue\" , NULL }", "hash": -1487877838474751244, "project": "debian", "size": 2, "target": 0, "idx": 5343}
{"code": "PHP_FUNCTION ( locale_get_display_script ) {\n get_icu_disp_value_src_php ( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU ) ;\n }", "hash": -1487877838474751244, "project": "debian", "size": 3, "target": 0, "idx": 5348}
{"code": "static int dissect_segment_defn ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , guint64 channel , int encoding ) {\n proto_item * subtree_item = NULL ;\n proto_tree * subtree = NULL ;\n int seglen = 0 ;\n int ofs = 0 ;\n gboolean string_field_name = FALSE ;\n int remaining_datalen = 0 ;\n guint32 num_fields = 0 ;\n lbmpdm_definition_t * def = NULL ;\n gboolean add_definition = FALSE ;\n guint32 def_id = 0 ;\n guint8 vers_major = 0 ;\n guint8 vers_minor = 0 ;\n lbmpdm_definition_field_t * last_fixed_required_field = NULL ;\n seglen = lbmpdm_get_segment_length ( tvb , offset , encoding , & remaining_datalen ) ;\n if ( pinfo -> fd -> flags . visited == 0 ) {\n add_definition = TRUE ;\n }\n subtree_item = proto_tree_add_none_format ( tree , hf_lbmpdm_segment , tvb , offset , seglen , \"Definition Segment\" ) ;\n subtree = proto_item_add_subtree ( subtree_item , ett_lbmpdm_segment ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_next_hdr , tvb , offset + O_LBMPDM_SEG_HDR_T_NEXT_HDR , L_LBMPDM_SEG_HDR_T_NEXT_HDR , encoding ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_flags , tvb , offset + O_LBMPDM_SEG_HDR_T_FLAGS , L_LBMPDM_SEG_HDR_T_FLAGS , encoding ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_res , tvb , offset + O_LBMPDM_SEG_HDR_T_RES , L_LBMPDM_SEG_HDR_T_RES , encoding ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_len , tvb , offset + O_LBMPDM_SEG_HDR_T_LEN , L_LBMPDM_SEG_HDR_T_LEN , encoding ) ;\n ofs = offset + L_LBMPDM_SEG_HDR_T ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_def_id , tvb , ofs + O_LBMPDM_DEFN_T_ID , L_LBMPDM_DEFN_T_ID , encoding ) ;\n def_id = lbmpdm_fetch_uint32_encoded ( tvb , ofs + O_LBMPDM_DEFN_T_ID , encoding ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_def_num_fields , tvb , ofs + O_LBMPDM_DEFN_T_NUM_FIELDS , L_LBMPDM_DEFN_T_NUM_FIELDS , encoding ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_def_field_names_type , tvb , ofs + O_LBMPDM_DEFN_T_FIELD_NAMES_TYPE , L_LBMPDM_DEFN_T_FIELD_NAMES_TYPE , encoding ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_def_finalized , tvb , ofs + O_LBMPDM_DEFN_T_FINALIZED , L_LBMPDM_DEFN_T_FINALIZED , encoding ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_def_msg_vers_major , tvb , ofs + O_LBMPDM_DEFN_T_MSG_VERS_MAJOR , L_LBMPDM_DEFN_T_MSG_VERS_MAJOR , encoding ) ;\n vers_major = tvb_get_guint8 ( tvb , ofs + O_LBMPDM_DEFN_T_MSG_VERS_MAJOR ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_def_msg_vers_minor , tvb , ofs + O_LBMPDM_DEFN_T_MSG_VERS_MINOR , L_LBMPDM_DEFN_T_MSG_VERS_MINOR , encoding ) ;\n vers_minor = tvb_get_guint8 ( tvb , ofs + O_LBMPDM_DEFN_T_MSG_VERS_MINOR ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_def_fixed_req_section_len , tvb , ofs + O_LBMPDM_DEFN_T_FIXED_REQ_SECTION_LEN , L_LBMPDM_DEFN_T_FIXED_REQ_SECTION_LEN , encoding ) ;\n proto_tree_add_item ( subtree , hf_lbmpdm_segment_def_field_info_len , tvb , ofs + O_LBMPDM_DEFN_T_FIELD_INFO_LEN , L_LBMPDM_DEFN_T_FIELD_INFO_LEN , encoding ) ;\n if ( tvb_get_guint8 ( tvb , ofs + O_LBMPDM_DEFN_T_FIELD_NAMES_TYPE ) == PDM_DEFN_STR_FIELD_NAMES ) {\n string_field_name = TRUE ;\n }\n num_fields = lbmpdm_fetch_uint32_encoded ( tvb , ofs + O_LBMPDM_DEFN_T_NUM_FIELDS , encoding ) ;\n if ( add_definition ) {\n def = lbmpdm_definition_find ( channel , def_id , vers_major , vers_minor ) ;\n if ( def == NULL ) {\n def = lbmpdm_definition_add ( channel , def_id , vers_major , vers_minor ) ;\n def -> num_fields = num_fields ;\n def -> field_names_type = tvb_get_guint8 ( tvb , ofs + O_LBMPDM_DEFN_T_FIELD_NAMES_TYPE ) ;\n def -> fixed_req_section_len = lbmpdm_fetch_uint32_encoded ( tvb , ofs + O_LBMPDM_DEFN_T_FIXED_REQ_SECTION_LEN , encoding ) ;\n def -> first_fixed_required = NULL ;\n def -> fixed_required_count = 0 ;\n }\n }\n ofs += L_LBMPDM_DEFN_T ;\n remaining_datalen = seglen - L_LBMPDM_SEG_HDR_T - L_LBMPDM_DEFN_T ;\n while ( ( remaining_datalen > 0 ) && ( num_fields > 0 ) ) {\n proto_item * field_item = NULL ;\n proto_tree * field_tree = NULL ;\n guint32 def_len = L_LBMPDM_FIELD_INFO_T_INT_NAME ;\n int def_ofs = 0 ;\n int type_ofs = L_LBMPDM_FIELD_INFO_T ;\n guint32 string_name_len = 0 ;\n int string_name_ofs = - 1 ;\n if ( string_field_name ) {\n def_len = lbmpdm_fetch_uint32_encoded ( tvb , ofs , encoding ) + 4 ;\n }\n field_item = proto_tree_add_item ( subtree , hf_lbmpdm_segment_def_field , tvb , ofs , def_len , ENC_NA ) ;\n field_tree = proto_item_add_subtree ( field_item , ett_lbmpdm_segment_def_field ) ;\n if ( string_field_name ) {\n proto_tree_add_item ( field_tree , hf_lbmpdm_segment_def_field_def_len , tvb , ofs , 4 , encoding ) ;\n def_ofs = 4 ;\n type_ofs += def_ofs ;\n }\n proto_tree_add_item ( field_tree , hf_lbmpdm_segment_def_field_id , tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_ID , L_LBMPDM_FIELD_INFO_T_ID , encoding ) ;\n proto_tree_add_item ( field_tree , hf_lbmpdm_segment_def_field_len , tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_LEN , L_LBMPDM_FIELD_INFO_T_LEN , encoding ) ;\n proto_tree_add_item ( field_tree , hf_lbmpdm_segment_def_field_fixed_str_len , tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_FIXED_STR_LEN , L_LBMPDM_FIELD_INFO_T_FIXED_STR_LEN , encoding ) ;\n proto_tree_add_item ( field_tree , hf_lbmpdm_segment_def_field_num_arr_elem , tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_NUM_ARR_ELEM , L_LBMPDM_FIELD_INFO_T_NUM_ARR_ELEM , encoding ) ;\n proto_tree_add_item ( field_tree , hf_lbmpdm_segment_def_field_req , tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_REQ , L_LBMPDM_FIELD_INFO_T_REQ , encoding ) ;\n proto_tree_add_item ( field_tree , hf_lbmpdm_segment_def_field_fixed , tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_FIXED , L_LBMPDM_FIELD_INFO_T_FIXED , encoding ) ;\n proto_tree_add_item ( field_tree , hf_lbmpdm_segment_def_field_fld_int_name , tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_FLD_INT_NAME , L_LBMPDM_FIELD_INFO_T_FLD_INT_NAME , encoding ) ;\n proto_tree_add_item ( field_tree , hf_lbmpdm_segment_def_field_str_name_len , tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_STR_NAME_LEN , L_LBMPDM_FIELD_INFO_T_STR_NAME_LEN , encoding ) ;\n if ( string_field_name ) {\n string_name_len = lbmpdm_fetch_uint32_encoded ( tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_STR_NAME_LEN , encoding ) ;\n if ( string_name_len > 0 ) {\n string_name_ofs = ofs + def_ofs + L_LBMPDM_FIELD_INFO_T ;\n proto_tree_add_item ( field_tree , hf_lbmpdm_segment_def_field_str_name , tvb , string_name_ofs , ( int ) string_name_len , ENC_ASCII | ENC_NA ) ;\n type_ofs += string_name_len ;\n }\n }\n proto_tree_add_item ( field_tree , hf_lbmpdm_segment_def_field_fld_type , tvb , ofs + type_ofs , 2 , encoding ) ;\n if ( add_definition && ( def != NULL ) ) {\n lbmpdm_definition_field_t * field = NULL ;\n guint32 field_id ;\n field_id = lbmpdm_fetch_uint32_encoded ( tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_ID , encoding ) ;\n field = lbmpdm_definition_field_find ( def , field_id ) ;\n if ( field == NULL ) {\n field = lbmpdm_definition_field_add ( def , field_id ) ;\n if ( field != NULL ) {\n field -> len = lbmpdm_fetch_uint32_encoded ( tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_LEN , encoding ) ;\n field -> fixed_string_len = lbmpdm_fetch_uint32_encoded ( tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_FIXED_STR_LEN , encoding ) ;\n field -> num_array_elem = lbmpdm_fetch_uint32_encoded ( tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_NUM_ARR_ELEM , encoding ) ;\n field -> required = tvb_get_guint8 ( tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_REQ ) ;\n field -> fixed = tvb_get_guint8 ( tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_FIXED ) ;\n field -> field_int_name = lbmpdm_fetch_uint32_encoded ( tvb , ofs + def_ofs + O_LBMPDM_FIELD_INFO_T_FLD_INT_NAME , encoding ) ;\n if ( string_field_name && ( string_name_len > 0 ) ) {\n field -> field_string_name_len = string_name_len ;\n field -> field_string_name = tvb_get_string_enc ( wmem_file_scope ( ) , tvb , string_name_ofs , string_name_len , ENC_ASCII ) ;\n }\n else {\n field -> field_string_name_len = 0 ;\n field -> field_string_name = NULL ;\n }\n field -> field_type = lbmpdm_fetch_uint16_encoded ( tvb , ofs + type_ofs , encoding ) ;\n switch ( field -> field_type ) {\n case PDM_TYPE_BOOLEAN : case PDM_TYPE_BOOLEAN_ARR : field -> base_type = PDM_TYPE_BOOLEAN ;\n break ;\n case PDM_TYPE_INT8 : case PDM_TYPE_INT8_ARR : field -> base_type = PDM_TYPE_INT8 ;\n break ;\n case PDM_TYPE_UINT8 : case PDM_TYPE_UINT8_ARR : field -> base_type = PDM_TYPE_UINT8 ;\n break ;\n case PDM_TYPE_INT16 : case PDM_TYPE_INT16_ARR : field -> base_type = PDM_TYPE_INT16 ;\n break ;\n case PDM_TYPE_UINT16 : case PDM_TYPE_UINT16_ARR : field -> base_type = PDM_TYPE_UINT16 ;\n break ;\n case PDM_TYPE_INT32 : case PDM_TYPE_INT32_ARR : field -> base_type = PDM_TYPE_INT32 ;\n break ;\n case PDM_TYPE_UINT32 : case PDM_TYPE_UINT32_ARR : field -> base_type = PDM_TYPE_UINT32 ;\n break ;\n case PDM_TYPE_INT64 : case PDM_TYPE_INT64_ARR : field -> base_type = PDM_TYPE_INT64 ;\n break ;\n case PDM_TYPE_UINT64 : case PDM_TYPE_UINT64_ARR : field -> base_type = PDM_TYPE_UINT64 ;\n break ;\n case PDM_TYPE_FLOAT : case PDM_TYPE_FLOAT_ARR : field -> base_type = PDM_TYPE_FLOAT ;\n break ;\n case PDM_TYPE_DOUBLE : case PDM_TYPE_DOUBLE_ARR : field -> base_type = PDM_TYPE_DOUBLE ;\n break ;\n case PDM_TYPE_DECIMAL : case PDM_TYPE_DECIMAL_ARR : field -> base_type = PDM_TYPE_DECIMAL ;\n break ;\n case PDM_TYPE_TIMESTAMP : case PDM_TYPE_TIMESTAMP_ARR : field -> base_type = PDM_TYPE_TIMESTAMP ;\n break ;\n case PDM_TYPE_FIX_STRING : case PDM_TYPE_FIX_STRING_ARR : field -> base_type = PDM_TYPE_FIX_STRING ;\n break ;\n case PDM_TYPE_STRING : case PDM_TYPE_STRING_ARR : field -> base_type = PDM_TYPE_STRING ;\n break ;\n case PDM_TYPE_FIX_UNICODE : case PDM_TYPE_FIX_UNICODE_ARR : field -> base_type = PDM_TYPE_FIX_UNICODE ;\n break ;\n case PDM_TYPE_UNICODE : case PDM_TYPE_UNICODE_ARR : field -> base_type = PDM_TYPE_UNICODE ;\n break ;\n case PDM_TYPE_BLOB : case PDM_TYPE_BLOB_ARR : default : field -> base_type = PDM_TYPE_BLOB ;\n break ;\n case PDM_TYPE_MESSAGE : case PDM_TYPE_MESSAGE_ARR : field -> base_type = PDM_TYPE_MESSAGE ;\n break ;\n }\n if ( ( field -> fixed == PDM_DEFN_FIXED_LENGTH_FIELD ) && ( field -> required == PDM_DEFN_REQUIRED_FIELD ) ) {\n if ( last_fixed_required_field == NULL ) {\n def -> first_fixed_required = field ;\n field -> fixed_required_offset = 0 ;\n }\n else {\n last_fixed_required_field -> next_fixed_required = field ;\n field -> fixed_required_offset = last_fixed_required_field -> fixed_required_offset + last_fixed_required_field -> len ;\n }\n last_fixed_required_field = field ;\n def -> fixed_required_count ++ ;\n }\n }\n }\n }\n ofs += def_len ;\n remaining_datalen -= def_len ;\n num_fields -- ;\n }\n return ( seglen ) ;\n }", "hash": 1312888211311686952, "project": "debian", "size": 172, "target": 0, "idx": 5353}
{"code": "gboolean lbmpdm_verify_payload ( tvbuff_t * tvb , int offset , int * encoding , int * length ) {\n guint8 next_header ;\n guint32 len = 0 ;\n if ( ! tvb_bytes_exist ( tvb , offset , L_LBMPDM_MSG_HDR_T ) ) {\n return ( FALSE ) ;\n }\n if ( ! check_lbmpdm_encoding ( tvb , offset , encoding ) ) {\n return ( FALSE ) ;\n }\n next_header = tvb_get_guint8 ( tvb , offset + O_LBMPDM_MSG_HDR_T_NEXT_HDR ) ;\n switch ( next_header ) {\n case PDM_HDR_TYPE_DATA : case PDM_HDR_TYPE_OFSTTBLE : case PDM_HDR_TYPE_DEFN : case PDM_HDR_TYPE_EOM : break ;\n default : return ( FALSE ) ;\n break ;\n }\n len = lbmpdm_fetch_uint32_encoded ( tvb , offset + O_LBMPDM_MSG_HDR_T_LEN , * encoding ) ;\n if ( len > G_MAXINT ) {\n return ( FALSE ) ;\n }\n * length = ( int ) len ;\n return ( TRUE ) ;\n }", "hash": 1312888211311686952, "project": "debian", "size": 22, "target": 0, "idx": 5366}
{"code": "enum ImapAuthRes imap_auth_cram_md5 ( struct ImapData * idata , const char * method ) {\n char ibuf [ LONG_STRING * 2 ] , obuf [ LONG_STRING ] ;\n unsigned char hmac_response [ MD5_DIGEST_LEN ] ;\n int len ;\n int rc ;\n if ( ! mutt_bit_isset ( idata -> capabilities , ACRAM_MD5 ) ) return IMAP_AUTH_UNAVAIL ;\n mutt_message ( _ ( \"Authenticating (CRAM-MD5)...\" ) ) ;\n if ( mutt_account_getlogin ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n imap_cmd_start ( idata , \"AUTHENTICATE CRAM-MD5\" ) ;\n do rc = imap_cmd_step ( idata ) ;\n while ( rc == IMAP_CMD_CONTINUE ) ;\n if ( rc != IMAP_CMD_RESPOND ) {\n mutt_debug ( 1 , \"Invalid response from server: %s\\n\" , ibuf ) ;\n goto bail ;\n }\n len = mutt_b64_decode ( obuf , idata -> buf + 2 , sizeof ( obuf ) ) ;\n if ( len == - 1 ) {\n mutt_debug ( 1 , \"Error decoding base64 response.\\n\" ) ;\n goto bail ;\n }\n obuf [ len ] = '\\0' ;\n mutt_debug ( 2 , \"CRAM challenge: %s\\n\" , obuf ) ;\n hmac_md5 ( idata -> conn -> account . pass , obuf , hmac_response ) ;\n int off = snprintf ( obuf , sizeof ( obuf ) , \"%s \" , idata -> conn -> account . user ) ;\n mutt_md5_toascii ( hmac_response , obuf + off ) ;\n mutt_debug ( 2 , \"CRAM response: %s\\n\" , obuf ) ;\n mutt_b64_encode ( ibuf , obuf , strlen ( obuf ) , sizeof ( ibuf ) - 2 ) ;\n mutt_str_strcat ( ibuf , sizeof ( ibuf ) , \"\\r\\n\" ) ;\n mutt_socket_send ( idata -> conn , ibuf ) ;\n do rc = imap_cmd_step ( idata ) ;\n while ( rc == IMAP_CMD_CONTINUE ) ;\n if ( rc != IMAP_CMD_OK ) {\n mutt_debug ( 1 , \"Error receiving server response.\\n\" ) ;\n goto bail ;\n }\n if ( imap_code ( idata -> buf ) ) return IMAP_AUTH_SUCCESS ;\n bail : mutt_error ( _ ( \"CRAM-MD5 authentication failed.\" ) ) ;\n return IMAP_AUTH_FAILURE ;\n }", "hash": 8326517429469576957, "project": "debian", "size": 40, "target": 0, "idx": 5372}
{"code": "static void print_gss_error ( OM_uint32 err_maj , OM_uint32 err_min ) {\n OM_uint32 maj_stat , min_stat ;\n OM_uint32 msg_ctx = 0 ;\n gss_buffer_desc status_string ;\n char buf_maj [ 512 ] ;\n char buf_min [ 512 ] ;\n do {\n maj_stat = gss_display_status ( & min_stat , err_maj , GSS_C_GSS_CODE , GSS_C_NO_OID , & msg_ctx , & status_string ) ;\n if ( GSS_ERROR ( maj_stat ) ) break ;\n size_t status_len = status_string . length ;\n if ( status_len >= sizeof ( buf_maj ) ) status_len = sizeof ( buf_maj ) - 1 ;\n strncpy ( buf_maj , ( char * ) status_string . value , status_len ) ;\n buf_maj [ status_len ] = '\\0' ;\n gss_release_buffer ( & min_stat , & status_string ) ;\n maj_stat = gss_display_status ( & min_stat , err_min , GSS_C_MECH_CODE , GSS_C_NULL_OID , & msg_ctx , & status_string ) ;\n if ( ! GSS_ERROR ( maj_stat ) ) {\n status_len = status_string . length ;\n if ( status_len >= sizeof ( buf_min ) ) status_len = sizeof ( buf_min ) - 1 ;\n strncpy ( buf_min , ( char * ) status_string . value , status_len ) ;\n buf_min [ status_len ] = '\\0' ;\n gss_release_buffer ( & min_stat , & status_string ) ;\n }\n }\n while ( ! GSS_ERROR ( maj_stat ) && msg_ctx != 0 ) ;\n mutt_debug ( 2 , \"((%s:%d )(%s:%d))\\n\" , buf_maj , err_maj , buf_min , err_min ) ;\n }", "hash": 8280658844309151365, "project": "debian", "size": 26, "target": 0, "idx": 5385}
{"code": "static enum fetch_step vbf_stp_fail ( struct worker * wrk , const struct busyobj * bo ) {\n CHECK_OBJ_NOTNULL ( wrk , WORKER_MAGIC ) ;\n CHECK_OBJ_NOTNULL ( bo , BUSYOBJ_MAGIC ) ;\n CHECK_OBJ_NOTNULL ( bo -> fetch_objcore , OBJCORE_MAGIC ) ;\n assert ( bo -> fetch_objcore -> boc -> state < BOS_FINISHED ) ;\n HSH_Fail ( bo -> fetch_objcore ) ;\n if ( ! ( bo -> fetch_objcore -> flags & OC_F_BUSY ) ) HSH_Kill ( bo -> fetch_objcore ) ;\n ObjSetState ( wrk , bo -> fetch_objcore , BOS_FAILED ) ;\n return ( F_STP_DONE ) ;\n }", "hash": -4810636875286199147, "project": "debian", "size": 10, "target": 0, "idx": 5396}
{"code": "static int token_continue ( i_ctx_t * i_ctx_p , scanner_state * pstate , bool save ) {\n os_ptr op = osp ;\n int code ;\n ref token ;\n make_null ( osp ) ;\n pop ( 1 ) ;\n again : code = gs_scan_token ( i_ctx_p , & token , pstate ) ;\n op = osp ;\n switch ( code ) {\n default : if ( code > 0 ) code = gs_note_error ( gs_error_syntaxerror ) ;\n gs_scanner_error_object ( i_ctx_p , pstate , & i_ctx_p -> error_object ) ;\n break ;\n case scan_BOS : code = 0 ;\n case 0 : push ( 2 ) ;\n ref_assign ( op - 1 , & token ) ;\n make_true ( op ) ;\n break ;\n case scan_EOF : push ( 1 ) ;\n make_false ( op ) ;\n code = 0 ;\n break ;\n case scan_Refill : code = gs_scan_handle_refill ( i_ctx_p , pstate , save , ztoken_continue ) ;\n switch ( code ) {\n case 0 : goto again ;\n case o_push_estack : return code ;\n }\n break ;\n }\n if ( code <= 0 && ! save ) {\n ifree_object ( pstate , \"token_continue\" ) ;\n }\n return code ;\n }", "hash": -357657257866300423, "project": "debian", "size": 33, "target": 0, "idx": 5400}
{"code": "int ztoken_get_scanner_option ( const ref * psref , int options , const char * * pname ) {\n const named_scanner_option_t * pnso ;\n for ( pnso = named_options + countof ( named_options ) ;\n pnso -- != named_options ;\n ) {\n if ( ! bytes_compare ( ( const byte * ) pnso -> pname , strlen ( pnso -> pname ) , psref -> value . const_bytes , r_size ( psref ) ) ) {\n * pname = pnso -> pname ;\n return ( options & pnso -> option ? 1 : 0 ) ;\n }\n }\n return - 1 ;\n }", "hash": -357657257866300423, "project": "debian", "size": 12, "target": 0, "idx": 5401}
{"code": "static void keyblock_cache_clear ( void ) {\n keyblock_cache . state = KEYBLOCK_CACHE_EMPTY ;\n xfree ( keyblock_cache . sigstatus ) ;\n keyblock_cache . sigstatus = NULL ;\n iobuf_close ( keyblock_cache . iobuf ) ;\n keyblock_cache . iobuf = NULL ;\n }", "hash": 3576240888172463140, "project": "debian", "size": 7, "target": 0, "idx": 5409}
{"code": "static void dump_search_desc ( KEYDB_HANDLE hd , const char * text , KEYDB_SEARCH_DESC * desc , size_t ndesc ) {\n int n ;\n const char * s ;\n for ( n = 0 ;\n n < ndesc ;\n n ++ ) {\n switch ( desc [ n ] . mode ) {\n case KEYDB_SEARCH_MODE_NONE : s = \"none\" ;\n break ;\n case KEYDB_SEARCH_MODE_EXACT : s = \"exact\" ;\n break ;\n case KEYDB_SEARCH_MODE_SUBSTR : s = \"substr\" ;\n break ;\n case KEYDB_SEARCH_MODE_MAIL : s = \"mail\" ;\n break ;\n case KEYDB_SEARCH_MODE_MAILSUB : s = \"mailsub\" ;\n break ;\n case KEYDB_SEARCH_MODE_MAILEND : s = \"mailend\" ;\n break ;\n case KEYDB_SEARCH_MODE_WORDS : s = \"words\" ;\n break ;\n case KEYDB_SEARCH_MODE_SHORT_KID : s = \"short_kid\" ;\n break ;\n case KEYDB_SEARCH_MODE_LONG_KID : s = \"long_kid\" ;\n break ;\n case KEYDB_SEARCH_MODE_FPR16 : s = \"fpr16\" ;\n break ;\n case KEYDB_SEARCH_MODE_FPR20 : s = \"fpr20\" ;\n break ;\n case KEYDB_SEARCH_MODE_FPR : s = \"fpr\" ;\n break ;\n case KEYDB_SEARCH_MODE_ISSUER : s = \"issuer\" ;\n break ;\n case KEYDB_SEARCH_MODE_ISSUER_SN : s = \"issuer_sn\" ;\n break ;\n case KEYDB_SEARCH_MODE_SN : s = \"sn\" ;\n break ;\n case KEYDB_SEARCH_MODE_SUBJECT : s = \"subject\" ;\n break ;\n case KEYDB_SEARCH_MODE_KEYGRIP : s = \"keygrip\" ;\n break ;\n case KEYDB_SEARCH_MODE_FIRST : s = \"first\" ;\n break ;\n case KEYDB_SEARCH_MODE_NEXT : s = \"next\" ;\n break ;\n default : s = \"?\" ;\n break ;\n }\n if ( ! n ) log_debug ( \"%s: mode=%s (hd=%p)\" , text , s , hd ) ;\n else log_debug ( \"%*s mode=%s\" , ( int ) strlen ( text ) , \"\" , s ) ;\n if ( desc [ n ] . mode == KEYDB_SEARCH_MODE_LONG_KID ) log_printf ( \" %08lX%08lX\" , ( unsigned long ) desc [ n ] . u . kid [ 0 ] , ( unsigned long ) desc [ n ] . u . kid [ 1 ] ) ;\n else if ( desc [ n ] . mode == KEYDB_SEARCH_MODE_SHORT_KID ) log_printf ( \" %08lX\" , ( unsigned long ) desc [ n ] . u . kid [ 1 ] ) ;\n else if ( desc [ n ] . mode == KEYDB_SEARCH_MODE_SUBSTR ) log_printf ( \" '%s'\" , desc [ n ] . u . name ) ;\n }\n }", "hash": 3576240888172463140, "project": "debian", "size": 55, "target": 0, "idx": 5414}
{"code": "gpg_error_t keydb_search ( KEYDB_HANDLE hd , KEYDB_SEARCH_DESC * desc , size_t ndesc , size_t * descindex ) {\n gpg_error_t rc ;\n if ( descindex ) * descindex = 0 ;\n if ( ! hd ) return gpg_error ( GPG_ERR_INV_ARG ) ;\n if ( DBG_CLOCK ) log_clock ( \"keydb_search enter\" ) ;\n if ( DBG_CACHE ) dump_search_desc ( hd , \"keydb_search\" , desc , ndesc ) ;\n if ( ! hd -> no_caching && ndesc == 1 && ( desc [ 0 ] . mode == KEYDB_SEARCH_MODE_FPR20 || desc [ 0 ] . mode == KEYDB_SEARCH_MODE_FPR ) && keyblock_cache . state == KEYBLOCK_CACHE_FILLED && ! memcmp ( keyblock_cache . fpr , desc [ 0 ] . u . fpr , 20 ) ) {\n if ( DBG_CLOCK ) log_clock ( \"keydb_search leave (cached)\" ) ;\n return 0 ;\n }\n rc = - 1 ;\n while ( ( rc == - 1 || gpg_err_code ( rc ) == GPG_ERR_EOF ) && hd -> current >= 0 && hd -> current < hd -> used ) {\n switch ( hd -> active [ hd -> current ] . type ) {\n case KEYDB_RESOURCE_TYPE_NONE : BUG ( ) ;\n break ;\n case KEYDB_RESOURCE_TYPE_KEYRING : rc = keyring_search ( hd -> active [ hd -> current ] . u . kr , desc , ndesc , descindex ) ;\n break ;\n case KEYDB_RESOURCE_TYPE_KEYBOX : rc = keybox_search ( hd -> active [ hd -> current ] . u . kb , desc , ndesc , KEYBOX_BLOBTYPE_PGP , descindex , & hd -> skipped_long_blobs ) ;\n break ;\n }\n if ( rc == - 1 || gpg_err_code ( rc ) == GPG_ERR_EOF ) {\n hd -> current ++ ;\n }\n else if ( ! rc ) hd -> found = hd -> current ;\n }\n rc = ( ( rc == - 1 || gpg_err_code ( rc ) == GPG_ERR_EOF ) ? gpg_error ( GPG_ERR_NOT_FOUND ) : rc ) ;\n keyblock_cache_clear ( ) ;\n if ( ! hd -> no_caching && ! rc && ndesc == 1 && ( desc [ 0 ] . mode == KEYDB_SEARCH_MODE_FPR20 || desc [ 0 ] . mode == KEYDB_SEARCH_MODE_FPR ) ) {\n keyblock_cache . state = KEYBLOCK_CACHE_PREPARED ;\n memcpy ( keyblock_cache . fpr , desc [ 0 ] . u . fpr , 20 ) ;\n }\n if ( DBG_CLOCK ) log_clock ( rc ? \"keydb_search leave (not found)\" : \"keydb_search leave (found)\" ) ;\n return rc ;\n }", "hash": 3576240888172463140, "project": "debian", "size": 34, "target": 0, "idx": 5422}
{"code": "const char * keyring_get_resource_name ( KEYRING_HANDLE hd ) {\n if ( ! hd || ! hd -> resource ) return NULL ;\n return hd -> resource -> fname ;\n }", "hash": -2931981263594364686, "project": "debian", "size": 4, "target": 0, "idx": 5434}
{"code": "static OffsetHashTable new_offset_hash_table ( void ) {\n struct off_item * * tbl ;\n tbl = xmalloc_clear ( 2048 * sizeof * tbl ) ;\n return tbl ;\n }", "hash": -2931981263594364686, "project": "debian", "size": 5, "target": 0, "idx": 5437}
{"code": "int keyring_insert_keyblock ( KEYRING_HANDLE hd , KBNODE kb ) {\n int rc ;\n const char * fname ;\n if ( ! hd ) fname = NULL ;\n else if ( hd -> found . kr ) {\n fname = hd -> found . kr -> fname ;\n if ( hd -> found . kr -> read_only ) return gpg_error ( GPG_ERR_EACCES ) ;\n }\n else if ( hd -> current . kr ) {\n fname = hd -> current . kr -> fname ;\n if ( hd -> current . kr -> read_only ) return gpg_error ( GPG_ERR_EACCES ) ;\n }\n else fname = hd -> resource ? hd -> resource -> fname : NULL ;\n if ( ! fname ) return GPG_ERR_GENERAL ;\n iobuf_close ( hd -> current . iobuf ) ;\n hd -> current . iobuf = NULL ;\n rc = do_copy ( 1 , fname , kb , 0 , 0 ) ;\n if ( ! rc && kr_offtbl ) {\n update_offset_hash_table_from_kb ( kr_offtbl , kb , 0 ) ;\n }\n return rc ;\n }", "hash": -2931981263594364686, "project": "debian", "size": 22, "target": 0, "idx": 5442}
{"code": "static void convert_zerofill_number_to_string ( Item * * item , Field_num * field ) {\n char buff [ MAX_FIELD_WIDTH ] , * pos ;\n String tmp ( buff , sizeof ( buff ) , field -> charset ( ) ) , * res ;\n res = ( * item ) -> val_str ( & tmp ) ;\n if ( ( * item ) -> is_null ( ) ) * item = new Item_null ( ) ;\n else {\n field -> prepend_zeros ( res ) ;\n pos = ( char * ) sql_strmake ( res -> ptr ( ) , res -> length ( ) ) ;\n * item = new Item_string ( pos , res -> length ( ) , field -> charset ( ) ) ;\n }\n }", "hash": -7334302271653594926, "project": "debian", "size": 11, "target": 0, "idx": 5469}
{"code": "static ssize_t qio_channel_websock_write_wire ( QIOChannelWebsock * ioc , Error * * errp ) {\n ssize_t ret ;\n ssize_t done = 0 ;\n if ( ! ioc -> ping_reply . offset ) {\n qio_channel_websock_encode ( ioc ) ;\n }\n else if ( ! ioc -> encoutput . offset ) {\n buffer_move_empty ( & ioc -> encoutput , & ioc -> ping_reply ) ;\n }\n while ( ioc -> encoutput . offset > 0 ) {\n ret = qio_channel_write ( ioc -> master , ( char * ) ioc -> encoutput . buffer , ioc -> encoutput . offset , errp ) ;\n if ( ret < 0 ) {\n if ( ret == QIO_CHANNEL_ERR_BLOCK && done > 0 ) {\n return done ;\n }\n else {\n return ret ;\n }\n }\n buffer_advance ( & ioc -> encoutput , ret ) ;\n done += ret ;\n }\n return done ;\n }", "hash": 8849962823026424130, "project": "debian", "size": 24, "target": 0, "idx": 5498}
{"code": "static gboolean qio_channel_websock_source_prepare ( GSource * source , gint * timeout ) {\n * timeout = - 1 ;\n return qio_channel_websock_source_check ( source ) ;\n }", "hash": 8849962823026424130, "project": "debian", "size": 4, "target": 0, "idx": 5505}
{"code": "static ssize_t qio_channel_websock_readv ( QIOChannel * ioc , const struct iovec * iov , size_t niov , int * * fds , size_t * nfds , Error * * errp ) {\n QIOChannelWebsock * wioc = QIO_CHANNEL_WEBSOCK ( ioc ) ;\n size_t i ;\n ssize_t got = 0 ;\n ssize_t ret ;\n if ( wioc -> io_err ) {\n error_propagate ( errp , error_copy ( wioc -> io_err ) ) ;\n return - 1 ;\n }\n if ( ! wioc -> rawinput . offset ) {\n ret = qio_channel_websock_read_wire ( QIO_CHANNEL_WEBSOCK ( ioc ) , errp ) ;\n if ( ret < 0 ) {\n return ret ;\n }\n }\n for ( i = 0 ;\n i < niov ;\n i ++ ) {\n size_t want = iov [ i ] . iov_len ;\n if ( want > ( wioc -> rawinput . offset - got ) ) {\n want = ( wioc -> rawinput . offset - got ) ;\n }\n memcpy ( iov [ i ] . iov_base , wioc -> rawinput . buffer + got , want ) ;\n got += want ;\n if ( want < iov [ i ] . iov_len ) {\n break ;\n }\n }\n buffer_advance ( & wioc -> rawinput , got ) ;\n qio_channel_websock_set_watch ( wioc ) ;\n return got ;\n }", "hash": 8849962823026424130, "project": "debian", "size": 32, "target": 0, "idx": 5507}
{"code": "static gboolean qio_channel_websock_source_check ( GSource * source ) {\n QIOChannelWebsockSource * wsource = ( QIOChannelWebsockSource * ) source ;\n GIOCondition cond = 0 ;\n if ( wsource -> wioc -> rawinput . offset || wsource -> wioc -> io_eof ) {\n cond |= G_IO_IN ;\n }\n if ( wsource -> wioc -> encoutput . offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER ) {\n cond |= G_IO_OUT ;\n }\n return cond & wsource -> condition ;\n }", "hash": 8849962823026424130, "project": "debian", "size": 11, "target": 0, "idx": 5508}
{"code": "static GSource * qio_channel_websock_create_watch ( QIOChannel * ioc , GIOCondition condition ) {\n QIOChannelWebsock * wioc = QIO_CHANNEL_WEBSOCK ( ioc ) ;\n QIOChannelWebsockSource * ssource ;\n GSource * source ;\n source = g_source_new ( & qio_channel_websock_source_funcs , sizeof ( QIOChannelWebsockSource ) ) ;\n ssource = ( QIOChannelWebsockSource * ) source ;\n ssource -> wioc = wioc ;\n object_ref ( OBJECT ( wioc ) ) ;\n ssource -> condition = condition ;\n qio_channel_websock_set_watch ( wioc ) ;\n return source ;\n }", "hash": 8849962823026424130, "project": "debian", "size": 12, "target": 0, "idx": 5512}
{"code": "static void parseqatom ( struct vars * v , int stopper , int type , struct state * lp , struct state * rp , struct subre * top ) {\n struct state * s ;\n struct state * s2 ;\n # define ARCV ( t , val ) newarc ( v -> nfa , t , val , lp , rp ) int m , n ;\n struct subre * atom ;\n struct subre * t ;\n int cap ;\n int latype ;\n int subno ;\n int atomtype ;\n int qprefer ;\n int f ;\n struct subre * * atomp ;\n atom = NULL ;\n assert ( lp -> nouts == 0 ) ;\n assert ( rp -> nins == 0 ) ;\n subno = 0 ;\n atomtype = v -> nexttype ;\n switch ( atomtype ) {\n case '^' : ARCV ( '^' , 1 ) ;\n if ( v -> cflags & REG_NLANCH ) ARCV ( BEHIND , v -> nlcolor ) ;\n NEXT ( ) ;\n return ;\n break ;\n case '$' : ARCV ( '$' , 1 ) ;\n if ( v -> cflags & REG_NLANCH ) ARCV ( AHEAD , v -> nlcolor ) ;\n NEXT ( ) ;\n return ;\n break ;\n case SBEGIN : ARCV ( '^' , 1 ) ;\n ARCV ( '^' , 0 ) ;\n NEXT ( ) ;\n return ;\n break ;\n case SEND : ARCV ( '$' , 1 ) ;\n ARCV ( '$' , 0 ) ;\n NEXT ( ) ;\n return ;\n break ;\n case '<' : wordchrs ( v ) ;\n s = newstate ( v -> nfa ) ;\n NOERR ( ) ;\n nonword ( v , BEHIND , lp , s ) ;\n word ( v , AHEAD , s , rp ) ;\n return ;\n break ;\n case '>' : wordchrs ( v ) ;\n s = newstate ( v -> nfa ) ;\n NOERR ( ) ;\n word ( v , BEHIND , lp , s ) ;\n nonword ( v , AHEAD , s , rp ) ;\n return ;\n break ;\n case WBDRY : wordchrs ( v ) ;\n s = newstate ( v -> nfa ) ;\n NOERR ( ) ;\n nonword ( v , BEHIND , lp , s ) ;\n word ( v , AHEAD , s , rp ) ;\n s = newstate ( v -> nfa ) ;\n NOERR ( ) ;\n word ( v , BEHIND , lp , s ) ;\n nonword ( v , AHEAD , s , rp ) ;\n return ;\n break ;\n case NWBDRY : wordchrs ( v ) ;\n s = newstate ( v -> nfa ) ;\n NOERR ( ) ;\n word ( v , BEHIND , lp , s ) ;\n word ( v , AHEAD , s , rp ) ;\n s = newstate ( v -> nfa ) ;\n NOERR ( ) ;\n nonword ( v , BEHIND , lp , s ) ;\n nonword ( v , AHEAD , s , rp ) ;\n return ;\n break ;\n case LACON : latype = v -> nextvalue ;\n NEXT ( ) ;\n s = newstate ( v -> nfa ) ;\n s2 = newstate ( v -> nfa ) ;\n NOERR ( ) ;\n t = parse ( v , ')' , LACON , s , s2 ) ;\n freesubre ( v , t ) ;\n NOERR ( ) ;\n assert ( SEE ( ')' ) ) ;\n NEXT ( ) ;\n processlacon ( v , s , s2 , latype , lp , rp ) ;\n return ;\n break ;\n case '*' : case '+' : case '?' : case '{\n' : ERR ( REG_BADRPT ) ;\n return ;\n break ;\n default : ERR ( REG_ASSERT ) ;\n return ;\n break ;\n case ')' : if ( ( v -> cflags & REG_ADVANCED ) != REG_EXTENDED ) {\n ERR ( REG_EPAREN ) ;\n return ;\n }\n NOTE ( REG_UPBOTCH ) ;\n case PLAIN : onechr ( v , v -> nextvalue , lp , rp ) ;\n okcolors ( v -> nfa , v -> cm ) ;\n NOERR ( ) ;\n NEXT ( ) ;\n break ;\n case '[' : if ( v -> nextvalue == 1 ) bracket ( v , lp , rp ) ;\n else cbracket ( v , lp , rp ) ;\n assert ( SEE ( ']' ) || ISERR ( ) ) ;\n NEXT ( ) ;\n break ;\n case '.' : rainbow ( v -> nfa , v -> cm , PLAIN , ( v -> cflags & REG_NLSTOP ) ? v -> nlcolor : COLORLESS , lp , rp ) ;\n NEXT ( ) ;\n break ;\n case '(' : cap = ( type == LACON ) ? 0 : v -> nextvalue ;\n if ( cap ) {\n v -> nsubexp ++ ;\n subno = v -> nsubexp ;\n if ( ( size_t ) subno >= v -> nsubs ) moresubs ( v , subno ) ;\n assert ( ( size_t ) subno < v -> nsubs ) ;\n }\n else atomtype = PLAIN ;\n NEXT ( ) ;\n s = newstate ( v -> nfa ) ;\n s2 = newstate ( v -> nfa ) ;\n NOERR ( ) ;\n EMPTYARC ( lp , s ) ;\n EMPTYARC ( s2 , rp ) ;\n NOERR ( ) ;\n atom = parse ( v , ')' , type , s , s2 ) ;\n assert ( SEE ( ')' ) || ISERR ( ) ) ;\n NEXT ( ) ;\n NOERR ( ) ;\n if ( cap ) {\n v -> subs [ subno ] = atom ;\n t = subre ( v , '(' , atom -> flags | CAP , lp , rp ) ;\n NOERR ( ) ;\n t -> subno = subno ;\n t -> left = atom ;\n atom = t ;\n }\n break ;\n case BACKREF : INSIST ( type != LACON , REG_ESUBREG ) ;\n INSIST ( v -> nextvalue < v -> nsubs , REG_ESUBREG ) ;\n INSIST ( v -> subs [ v -> nextvalue ] != NULL , REG_ESUBREG ) ;\n NOERR ( ) ;\n assert ( v -> nextvalue > 0 ) ;\n atom = subre ( v , 'b' , BACKR , lp , rp ) ;\n NOERR ( ) ;\n subno = v -> nextvalue ;\n atom -> subno = subno ;\n EMPTYARC ( lp , rp ) ;\n NEXT ( ) ;\n break ;\n }\n switch ( v -> nexttype ) {\n case '*' : m = 0 ;\n n = DUPINF ;\n qprefer = ( v -> nextvalue ) ? LONGER : SHORTER ;\n NEXT ( ) ;\n break ;\n case '+' : m = 1 ;\n n = DUPINF ;\n qprefer = ( v -> nextvalue ) ? LONGER : SHORTER ;\n NEXT ( ) ;\n break ;\n case '?' : m = 0 ;\n n = 1 ;\n qprefer = ( v -> nextvalue ) ? LONGER : SHORTER ;\n NEXT ( ) ;\n break ;\n case '{\n' : NEXT ( ) ;\n m = scannum ( v ) ;\n if ( EAT ( ',' ) ) {\n if ( SEE ( DIGIT ) ) n = scannum ( v ) ;\n else n = DUPINF ;\n if ( m > n ) {\n ERR ( REG_BADBR ) ;\n return ;\n }\n qprefer = ( v -> nextvalue ) ? LONGER : SHORTER ;\n }\n else {\n n = m ;\n qprefer = 0 ;\n }\n if ( ! SEE ( '}\n' ) ) {\n ERR ( REG_BADBR ) ;\n return ;\n }\n NEXT ( ) ;\n break ;\n default : m = n = 1 ;\n qprefer = 0 ;\n break ;\n }\n if ( m == 0 && n == 0 ) {\n if ( atom != NULL ) freesubre ( v , atom ) ;\n if ( atomtype == '(' ) v -> subs [ subno ] = NULL ;\n delsub ( v -> nfa , lp , rp ) ;\n EMPTYARC ( lp , rp ) ;\n return ;\n }\n assert ( ! MESSY ( top -> flags ) ) ;\n f = top -> flags | qprefer | ( ( atom != NULL ) ? atom -> flags : 0 ) ;\n if ( atomtype != '(' && atomtype != BACKREF && ! MESSY ( UP ( f ) ) ) {\n if ( ! ( m == 1 && n == 1 ) ) repeat ( v , lp , rp , m , n ) ;\n if ( atom != NULL ) freesubre ( v , atom ) ;\n top -> flags = f ;\n return ;\n }\n if ( atom == NULL ) {\n atom = subre ( v , '=' , 0 , lp , rp ) ;\n NOERR ( ) ;\n }\n s = newstate ( v -> nfa ) ;\n s2 = newstate ( v -> nfa ) ;\n NOERR ( ) ;\n moveouts ( v -> nfa , lp , s ) ;\n moveins ( v -> nfa , rp , s2 ) ;\n NOERR ( ) ;\n atom -> begin = s ;\n atom -> end = s2 ;\n s = newstate ( v -> nfa ) ;\n NOERR ( ) ;\n EMPTYARC ( lp , s ) ;\n NOERR ( ) ;\n t = subre ( v , '.' , COMBINE ( qprefer , atom -> flags ) , lp , rp ) ;\n NOERR ( ) ;\n t -> left = atom ;\n atomp = & t -> left ;\n assert ( top -> op == '=' && top -> left == NULL && top -> right == NULL ) ;\n top -> left = subre ( v , '=' , top -> flags , top -> begin , lp ) ;\n NOERR ( ) ;\n top -> op = '.' ;\n top -> right = t ;\n if ( atomtype == BACKREF ) {\n assert ( atom -> begin -> nouts == 1 ) ;\n delsub ( v -> nfa , atom -> begin , atom -> end ) ;\n assert ( v -> subs [ subno ] != NULL ) ;\n dupnfa ( v -> nfa , v -> subs [ subno ] -> begin , v -> subs [ subno ] -> end , atom -> begin , atom -> end ) ;\n NOERR ( ) ;\n }\n if ( atomtype == BACKREF ) {\n EMPTYARC ( s , atom -> begin ) ;\n repeat ( v , atom -> begin , atom -> end , m , n ) ;\n atom -> min = ( short ) m ;\n atom -> max = ( short ) n ;\n atom -> flags |= COMBINE ( qprefer , atom -> flags ) ;\n s2 = atom -> end ;\n }\n else if ( m == 1 && n == 1 ) {\n EMPTYARC ( s , atom -> begin ) ;\n s2 = atom -> end ;\n }\n else if ( m > 0 && ! ( atom -> flags & BACKR ) ) {\n dupnfa ( v -> nfa , atom -> begin , atom -> end , s , atom -> begin ) ;\n assert ( m >= 1 && m != DUPINF && n >= 1 ) ;\n repeat ( v , s , atom -> begin , m - 1 , ( n == DUPINF ) ? n : n - 1 ) ;\n f = COMBINE ( qprefer , atom -> flags ) ;\n t = subre ( v , '.' , f , s , atom -> end ) ;\n NOERR ( ) ;\n t -> left = subre ( v , '=' , PREF ( f ) , s , atom -> begin ) ;\n NOERR ( ) ;\n t -> right = atom ;\n * atomp = t ;\n s2 = atom -> end ;\n }\n else {\n s2 = newstate ( v -> nfa ) ;\n NOERR ( ) ;\n moveouts ( v -> nfa , atom -> end , s2 ) ;\n NOERR ( ) ;\n dupnfa ( v -> nfa , atom -> begin , atom -> end , s , s2 ) ;\n repeat ( v , s , s2 , m , n ) ;\n f = COMBINE ( qprefer , atom -> flags ) ;\n t = subre ( v , '*' , f , s , s2 ) ;\n NOERR ( ) ;\n t -> min = ( short ) m ;\n t -> max = ( short ) n ;\n t -> left = atom ;\n * atomp = t ;\n }\n t = top -> right ;\n if ( ! ( SEE ( '|' ) || SEE ( stopper ) || SEE ( EOS ) ) ) t -> right = parsebranch ( v , stopper , type , s2 , rp , 1 ) ;\n else {\n EMPTYARC ( s2 , rp ) ;\n t -> right = subre ( v , '=' , 0 , s2 , rp ) ;\n }\n NOERR ( ) ;\n assert ( SEE ( '|' ) || SEE ( stopper ) || SEE ( EOS ) ) ;\n t -> flags |= COMBINE ( t -> flags , t -> right -> flags ) ;\n top -> flags |= COMBINE ( top -> flags , t -> flags ) ;\n }", "hash": 2390790920103114259, "project": "debian", "size": 295, "target": 0, "idx": 5556}
{"code": "static struct subre * parsebranch ( struct vars * v , int stopper , int type , struct state * left , struct state * right , int partial ) {\n struct state * lp ;\n int seencontent ;\n struct subre * t ;\n lp = left ;\n seencontent = 0 ;\n t = subre ( v , '=' , 0 , left , right ) ;\n NOERRN ( ) ;\n while ( ! SEE ( '|' ) && ! SEE ( stopper ) && ! SEE ( EOS ) ) {\n if ( seencontent ) {\n lp = newstate ( v -> nfa ) ;\n NOERRN ( ) ;\n moveins ( v -> nfa , right , lp ) ;\n }\n seencontent = 1 ;\n parseqatom ( v , stopper , type , lp , right , t ) ;\n NOERRN ( ) ;\n }\n if ( ! seencontent ) {\n if ( ! partial ) NOTE ( REG_UUNSPEC ) ;\n assert ( lp == left ) ;\n EMPTYARC ( left , right ) ;\n }\n return t ;\n }", "hash": 2390790920103114259, "project": "debian", "size": 25, "target": 0, "idx": 5573}
{"code": "static void freesubre ( struct vars * v , struct subre * sr ) {\n if ( sr == NULL ) return ;\n if ( sr -> left != NULL ) freesubre ( v , sr -> left ) ;\n if ( sr -> right != NULL ) freesubre ( v , sr -> right ) ;\n freesrnode ( v , sr ) ;\n }", "hash": 2390790920103114259, "project": "debian", "size": 6, "target": 0, "idx": 5575}
{"code": "static int freev ( struct vars * v , int err ) {\n if ( v -> re != NULL ) rfree ( v -> re ) ;\n if ( v -> subs != v -> sub10 ) FREE ( v -> subs ) ;\n if ( v -> nfa != NULL ) freenfa ( v -> nfa ) ;\n if ( v -> tree != NULL ) freesubre ( v , v -> tree ) ;\n if ( v -> treechain != NULL ) cleanst ( v ) ;\n if ( v -> cv != NULL ) freecvec ( v -> cv ) ;\n if ( v -> cv2 != NULL ) freecvec ( v -> cv2 ) ;\n if ( v -> lacons != NULL ) freelacons ( v -> lacons , v -> nlacons ) ;\n ERR ( err ) ;\n return v -> err ;\n }", "hash": 2390790920103114259, "project": "debian", "size": 12, "target": 0, "idx": 5583}
{"code": "static void word ( struct vars * v , int dir , struct state * lp , struct state * rp ) {\n assert ( dir == AHEAD || dir == BEHIND ) ;\n cloneouts ( v -> nfa , v -> wordchrs , lp , rp , dir ) ;\n }", "hash": 2390790920103114259, "project": "debian", "size": 4, "target": 0, "idx": 5587}
{"code": "static int tcomp ( const void * _t1 , const void * _t2 ) {\n struct taboff * t1 = * ( ( struct taboff * * ) _t1 ) , * t2 = * ( ( struct taboff * * ) _t2 ) ;\n return ( t1 -> orderingval - t2 -> orderingval ) ;\n }", "hash": -3740862514502467070, "project": "debian", "size": 4, "target": 0, "idx": 5593}
{"code": "static int AssignTTFBitGlyph ( struct glyphinfo * gi , SplineFont * sf , EncMap * map , int32 * bsizes ) {\n int i , j ;\n BDFFont * bdf ;\n int * bygid = malloc ( ( sf -> glyphcnt + 3 ) * sizeof ( int ) ) ;\n memset ( bygid , 0xff , ( sf -> glyphcnt + 3 ) * sizeof ( int ) ) ;\n AssignNotdefNull ( sf , bygid , false ) ;\n for ( bdf = sf -> bitmaps ;\n bdf != NULL ;\n bdf = bdf -> next ) {\n for ( j = 0 ;\n bsizes [ j ] != 0 && ( ( bsizes [ j ] & 0xffff ) != bdf -> pixelsize || ( bsizes [ j ] >> 16 ) != BDFDepth ( bdf ) ) ;\n ++ j ) ;\n if ( bsizes [ j ] == 0 ) continue ;\n for ( i = 0 ;\n i < bdf -> glyphcnt ;\n ++ i ) if ( ! IsntBDFChar ( bdf -> glyphs [ i ] ) ) sf -> glyphs [ i ] -> ttf_glyph = - 2 ;\n }\n j = 3 ;\n for ( i = 0 ;\n i < map -> enccount ;\n ++ i ) if ( map -> map [ i ] != - 1 ) {\n SplineChar * sc = sf -> glyphs [ map -> map [ i ] ] ;\n if ( sc -> ttf_glyph == - 2 ) {\n sc -> ttf_glyph = j ;\n bygid [ j ++ ] = sc -> orig_pos ;\n }\n }\n for ( i = 0 ;\n i < sf -> glyphcnt ;\n ++ i ) if ( sf -> glyphs [ i ] != NULL ) {\n SplineChar * sc = sf -> glyphs [ i ] ;\n if ( sc -> ttf_glyph == - 2 ) {\n sc -> ttf_glyph = j ;\n bygid [ j ++ ] = i ;\n }\n }\n gi -> bygid = bygid ;\n gi -> gcnt = j ;\n return j ;\n }", "hash": -3740862514502467070, "project": "debian", "size": 40, "target": 0, "idx": 5596}
{"code": "static void buildtablestructures ( struct alltabs * at , SplineFont * sf , enum fontformat format ) {\n int i ;\n int ebdtpos , eblcpos ;\n struct ttf_table * tab ;\n if ( format == ff_otf || format == ff_otfcid ) {\n at -> tabdir . version = CHR ( 'O' , 'T' , 'T' , 'O' ) ;\n # ifdef FONTFORGE_CONFIG_APPLE_ONLY_TTF }\n else if ( at -> applemode && ! at -> opentypemode ) {\n at -> tabdir . version = CHR ( 't' , 'r' , 'u' , 'e' ) ;\n # endif }\n else {\n at -> tabdir . version = 0x00010000 ;\n }\n i = 0 ;\n if ( at -> base != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'B' , 'A' , 'S' , 'E' ) ;\n at -> tabdir . tabs [ i ] . data = at -> base ;\n at -> tabdir . tabs [ i ++ ] . length = at -> baselen ;\n }\n if ( at -> bsln != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'b' , 's' , 'l' , 'n' ) ;\n at -> tabdir . tabs [ i ] . data = at -> bsln ;\n at -> tabdir . tabs [ i ++ ] . length = at -> bslnlen ;\n }\n if ( at -> bdf != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'B' , 'D' , 'F' , ' ' ) ;\n at -> tabdir . tabs [ i ] . data = at -> bdf ;\n at -> tabdir . tabs [ i ++ ] . length = at -> bdflen ;\n }\n if ( format == ff_otf || format == ff_otfcid ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'C' , 'F' , 'F' , ' ' ) ;\n at -> tabdir . tabs [ i ] . length = at -> cfflen ;\n at -> tabdir . tabs [ i ++ ] . data = at -> cfff ;\n }\n if ( at -> dsigf != NULL ) {\n ebdtpos = i ;\n at -> tabdir . tabs [ i ] . tag = CHR ( 'D' , 'S' , 'I' , 'G' ) ;\n at -> tabdir . tabs [ i ] . length = at -> dsiglen ;\n at -> tabdir . tabs [ i ++ ] . data = at -> dsigf ;\n }\n if ( at -> bdat != NULL && ( at -> msbitmaps || at -> otbbitmaps ) ) {\n ebdtpos = i ;\n at -> tabdir . tabs [ i ] . tag = CHR ( 'E' , 'B' , 'D' , 'T' ) ;\n at -> tabdir . tabs [ i ] . length = at -> bdatlen ;\n at -> tabdir . tabs [ i ++ ] . data = at -> bdat ;\n }\n if ( at -> bloc != NULL && ( at -> msbitmaps || at -> otbbitmaps ) ) {\n eblcpos = i ;\n at -> tabdir . tabs [ i ] . tag = CHR ( 'E' , 'B' , 'L' , 'C' ) ;\n at -> tabdir . tabs [ i ] . data = at -> bloc ;\n at -> tabdir . tabs [ i ++ ] . length = at -> bloclen ;\n }\n if ( at -> ebsc != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'E' , 'B' , 'S' , 'C' ) ;\n at -> tabdir . tabs [ i ] . data = at -> ebsc ;\n at -> tabdir . tabs [ i ++ ] . length = at -> ebsclen ;\n }\n if ( at -> fftmf != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'F' , 'F' , 'T' , 'M' ) ;\n at -> tabdir . tabs [ i ] . data = at -> fftmf ;\n at -> tabdir . tabs [ i ++ ] . length = at -> fftmlen ;\n }\n if ( at -> gdef != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'G' , 'D' , 'E' , 'F' ) ;\n at -> tabdir . tabs [ i ] . data = at -> gdef ;\n at -> tabdir . tabs [ i ++ ] . length = at -> gdeflen ;\n }\n if ( at -> gpos != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'G' , 'P' , 'O' , 'S' ) ;\n at -> tabdir . tabs [ i ] . data = at -> gpos ;\n at -> tabdir . tabs [ i ++ ] . length = at -> gposlen ;\n }\n if ( at -> gsub != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'G' , 'S' , 'U' , 'B' ) ;\n at -> tabdir . tabs [ i ] . data = at -> gsub ;\n at -> tabdir . tabs [ i ++ ] . length = at -> gsublen ;\n }\n if ( at -> jstf != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'J' , 'S' , 'T' , 'F' ) ;\n at -> tabdir . tabs [ i ] . data = at -> jstf ;\n at -> tabdir . tabs [ i ++ ] . length = at -> jstflen ;\n }\n if ( at -> os2f != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'O' , 'S' , '/' , '2' ) ;\n at -> tabdir . tabs [ i ] . data = at -> os2f ;\n at -> tabdir . tabs [ i ++ ] . length = at -> os2len ;\n }\n if ( at -> pfed != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'P' , 'f' , 'E' , 'd' ) ;\n at -> tabdir . tabs [ i ] . data = at -> pfed ;\n at -> tabdir . tabs [ i ++ ] . length = at -> pfedlen ;\n }\n if ( at -> tex != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'T' , 'e' , 'X' , ' ' ) ;\n at -> tabdir . tabs [ i ] . data = at -> tex ;\n at -> tabdir . tabs [ i ++ ] . length = at -> texlen ;\n }\n if ( at -> math != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'M' , 'A' , 'T' , 'H' ) ;\n at -> tabdir . tabs [ i ] . data = at -> math ;\n at -> tabdir . tabs [ i ++ ] . length = at -> mathlen ;\n }\n if ( at -> vorgf != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'V' , 'O' , 'R' , 'G' ) ;\n at -> tabdir . tabs [ i ] . data = at -> vorgf ;\n at -> tabdir . tabs [ i ++ ] . length = at -> vorglen ;\n }\n if ( at -> acnt != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'a' , 'c' , 'n' , 't' ) ;\n at -> tabdir . tabs [ i ] . data = at -> acnt ;\n at -> tabdir . tabs [ i ++ ] . length = at -> acntlen ;\n }\n if ( at -> bdat != NULL && at -> applebitmaps ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'b' , 'd' , 'a' , 't' ) ;\n if ( ! at -> msbitmaps ) {\n at -> tabdir . tabs [ i ] . data = at -> bdat ;\n at -> tabdir . tabs [ i ++ ] . length = at -> bdatlen ;\n }\n else {\n at -> tabdir . tabs [ i ] . data = NULL ;\n at -> tabdir . tabs [ i ] . dup_of = ebdtpos ;\n at -> tabdir . tabs [ i ++ ] . length = at -> tabdir . tabs [ ebdtpos ] . length ;\n }\n }\n if ( format == ff_none && at -> applebitmaps ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'b' , 'h' , 'e' , 'd' ) ;\n at -> tabdir . tabs [ i ] . data = at -> headf ;\n at -> tabdir . tabs [ i ++ ] . length = at -> headlen ;\n }\n if ( at -> bloc != NULL && at -> applebitmaps ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'b' , 'l' , 'o' , 'c' ) ;\n if ( ! at -> msbitmaps ) {\n at -> tabdir . tabs [ i ] . data = at -> bloc ;\n at -> tabdir . tabs [ i ++ ] . length = at -> bloclen ;\n }\n else {\n at -> tabdir . tabs [ i ] . data = NULL ;\n at -> tabdir . tabs [ i ] . dup_of = eblcpos ;\n at -> tabdir . tabs [ i ++ ] . length = at -> tabdir . tabs [ eblcpos ] . length ;\n }\n }\n if ( at -> cmap != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'c' , 'm' , 'a' , 'p' ) ;\n at -> tabdir . tabs [ i ] . data = at -> cmap ;\n at -> tabdir . tabs [ i ++ ] . length = at -> cmaplen ;\n }\n if ( format != ff_otf && format != ff_otfcid && format != ff_none ) {\n if ( at -> cvtf != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'c' , 'v' , 't' , ' ' ) ;\n at -> tabdir . tabs [ i ] . data = at -> cvtf ;\n at -> tabdir . tabs [ i ++ ] . length = at -> cvtlen ;\n }\n }\n if ( at -> feat != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'f' , 'e' , 'a' , 't' ) ;\n at -> tabdir . tabs [ i ] . data = at -> feat ;\n at -> tabdir . tabs [ i ++ ] . length = at -> featlen ;\n }\n if ( at -> fpgmf != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'f' , 'p' , 'g' , 'm' ) ;\n at -> tabdir . tabs [ i ] . data = at -> fpgmf ;\n at -> tabdir . tabs [ i ++ ] . length = at -> fpgmlen ;\n }\n if ( at -> gaspf != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'g' , 'a' , 's' , 'p' ) ;\n at -> tabdir . tabs [ i ] . data = at -> gaspf ;\n at -> tabdir . tabs [ i ++ ] . length = at -> gasplen ;\n }\n if ( at -> gi . glyphs != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'g' , 'l' , 'y' , 'f' ) ;\n at -> tabdir . tabs [ i ] . data = at -> gi . glyphs ;\n at -> tabdir . tabs [ i ++ ] . length = at -> gi . glyph_len ;\n }\n if ( at -> hdmxf != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'h' , 'd' , 'm' , 'x' ) ;\n at -> tabdir . tabs [ i ] . data = at -> hdmxf ;\n at -> tabdir . tabs [ i ++ ] . length = at -> hdmxlen ;\n }\n if ( format != ff_none || ! at -> applebitmaps ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'h' , 'e' , 'a' , 'd' ) ;\n at -> tabdir . tabs [ i ] . data = at -> headf ;\n at -> tabdir . tabs [ i ++ ] . length = at -> headlen ;\n }\n if ( format != ff_none || ! at -> applemode ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'h' , 'h' , 'e' , 'a' ) ;\n at -> tabdir . tabs [ i ] . data = at -> hheadf ;\n at -> tabdir . tabs [ i ++ ] . length = at -> hheadlen ;\n }\n else if ( at -> hheadf != NULL ) {\n fclose ( at -> hheadf ) ;\n at -> hheadf = NULL ;\n }\n if ( format != ff_none || ! at -> applemode ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'h' , 'm' , 't' , 'x' ) ;\n at -> tabdir . tabs [ i ] . data = at -> gi . hmtx ;\n at -> tabdir . tabs [ i ++ ] . length = at -> gi . hmtxlen ;\n }\n if ( at -> kern != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'k' , 'e' , 'r' , 'n' ) ;\n at -> tabdir . tabs [ i ] . data = at -> kern ;\n at -> tabdir . tabs [ i ++ ] . length = at -> kernlen ;\n }\n if ( at -> lcar != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'l' , 'c' , 'a' , 'r' ) ;\n at -> tabdir . tabs [ i ] . data = at -> lcar ;\n at -> tabdir . tabs [ i ++ ] . length = at -> lcarlen ;\n }\n if ( at -> loca != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'l' , 'o' , 'c' , 'a' ) ;\n at -> tabdir . tabs [ i ] . data = at -> loca ;\n at -> tabdir . tabs [ i ++ ] . length = at -> localen ;\n }\n at -> tabdir . tabs [ i ] . tag = CHR ( 'm' , 'a' , 'x' , 'p' ) ;\n at -> tabdir . tabs [ i ] . data = at -> maxpf ;\n at -> tabdir . tabs [ i ++ ] . length = at -> maxplen ;\n if ( at -> morx != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'm' , 'o' , 'r' , 'x' ) ;\n at -> tabdir . tabs [ i ] . data = at -> morx ;\n at -> tabdir . tabs [ i ++ ] . length = at -> morxlen ;\n }\n if ( at -> name != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'n' , 'a' , 'm' , 'e' ) ;\n at -> tabdir . tabs [ i ] . data = at -> name ;\n at -> tabdir . tabs [ i ++ ] . length = at -> namelen ;\n }\n if ( at -> opbd != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'o' , 'p' , 'b' , 'd' ) ;\n at -> tabdir . tabs [ i ] . data = at -> opbd ;\n at -> tabdir . tabs [ i ++ ] . length = at -> opbdlen ;\n }\n if ( at -> post != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'p' , 'o' , 's' , 't' ) ;\n at -> tabdir . tabs [ i ] . data = at -> post ;\n at -> tabdir . tabs [ i ++ ] . length = at -> postlen ;\n }\n if ( format != ff_otf && format != ff_otfcid && format != ff_none ) {\n if ( at -> prepf != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'p' , 'r' , 'e' , 'p' ) ;\n at -> tabdir . tabs [ i ] . data = at -> prepf ;\n at -> tabdir . tabs [ i ++ ] . length = at -> preplen ;\n }\n }\n if ( at -> prop != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'p' , 'r' , 'o' , 'p' ) ;\n at -> tabdir . tabs [ i ] . data = at -> prop ;\n at -> tabdir . tabs [ i ++ ] . length = at -> proplen ;\n }\n if ( at -> vheadf != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'v' , 'h' , 'e' , 'a' ) ;\n at -> tabdir . tabs [ i ] . data = at -> vheadf ;\n at -> tabdir . tabs [ i ++ ] . length = at -> vheadlen ;\n at -> tabdir . tabs [ i ] . tag = CHR ( 'v' , 'm' , 't' , 'x' ) ;\n at -> tabdir . tabs [ i ] . data = at -> gi . vmtx ;\n at -> tabdir . tabs [ i ++ ] . length = at -> gi . vmtxlen ;\n }\n if ( at -> fvar != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'f' , 'v' , 'a' , 'r' ) ;\n at -> tabdir . tabs [ i ] . data = at -> fvar ;\n at -> tabdir . tabs [ i ++ ] . length = at -> fvarlen ;\n }\n if ( at -> gvar != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'g' , 'v' , 'a' , 'r' ) ;\n at -> tabdir . tabs [ i ] . data = at -> gvar ;\n at -> tabdir . tabs [ i ++ ] . length = at -> gvarlen ;\n }\n if ( at -> cvar != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'c' , 'v' , 'a' , 'r' ) ;\n at -> tabdir . tabs [ i ] . data = at -> cvar ;\n at -> tabdir . tabs [ i ++ ] . length = at -> cvarlen ;\n }\n if ( at -> avar != NULL ) {\n at -> tabdir . tabs [ i ] . tag = CHR ( 'a' , 'v' , 'a' , 'r' ) ;\n at -> tabdir . tabs [ i ] . data = at -> avar ;\n at -> tabdir . tabs [ i ++ ] . length = at -> avarlen ;\n }\n if ( i >= MAX_TAB ) IError ( \"Miscalculation of number of tables needed. Up sizeof tabs array in struct tabdir in ttf.h\" ) ;\n for ( tab = sf -> ttf_tab_saved ;\n tab != NULL && i < MAX_TAB ;\n tab = tab -> next ) {\n at -> tabdir . tabs [ i ] . tag = tab -> tag ;\n at -> tabdir . tabs [ i ] . data = tab -> temp ;\n at -> tabdir . tabs [ i ++ ] . length = tab -> len ;\n }\n if ( tab != NULL ) IError ( \"Some user supplied tables omitted. Up sizeof tabs array in struct tabdir in ttf.h\" ) ;\n at -> tabdir . numtab = i ;\n at -> tabdir . searchRange = ( i < 16 ? 8 : i < 32 ? 16 : i < 64 ? 32 : 64 ) * 16 ;\n at -> tabdir . entrySel = ( i < 16 ? 3 : i < 32 ? 4 : i < 64 ? 5 : 6 ) ;\n at -> tabdir . rangeShift = at -> tabdir . numtab * 16 - at -> tabdir . searchRange ;\n }", "hash": -3740862514502467070, "project": "debian", "size": 289, "target": 0, "idx": 5609}
{"code": "void OS2FigureCodePages ( SplineFont * sf , uint32 CodePage [ 2 ] ) {\n int i ;\n uint32 latin1 [ 8 ] ;\n int has_ascii , has_lineart = 0 , has_radical = 0 , has_summation = 0 ;\n int cp852 = 0 , cp775 = 0 , cp861 = 0 , cp860 = 0 , cp857 = 0 , cp855 = 0 , cp862 = 0 , cp863 = 0 ;\n int cp864 = 0 , cp865 = 0 , cp866 = 0 , cp869 = 0 , cp737 = 0 , cp708 = 0 , mac = 0 ;\n int k ;\n SplineChar * sc ;\n SplineFont * sub ;\n memset ( latin1 , 0 , sizeof ( latin1 ) ) ;\n k = 0 ;\n do {\n sub = k < sf -> subfontcnt ? sf -> subfonts [ k ] : sf ;\n for ( i = 0 ;\n i < sub -> glyphcnt ;\n ++ i ) if ( ( sc = sub -> glyphs [ i ] ) != NULL ) {\n if ( sc -> unicodeenc < 256 && sc -> unicodeenc >= 0 ) latin1 [ ( sc -> unicodeenc >> 5 ) ] |= 1 << ( sc -> unicodeenc & 31 ) ;\n }\n ++ k ;\n }\n while ( k < sf -> subfontcnt ) ;\n has_ascii = latin1 [ 1 ] == 0xffffffff && latin1 [ 2 ] == 0xffffffff && ( latin1 [ 3 ] & 0x7fffffff ) == 0x7fffffff ;\n CodePage [ 0 ] = CodePage [ 1 ] = 0 ;\n k = 0 ;\n do {\n sub = k < sf -> subfontcnt ? sf -> subfonts [ k ] : sf ;\n for ( i = 0 ;\n i < sub -> glyphcnt ;\n ++ i ) if ( ( sc = sub -> glyphs [ i ] ) != NULL ) {\n int uni = sc -> unicodeenc ;\n if ( uni == 0xde && has_ascii ) CodePage [ 0 ] |= 1 << 0 ;\n else if ( uni == 0x255a && has_ascii ) {\n CodePage [ 1 ] |= 1U << 30 ;\n CodePage [ 1 ] |= 1U << 31 ;\n }\n else if ( uni == 0x13d && has_ascii ) {\n CodePage [ 0 ] |= 1 << 1 ;\n ++ cp852 ;\n }\n else if ( uni == 0x411 ) {\n CodePage [ 0 ] |= 1 << 2 ;\n ++ cp866 ;\n ++ cp855 ;\n }\n else if ( uni == 0x405 ) {\n ++ cp855 ;\n }\n else if ( uni == 0x386 ) {\n CodePage [ 0 ] |= 1 << 3 ;\n ++ cp869 ;\n ++ cp737 ;\n }\n else if ( uni == 0x130 && has_ascii ) {\n CodePage [ 0 ] |= 1 << 4 ;\n ++ cp857 ;\n }\n else if ( uni == 0x5d0 ) {\n CodePage [ 0 ] |= 1 << 5 ;\n ++ cp862 ;\n }\n else if ( uni == 0x631 ) {\n CodePage [ 0 ] |= 1 << 6 ;\n ++ cp864 ;\n ++ cp708 ;\n }\n else if ( uni == 0x157 && has_ascii ) {\n CodePage [ 0 ] |= 1 << 7 ;\n ++ cp775 ;\n }\n else if ( uni == 0x20AB && has_ascii ) {\n CodePage [ 0 ] |= 1 << 8 ;\n }\n else if ( uni == 0xe45 ) CodePage [ 0 ] |= 1 << 16 ;\n else if ( uni == 0x30a8 ) CodePage [ 0 ] |= 1 << 17 ;\n else if ( uni == 0x3105 ) CodePage [ 0 ] |= 1 << 18 ;\n else if ( uni == 0x3131 ) CodePage [ 0 ] |= 1 << 19 ;\n else if ( uni == 0x592E ) CodePage [ 0 ] |= 1 << 20 ;\n else if ( uni == 0xacf4 ) CodePage [ 0 ] |= 1 << 21 ;\n else if ( uni == 0x2030 && has_ascii ) ++ mac ;\n else if ( uni == 0x2665 && has_ascii ) CodePage [ 0 ] |= 1U << 30 ;\n else if ( uni >= 0xf000 && uni <= 0xf0ff ) CodePage [ 0 ] |= 1U << 31 ;\n else if ( uni == 0xc5 && has_ascii ) ++ cp865 ;\n else if ( uni == 0xe9 && has_ascii ) ++ cp863 ;\n else if ( uni == 0xf5 && has_ascii ) ++ cp860 ;\n else if ( uni == 0xfe && has_ascii ) ++ cp861 ;\n else if ( uni == 0x2524 ) ++ has_lineart ;\n else if ( uni == 0x255c ) ++ cp866 ;\n else if ( uni == 0xbd ) ++ cp869 ;\n else if ( uni == 0x221A ) has_radical = true ;\n else if ( uni == 0x2211 ) has_summation = true ;\n }\n ++ k ;\n }\n while ( k < sf -> subfontcnt ) ;\n if ( cp852 && has_lineart ) CodePage [ 1 ] |= 1 << 26 ;\n if ( cp775 && has_lineart ) CodePage [ 1 ] |= 1 << 27 ;\n if ( cp861 && has_lineart ) CodePage [ 1 ] |= 1 << 22 ;\n if ( cp866 == 2 && has_lineart ) CodePage [ 1 ] |= 1 << 17 ;\n if ( cp855 == 2 && has_lineart ) CodePage [ 1 ] |= 1 << 25 ;\n if ( cp869 == 2 && has_lineart ) CodePage [ 1 ] |= 1 << 16 ;\n if ( cp737 && has_lineart && has_radical ) CodePage [ 1 ] |= 1 << 28 ;\n if ( cp857 && has_lineart ) CodePage [ 1 ] |= 1 << 24 ;\n if ( cp862 && has_lineart && has_radical ) CodePage [ 1 ] |= 1 << 21 ;\n if ( cp864 && has_radical ) CodePage [ 1 ] |= 1 << 19 ;\n if ( cp708 && has_lineart ) CodePage [ 1 ] |= 1 << 29 ;\n if ( cp863 && has_lineart && has_radical ) CodePage [ 1 ] |= 1 << 20 ;\n if ( cp865 && has_lineart && has_radical ) CodePage [ 1 ] |= 1 << 18 ;\n if ( cp860 && has_lineart && has_radical ) CodePage [ 1 ] |= 1 << 23 ;\n if ( mac && has_summation ) CodePage [ 0 ] |= 1U << 29 ;\n }", "hash": -3740862514502467070, "project": "debian", "size": 110, "target": 0, "idx": 5649}
{"code": "static void CopySFNTAndFixup ( FILE * ttc , FILE * ttf ) {\n int offset = ftell ( ttc ) ;\n int val , table_cnt , i ;\n fseek ( ttf , 0 , SEEK_SET ) ;\n val = getlong ( ttf ) ;\n putlong ( ttc , val ) ;\n table_cnt = getushort ( ttf ) ;\n putshort ( ttc , table_cnt ) ;\n val = getushort ( ttf ) ;\n putshort ( ttc , val ) ;\n val = getushort ( ttf ) ;\n putshort ( ttc , val ) ;\n val = getushort ( ttf ) ;\n putshort ( ttc , val ) ;\n for ( i = 0 ;\n i < table_cnt ;\n ++ i ) {\n val = getlong ( ttf ) ;\n putlong ( ttc , val ) ;\n val = getlong ( ttf ) ;\n putlong ( ttc , val ) ;\n val = getlong ( ttf ) ;\n putlong ( ttc , val + offset ) ;\n val = getlong ( ttf ) ;\n putlong ( ttc , val ) ;\n }\n while ( ( val = getc ( ttf ) ) != EOF ) putc ( val , ttc ) ;\n fclose ( ttf ) ;\n if ( ftell ( ttc ) & 1 ) putc ( '\\0' , ttc ) ;\n if ( ftell ( ttc ) & 2 ) putshort ( ttc , 0 ) ;\n }", "hash": -3740862514502467070, "project": "debian", "size": 31, "target": 0, "idx": 5653}
{"code": "static void dumphex ( struct hexout * hexout , FILE * temp , int length ) {\n int i , ch , ch1 ;\n if ( length & 1 ) LogError ( _ ( \"Table length should not be odd\\n\" ) ) ;\n while ( length > 65534 ) {\n dumphex ( hexout , temp , 65534 ) ;\n length -= 65534 ;\n }\n fprintf ( hexout -> type42 , \" <\\n \" ) ;\n hexout -> bytesout = 0 ;\n for ( i = 0 ;\n i < length ;\n ++ i ) {\n ch = getc ( temp ) ;\n if ( ch == EOF ) break ;\n if ( hexout -> bytesout >= 31 ) {\n fprintf ( hexout -> type42 , \"\\n \" ) ;\n hexout -> bytesout = 0 ;\n }\n ch1 = ch >> 4 ;\n if ( ch1 >= 10 ) ch1 += 'A' - 10 ;\n else ch1 += '0' ;\n putc ( ch1 , hexout -> type42 ) ;\n ch1 = ch & 0xf ;\n if ( ch1 >= 10 ) ch1 += 'A' - 10 ;\n else ch1 += '0' ;\n putc ( ch1 , hexout -> type42 ) ;\n ++ hexout -> bytesout ;\n }\n fprintf ( hexout -> type42 , \"\\n 00\\n >\\n\" ) ;\n }", "hash": -3740862514502467070, "project": "debian", "size": 30, "target": 0, "idx": 5661}
{"code": "void SFDefaultOS2SubSuper ( struct pfminfo * pfminfo , int emsize , double italic_angle ) {\n double s = sin ( italic_angle * 3.1415926535897932 / 180.0 ) ;\n pfminfo -> os2_supysize = pfminfo -> os2_subysize = .7 * emsize ;\n pfminfo -> os2_supxsize = pfminfo -> os2_subxsize = .65 * emsize ;\n pfminfo -> os2_subyoff = .14 * emsize ;\n pfminfo -> os2_supyoff = .48 * emsize ;\n pfminfo -> os2_supxoff = s * pfminfo -> os2_supyoff ;\n pfminfo -> os2_subxoff = - s * pfminfo -> os2_subyoff ;\n pfminfo -> os2_strikeysize = 102 * emsize / 2048 ;\n pfminfo -> os2_strikeypos = 530 * emsize / 2048 ;\n }", "hash": -3740862514502467070, "project": "debian", "size": 11, "target": 0, "idx": 5680}
{"code": "static void dumpdbl ( FILE * cfff , double d ) {\n if ( d - rint ( d ) > - .00001 && d - rint ( d ) < .00001 ) dumpint ( cfff , ( int ) d ) ;\n else {\n char buffer [ 20 ] , * pt ;\n int sofar , n , odd ;\n sprintf ( buffer , \"%g\" , d ) ;\n sofar = 0 ;\n odd = true ;\n putc ( 30 , cfff ) ;\n for ( pt = buffer ;\n * pt ;\n ++ pt ) {\n if ( isdigit ( * pt ) ) n = * pt - '0' ;\n else if ( * pt == '.' ) n = 0xa ;\n else if ( * pt == '-' ) n = 0xe ;\n else if ( ( * pt == 'E' || * pt == 'e' ) && pt [ 1 ] == '-' ) {\n n = 0xc ;\n ++ pt ;\n }\n else if ( * pt == 'E' || * pt == 'e' ) n = 0xb ;\n else n = 0 ;\n if ( odd ) {\n sofar = n << 4 ;\n odd = false ;\n }\n else {\n putc ( sofar | n , cfff ) ;\n sofar = 0 ;\n odd = true ;\n }\n }\n if ( sofar == 0 ) putc ( 0xff , cfff ) ;\n else putc ( sofar | 0xf , cfff ) ;\n }\n }", "hash": -3740862514502467070, "project": "debian", "size": 35, "target": 0, "idx": 5684}
{"code": "static void dumpnames ( struct alltabs * at , SplineFont * sf , enum fontformat format ) {\n int i , j ;\n struct ttflangname dummy , * cur , * useng = NULL ;\n struct macname * mn ;\n struct other_names * on , * onn ;\n NamTab nt ;\n struct otfname * otfn ;\n struct otffeatname * fn ;\n memset ( & nt , 0 , sizeof ( nt ) ) ;\n nt . encoding_name = at -> map -> enc ;\n nt . format = format ;\n nt . applemode = at -> applemode ;\n nt . strings = tmpfile ( ) ;\n if ( ( format >= ff_ttf && format <= ff_otfdfont ) && ( at -> gi . flags & ttf_flag_symbol ) ) nt . format = ff_ttfsym ;\n memset ( & dummy , 0 , sizeof ( dummy ) ) ;\n for ( cur = sf -> names ;\n cur != NULL ;\n cur = cur -> next ) {\n if ( cur -> lang == 0x409 ) {\n dummy = * cur ;\n useng = cur ;\n break ;\n }\n }\n DefaultTTFEnglishNames ( & dummy , sf ) ;\n for ( i = 0 ;\n i < ttf_namemax ;\n ++ i ) if ( dummy . names [ i ] != NULL ) AddEncodedName ( & nt , dummy . names [ i ] , 0x409 , i ) ;\n for ( cur = sf -> names ;\n cur != NULL ;\n cur = cur -> next ) {\n if ( cur -> lang != 0x409 ) for ( i = 0 ;\n i < ttf_namemax ;\n ++ i ) if ( cur -> names [ i ] != NULL ) AddEncodedName ( & nt , cur -> names [ i ] , cur -> lang , i ) ;\n }\n if ( at -> feat_name != NULL ) {\n for ( i = 0 ;\n at -> feat_name [ i ] . strid != 0 ;\n ++ i ) {\n for ( mn = at -> feat_name [ i ] . mn ;\n mn != NULL ;\n mn = mn -> next ) AddMacName ( & nt , mn , at -> feat_name [ i ] . strid ) ;\n }\n }\n for ( on = at -> other_names ;\n on != NULL ;\n on = onn ) {\n for ( mn = on -> mn ;\n mn != NULL ;\n mn = mn -> next ) AddMacName ( & nt , mn , on -> strid ) ;\n onn = on -> next ;\n chunkfree ( on , sizeof ( * on ) ) ;\n }\n if ( at -> fontstyle_name_strid != 0 && sf -> fontstyle_name != NULL ) {\n for ( otfn = sf -> fontstyle_name ;\n otfn != NULL ;\n otfn = otfn -> next ) AddEncodedName ( & nt , otfn -> name , otfn -> lang , at -> fontstyle_name_strid ) ;\n }\n for ( fn = sf -> feat_names ;\n fn != NULL ;\n fn = fn -> next ) {\n for ( otfn = fn -> names ;\n otfn != NULL ;\n otfn = otfn -> next ) AddEncodedName ( & nt , otfn -> name , otfn -> lang , fn -> nid ) ;\n }\n qsort ( nt . entries , nt . cur , sizeof ( NameEntry ) , compare_entry ) ;\n at -> name = tmpfile ( ) ;\n putshort ( at -> name , 0 ) ;\n putshort ( at -> name , nt . cur ) ;\n putshort ( at -> name , ( 3 + nt . cur * 6 ) * sizeof ( int16 ) ) ;\n for ( i = 0 ;\n i < nt . cur ;\n ++ i ) {\n putshort ( at -> name , nt . entries [ i ] . platform ) ;\n putshort ( at -> name , nt . entries [ i ] . specific ) ;\n putshort ( at -> name , nt . entries [ i ] . lang ) ;\n putshort ( at -> name , nt . entries [ i ] . strid ) ;\n putshort ( at -> name , nt . entries [ i ] . len ) ;\n putshort ( at -> name , nt . entries [ i ] . offset ) ;\n }\n if ( ! ttfcopyfile ( at -> name , nt . strings , ( 3 + nt . cur * 6 ) * sizeof ( int16 ) , \"name-data\" ) ) at -> error = true ;\n at -> namelen = ftell ( at -> name ) ;\n if ( ( at -> namelen & 3 ) != 0 ) for ( j = 4 - ( at -> namelen & 3 ) ;\n j > 0 ;\n -- j ) putc ( '\\0' , at -> name ) ;\n for ( i = 0 ;\n i < ttf_namemax ;\n ++ i ) if ( useng == NULL || dummy . names [ i ] != useng -> names [ i ] ) free ( dummy . names [ i ] ) ;\n free ( nt . entries ) ;\n free ( at -> feat_name ) ;\n }", "hash": -3740862514502467070, "project": "debian", "size": 91, "target": 0, "idx": 5689}
{"code": "static void redohhead ( struct alltabs * at , int isv ) {\n int i ;\n struct hhead * head ;\n FILE * f ;\n if ( ! isv ) {\n f = at -> hheadf = tmpfile ( ) ;\n head = & at -> hhead ;\n }\n else {\n f = at -> vheadf = tmpfile ( ) ;\n head = & at -> vhead ;\n }\n putlong ( f , head -> version ) ;\n putshort ( f , head -> ascender ) ;\n putshort ( f , head -> descender ) ;\n putshort ( f , head -> linegap ) ;\n putshort ( f , head -> maxwidth ) ;\n putshort ( f , head -> minlsb ) ;\n putshort ( f , head -> minrsb ) ;\n putshort ( f , head -> maxextent ) ;\n putshort ( f , head -> caretSlopeRise ) ;\n putshort ( f , head -> caretSlopeRun ) ;\n for ( i = 0 ;\n i < 5 ;\n ++ i ) putshort ( f , head -> mbz [ i ] ) ;\n putshort ( f , head -> metricformat ) ;\n putshort ( f , head -> numMetrics ) ;\n if ( ! isv ) {\n at -> hheadlen = ftell ( f ) ;\n if ( ( at -> hheadlen & 2 ) != 0 ) putshort ( f , 0 ) ;\n }\n else {\n at -> vheadlen = ftell ( f ) ;\n if ( ( at -> vheadlen & 2 ) != 0 ) putshort ( f , 0 ) ;\n }\n }", "hash": -3740862514502467070, "project": "debian", "size": 36, "target": 0, "idx": 5693}
{"code": "int AlreadyMSSymbolArea ( SplineFont * sf , EncMap * map ) {\n int i ;\n int acnt = 0 , pcnt = 0 ;\n for ( i = 0 ;\n i < map -> enccount && i < 0xffff ;\n ++ i ) {\n if ( map -> map [ i ] != - 1 && sf -> glyphs [ map -> map [ i ] ] != NULL && sf -> glyphs [ map -> map [ i ] ] -> ttf_glyph != - 1 ) {\n if ( i >= 0xf000 && i <= 0xf0ff ) ++ pcnt ;\n else if ( i >= 0x20 && i <= 0xff ) ++ acnt ;\n }\n }\n return ( pcnt > acnt ) ;\n }", "hash": -3740862514502467070, "project": "debian", "size": 13, "target": 0, "idx": 5694}
{"code": "static void dumptype42 ( FILE * type42 , struct alltabs * at , enum fontformat format ) {\n FILE * temp = tmpfile ( ) ;\n struct hexout hexout ;\n int i , length ;\n dumpttf ( temp , at ) ;\n rewind ( temp ) ;\n hexout . type42 = type42 ;\n hexout . bytesout = 0 ;\n qsort ( at -> tabdir . ordered , at -> tabdir . numtab , sizeof ( struct taboff * ) , tcomp2 ) ;\n dumphex ( & hexout , temp , at -> tabdir . ordered [ 0 ] -> offset ) ;\n for ( i = 0 ;\n i < at -> tabdir . numtab ;\n ++ i ) {\n if ( at -> tabdir . ordered [ i ] -> length > 65534 && at -> tabdir . ordered [ i ] -> tag == CHR ( 'g' , 'l' , 'y' , 'f' ) ) {\n uint32 last = 0 ;\n int j ;\n fseek ( temp , at -> tabdir . ordered [ i ] -> offset , SEEK_SET ) ;\n for ( j = 0 ;\n j < at -> maxp . numGlyphs ;\n ++ j ) {\n if ( at -> gi . loca [ j + 1 ] - last > 65534 ) {\n dumphex ( & hexout , temp , at -> gi . loca [ j ] - last ) ;\n last = at -> gi . loca [ j ] ;\n }\n }\n dumphex ( & hexout , temp , at -> gi . loca [ j ] - last ) ;\n }\n else {\n if ( i < at -> tabdir . numtab - 1 ) length = at -> tabdir . ordered [ i + 1 ] -> offset - at -> tabdir . ordered [ i ] -> offset ;\n else {\n fseek ( temp , 0 , SEEK_END ) ;\n length = ftell ( temp ) - at -> tabdir . ordered [ i ] -> offset ;\n }\n fseek ( temp , at -> tabdir . ordered [ i ] -> offset , SEEK_SET ) ;\n dumphex ( & hexout , temp , length ) ;\n }\n }\n fclose ( temp ) ;\n }", "hash": -3740862514502467070, "project": "debian", "size": 39, "target": 0, "idx": 5701}
{"code": "static void ATinit ( struct alltabs * at , SplineFont * sf , EncMap * map , int flags , int layer , enum fontformat format , enum bitmapformat bf , int * bsizes ) {\n at -> gi . flags = flags ;\n at -> gi . layer = layer ;\n at -> gi . is_ttf = format == ff_ttf || format == ff_ttfsym || format == ff_ttfmacbin || format == ff_ttfdfont ;\n at -> gi . sf = sf ;\n at -> applemode = ( flags & ttf_flag_applemode ) ? 1 : 0 ;\n at -> opentypemode = ( flags & ttf_flag_otmode ) ? 1 : 0 ;\n at -> msbitmaps = bsizes != NULL && at -> opentypemode ;\n at -> applebitmaps = bsizes != NULL && at -> applemode ;\n at -> gi . onlybitmaps = format == ff_none ;\n if ( bf == bf_sfnt_dfont ) {\n at -> msbitmaps = false ;\n at -> applebitmaps = true ;\n at -> opentypemode = false ;\n at -> gi . onlybitmaps = true ;\n }\n if ( bf == bf_sfnt_ms ) {\n at -> msbitmaps = true ;\n at -> applebitmaps = false ;\n at -> applemode = false ;\n at -> gi . onlybitmaps = true ;\n }\n if ( bf == bf_otb ) {\n at -> otbbitmaps = true ;\n at -> applebitmaps = at -> msbitmaps = false ;\n at -> applemode = false ;\n at -> gi . onlybitmaps = true ;\n }\n if ( bsizes != NULL && ! at -> applebitmaps && ! at -> otbbitmaps && ! at -> msbitmaps ) at -> msbitmaps = true ;\n at -> gi . bsizes = bsizes ;\n at -> gi . fixed_width = CIDOneWidth ( sf ) ;\n at -> isotf = format == ff_otf || format == ff_otfcid ;\n at -> format = format ;\n at -> next_strid = 256 ;\n if ( at -> applemode && sf -> mm != NULL && sf -> mm -> apple && ( format == ff_ttf || format == ff_ttfsym || format == ff_ttfmacbin || format == ff_ttfdfont ) && MMValid ( sf -> mm , false ) ) {\n at -> dovariations = true ;\n at -> gi . dovariations = true ;\n sf = sf -> mm -> normal ;\n }\n at -> sf = sf ;\n at -> map = map ;\n }", "hash": -3740862514502467070, "project": "debian", "size": 42, "target": 0, "idx": 5707}
{"code": "static unsigned int hashname ( const char * name ) {\n unsigned int hash = 0 ;\n while ( * name ) {\n unsigned int extra = ( hash >> 27 ) ;\n hash <<= 5 ;\n hash += * name & 0x1f ;\n hash ^= extra ;\n ++ name ;\n }\n return ( hash % 257 ) ;\n }", "hash": -3740862514502467070, "project": "debian", "size": 11, "target": 0, "idx": 5708}
{"code": "static void dumpcomposite ( SplineChar * sc , struct glyphinfo * gi ) {\n struct glyphhead gh ;\n DBounds bb ;\n int i , ptcnt , ctcnt , flags , sptcnt , rd ;\n SplineSet * ss ;\n RefChar * ref ;\n SplineChar * isc = sc -> ttf_instrs == NULL && sc -> parent -> mm != NULL && sc -> parent -> mm -> apple ? sc -> parent -> mm -> normal -> glyphs [ sc -> orig_pos ] : sc ;\n int arg1 , arg2 ;\n if ( gi -> next_glyph != sc -> ttf_glyph ) IError ( \"Glyph count wrong in ttf output\" ) ;\n if ( gi -> next_glyph >= gi -> maxp -> numGlyphs ) IError ( \"max glyph count wrong in ttf output\" ) ;\n gi -> loca [ gi -> next_glyph ] = ftell ( gi -> glyphs ) ;\n SplineCharLayerQuickBounds ( sc , gi -> layer , & bb ) ;\n gh . numContours = - 1 ;\n gh . xmin = floor ( bb . minx ) ;\n gh . ymin = floor ( bb . miny ) ;\n gh . xmax = ceil ( bb . maxx ) ;\n gh . ymax = ceil ( bb . maxy ) ;\n dumpghstruct ( gi , & gh ) ;\n i = ptcnt = ctcnt = 0 ;\n for ( ref = sc -> layers [ gi -> layer ] . refs ;\n ref != NULL ;\n ref = ref -> next , ++ i ) {\n if ( ref -> sc -> ttf_glyph == - 1 ) {\n continue ;\n }\n flags = 0 ;\n if ( ref -> round_translation_to_grid ) flags |= _ROUND ;\n if ( ref -> use_my_metrics ) flags |= _USE_MY_METRICS ;\n if ( ref -> next != NULL ) flags |= _MORE ;\n else if ( isc -> ttf_instrs_len != 0 ) flags |= _INSTR ;\n if ( ref -> transform [ 1 ] != 0 || ref -> transform [ 2 ] != 0 ) flags |= _MATRIX ;\n else if ( ref -> transform [ 0 ] != ref -> transform [ 3 ] ) flags |= _XY_SCALE ;\n else if ( ref -> transform [ 0 ] != 1. ) flags |= _SCALE ;\n if ( ref -> point_match ) {\n arg1 = ref -> match_pt_base ;\n arg2 = ref -> match_pt_ref ;\n }\n else {\n arg1 = rint ( ref -> transform [ 4 ] ) ;\n arg2 = rint ( ref -> transform [ 5 ] ) ;\n flags |= _ARGS_ARE_XY | _UNSCALED_OFFSETS ;\n }\n if ( arg1 < - 128 || arg1 > 127 || arg2 < - 128 || arg2 > 127 ) flags |= _ARGS_ARE_WORDS ;\n putshort ( gi -> glyphs , flags ) ;\n putshort ( gi -> glyphs , ref -> sc -> ttf_glyph == - 1 ? 0 : ref -> sc -> ttf_glyph ) ;\n if ( flags & _ARGS_ARE_WORDS ) {\n putshort ( gi -> glyphs , ( short ) arg1 ) ;\n putshort ( gi -> glyphs , ( short ) arg2 ) ;\n }\n else {\n putc ( ( char ) arg1 , gi -> glyphs ) ;\n putc ( ( char ) arg2 , gi -> glyphs ) ;\n }\n if ( flags & _MATRIX ) {\n put2d14 ( gi -> glyphs , ref -> transform [ 0 ] ) ;\n put2d14 ( gi -> glyphs , ref -> transform [ 1 ] ) ;\n put2d14 ( gi -> glyphs , ref -> transform [ 2 ] ) ;\n put2d14 ( gi -> glyphs , ref -> transform [ 3 ] ) ;\n }\n else if ( flags & _XY_SCALE ) {\n put2d14 ( gi -> glyphs , ref -> transform [ 0 ] ) ;\n put2d14 ( gi -> glyphs , ref -> transform [ 3 ] ) ;\n }\n else if ( flags & _SCALE ) {\n put2d14 ( gi -> glyphs , ref -> transform [ 0 ] ) ;\n }\n sptcnt = SSTtfNumberPoints ( ref -> layers [ 0 ] . splines ) ;\n for ( ss = ref -> layers [ 0 ] . splines ;\n ss != NULL ;\n ss = ss -> next ) {\n ++ ctcnt ;\n }\n if ( sc -> layers [ gi -> layer ] . order2 ) ptcnt += sptcnt ;\n else if ( ptcnt >= 0 && gi -> pointcounts [ ref -> sc -> ttf_glyph == - 1 ? 0 : ref -> sc -> ttf_glyph ] >= 0 ) ptcnt += gi -> pointcounts [ ref -> sc -> ttf_glyph == - 1 ? 0 : ref -> sc -> ttf_glyph ] ;\n else ptcnt = - 1 ;\n rd = RefDepth ( ref , gi -> layer ) ;\n if ( rd > gi -> maxp -> maxcomponentdepth ) gi -> maxp -> maxcomponentdepth = rd ;\n }\n if ( isc -> ttf_instrs_len != 0 ) dumpinstrs ( gi , isc -> ttf_instrs , isc -> ttf_instrs_len ) ;\n gi -> pointcounts [ gi -> next_glyph ++ ] = ptcnt ;\n if ( gi -> maxp -> maxnumcomponents < i ) gi -> maxp -> maxnumcomponents = i ;\n if ( gi -> maxp -> maxCompositPts < ptcnt ) gi -> maxp -> maxCompositPts = ptcnt ;\n if ( gi -> maxp -> maxCompositCtrs < ctcnt ) gi -> maxp -> maxCompositCtrs = ctcnt ;\n ttfdumpmetrics ( sc , gi , & bb ) ;\n if ( ftell ( gi -> glyphs ) & 1 ) putc ( '\\0' , gi -> glyphs ) ;\n }", "hash": -3740862514502467070, "project": "debian", "size": 86, "target": 0, "idx": 5714}
{"code": "static void HintsRenumber ( SplineChar * sc ) {\n int mapping [ 96 ] ;\n int i , max ;\n StemInfo * h ;\n SplineSet * spl ;\n SplinePoint * sp ;\n for ( i = 0 ;\n i < 96 ;\n ++ i ) mapping [ i ] = i ;\n i = 0 ;\n for ( h = sc -> hstem ;\n h != NULL ;\n h = h -> next ) {\n if ( h -> hintnumber < 96 && i < 96 ) {\n mapping [ h -> hintnumber ] = i ;\n h -> hintnumber = i ++ ;\n }\n chunkfree ( h -> u . unblended , sizeof ( real [ 2 ] [ MmMax ] ) ) ;\n h -> u . unblended = NULL ;\n }\n for ( h = sc -> vstem ;\n h != NULL ;\n h = h -> next ) {\n if ( h -> hintnumber < 96 && i < 96 ) {\n mapping [ h -> hintnumber ] = i ;\n h -> hintnumber = i ++ ;\n }\n chunkfree ( h -> u . unblended , sizeof ( real [ 2 ] [ MmMax ] ) ) ;\n h -> u . unblended = NULL ;\n }\n max = i ;\n for ( i = 0 ;\n i < max ;\n ++ i ) if ( mapping [ i ] != i ) break ;\n if ( i == max ) return ;\n for ( i = 0 ;\n i < sc -> countermask_cnt ;\n ++ i ) RemapHintMask ( & sc -> countermasks [ i ] , mapping , max ) ;\n for ( spl = sc -> layers [ ly_fore ] . splines ;\n spl != NULL ;\n spl = spl -> next ) {\n for ( sp = spl -> first ;\n ;\n ) {\n RemapHintMask ( sp -> hintmask , mapping , max ) ;\n if ( sp -> next == NULL ) break ;\n sp = sp -> next -> to ;\n if ( sp == spl -> first ) break ;\n }\n }\n }", "hash": 8947170728280515149, "project": "debian", "size": 51, "target": 0, "idx": 5733}
{"code": "void EntityDefaultStrokeFill ( Entity * ent ) {\n while ( ent != NULL ) {\n if ( ent -> type == et_splines && ent -> u . splines . stroke . col == 0xffffffff && ent -> u . splines . fill . col == 0xffffffff ) {\n SplineSet * spl ;\n int all = 1 ;\n for ( spl = ent -> u . splines . splines ;\n spl != NULL ;\n spl = spl -> next ) if ( spl -> first -> prev != NULL ) {\n all = false ;\n break ;\n }\n if ( all && ent -> u . splines . splines != NULL && ( ent -> u . splines . stroke_width == 0 || ent -> u . splines . stroke_width == WIDTH_INHERITED ) ) ent -> u . splines . stroke_width = 40 ;\n if ( ent -> u . splines . stroke_width == 0 || ent -> u . splines . stroke_width == WIDTH_INHERITED ) ent -> u . splines . fill . col = COLOR_INHERITED ;\n else ent -> u . splines . stroke . col = COLOR_INHERITED ;\n }\n ent = ent -> next ;\n }\n }", "hash": 8947170728280515149, "project": "debian", "size": 18, "target": 0, "idx": 5759}
{"code": "int UnblendedCompare ( real u1 [ MmMax ] , real u2 [ MmMax ] , int cnt ) {\n int i ;\n for ( i = 0 ;\n i < cnt ;\n ++ i ) {\n if ( u1 [ i ] != u2 [ i ] ) return ( u1 [ i ] > u2 [ i ] ? 1 : - 1 ) ;\n }\n return ( 0 ) ;\n }", "hash": 8947170728280515149, "project": "debian", "size": 9, "target": 0, "idx": 5763}
{"code": "static void AddTok ( GrowBuf * gb , char * buf , int islit ) {\n if ( islit ) GrowBufferAdd ( gb , '/' ) ;\n GrowBufferAddStr ( gb , buf ) ;\n GrowBufferAdd ( gb , ' ' ) ;\n }", "hash": 8947170728280515149, "project": "debian", "size": 5, "target": 0, "idx": 5767}
{"code": "static void CheckMake ( SplinePoint * from , SplinePoint * to ) {\n CheckMakeB ( & from -> me , NULL ) ;\n CheckMakeB ( & from -> nextcp , & from -> me ) ;\n CheckMakeB ( & to -> prevcp , & from -> nextcp ) ;\n CheckMakeB ( & to -> me , & to -> prevcp ) ;\n }", "hash": 8947170728280515149, "project": "debian", "size": 6, "target": 0, "idx": 5768}
{"code": "static void Transform ( BasePoint * to , DBasePoint * from , real trans [ 6 ] ) {\n to -> x = trans [ 0 ] * from -> x + trans [ 2 ] * from -> y + trans [ 4 ] ;\n to -> y = trans [ 1 ] * from -> x + trans [ 3 ] * from -> y + trans [ 5 ] ;\n }", "hash": 8947170728280515149, "project": "debian", "size": 4, "target": 0, "idx": 5772}
{"code": "Entity * EntityInterpretPS ( FILE * ps , int * width ) {\n EntityChar ec ;\n memset ( & ec , '\\0' , sizeof ( ec ) ) ;\n ec . width = ec . vwidth = UNDEFINED_WIDTH ;\n InterpretPS ( ps , NULL , & ec , NULL ) ;\n if ( width != NULL ) * width = ec . width ;\n return ( ec . splines ) ;\n }", "hash": 8947170728280515149, "project": "debian", "size": 8, "target": 0, "idx": 5773}
{"code": "Encoding * PSSlurpEncodings ( FILE * file ) {\n char * names [ 1024 ] ;\n int32 encs [ 1024 ] ;\n Encoding * item , * head = NULL , * last ;\n char * encname ;\n char tokbuf [ 200 ] ;\n IO wrapper ;\n real dval ;\n size_t i , any ;\n int max , enc , codepointsonly , tok ;\n wrapper . top = NULL ;\n wrapper . advance_width = UNDEFINED_WIDTH ;\n pushio ( & wrapper , file , NULL , 0 ) ;\n while ( ( tok = nextpstoken ( & wrapper , & dval , tokbuf , sizeof ( tokbuf ) ) ) != pt_eof ) {\n encname = NULL ;\n if ( tok == pt_namelit ) {\n encname = copy ( tokbuf ) ;\n tok = nextpstoken ( & wrapper , & dval , tokbuf , sizeof ( tokbuf ) ) ;\n }\n if ( tok != pt_openarray && tok != pt_opencurly ) return ( head ) ;\n for ( i = 0 ;\n i < sizeof ( names ) / sizeof ( names [ 0 ] ) ;\n ++ i ) {\n encs [ i ] = - 1 ;\n names [ i ] = NULL ;\n }\n codepointsonly = CheckCodePointsComment ( & wrapper ) ;\n max = - 1 ;\n any = 0 ;\n for ( i = 0 ;\n ( tok = nextpstoken ( & wrapper , & dval , tokbuf , sizeof ( tokbuf ) ) ) != pt_eof && tok != pt_closearray && tok != pt_closecurly ;\n i ++ ) {\n if ( tok == pt_namelit && i < sizeof ( names ) / sizeof ( names [ 0 ] ) ) {\n max = i ;\n if ( strcmp ( tokbuf , \".notdef\" ) == 0 ) {\n encs [ i ] = - 1 ;\n }\n else if ( ( enc = UniFromName ( tokbuf , ui_none , & custom ) ) != - 1 ) {\n encs [ i ] = enc ;\n names [ i ] = copy ( tokbuf ) ;\n any = 1 ;\n }\n else {\n names [ i ] = copy ( tokbuf ) ;\n any = 1 ;\n }\n }\n }\n if ( encname != NULL ) {\n tok = nextpstoken ( & wrapper , & dval , tokbuf , sizeof ( tokbuf ) ) ;\n if ( tok == pt_def ) {\n }\n else {\n }\n }\n if ( max != - 1 ) {\n if ( ++ max < 256 ) max = 256 ;\n item = calloc ( 1 , sizeof ( Encoding ) ) ;\n item -> enc_name = encname ;\n item -> char_cnt = max ;\n item -> unicode = malloc ( max * sizeof ( int32 ) ) ;\n memcpy ( item -> unicode , encs , max * sizeof ( int32 ) ) ;\n if ( any && ! codepointsonly ) {\n item -> psnames = calloc ( max , sizeof ( char * ) ) ;\n memcpy ( item -> psnames , names , max * sizeof ( char * ) ) ;\n }\n else {\n for ( i = 0 ;\n i < max ;\n ++ i ) free ( names [ i ] ) ;\n }\n if ( head == NULL ) head = item ;\n else last -> next = item ;\n last = item ;\n }\n }\n return ( head ) ;\n }", "hash": 8947170728280515149, "project": "debian", "size": 78, "target": 0, "idx": 5783}
{"code": "static struct pskeyval * lookup ( struct pskeydict * dict , char * tokbuf ) {\n int i ;\n for ( i = 0 ;\n i < dict -> cnt ;\n ++ i ) if ( strcmp ( dict -> entries [ i ] . key , tokbuf ) == 0 ) return ( & dict -> entries [ i ] ) ;\n return ( NULL ) ;\n }", "hash": 8947170728280515149, "project": "debian", "size": 7, "target": 0, "idx": 5787}
{"code": "static int xhci_xfer_create_sgl ( XHCITransfer * xfer , int in_xfer ) {\n XHCIState * xhci = xfer -> epctx -> xhci ;\n int i ;\n xfer -> int_req = false ;\n pci_dma_sglist_init ( & xfer -> sgl , PCI_DEVICE ( xhci ) , xfer -> trb_count ) ;\n for ( i = 0 ;\n i < xfer -> trb_count ;\n i ++ ) {\n XHCITRB * trb = & xfer -> trbs [ i ] ;\n dma_addr_t addr ;\n unsigned int chunk = 0 ;\n if ( trb -> control & TRB_TR_IOC ) {\n xfer -> int_req = true ;\n }\n switch ( TRB_TYPE ( * trb ) ) {\n case TR_DATA : if ( ( ! ( trb -> control & TRB_TR_DIR ) ) != ( ! in_xfer ) ) {\n DPRINTF ( \"xhci: data direction mismatch for TR_DATA\\n\" ) ;\n goto err ;\n }\n case TR_NORMAL : case TR_ISOCH : addr = xhci_mask64 ( trb -> parameter ) ;\n chunk = trb -> status & 0x1ffff ;\n if ( trb -> control & TRB_TR_IDT ) {\n if ( chunk > 8 || in_xfer ) {\n DPRINTF ( \"xhci: invalid immediate data TRB\\n\" ) ;\n goto err ;\n }\n qemu_sglist_add ( & xfer -> sgl , trb -> addr , chunk ) ;\n }\n else {\n qemu_sglist_add ( & xfer -> sgl , addr , chunk ) ;\n }\n break ;\n }\n }\n return 0 ;\n err : qemu_sglist_destroy ( & xfer -> sgl ) ;\n xhci_die ( xhci ) ;\n return - 1 ;\n }", "hash": 6393050609822897742, "project": "debian", "size": 39, "target": 0, "idx": 5797}
{"code": "static void xhci_port_notify ( XHCIPort * port , uint32_t bits ) {\n XHCIEvent ev = {\n ER_PORT_STATUS_CHANGE , CC_SUCCESS , port -> portnr << 24 }\n ;\n if ( ( port -> portsc & bits ) == bits ) {\n return ;\n }\n trace_usb_xhci_port_notify ( port -> portnr , bits ) ;\n port -> portsc |= bits ;\n if ( ! xhci_running ( port -> xhci ) ) {\n return ;\n }\n xhci_event ( port -> xhci , & ev , 0 ) ;\n }", "hash": 6393050609822897742, "project": "debian", "size": 14, "target": 0, "idx": 5803}
{"code": "static inline int xhci_running ( XHCIState * xhci ) {\n return ! ( xhci -> usbsts & USBSTS_HCH ) && ! xhci -> intr [ 0 ] . er_full ;\n }", "hash": 6393050609822897742, "project": "debian", "size": 3, "target": 0, "idx": 5807}
{"code": "static uint64_t xhci_doorbell_read ( void * ptr , hwaddr reg , unsigned size ) {\n trace_usb_xhci_doorbell_read ( reg , 0 ) ;\n return 0 ;\n }", "hash": 6393050609822897742, "project": "debian", "size": 4, "target": 0, "idx": 5814}
{"code": "static bool xhci_er_full ( void * opaque , int version_id ) {\n struct XHCIInterrupter * intr = opaque ;\n return intr -> er_full ;\n }", "hash": 6393050609822897742, "project": "debian", "size": 4, "target": 0, "idx": 5818}
{"code": "static int xhci_try_complete_packet ( XHCITransfer * xfer ) {\n if ( xfer -> packet . status == USB_RET_ASYNC ) {\n trace_usb_xhci_xfer_async ( xfer ) ;\n xfer -> running_async = 1 ;\n xfer -> running_retry = 0 ;\n xfer -> complete = 0 ;\n return 0 ;\n }\n else if ( xfer -> packet . status == USB_RET_NAK ) {\n trace_usb_xhci_xfer_nak ( xfer ) ;\n xfer -> running_async = 0 ;\n xfer -> running_retry = 1 ;\n xfer -> complete = 0 ;\n return 0 ;\n }\n else {\n xfer -> running_async = 0 ;\n xfer -> running_retry = 0 ;\n xfer -> complete = 1 ;\n xhci_xfer_unmap ( xfer ) ;\n }\n if ( xfer -> packet . status == USB_RET_SUCCESS ) {\n trace_usb_xhci_xfer_success ( xfer , xfer -> packet . actual_length ) ;\n xfer -> status = CC_SUCCESS ;\n xhci_xfer_report ( xfer ) ;\n return 0 ;\n }\n trace_usb_xhci_xfer_error ( xfer , xfer -> packet . status ) ;\n switch ( xfer -> packet . status ) {\n case USB_RET_NODEV : case USB_RET_IOERROR : xfer -> status = CC_USB_TRANSACTION_ERROR ;\n xhci_xfer_report ( xfer ) ;\n xhci_stall_ep ( xfer ) ;\n break ;\n case USB_RET_STALL : xfer -> status = CC_STALL_ERROR ;\n xhci_xfer_report ( xfer ) ;\n xhci_stall_ep ( xfer ) ;\n break ;\n case USB_RET_BABBLE : xfer -> status = CC_BABBLE_DETECTED ;\n xhci_xfer_report ( xfer ) ;\n xhci_stall_ep ( xfer ) ;\n break ;\n default : DPRINTF ( \"%s: FIXME: status = %d\\n\" , __func__ , xfer -> packet . status ) ;\n FIXME ( \"unhandled USB_RET_*\" ) ;\n }\n return 0 ;\n }", "hash": 6393050609822897742, "project": "debian", "size": 46, "target": 0, "idx": 5860}
{"code": "static void xhci_doorbell_write ( void * ptr , hwaddr reg , uint64_t val , unsigned size ) {\n XHCIState * xhci = ptr ;\n unsigned int epid , streamid ;\n trace_usb_xhci_doorbell_write ( reg , val ) ;\n if ( ! xhci_running ( xhci ) ) {\n DPRINTF ( \"xhci: wrote doorbell while xHC stopped or paused\\n\" ) ;\n return ;\n }\n reg >>= 2 ;\n if ( reg == 0 ) {\n if ( val == 0 ) {\n xhci_process_commands ( xhci ) ;\n }\n else {\n DPRINTF ( \"xhci: bad doorbell 0 write: 0x%x\\n\" , ( uint32_t ) val ) ;\n }\n }\n else {\n epid = val & 0xff ;\n streamid = ( val >> 16 ) & 0xffff ;\n if ( reg > xhci -> numslots ) {\n DPRINTF ( \"xhci: bad doorbell %d\\n\" , ( int ) reg ) ;\n }\n else if ( epid > 31 ) {\n DPRINTF ( \"xhci: bad doorbell %d write: 0x%x\\n\" , ( int ) reg , ( uint32_t ) val ) ;\n }\n else {\n xhci_kick_ep ( xhci , reg , epid , streamid ) ;\n }\n }\n }", "hash": 6393050609822897742, "project": "debian", "size": 31, "target": 0, "idx": 5870}
{"code": "static int xhci_fire_ctl_transfer ( XHCIState * xhci , XHCITransfer * xfer ) {\n XHCITRB * trb_setup , * trb_status ;\n uint8_t bmRequestType ;\n trb_setup = & xfer -> trbs [ 0 ] ;\n trb_status = & xfer -> trbs [ xfer -> trb_count - 1 ] ;\n trace_usb_xhci_xfer_start ( xfer , xfer -> epctx -> slotid , xfer -> epctx -> epid , xfer -> streamid ) ;\n if ( TRB_TYPE ( * trb_status ) == TR_EVDATA && xfer -> trb_count > 2 ) {\n trb_status -- ;\n }\n if ( TRB_TYPE ( * trb_setup ) != TR_SETUP ) {\n DPRINTF ( \"xhci: ep0 first TD not SETUP: %d\\n\" , TRB_TYPE ( * trb_setup ) ) ;\n return - 1 ;\n }\n if ( TRB_TYPE ( * trb_status ) != TR_STATUS ) {\n DPRINTF ( \"xhci: ep0 last TD not STATUS: %d\\n\" , TRB_TYPE ( * trb_status ) ) ;\n return - 1 ;\n }\n if ( ! ( trb_setup -> control & TRB_TR_IDT ) ) {\n DPRINTF ( \"xhci: Setup TRB doesn't have IDT set\\n\" ) ;\n return - 1 ;\n }\n if ( ( trb_setup -> status & 0x1ffff ) != 8 ) {\n DPRINTF ( \"xhci: Setup TRB has bad length (%d)\\n\" , ( trb_setup -> status & 0x1ffff ) ) ;\n return - 1 ;\n }\n bmRequestType = trb_setup -> parameter ;\n xfer -> in_xfer = bmRequestType & USB_DIR_IN ;\n xfer -> iso_xfer = false ;\n xfer -> timed_xfer = false ;\n if ( xhci_setup_packet ( xfer ) < 0 ) {\n return - 1 ;\n }\n xfer -> packet . parameter = trb_setup -> parameter ;\n usb_handle_packet ( xfer -> packet . ep -> dev , & xfer -> packet ) ;\n xhci_try_complete_packet ( xfer ) ;\n return 0 ;\n }", "hash": 6393050609822897742, "project": "debian", "size": 37, "target": 0, "idx": 5872}
{"code": "static void xhci_msix_update ( XHCIState * xhci , int v ) {\n PCIDevice * pci_dev = PCI_DEVICE ( xhci ) ;\n bool enabled ;\n if ( ! msix_enabled ( pci_dev ) ) {\n return ;\n }\n enabled = xhci -> intr [ v ] . iman & IMAN_IE ;\n if ( enabled == xhci -> intr [ v ] . msix_used ) {\n return ;\n }\n if ( enabled ) {\n trace_usb_xhci_irq_msix_use ( v ) ;\n msix_vector_use ( pci_dev , v ) ;\n xhci -> intr [ v ] . msix_used = true ;\n }\n else {\n trace_usb_xhci_irq_msix_unuse ( v ) ;\n msix_vector_unuse ( pci_dev , v ) ;\n xhci -> intr [ v ] . msix_used = false ;\n }\n }", "hash": 6393050609822897742, "project": "debian", "size": 21, "target": 0, "idx": 5874}
{"code": "static inline dma_addr_t xhci_addr64 ( uint32_t low , uint32_t high ) {\n if ( sizeof ( dma_addr_t ) == 4 ) {\n return low ;\n }\n else {\n return low | ( ( ( dma_addr_t ) high << 16 ) << 16 ) ;\n }\n }", "hash": 6393050609822897742, "project": "debian", "size": 8, "target": 0, "idx": 5877}
{"code": "static XHCIStreamContext * xhci_find_stream ( XHCIEPContext * epctx , unsigned int streamid , uint32_t * cc_error ) {\n XHCIStreamContext * sctx ;\n dma_addr_t base ;\n uint32_t ctx [ 2 ] , sct ;\n assert ( streamid != 0 ) ;\n if ( epctx -> lsa ) {\n if ( streamid >= epctx -> nr_pstreams ) {\n * cc_error = CC_INVALID_STREAM_ID_ERROR ;\n return NULL ;\n }\n sctx = epctx -> pstreams + streamid ;\n }\n else {\n FIXME ( \"secondary streams not implemented yet\" ) ;\n }\n if ( sctx -> sct == - 1 ) {\n xhci_dma_read_u32s ( epctx -> xhci , sctx -> pctx , ctx , sizeof ( ctx ) ) ;\n sct = ( ctx [ 0 ] >> 1 ) & 0x07 ;\n if ( epctx -> lsa && sct != 1 ) {\n * cc_error = CC_INVALID_STREAM_TYPE_ERROR ;\n return NULL ;\n }\n sctx -> sct = sct ;\n base = xhci_addr64 ( ctx [ 0 ] & ~ 0xf , ctx [ 1 ] ) ;\n xhci_ring_init ( epctx -> xhci , & sctx -> ring , base ) ;\n }\n return sctx ;\n }", "hash": 6393050609822897742, "project": "debian", "size": 28, "target": 0, "idx": 5885}
{"code": "static inline int ipv6_addr_scope ( const struct in6_addr * addr ) {\n return __ipv6_addr_type ( addr ) & IPV6_ADDR_SCOPE_MASK ;\n }", "hash": -9032389459913766398, "project": "debian", "size": 3, "target": 0, "idx": 5901}
{"code": "static inline u32 ipv6_addr_hash ( const struct in6_addr * a ) {\n # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) && BITS_PER_LONG == 64 const unsigned long * ul = ( const unsigned long * ) a ;\n unsigned long x = ul [ 0 ] ^ ul [ 1 ] ;\n return ( u32 ) ( x ^ ( x >> 32 ) ) ;\n # else return ( __force u32 ) ( a -> s6_addr32 [ 0 ] ^ a -> s6_addr32 [ 1 ] ^ a -> s6_addr32 [ 2 ] ^ a -> s6_addr32 [ 3 ] ) ;\n # endif }", "hash": -9032389459913766398, "project": "debian", "size": 6, "target": 0, "idx": 5913}
{"code": "static char * purple_get_account_prpl_id ( account_t * acc ) {\n if ( g_strcmp0 ( acc -> prpl -> name , \"oscar\" ) == 0 ) {\n return ( g_ascii_isdigit ( acc -> user [ 0 ] ) ) ? \"prpl-icq\" : \"prpl-aim\" ;\n }\n return acc -> prpl -> data ;\n }", "hash": 9176142195250515812, "project": "debian", "size": 6, "target": 0, "idx": 5922}
{"code": "static void prplcb_conn_disconnected ( PurpleConnection * gc ) {\n struct im_connection * ic = purple_ic_by_gc ( gc ) ;\n if ( ic != NULL ) {\n imc_logout ( ic , ! gc -> wants_to_die ) ;\n }\n }", "hash": 9176142195250515812, "project": "debian", "size": 6, "target": 0, "idx": 5944}
{"code": "static void prplcb_privacy_deny_removed ( PurpleAccount * account , const char * name ) {\n struct im_connection * ic = purple_ic_by_pa ( account ) ;\n void * n ;\n n = g_slist_find_custom ( ic -> deny , name , ( GCompareFunc ) ic -> acc -> prpl -> handle_cmp ) ;\n ic -> deny = g_slist_remove ( ic -> deny , n ) ;\n }", "hash": 9176142195250515812, "project": "debian", "size": 6, "target": 0, "idx": 5946}
{"code": "static void prplcb_conn_progress ( PurpleConnection * gc , const char * text , size_t step , size_t step_count ) {\n struct im_connection * ic = purple_ic_by_gc ( gc ) ;\n imcb_log ( ic , \"%s\" , text ) ;\n }", "hash": 9176142195250515812, "project": "debian", "size": 4, "target": 0, "idx": 5955}
{"code": "static void handle_conv_msg ( PurpleConversation * conv , const char * who , const char * message_ , guint32 bee_flags , time_t mtime ) {\n struct im_connection * ic = purple_ic_by_pa ( conv -> account ) ;\n struct groupchat * gc = conv -> ui_data ;\n char * message = g_strdup ( message_ ) ;\n PurpleBuddy * buddy ;\n buddy = purple_find_buddy ( conv -> account , who ) ;\n if ( buddy != NULL ) {\n who = purple_buddy_get_name ( buddy ) ;\n }\n if ( conv -> type == PURPLE_CONV_TYPE_IM ) {\n imcb_buddy_msg ( ic , who , message , bee_flags , mtime ) ;\n }\n else if ( gc ) {\n imcb_chat_msg ( gc , who , message , bee_flags , mtime ) ;\n }\n g_free ( message ) ;\n }", "hash": 9176142195250515812, "project": "debian", "size": 17, "target": 0, "idx": 5956}
{"code": "static void prplcb_request_action_free ( void * data ) {\n struct prplcb_request_action_data * pqad = data ;\n pqad -> bee_data = NULL ;\n purple_request_close ( PURPLE_REQUEST_ACTION , pqad ) ;\n }", "hash": 9176142195250515812, "project": "debian", "size": 5, "target": 0, "idx": 5964}
{"code": "static GList * purple_away_states ( struct im_connection * ic ) {\n struct purple_data * pd = ic -> proto_data ;\n GList * st , * ret = NULL ;\n for ( st = purple_account_get_status_types ( pd -> account ) ;\n st ;\n st = st -> next ) {\n PurpleStatusPrimitive prim = purple_status_type_get_primitive ( st -> data ) ;\n if ( prim != PURPLE_STATUS_AVAILABLE && prim != PURPLE_STATUS_OFFLINE ) {\n ret = g_list_append ( ret , ( void * ) purple_status_type_get_name ( st -> data ) ) ;\n }\n }\n return ret ;\n }", "hash": 9176142195250515812, "project": "debian", "size": 13, "target": 0, "idx": 5971}
{"code": "int av_lzo1x_decode ( void * out , int * outlen , const void * in , int * inlen ) {\n int state = 0 ;\n int x ;\n LZOContext c ;\n if ( ! * outlen || ! * inlen ) {\n int res = 0 ;\n if ( ! * outlen ) res |= AV_LZO_OUTPUT_FULL ;\n if ( ! * inlen ) res |= AV_LZO_INPUT_DEPLETED ;\n return res ;\n }\n c . in = in ;\n c . in_end = ( const uint8_t * ) in + * inlen ;\n c . out = c . out_start = out ;\n c . out_end = ( uint8_t * ) out + * outlen ;\n c . error = 0 ;\n x = GETB ( c ) ;\n if ( x > 17 ) {\n copy ( & c , x - 17 ) ;\n x = GETB ( c ) ;\n if ( x < 16 ) c . error |= AV_LZO_ERROR ;\n }\n if ( c . in > c . in_end ) c . error |= AV_LZO_INPUT_DEPLETED ;\n while ( ! c . error ) {\n int cnt , back ;\n if ( x > 15 ) {\n if ( x > 63 ) {\n cnt = ( x >> 5 ) - 1 ;\n back = ( GETB ( c ) << 3 ) + ( ( x >> 2 ) & 7 ) + 1 ;\n }\n else if ( x > 31 ) {\n cnt = get_len ( & c , x , 31 ) ;\n x = GETB ( c ) ;\n back = ( GETB ( c ) << 6 ) + ( x >> 2 ) + 1 ;\n }\n else {\n cnt = get_len ( & c , x , 7 ) ;\n back = ( 1 << 14 ) + ( ( x & 8 ) << 11 ) ;\n x = GETB ( c ) ;\n back += ( GETB ( c ) << 6 ) + ( x >> 2 ) ;\n if ( back == ( 1 << 14 ) ) {\n if ( cnt != 1 ) c . error |= AV_LZO_ERROR ;\n break ;\n }\n }\n }\n else if ( ! state ) {\n cnt = get_len ( & c , x , 15 ) ;\n copy ( & c , cnt + 3 ) ;\n x = GETB ( c ) ;\n if ( x > 15 ) continue ;\n cnt = 1 ;\n back = ( 1 << 11 ) + ( GETB ( c ) << 2 ) + ( x >> 2 ) + 1 ;\n }\n else {\n cnt = 0 ;\n back = ( GETB ( c ) << 2 ) + ( x >> 2 ) + 1 ;\n }\n copy_backptr ( & c , back , cnt + 2 ) ;\n state = cnt = x & 3 ;\n copy ( & c , cnt ) ;\n x = GETB ( c ) ;\n }\n * inlen = c . in_end - c . in ;\n if ( c . in > c . in_end ) * inlen = 0 ;\n * outlen = c . out_end - c . out ;\n return c . error ;\n }", "hash": 179698602413630959, "project": "debian", "size": 67, "target": 0, "idx": 6014}
{"code": "static int dwt_plane ( AVCodecContext * avctx , void * arg ) {\n TransformArgs * transform_dat = arg ;\n VC2EncContext * s = transform_dat -> ctx ;\n const void * frame_data = transform_dat -> idata ;\n const ptrdiff_t linesize = transform_dat -> istride ;\n const int field = transform_dat -> field ;\n const Plane * p = transform_dat -> plane ;\n VC2TransformContext * t = & transform_dat -> t ;\n dwtcoef * buf = p -> coef_buf ;\n const int idx = s -> wavelet_idx ;\n const int skip = 1 + s -> interlaced ;\n int x , y , level , offset ;\n ptrdiff_t pix_stride = linesize >> ( s -> bpp - 1 ) ;\n if ( field == 1 ) {\n offset = 0 ;\n pix_stride <<= 1 ;\n }\n else if ( field == 2 ) {\n offset = pix_stride ;\n pix_stride <<= 1 ;\n }\n else {\n offset = 0 ;\n }\n if ( s -> bpp == 1 ) {\n const uint8_t * pix = ( const uint8_t * ) frame_data + offset ;\n for ( y = 0 ;\n y < p -> height * skip ;\n y += skip ) {\n for ( x = 0 ;\n x < p -> width ;\n x ++ ) {\n buf [ x ] = pix [ x ] - s -> diff_offset ;\n }\n buf += p -> coef_stride ;\n pix += pix_stride ;\n }\n }\n else {\n const uint16_t * pix = ( const uint16_t * ) frame_data + offset ;\n for ( y = 0 ;\n y < p -> height * skip ;\n y += skip ) {\n for ( x = 0 ;\n x < p -> width ;\n x ++ ) {\n buf [ x ] = pix [ x ] - s -> diff_offset ;\n }\n buf += p -> coef_stride ;\n pix += pix_stride ;\n }\n }\n memset ( buf , 0 , p -> coef_stride * ( p -> dwt_height - p -> height ) * sizeof ( dwtcoef ) ) ;\n for ( level = s -> wavelet_depth - 1 ;\n level >= 0 ;\n level -- ) {\n const SubBand * b = & p -> band [ level ] [ 0 ] ;\n t -> vc2_subband_dwt [ idx ] ( t , p -> coef_buf , p -> coef_stride , b -> width , b -> height ) ;\n }\n return 0 ;\n }", "hash": -7253276028511611170, "project": "debian", "size": 61, "target": 0, "idx": 6027}
{"code": "static int encode_hq_slice ( AVCodecContext * avctx , void * arg ) {\n SliceArgs * slice_dat = arg ;\n VC2EncContext * s = slice_dat -> ctx ;\n PutBitContext * pb = & slice_dat -> pb ;\n const int slice_x = slice_dat -> x ;\n const int slice_y = slice_dat -> y ;\n const int quant_idx = slice_dat -> quant_idx ;\n const int slice_bytes_max = slice_dat -> bytes ;\n uint8_t quants [ MAX_DWT_LEVELS ] [ 4 ] ;\n int p , level , orientation ;\n memset ( put_bits_ptr ( pb ) , 0 , s -> prefix_bytes ) ;\n skip_put_bytes ( pb , s -> prefix_bytes ) ;\n put_bits ( pb , 8 , quant_idx ) ;\n for ( level = 0 ;\n level < s -> wavelet_depth ;\n level ++ ) for ( orientation = ! ! level ;\n orientation < 4 ;\n orientation ++ ) quants [ level ] [ orientation ] = FFMAX ( quant_idx - s -> quant [ level ] [ orientation ] , 0 ) ;\n for ( p = 0 ;\n p < 3 ;\n p ++ ) {\n int bytes_start , bytes_len , pad_s , pad_c ;\n bytes_start = put_bits_count ( pb ) >> 3 ;\n put_bits ( pb , 8 , 0 ) ;\n for ( level = 0 ;\n level < s -> wavelet_depth ;\n level ++ ) {\n for ( orientation = ! ! level ;\n orientation < 4 ;\n orientation ++ ) {\n encode_subband ( s , pb , slice_x , slice_y , & s -> plane [ p ] . band [ level ] [ orientation ] , quants [ level ] [ orientation ] ) ;\n }\n }\n avpriv_align_put_bits ( pb ) ;\n bytes_len = ( put_bits_count ( pb ) >> 3 ) - bytes_start - 1 ;\n if ( p == 2 ) {\n int len_diff = slice_bytes_max - ( put_bits_count ( pb ) >> 3 ) ;\n pad_s = FFALIGN ( ( bytes_len + len_diff ) , s -> size_scaler ) / s -> size_scaler ;\n pad_c = ( pad_s * s -> size_scaler ) - bytes_len ;\n }\n else {\n pad_s = FFALIGN ( bytes_len , s -> size_scaler ) / s -> size_scaler ;\n pad_c = ( pad_s * s -> size_scaler ) - bytes_len ;\n }\n pb -> buf [ bytes_start ] = pad_s ;\n flush_put_bits ( pb ) ;\n memset ( put_bits_ptr ( pb ) , 0xFF , pad_c ) ;\n skip_put_bytes ( pb , pad_c ) ;\n }\n return 0 ;\n }", "hash": -7253276028511611170, "project": "debian", "size": 51, "target": 0, "idx": 6031}
{"code": "static void encode_sample_fmt ( VC2EncContext * s ) {\n put_bits ( & s -> pb , 1 , ! s -> strict_compliance ) ;\n if ( ! s -> strict_compliance ) {\n int idx ;\n if ( s -> chroma_x_shift == 1 && s -> chroma_y_shift == 0 ) idx = 1 ;\n else if ( s -> chroma_x_shift == 1 && s -> chroma_y_shift == 1 ) idx = 2 ;\n else idx = 0 ;\n put_vc2_ue_uint ( & s -> pb , idx ) ;\n }\n }", "hash": -7253276028511611170, "project": "debian", "size": 10, "target": 0, "idx": 6037}
{"code": "static void encode_seq_header ( VC2EncContext * s ) {\n avpriv_align_put_bits ( & s -> pb ) ;\n encode_parse_params ( s ) ;\n put_vc2_ue_uint ( & s -> pb , s -> base_vf ) ;\n encode_source_params ( s ) ;\n put_vc2_ue_uint ( & s -> pb , s -> interlaced ) ;\n }", "hash": -7253276028511611170, "project": "debian", "size": 7, "target": 0, "idx": 6038}
{"code": "static void encode_quant_matrix ( VC2EncContext * s ) {\n int level ;\n put_bits ( & s -> pb , 1 , s -> custom_quant_matrix ) ;\n if ( s -> custom_quant_matrix ) {\n put_vc2_ue_uint ( & s -> pb , s -> quant [ 0 ] [ 0 ] ) ;\n for ( level = 0 ;\n level < s -> wavelet_depth ;\n level ++ ) {\n put_vc2_ue_uint ( & s -> pb , s -> quant [ level ] [ 1 ] ) ;\n put_vc2_ue_uint ( & s -> pb , s -> quant [ level ] [ 2 ] ) ;\n put_vc2_ue_uint ( & s -> pb , s -> quant [ level ] [ 3 ] ) ;\n }\n }\n }", "hash": -7253276028511611170, "project": "debian", "size": 14, "target": 0, "idx": 6045}
{"code": "static struct cgroup_process_info * lxc_cgroup_process_info_get_self ( struct cgroup_meta_data * meta ) {\n struct cgroup_process_info * i ;\n i = lxc_cgroup_process_info_getx ( \"/proc/self/cgroup\" , meta ) ;\n if ( ! i ) i = lxc_cgroup_process_info_get ( getpid ( ) , meta ) ;\n return i ;\n }", "hash": -5992472514718425579, "project": "debian", "size": 6, "target": 0, "idx": 6065}
{"code": "static struct cgroup_process_info * find_info_for_subsystem ( struct cgroup_process_info * info , const char * subsystem ) {\n struct cgroup_process_info * info_ptr ;\n for ( info_ptr = info ;\n info_ptr ;\n info_ptr = info_ptr -> next ) {\n struct cgroup_hierarchy * h = info_ptr -> hierarchy ;\n if ( lxc_string_in_array ( subsystem , ( const char * * ) h -> subsystems ) ) return info_ptr ;\n }\n errno = ENOENT ;\n return NULL ;\n }", "hash": -5992472514718425579, "project": "debian", "size": 11, "target": 0, "idx": 6070}
{"code": "static int lxc_cgroup_create_legacy ( struct cgroup_process_info * base_info , const char * name , pid_t pid ) {\n struct cgroup_process_info * info_ptr ;\n int r ;\n for ( info_ptr = base_info ;\n info_ptr ;\n info_ptr = info_ptr -> next ) {\n if ( ! lxc_string_in_array ( \"ns\" , ( const char * * ) info_ptr -> hierarchy -> subsystems ) ) continue ;\n char * tmp = cgroup_rename_nsgroup ( ( const char * ) info_ptr -> designated_mount_point -> mount_point , info_ptr -> cgroup_path , pid , name ) ;\n if ( ! tmp ) return - 1 ;\n free ( info_ptr -> cgroup_path ) ;\n info_ptr -> cgroup_path = tmp ;\n r = lxc_grow_array ( ( void * * * ) & info_ptr -> created_paths , & info_ptr -> created_paths_capacity , info_ptr -> created_paths_count + 1 , 8 ) ;\n if ( r < 0 ) return - 1 ;\n tmp = strdup ( tmp ) ;\n if ( ! tmp ) return - 1 ;\n info_ptr -> created_paths [ info_ptr -> created_paths_count ++ ] = tmp ;\n }\n return 0 ;\n }", "hash": -5992472514718425579, "project": "debian", "size": 19, "target": 0, "idx": 6083}
{"code": "static void lxc_cgroup_hierarchy_free ( struct cgroup_hierarchy * h ) {\n if ( ! h ) return ;\n lxc_free_array ( ( void * * ) h -> subsystems , free ) ;\n free ( h -> all_mount_points ) ;\n free ( h ) ;\n }", "hash": -5992472514718425579, "project": "debian", "size": 6, "target": 0, "idx": 6099}
{"code": "static int lxc_cgroupfs_set ( const char * filename , const char * value , const char * name , const char * lxcpath ) {\n char * subsystem = NULL , * p , * path ;\n int ret = - 1 ;\n subsystem = alloca ( strlen ( filename ) + 1 ) ;\n strcpy ( subsystem , filename ) ;\n if ( ( p = strchr ( subsystem , '.' ) ) != NULL ) * p = '\\0' ;\n path = lxc_cgroup_get_hierarchy_abs_path ( subsystem , name , lxcpath ) ;\n if ( path ) {\n ret = do_cgroup_set ( path , filename , value ) ;\n free ( path ) ;\n }\n return ret ;\n }", "hash": -5992472514718425579, "project": "debian", "size": 13, "target": 0, "idx": 6104}
{"code": "void lxc_cgroup_process_info_free ( struct cgroup_process_info * info ) {\n struct cgroup_process_info * next ;\n if ( ! info ) return ;\n next = info -> next ;\n lxc_cgroup_put_meta ( info -> meta_ref ) ;\n free ( info -> cgroup_path ) ;\n free ( info -> cgroup_path_sub ) ;\n lxc_free_array ( ( void * * ) info -> created_paths , free ) ;\n free ( info ) ;\n lxc_cgroup_process_info_free ( next ) ;\n }", "hash": -5992472514718425579, "project": "debian", "size": 11, "target": 0, "idx": 6112}
{"code": "static int add_recent_loose ( const unsigned char * sha1 , const char * path , void * data ) {\n struct stat st ;\n struct object * obj = lookup_object ( sha1 ) ;\n if ( obj && obj -> flags & SEEN ) return 0 ;\n if ( stat ( path , & st ) < 0 ) {\n if ( errno == ENOENT ) return 0 ;\n return error ( \"unable to stat %s: %s\" , sha1_to_hex ( sha1 ) , strerror ( errno ) ) ;\n }\n add_recent_object ( sha1 , st . st_mtime , data ) ;\n return 0 ;\n }", "hash": 1234302720527317863, "project": "debian", "size": 11, "target": 0, "idx": 6125}
{"code": "static int check_pack_inflate ( struct packed_git * p , struct pack_window * * w_curs , off_t offset , off_t len , unsigned long expect ) {\n git_zstream stream ;\n unsigned char fakebuf [ 4096 ] , * in ;\n int st ;\n memset ( & stream , 0 , sizeof ( stream ) ) ;\n git_inflate_init ( & stream ) ;\n do {\n in = use_pack ( p , w_curs , offset , & stream . avail_in ) ;\n stream . next_in = in ;\n stream . next_out = fakebuf ;\n stream . avail_out = sizeof ( fakebuf ) ;\n st = git_inflate ( & stream , Z_FINISH ) ;\n offset += stream . next_in - in ;\n }\n while ( st == Z_OK || st == Z_BUF_ERROR ) ;\n git_inflate_end ( & stream ) ;\n return ( st == Z_STREAM_END && stream . total_out == expect && stream . total_in == len ) ? 0 : - 1 ;\n }", "hash": 3919646340804521652, "project": "debian", "size": 18, "target": 0, "idx": 6145}
{"code": "static int have_duplicate_entry ( const unsigned char * sha1 , int exclude , uint32_t * index_pos ) {\n struct object_entry * entry ;\n entry = packlist_find ( & to_pack , sha1 , index_pos ) ;\n if ( ! entry ) return 0 ;\n if ( exclude ) {\n if ( ! entry -> preferred_base ) nr_result -- ;\n entry -> preferred_base = 1 ;\n }\n return 1 ;\n }", "hash": 3919646340804521652, "project": "debian", "size": 10, "target": 0, "idx": 6155}
{"code": "static inline void add_to_write_order ( struct object_entry * * wo , unsigned int * endp , struct object_entry * e ) {\n if ( e -> filled ) return ;\n wo [ ( * endp ) ++ ] = e ;\n e -> filled = 1 ;\n }", "hash": 3919646340804521652, "project": "debian", "size": 5, "target": 0, "idx": 6156}
{"code": "static void add_preferred_base ( unsigned char * sha1 ) {\n struct pbase_tree * it ;\n void * data ;\n unsigned long size ;\n unsigned char tree_sha1 [ 20 ] ;\n if ( window <= num_preferred_base ++ ) return ;\n data = read_object_with_reference ( sha1 , tree_type , & size , tree_sha1 ) ;\n if ( ! data ) return ;\n for ( it = pbase_tree ;\n it ;\n it = it -> next ) {\n if ( ! hashcmp ( it -> pcache . sha1 , tree_sha1 ) ) {\n free ( data ) ;\n return ;\n }\n }\n it = xcalloc ( 1 , sizeof ( * it ) ) ;\n it -> next = pbase_tree ;\n pbase_tree = it ;\n hashcpy ( it -> pcache . sha1 , tree_sha1 ) ;\n it -> pcache . tree_data = data ;\n it -> pcache . tree_size = size ;\n }", "hash": 3919646340804521652, "project": "debian", "size": 23, "target": 0, "idx": 6194}
{"code": "static int ofscmp ( const void * a_ , const void * b_ ) {\n struct in_pack_object * a = ( struct in_pack_object * ) a_ ;\n struct in_pack_object * b = ( struct in_pack_object * ) b_ ;\n if ( a -> offset < b -> offset ) return - 1 ;\n else if ( a -> offset > b -> offset ) return 1 ;\n else return oidcmp ( & a -> object -> oid , & b -> object -> oid ) ;\n }", "hash": 3919646340804521652, "project": "debian", "size": 7, "target": 0, "idx": 6197}
{"code": "static void xml_cdata ( void * userData , const XML_Char * s , int len ) {\n struct xml_ctx * ctx = ( struct xml_ctx * ) userData ;\n free ( ctx -> cdata ) ;\n ctx -> cdata = xmemdupz ( s , len ) ;\n }", "hash": 229962612204196999, "project": "debian", "size": 5, "target": 0, "idx": 6203}
{"code": "static void remove_locks_on_signal ( int signo ) {\n remove_locks ( ) ;\n sigchain_pop ( signo ) ;\n raise ( signo ) ;\n }", "hash": 229962612204196999, "project": "debian", "size": 5, "target": 0, "idx": 6207}
{"code": "static void start_put ( struct transfer_request * request ) {\n char * hex = oid_to_hex ( & request -> obj -> oid ) ;\n struct active_request_slot * slot ;\n struct strbuf buf = STRBUF_INIT ;\n enum object_type type ;\n char hdr [ 50 ] ;\n void * unpacked ;\n unsigned long len ;\n int hdrlen ;\n ssize_t size ;\n git_zstream stream ;\n unpacked = read_sha1_file ( request -> obj -> oid . hash , & type , & len ) ;\n hdrlen = xsnprintf ( hdr , sizeof ( hdr ) , \"%s %lu\" , typename ( type ) , len ) + 1 ;\n git_deflate_init ( & stream , zlib_compression_level ) ;\n size = git_deflate_bound ( & stream , len + hdrlen ) ;\n strbuf_init ( & request -> buffer . buf , size ) ;\n request -> buffer . posn = 0 ;\n stream . next_out = ( unsigned char * ) request -> buffer . buf . buf ;\n stream . avail_out = size ;\n stream . next_in = ( void * ) hdr ;\n stream . avail_in = hdrlen ;\n while ( git_deflate ( & stream , 0 ) == Z_OK ) ;\n stream . next_in = unpacked ;\n stream . avail_in = len ;\n while ( git_deflate ( & stream , Z_FINISH ) == Z_OK ) ;\n git_deflate_end ( & stream ) ;\n free ( unpacked ) ;\n request -> buffer . buf . len = stream . total_out ;\n strbuf_addstr ( & buf , \"Destination: \" ) ;\n append_remote_object_url ( & buf , repo -> url , hex , 0 ) ;\n request -> dest = strbuf_detach ( & buf , NULL ) ;\n append_remote_object_url ( & buf , repo -> url , hex , 0 ) ;\n strbuf_add ( & buf , request -> lock -> tmpfile_suffix , 41 ) ;\n request -> url = strbuf_detach ( & buf , NULL ) ;\n slot = get_active_slot ( ) ;\n slot -> callback_func = process_response ;\n slot -> callback_data = request ;\n curl_setup_http ( slot -> curl , request -> url , DAV_PUT , & request -> buffer , fwrite_null ) ;\n if ( start_active_slot ( slot ) ) {\n request -> slot = slot ;\n request -> state = RUN_PUT ;\n }\n else {\n request -> state = ABORTED ;\n free ( request -> url ) ;\n request -> url = NULL ;\n }\n }", "hash": 229962612204196999, "project": "debian", "size": 48, "target": 0, "idx": 6210}
{"code": "static int add_send_request ( struct object * obj , struct remote_lock * lock ) {\n struct transfer_request * request ;\n struct packed_git * target ;\n check_locks ( ) ;\n if ( remote_dir_exists [ obj -> oid . hash [ 0 ] ] == - 1 ) get_remote_object_list ( obj -> oid . hash [ 0 ] ) ;\n if ( obj -> flags & ( REMOTE | PUSHING ) ) return 0 ;\n target = find_sha1_pack ( obj -> oid . hash , repo -> packs ) ;\n if ( target ) {\n obj -> flags |= REMOTE ;\n return 0 ;\n }\n obj -> flags |= PUSHING ;\n request = xmalloc ( sizeof ( * request ) ) ;\n request -> obj = obj ;\n request -> url = NULL ;\n request -> lock = lock ;\n request -> headers = NULL ;\n request -> state = NEED_PUSH ;\n request -> next = request_queue_head ;\n request_queue_head = request ;\n # ifdef USE_CURL_MULTI fill_active_slots ( ) ;\n step_active_slots ( ) ;\n # endif return 1 ;\n }", "hash": 229962612204196999, "project": "debian", "size": 24, "target": 0, "idx": 6211}
{"code": "static void curl_setup_http ( CURL * curl , const char * url , const char * custom_req , struct buffer * buffer , curl_write_callback write_fn ) {\n curl_easy_setopt ( curl , CURLOPT_PUT , 1 ) ;\n curl_easy_setopt ( curl , CURLOPT_URL , url ) ;\n curl_easy_setopt ( curl , CURLOPT_INFILE , buffer ) ;\n curl_easy_setopt ( curl , CURLOPT_INFILESIZE , buffer -> buf . len ) ;\n curl_easy_setopt ( curl , CURLOPT_READFUNCTION , fread_buffer ) ;\n # ifndef NO_CURL_IOCTL curl_easy_setopt ( curl , CURLOPT_IOCTLFUNCTION , ioctl_buffer ) ;\n curl_easy_setopt ( curl , CURLOPT_IOCTLDATA , buffer ) ;\n # endif curl_easy_setopt ( curl , CURLOPT_WRITEFUNCTION , write_fn ) ;\n curl_easy_setopt ( curl , CURLOPT_NOBODY , 0 ) ;\n curl_easy_setopt ( curl , CURLOPT_CUSTOMREQUEST , custom_req ) ;\n curl_easy_setopt ( curl , CURLOPT_UPLOAD , 1 ) ;\n }", "hash": 229962612204196999, "project": "debian", "size": 13, "target": 0, "idx": 6213}
{"code": "static void remove_locks ( void ) {\n struct remote_lock * lock = repo -> locks ;\n fprintf ( stderr , \"Removing remote locks...\\n\" ) ;\n while ( lock ) {\n struct remote_lock * next = lock -> next ;\n unlock_remote ( lock ) ;\n lock = next ;\n }\n }", "hash": 229962612204196999, "project": "debian", "size": 9, "target": 0, "idx": 6231}
{"code": "static void start_fetch_packed ( struct transfer_request * request ) {\n struct packed_git * target ;\n struct transfer_request * check_request = request_queue_head ;\n struct http_pack_request * preq ;\n target = find_sha1_pack ( request -> obj -> oid . hash , repo -> packs ) ;\n if ( ! target ) {\n fprintf ( stderr , \"Unable to fetch %s, will not be able to update server info refs\\n\" , oid_to_hex ( & request -> obj -> oid ) ) ;\n repo -> can_update_info_refs = 0 ;\n release_request ( request ) ;\n return ;\n }\n fprintf ( stderr , \"Fetching pack %s\\n\" , sha1_to_hex ( target -> sha1 ) ) ;\n fprintf ( stderr , \" which contains %s\\n\" , oid_to_hex ( & request -> obj -> oid ) ) ;\n preq = new_http_pack_request ( target , repo -> url ) ;\n if ( preq == NULL ) {\n repo -> can_update_info_refs = 0 ;\n return ;\n }\n preq -> lst = & repo -> packs ;\n while ( check_request ) {\n if ( check_request -> state == RUN_FETCH_PACKED && ! strcmp ( check_request -> url , preq -> url ) ) {\n release_http_pack_request ( preq ) ;\n release_request ( request ) ;\n return ;\n }\n check_request = check_request -> next ;\n }\n preq -> slot -> callback_func = process_response ;\n preq -> slot -> callback_data = request ;\n request -> slot = preq -> slot ;\n request -> userData = preq ;\n request -> state = RUN_FETCH_PACKED ;\n if ( ! start_active_slot ( preq -> slot ) ) {\n fprintf ( stderr , \"Unable to start GET request\\n\" ) ;\n release_http_pack_request ( preq ) ;\n repo -> can_update_info_refs = 0 ;\n release_request ( request ) ;\n }\n }", "hash": 229962612204196999, "project": "debian", "size": 39, "target": 0, "idx": 6241}
{"code": "static inline uint8_t read_u8 ( const unsigned char * buffer , size_t * pos ) {\n return buffer [ ( * pos ) ++ ] ;\n }", "hash": 1414661670117003749, "project": "debian", "size": 3, "target": 0, "idx": 6248}
{"code": "static inline int bitmap_position_packfile ( const unsigned char * sha1 ) {\n off_t offset = find_pack_entry_one ( sha1 , bitmap_git . pack ) ;\n if ( ! offset ) return - 1 ;\n return find_revindex_position ( bitmap_git . pack , offset ) ;\n }", "hash": 1414661670117003749, "project": "debian", "size": 5, "target": 0, "idx": 6250}
{"code": "static int show_object_fast ( const unsigned char * sha1 , enum object_type type , int exclude , uint32_t name_hash , struct packed_git * found_pack , off_t found_offset ) {\n fprintf ( stdout , \"%s\\n\" , sha1_to_hex ( sha1 ) ) ;\n return 1 ;\n }", "hash": -7811574867662618708, "project": "debian", "size": 4, "target": 0, "idx": 6291}
{"code": "static void startoutput ( void ) {\n out_chars = 0 ;\n out_linecount = 0 ;\n }", "hash": -341028540041678099, "project": "debian", "size": 4, "target": 0, "idx": 6335}
{"code": "static void __attribute__ ( ( __format__ ( __printf__ , 1 , 0 ) ) ) vwarning ( const char * fmt , va_list ap ) {\n int serrno = errno ;\n ( void ) fprintf ( stderr , \"%s: \" , progname ) ;\n vfprintf ( stderr , fmt , ap ) ;\n ( void ) fprintf ( stderr , \": %s\" , strerror ( serrno ) ) ;\n }", "hash": -341028540041678099, "project": "debian", "size": 6, "target": 0, "idx": 6337}
{"code": "static void version ( struct parse * pcmd , FILE * fp ) {\n ( void ) fprintf ( fp , \"%s\\n\" , Version ) ;\n return ;\n }", "hash": -341028540041678099, "project": "debian", "size": 4, "target": 0, "idx": 6343}
{"code": "void printvars ( int length , const char * data , int status , int sttype , int quiet , FILE * fp ) {\n if ( rawmode ) rawprint ( sttype , length , data , status , quiet , fp ) ;\n else cookedprint ( sttype , length , data , status , quiet , fp ) ;\n }", "hash": -341028540041678099, "project": "debian", "size": 4, "target": 0, "idx": 6352}
{"code": "int main ( int argc , char * argv [ ] ) {\n return ntpqmain ( argc , argv ) ;\n }", "hash": -341028540041678099, "project": "debian", "size": 3, "target": 0, "idx": 6360}
{"code": "static void __attribute__ ( ( __format__ ( __printf__ , 1 , 2 ) ) ) error ( const char * fmt , ... ) {\n va_list ap ;\n va_start ( ap , fmt ) ;\n vwarning ( fmt , ap ) ;\n va_end ( ap ) ;\n exit ( 1 ) ;\n }", "hash": -341028540041678099, "project": "debian", "size": 7, "target": 0, "idx": 6363}
{"code": "static void quit ( struct parse * pcmd , FILE * fp ) {\n if ( havehost ) closesocket ( sockfd ) ;\n exit ( 0 ) ;\n }", "hash": -341028540041678099, "project": "debian", "size": 4, "target": 0, "idx": 6368}
{"code": "static int assoccmp ( const void * t1 , const void * t2 ) {\n const struct association * ass1 = t1 ;\n const struct association * ass2 = t2 ;\n if ( ass1 -> assid < ass2 -> assid ) return - 1 ;\n if ( ass1 -> assid > ass2 -> assid ) return 1 ;\n return 0 ;\n }", "hash": -341028540041678099, "project": "debian", "size": 7, "target": 0, "idx": 6383}
{"code": "static void pdo_stmt_iter_get_key ( zend_object_iterator * iter , zval * key TSRMLS_DC ) {\n struct php_pdo_iterator * I = ( struct php_pdo_iterator * ) iter -> data ;\n if ( I -> key == ( ulong ) - 1 ) {\n ZVAL_NULL ( key ) ;\n }\n else {\n ZVAL_LONG ( key , I -> key ) ;\n }\n }", "hash": 7399683071036018868, "project": "debian", "size": 9, "target": 0, "idx": 6400}
{"code": "static void dbstmt_prop_delete ( zval * object , zval * member , const zend_literal * key TSRMLS_DC ) {\n pdo_stmt_t * stmt = ( pdo_stmt_t * ) zend_object_store_get_object ( object TSRMLS_CC ) ;\n convert_to_string ( member ) ;\n if ( strcmp ( Z_STRVAL_P ( member ) , \"queryString\" ) == 0 ) {\n pdo_raise_impl_error ( stmt -> dbh , stmt , \"HY000\" , \"property queryString is read only\" TSRMLS_CC ) ;\n }\n else {\n std_object_handlers . unset_property ( object , member , key TSRMLS_CC ) ;\n }\n }", "hash": 7399683071036018868, "project": "debian", "size": 10, "target": 0, "idx": 6406}
{"code": "static void row_prop_delete ( zval * object , zval * offset , const zend_literal * key TSRMLS_DC ) {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Cannot delete properties from a PDORow\" ) ;\n }", "hash": 7399683071036018868, "project": "debian", "size": 3, "target": 0, "idx": 6414}
{"code": "static void pdo_stmt_iter_dtor ( zend_object_iterator * iter TSRMLS_DC ) {\n struct php_pdo_iterator * I = ( struct php_pdo_iterator * ) iter -> data ;\n if ( -- I -> stmt -> refcount == 0 ) {\n free_statement ( I -> stmt TSRMLS_CC ) ;\n }\n if ( I -> fetch_ahead ) {\n zval_ptr_dtor ( & I -> fetch_ahead ) ;\n }\n efree ( I ) ;\n }", "hash": 7399683071036018868, "project": "debian", "size": 10, "target": 0, "idx": 6417}
{"code": "static int processcompl ( struct async * as , void __user * __user * arg ) {\n struct urb * urb = as -> urb ;\n struct usbdevfs_urb __user * userurb = as -> userurb ;\n void __user * addr = as -> userurb ;\n unsigned int i ;\n if ( as -> userbuffer && urb -> actual_length ) {\n if ( copy_urb_data_to_user ( as -> userbuffer , urb ) ) goto err_out ;\n }\n if ( put_user ( as -> status , & userurb -> status ) ) goto err_out ;\n if ( put_user ( urb -> actual_length , & userurb -> actual_length ) ) goto err_out ;\n if ( put_user ( urb -> error_count , & userurb -> error_count ) ) goto err_out ;\n if ( usb_endpoint_xfer_isoc ( & urb -> ep -> desc ) ) {\n for ( i = 0 ;\n i < urb -> number_of_packets ;\n i ++ ) {\n if ( put_user ( urb -> iso_frame_desc [ i ] . actual_length , & userurb -> iso_frame_desc [ i ] . actual_length ) ) goto err_out ;\n if ( put_user ( urb -> iso_frame_desc [ i ] . status , & userurb -> iso_frame_desc [ i ] . status ) ) goto err_out ;\n }\n }\n if ( put_user ( addr , ( void __user * __user * ) arg ) ) return - EFAULT ;\n return 0 ;\n err_out : return - EFAULT ;\n }", "hash": 7424930167238097621, "project": "debian", "size": 23, "target": 0, "idx": 6423}
{"code": "static int proc_releaseinterface ( struct usb_dev_state * ps , void __user * arg ) {\n unsigned int ifnum ;\n int ret ;\n if ( get_user ( ifnum , ( unsigned int __user * ) arg ) ) return - EFAULT ;\n ret = releaseintf ( ps , ifnum ) ;\n if ( ret < 0 ) return ret ;\n destroy_async_on_interface ( ps , ifnum ) ;\n return 0 ;\n }", "hash": 7424930167238097621, "project": "debian", "size": 9, "target": 0, "idx": 6424}
{"code": "static ssize_t usbdev_read ( struct file * file , char __user * buf , size_t nbytes , loff_t * ppos ) {\n struct usb_dev_state * ps = file -> private_data ;\n struct usb_device * dev = ps -> dev ;\n ssize_t ret = 0 ;\n unsigned len ;\n loff_t pos ;\n int i ;\n pos = * ppos ;\n usb_lock_device ( dev ) ;\n if ( ! connected ( ps ) ) {\n ret = - ENODEV ;\n goto err ;\n }\n else if ( pos < 0 ) {\n ret = - EINVAL ;\n goto err ;\n }\n if ( pos < sizeof ( struct usb_device_descriptor ) ) {\n struct usb_device_descriptor temp_desc ;\n memcpy ( & temp_desc , & dev -> descriptor , sizeof ( dev -> descriptor ) ) ;\n le16_to_cpus ( & temp_desc . bcdUSB ) ;\n le16_to_cpus ( & temp_desc . idVendor ) ;\n le16_to_cpus ( & temp_desc . idProduct ) ;\n le16_to_cpus ( & temp_desc . bcdDevice ) ;\n len = sizeof ( struct usb_device_descriptor ) - pos ;\n if ( len > nbytes ) len = nbytes ;\n if ( copy_to_user ( buf , ( ( char * ) & temp_desc ) + pos , len ) ) {\n ret = - EFAULT ;\n goto err ;\n }\n * ppos += len ;\n buf += len ;\n nbytes -= len ;\n ret += len ;\n }\n pos = sizeof ( struct usb_device_descriptor ) ;\n for ( i = 0 ;\n nbytes && i < dev -> descriptor . bNumConfigurations ;\n i ++ ) {\n struct usb_config_descriptor * config = ( struct usb_config_descriptor * ) dev -> rawdescriptors [ i ] ;\n unsigned int length = le16_to_cpu ( config -> wTotalLength ) ;\n if ( * ppos < pos + length ) {\n unsigned alloclen = le16_to_cpu ( dev -> config [ i ] . desc . wTotalLength ) ;\n len = length - ( * ppos - pos ) ;\n if ( len > nbytes ) len = nbytes ;\n if ( alloclen > ( * ppos - pos ) ) {\n alloclen -= ( * ppos - pos ) ;\n if ( copy_to_user ( buf , dev -> rawdescriptors [ i ] + ( * ppos - pos ) , min ( len , alloclen ) ) ) {\n ret = - EFAULT ;\n goto err ;\n }\n }\n * ppos += len ;\n buf += len ;\n nbytes -= len ;\n ret += len ;\n }\n pos += length ;\n }\n err : usb_unlock_device ( dev ) ;\n return ret ;\n }", "hash": 7424930167238097621, "project": "debian", "size": 62, "target": 0, "idx": 6427}
{"code": "static void usbfs_decrease_memory_usage ( unsigned amount ) {\n atomic_sub ( amount , & usbfs_memory_usage ) ;\n }", "hash": 7424930167238097621, "project": "debian", "size": 3, "target": 0, "idx": 6429}
{"code": "static int proc_control ( struct usb_dev_state * ps , void __user * arg ) {\n struct usb_device * dev = ps -> dev ;\n struct usbdevfs_ctrltransfer ctrl ;\n unsigned int tmo ;\n unsigned char * tbuf ;\n unsigned wLength ;\n int i , pipe , ret ;\n if ( copy_from_user ( & ctrl , arg , sizeof ( ctrl ) ) ) return - EFAULT ;\n ret = check_ctrlrecip ( ps , ctrl . bRequestType , ctrl . bRequest , ctrl . wIndex ) ;\n if ( ret ) return ret ;\n wLength = ctrl . wLength ;\n if ( wLength > PAGE_SIZE ) return - EINVAL ;\n ret = usbfs_increase_memory_usage ( PAGE_SIZE + sizeof ( struct urb ) + sizeof ( struct usb_ctrlrequest ) ) ;\n if ( ret ) return ret ;\n tbuf = ( unsigned char * ) __get_free_page ( GFP_KERNEL ) ;\n if ( ! tbuf ) {\n ret = - ENOMEM ;\n goto done ;\n }\n tmo = ctrl . timeout ;\n snoop ( & dev -> dev , \"control urb: bRequestType=%02x \" \"bRequest=%02x wValue=%04x \" \"wIndex=%04x wLength=%04x\\n\" , ctrl . bRequestType , ctrl . bRequest , ctrl . wValue , ctrl . wIndex , ctrl . wLength ) ;\n if ( ctrl . bRequestType & 0x80 ) {\n if ( ctrl . wLength && ! access_ok ( VERIFY_WRITE , ctrl . data , ctrl . wLength ) ) {\n ret = - EINVAL ;\n goto done ;\n }\n pipe = usb_rcvctrlpipe ( dev , 0 ) ;\n snoop_urb ( dev , NULL , pipe , ctrl . wLength , tmo , SUBMIT , NULL , 0 ) ;\n usb_unlock_device ( dev ) ;\n i = usb_control_msg ( dev , pipe , ctrl . bRequest , ctrl . bRequestType , ctrl . wValue , ctrl . wIndex , tbuf , ctrl . wLength , tmo ) ;\n usb_lock_device ( dev ) ;\n snoop_urb ( dev , NULL , pipe , max ( i , 0 ) , min ( i , 0 ) , COMPLETE , tbuf , max ( i , 0 ) ) ;\n if ( ( i > 0 ) && ctrl . wLength ) {\n if ( copy_to_user ( ctrl . data , tbuf , i ) ) {\n ret = - EFAULT ;\n goto done ;\n }\n }\n }\n else {\n if ( ctrl . wLength ) {\n if ( copy_from_user ( tbuf , ctrl . data , ctrl . wLength ) ) {\n ret = - EFAULT ;\n goto done ;\n }\n }\n pipe = usb_sndctrlpipe ( dev , 0 ) ;\n snoop_urb ( dev , NULL , pipe , ctrl . wLength , tmo , SUBMIT , tbuf , ctrl . wLength ) ;\n usb_unlock_device ( dev ) ;\n i = usb_control_msg ( dev , usb_sndctrlpipe ( dev , 0 ) , ctrl . bRequest , ctrl . bRequestType , ctrl . wValue , ctrl . wIndex , tbuf , ctrl . wLength , tmo ) ;\n usb_lock_device ( dev ) ;\n snoop_urb ( dev , NULL , pipe , max ( i , 0 ) , min ( i , 0 ) , COMPLETE , NULL , 0 ) ;\n }\n if ( i < 0 && i != - EPIPE ) {\n dev_printk ( KERN_DEBUG , & dev -> dev , \"usbfs: USBDEVFS_CONTROL \" \"failed cmd %s rqt %u rq %u len %u ret %d\\n\" , current -> comm , ctrl . bRequestType , ctrl . bRequest , ctrl . wLength , i ) ;\n }\n ret = i ;\n done : free_page ( ( unsigned long ) tbuf ) ;\n usbfs_decrease_memory_usage ( PAGE_SIZE + sizeof ( struct urb ) + sizeof ( struct usb_ctrlrequest ) ) ;\n return ret ;\n }", "hash": 7424930167238097621, "project": "debian", "size": 61, "target": 0, "idx": 6430}
{"code": "static struct async * async_getpending ( struct usb_dev_state * ps , void __user * userurb ) {\n struct async * as ;\n list_for_each_entry ( as , & ps -> async_pending , asynclist ) if ( as -> userurb == userurb ) {\n list_del_init ( & as -> asynclist ) ;\n return as ;\n }\n return NULL ;\n }", "hash": 7424930167238097621, "project": "debian", "size": 8, "target": 0, "idx": 6434}
{"code": "static int usbfs_increase_memory_usage ( unsigned amount ) {\n unsigned lim ;\n lim = ACCESS_ONCE ( usbfs_memory_mb ) ;\n if ( lim == 0 || lim > ( USBFS_XFER_MAX >> 20 ) ) lim = USBFS_XFER_MAX ;\n else lim <<= 20 ;\n atomic_add ( amount , & usbfs_memory_usage ) ;\n if ( atomic_read ( & usbfs_memory_usage ) <= lim ) return 0 ;\n atomic_sub ( amount , & usbfs_memory_usage ) ;\n return - ENOMEM ;\n }", "hash": 7424930167238097621, "project": "debian", "size": 10, "target": 0, "idx": 6435}
{"code": "static long usbdev_do_ioctl ( struct file * file , unsigned int cmd , void __user * p ) {\n struct usb_dev_state * ps = file -> private_data ;\n struct inode * inode = file_inode ( file ) ;\n struct usb_device * dev = ps -> dev ;\n int ret = - ENOTTY ;\n if ( ! ( file -> f_mode & FMODE_WRITE ) ) return - EPERM ;\n usb_lock_device ( dev ) ;\n switch ( cmd ) {\n case USBDEVFS_REAPURB : snoop ( & dev -> dev , \"%s: REAPURB\\n\" , __func__ ) ;\n ret = proc_reapurb ( ps , p ) ;\n goto done ;\n case USBDEVFS_REAPURBNDELAY : snoop ( & dev -> dev , \"%s: REAPURBNDELAY\\n\" , __func__ ) ;\n ret = proc_reapurbnonblock ( ps , p ) ;\n goto done ;\n # ifdef CONFIG_COMPAT case USBDEVFS_REAPURB32 : snoop ( & dev -> dev , \"%s: REAPURB32\\n\" , __func__ ) ;\n ret = proc_reapurb_compat ( ps , p ) ;\n goto done ;\n case USBDEVFS_REAPURBNDELAY32 : snoop ( & dev -> dev , \"%s: REAPURBNDELAY32\\n\" , __func__ ) ;\n ret = proc_reapurbnonblock_compat ( ps , p ) ;\n goto done ;\n # endif }\n if ( ! connected ( ps ) ) {\n usb_unlock_device ( dev ) ;\n return - ENODEV ;\n }\n switch ( cmd ) {\n case USBDEVFS_CONTROL : snoop ( & dev -> dev , \"%s: CONTROL\\n\" , __func__ ) ;\n ret = proc_control ( ps , p ) ;\n if ( ret >= 0 ) inode -> i_mtime = CURRENT_TIME ;\n break ;\n case USBDEVFS_BULK : snoop ( & dev -> dev , \"%s: BULK\\n\" , __func__ ) ;\n ret = proc_bulk ( ps , p ) ;\n if ( ret >= 0 ) inode -> i_mtime = CURRENT_TIME ;\n break ;\n case USBDEVFS_RESETEP : snoop ( & dev -> dev , \"%s: RESETEP\\n\" , __func__ ) ;\n ret = proc_resetep ( ps , p ) ;\n if ( ret >= 0 ) inode -> i_mtime = CURRENT_TIME ;\n break ;\n case USBDEVFS_RESET : snoop ( & dev -> dev , \"%s: RESET\\n\" , __func__ ) ;\n ret = proc_resetdevice ( ps ) ;\n break ;\n case USBDEVFS_CLEAR_HALT : snoop ( & dev -> dev , \"%s: CLEAR_HALT\\n\" , __func__ ) ;\n ret = proc_clearhalt ( ps , p ) ;\n if ( ret >= 0 ) inode -> i_mtime = CURRENT_TIME ;\n break ;\n case USBDEVFS_GETDRIVER : snoop ( & dev -> dev , \"%s: GETDRIVER\\n\" , __func__ ) ;\n ret = proc_getdriver ( ps , p ) ;\n break ;\n case USBDEVFS_CONNECTINFO : snoop ( & dev -> dev , \"%s: CONNECTINFO\\n\" , __func__ ) ;\n ret = proc_connectinfo ( ps , p ) ;\n break ;\n case USBDEVFS_SETINTERFACE : snoop ( & dev -> dev , \"%s: SETINTERFACE\\n\" , __func__ ) ;\n ret = proc_setintf ( ps , p ) ;\n break ;\n case USBDEVFS_SETCONFIGURATION : snoop ( & dev -> dev , \"%s: SETCONFIGURATION\\n\" , __func__ ) ;\n ret = proc_setconfig ( ps , p ) ;\n break ;\n case USBDEVFS_SUBMITURB : snoop ( & dev -> dev , \"%s: SUBMITURB\\n\" , __func__ ) ;\n ret = proc_submiturb ( ps , p ) ;\n if ( ret >= 0 ) inode -> i_mtime = CURRENT_TIME ;\n break ;\n # ifdef CONFIG_COMPAT case USBDEVFS_CONTROL32 : snoop ( & dev -> dev , \"%s: CONTROL32\\n\" , __func__ ) ;\n ret = proc_control_compat ( ps , p ) ;\n if ( ret >= 0 ) inode -> i_mtime = CURRENT_TIME ;\n break ;\n case USBDEVFS_BULK32 : snoop ( & dev -> dev , \"%s: BULK32\\n\" , __func__ ) ;\n ret = proc_bulk_compat ( ps , p ) ;\n if ( ret >= 0 ) inode -> i_mtime = CURRENT_TIME ;\n break ;\n case USBDEVFS_DISCSIGNAL32 : snoop ( & dev -> dev , \"%s: DISCSIGNAL32\\n\" , __func__ ) ;\n ret = proc_disconnectsignal_compat ( ps , p ) ;\n break ;\n case USBDEVFS_SUBMITURB32 : snoop ( & dev -> dev , \"%s: SUBMITURB32\\n\" , __func__ ) ;\n ret = proc_submiturb_compat ( ps , p ) ;\n if ( ret >= 0 ) inode -> i_mtime = CURRENT_TIME ;\n break ;\n case USBDEVFS_IOCTL32 : snoop ( & dev -> dev , \"%s: IOCTL32\\n\" , __func__ ) ;\n ret = proc_ioctl_compat ( ps , ptr_to_compat ( p ) ) ;\n break ;\n # endif case USBDEVFS_DISCARDURB : snoop ( & dev -> dev , \"%s: DISCARDURB %p\\n\" , __func__ , p ) ;\n ret = proc_unlinkurb ( ps , p ) ;\n break ;\n case USBDEVFS_DISCSIGNAL : snoop ( & dev -> dev , \"%s: DISCSIGNAL\\n\" , __func__ ) ;\n ret = proc_disconnectsignal ( ps , p ) ;\n break ;\n case USBDEVFS_CLAIMINTERFACE : snoop ( & dev -> dev , \"%s: CLAIMINTERFACE\\n\" , __func__ ) ;\n ret = proc_claiminterface ( ps , p ) ;\n break ;\n case USBDEVFS_RELEASEINTERFACE : snoop ( & dev -> dev , \"%s: RELEASEINTERFACE\\n\" , __func__ ) ;\n ret = proc_releaseinterface ( ps , p ) ;\n break ;\n case USBDEVFS_IOCTL : snoop ( & dev -> dev , \"%s: IOCTL\\n\" , __func__ ) ;\n ret = proc_ioctl_default ( ps , p ) ;\n break ;\n case USBDEVFS_CLAIM_PORT : snoop ( & dev -> dev , \"%s: CLAIM_PORT\\n\" , __func__ ) ;\n ret = proc_claim_port ( ps , p ) ;\n break ;\n case USBDEVFS_RELEASE_PORT : snoop ( & dev -> dev , \"%s: RELEASE_PORT\\n\" , __func__ ) ;\n ret = proc_release_port ( ps , p ) ;\n break ;\n case USBDEVFS_GET_CAPABILITIES : ret = proc_get_capabilities ( ps , p ) ;\n break ;\n case USBDEVFS_DISCONNECT_CLAIM : ret = proc_disconnect_claim ( ps , p ) ;\n break ;\n case USBDEVFS_ALLOC_STREAMS : ret = proc_alloc_streams ( ps , p ) ;\n break ;\n case USBDEVFS_FREE_STREAMS : ret = proc_free_streams ( ps , p ) ;\n break ;\n case USBDEVFS_DROP_PRIVILEGES : ret = proc_drop_privileges ( ps , p ) ;\n break ;\n }\n done : usb_unlock_device ( dev ) ;\n if ( ret >= 0 ) inode -> i_atime = CURRENT_TIME ;\n return ret ;\n }", "hash": 7424930167238097621, "project": "debian", "size": 115, "target": 0, "idx": 6436}
{"code": "static void snoop_urb_data ( struct urb * urb , unsigned len ) {\n int i , size ;\n len = min ( len , usbfs_snoop_max ) ;\n if ( ! usbfs_snoop || len == 0 ) return ;\n if ( urb -> num_sgs == 0 ) {\n print_hex_dump ( KERN_DEBUG , \"data: \" , DUMP_PREFIX_NONE , 32 , 1 , urb -> transfer_buffer , len , 1 ) ;\n return ;\n }\n for ( i = 0 ;\n i < urb -> num_sgs && len ;\n i ++ ) {\n size = ( len > USB_SG_SIZE ) ? USB_SG_SIZE : len ;\n print_hex_dump ( KERN_DEBUG , \"data: \" , DUMP_PREFIX_NONE , 32 , 1 , sg_virt ( & urb -> sg [ i ] ) , size , 1 ) ;\n len -= size ;\n }\n }", "hash": 7424930167238097621, "project": "debian", "size": 16, "target": 0, "idx": 6452}
{"code": "static int proc_bulk ( struct usb_dev_state * ps , void __user * arg ) {\n struct usb_device * dev = ps -> dev ;\n struct usbdevfs_bulktransfer bulk ;\n unsigned int tmo , len1 , pipe ;\n int len2 ;\n unsigned char * tbuf ;\n int i , ret ;\n if ( copy_from_user ( & bulk , arg , sizeof ( bulk ) ) ) return - EFAULT ;\n ret = findintfep ( ps -> dev , bulk . ep ) ;\n if ( ret < 0 ) return ret ;\n ret = checkintf ( ps , ret ) ;\n if ( ret ) return ret ;\n if ( bulk . ep & USB_DIR_IN ) pipe = usb_rcvbulkpipe ( dev , bulk . ep & 0x7f ) ;\n else pipe = usb_sndbulkpipe ( dev , bulk . ep & 0x7f ) ;\n if ( ! usb_maxpacket ( dev , pipe , ! ( bulk . ep & USB_DIR_IN ) ) ) return - EINVAL ;\n len1 = bulk . len ;\n if ( len1 >= USBFS_XFER_MAX ) return - EINVAL ;\n ret = usbfs_increase_memory_usage ( len1 + sizeof ( struct urb ) ) ;\n if ( ret ) return ret ;\n tbuf = kmalloc ( len1 , GFP_KERNEL ) ;\n if ( ! tbuf ) {\n ret = - ENOMEM ;\n goto done ;\n }\n tmo = bulk . timeout ;\n if ( bulk . ep & 0x80 ) {\n if ( len1 && ! access_ok ( VERIFY_WRITE , bulk . data , len1 ) ) {\n ret = - EINVAL ;\n goto done ;\n }\n snoop_urb ( dev , NULL , pipe , len1 , tmo , SUBMIT , NULL , 0 ) ;\n usb_unlock_device ( dev ) ;\n i = usb_bulk_msg ( dev , pipe , tbuf , len1 , & len2 , tmo ) ;\n usb_lock_device ( dev ) ;\n snoop_urb ( dev , NULL , pipe , len2 , i , COMPLETE , tbuf , len2 ) ;\n if ( ! i && len2 ) {\n if ( copy_to_user ( bulk . data , tbuf , len2 ) ) {\n ret = - EFAULT ;\n goto done ;\n }\n }\n }\n else {\n if ( len1 ) {\n if ( copy_from_user ( tbuf , bulk . data , len1 ) ) {\n ret = - EFAULT ;\n goto done ;\n }\n }\n snoop_urb ( dev , NULL , pipe , len1 , tmo , SUBMIT , tbuf , len1 ) ;\n usb_unlock_device ( dev ) ;\n i = usb_bulk_msg ( dev , pipe , tbuf , len1 , & len2 , tmo ) ;\n usb_lock_device ( dev ) ;\n snoop_urb ( dev , NULL , pipe , len2 , i , COMPLETE , NULL , 0 ) ;\n }\n ret = ( i < 0 ? i : len2 ) ;\n done : kfree ( tbuf ) ;\n usbfs_decrease_memory_usage ( len1 + sizeof ( struct urb ) ) ;\n return ret ;\n }", "hash": 7424930167238097621, "project": "debian", "size": 60, "target": 0, "idx": 6465}
{"code": "static int proc_resetdevice ( struct usb_dev_state * ps ) {\n struct usb_host_config * actconfig = ps -> dev -> actconfig ;\n struct usb_interface * interface ;\n int i , number ;\n if ( ps -> privileges_dropped && actconfig ) {\n for ( i = 0 ;\n i < actconfig -> desc . bNumInterfaces ;\n ++ i ) {\n interface = actconfig -> interface [ i ] ;\n number = interface -> cur_altsetting -> desc . bInterfaceNumber ;\n if ( usb_interface_claimed ( interface ) && ! test_bit ( number , & ps -> ifclaimed ) ) {\n dev_warn ( & ps -> dev -> dev , \"usbfs: interface %d claimed by %s while '%s' resets device\\n\" , number , interface -> dev . driver -> name , current -> comm ) ;\n return - EACCES ;\n }\n }\n }\n return usb_reset_device ( ps -> dev ) ;\n }", "hash": 7424930167238097621, "project": "debian", "size": 18, "target": 0, "idx": 6467}
{"code": "static int proc_getdriver ( struct usb_dev_state * ps , void __user * arg ) {\n struct usbdevfs_getdriver gd ;\n struct usb_interface * intf ;\n int ret ;\n if ( copy_from_user ( & gd , arg , sizeof ( gd ) ) ) return - EFAULT ;\n intf = usb_ifnum_to_if ( ps -> dev , gd . interface ) ;\n if ( ! intf || ! intf -> dev . driver ) ret = - ENODATA ;\n else {\n strlcpy ( gd . driver , intf -> dev . driver -> name , sizeof ( gd . driver ) ) ;\n ret = ( copy_to_user ( arg , & gd , sizeof ( gd ) ) ? - EFAULT : 0 ) ;\n }\n return ret ;\n }", "hash": 7424930167238097621, "project": "debian", "size": 13, "target": 0, "idx": 6472}
{"code": "static bfd_boolean srec_write_record ( bfd * abfd , unsigned int type , bfd_vma address , const bfd_byte * data , const bfd_byte * end ) {\n char buffer [ 2 * MAXCHUNK + 6 ] ;\n unsigned int check_sum = 0 ;\n const bfd_byte * src = data ;\n char * dst = buffer ;\n char * length ;\n bfd_size_type wrlen ;\n * dst ++ = 'S' ;\n * dst ++ = '0' + type ;\n length = dst ;\n dst += 2 ;\n switch ( type ) {\n case 3 : case 7 : TOHEX ( dst , ( address >> 24 ) , check_sum ) ;\n dst += 2 ;\n case 8 : case 2 : TOHEX ( dst , ( address >> 16 ) , check_sum ) ;\n dst += 2 ;\n case 9 : case 1 : case 0 : TOHEX ( dst , ( address >> 8 ) , check_sum ) ;\n dst += 2 ;\n TOHEX ( dst , ( address ) , check_sum ) ;\n dst += 2 ;\n break ;\n }\n for ( src = data ;\n src < end ;\n src ++ ) {\n TOHEX ( dst , * src , check_sum ) ;\n dst += 2 ;\n }\n TOHEX ( length , ( dst - length ) / 2 , check_sum ) ;\n check_sum &= 0xff ;\n check_sum = 255 - check_sum ;\n TOHEX ( dst , check_sum , check_sum ) ;\n dst += 2 ;\n * dst ++ = '\\r' ;\n * dst ++ = '\\n' ;\n wrlen = dst - buffer ;\n return bfd_bwrite ( ( void * ) buffer , wrlen , abfd ) == wrlen ;\n }", "hash": -8638406710431929037, "project": "debian", "size": 38, "target": 0, "idx": 6503}
{"code": "static bfd_boolean srec_set_section_contents ( bfd * abfd , sec_ptr section , const void * location , file_ptr offset , bfd_size_type bytes_to_do ) {\n int opb = bfd_octets_per_byte ( abfd ) ;\n tdata_type * tdata = abfd -> tdata . srec_data ;\n srec_data_list_type * entry ;\n entry = ( srec_data_list_type * ) bfd_alloc ( abfd , sizeof ( * entry ) ) ;\n if ( entry == NULL ) return FALSE ;\n if ( bytes_to_do && ( section -> flags & SEC_ALLOC ) && ( section -> flags & SEC_LOAD ) ) {\n bfd_byte * data ;\n data = ( bfd_byte * ) bfd_alloc ( abfd , bytes_to_do ) ;\n if ( data == NULL ) return FALSE ;\n memcpy ( ( void * ) data , location , ( size_t ) bytes_to_do ) ;\n if ( S3Forced ) tdata -> type = 3 ;\n else if ( ( section -> lma + ( offset + bytes_to_do ) / opb - 1 ) <= 0xffff ) ;\n else if ( ( section -> lma + ( offset + bytes_to_do ) / opb - 1 ) <= 0xffffff && tdata -> type <= 2 ) tdata -> type = 2 ;\n else tdata -> type = 3 ;\n entry -> data = data ;\n entry -> where = section -> lma + offset / opb ;\n entry -> size = bytes_to_do ;\n if ( tdata -> tail != NULL && entry -> where >= tdata -> tail -> where ) {\n tdata -> tail -> next = entry ;\n entry -> next = NULL ;\n tdata -> tail = entry ;\n }\n else {\n srec_data_list_type * * look ;\n for ( look = & tdata -> head ;\n * look != NULL && ( * look ) -> where < entry -> where ;\n look = & ( * look ) -> next ) ;\n entry -> next = * look ;\n * look = entry ;\n if ( entry -> next == NULL ) tdata -> tail = entry ;\n }\n }\n return TRUE ;\n }", "hash": -8638406710431929037, "project": "debian", "size": 35, "target": 0, "idx": 6505}
{"code": "static PyObject * string_isdigit ( PyStringObject * self ) {\n register const unsigned char * p = ( unsigned char * ) PyString_AS_STRING ( self ) ;\n register const unsigned char * e ;\n if ( PyString_GET_SIZE ( self ) == 1 && isdigit ( * p ) ) return PyBool_FromLong ( 1 ) ;\n if ( PyString_GET_SIZE ( self ) == 0 ) return PyBool_FromLong ( 0 ) ;\n e = p + PyString_GET_SIZE ( self ) ;\n for ( ;\n p < e ;\n p ++ ) {\n if ( ! isdigit ( * p ) ) return PyBool_FromLong ( 0 ) ;\n }\n return PyBool_FromLong ( 1 ) ;\n }", "hash": -4555950263653671147, "project": "debian", "size": 13, "target": 0, "idx": 6529}
{"code": "PyObject * PyString_AsEncodedObject ( PyObject * str , const char * encoding , const char * errors ) {\n PyObject * v ;\n if ( ! PyString_Check ( str ) ) {\n PyErr_BadArgument ( ) ;\n goto onError ;\n }\n if ( encoding == NULL ) {\n # ifdef Py_USING_UNICODE encoding = PyUnicode_GetDefaultEncoding ( ) ;\n # else PyErr_SetString ( PyExc_ValueError , \"no encoding specified\" ) ;\n goto onError ;\n # endif }\n v = _PyCodec_EncodeText ( str , encoding , errors ) ;\n if ( v == NULL ) goto onError ;\n return v ;\n onError : return NULL ;\n }", "hash": -4555950263653671147, "project": "debian", "size": 16, "target": 0, "idx": 6533}
{"code": "static Py_ssize_t string_length ( PyStringObject * a ) {\n return Py_SIZE ( a ) ;\n }", "hash": -4555950263653671147, "project": "debian", "size": 3, "target": 0, "idx": 6548}
{"code": "PyObject * PyString_Encode ( const char * s , Py_ssize_t size , const char * encoding , const char * errors ) {\n PyObject * v , * str ;\n str = PyString_FromStringAndSize ( s , size ) ;\n if ( str == NULL ) return NULL ;\n v = PyString_AsEncodedString ( str , encoding , errors ) ;\n Py_DECREF ( str ) ;\n return v ;\n }", "hash": -4555950263653671147, "project": "debian", "size": 8, "target": 0, "idx": 6555}
{"code": "static PyObject * string__format__ ( PyObject * self , PyObject * args ) {\n PyObject * format_spec ;\n PyObject * result = NULL ;\n PyObject * tmp = NULL ;\n if ( ! PyArg_ParseTuple ( args , \"O:__format__\" , & format_spec ) ) goto done ;\n if ( ! ( PyString_Check ( format_spec ) || PyUnicode_Check ( format_spec ) ) ) {\n PyErr_Format ( PyExc_TypeError , \"__format__ arg must be str \" \"or unicode, not %s\" , Py_TYPE ( format_spec ) -> tp_name ) ;\n goto done ;\n }\n tmp = PyObject_Str ( format_spec ) ;\n if ( tmp == NULL ) goto done ;\n format_spec = tmp ;\n result = _PyBytes_FormatAdvanced ( self , PyString_AS_STRING ( format_spec ) , PyString_GET_SIZE ( format_spec ) ) ;\n done : Py_XDECREF ( tmp ) ;\n return result ;\n }", "hash": -4555950263653671147, "project": "debian", "size": 16, "target": 0, "idx": 6562}
{"code": "static PyObject * string_mod ( PyObject * v , PyObject * w ) {\n if ( ! PyString_Check ( v ) ) {\n Py_INCREF ( Py_NotImplemented ) ;\n return Py_NotImplemented ;\n }\n return PyString_Format ( v , w ) ;\n }", "hash": -4555950263653671147, "project": "debian", "size": 7, "target": 0, "idx": 6566}
{"code": "Py_ssize_t PyString_Size ( register PyObject * op ) {\n if ( ! PyString_Check ( op ) ) return string_getsize ( op ) ;\n return Py_SIZE ( op ) ;\n }", "hash": -4555950263653671147, "project": "debian", "size": 4, "target": 0, "idx": 6575}
{"code": "static Py_ssize_t string_buffer_getreadbuf ( PyStringObject * self , Py_ssize_t index , const void * * ptr ) {\n if ( index != 0 ) {\n PyErr_SetString ( PyExc_SystemError , \"accessing non-existent string segment\" ) ;\n return - 1 ;\n }\n * ptr = ( void * ) self -> ob_sval ;\n return Py_SIZE ( self ) ;\n }", "hash": -4555950263653671147, "project": "debian", "size": 8, "target": 0, "idx": 6579}
{"code": "PyObject * PyString_AsEncodedString ( PyObject * str , const char * encoding , const char * errors ) {\n PyObject * v ;\n v = PyString_AsEncodedObject ( str , encoding , errors ) ;\n if ( v == NULL ) goto onError ;\n # ifdef Py_USING_UNICODE if ( PyUnicode_Check ( v ) ) {\n PyObject * temp = v ;\n v = PyUnicode_AsEncodedString ( v , NULL , NULL ) ;\n Py_DECREF ( temp ) ;\n if ( v == NULL ) goto onError ;\n }\n # endif if ( ! PyString_Check ( v ) ) {\n PyErr_Format ( PyExc_TypeError , \"encoder did not return a string object (type=%.400s)\" , Py_TYPE ( v ) -> tp_name ) ;\n Py_DECREF ( v ) ;\n goto onError ;\n }\n return v ;\n onError : return NULL ;\n }", "hash": -4555950263653671147, "project": "debian", "size": 18, "target": 0, "idx": 6581}
{"code": "char * PyString_AsString ( register PyObject * op ) {\n if ( ! PyString_Check ( op ) ) return string_getbuffer ( op ) ;\n return ( ( PyStringObject * ) op ) -> ob_sval ;\n }", "hash": -4555950263653671147, "project": "debian", "size": 4, "target": 0, "idx": 6583}
{"code": "static void dump_ah_combs ( struct sk_buff * skb , const struct xfrm_tmpl * t ) {\n struct sadb_prop * p ;\n int i ;\n p = ( struct sadb_prop * ) skb_put ( skb , sizeof ( struct sadb_prop ) ) ;\n p -> sadb_prop_len = sizeof ( struct sadb_prop ) / 8 ;\n p -> sadb_prop_exttype = SADB_EXT_PROPOSAL ;\n p -> sadb_prop_replay = 32 ;\n memset ( p -> sadb_prop_reserved , 0 , sizeof ( p -> sadb_prop_reserved ) ) ;\n for ( i = 0 ;\n ;\n i ++ ) {\n const struct xfrm_algo_desc * aalg = xfrm_aalg_get_byidx ( i ) ;\n if ( ! aalg ) break ;\n if ( ! aalg -> pfkey_supported ) continue ;\n if ( aalg_tmpl_set ( t , aalg ) && aalg -> available ) {\n struct sadb_comb * c ;\n c = ( struct sadb_comb * ) skb_put ( skb , sizeof ( struct sadb_comb ) ) ;\n memset ( c , 0 , sizeof ( * c ) ) ;\n p -> sadb_prop_len += sizeof ( struct sadb_comb ) / 8 ;\n c -> sadb_comb_auth = aalg -> desc . sadb_alg_id ;\n c -> sadb_comb_auth_minbits = aalg -> desc . sadb_alg_minbits ;\n c -> sadb_comb_auth_maxbits = aalg -> desc . sadb_alg_maxbits ;\n c -> sadb_comb_hard_addtime = 24 * 60 * 60 ;\n c -> sadb_comb_soft_addtime = 20 * 60 * 60 ;\n c -> sadb_comb_hard_usetime = 8 * 60 * 60 ;\n c -> sadb_comb_soft_usetime = 7 * 60 * 60 ;\n }\n }\n }", "hash": 8572106347813672436, "project": "debian", "size": 29, "target": 0, "idx": 6632}
{"code": "static int pfkey_sockaddr_extract ( const struct sockaddr * sa , xfrm_address_t * xaddr ) {\n switch ( sa -> sa_family ) {\n case AF_INET : xaddr -> a4 = ( ( struct sockaddr_in * ) sa ) -> sin_addr . s_addr ;\n return AF_INET ;\n # if IS_ENABLED ( CONFIG_IPV6 ) case AF_INET6 : memcpy ( xaddr -> a6 , & ( ( struct sockaddr_in6 * ) sa ) -> sin6_addr , sizeof ( struct in6_addr ) ) ;\n return AF_INET6 ;\n # endif }\n return 0 ;\n }", "hash": 8572106347813672436, "project": "debian", "size": 9, "target": 0, "idx": 6634}
{"code": "static inline struct xfrm_user_sec_ctx * pfkey_sadb2xfrm_user_sec_ctx ( const struct sadb_x_sec_ctx * sec_ctx ) {\n struct xfrm_user_sec_ctx * uctx = NULL ;\n int ctx_size = sec_ctx -> sadb_x_ctx_len ;\n uctx = kmalloc ( ( sizeof ( * uctx ) + ctx_size ) , GFP_KERNEL ) ;\n if ( ! uctx ) return NULL ;\n uctx -> len = pfkey_sec_ctx_len ( sec_ctx ) ;\n uctx -> exttype = sec_ctx -> sadb_x_sec_exttype ;\n uctx -> ctx_doi = sec_ctx -> sadb_x_ctx_doi ;\n uctx -> ctx_alg = sec_ctx -> sadb_x_ctx_alg ;\n uctx -> ctx_len = sec_ctx -> sadb_x_ctx_len ;\n memcpy ( uctx + 1 , sec_ctx + 1 , uctx -> ctx_len ) ;\n return uctx ;\n }", "hash": 8572106347813672436, "project": "debian", "size": 13, "target": 0, "idx": 6643}
{"code": "static struct sadb_msg * pfkey_get_base_msg ( struct sk_buff * skb , int * errp ) {\n struct sadb_msg * hdr = NULL ;\n if ( skb -> len < sizeof ( * hdr ) ) {\n * errp = - EMSGSIZE ;\n }\n else {\n hdr = ( struct sadb_msg * ) skb -> data ;\n if ( hdr -> sadb_msg_version != PF_KEY_V2 || hdr -> sadb_msg_reserved != 0 || ( hdr -> sadb_msg_type <= SADB_RESERVED || hdr -> sadb_msg_type > SADB_MAX ) ) {\n hdr = NULL ;\n * errp = - EINVAL ;\n }\n else if ( hdr -> sadb_msg_len != ( skb -> len / sizeof ( uint64_t ) ) || hdr -> sadb_msg_len < ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ) {\n hdr = NULL ;\n * errp = - EMSGSIZE ;\n }\n else {\n * errp = 0 ;\n }\n }\n return hdr ;\n }", "hash": 8572106347813672436, "project": "debian", "size": 21, "target": 0, "idx": 6673}
{"code": "static int key_notify_sa_expire ( struct xfrm_state * x , const struct km_event * c ) {\n struct sk_buff * out_skb ;\n struct sadb_msg * out_hdr ;\n int hard ;\n int hsc ;\n hard = c -> data . hard ;\n if ( hard ) hsc = 2 ;\n else hsc = 1 ;\n out_skb = pfkey_xfrm_state2msg_expire ( x , hsc ) ;\n if ( IS_ERR ( out_skb ) ) return PTR_ERR ( out_skb ) ;\n out_hdr = ( struct sadb_msg * ) out_skb -> data ;\n out_hdr -> sadb_msg_version = PF_KEY_V2 ;\n out_hdr -> sadb_msg_type = SADB_EXPIRE ;\n out_hdr -> sadb_msg_satype = pfkey_proto2satype ( x -> id . proto ) ;\n out_hdr -> sadb_msg_errno = 0 ;\n out_hdr -> sadb_msg_reserved = 0 ;\n out_hdr -> sadb_msg_seq = 0 ;\n out_hdr -> sadb_msg_pid = 0 ;\n pfkey_broadcast ( out_skb , GFP_ATOMIC , BROADCAST_REGISTERED , NULL , xs_net ( x ) ) ;\n return 0 ;\n }", "hash": 8572106347813672436, "project": "debian", "size": 21, "target": 0, "idx": 6681}
{"code": "static int pfkey_release ( struct socket * sock ) {\n struct sock * sk = sock -> sk ;\n if ( ! sk ) return 0 ;\n pfkey_remove ( sk ) ;\n sock_orphan ( sk ) ;\n sock -> sk = NULL ;\n skb_queue_purge ( & sk -> sk_write_queue ) ;\n synchronize_rcu ( ) ;\n sock_put ( sk ) ;\n return 0 ;\n }", "hash": 8572106347813672436, "project": "debian", "size": 11, "target": 0, "idx": 6690}
{"code": "static void ossl_x509name_free ( void * ptr ) {\n X509_NAME_free ( ptr ) ;\n }", "hash": 5651124822185017997, "project": "debian", "size": 3, "target": 0, "idx": 6704}
{"code": "static void cirrus_update_memory_access ( CirrusVGAState * s ) {\n unsigned mode ;\n memory_region_transaction_begin ( ) ;\n if ( ( s -> vga . sr [ 0x17 ] & 0x44 ) == 0x44 ) {\n goto generic_io ;\n }\n else if ( s -> cirrus_srcptr != s -> cirrus_srcptr_end ) {\n goto generic_io ;\n }\n else {\n if ( ( s -> vga . gr [ 0x0B ] & 0x14 ) == 0x14 ) {\n goto generic_io ;\n }\n else if ( s -> vga . gr [ 0x0B ] & 0x02 ) {\n goto generic_io ;\n }\n mode = s -> vga . gr [ 0x05 ] & 0x7 ;\n if ( mode < 4 || mode > 5 || ( ( s -> vga . gr [ 0x0B ] & 0x4 ) == 0 ) ) {\n map_linear_vram ( s ) ;\n }\n else {\n generic_io : unmap_linear_vram ( s ) ;\n }\n }\n memory_region_transaction_commit ( ) ;\n }", "hash": -8933711118846965366, "project": "debian", "size": 26, "target": 0, "idx": 6731}
{"code": "static void cirrus_vga_ioport_write ( void * opaque , hwaddr addr , uint64_t val , unsigned size ) {\n CirrusVGAState * c = opaque ;\n VGACommonState * s = & c -> vga ;\n int index ;\n addr += 0x3b0 ;\n if ( vga_ioport_invalid ( s , addr ) ) {\n return ;\n }\n trace_vga_cirrus_write_io ( addr , val ) ;\n switch ( addr ) {\n case 0x3c0 : if ( s -> ar_flip_flop == 0 ) {\n val &= 0x3f ;\n s -> ar_index = val ;\n }\n else {\n index = s -> ar_index & 0x1f ;\n switch ( index ) {\n case 0x00 ... 0x0f : s -> ar [ index ] = val & 0x3f ;\n break ;\n case 0x10 : s -> ar [ index ] = val & ~ 0x10 ;\n break ;\n case 0x11 : s -> ar [ index ] = val ;\n break ;\n case 0x12 : s -> ar [ index ] = val & ~ 0xc0 ;\n break ;\n case 0x13 : s -> ar [ index ] = val & ~ 0xf0 ;\n break ;\n case 0x14 : s -> ar [ index ] = val & ~ 0xf0 ;\n break ;\n default : break ;\n }\n }\n s -> ar_flip_flop ^= 1 ;\n break ;\n case 0x3c2 : s -> msr = val & ~ 0x10 ;\n s -> update_retrace_info ( s ) ;\n break ;\n case 0x3c4 : s -> sr_index = val ;\n break ;\n case 0x3c5 : # ifdef DEBUG_VGA_REG printf ( \"vga: write SR%x = 0x%02\" PRIu64 \"\\n\" , s -> sr_index , val ) ;\n # endif cirrus_vga_write_sr ( c , val ) ;\n break ;\n case 0x3c6 : cirrus_write_hidden_dac ( c , val ) ;\n break ;\n case 0x3c7 : s -> dac_read_index = val ;\n s -> dac_sub_index = 0 ;\n s -> dac_state = 3 ;\n break ;\n case 0x3c8 : s -> dac_write_index = val ;\n s -> dac_sub_index = 0 ;\n s -> dac_state = 0 ;\n break ;\n case 0x3c9 : cirrus_vga_write_palette ( c , val ) ;\n break ;\n case 0x3ce : s -> gr_index = val ;\n break ;\n case 0x3cf : # ifdef DEBUG_VGA_REG printf ( \"vga: write GR%x = 0x%02\" PRIu64 \"\\n\" , s -> gr_index , val ) ;\n # endif cirrus_vga_write_gr ( c , s -> gr_index , val ) ;\n break ;\n case 0x3b4 : case 0x3d4 : s -> cr_index = val ;\n break ;\n case 0x3b5 : case 0x3d5 : # ifdef DEBUG_VGA_REG printf ( \"vga: write CR%x = 0x%02\" PRIu64 \"\\n\" , s -> cr_index , val ) ;\n # endif cirrus_vga_write_cr ( c , val ) ;\n break ;\n case 0x3ba : case 0x3da : s -> fcr = val & 0x10 ;\n break ;\n }\n }", "hash": -8933711118846965366, "project": "debian", "size": 68, "target": 0, "idx": 6740}
{"code": "static void cirrus_mmio_write ( void * opaque , hwaddr addr , uint64_t val , unsigned size ) {\n CirrusVGAState * s = opaque ;\n if ( addr >= 0x100 ) {\n cirrus_mmio_blt_write ( s , addr - 0x100 , val ) ;\n }\n else {\n cirrus_vga_ioport_write ( s , addr + 0x10 , val , size ) ;\n }\n }", "hash": -8933711118846965366, "project": "debian", "size": 9, "target": 0, "idx": 6742}
{"code": "static void execve_shell ( const char * shellname , char * args [ ] , char * const envp [ ] ) {\n int err ;\n ( void ) execve ( shellname , ( char * * ) args , envp ) ;\n err = errno ;\n if ( access ( shellname , R_OK | X_OK ) == 0 ) {\n size_t n_args = 0 ;\n char * * targs ;\n while ( NULL != args [ n_args ] ) {\n n_args ++ ;\n }\n targs = ( char * * ) xmalloc ( ( n_args + 3 ) * sizeof ( args [ 0 ] ) ) ;\n targs [ 0 ] = \"sh\" ;\n targs [ 1 ] = \"-\" ;\n targs [ 2 ] = xstrdup ( shellname ) ;\n targs [ n_args + 2 ] = NULL ;\n while ( 1 != n_args ) {\n targs [ n_args + 1 ] = args [ n_args - 1 ] ;\n n_args -- ;\n }\n ( void ) execve ( SHELL , targs , envp ) ;\n }\n else {\n errno = err ;\n }\n }", "hash": -5968890769755017734, "project": "debian", "size": 25, "target": 0, "idx": 6781}
{"code": "static kadm5_ret_t validate_allowed_keysalts ( const char * allowed_keysalts ) {\n kadm5_ret_t ret ;\n krb5_key_salt_tuple * ks_tuple = NULL ;\n krb5_int32 n_ks_tuple = 0 ;\n if ( strchr ( allowed_keysalts , '\\t' ) != NULL ) return KADM5_BAD_KEYSALTS ;\n ret = krb5_string_to_keysalts ( allowed_keysalts , \",\" , \":.-\" , 0 , & ks_tuple , & n_ks_tuple ) ;\n free ( ks_tuple ) ;\n if ( ret == EINVAL ) return KADM5_BAD_KEYSALTS ;\n return ret ;\n }", "hash": -6986708248145981986, "project": "debian", "size": 10, "target": 0, "idx": 6790}
{"code": "void kadmin_addpol ( int argc , char * argv [ ] ) {\n krb5_error_code retval ;\n long mask ;\n kadm5_policy_ent_rec policy ;\n memset ( & policy , 0 , sizeof ( policy ) ) ;\n if ( kadmin_parse_policy_args ( argc , argv , & policy , & mask , \"add_policy\" ) ) {\n kadmin_addmodpol_usage ( \"add_policy\" ) ;\n return ;\n }\n policy . policy = argv [ argc - 1 ] ;\n mask |= KADM5_POLICY ;\n retval = kadm5_create_policy ( handle , & policy , mask ) ;\n if ( retval ) {\n com_err ( \"add_policy\" , retval , _ ( \"while creating policy \\\"%s\\\".\" ) , policy . policy ) ;\n }\n }", "hash": 1676654288894940649, "project": "debian", "size": 16, "target": 0, "idx": 6819}
{"code": "static void kadmin_addprinc_usage ( ) {\n fprintf ( stderr , _ ( \"usage: add_principal [options] principal\\n\" ) ) ;\n fprintf ( stderr , _ ( \"\\toptions are:\\n\" ) ) ;\n fprintf ( stderr , _ ( \"\\t\\t[-x db_princ_args]* [-expire expdate] \" \"[-pwexpire pwexpdate] [-maxlife maxtixlife]\\n\" \"\\t\\t[-kvno kvno] [-policy policy] [-clearpolicy] [-randkey]\\n\" \"\\t\\t[-pw password] [-maxrenewlife maxrenewlife]\\n\" \"\\t\\t[-e keysaltlist]\\n\\t\\t[{\n+|-}\nattribute]\\n\" ) ) ;\n fprintf ( stderr , _ ( \"\\tattributes are:\\n\" ) ) ;\n fprintf ( stderr , _ ( \"\\t\\tallow_postdated allow_forwardable allow_tgs_req \" \"allow_renewable\\n\" \"\\t\\tallow_proxiable allow_dup_skey allow_tix requires_preauth\\n\" \"\\t\\trequires_hwauth needchange allow_svr \" \"password_changing_service\\n\" \"\\t\\tok_as_delegate ok_to_auth_as_delegate \" \"no_auth_data_required\\n\" \"\\nwhere,\\n\\t[-x db_princ_args]* - any number of database \" \"specific arguments.\\n\" \"\\t\\t\\tLook at each database documentation for supported \" \"arguments\\n\" ) ) ;\n }", "hash": 1676654288894940649, "project": "debian", "size": 9, "target": 0, "idx": 6822}
{"code": "void kadmin_renameprinc ( int argc , char * argv [ ] ) {\n kadm5_ret_t retval ;\n krb5_principal oprinc = NULL , nprinc = NULL ;\n char * ocanon = NULL , * ncanon = NULL ;\n char reply [ 5 ] ;\n if ( ! ( argc == 3 || ( argc == 4 && ! strcmp ( \"-force\" , argv [ 1 ] ) ) ) ) {\n fprintf ( stderr , _ ( \"usage: rename_principal [-force] old_principal \" \"new_principal\\n\" ) ) ;\n return ;\n }\n retval = kadmin_parse_name ( argv [ argc - 2 ] , & oprinc ) ;\n if ( retval ) {\n com_err ( \"rename_principal\" , retval , _ ( \"while parsing old principal name\" ) ) ;\n goto cleanup ;\n }\n retval = kadmin_parse_name ( argv [ argc - 1 ] , & nprinc ) ;\n if ( retval ) {\n com_err ( \"rename_principal\" , retval , _ ( \"while parsing new principal name\" ) ) ;\n goto cleanup ;\n }\n retval = krb5_unparse_name ( context , oprinc , & ocanon ) ;\n if ( retval ) {\n com_err ( \"rename_principal\" , retval , _ ( \"while canonicalizing old principal\" ) ) ;\n goto cleanup ;\n }\n retval = krb5_unparse_name ( context , nprinc , & ncanon ) ;\n if ( retval ) {\n com_err ( \"rename_principal\" , retval , _ ( \"while canonicalizing new principal\" ) ) ;\n goto cleanup ;\n }\n if ( argc == 3 ) {\n printf ( _ ( \"Are you sure you want to rename the principal \\\"%s\\\" \" \"to \\\"%s\\\"? (yeso): \" ) , ocanon , ncanon ) ;\n fgets ( reply , sizeof ( reply ) , stdin ) ;\n if ( strcmp ( \"yes\\n\" , reply ) ) {\n fprintf ( stderr , _ ( \"Principal \\\"%s\\\" not renamed\\n\" ) , ocanon ) ;\n goto cleanup ;\n }\n }\n retval = kadm5_rename_principal ( handle , oprinc , nprinc ) ;\n if ( retval ) {\n com_err ( \"rename_principal\" , retval , _ ( \"while renaming principal \\\"%s\\\" to \\\"%s\\\"\" ) , ocanon , ncanon ) ;\n goto cleanup ;\n }\n printf ( _ ( \"Principal \\\"%s\\\" renamed to \\\"%s\\\".\\n\" ) , ocanon , ncanon ) ;\n printf ( _ ( \"Make sure that you have removed the old principal from all ACLs \" \"before reusing.\\n\" ) ) ;\n cleanup : krb5_free_principal ( context , nprinc ) ;\n krb5_free_principal ( context , oprinc ) ;\n free ( ncanon ) ;\n free ( ocanon ) ;\n }", "hash": 1676654288894940649, "project": "debian", "size": 49, "target": 0, "idx": 6824}
{"code": "static int kadmin_parse_princ_args ( int argc , char * argv [ ] , kadm5_principal_ent_t oprinc , long * mask , char * * pass , krb5_boolean * randkey , krb5_key_salt_tuple * * ks_tuple , int * n_ks_tuple , char * caller ) {\n int i , attrib_set ;\n size_t j ;\n time_t date ;\n time_t now ;\n krb5_error_code retval ;\n * mask = 0 ;\n * pass = NULL ;\n * n_ks_tuple = 0 ;\n * ks_tuple = NULL ;\n time ( & now ) ;\n * randkey = FALSE ;\n for ( i = 1 ;\n i < argc - 1 ;\n i ++ ) {\n attrib_set = 0 ;\n if ( ! strcmp ( \"-x\" , argv [ i ] ) ) {\n if ( ++ i > argc - 2 ) return - 1 ;\n add_tl_data ( & oprinc -> n_tl_data , & oprinc -> tl_data , KRB5_TL_DB_ARGS , strlen ( argv [ i ] ) + 1 , ( krb5_octet * ) argv [ i ] ) ;\n * mask |= KADM5_TL_DATA ;\n continue ;\n }\n if ( ! strcmp ( \"-expire\" , argv [ i ] ) ) {\n if ( ++ i > argc - 2 ) return - 1 ;\n date = get_date ( argv [ i ] ) ;\n if ( date == ( time_t ) - 1 ) {\n fprintf ( stderr , _ ( \"Invalid date specification \\\"%s\\\".\\n\" ) , argv [ i ] ) ;\n return - 1 ;\n }\n oprinc -> princ_expire_time = date ;\n * mask |= KADM5_PRINC_EXPIRE_TIME ;\n continue ;\n }\n if ( ! strcmp ( \"-pwexpire\" , argv [ i ] ) ) {\n if ( ++ i > argc - 2 ) return - 1 ;\n date = get_date ( argv [ i ] ) ;\n if ( date == ( time_t ) - 1 ) {\n fprintf ( stderr , _ ( \"Invalid date specification \\\"%s\\\".\\n\" ) , argv [ i ] ) ;\n return - 1 ;\n }\n oprinc -> pw_expiration = date ;\n * mask |= KADM5_PW_EXPIRATION ;\n continue ;\n }\n if ( ! strcmp ( \"-maxlife\" , argv [ i ] ) ) {\n if ( ++ i > argc - 2 ) return - 1 ;\n date = get_date ( argv [ i ] ) ;\n if ( date == ( time_t ) - 1 ) {\n fprintf ( stderr , _ ( \"Invalid date specification \\\"%s\\\".\\n\" ) , argv [ i ] ) ;\n return - 1 ;\n }\n oprinc -> max_life = date - now ;\n * mask |= KADM5_MAX_LIFE ;\n continue ;\n }\n if ( ! strcmp ( \"-maxrenewlife\" , argv [ i ] ) ) {\n if ( ++ i > argc - 2 ) return - 1 ;\n date = get_date ( argv [ i ] ) ;\n if ( date == ( time_t ) - 1 ) {\n fprintf ( stderr , _ ( \"Invalid date specification \\\"%s\\\".\\n\" ) , argv [ i ] ) ;\n return - 1 ;\n }\n oprinc -> max_renewable_life = date - now ;\n * mask |= KADM5_MAX_RLIFE ;\n continue ;\n }\n if ( ! strcmp ( \"-kvno\" , argv [ i ] ) ) {\n if ( ++ i > argc - 2 ) return - 1 ;\n oprinc -> kvno = atoi ( argv [ i ] ) ;\n * mask |= KADM5_KVNO ;\n continue ;\n }\n if ( ! strcmp ( \"-policy\" , argv [ i ] ) ) {\n if ( ++ i > argc - 2 ) return - 1 ;\n oprinc -> policy = argv [ i ] ;\n * mask |= KADM5_POLICY ;\n continue ;\n }\n if ( ! strcmp ( \"-clearpolicy\" , argv [ i ] ) ) {\n oprinc -> policy = NULL ;\n * mask |= KADM5_POLICY_CLR ;\n continue ;\n }\n if ( ! strcmp ( \"-pw\" , argv [ i ] ) ) {\n if ( ++ i > argc - 2 ) return - 1 ;\n * pass = argv [ i ] ;\n continue ;\n }\n if ( ! strcmp ( \"-randkey\" , argv [ i ] ) ) {\n * randkey = TRUE ;\n continue ;\n }\n if ( ! strcmp ( \"-unlock\" , argv [ i ] ) ) {\n unlock_princ ( oprinc , mask , caller ) ;\n continue ;\n }\n if ( ! strcmp ( \"-e\" , argv [ i ] ) ) {\n if ( ++ i > argc - 2 ) return - 1 ;\n retval = krb5_string_to_keysalts ( argv [ i ] , \", \\t\" , \":.-\" , 0 , ks_tuple , n_ks_tuple ) ;\n if ( retval ) {\n com_err ( caller , retval , _ ( \"while parsing keysalts %s\" ) , argv [ i ] ) ;\n return - 1 ;\n }\n continue ;\n }\n for ( j = 0 ;\n j < sizeof ( flags ) / sizeof ( struct pflag ) ;\n j ++ ) {\n if ( strlen ( argv [ i ] ) == flags [ j ] . flaglen + 1 && ! strcmp ( flags [ j ] . flagname , & argv [ i ] [ 1 ] ) ) {\n if ( ( flags [ j ] . set && argv [ i ] [ 0 ] == '-' ) || ( ! flags [ j ] . set && argv [ i ] [ 0 ] == '+' ) ) {\n oprinc -> attributes |= flags [ j ] . theflag ;\n * mask |= KADM5_ATTRIBUTES ;\n attrib_set ++ ;\n break ;\n }\n else if ( ( flags [ j ] . set && argv [ i ] [ 0 ] == '+' ) || ( ! flags [ j ] . set && argv [ i ] [ 0 ] == '-' ) ) {\n oprinc -> attributes &= ~ flags [ j ] . theflag ;\n * mask |= KADM5_ATTRIBUTES ;\n attrib_set ++ ;\n break ;\n }\n else {\n return - 1 ;\n }\n }\n }\n if ( ! attrib_set ) return - 1 ;\n }\n if ( i != argc - 1 ) return - 1 ;\n retval = kadmin_parse_name ( argv [ i ] , & oprinc -> principal ) ;\n if ( retval ) {\n com_err ( caller , retval , _ ( \"while parsing principal\" ) ) ;\n return - 1 ;\n }\n return 0 ;\n }", "hash": 1676654288894940649, "project": "debian", "size": 136, "target": 0, "idx": 6825}
{"code": "void mpi_set ( MPI w , MPI u ) {\n mpi_ptr_t wp , up ;\n mpi_size_t usize = u -> nlimbs ;\n int usign = u -> sign ;\n RESIZE_IF_NEEDED ( w , usize ) ;\n wp = w -> d ;\n up = u -> d ;\n MPN_COPY ( wp , up , usize ) ;\n w -> nlimbs = usize ;\n w -> nbits = u -> nbits ;\n w -> flags = u -> flags ;\n w -> sign = usign ;\n }", "hash": -4552633429382740307, "project": "debian", "size": 13, "target": 0, "idx": 6852}
{"code": "int mpi_is_neg ( MPI a ) {\n return a -> sign ;\n }", "hash": -4552633429382740307, "project": "debian", "size": 3, "target": 0, "idx": 6858}
{"code": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens ) ;\n DECL_PIOCTL ( PUnlog ) ;\n DECL_PIOCTL ( PMariner ) ;\n DECL_PIOCTL ( PCheckServers ) ;\n DECL_PIOCTL ( PCheckVolNames ) ;\n DECL_PIOCTL ( PCheckAuth ) ;\n DECL_PIOCTL ( PFindVolume ) ;\n DECL_PIOCTL ( PViceAccess ) ;\n DECL_PIOCTL ( PSetCacheSize ) ;\n DECL_PIOCTL ( PGetCacheSize ) ;\n DECL_PIOCTL ( PRemoveCallBack ) ;\n DECL_PIOCTL ( PNewCell ) ;\n DECL_PIOCTL ( PNewAlias ) ;\n DECL_PIOCTL ( PListCells ) ;\n DECL_PIOCTL ( PListAliases ) ;\n DECL_PIOCTL ( PRemoveMount ) ;\n DECL_PIOCTL ( PGetCellStatus ) ;\n DECL_PIOCTL ( PSetCellStatus ) ;\n DECL_PIOCTL ( PFlushVolumeData ) ;\n DECL_PIOCTL ( PFlushAllVolumeData ) ;\n DECL_PIOCTL ( PGetVnodeXStatus ) ;\n DECL_PIOCTL ( PGetVnodeXStatus2 ) ;\n DECL_PIOCTL ( PSetSysName ) ;\n DECL_PIOCTL ( PSetSPrefs ) ;\n DECL_PIOCTL ( PSetSPrefs33 ) ;\n DECL_PIOCTL ( PGetSPrefs ) ;\n DECL_PIOCTL ( PExportAfs ) ;\n DECL_PIOCTL ( PGag ) ;\n DECL_PIOCTL ( PTwiddleRx ) ;\n DECL_PIOCTL ( PGetInitParams ) ;\n DECL_PIOCTL ( PGetRxkcrypt ) ;\n DECL_PIOCTL ( PSetRxkcrypt ) ;\n DECL_PIOCTL ( PGetCPrefs ) ;\n DECL_PIOCTL ( PSetCPrefs ) ;\n DECL_PIOCTL ( PFlushMount ) ;\n DECL_PIOCTL ( PRxStatProc ) ;\n DECL_PIOCTL ( PRxStatPeer ) ;\n DECL_PIOCTL ( PPrefetchFromTape )", "hash": -3053641395158209010, "project": "debian", "size": 53, "target": 0, "idx": 6870}
{"code": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens ) ;\n DECL_PIOCTL ( PUnlog ) ;\n DECL_PIOCTL ( PMariner ) ;\n DECL_PIOCTL ( PCheckServers ) ;\n DECL_PIOCTL ( PCheckVolNames ) ;\n DECL_PIOCTL ( PCheckAuth ) ;\n DECL_PIOCTL ( PFindVolume ) ;\n DECL_PIOCTL ( PViceAccess ) ;\n DECL_PIOCTL ( PSetCacheSize ) ;\n DECL_PIOCTL ( PGetCacheSize ) ;\n DECL_PIOCTL ( PRemoveCallBack ) ;\n DECL_PIOCTL ( PNewCell ) ;\n DECL_PIOCTL ( PNewAlias ) ;\n DECL_PIOCTL ( PListCells ) ;\n DECL_PIOCTL ( PListAliases ) ;\n DECL_PIOCTL ( PRemoveMount ) ;\n DECL_PIOCTL ( PGetCellStatus ) ;\n DECL_PIOCTL ( PSetCellStatus ) ;\n DECL_PIOCTL ( PFlushVolumeData ) ;\n DECL_PIOCTL ( PFlushAllVolumeData ) ;\n DECL_PIOCTL ( PGetVnodeXStatus ) ;\n DECL_PIOCTL ( PGetVnodeXStatus2 ) ;\n DECL_PIOCTL ( PSetSysName ) ;\n DECL_PIOCTL ( PSetSPrefs ) ;\n DECL_PIOCTL ( PSetSPrefs33 ) ;\n DECL_PIOCTL ( PGetSPrefs ) ;\n DECL_PIOCTL ( PExportAfs ) ;\n DECL_PIOCTL ( PGag ) ;\n DECL_PIOCTL ( PTwiddleRx ) ;\n DECL_PIOCTL ( PGetInitParams ) ;\n DECL_PIOCTL ( PGetRxkcrypt ) ;\n DECL_PIOCTL ( PSetRxkcrypt ) ;\n DECL_PIOCTL ( PGetCPrefs ) ;\n DECL_PIOCTL ( PSetCPrefs )", "hash": -3053641395158209010, "project": "debian", "size": 49, "target": 0, "idx": 6873}
{"code": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens )", "hash": -3053641395158209010, "project": "debian", "size": 16, "target": 0, "idx": 6876}
{"code": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens ) ;\n DECL_PIOCTL ( PUnlog ) ;\n DECL_PIOCTL ( PMariner ) ;\n DECL_PIOCTL ( PCheckServers ) ;\n DECL_PIOCTL ( PCheckVolNames ) ;\n DECL_PIOCTL ( PCheckAuth ) ;\n DECL_PIOCTL ( PFindVolume ) ;\n DECL_PIOCTL ( PViceAccess ) ;\n DECL_PIOCTL ( PSetCacheSize ) ;\n DECL_PIOCTL ( PGetCacheSize ) ;\n DECL_PIOCTL ( PRemoveCallBack ) ;\n DECL_PIOCTL ( PNewCell ) ;\n DECL_PIOCTL ( PNewAlias ) ;\n DECL_PIOCTL ( PListCells ) ;\n DECL_PIOCTL ( PListAliases ) ;\n DECL_PIOCTL ( PRemoveMount ) ;\n DECL_PIOCTL ( PGetCellStatus ) ;\n DECL_PIOCTL ( PSetCellStatus ) ;\n DECL_PIOCTL ( PFlushVolumeData ) ;\n DECL_PIOCTL ( PFlushAllVolumeData ) ;\n DECL_PIOCTL ( PGetVnodeXStatus ) ;\n DECL_PIOCTL ( PGetVnodeXStatus2 ) ;\n DECL_PIOCTL ( PSetSysName ) ;\n DECL_PIOCTL ( PSetSPrefs ) ;\n DECL_PIOCTL ( PSetSPrefs33 ) ;\n DECL_PIOCTL ( PGetSPrefs ) ;\n DECL_PIOCTL ( PExportAfs ) ;\n DECL_PIOCTL ( PGag ) ;\n DECL_PIOCTL ( PTwiddleRx ) ;\n DECL_PIOCTL ( PGetInitParams ) ;\n DECL_PIOCTL ( PGetRxkcrypt ) ;\n DECL_PIOCTL ( PSetRxkcrypt ) ;\n DECL_PIOCTL ( PGetCPrefs ) ;\n DECL_PIOCTL ( PSetCPrefs ) ;\n DECL_PIOCTL ( PFlushMount ) ;\n DECL_PIOCTL ( PRxStatProc ) ;\n DECL_PIOCTL ( PRxStatPeer ) ;\n DECL_PIOCTL ( PPrefetchFromTape ) ;\n DECL_PIOCTL ( PFsCmd ) ;\n DECL_PIOCTL ( PCallBackAddr )", "hash": -3053641395158209010, "project": "debian", "size": 55, "target": 0, "idx": 6879}
{"code": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens ) ;\n DECL_PIOCTL ( PUnlog ) ;\n DECL_PIOCTL ( PMariner )", "hash": -3053641395158209010, "project": "debian", "size": 18, "target": 0, "idx": 6905}
{"code": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens ) ;\n DECL_PIOCTL ( PUnlog ) ;\n DECL_PIOCTL ( PMariner ) ;\n DECL_PIOCTL ( PCheckServers ) ;\n DECL_PIOCTL ( PCheckVolNames ) ;\n DECL_PIOCTL ( PCheckAuth ) ;\n DECL_PIOCTL ( PFindVolume ) ;\n DECL_PIOCTL ( PViceAccess ) ;\n DECL_PIOCTL ( PSetCacheSize ) ;\n DECL_PIOCTL ( PGetCacheSize ) ;\n DECL_PIOCTL ( PRemoveCallBack ) ;\n DECL_PIOCTL ( PNewCell ) ;\n DECL_PIOCTL ( PNewAlias ) ;\n DECL_PIOCTL ( PListCells ) ;\n DECL_PIOCTL ( PListAliases ) ;\n DECL_PIOCTL ( PRemoveMount ) ;\n DECL_PIOCTL ( PGetCellStatus ) ;\n DECL_PIOCTL ( PSetCellStatus ) ;\n DECL_PIOCTL ( PFlushVolumeData ) ;\n DECL_PIOCTL ( PFlushAllVolumeData ) ;\n DECL_PIOCTL ( PGetVnodeXStatus ) ;\n DECL_PIOCTL ( PGetVnodeXStatus2 ) ;\n DECL_PIOCTL ( PSetSysName ) ;\n DECL_PIOCTL ( PSetSPrefs ) ;\n DECL_PIOCTL ( PSetSPrefs33 ) ;\n DECL_PIOCTL ( PGetSPrefs ) ;\n DECL_PIOCTL ( PExportAfs ) ;\n DECL_PIOCTL ( PGag ) ;\n DECL_PIOCTL ( PTwiddleRx ) ;\n DECL_PIOCTL ( PGetInitParams ) ;\n DECL_PIOCTL ( PGetRxkcrypt )", "hash": -3053641395158209010, "project": "debian", "size": 46, "target": 0, "idx": 6907}
{"code": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs )", "hash": -3053641395158209010, "project": "debian", "size": 4, "target": 0, "idx": 6909}
{"code": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens ) ;\n DECL_PIOCTL ( PUnlog ) ;\n DECL_PIOCTL ( PMariner ) ;\n DECL_PIOCTL ( PCheckServers ) ;\n DECL_PIOCTL ( PCheckVolNames ) ;\n DECL_PIOCTL ( PCheckAuth ) ;\n DECL_PIOCTL ( PFindVolume ) ;\n DECL_PIOCTL ( PViceAccess ) ;\n DECL_PIOCTL ( PSetCacheSize ) ;\n DECL_PIOCTL ( PGetCacheSize ) ;\n DECL_PIOCTL ( PRemoveCallBack ) ;\n DECL_PIOCTL ( PNewCell ) ;\n DECL_PIOCTL ( PNewAlias ) ;\n DECL_PIOCTL ( PListCells ) ;\n DECL_PIOCTL ( PListAliases ) ;\n DECL_PIOCTL ( PRemoveMount ) ;\n DECL_PIOCTL ( PGetCellStatus ) ;\n DECL_PIOCTL ( PSetCellStatus ) ;\n DECL_PIOCTL ( PFlushVolumeData ) ;\n DECL_PIOCTL ( PFlushAllVolumeData ) ;\n DECL_PIOCTL ( PGetVnodeXStatus ) ;\n DECL_PIOCTL ( PGetVnodeXStatus2 ) ;\n DECL_PIOCTL ( PSetSysName ) ;\n DECL_PIOCTL ( PSetSPrefs )", "hash": -3053641395158209010, "project": "debian", "size": 39, "target": 0, "idx": 6912}
{"code": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush )", "hash": -3053641395158209010, "project": "debian", "size": 14, "target": 0, "idx": 6914}
{"code": "METHOD ( asn1_parser_t , iterate , bool , private_asn1_parser_t * this , int * objectID , chunk_t * object ) {\n chunk_t * blob , * blob1 , blob_ori ;\n u_char * start_ptr ;\n u_int level ;\n asn1Object_t obj ;\n * object = chunk_empty ;\n obj = this -> objects [ ++ ( this -> line ) ] ;\n if ( obj . flags & ASN1_EXIT ) {\n return FALSE ;\n }\n if ( obj . flags & ASN1_END ) {\n if ( this -> loopAddr [ obj . level ] && this -> blobs [ obj . level + 1 ] . len > 0 ) {\n this -> line = this -> loopAddr [ obj . level ] ;\n obj = this -> objects [ this -> line ] ;\n }\n else {\n this -> loopAddr [ obj . level ] = 0 ;\n if ( obj . flags & ASN1_CHOICE ) {\n if ( this -> choice [ obj . level + 1 ] ) {\n DBG1 ( DBG_ASN , \"L%d - %s: incorrect choice encoding\" , this -> level0 + obj . level , obj . name ) ;\n this -> success = FALSE ;\n goto end ;\n }\n }\n if ( obj . flags & ASN1_CH ) {\n this -> choice [ obj . level ] = FALSE ;\n do {\n this -> line ++ ;\n }\n while ( ! ( ( this -> objects [ this -> line ] . flags & ASN1_END ) && ( this -> objects [ this -> line ] . flags & ASN1_CHOICE ) && ( this -> objects [ this -> line ] . level == obj . level - 1 ) ) ) ;\n this -> line -- ;\n }\n goto end ;\n }\n }\n level = this -> level0 + obj . level ;\n blob = this -> blobs + obj . level ;\n blob_ori = * blob ;\n blob1 = blob + 1 ;\n start_ptr = blob -> ptr ;\n if ( ( obj . flags & ASN1_DEF ) && ( blob -> len == 0 || * start_ptr != obj . type ) ) {\n DBG2 ( DBG_ASN , \"L%d - %s:\" , level , obj . name ) ;\n if ( obj . type & ASN1_CONSTRUCTED ) {\n this -> line ++ ;\n }\n goto end ;\n }\n if ( ( obj . flags & ASN1_OPT ) && ( blob -> len == 0 || * start_ptr != obj . type ) ) {\n do {\n this -> line ++ ;\n }\n while ( ! ( ( this -> objects [ this -> line ] . flags & ASN1_END ) && ( this -> objects [ this -> line ] . level == obj . level ) ) ) ;\n goto end ;\n }\n if ( blob -> len < 2 ) {\n DBG1 ( DBG_ASN , \"L%d - %s: ASN.1 object smaller than 2 octets\" , level , obj . name ) ;\n this -> success = FALSE ;\n goto end ;\n }\n blob1 -> len = asn1_length ( blob ) ;\n if ( blob1 -> len == ASN1_INVALID_LENGTH ) {\n DBG1 ( DBG_ASN , \"L%d - %s: length of ASN.1 object invalid or too large\" , level , obj . name ) ;\n this -> success = FALSE ;\n goto end ;\n }\n blob1 -> ptr = blob -> ptr ;\n blob -> ptr += blob1 -> len ;\n blob -> len -= blob1 -> len ;\n if ( ( obj . flags & ASN1_CHOICE ) && obj . type == ASN1_EOC ) {\n DBG2 ( DBG_ASN , \"L%d - %s:\" , level , obj . name ) ;\n this -> choice [ obj . level + 1 ] = TRUE ;\n * blob1 = blob_ori ;\n goto end ;\n }\n if ( obj . flags & ASN1_RAW ) {\n DBG2 ( DBG_ASN , \"L%d - %s:\" , level , obj . name ) ;\n object -> ptr = start_ptr ;\n object -> len = ( size_t ) ( blob -> ptr - start_ptr ) ;\n goto end ;\n }\n if ( * start_ptr != obj . type && ! ( this -> implicit && this -> line == 0 ) ) {\n DBG2 ( DBG_ASN , \"L%d - %s: ASN1 tag 0x%02x expected, but is 0x%02x\" , level , obj . name , obj . type , * start_ptr ) ;\n DBG3 ( DBG_ASN , \"%b\" , start_ptr , ( u_int ) ( blob -> ptr - start_ptr ) ) ;\n this -> success = FALSE ;\n goto end ;\n }\n DBG2 ( DBG_ASN , \"L%d - %s:\" , level , obj . name ) ;\n if ( obj . flags & ASN1_LOOP ) {\n if ( blob1 -> len > 0 ) {\n this -> loopAddr [ obj . level ] = this -> line + 1 ;\n }\n else {\n do {\n this -> line ++ ;\n }\n while ( ! ( ( this -> objects [ this -> line ] . flags & ASN1_END ) && ( this -> objects [ this -> line ] . level == obj . level ) ) ) ;\n goto end ;\n }\n }\n if ( obj . flags & ASN1_CHOICE ) {\n if ( blob1 -> len == 0 ) {\n DBG1 ( DBG_ASN , \"L%d - %s: contains no choice\" , level , obj . name ) ;\n this -> success = FALSE ;\n goto end ;\n }\n this -> choice [ obj . level + 1 ] = TRUE ;\n }\n if ( obj . flags & ASN1_OBJ ) {\n object -> ptr = start_ptr ;\n object -> len = ( size_t ) ( blob -> ptr - start_ptr ) ;\n if ( this -> private ) {\n DBG4 ( DBG_ASN , \"%B\" , object ) ;\n }\n else {\n DBG3 ( DBG_ASN , \"%B\" , object ) ;\n }\n }\n else if ( obj . flags & ASN1_BODY ) {\n * object = * blob1 ;\n asn1_debug_simple_object ( * object , obj . type , this -> private ) ;\n }\n end : * objectID = this -> line ;\n return this -> success ;\n }", "hash": 5658404386336978957, "project": "debian", "size": 124, "target": 0, "idx": 6922}
{"code": "METHOD ( certificate_t , equals , bool , private_x509_cert_t * this , certificate_t * other ) {\n chunk_t encoding ;\n bool equal ;\n if ( this == ( private_x509_cert_t * ) other ) {\n return TRUE ;\n }\n if ( other -> get_type ( other ) != CERT_X509 ) {\n return FALSE ;\n }\n if ( other -> equals == ( void * ) equals ) {\n return chunk_equals ( this -> encoding , ( ( private_x509_cert_t * ) other ) -> encoding ) ;\n }\n if ( ! other -> get_encoding ( other , CERT_ASN1_DER , & encoding ) ) {\n return FALSE ;\n }\n equal = chunk_equals ( this -> encoding , encoding ) ;\n free ( encoding . ptr ) ;\n return equal ;\n }", "hash": -3819889754140204145, "project": "debian", "size": 19, "target": 0, "idx": 6934}
{"code": "static bool parse_extendedKeyUsage ( chunk_t blob , int level0 , private_x509_cert_t * this ) {\n asn1_parser_t * parser ;\n chunk_t object ;\n int objectID ;\n bool success ;\n parser = asn1_parser_create ( extendedKeyUsageObjects , blob ) ;\n parser -> set_top_level ( parser , level0 ) ;\n while ( parser -> iterate ( parser , & objectID , & object ) ) {\n if ( objectID == EXT_KEY_USAGE_PURPOSE_ID ) {\n switch ( asn1_known_oid ( object ) ) {\n case OID_SERVER_AUTH : this -> flags |= X509_SERVER_AUTH ;\n break ;\n case OID_CLIENT_AUTH : this -> flags |= X509_CLIENT_AUTH ;\n break ;\n case OID_IKE_INTERMEDIATE : this -> flags |= X509_IKE_INTERMEDIATE ;\n break ;\n case OID_OCSP_SIGNING : this -> flags |= X509_OCSP_SIGNER ;\n break ;\n case OID_MS_SMARTCARD_LOGON : this -> flags |= X509_MS_SMARTCARD_LOGON ;\n break ;\n default : break ;\n }\n }\n }\n success = parser -> success ( parser ) ;\n parser -> destroy ( parser ) ;\n return success ;\n }", "hash": -3819889754140204145, "project": "debian", "size": 28, "target": 0, "idx": 6941}
{"code": "METHOD ( x509_t , get_serial , chunk_t , private_x509_cert_t * this ) {\n return this -> serialNumber ;\n }", "hash": -3819889754140204145, "project": "debian", "size": 3, "target": 0, "idx": 6942}
{"code": "static bool check_address_object ( ts_type_t ts_type , chunk_t object ) {\n switch ( ts_type ) {\n case TS_IPV4_ADDR_RANGE : if ( object . len > 5 ) {\n DBG1 ( DBG_ASN , \"IPv4 address object is larger than 5 octets\" ) ;\n return FALSE ;\n }\n break ;\n case TS_IPV6_ADDR_RANGE : if ( object . len > 17 ) {\n DBG1 ( DBG_ASN , \"IPv6 address object is larger than 17 octets\" ) ;\n return FALSE ;\n }\n break ;\n default : DBG1 ( DBG_ASN , \"unknown address family\" ) ;\n return FALSE ;\n }\n if ( object . len == 0 ) {\n DBG1 ( DBG_ASN , \"An ASN.1 bit string must contain at least the \" \"initial octet\" ) ;\n return FALSE ;\n }\n if ( object . len == 1 && object . ptr [ 0 ] != 0 ) {\n DBG1 ( DBG_ASN , \"An empty ASN.1 bit string must contain a zero \" \"initial octet\" ) ;\n return FALSE ;\n }\n if ( object . ptr [ 0 ] > 7 ) {\n DBG1 ( DBG_ASN , \"number of unused bits is too large\" ) ;\n return FALSE ;\n }\n return TRUE ;\n }", "hash": -3819889754140204145, "project": "debian", "size": 29, "target": 0, "idx": 6952}
{"code": "chunk_t build_generalName ( identification_t * id ) {\n int context ;\n switch ( id -> get_type ( id ) ) {\n case ID_RFC822_ADDR : context = ASN1_CONTEXT_S_1 ;\n break ;\n case ID_FQDN : context = ASN1_CONTEXT_S_2 ;\n break ;\n case ID_DER_ASN1_DN : context = ASN1_CONTEXT_C_4 ;\n break ;\n case ID_IPV4_ADDR : case ID_IPV6_ADDR : context = ASN1_CONTEXT_S_7 ;\n break ;\n default : DBG1 ( DBG_ASN , \"encoding %N as generalName not supported\" , id_type_names , id -> get_type ( id ) ) ;\n return chunk_empty ;\n }\n return asn1_wrap ( context , \"c\" , id -> get_encoding ( id ) ) ;\n }", "hash": -3819889754140204145, "project": "debian", "size": 16, "target": 0, "idx": 6974}
{"code": "static int aes_ccm_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , ctx ) ;\n if ( ! iv && ! key ) return 1 ;\n if ( key ) do {\n # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & cctx -> ks . ks ) ;\n CRYPTO_ccm128_init ( & cctx -> ccm , cctx -> M , cctx -> L , & cctx -> ks , ( block128_f ) HWAES_encrypt ) ;\n cctx -> str = NULL ;\n cctx -> key_set = 1 ;\n break ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & cctx -> ks . ks ) ;\n CRYPTO_ccm128_init ( & cctx -> ccm , cctx -> M , cctx -> L , & cctx -> ks , ( block128_f ) vpaes_encrypt ) ;\n cctx -> str = NULL ;\n cctx -> key_set = 1 ;\n break ;\n }\n # endif AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & cctx -> ks . ks ) ;\n CRYPTO_ccm128_init ( & cctx -> ccm , cctx -> M , cctx -> L , & cctx -> ks , ( block128_f ) AES_encrypt ) ;\n cctx -> str = NULL ;\n cctx -> key_set = 1 ;\n }\n while ( 0 ) ;\n if ( iv ) {\n memcpy ( EVP_CIPHER_CTX_iv_noconst ( ctx ) , iv , 15 - cctx -> L ) ;\n cctx -> iv_set = 1 ;\n }\n return 1 ;\n }", "hash": 8801969307247112896, "project": "debian", "size": 30, "target": 0, "idx": 7017}
{"code": "static int aes_gcm_tls_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n int rv = - 1 ;\n if ( out != in || len < ( EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ) ) return - 1 ;\n if ( EVP_CIPHER_CTX_ctrl ( ctx , EVP_CIPHER_CTX_encrypting ( ctx ) ? EVP_CTRL_GCM_IV_GEN : EVP_CTRL_GCM_SET_IV_INV , EVP_GCM_TLS_EXPLICIT_IV_LEN , out ) <= 0 ) goto err ;\n if ( CRYPTO_gcm128_aad ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , gctx -> tls_aad_len ) ) goto err ;\n in += EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n out += EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n len -= EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ;\n if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 32 && AES_GCM_ASM ( gctx ) ) {\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_encrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) goto err ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 32 && AES_GCM_ASM2 ( gctx ) ) {\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) goto err ;\n }\n out += len ;\n CRYPTO_gcm128_tag ( & gctx -> gcm , out , EVP_GCM_TLS_TAG_LEN ) ;\n rv = len + EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ;\n }\n else {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 16 && AES_GCM_ASM ( gctx ) ) {\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_decrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) goto err ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 16 && AES_GCM_ASM2 ( gctx ) ) {\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) goto err ;\n }\n CRYPTO_gcm128_tag ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , EVP_GCM_TLS_TAG_LEN ) ;\n if ( CRYPTO_memcmp ( EVP_CIPHER_CTX_buf_noconst ( ctx ) , in + len , EVP_GCM_TLS_TAG_LEN ) ) {\n OPENSSL_cleanse ( out , len ) ;\n goto err ;\n }\n rv = len ;\n }\n err : gctx -> iv_set = 0 ;\n gctx -> tls_aad_len = - 1 ;\n return rv ;\n }", "hash": 8801969307247112896, "project": "debian", "size": 62, "target": 0, "idx": 7022}
{"code": "static int chacha20_poly1305_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ;\n size_t rem , plen = actx -> tls_payload_length ;\n static const unsigned char zero [ POLY1305_BLOCK_SIZE ] = {\n 0 }\n ;\n if ( ! actx -> mac_inited ) {\n actx -> key . counter [ 0 ] = 0 ;\n memset ( actx -> key . buf , 0 , sizeof ( actx -> key . buf ) ) ;\n ChaCha20_ctr32 ( actx -> key . buf , actx -> key . buf , CHACHA_BLK_SIZE , actx -> key . key . d , actx -> key . counter ) ;\n Poly1305_Init ( POLY1305_ctx ( actx ) , actx -> key . buf ) ;\n actx -> key . counter [ 0 ] = 1 ;\n actx -> key . partial_len = 0 ;\n actx -> len . aad = actx -> len . text = 0 ;\n actx -> mac_inited = 1 ;\n }\n if ( in ) {\n if ( out == NULL ) {\n Poly1305_Update ( POLY1305_ctx ( actx ) , in , len ) ;\n actx -> len . aad += len ;\n actx -> aad = 1 ;\n return len ;\n }\n else {\n if ( actx -> aad ) {\n if ( ( rem = ( size_t ) actx -> len . aad % POLY1305_BLOCK_SIZE ) ) Poly1305_Update ( POLY1305_ctx ( actx ) , zero , POLY1305_BLOCK_SIZE - rem ) ;\n actx -> aad = 0 ;\n }\n actx -> tls_payload_length = NO_TLS_PAYLOAD_LENGTH ;\n if ( plen == NO_TLS_PAYLOAD_LENGTH ) plen = len ;\n else if ( len != plen + POLY1305_BLOCK_SIZE ) return - 1 ;\n if ( ctx -> encrypt ) {\n chacha_cipher ( ctx , out , in , plen ) ;\n Poly1305_Update ( POLY1305_ctx ( actx ) , out , plen ) ;\n in += plen ;\n out += plen ;\n actx -> len . text += plen ;\n }\n else {\n Poly1305_Update ( POLY1305_ctx ( actx ) , in , plen ) ;\n chacha_cipher ( ctx , out , in , plen ) ;\n in += plen ;\n out += plen ;\n actx -> len . text += plen ;\n }\n }\n }\n if ( in == NULL || plen != len ) {\n const union {\n long one ;\n char little ;\n }\n is_endian = {\n 1 }\n ;\n unsigned char temp [ POLY1305_BLOCK_SIZE ] ;\n if ( actx -> aad ) {\n if ( ( rem = ( size_t ) actx -> len . aad % POLY1305_BLOCK_SIZE ) ) Poly1305_Update ( POLY1305_ctx ( actx ) , zero , POLY1305_BLOCK_SIZE - rem ) ;\n actx -> aad = 0 ;\n }\n if ( ( rem = ( size_t ) actx -> len . text % POLY1305_BLOCK_SIZE ) ) Poly1305_Update ( POLY1305_ctx ( actx ) , zero , POLY1305_BLOCK_SIZE - rem ) ;\n if ( is_endian . little ) {\n Poly1305_Update ( POLY1305_ctx ( actx ) , ( unsigned char * ) & actx -> len , POLY1305_BLOCK_SIZE ) ;\n }\n else {\n temp [ 0 ] = ( unsigned char ) ( actx -> len . aad ) ;\n temp [ 1 ] = ( unsigned char ) ( actx -> len . aad >> 8 ) ;\n temp [ 2 ] = ( unsigned char ) ( actx -> len . aad >> 16 ) ;\n temp [ 3 ] = ( unsigned char ) ( actx -> len . aad >> 24 ) ;\n temp [ 4 ] = ( unsigned char ) ( actx -> len . aad >> 32 ) ;\n temp [ 5 ] = ( unsigned char ) ( actx -> len . aad >> 40 ) ;\n temp [ 6 ] = ( unsigned char ) ( actx -> len . aad >> 48 ) ;\n temp [ 7 ] = ( unsigned char ) ( actx -> len . aad >> 56 ) ;\n temp [ 8 ] = ( unsigned char ) ( actx -> len . text ) ;\n temp [ 9 ] = ( unsigned char ) ( actx -> len . text >> 8 ) ;\n temp [ 10 ] = ( unsigned char ) ( actx -> len . text >> 16 ) ;\n temp [ 11 ] = ( unsigned char ) ( actx -> len . text >> 24 ) ;\n temp [ 12 ] = ( unsigned char ) ( actx -> len . text >> 32 ) ;\n temp [ 13 ] = ( unsigned char ) ( actx -> len . text >> 40 ) ;\n temp [ 14 ] = ( unsigned char ) ( actx -> len . text >> 48 ) ;\n temp [ 15 ] = ( unsigned char ) ( actx -> len . text >> 56 ) ;\n Poly1305_Update ( POLY1305_ctx ( actx ) , temp , POLY1305_BLOCK_SIZE ) ;\n }\n Poly1305_Final ( POLY1305_ctx ( actx ) , ctx -> encrypt ? actx -> tag : temp ) ;\n actx -> mac_inited = 0 ;\n if ( in != NULL && len != plen ) {\n if ( ctx -> encrypt ) {\n memcpy ( out , actx -> tag , POLY1305_BLOCK_SIZE ) ;\n }\n else {\n if ( CRYPTO_memcmp ( temp , in , POLY1305_BLOCK_SIZE ) ) {\n memset ( out - plen , 0 , plen ) ;\n return - 1 ;\n }\n }\n }\n else if ( ! ctx -> encrypt ) {\n if ( CRYPTO_memcmp ( temp , actx -> tag , actx -> tag_len ) ) return - 1 ;\n }\n }\n return len ;\n }", "hash": -1763326842639388875, "project": "debian", "size": 102, "target": 0, "idx": 7024}
{"code": "static int chacha20_poly1305_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * inkey , const unsigned char * iv , int enc ) {\n EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ;\n if ( ! inkey && ! iv ) return 1 ;\n actx -> len . aad = 0 ;\n actx -> len . text = 0 ;\n actx -> aad = 0 ;\n actx -> mac_inited = 0 ;\n actx -> tls_payload_length = NO_TLS_PAYLOAD_LENGTH ;\n if ( iv != NULL ) {\n unsigned char temp [ CHACHA_CTR_SIZE ] = {\n 0 }\n ;\n if ( actx -> nonce_len <= CHACHA_CTR_SIZE ) memcpy ( temp + CHACHA_CTR_SIZE - actx -> nonce_len , iv , actx -> nonce_len ) ;\n chacha_init_key ( ctx , inkey , temp , enc ) ;\n actx -> nonce [ 0 ] = actx -> key . counter [ 1 ] ;\n actx -> nonce [ 1 ] = actx -> key . counter [ 2 ] ;\n actx -> nonce [ 2 ] = actx -> key . counter [ 3 ] ;\n }\n else {\n chacha_init_key ( ctx , inkey , NULL , enc ) ;\n }\n return 1 ;\n }", "hash": -1763326842639388875, "project": "debian", "size": 23, "target": 0, "idx": 7027}
{"code": "static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , void * ptr ) {\n EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ;\n switch ( type ) {\n case EVP_CTRL_INIT : if ( actx == NULL ) actx = ctx -> cipher_data = OPENSSL_zalloc ( sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ;\n if ( actx == NULL ) {\n EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_INITIALIZATION_ERROR ) ;\n return 0 ;\n }\n actx -> len . aad = 0 ;\n actx -> len . text = 0 ;\n actx -> aad = 0 ;\n actx -> mac_inited = 0 ;\n actx -> tag_len = 0 ;\n actx -> nonce_len = 12 ;\n actx -> tls_payload_length = NO_TLS_PAYLOAD_LENGTH ;\n return 1 ;\n case EVP_CTRL_COPY : if ( actx ) {\n EVP_CIPHER_CTX * dst = ( EVP_CIPHER_CTX * ) ptr ;\n dst -> cipher_data = OPENSSL_memdup ( actx , sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ;\n if ( dst -> cipher_data == NULL ) {\n EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_COPY_ERROR ) ;\n return 0 ;\n }\n }\n return 1 ;\n case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 || arg > CHACHA_CTR_SIZE ) return 0 ;\n actx -> nonce_len = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_IV_FIXED : if ( arg != 12 ) return 0 ;\n actx -> nonce [ 0 ] = actx -> key . counter [ 1 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr ) ;\n actx -> nonce [ 1 ] = actx -> key . counter [ 2 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 4 ) ;\n actx -> nonce [ 2 ] = actx -> key . counter [ 3 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 8 ) ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE ) return 0 ;\n if ( ptr != NULL ) {\n memcpy ( actx -> tag , ptr , arg ) ;\n actx -> tag_len = arg ;\n }\n return 1 ;\n case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE || ! ctx -> encrypt ) return 0 ;\n memcpy ( ptr , actx -> tag , arg ) ;\n return 1 ;\n case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n {\n unsigned int len ;\n unsigned char * aad = ptr , temp [ POLY1305_BLOCK_SIZE ] ;\n len = aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] << 8 | aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] ;\n if ( ! ctx -> encrypt ) {\n if ( len < POLY1305_BLOCK_SIZE ) return 0 ;\n len -= POLY1305_BLOCK_SIZE ;\n memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ;\n aad = temp ;\n temp [ EVP_AEAD_TLS1_AAD_LEN - 2 ] = ( unsigned char ) ( len >> 8 ) ;\n temp [ EVP_AEAD_TLS1_AAD_LEN - 1 ] = ( unsigned char ) len ;\n }\n actx -> tls_payload_length = len ;\n actx -> key . counter [ 1 ] = actx -> nonce [ 0 ] ;\n actx -> key . counter [ 2 ] = actx -> nonce [ 1 ] ^ CHACHA_U8TOU32 ( aad ) ;\n actx -> key . counter [ 3 ] = actx -> nonce [ 2 ] ^ CHACHA_U8TOU32 ( aad + 4 ) ;\n actx -> mac_inited = 0 ;\n chacha20_poly1305_cipher ( ctx , NULL , aad , EVP_AEAD_TLS1_AAD_LEN ) ;\n return POLY1305_BLOCK_SIZE ;\n }\n case EVP_CTRL_AEAD_SET_MAC_KEY : return 1 ;\n default : return - 1 ;\n }\n }", "hash": -1763326842639388875, "project": "debian", "size": 67, "target": 0, "idx": 7029}
{"code": "static int chacha_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char user_key [ CHACHA_KEY_SIZE ] , const unsigned char iv [ CHACHA_CTR_SIZE ] , int enc ) {\n EVP_CHACHA_KEY * key = data ( ctx ) ;\n unsigned int i ;\n if ( user_key ) for ( i = 0 ;\n i < CHACHA_KEY_SIZE ;\n i += 4 ) {\n key -> key . d [ i / 4 ] = CHACHA_U8TOU32 ( user_key + i ) ;\n }\n if ( iv ) for ( i = 0 ;\n i < CHACHA_CTR_SIZE ;\n i += 4 ) {\n key -> counter [ i / 4 ] = CHACHA_U8TOU32 ( iv + i ) ;\n }\n key -> partial_len = 0 ;\n return 1 ;\n }", "hash": -1763326842639388875, "project": "debian", "size": 16, "target": 0, "idx": 7031}
{"code": "static void incomplete_class_message ( zval * object , int error_type TSRMLS_DC ) {\n char * class_name ;\n zend_bool class_name_alloced = 1 ;\n class_name = php_lookup_class_name ( object , NULL ) ;\n if ( ! class_name ) {\n class_name_alloced = 0 ;\n class_name = \"unknown\" ;\n }\n php_error_docref ( NULL TSRMLS_CC , error_type , INCOMPLETE_CLASS_MSG , class_name ) ;\n if ( class_name_alloced ) {\n efree ( class_name ) ;\n }\n }", "hash": 8280197130498466782, "project": "debian", "size": 13, "target": 0, "idx": 7034}
{"code": "static int dissect_pcp_message_desc_req ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , int offset ) {\n proto_item * pcp_desc_req_item ;\n proto_tree * pcp_desc_req_tree ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"[%s]\" , val_to_str ( PCP_PDU_DESC_REQ , packettypenames , \"Unknown Type:0x%02x\" ) ) ;\n pcp_desc_req_item = proto_tree_add_item ( tree , hf_pcp_desc_req , tvb , offset , - 1 , ENC_NA ) ;\n pcp_desc_req_tree = proto_item_add_subtree ( pcp_desc_req_item , ett_pcp ) ;\n offset = dissect_pcp_partial_pmid ( tvb , pinfo , pcp_desc_req_tree , offset ) ;\n return offset ;\n }", "hash": 8637588907624249958, "project": "debian", "size": 9, "target": 0, "idx": 7059}
{"code": "static int dissect_pcp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n tcp_dissect_pdus ( tvb , pinfo , tree , TRUE , PCP_HEADER_LEN , get_pcp_message_len , dissect_pcp_message , data ) ;\n return tvb_captured_length ( tvb ) ;\n }", "hash": 8637588907624249958, "project": "debian", "size": 4, "target": 0, "idx": 7066}
{"code": "static pcp_conv_info_t * get_pcp_conversation_info ( packet_info * pinfo ) {\n conversation_t * conversation ;\n pcp_conv_info_t * pcp_conv_info ;\n conversation = find_conversation ( pinfo -> num , & pinfo -> src , & pinfo -> dst , pinfo -> ptype , pinfo -> srcport , pinfo -> destport , 0 ) ;\n DISSECTOR_ASSERT ( conversation ) ;\n pcp_conv_info = ( pcp_conv_info_t * ) conversation_get_proto_data ( conversation , proto_pcp ) ;\n DISSECTOR_ASSERT ( pcp_conv_info ) ;\n return pcp_conv_info ;\n }", "hash": 8637588907624249958, "project": "debian", "size": 9, "target": 0, "idx": 7067}
{"code": "static const gchar * get_pcp_features_to_string ( guint16 feature_flags ) {\n const value_string * flag_under_test ;\n wmem_strbuf_t * string_buffer ;\n gsize string_length ;\n string_buffer = wmem_strbuf_new ( wmem_packet_scope ( ) , \"\" ) ;\n flag_under_test = & pcp_feature_flags [ 0 ] ;\n while ( flag_under_test -> value ) {\n if ( feature_flags & flag_under_test -> value ) {\n wmem_strbuf_append_printf ( string_buffer , \"%s, \" , flag_under_test -> strptr ) ;\n }\n flag_under_test ++ ;\n }\n string_length = wmem_strbuf_get_len ( string_buffer ) ;\n if ( string_length > 2 ) {\n wmem_strbuf_truncate ( string_buffer , string_length - 2 ) ;\n }\n return wmem_strbuf_get_str ( string_buffer ) ;\n }", "hash": 8637588907624249958, "project": "debian", "size": 18, "target": 0, "idx": 7069}
{"code": "static void reindex_all_databases ( const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet , bool verbose ) {\n PGconn * conn ;\n PGresult * result ;\n PQExpBufferData connstr ;\n int i ;\n conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n result = executeQuery ( conn , \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;\n\" , progname , echo ) ;\n PQfinish ( conn ) ;\n initPQExpBuffer ( & connstr ) ;\n for ( i = 0 ;\n i < PQntuples ( result ) ;\n i ++ ) {\n char * dbname = PQgetvalue ( result , i , 0 ) ;\n if ( ! quiet ) {\n printf ( _ ( \"%s: reindexing database \\\"%s\\\"\\n\" ) , progname , dbname ) ;\n fflush ( stdout ) ;\n }\n resetPQExpBuffer ( & connstr ) ;\n appendPQExpBuffer ( & connstr , \"dbname=\" ) ;\n appendConnStrVal ( & connstr , dbname ) ;\n reindex_one_database ( NULL , connstr . data , \"DATABASE\" , host , port , username , prompt_password , progname , echo , verbose ) ;\n }\n termPQExpBuffer ( & connstr ) ;\n PQclear ( result ) ;\n }", "hash": -4872400287267974771, "project": "debian", "size": 26, "target": 0, "idx": 7097}
{"code": "bool RunIdentifySystem ( PGconn * conn , char * * sysid , TimeLineID * starttli , XLogRecPtr * startpos , char * * db_name ) {\n PGresult * res ;\n uint32 hi , lo ;\n Assert ( conn != NULL ) ;\n res = PQexec ( conn , \"IDENTIFY_SYSTEM\" ) ;\n if ( PQresultStatus ( res ) != PGRES_TUPLES_OK ) {\n fprintf ( stderr , _ ( \"%s: could not send replication command \\\"%s\\\": %s\" ) , progname , \"IDENTIFY_SYSTEM\" , PQerrorMessage ( conn ) ) ;\n PQclear ( res ) ;\n return false ;\n }\n if ( PQntuples ( res ) != 1 || PQnfields ( res ) < 3 ) {\n fprintf ( stderr , _ ( \"%s: could not identify system: got %d rows and %d fields, expected %d rows and %d or more fields\\n\" ) , progname , PQntuples ( res ) , PQnfields ( res ) , 1 , 3 ) ;\n PQclear ( res ) ;\n return false ;\n }\n if ( sysid != NULL ) * sysid = pg_strdup ( PQgetvalue ( res , 0 , 0 ) ) ;\n if ( starttli != NULL ) * starttli = atoi ( PQgetvalue ( res , 0 , 1 ) ) ;\n if ( startpos != NULL ) {\n if ( sscanf ( PQgetvalue ( res , 0 , 2 ) , \"%X/%X\" , & hi , & lo ) != 2 ) {\n fprintf ( stderr , _ ( \"%s: could not parse transaction log location \\\"%s\\\"\\n\" ) , progname , PQgetvalue ( res , 0 , 2 ) ) ;\n PQclear ( res ) ;\n return false ;\n }\n * startpos = ( ( uint64 ) hi ) << 32 | lo ;\n }\n if ( db_name != NULL ) {\n * db_name = NULL ;\n if ( PQserverVersion ( conn ) >= 90400 ) {\n if ( PQnfields ( res ) < 4 ) {\n fprintf ( stderr , _ ( \"%s: could not identify system: got %d rows and %d fields, expected %d rows and %d or more fields\\n\" ) , progname , PQntuples ( res ) , PQnfields ( res ) , 1 , 4 ) ;\n PQclear ( res ) ;\n return false ;\n }\n if ( ! PQgetisnull ( res , 0 , 3 ) ) * db_name = pg_strdup ( PQgetvalue ( res , 0 , 3 ) ) ;\n }\n }\n PQclear ( res ) ;\n return true ;\n }", "hash": 7545838748510052337, "project": "debian", "size": 39, "target": 0, "idx": 7102}
{"code": "static void dumpTimestamp ( ArchiveHandle * AH , const char * msg , time_t tim ) {\n char buf [ 64 ] ;\n if ( strftime ( buf , sizeof ( buf ) , PGDUMP_STRFTIME_FMT , localtime ( & tim ) ) != 0 ) ahprintf ( AH , \"-- %s %s\\n\\n\" , msg , buf ) ;\n }", "hash": -8028756826159773630, "project": "debian", "size": 4, "target": 0, "idx": 7117}
{"code": "static void mark_work_done ( ArchiveHandle * AH , TocEntry * ready_list , int worker , int status , ParallelState * pstate ) {\n TocEntry * te = NULL ;\n te = pstate -> parallelSlot [ worker ] . args -> te ;\n if ( te == NULL ) exit_horribly ( modulename , \"could not find slot of finished worker\\n\" ) ;\n ahlog ( AH , 1 , \"finished item %d %s %s\\n\" , te -> dumpId , te -> desc , te -> tag ) ;\n if ( status == WORKER_CREATE_DONE ) mark_create_done ( AH , te ) ;\n else if ( status == WORKER_INHIBIT_DATA ) {\n inhibit_data_for_failed_table ( AH , te ) ;\n AH -> public . n_errors ++ ;\n }\n else if ( status == WORKER_IGNORED_ERRORS ) AH -> public . n_errors ++ ;\n else if ( status != 0 ) exit_horribly ( modulename , \"worker process failed: exit code %d\\n\" , status ) ;\n reduce_dependencies ( AH , te , ready_list ) ;\n }", "hash": -8028756826159773630, "project": "debian", "size": 14, "target": 0, "idx": 7118}
{"code": "TocEntry * getTocEntryByDumpId ( ArchiveHandle * AH , DumpId id ) {\n if ( AH -> tocsByDumpId == NULL ) buildTocEntryArrays ( AH ) ;\n if ( id > 0 && id <= AH -> maxDumpId ) return AH -> tocsByDumpId [ id ] ;\n return NULL ;\n }", "hash": -8028756826159773630, "project": "debian", "size": 5, "target": 0, "idx": 7131}
{"code": "void PrintTOCSummary ( Archive * AHX ) {\n ArchiveHandle * AH = ( ArchiveHandle * ) AHX ;\n RestoreOptions * ropt = AH -> public . ropt ;\n TocEntry * te ;\n teSection curSection ;\n OutputContext sav ;\n const char * fmtName ;\n char stamp_str [ 64 ] ;\n sav = SaveOutput ( AH ) ;\n if ( ropt -> filename ) SetOutput ( AH , ropt -> filename , 0 ) ;\n if ( strftime ( stamp_str , sizeof ( stamp_str ) , PGDUMP_STRFTIME_FMT , localtime ( & AH -> createDate ) ) == 0 ) strcpy ( stamp_str , \"[unknown]\" ) ;\n ahprintf ( AH , \";\n\\n;\n Archive created at %s\\n\" , stamp_str ) ;\n ahprintf ( AH , \";\n dbname: %s\\n;\n TOC Entries: %d\\n;\n Compression: %d\\n\" , AH -> archdbname , AH -> tocCount , AH -> compression ) ;\n switch ( AH -> format ) {\n case archCustom : fmtName = \"CUSTOM\" ;\n break ;\n case archDirectory : fmtName = \"DIRECTORY\" ;\n break ;\n case archTar : fmtName = \"TAR\" ;\n break ;\n default : fmtName = \"UNKNOWN\" ;\n }\n ahprintf ( AH , \";\n Dump Version: %d.%d-%d\\n\" , AH -> vmaj , AH -> vmin , AH -> vrev ) ;\n ahprintf ( AH , \";\n Format: %s\\n\" , fmtName ) ;\n ahprintf ( AH , \";\n Integer: %d bytes\\n\" , ( int ) AH -> intSize ) ;\n ahprintf ( AH , \";\n Offset: %d bytes\\n\" , ( int ) AH -> offSize ) ;\n if ( AH -> archiveRemoteVersion ) ahprintf ( AH , \";\n Dumped from database version: %s\\n\" , AH -> archiveRemoteVersion ) ;\n if ( AH -> archiveDumpVersion ) ahprintf ( AH , \";\n Dumped by pg_dump version: %s\\n\" , AH -> archiveDumpVersion ) ;\n ahprintf ( AH , \";\n\\n;\n\\n;\n Selected TOC Entries:\\n;\n\\n\" ) ;\n curSection = SECTION_PRE_DATA ;\n for ( te = AH -> toc -> next ;\n te != AH -> toc ;\n te = te -> next ) {\n if ( te -> section != SECTION_NONE ) curSection = te -> section ;\n if ( ropt -> verbose || ( _tocEntryRequired ( te , curSection , ropt ) & ( REQ_SCHEMA | REQ_DATA ) ) != 0 ) ahprintf ( AH , \"%d;\n %u %u %s %s %s %s\\n\" , te -> dumpId , te -> catalogId . tableoid , te -> catalogId . oid , te -> desc , te -> namespace ? te -> namespace : \"-\" , te -> tag , te -> owner ) ;\n if ( ropt -> verbose && te -> nDeps > 0 ) {\n int i ;\n ahprintf ( AH , \";\n\\tdepends on:\" ) ;\n for ( i = 0 ;\n i < te -> nDeps ;\n i ++ ) ahprintf ( AH , \" %d\" , te -> dependencies [ i ] ) ;\n ahprintf ( AH , \"\\n\" ) ;\n }\n }\n if ( ropt -> strict_names ) StrictNamesCheck ( ropt ) ;\n if ( ropt -> filename ) RestoreOutput ( AH , sav ) ;\n }", "hash": -8028756826159773630, "project": "debian", "size": 64, "target": 0, "idx": 7134}
{"code": "static void mark_create_done ( ArchiveHandle * AH , TocEntry * te ) {\n if ( AH -> tableDataId [ te -> dumpId ] != 0 ) {\n TocEntry * ted = AH -> tocsByDumpId [ AH -> tableDataId [ te -> dumpId ] ] ;\n ted -> created = true ;\n }\n }", "hash": -8028756826159773630, "project": "debian", "size": 6, "target": 0, "idx": 7161}
{"code": "char * ReadStr ( ArchiveHandle * AH ) {\n char * buf ;\n int l ;\n l = ReadInt ( AH ) ;\n if ( l < 0 ) buf = NULL ;\n else {\n buf = ( char * ) pg_malloc ( l + 1 ) ;\n ( * AH -> ReadBufPtr ) ( AH , ( void * ) buf , l ) ;\n buf [ l ] = '\\0' ;\n }\n return buf ;\n }", "hash": -8028756826159773630, "project": "debian", "size": 12, "target": 0, "idx": 7175}
{"code": "static bool _tocEntryIsACL ( TocEntry * te ) {\n if ( strcmp ( te -> desc , \"ACL\" ) == 0 || strcmp ( te -> desc , \"ACL LANGUAGE\" ) == 0 || strcmp ( te -> desc , \"DEFAULT ACL\" ) == 0 ) return true ;\n return false ;\n }", "hash": -8028756826159773630, "project": "debian", "size": 4, "target": 0, "idx": 7182}
{"code": "static void fix_dependencies ( ArchiveHandle * AH ) {\n TocEntry * te ;\n int i ;\n for ( te = AH -> toc -> next ;\n te != AH -> toc ;\n te = te -> next ) {\n te -> depCount = te -> nDeps ;\n te -> revDeps = NULL ;\n te -> nRevDeps = 0 ;\n te -> par_prev = NULL ;\n te -> par_next = NULL ;\n }\n repoint_table_dependencies ( AH ) ;\n if ( AH -> version < K_VERS_1_11 ) {\n for ( te = AH -> toc -> next ;\n te != AH -> toc ;\n te = te -> next ) {\n if ( strcmp ( te -> desc , \"BLOB COMMENTS\" ) == 0 && te -> nDeps == 0 ) {\n TocEntry * te2 ;\n for ( te2 = AH -> toc -> next ;\n te2 != AH -> toc ;\n te2 = te2 -> next ) {\n if ( strcmp ( te2 -> desc , \"BLOBS\" ) == 0 ) {\n te -> dependencies = ( DumpId * ) pg_malloc ( sizeof ( DumpId ) ) ;\n te -> dependencies [ 0 ] = te2 -> dumpId ;\n te -> nDeps ++ ;\n te -> depCount ++ ;\n break ;\n }\n }\n break ;\n }\n }\n }\n for ( te = AH -> toc -> next ;\n te != AH -> toc ;\n te = te -> next ) {\n for ( i = 0 ;\n i < te -> nDeps ;\n i ++ ) {\n DumpId depid = te -> dependencies [ i ] ;\n if ( depid <= AH -> maxDumpId && AH -> tocsByDumpId [ depid ] != NULL ) AH -> tocsByDumpId [ depid ] -> nRevDeps ++ ;\n else te -> depCount -- ;\n }\n }\n for ( te = AH -> toc -> next ;\n te != AH -> toc ;\n te = te -> next ) {\n if ( te -> nRevDeps > 0 ) te -> revDeps = ( DumpId * ) pg_malloc ( te -> nRevDeps * sizeof ( DumpId ) ) ;\n te -> nRevDeps = 0 ;\n }\n for ( te = AH -> toc -> next ;\n te != AH -> toc ;\n te = te -> next ) {\n for ( i = 0 ;\n i < te -> nDeps ;\n i ++ ) {\n DumpId depid = te -> dependencies [ i ] ;\n if ( depid <= AH -> maxDumpId && AH -> tocsByDumpId [ depid ] != NULL ) {\n TocEntry * otherte = AH -> tocsByDumpId [ depid ] ;\n otherte -> revDeps [ otherte -> nRevDeps ++ ] = te -> dumpId ;\n }\n }\n }\n for ( te = AH -> toc -> next ;\n te != AH -> toc ;\n te = te -> next ) {\n te -> lockDeps = NULL ;\n te -> nLockDeps = 0 ;\n identify_locking_dependencies ( AH , te ) ;\n }\n }", "hash": -8028756826159773630, "project": "debian", "size": 72, "target": 0, "idx": 7183}
{"code": "static void par_list_header_init ( TocEntry * l ) {\n l -> par_prev = l -> par_next = l ;\n }", "hash": -8028756826159773630, "project": "debian", "size": 3, "target": 0, "idx": 7185}
{"code": "void EndRestoreBlobs ( ArchiveHandle * AH ) {\n RestoreOptions * ropt = AH -> public . ropt ;\n if ( ! ropt -> single_txn ) {\n if ( AH -> connection ) CommitTransaction ( & AH -> public ) ;\n else ahprintf ( AH , \"COMMIT;\n\\n\\n\" ) ;\n }\n ahlog ( AH , 1 , ngettext ( \"restored %d large object\\n\" , \"restored %d large objects\\n\" , AH -> blobCount ) , AH -> blobCount ) ;\n }", "hash": -8028756826159773630, "project": "debian", "size": 9, "target": 0, "idx": 7187}
{"code": "static void restore_toc_entries_parallel ( ArchiveHandle * AH , ParallelState * pstate , TocEntry * pending_list ) {\n int work_status ;\n bool skipped_some ;\n TocEntry ready_list ;\n TocEntry * next_work_item ;\n int ret_child ;\n ahlog ( AH , 2 , \"entering restore_toc_entries_parallel\\n\" ) ;\n par_list_header_init ( & ready_list ) ;\n skipped_some = false ;\n for ( next_work_item = AH -> toc -> next ;\n next_work_item != AH -> toc ;\n next_work_item = next_work_item -> next ) {\n if ( next_work_item -> section == SECTION_PRE_DATA ) {\n continue ;\n }\n if ( next_work_item -> section == SECTION_DATA || next_work_item -> section == SECTION_POST_DATA ) {\n skipped_some = true ;\n }\n else {\n if ( ! skipped_some ) continue ;\n }\n if ( next_work_item -> depCount > 0 ) par_list_append ( pending_list , next_work_item ) ;\n else par_list_append ( & ready_list , next_work_item ) ;\n }\n ahlog ( AH , 1 , \"entering main parallel loop\\n\" ) ;\n while ( ( next_work_item = get_next_work_item ( AH , & ready_list , pstate ) ) != NULL || ! IsEveryWorkerIdle ( pstate ) ) {\n if ( next_work_item != NULL ) {\n if ( ( next_work_item -> reqs & ( REQ_SCHEMA | REQ_DATA ) ) == 0 || _tocEntryIsACL ( next_work_item ) ) {\n ahlog ( AH , 1 , \"skipping item %d %s %s\\n\" , next_work_item -> dumpId , next_work_item -> desc , next_work_item -> tag ) ;\n par_list_remove ( next_work_item ) ;\n reduce_dependencies ( AH , next_work_item , & ready_list ) ;\n continue ;\n }\n ahlog ( AH , 1 , \"launching item %d %s %s\\n\" , next_work_item -> dumpId , next_work_item -> desc , next_work_item -> tag ) ;\n par_list_remove ( next_work_item ) ;\n DispatchJobForTocEntry ( AH , pstate , next_work_item , ACT_RESTORE ) ;\n }\n else {\n }\n for ( ;\n ;\n ) {\n int nTerm = 0 ;\n ListenToWorkers ( AH , pstate , ! next_work_item ) ;\n while ( ( ret_child = ReapWorkerStatus ( pstate , & work_status ) ) != NO_SLOT ) {\n nTerm ++ ;\n mark_work_done ( AH , & ready_list , ret_child , work_status , pstate ) ;\n }\n if ( nTerm > 0 ) break ;\n if ( GetIdleWorker ( pstate ) != NO_SLOT ) break ;\n ListenToWorkers ( AH , pstate , true ) ;\n }\n }\n ahlog ( AH , 1 , \"finished main parallel loop\\n\" ) ;\n }", "hash": -8028756826159773630, "project": "debian", "size": 55, "target": 0, "idx": 7193}
{"code": "void SortTocFromFile ( Archive * AHX ) {\n ArchiveHandle * AH = ( ArchiveHandle * ) AHX ;\n RestoreOptions * ropt = AH -> public . ropt ;\n FILE * fh ;\n char buf [ 100 ] ;\n bool incomplete_line ;\n ropt -> idWanted = ( bool * ) pg_malloc ( sizeof ( bool ) * AH -> maxDumpId ) ;\n memset ( ropt -> idWanted , 0 , sizeof ( bool ) * AH -> maxDumpId ) ;\n fh = fopen ( ropt -> tocFile , PG_BINARY_R ) ;\n if ( ! fh ) exit_horribly ( modulename , \"could not open TOC file \\\"%s\\\": %s\\n\" , ropt -> tocFile , strerror ( errno ) ) ;\n incomplete_line = false ;\n while ( fgets ( buf , sizeof ( buf ) , fh ) != NULL ) {\n bool prev_incomplete_line = incomplete_line ;\n int buflen ;\n char * cmnt ;\n char * endptr ;\n DumpId id ;\n TocEntry * te ;\n buflen = strlen ( buf ) ;\n if ( buflen > 0 && buf [ buflen - 1 ] == '\\n' ) incomplete_line = false ;\n else incomplete_line = true ;\n if ( prev_incomplete_line ) continue ;\n cmnt = strchr ( buf , ';\n' ) ;\n if ( cmnt != NULL ) cmnt [ 0 ] = '\\0' ;\n if ( strspn ( buf , \" \\t\\r\\n\" ) == strlen ( buf ) ) continue ;\n id = strtol ( buf , & endptr , 10 ) ;\n if ( endptr == buf || id <= 0 || id > AH -> maxDumpId || ropt -> idWanted [ id - 1 ] ) {\n write_msg ( modulename , \"WARNING: line ignored: %s\\n\" , buf ) ;\n continue ;\n }\n te = getTocEntryByDumpId ( AH , id ) ;\n if ( ! te ) exit_horribly ( modulename , \"could not find entry for ID %d\\n\" , id ) ;\n ropt -> idWanted [ id - 1 ] = true ;\n _moveBefore ( AH , AH -> toc , te ) ;\n }\n if ( fclose ( fh ) != 0 ) exit_horribly ( modulename , \"could not close TOC file: %s\\n\" , strerror ( errno ) ) ;\n }", "hash": -8028756826159773630, "project": "debian", "size": 38, "target": 0, "idx": 7196}
{"code": "static OutputContext SaveOutput ( ArchiveHandle * AH ) {\n OutputContext sav ;\n sav . OF = AH -> OF ;\n sav . gzOut = AH -> gzOut ;\n return sav ;\n }", "hash": -8028756826159773630, "project": "debian", "size": 6, "target": 0, "idx": 7199}
{"code": "PGresult * executeQueryOrDie ( PGconn * conn , const char * fmt , ... ) {\n static char query [ QUERY_ALLOC ] ;\n va_list args ;\n PGresult * result ;\n ExecStatusType status ;\n va_start ( args , fmt ) ;\n vsnprintf ( query , sizeof ( query ) , fmt , args ) ;\n va_end ( args ) ;\n pg_log ( PG_VERBOSE , \"executing: %s\\n\" , query ) ;\n result = PQexec ( conn , query ) ;\n status = PQresultStatus ( result ) ;\n if ( ( status != PGRES_TUPLES_OK ) && ( status != PGRES_COMMAND_OK ) ) {\n pg_log ( PG_REPORT , \"SQL command failed\\n%s\\n%s\\n\" , query , PQerrorMessage ( conn ) ) ;\n PQclear ( result ) ;\n PQfinish ( conn ) ;\n printf ( \"Failure, exiting\\n\" ) ;\n exit ( 1 ) ;\n }\n else return result ;\n }", "hash": -4979531020783644238, "project": "debian", "size": 20, "target": 0, "idx": 7201}
{"code": "static void remove_new_subdir ( char * subdir , bool rmtopdir ) {\n char new_path [ MAXPGPATH ] ;\n prep_status ( \"Deleting files from new %s\" , subdir ) ;\n snprintf ( new_path , sizeof ( new_path ) , \"%s/%s\" , new_cluster . pgdata , subdir ) ;\n if ( ! rmtree ( new_path , rmtopdir ) ) pg_fatal ( \"could not delete directory \\\"%s\\\"\\n\" , new_path ) ;\n check_ok ( ) ;\n }", "hash": 214341372476109918, "project": "debian", "size": 7, "target": 0, "idx": 7216}
{"code": "static void help ( void ) {\n printf ( _ ( \"%s extracts a PostgreSQL database cluster into an SQL script file.\\n\\n\" ) , progname ) ;\n printf ( _ ( \"Usage:\\n\" ) ) ;\n printf ( _ ( \" %s [OPTION]...\\n\" ) , progname ) ;\n printf ( _ ( \"\\nGeneral options:\\n\" ) ) ;\n printf ( _ ( \" -f, --file=FILENAME output file name\\n\" ) ) ;\n printf ( _ ( \" -V, --version output version information, then exit\\n\" ) ) ;\n printf ( _ ( \" --lock-wait-timeout=TIMEOUT fail after waiting TIMEOUT for a table lock\\n\" ) ) ;\n printf ( _ ( \" -?, --help show this help, then exit\\n\" ) ) ;\n printf ( _ ( \"\\nOptions controlling the output content:\\n\" ) ) ;\n printf ( _ ( \" -a, --data-only dump only the data, not the schema\\n\" ) ) ;\n printf ( _ ( \" -c, --clean clean (drop) databases before recreating\\n\" ) ) ;\n printf ( _ ( \" -g, --globals-only dump only global objects, no databases\\n\" ) ) ;\n printf ( _ ( \" -o, --oids include OIDs in dump\\n\" ) ) ;\n printf ( _ ( \" -O, --no-owner skip restoration of object ownership\\n\" ) ) ;\n printf ( _ ( \" -r, --roles-only dump only roles, no databases or tablespaces\\n\" ) ) ;\n printf ( _ ( \" -s, --schema-only dump only the schema, no data\\n\" ) ) ;\n printf ( _ ( \" -S, --superuser=NAME superuser user name to use in the dump\\n\" ) ) ;\n printf ( _ ( \" -t, --tablespaces-only dump only tablespaces, no databases or roles\\n\" ) ) ;\n printf ( _ ( \" -x, --no-privileges do not dump privileges (grant/revoke)\\n\" ) ) ;\n printf ( _ ( \" --binary-upgrade for use by upgrade utilities only\\n\" ) ) ;\n printf ( _ ( \" --column-inserts dump data as INSERT commands with column names\\n\" ) ) ;\n printf ( _ ( \" --disable-dollar-quoting disable dollar quoting, use SQL standard quoting\\n\" ) ) ;\n printf ( _ ( \" --disable-triggers disable triggers during data-only restore\\n\" ) ) ;\n printf ( _ ( \" --if-exists use IF EXISTS when dropping objects\\n\" ) ) ;\n printf ( _ ( \" --inserts dump data as INSERT commands, rather than COPY\\n\" ) ) ;\n printf ( _ ( \" --no-security-labels do not dump security label assignments\\n\" ) ) ;\n printf ( _ ( \" --no-tablespaces do not dump tablespace assignments\\n\" ) ) ;\n printf ( _ ( \" --no-unlogged-table-data do not dump unlogged table data\\n\" ) ) ;\n printf ( _ ( \" --quote-all-identifiers quote all identifiers, even if not key words\\n\" ) ) ;\n printf ( _ ( \" --use-set-session-authorization\\n\" \" use SET SESSION AUTHORIZATION commands instead of\\n\" \" ALTER OWNER commands to set ownership\\n\" ) ) ;\n printf ( _ ( \"\\nConnection options:\\n\" ) ) ;\n printf ( _ ( \" -d, --dbname=CONNSTR connect using connection string\\n\" ) ) ;\n printf ( _ ( \" -h, --host=HOSTNAME database server host or socket directory\\n\" ) ) ;\n printf ( _ ( \" -l, --database=DBNAME alternative default database\\n\" ) ) ;\n printf ( _ ( \" -p, --port=PORT database server port number\\n\" ) ) ;\n printf ( _ ( \" -U, --username=NAME connect as specified database user\\n\" ) ) ;\n printf ( _ ( \" -w, --no-password never prompt for password\\n\" ) ) ;\n printf ( _ ( \" -W, --password force password prompt (should happen automatically)\\n\" ) ) ;\n printf ( _ ( \" --role=ROLENAME do SET ROLE before dump\\n\" ) ) ;\n printf ( _ ( \"\\nIf -f/--file is not used, then the SQL script will be written to the standard\\n\" \"output.\\n\\n\" ) ) ;\n printf ( _ ( \"Report bugs to <pgsql-bugs@postgresql.org>.\\n\" ) ) ;\n }", "hash": -6215323349888018447, "project": "debian", "size": 43, "target": 0, "idx": 7225}
{"code": "static void help ( const char * progname ) {\n printf ( _ ( \"%s cleans and analyzes a PostgreSQL database.\\n\\n\" ) , progname ) ;\n printf ( _ ( \"Usage:\\n\" ) ) ;\n printf ( _ ( \" %s [OPTION]... [DBNAME]\\n\" ) , progname ) ;\n printf ( _ ( \"\\nOptions:\\n\" ) ) ;\n printf ( _ ( \" -a, --all vacuum all databases\\n\" ) ) ;\n printf ( _ ( \" -d, --dbname=DBNAME database to vacuum\\n\" ) ) ;\n printf ( _ ( \" -e, --echo show the commands being sent to the server\\n\" ) ) ;\n printf ( _ ( \" -f, --full do full vacuuming\\n\" ) ) ;\n printf ( _ ( \" -F, --freeze freeze row transaction information\\n\" ) ) ;\n printf ( _ ( \" -j, --jobs=NUM use this many concurrent connections to vacuum\\n\" ) ) ;\n printf ( _ ( \" -q, --quiet don't write any messages\\n\" ) ) ;\n printf ( _ ( \" -t, --table='TABLE[(COLUMNS)]' vacuum specific table(s) only\\n\" ) ) ;\n printf ( _ ( \" -v, --verbose write a lot of output\\n\" ) ) ;\n printf ( _ ( \" -V, --version output version information, then exit\\n\" ) ) ;\n printf ( _ ( \" -z, --analyze update optimizer statistics\\n\" ) ) ;\n printf ( _ ( \" -Z, --analyze-only only update optimizer statistics;\n no vacuum\\n\" ) ) ;\n printf ( _ ( \" --analyze-in-stages only update optimizer statistics, in multiple\\n\" \" stages for faster results;\n no vacuum\\n\" ) ) ;\n printf ( _ ( \" -?, --help show this help, then exit\\n\" ) ) ;\n printf ( _ ( \"\\nConnection options:\\n\" ) ) ;\n printf ( _ ( \" -h, --host=HOSTNAME database server host or socket directory\\n\" ) ) ;\n printf ( _ ( \" -p, --port=PORT database server port\\n\" ) ) ;\n printf ( _ ( \" -U, --username=USERNAME user name to connect as\\n\" ) ) ;\n printf ( _ ( \" -w, --no-password never prompt for password\\n\" ) ) ;\n printf ( _ ( \" -W, --password force password prompt\\n\" ) ) ;\n printf ( _ ( \" --maintenance-db=DBNAME alternate maintenance database\\n\" ) ) ;\n printf ( _ ( \"\\nRead the description of the SQL command VACUUM for details.\\n\" ) ) ;\n printf ( _ ( \"\\nReport bugs to <pgsql-bugs@postgresql.org>.\\n\" ) ) ;\n }", "hash": 468458465404335175, "project": "debian", "size": 31, "target": 0, "idx": 7245}
{"code": "static void init_slot ( ParallelSlot * slot , PGconn * conn , const char * progname ) {\n slot -> connection = conn ;\n slot -> isFree = true ;\n slot -> sock = PQsocket ( conn ) ;\n if ( slot -> sock < 0 ) {\n fprintf ( stderr , _ ( \"%s: invalid socket: %s\" ) , progname , PQerrorMessage ( conn ) ) ;\n exit ( 1 ) ;\n }\n }", "hash": 468458465404335175, "project": "debian", "size": 9, "target": 0, "idx": 7246}
{"code": "static void check_new_cluster_is_empty ( void ) {\n int dbnum ;\n for ( dbnum = 0 ;\n dbnum < new_cluster . dbarr . ndbs ;\n dbnum ++ ) {\n int relnum ;\n RelInfoArr * rel_arr = & new_cluster . dbarr . dbs [ dbnum ] . rel_arr ;\n for ( relnum = 0 ;\n relnum < rel_arr -> nrels ;\n relnum ++ ) {\n if ( strcmp ( rel_arr -> rels [ relnum ] . nspname , \"pg_catalog\" ) != 0 ) pg_fatal ( \"New cluster database \\\"%s\\\" is not empty\\n\" , new_cluster . dbarr . dbs [ dbnum ] . db_name ) ;\n }\n }\n }", "hash": 2830888773500127914, "project": "debian", "size": 14, "target": 0, "idx": 7254}
{"code": "bool appendReloptionsArray ( PQExpBuffer buffer , const char * reloptions , const char * prefix , int encoding , bool std_strings ) {\n char * * options ;\n int noptions ;\n int i ;\n if ( ! parsePGArray ( reloptions , & options , & noptions ) ) {\n if ( options ) free ( options ) ;\n return false ;\n }\n for ( i = 0 ;\n i < noptions ;\n i ++ ) {\n char * option = options [ i ] ;\n char * name ;\n char * separator ;\n char * value ;\n name = option ;\n separator = strchr ( option , '=' ) ;\n if ( separator ) {\n * separator = '\\0' ;\n value = separator + 1 ;\n }\n else value = \"\" ;\n if ( i > 0 ) appendPQExpBufferStr ( buffer , \", \" ) ;\n appendPQExpBuffer ( buffer , \"%s%s=\" , prefix , fmtId ( name ) ) ;\n if ( strcmp ( fmtId ( value ) , value ) == 0 ) appendPQExpBufferStr ( buffer , value ) ;\n else appendStringLiteral ( buffer , value , encoding , std_strings ) ;\n }\n if ( options ) free ( options ) ;\n return true ;\n }", "hash": -650231346353974279, "project": "debian", "size": 30, "target": 0, "idx": 7284}
{"code": "const char * fmtQualifiedId ( int remoteVersion , const char * schema , const char * id ) {\n PQExpBuffer id_return ;\n PQExpBuffer lcl_pqexp = createPQExpBuffer ( ) ;\n if ( remoteVersion >= 70300 && schema && * schema ) {\n appendPQExpBuffer ( lcl_pqexp , \"%s.\" , fmtId ( schema ) ) ;\n }\n appendPQExpBufferStr ( lcl_pqexp , fmtId ( id ) ) ;\n id_return = getLocalPQExpBuffer ( ) ;\n appendPQExpBufferStr ( id_return , lcl_pqexp -> data ) ;\n destroyPQExpBuffer ( lcl_pqexp ) ;\n return id_return -> data ;\n }", "hash": -650231346353974279, "project": "debian", "size": 12, "target": 0, "idx": 7286}
{"code": "static void dummy ( void ) {\n }", "hash": 8083419164433894330, "project": "debian", "size": 2, "target": 0, "idx": 7307}
{"code": "static void do_encrypt ( MPI a , MPI b , MPI input , ELG_public_key * pkey ) {\n MPI k ;\n k = gen_k ( pkey -> p , 1 ) ;\n mpi_powm ( a , pkey -> g , k , pkey -> p ) ;\n mpi_powm ( b , pkey -> y , k , pkey -> p ) ;\n mpi_mulm ( b , b , input , pkey -> p ) ;\n # if 0 if ( DBG_CIPHER ) {\n log_mpidump ( \"elg encrypted y= \" , pkey -> y ) ;\n log_mpidump ( \"elg encrypted p= \" , pkey -> p ) ;\n log_mpidump ( \"elg encrypted k= \" , k ) ;\n log_mpidump ( \"elg encrypted M= \" , input ) ;\n log_mpidump ( \"elg encrypted a= \" , a ) ;\n log_mpidump ( \"elg encrypted b= \" , b ) ;\n }\n # endif mpi_free ( k ) ;\n }", "hash": -2751047985690578371, "project": "debian", "size": 16, "target": 0, "idx": 7310}
{"code": "static void vmsvga_fifo_run ( struct vmsvga_state_s * s ) {\n uint32_t cmd , colour ;\n int args , len ;\n int x , y , dx , dy , width , height ;\n struct vmsvga_cursor_definition_s cursor ;\n uint32_t cmd_start ;\n len = vmsvga_fifo_length ( s ) ;\n while ( len > 0 ) {\n cmd_start = s -> cmd -> stop ;\n switch ( cmd = vmsvga_fifo_read ( s ) ) {\n case SVGA_CMD_UPDATE : case SVGA_CMD_UPDATE_VERBOSE : len -= 5 ;\n if ( len < 0 ) {\n goto rewind ;\n }\n x = vmsvga_fifo_read ( s ) ;\n y = vmsvga_fifo_read ( s ) ;\n width = vmsvga_fifo_read ( s ) ;\n height = vmsvga_fifo_read ( s ) ;\n vmsvga_update_rect_delayed ( s , x , y , width , height ) ;\n break ;\n case SVGA_CMD_RECT_FILL : len -= 6 ;\n if ( len < 0 ) {\n goto rewind ;\n }\n colour = vmsvga_fifo_read ( s ) ;\n x = vmsvga_fifo_read ( s ) ;\n y = vmsvga_fifo_read ( s ) ;\n width = vmsvga_fifo_read ( s ) ;\n height = vmsvga_fifo_read ( s ) ;\n # ifdef HW_FILL_ACCEL vmsvga_fill_rect ( s , colour , x , y , width , height ) ;\n break ;\n # else args = 0 ;\n goto badcmd ;\n # endif case SVGA_CMD_RECT_COPY : len -= 7 ;\n if ( len < 0 ) {\n goto rewind ;\n }\n x = vmsvga_fifo_read ( s ) ;\n y = vmsvga_fifo_read ( s ) ;\n dx = vmsvga_fifo_read ( s ) ;\n dy = vmsvga_fifo_read ( s ) ;\n width = vmsvga_fifo_read ( s ) ;\n height = vmsvga_fifo_read ( s ) ;\n # ifdef HW_RECT_ACCEL vmsvga_copy_rect ( s , x , y , dx , dy , width , height ) ;\n break ;\n # else args = 0 ;\n goto badcmd ;\n # endif case SVGA_CMD_DEFINE_CURSOR : len -= 8 ;\n if ( len < 0 ) {\n goto rewind ;\n }\n cursor . id = vmsvga_fifo_read ( s ) ;\n cursor . hot_x = vmsvga_fifo_read ( s ) ;\n cursor . hot_y = vmsvga_fifo_read ( s ) ;\n cursor . width = x = vmsvga_fifo_read ( s ) ;\n cursor . height = y = vmsvga_fifo_read ( s ) ;\n vmsvga_fifo_read ( s ) ;\n cursor . bpp = vmsvga_fifo_read ( s ) ;\n args = SVGA_BITMAP_SIZE ( x , y ) + SVGA_PIXMAP_SIZE ( x , y , cursor . bpp ) ;\n if ( SVGA_BITMAP_SIZE ( x , y ) > sizeof cursor . mask || SVGA_PIXMAP_SIZE ( x , y , cursor . bpp ) > sizeof cursor . image ) {\n goto badcmd ;\n }\n len -= args ;\n if ( len < 0 ) {\n goto rewind ;\n }\n for ( args = 0 ;\n args < SVGA_BITMAP_SIZE ( x , y ) ;\n args ++ ) {\n cursor . mask [ args ] = vmsvga_fifo_read_raw ( s ) ;\n }\n for ( args = 0 ;\n args < SVGA_PIXMAP_SIZE ( x , y , cursor . bpp ) ;\n args ++ ) {\n cursor . image [ args ] = vmsvga_fifo_read_raw ( s ) ;\n }\n # ifdef HW_MOUSE_ACCEL vmsvga_cursor_define ( s , & cursor ) ;\n break ;\n # else args = 0 ;\n goto badcmd ;\n # endif case SVGA_CMD_DEFINE_ALPHA_CURSOR : len -= 6 ;\n if ( len < 0 ) {\n goto rewind ;\n }\n vmsvga_fifo_read ( s ) ;\n vmsvga_fifo_read ( s ) ;\n vmsvga_fifo_read ( s ) ;\n x = vmsvga_fifo_read ( s ) ;\n y = vmsvga_fifo_read ( s ) ;\n args = x * y ;\n goto badcmd ;\n case SVGA_CMD_RECT_ROP_FILL : args = 6 ;\n goto badcmd ;\n case SVGA_CMD_RECT_ROP_COPY : args = 7 ;\n goto badcmd ;\n case SVGA_CMD_DRAW_GLYPH_CLIPPED : len -= 4 ;\n if ( len < 0 ) {\n goto rewind ;\n }\n vmsvga_fifo_read ( s ) ;\n vmsvga_fifo_read ( s ) ;\n args = 7 + ( vmsvga_fifo_read ( s ) >> 2 ) ;\n goto badcmd ;\n case SVGA_CMD_SURFACE_ALPHA_BLEND : args = 12 ;\n goto badcmd ;\n case SVGA_CMD_SURFACE_FILL : case SVGA_CMD_SURFACE_COPY : case SVGA_CMD_FRONT_ROP_FILL : case SVGA_CMD_FENCE : case SVGA_CMD_INVALID_CMD : break ;\n default : args = 0 ;\n badcmd : len -= args ;\n if ( len < 0 ) {\n goto rewind ;\n }\n while ( args -- ) {\n vmsvga_fifo_read ( s ) ;\n }\n printf ( \"%s: Unknown command 0x%02x in SVGA command FIFO\\n\" , __func__ , cmd ) ;\n break ;\n rewind : s -> cmd -> stop = cmd_start ;\n break ;\n }\n }\n s -> syncing = 0 ;\n }", "hash": 3649198920984613385, "project": "debian", "size": 122, "target": 0, "idx": 7336}
{"code": "static void vmsvga_init ( DeviceState * dev , struct vmsvga_state_s * s , MemoryRegion * address_space , MemoryRegion * io ) {\n s -> scratch_size = SVGA_SCRATCH_SIZE ;\n s -> scratch = g_malloc ( s -> scratch_size * 4 ) ;\n s -> vga . con = graphic_console_init ( dev , 0 , & vmsvga_ops , s ) ;\n s -> fifo_size = SVGA_FIFO_SIZE ;\n memory_region_init_ram ( & s -> fifo_ram , NULL , \"vmsvga.fifo\" , s -> fifo_size , & error_abort ) ;\n vmstate_register_ram_global ( & s -> fifo_ram ) ;\n s -> fifo_ptr = memory_region_get_ram_ptr ( & s -> fifo_ram ) ;\n vga_common_init ( & s -> vga , OBJECT ( dev ) , true ) ;\n vga_init ( & s -> vga , OBJECT ( dev ) , address_space , io , true ) ;\n vmstate_register ( NULL , 0 , & vmstate_vga_common , & s -> vga ) ;\n s -> new_depth = 32 ;\n }", "hash": 3649198920984613385, "project": "debian", "size": 13, "target": 0, "idx": 7343}
{"code": "static int get_list_files ( DYNAMIC_STRING * ds , const DYNAMIC_STRING * ds_dirname , const DYNAMIC_STRING * ds_wild ) {\n uint i ;\n MY_DIR * dir_info ;\n FILEINFO * file ;\n DBUG_ENTER ( \"get_list_files\" ) ;\n DBUG_PRINT ( \"info\" , ( \"listing directory: %s\" , ds_dirname -> str ) ) ;\n if ( ! ( dir_info = my_dir ( ds_dirname -> str , MYF ( 0 ) ) ) ) DBUG_RETURN ( 1 ) ;\n set_wild_chars ( 1 ) ;\n for ( i = 0 ;\n i < ( uint ) dir_info -> number_off_files ;\n i ++ ) {\n file = dir_info -> dir_entry + i ;\n if ( file -> name [ 0 ] == '.' && ( file -> name [ 1 ] == '\\0' || ( file -> name [ 1 ] == '.' && file -> name [ 2 ] == '\\0' ) ) ) continue ;\n if ( ds_wild && ds_wild -> length && wild_compare ( file -> name , ds_wild -> str , 0 ) ) continue ;\n replace_dynstr_append ( ds , file -> name ) ;\n dynstr_append ( ds , \"\\n\" ) ;\n }\n set_wild_chars ( 0 ) ;\n my_dirend ( dir_info ) ;\n DBUG_RETURN ( 0 ) ;\n }", "hash": 1182028467273264883, "project": "debian", "size": 21, "target": 0, "idx": 7361}
{"code": "static int match_expected_error ( struct st_command * command , unsigned int err_errno , const char * err_sqlstate ) {\n uint i ;\n for ( i = 0 ;\n ( uint ) i < command -> expected_errors . count ;\n i ++ ) {\n if ( ( command -> expected_errors . err [ i ] . type == ERR_ERRNO ) && ( command -> expected_errors . err [ i ] . code . errnum == err_errno ) ) return i ;\n if ( command -> expected_errors . err [ i ] . type == ERR_SQLSTATE ) {\n if ( unlikely ( err_sqlstate == NULL ) ) die ( \"expecting a SQL-state (%s) from query '%s' which cannot \" \"produce one...\" , command -> expected_errors . err [ i ] . code . sqlstate , command -> query ) ;\n if ( strncmp ( command -> expected_errors . err [ i ] . code . sqlstate , err_sqlstate , SQLSTATE_LENGTH ) == 0 ) return i ;\n }\n }\n return - 1 ;\n }", "hash": 1182028467273264883, "project": "debian", "size": 13, "target": 0, "idx": 7367}
{"code": "void do_get_replace_regex ( struct st_command * command ) {\n char * expr = command -> first_argument ;\n free_replace_regex ( ) ;\n if ( * expr == '$' ) {\n VAR * val = var_get ( expr , NULL , 0 , 1 ) ;\n expr = val ? val -> str_val : NULL ;\n }\n if ( expr && * expr && ! ( glob_replace_regex = init_replace_regex ( expr ) ) ) die ( \"Could not init replace_regex\" ) ;\n command -> last_argument = command -> end ;\n }", "hash": 1182028467273264883, "project": "debian", "size": 10, "target": 0, "idx": 7368}
{"code": "int multi_reg_replace ( struct st_replace_regex * r , char * val ) {\n uint i ;\n char * in_buf , * out_buf ;\n int * buf_len_p ;\n in_buf = val ;\n out_buf = r -> even_buf ;\n buf_len_p = & r -> even_buf_len ;\n r -> buf = 0 ;\n for ( i = 0 ;\n i < r -> regex_arr . elements ;\n i ++ ) {\n struct st_regex re ;\n char * save_out_buf = out_buf ;\n get_dynamic ( & r -> regex_arr , ( uchar * ) & re , i ) ;\n if ( ! reg_replace ( & out_buf , buf_len_p , re . pattern , re . replace , in_buf , re . icase ) ) {\n if ( save_out_buf != out_buf ) {\n if ( save_out_buf == r -> even_buf ) r -> even_buf = out_buf ;\n else r -> odd_buf = out_buf ;\n }\n r -> buf = out_buf ;\n if ( in_buf == val ) in_buf = r -> odd_buf ;\n swap_variables ( char * , in_buf , out_buf ) ;\n buf_len_p = ( out_buf == r -> even_buf ) ? & r -> even_buf_len : & r -> odd_buf_len ;\n }\n }\n return ( r -> buf == 0 ) ;\n }", "hash": 1182028467273264883, "project": "debian", "size": 27, "target": 0, "idx": 7395}
{"code": "static my_bool get_one_option ( int optid , const struct my_option * opt , char * argument ) {\n switch ( optid ) {\n case '#' : # ifndef DBUG_OFF DBUG_PUSH ( argument ? argument : \"d:t:S:i:O,/tmp/mysqltest.trace\" ) ;\n debug_check_flag = 1 ;\n debug_info_flag = 1 ;\n # endif break ;\n case 'r' : record = 1 ;\n break ;\n case 'x' : {\n char buff [ FN_REFLEN ] ;\n if ( ! test_if_hard_path ( argument ) ) {\n strxmov ( buff , opt_basedir , argument , NullS ) ;\n argument = buff ;\n }\n fn_format ( buff , argument , \"\" , \"\" , MY_UNPACK_FILENAME ) ;\n DBUG_ASSERT ( cur_file == file_stack && cur_file -> file == 0 ) ;\n if ( ! ( cur_file -> file = fopen ( buff , \"rb\" ) ) ) die ( \"Could not open '%s' for reading, errno: %d\" , buff , errno ) ;\n cur_file -> file_name = my_strdup ( buff , MYF ( MY_FAE ) ) ;\n cur_file -> lineno = 1 ;\n break ;\n }\n case 'm' : {\n static char buff [ FN_REFLEN ] ;\n if ( ! test_if_hard_path ( argument ) ) {\n strxmov ( buff , opt_basedir , argument , NullS ) ;\n argument = buff ;\n }\n fn_format ( buff , argument , \"\" , \"\" , MY_UNPACK_FILENAME ) ;\n timer_file = buff ;\n unlink ( timer_file ) ;\n break ;\n }\n case 'p' : if ( argument == disabled_my_option ) argument = ( char * ) \"\" ;\n if ( argument ) {\n my_free ( opt_pass ) ;\n opt_pass = my_strdup ( argument , MYF ( MY_FAE ) ) ;\n while ( * argument ) * argument ++ = 'x' ;\n tty_password = 0 ;\n }\n else tty_password = 1 ;\n break ;\n # include < sslopt - case . h > case 't' : strnmov ( TMPDIR , argument , sizeof ( TMPDIR ) ) ;\n break ;\n case 'A' : if ( ! embedded_server_arg_count ) {\n embedded_server_arg_count = 1 ;\n embedded_server_args [ 0 ] = ( char * ) \"\" ;\n }\n if ( embedded_server_arg_count == MAX_EMBEDDED_SERVER_ARGS - 1 || ! ( embedded_server_args [ embedded_server_arg_count ++ ] = my_strdup ( argument , MYF ( MY_FAE ) ) ) ) {\n die ( \"Can't use server argument\" ) ;\n }\n break ;\n case OPT_LOG_DIR : if ( access ( opt_logdir , F_OK ) != 0 ) die ( \"The specified log directory does not exist: '%s'\" , opt_logdir ) ;\n break ;\n case 'F' : read_embedded_server_arguments ( argument ) ;\n break ;\n case OPT_RESULT_FORMAT_VERSION : set_result_format_version ( opt_result_format_version ) ;\n break ;\n case 'V' : print_version ( ) ;\n exit ( 0 ) ;\n case OPT_MYSQL_PROTOCOL : # ifndef EMBEDDED_LIBRARY opt_protocol = find_type_or_exit ( argument , & sql_protocol_typelib , opt -> name ) ;\n # endif break ;\n case '?' : usage ( ) ;\n exit ( 0 ) ;\n }\n return 0 ;\n }", "hash": 1182028467273264883, "project": "debian", "size": 66, "target": 0, "idx": 7432}
{"code": "int connect_n_handle_errors ( struct st_command * command , MYSQL * con , const char * host , const char * user , const char * pass , const char * db , int port , const char * sock ) {\n DYNAMIC_STRING * ds ;\n int failed_attempts = 0 ;\n ds = & ds_res ;\n if ( command -> expected_errors . count > 0 && ! disable_query_log ) {\n dynstr_append_mem ( ds , \"connect(\" , 8 ) ;\n replace_dynstr_append ( ds , host ) ;\n dynstr_append_mem ( ds , \",\" , 1 ) ;\n replace_dynstr_append ( ds , user ) ;\n dynstr_append_mem ( ds , \",\" , 1 ) ;\n replace_dynstr_append ( ds , pass ) ;\n dynstr_append_mem ( ds , \",\" , 1 ) ;\n if ( db ) replace_dynstr_append ( ds , db ) ;\n dynstr_append_mem ( ds , \",\" , 1 ) ;\n replace_dynstr_append_uint ( ds , port ) ;\n dynstr_append_mem ( ds , \",\" , 1 ) ;\n if ( sock ) replace_dynstr_append ( ds , sock ) ;\n dynstr_append_mem ( ds , \")\" , 1 ) ;\n dynstr_append_mem ( ds , delimiter , delimiter_length ) ;\n dynstr_append_mem ( ds , \"\\n\" , 1 ) ;\n }\n if ( ! disable_connect_log && ! disable_query_log ) {\n replace_dynstr_append ( ds , command -> query ) ;\n dynstr_append_mem ( ds , \";\n\\n\" , 2 ) ;\n }\n while ( ! mysql_real_connect ( con , host , user , pass , db , port , sock ? sock : 0 , CLIENT_MULTI_STATEMENTS ) ) {\n if ( ( ( mysql_errno ( con ) == ER_TOO_MANY_USER_CONNECTIONS ) || ( mysql_errno ( con ) == ER_USER_LIMIT_REACHED ) ) && ( failed_attempts ++ < opt_max_connect_retries ) ) {\n int i ;\n i = match_expected_error ( command , mysql_errno ( con ) , mysql_sqlstate ( con ) ) ;\n if ( i >= 0 ) goto do_handle_error ;\n my_sleep ( connection_retry_sleep ) ;\n continue ;\n }\n do_handle_error : var_set_errno ( mysql_errno ( con ) ) ;\n handle_error ( command , mysql_errno ( con ) , mysql_error ( con ) , mysql_sqlstate ( con ) , ds ) ;\n return 0 ;\n }\n var_set_errno ( 0 ) ;\n handle_no_error ( command ) ;\n revert_properties ( ) ;\n return 1 ;\n }", "hash": 1182028467273264883, "project": "debian", "size": 43, "target": 0, "idx": 7448}
{"code": "static void show_warnings_before_error ( MYSQL * mysql ) {\n MYSQL_RES * res ;\n const char * query = \"SHOW WARNINGS\" ;\n DBUG_ENTER ( \"show_warnings_before_error\" ) ;\n if ( ! mysql ) DBUG_VOID_RETURN ;\n if ( mysql_query ( mysql , query ) ) {\n log_msg ( \"Error running query '%s': %d %s\" , query , mysql_errno ( mysql ) , mysql_error ( mysql ) ) ;\n DBUG_VOID_RETURN ;\n }\n if ( ( res = mysql_store_result ( mysql ) ) == NULL ) {\n DBUG_VOID_RETURN ;\n }\n if ( mysql_num_rows ( res ) <= 1 ) {\n }\n else {\n MYSQL_ROW row ;\n unsigned int row_num = 0 ;\n unsigned int num_fields = mysql_num_fields ( res ) ;\n fprintf ( stderr , \"\\nWarnings from just before the error:\\n\" ) ;\n while ( ( row = mysql_fetch_row ( res ) ) ) {\n unsigned int i ;\n unsigned long * lengths = mysql_fetch_lengths ( res ) ;\n if ( ++ row_num >= mysql_num_rows ( res ) ) {\n break ;\n }\n for ( i = 0 ;\n i < num_fields ;\n i ++ ) {\n fprintf ( stderr , \"%.*s \" , ( int ) lengths [ i ] , row [ i ] ? row [ i ] : \"NULL\" ) ;\n }\n fprintf ( stderr , \"\\n\" ) ;\n }\n }\n mysql_free_result ( res ) ;\n DBUG_VOID_RETURN ;\n }", "hash": 1182028467273264883, "project": "debian", "size": 36, "target": 0, "idx": 7457}
{"code": "void my_ungetc ( int c ) {\n * line_buffer_pos ++ = ( char ) c ;\n }", "hash": 1182028467273264883, "project": "debian", "size": 3, "target": 0, "idx": 7474}
{"code": "const char * get_errname_from_code ( uint error_code ) {\n const char * name ;\n if ( ( name = get_errname_from_code ( error_code , global_error_names ) ) != unknown_error ) return name ;\n return get_errname_from_code ( error_code , handler_error_names ) ;\n }", "hash": 1182028467273264883, "project": "debian", "size": 5, "target": 0, "idx": 7478}
{"code": "static void do_list_files_write_file_command ( struct st_command * command , my_bool append ) {\n int error ;\n static DYNAMIC_STRING ds_content ;\n static DYNAMIC_STRING ds_filename ;\n static DYNAMIC_STRING ds_dirname ;\n static DYNAMIC_STRING ds_wild ;\n const struct command_arg list_files_args [ ] = {\n {\n \"filename\" , ARG_STRING , TRUE , & ds_filename , \"Filename for write\" }\n , {\n \"dirname\" , ARG_STRING , TRUE , & ds_dirname , \"Directory to list\" }\n , {\n \"file\" , ARG_STRING , FALSE , & ds_wild , \"Filename (incl. wildcard)\" }\n }\n ;\n DBUG_ENTER ( \"do_list_files_write_file\" ) ;\n command -> used_replace = 1 ;\n check_command_args ( command , command -> first_argument , list_files_args , sizeof ( list_files_args ) / sizeof ( struct command_arg ) , ' ' ) ;\n init_dynamic_string ( & ds_content , \"\" , 1024 , 1024 ) ;\n error = get_list_files ( & ds_content , & ds_dirname , & ds_wild ) ;\n handle_command_error ( command , error , my_errno ) ;\n str_to_file2 ( ds_filename . str , ds_content . str , ds_content . length , append ) ;\n dynstr_free ( & ds_content ) ;\n dynstr_free ( & ds_filename ) ;\n dynstr_free ( & ds_dirname ) ;\n dynstr_free ( & ds_wild ) ;\n DBUG_VOID_RETURN ;\n }", "hash": 1182028467273264883, "project": "debian", "size": 28, "target": 0, "idx": 7482}
{"code": "static int run_command ( char * cmd , DYNAMIC_STRING * ds_res ) {\n char buf [ 512 ] = {\n 0 }\n ;\n FILE * res_file ;\n int error ;\n DBUG_ENTER ( \"run_command\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"cmd: %s\" , cmd ) ) ;\n if ( ! ( res_file = popen ( cmd , \"r\" ) ) ) {\n report_or_die ( \"popen(\\\"%s\\\", \\\"r\\\") failed\" , cmd ) ;\n return - 1 ;\n }\n while ( fgets ( buf , sizeof ( buf ) , res_file ) ) {\n DBUG_PRINT ( \"info\" , ( \"buf: %s\" , buf ) ) ;\n if ( ds_res ) {\n dynstr_append ( ds_res , buf ) ;\n }\n else {\n fprintf ( stdout , \"%s\" , buf ) ;\n }\n }\n error = pclose ( res_file ) ;\n DBUG_RETURN ( WEXITSTATUS ( error ) ) ;\n }", "hash": 1182028467273264883, "project": "debian", "size": 24, "target": 0, "idx": 7511}
{"code": "char * get_string ( char * * to_ptr , char * * from_ptr , struct st_command * command ) {\n char c , sep ;\n char * to = * to_ptr , * from = * from_ptr , * start = to ;\n DBUG_ENTER ( \"get_string\" ) ;\n if ( * from == '\"' || * from == '\\'' ) sep = * from ++ ;\n else sep = ' ' ;\n for ( ;\n ( c = * from ) ;\n from ++ ) {\n if ( c == '\\\\' && from [ 1 ] ) {\n switch ( * ++ from ) {\n case 'n' : * to ++ = '\\n' ;\n break ;\n case 't' : * to ++ = '\\t' ;\n break ;\n case 'r' : * to ++ = '\\r' ;\n break ;\n case 'b' : * to ++ = '\\b' ;\n break ;\n case 'Z' : * to ++ = '\\032' ;\n break ;\n default : * to ++ = * from ;\n break ;\n }\n }\n else if ( c == sep ) {\n if ( c == ' ' || c != * ++ from ) break ;\n * to ++ = c ;\n }\n else * to ++ = c ;\n }\n if ( * from != ' ' && * from ) die ( \"Wrong string argument in %s\" , command -> query ) ;\n while ( my_isspace ( charset_info , * from ) ) from ++ ;\n * to = 0 ;\n * to_ptr = to + 1 ;\n * from_ptr = from ;\n if ( * start == '$' ) {\n const char * end = to ;\n VAR * var = var_get ( start , & end , 0 , 1 ) ;\n if ( var && to == ( char * ) end + 1 ) {\n DBUG_PRINT ( \"info\" , ( \"var: '%s' -> '%s'\" , start , var -> str_val ) ) ;\n DBUG_RETURN ( var -> str_val ) ;\n }\n }\n DBUG_RETURN ( start ) ;\n }", "hash": 1182028467273264883, "project": "debian", "size": 46, "target": 0, "idx": 7528}
{"code": "void internal_set_bit ( REP_SET * set , uint bit ) {\n set -> bits [ bit / WORD_BIT ] |= 1 << ( bit % WORD_BIT ) ;\n return ;\n }", "hash": 1182028467273264883, "project": "debian", "size": 4, "target": 0, "idx": 7533}
{"code": "int get_next_bit ( REP_SET * set , uint lastpos ) {\n uint pos , * start , * end , bits ;\n start = set -> bits + ( ( lastpos + 1 ) / WORD_BIT ) ;\n end = set -> bits + set -> size_of_bits ;\n bits = start [ 0 ] & ~ ( ( 1 << ( ( lastpos + 1 ) % WORD_BIT ) ) - 1 ) ;\n while ( ! bits && ++ start < end ) bits = start [ 0 ] ;\n if ( ! bits ) return 0 ;\n pos = ( uint ) ( start - set -> bits ) * WORD_BIT ;\n while ( ! ( bits & 1 ) ) {\n bits >>= 1 ;\n pos ++ ;\n }\n return pos ;\n }", "hash": 1182028467273264883, "project": "debian", "size": 14, "target": 0, "idx": 7534}
{"code": "void append_info ( DYNAMIC_STRING * ds , ulonglong affected_rows , const char * info ) {\n char buf [ 40 ] , buff2 [ 21 ] ;\n sprintf ( buf , \"affected rows: %s\\n\" , llstr ( affected_rows , buff2 ) ) ;\n dynstr_append ( ds , buf ) ;\n if ( info ) {\n dynstr_append ( ds , \"info: \" ) ;\n dynstr_append ( ds , info ) ;\n dynstr_append_mem ( ds , \"\\n\" , 1 ) ;\n }\n }", "hash": 1182028467273264883, "project": "debian", "size": 10, "target": 0, "idx": 7535}
{"code": "int EVP_EncryptFinal_ex ( EVP_CIPHER_CTX * ctx , unsigned char * out , int * outl ) {\n int n , ret ;\n unsigned int i , b , bl ;\n if ( ctx -> cipher -> flags & EVP_CIPH_FLAG_CUSTOM_CIPHER ) {\n ret = ctx -> cipher -> do_cipher ( ctx , out , NULL , 0 ) ;\n if ( ret < 0 ) return 0 ;\n else * outl = ret ;\n return 1 ;\n }\n b = ctx -> cipher -> block_size ;\n OPENSSL_assert ( b <= sizeof ctx -> buf ) ;\n if ( b == 1 ) {\n * outl = 0 ;\n return 1 ;\n }\n bl = ctx -> buf_len ;\n if ( ctx -> flags & EVP_CIPH_NO_PADDING ) {\n if ( bl ) {\n EVPerr ( EVP_F_EVP_ENCRYPTFINAL_EX , EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH ) ;\n return 0 ;\n }\n * outl = 0 ;\n return 1 ;\n }\n n = b - bl ;\n for ( i = bl ;\n i < b ;\n i ++ ) ctx -> buf [ i ] = n ;\n ret = ctx -> cipher -> do_cipher ( ctx , out , ctx -> buf , b ) ;\n if ( ret ) * outl = b ;\n return ret ;\n }", "hash": 1700977331036764538, "project": "debian", "size": 32, "target": 0, "idx": 7562}
{"code": "static int match_principals_file ( struct ssh * ssh , struct passwd * pw , char * file , struct sshkey_cert * cert , struct sshauthopt * * authoptsp ) {\n FILE * f ;\n int success ;\n if ( authoptsp != NULL ) * authoptsp = NULL ;\n temporarily_use_uid ( pw ) ;\n debug ( \"trying authorized principals file %s\" , file ) ;\n if ( ( f = auth_openprincipals ( file , pw , options . strict_modes ) ) == NULL ) {\n restore_uid ( ) ;\n return 0 ;\n }\n success = process_principals ( ssh , f , file , cert , authoptsp ) ;\n fclose ( f ) ;\n restore_uid ( ) ;\n return success ;\n }", "hash": 7847057953677889923, "project": "debian", "size": 15, "target": 0, "idx": 7570}
{"code": "static int process_principals ( struct ssh * ssh , FILE * f , const char * file , const struct sshkey_cert * cert , struct sshauthopt * * authoptsp ) {\n char loc [ 256 ] , * line = NULL , * cp , * ep ;\n size_t linesize = 0 ;\n u_long linenum = 0 ;\n u_int found_principal = 0 ;\n if ( authoptsp != NULL ) * authoptsp = NULL ;\n while ( getline ( & line , & linesize , f ) != - 1 ) {\n linenum ++ ;\n if ( found_principal ) continue ;\n for ( cp = line ;\n * cp == ' ' || * cp == '\\t' ;\n cp ++ ) ;\n if ( ( ep = strchr ( cp , '#' ) ) != NULL ) * ep = '\\0' ;\n if ( ! * cp || * cp == '\\n' ) continue ;\n snprintf ( loc , sizeof ( loc ) , \"%.200s:%lu\" , file , linenum ) ;\n if ( check_principals_line ( ssh , cp , cert , loc , authoptsp ) == 0 ) found_principal = 1 ;\n }\n free ( line ) ;\n return found_principal ;\n }", "hash": 7847057953677889923, "project": "debian", "size": 20, "target": 0, "idx": 7572}
{"code": "static int match_principals_command ( struct ssh * ssh , struct passwd * user_pw , const struct sshkey * key , struct sshauthopt * * authoptsp ) {\n struct passwd * runas_pw = NULL ;\n const struct sshkey_cert * cert = key -> cert ;\n FILE * f = NULL ;\n int r , ok , found_principal = 0 ;\n int i , ac = 0 , uid_swapped = 0 ;\n pid_t pid ;\n char * tmp , * username = NULL , * command = NULL , * * av = NULL ;\n char * ca_fp = NULL , * key_fp = NULL , * catext = NULL , * keytext = NULL ;\n char serial_s [ 16 ] , uidstr [ 32 ] ;\n void ( * osigchld ) ( int ) ;\n if ( authoptsp != NULL ) * authoptsp = NULL ;\n if ( options . authorized_principals_command == NULL ) return 0 ;\n if ( options . authorized_principals_command_user == NULL ) {\n error ( \"No user for AuthorizedPrincipalsCommand specified, \" \"skipping\" ) ;\n return 0 ;\n }\n osigchld = signal ( SIGCHLD , SIG_DFL ) ;\n username = percent_expand ( options . authorized_principals_command_user , \"u\" , user_pw -> pw_name , ( char * ) NULL ) ;\n runas_pw = getpwnam ( username ) ;\n if ( runas_pw == NULL ) {\n error ( \"AuthorizedPrincipalsCommandUser \\\"%s\\\" not found: %s\" , username , strerror ( errno ) ) ;\n goto out ;\n }\n if ( argv_split ( options . authorized_principals_command , & ac , & av ) != 0 ) {\n error ( \"AuthorizedPrincipalsCommand \\\"%s\\\" contains \" \"invalid quotes\" , command ) ;\n goto out ;\n }\n if ( ac == 0 ) {\n error ( \"AuthorizedPrincipalsCommand \\\"%s\\\" yielded no arguments\" , command ) ;\n goto out ;\n }\n if ( ( ca_fp = sshkey_fingerprint ( cert -> signature_key , options . fingerprint_hash , SSH_FP_DEFAULT ) ) == NULL ) {\n error ( \"%s: sshkey_fingerprint failed\" , __func__ ) ;\n goto out ;\n }\n if ( ( key_fp = sshkey_fingerprint ( key , options . fingerprint_hash , SSH_FP_DEFAULT ) ) == NULL ) {\n error ( \"%s: sshkey_fingerprint failed\" , __func__ ) ;\n goto out ;\n }\n if ( ( r = sshkey_to_base64 ( cert -> signature_key , & catext ) ) != 0 ) {\n error ( \"%s: sshkey_to_base64 failed: %s\" , __func__ , ssh_err ( r ) ) ;\n goto out ;\n }\n if ( ( r = sshkey_to_base64 ( key , & keytext ) ) != 0 ) {\n error ( \"%s: sshkey_to_base64 failed: %s\" , __func__ , ssh_err ( r ) ) ;\n goto out ;\n }\n snprintf ( serial_s , sizeof ( serial_s ) , \"%llu\" , ( unsigned long long ) cert -> serial ) ;\n snprintf ( uidstr , sizeof ( uidstr ) , \"%llu\" , ( unsigned long long ) user_pw -> pw_uid ) ;\n for ( i = 1 ;\n i < ac ;\n i ++ ) {\n tmp = percent_expand ( av [ i ] , \"U\" , uidstr , \"u\" , user_pw -> pw_name , \"h\" , user_pw -> pw_dir , \"t\" , sshkey_ssh_name ( key ) , \"T\" , sshkey_ssh_name ( cert -> signature_key ) , \"f\" , key_fp , \"F\" , ca_fp , \"k\" , keytext , \"K\" , catext , \"i\" , cert -> key_id , \"s\" , serial_s , ( char * ) NULL ) ;\n if ( tmp == NULL ) fatal ( \"%s: percent_expand failed\" , __func__ ) ;\n free ( av [ i ] ) ;\n av [ i ] = tmp ;\n }\n command = argv_assemble ( ac , av ) ;\n if ( ( pid = subprocess ( \"AuthorizedPrincipalsCommand\" , runas_pw , command , ac , av , & f , SSH_SUBPROCESS_STDOUT_CAPTURE | SSH_SUBPROCESS_STDERR_DISCARD ) ) == 0 ) goto out ;\n uid_swapped = 1 ;\n temporarily_use_uid ( runas_pw ) ;\n ok = process_principals ( ssh , f , \"(command)\" , cert , authoptsp ) ;\n fclose ( f ) ;\n f = NULL ;\n if ( exited_cleanly ( pid , \"AuthorizedPrincipalsCommand\" , command , 0 ) != 0 ) goto out ;\n found_principal = ok ;\n out : if ( f != NULL ) fclose ( f ) ;\n signal ( SIGCHLD , osigchld ) ;\n for ( i = 0 ;\n i < ac ;\n i ++ ) free ( av [ i ] ) ;\n free ( av ) ;\n if ( uid_swapped ) restore_uid ( ) ;\n free ( command ) ;\n free ( username ) ;\n free ( ca_fp ) ;\n free ( key_fp ) ;\n free ( catext ) ;\n free ( keytext ) ;\n return found_principal ;\n }", "hash": 7847057953677889923, "project": "debian", "size": 82, "target": 0, "idx": 7581}
{"code": "static int rtp_packetize_g726_40 ( sout_stream_id_sys_t * id , block_t * in ) {\n return rtp_packetize_g726 ( id , in , 8 ) ;\n }", "hash": 3935234056444097745, "project": "debian", "size": 3, "target": 0, "idx": 7594}
{"code": "static int rtp_packetize_h263 ( sout_stream_id_sys_t * id , block_t * in ) {\n uint8_t * p_data = in -> p_buffer ;\n int i_data = in -> i_buffer ;\n int i ;\n int i_max = rtp_mtu ( id ) - RTP_H263_HEADER_SIZE ;\n int i_count ;\n int b_p_bit ;\n int b_v_bit = 0 ;\n int i_plen = 0 ;\n int i_pebit = 0 ;\n uint16_t h ;\n if ( i_data < 2 ) {\n block_Release ( in ) ;\n return VLC_EGENERIC ;\n }\n if ( p_data [ 0 ] || p_data [ 1 ] ) {\n block_Release ( in ) ;\n return VLC_EGENERIC ;\n }\n p_data += 2 ;\n i_data -= 2 ;\n i_count = ( i_data + i_max - 1 ) / i_max ;\n for ( i = 0 ;\n i < i_count ;\n i ++ ) {\n int i_payload = __MIN ( i_max , i_data ) ;\n block_t * out = block_Alloc ( RTP_H263_PAYLOAD_START + i_payload ) ;\n b_p_bit = ( i == 0 ) ? 1 : 0 ;\n h = ( b_p_bit << 10 ) | ( b_v_bit << 9 ) | ( i_plen << 3 ) | i_pebit ;\n rtp_packetize_common ( id , out , ( i == i_count - 1 ) ? 1 : 0 , in -> i_pts > VLC_TS_INVALID ? in -> i_pts : in -> i_dts ) ;\n SetWBE ( out -> p_buffer + 12 , h ) ;\n memcpy ( & out -> p_buffer [ RTP_H263_PAYLOAD_START ] , p_data , i_payload ) ;\n out -> i_dts = in -> i_dts + i * in -> i_length / i_count ;\n out -> i_length = in -> i_length / i_count ;\n rtp_packetize_send ( id , out ) ;\n p_data += i_payload ;\n i_data -= i_payload ;\n }\n block_Release ( in ) ;\n return VLC_SUCCESS ;\n }", "hash": 3935234056444097745, "project": "debian", "size": 41, "target": 0, "idx": 7602}
{"code": "static int rtp_packetize_amr ( sout_stream_id_sys_t * id , block_t * in ) {\n int i_max = rtp_mtu ( id ) - 2 ;\n int i_count = ( in -> i_buffer + i_max - 1 ) / i_max ;\n uint8_t * p_data = in -> p_buffer ;\n int i_data = in -> i_buffer ;\n int i ;\n for ( i = 0 ;\n i < i_count ;\n i ++ ) {\n int i_payload = __MIN ( i_max , i_data ) ;\n block_t * out = block_Alloc ( 14 + i_payload ) ;\n rtp_packetize_common ( id , out , ( ( i == i_count - 1 ) ? 1 : 0 ) , ( in -> i_pts > VLC_TS_INVALID ? in -> i_pts : in -> i_dts ) ) ;\n out -> p_buffer [ 12 ] = 0xF0 ;\n out -> p_buffer [ 13 ] = p_data [ 0 ] & 0x7C ;\n memcpy ( & out -> p_buffer [ 14 ] , p_data + 1 , i_payload - 1 ) ;\n out -> i_buffer -- ;\n out -> i_dts = in -> i_dts + i * in -> i_length / i_count ;\n out -> i_length = in -> i_length / i_count ;\n rtp_packetize_send ( id , out ) ;\n p_data += i_payload ;\n i_data -= i_payload ;\n }\n block_Release ( in ) ;\n return VLC_SUCCESS ;\n }", "hash": 3935234056444097745, "project": "debian", "size": 25, "target": 0, "idx": 7612}
{"code": "int mi_repair ( MI_CHECK * param , register MI_INFO * info , char * name , int rep_quick , my_bool no_copy_stat ) {\n int error , got_error ;\n ha_rows start_records , new_header_length ;\n my_off_t del ;\n File new_file ;\n MYISAM_SHARE * share = info -> s ;\n char llbuff [ 22 ] , llbuff2 [ 22 ] ;\n SORT_INFO sort_info ;\n MI_SORT_PARAM sort_param ;\n DBUG_ENTER ( \"mi_repair\" ) ;\n bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ;\n bzero ( ( char * ) & sort_param , sizeof ( sort_param ) ) ;\n start_records = info -> state -> records ;\n new_header_length = ( param -> testflag & T_UNPACK ) ? 0L : share -> pack . header_length ;\n got_error = 1 ;\n new_file = - 1 ;\n sort_param . sort_info = & sort_info ;\n if ( ! ( param -> testflag & T_SILENT ) ) {\n printf ( \"- recovering (with keycache) MyISAM-table '%s'\\n\" , name ) ;\n printf ( \"Data records: %s\\n\" , llstr ( info -> state -> records , llbuff ) ) ;\n }\n param -> testflag |= T_REP ;\n if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ;\n DBUG_ASSERT ( param -> use_buffers < SIZE_T_MAX ) ;\n if ( ! param -> using_global_keycache ) ( void ) init_key_cache ( dflt_key_cache , param -> key_cache_block_size , param -> use_buffers , 0 , 0 ) ;\n if ( init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) ) {\n bzero ( & info -> rec_cache , sizeof ( info -> rec_cache ) ) ;\n goto err ;\n }\n if ( ! rep_quick ) if ( init_io_cache ( & info -> rec_cache , - 1 , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) ) ) goto err ;\n info -> opt_flag |= WRITE_CACHE_USED ;\n if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param . record ) || ! mi_alloc_rec_buff ( info , - 1 , & sort_param . rec_buff ) ) {\n mi_check_print_error ( param , \"Not enough memory for extra record\" ) ;\n goto err ;\n }\n if ( ! rep_quick ) {\n if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , \"\" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) {\n mi_check_print_error ( param , \"Can't create new tempfile: '%s'\" , param -> temp_filename ) ;\n goto err ;\n }\n if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , \"datafile-header\" ) ) goto err ;\n info -> s -> state . dellink = HA_OFFSET_ERROR ;\n info -> rec_cache . file = new_file ;\n if ( param -> testflag & T_UNPACK ) {\n share -> options &= ~ HA_OPTION_COMPRESS_RECORD ;\n mi_int2store ( share -> state . header . options , share -> options ) ;\n }\n }\n sort_info . info = info ;\n sort_info . param = param ;\n sort_param . read_cache = param -> read_cache ;\n sort_param . pos = sort_param . max_pos = share -> pack . header_length ;\n sort_param . filepos = new_header_length ;\n param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( info -> dfile , 0L , MY_SEEK_END , MYF ( 0 ) ) ;\n sort_info . dupp = 0 ;\n sort_param . fix_datafile = ( my_bool ) ( ! rep_quick ) ;\n sort_param . master = 1 ;\n sort_info . max_records = ~ ( ha_rows ) 0 ;\n set_data_file_type ( & sort_info , share ) ;\n del = info -> state -> del ;\n info -> state -> records = info -> state -> del = share -> state . split = 0 ;\n info -> state -> empty = 0 ;\n param -> glob_crc = 0 ;\n if ( param -> testflag & T_CALC_CHECKSUM ) sort_param . calc_checksum = 1 ;\n info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;\n if ( param -> testflag & T_CREATE_MISSING_KEYS ) mi_set_all_keys_active ( share -> state . key_map , share -> base . keys ) ;\n mi_drop_all_indexes ( param , info , TRUE ) ;\n lock_memory ( param ) ;\n while ( ! ( error = sort_get_next_record ( & sort_param ) ) ) {\n if ( writekeys ( & sort_param ) ) {\n if ( my_errno != HA_ERR_FOUND_DUPP_KEY ) goto err ;\n DBUG_DUMP ( \"record\" , ( uchar * ) sort_param . record , share -> base . pack_reclength ) ;\n mi_check_print_info ( param , \"Duplicate key %2d for record at %10s against new record at %10s\" , info -> errkey + 1 , llstr ( sort_param . start_recpos , llbuff ) , llstr ( info -> dupp_key_pos , llbuff2 ) ) ;\n if ( param -> testflag & T_VERBOSE ) {\n ( void ) _mi_make_key ( info , ( uint ) info -> errkey , info -> lastkey , sort_param . record , 0L ) ;\n _mi_print_key ( stdout , share -> keyinfo [ info -> errkey ] . seg , info -> lastkey , USE_WHOLE_KEY ) ;\n }\n sort_info . dupp ++ ;\n if ( ( param -> testflag & ( T_FORCE_UNIQUENESS | T_QUICK ) ) == T_QUICK ) {\n param -> testflag |= T_RETRY_WITHOUT_QUICK ;\n param -> error_printed = 1 ;\n goto err ;\n }\n continue ;\n }\n if ( sort_write_record ( & sort_param ) ) goto err ;\n }\n if ( error > 0 || write_data_suffix ( & sort_info , ( my_bool ) ! rep_quick ) || flush_io_cache ( & info -> rec_cache ) || param -> read_cache . error < 0 ) goto err ;\n if ( param -> testflag & T_WRITE_LOOP ) {\n ( void ) fputs ( \" \\r\" , stdout ) ;\n ( void ) fflush ( stdout ) ;\n }\n if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) {\n mi_check_print_warning ( param , \"Can't change size of indexfile, error: %d\" , my_errno ) ;\n goto err ;\n }\n if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {\n mi_check_print_error ( param , \"Couldn't fix table with quick recovery: Found wrong number of deleted records\" ) ;\n mi_check_print_error ( param , \"Run recovery again without -q\" ) ;\n got_error = 1 ;\n param -> retry_repair = 1 ;\n param -> testflag |= T_RETRY_WITHOUT_QUICK ;\n goto err ;\n }\n if ( param -> testflag & T_SAFE_REPAIR ) {\n if ( info -> state -> records + 1 < start_records ) {\n info -> state -> records = start_records ;\n got_error = 1 ;\n goto err ;\n }\n }\n if ( ! rep_quick ) {\n mysql_file_close ( info -> dfile , MYF ( 0 ) ) ;\n info -> dfile = new_file ;\n info -> state -> data_file_length = sort_param . filepos ;\n share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ;\n }\n else {\n info -> state -> data_file_length = sort_param . max_pos ;\n }\n if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;\n if ( ! ( param -> testflag & T_SILENT ) ) {\n if ( start_records != info -> state -> records ) printf ( \"Data records: %s\\n\" , llstr ( info -> state -> records , llbuff ) ) ;\n if ( sort_info . dupp ) mi_check_print_warning ( param , \"%s records have been removed\" , llstr ( sort_info . dupp , llbuff ) ) ;\n }\n got_error = 0 ;\n if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;\n err : if ( ! got_error ) {\n if ( new_file >= 0 ) {\n myf flags = 0 ;\n if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ;\n if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ;\n mysql_file_close ( new_file , MYF ( 0 ) ) ;\n info -> dfile = new_file = - 1 ;\n if ( info -> s -> file_map ) {\n ( void ) my_munmap ( ( char * ) info -> s -> file_map , ( size_t ) info -> s -> mmaped_length ) ;\n info -> s -> file_map = NULL ;\n }\n if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , flags ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n param -> retry_repair = 0 ;\n }\n }\n if ( got_error ) {\n if ( ! param -> error_printed ) mi_check_print_error ( param , \"%d for record at pos %s\" , my_errno , llstr ( sort_param . start_recpos , llbuff ) ) ;\n if ( new_file >= 0 ) {\n ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ;\n ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ;\n info -> rec_cache . file = - 1 ;\n }\n mi_mark_crashed_on_repair ( info ) ;\n }\n my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ;\n my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ;\n my_free ( sort_info . buff ) ;\n ( void ) end_io_cache ( & param -> read_cache ) ;\n info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ;\n ( void ) end_io_cache ( & info -> rec_cache ) ;\n got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ;\n if ( ! got_error && param -> testflag & T_UNPACK ) {\n share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ;\n share -> pack . header_length = 0 ;\n share -> data_file_type = sort_info . new_data_file_type ;\n }\n share -> state . changed |= ( STATE_NOT_OPTIMIZED_KEYS | STATE_NOT_SORTED_PAGES | STATE_NOT_ANALYZED ) ;\n DBUG_RETURN ( got_error ) ;\n }", "hash": -4885528830177756816, "project": "debian", "size": 166, "target": 0, "idx": 7613}
{"code": "static int sort_key_cmp ( MI_SORT_PARAM * sort_param , const void * a , const void * b ) {\n uint not_used [ 2 ] ;\n return ( ha_key_cmp ( sort_param -> seg , * ( ( uchar * * ) a ) , * ( ( uchar * * ) b ) , USE_WHOLE_KEY , SEARCH_SAME , not_used ) ) ;\n }", "hash": -4885528830177756816, "project": "debian", "size": 4, "target": 0, "idx": 7628}
{"code": "static void set_data_file_type ( SORT_INFO * sort_info , MYISAM_SHARE * share ) {\n if ( ( sort_info -> new_data_file_type = share -> data_file_type ) == COMPRESSED_RECORD && sort_info -> param -> testflag & T_UNPACK ) {\n MYISAM_SHARE tmp ;\n if ( share -> options & HA_OPTION_PACK_RECORD ) sort_info -> new_data_file_type = DYNAMIC_RECORD ;\n else sort_info -> new_data_file_type = STATIC_RECORD ;\n memcpy ( ( char * ) & tmp , share , sizeof ( * share ) ) ;\n tmp . options = ~ HA_OPTION_COMPRESS_RECORD ;\n mi_setup_functions ( & tmp ) ;\n share -> delete_record = tmp . delete_record ;\n }\n }", "hash": -4885528830177756816, "project": "debian", "size": 11, "target": 0, "idx": 7645}
{"code": "static int mi_sort_records ( MI_CHECK * param , register MI_INFO * info , char * name , uint sort_key , my_bool write_info , my_bool update_index ) {\n int got_error ;\n uint key ;\n MI_KEYDEF * keyinfo ;\n File new_file ;\n uchar * temp_buff ;\n ha_rows old_record_count ;\n MYISAM_SHARE * share = info -> s ;\n char llbuff [ 22 ] , llbuff2 [ 22 ] ;\n SORT_INFO sort_info ;\n MI_SORT_PARAM sort_param ;\n DBUG_ENTER ( \"sort_records\" ) ;\n bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ;\n bzero ( ( char * ) & sort_param , sizeof ( sort_param ) ) ;\n sort_param . sort_info = & sort_info ;\n sort_info . param = param ;\n keyinfo = & share -> keyinfo [ sort_key ] ;\n got_error = 1 ;\n temp_buff = 0 ;\n new_file = - 1 ;\n if ( ! mi_is_key_active ( share -> state . key_map , sort_key ) ) {\n mi_check_print_warning ( param , \"Can't sort table '%s' on key %d;\n No such key\" , name , sort_key + 1 ) ;\n param -> error_printed = 0 ;\n DBUG_RETURN ( 0 ) ;\n }\n if ( keyinfo -> flag & HA_FULLTEXT ) {\n mi_check_print_warning ( param , \"Can't sort table '%s' on FULLTEXT key %d\" , name , sort_key + 1 ) ;\n param -> error_printed = 0 ;\n DBUG_RETURN ( 0 ) ;\n }\n if ( share -> data_file_type == COMPRESSED_RECORD ) {\n mi_check_print_warning ( param , \"Can't sort read-only table '%s'\" , name ) ;\n param -> error_printed = 0 ;\n DBUG_RETURN ( 0 ) ;\n }\n if ( ! ( param -> testflag & T_SILENT ) ) {\n printf ( \"- Sorting records for MyISAM-table '%s'\\n\" , name ) ;\n if ( write_info ) printf ( \"Data records: %9s Deleted: %9s\\n\" , llstr ( info -> state -> records , llbuff ) , llstr ( info -> state -> del , llbuff2 ) ) ;\n }\n if ( share -> state . key_root [ sort_key ] == HA_OFFSET_ERROR ) DBUG_RETURN ( 0 ) ;\n init_key_cache ( dflt_key_cache , opt_key_cache_block_size , ( size_t ) param -> use_buffers , 0 , 0 ) ;\n if ( init_io_cache ( & info -> rec_cache , - 1 , ( uint ) param -> write_buffer_length , WRITE_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) ) ) goto err ;\n info -> opt_flag |= WRITE_CACHE_USED ;\n if ( ! ( temp_buff = ( uchar * ) my_alloca ( ( uint ) keyinfo -> block_length ) ) ) {\n mi_check_print_error ( param , \"Not enough memory for key block\" ) ;\n goto err ;\n }\n if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param . record ) ) {\n mi_check_print_error ( param , \"Not enough memory for record\" ) ;\n goto err ;\n }\n fn_format ( param -> temp_filename , name , \"\" , MI_NAME_DEXT , 2 + 4 + 32 ) ;\n new_file = my_create ( fn_format ( param -> temp_filename , param -> temp_filename , \"\" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ;\n if ( new_file < 0 ) {\n mi_check_print_error ( param , \"Can't create new tempfile: '%s'\" , param -> temp_filename ) ;\n goto err ;\n }\n if ( share -> pack . header_length ) if ( filecopy ( param , new_file , info -> dfile , 0L , share -> pack . header_length , \"datafile-header\" ) ) goto err ;\n info -> rec_cache . file = new_file ;\n lock_memory ( param ) ;\n for ( key = 0 ;\n key < share -> base . keys ;\n key ++ ) share -> keyinfo [ key ] . flag |= HA_SORT_ALLOWS_SAME ;\n if ( my_pread ( share -> kfile , ( uchar * ) temp_buff , ( uint ) keyinfo -> block_length , share -> state . key_root [ sort_key ] , MYF ( MY_NABP + MY_WME ) ) ) {\n mi_check_print_error ( param , \"Can't read indexpage from filepos: %s\" , ( ulong ) share -> state . key_root [ sort_key ] ) ;\n goto err ;\n }\n sort_info . info = info ;\n sort_info . new_data_file_type = share -> data_file_type ;\n sort_param . fix_datafile = 1 ;\n sort_param . master = 1 ;\n sort_param . filepos = share -> pack . header_length ;\n old_record_count = info -> state -> records ;\n info -> state -> records = 0 ;\n if ( sort_info . new_data_file_type != COMPRESSED_RECORD ) info -> state -> checksum = 0 ;\n if ( sort_record_index ( & sort_param , info , keyinfo , share -> state . key_root [ sort_key ] , temp_buff , sort_key , new_file , update_index ) || write_data_suffix ( & sort_info , 1 ) || flush_io_cache ( & info -> rec_cache ) ) goto err ;\n if ( info -> state -> records != old_record_count ) {\n mi_check_print_error ( param , \"found %s of %s records\" , llstr ( info -> state -> records , llbuff ) , llstr ( old_record_count , llbuff2 ) ) ;\n goto err ;\n }\n ( void ) my_close ( info -> dfile , MYF ( MY_WME ) ) ;\n param -> out_flag |= O_NEW_DATA ;\n info -> dfile = new_file ;\n info -> state -> del = 0 ;\n info -> state -> empty = 0 ;\n share -> state . dellink = HA_OFFSET_ERROR ;\n info -> state -> data_file_length = sort_param . filepos ;\n share -> state . split = info -> state -> records ;\n share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ;\n info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;\n if ( param -> testflag & T_WRITE_LOOP ) {\n ( void ) fputs ( \" \\r\" , stdout ) ;\n ( void ) fflush ( stdout ) ;\n }\n got_error = 0 ;\n err : if ( got_error && new_file >= 0 ) {\n ( void ) end_io_cache ( & info -> rec_cache ) ;\n ( void ) my_close ( new_file , MYF ( MY_WME ) ) ;\n ( void ) my_delete ( param -> temp_filename , MYF ( MY_WME ) ) ;\n }\n if ( temp_buff ) {\n my_afree ( ( uchar * ) temp_buff ) ;\n }\n my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ;\n info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ;\n ( void ) end_io_cache ( & info -> rec_cache ) ;\n my_free ( sort_info . buff ) ;\n sort_info . buff = 0 ;\n share -> state . sortkey = sort_key ;\n DBUG_RETURN ( flush_blocks ( param , share -> key_cache , share -> kfile ) | got_error ) ;\n }", "hash": -4978896576290502518, "project": "debian", "size": 112, "target": 0, "idx": 7675}
{"code": "volatile int * killed_ptr ( MI_CHECK * param __attribute__ ( ( unused ) ) ) {\n return & not_killed ;\n }", "hash": -4978896576290502518, "project": "debian", "size": 3, "target": 0, "idx": 7676}
{"code": "static void mi_check_print_msg ( MI_CHECK * param , const char * msg_type , const char * fmt , va_list args ) {\n THD * thd = ( THD * ) param -> thd ;\n Protocol * protocol = thd -> protocol ;\n size_t length , msg_length ;\n char msgbuf [ MI_MAX_MSG_BUF ] ;\n char name [ NAME_LEN * 2 + 2 ] ;\n msg_length = my_vsnprintf ( msgbuf , sizeof ( msgbuf ) , fmt , args ) ;\n msgbuf [ sizeof ( msgbuf ) - 1 ] = 0 ;\n DBUG_PRINT ( msg_type , ( \"message: %s\" , msgbuf ) ) ;\n if ( ! thd -> vio_ok ( ) ) {\n sql_print_error ( \"%s\" , msgbuf ) ;\n return ;\n }\n if ( param -> testflag & ( T_CREATE_MISSING_KEYS | T_SAFE_REPAIR | T_AUTO_REPAIR ) ) {\n my_message ( ER_NOT_KEYFILE , msgbuf , MYF ( MY_WME ) ) ;\n return ;\n }\n length = ( uint ) ( strxmov ( name , param -> db_name , \".\" , param -> table_name , NullS ) - name ) ;\n if ( param -> need_print_msg_lock ) mysql_mutex_lock ( & param -> print_msg_mutex ) ;\n protocol -> prepare_for_resend ( ) ;\n protocol -> store ( name , length , system_charset_info ) ;\n protocol -> store ( param -> op_name , system_charset_info ) ;\n protocol -> store ( msg_type , system_charset_info ) ;\n protocol -> store ( msgbuf , msg_length , system_charset_info ) ;\n if ( protocol -> write ( ) ) sql_print_error ( \"Failed on my_net_write, writing to stderr instead: %s\\n\" , msgbuf ) ;\n if ( param -> need_print_msg_lock ) mysql_mutex_unlock ( & param -> print_msg_mutex ) ;\n return ;\n }", "hash": 7783404437431406265, "project": "debian", "size": 28, "target": 0, "idx": 7679}
{"code": "int table2myisam ( TABLE * table_arg , MI_KEYDEF * * keydef_out , MI_COLUMNDEF * * recinfo_out , uint * records_out ) {\n uint i , j , recpos , minpos , fieldpos , temp_length , length ;\n enum ha_base_keytype type = HA_KEYTYPE_BINARY ;\n uchar * record ;\n KEY * pos ;\n MI_KEYDEF * keydef ;\n MI_COLUMNDEF * recinfo , * recinfo_pos ;\n HA_KEYSEG * keyseg ;\n TABLE_SHARE * share = table_arg -> s ;\n uint options = share -> db_options_in_use ;\n DBUG_ENTER ( \"table2myisam\" ) ;\n if ( ! ( my_multi_malloc ( MYF ( MY_WME ) , recinfo_out , ( share -> fields * 2 + 2 ) * sizeof ( MI_COLUMNDEF ) , keydef_out , share -> keys * sizeof ( MI_KEYDEF ) , & keyseg , ( share -> key_parts + share -> keys ) * sizeof ( HA_KEYSEG ) , NullS ) ) ) DBUG_RETURN ( HA_ERR_OUT_OF_MEM ) ;\n keydef = * keydef_out ;\n recinfo = * recinfo_out ;\n pos = table_arg -> key_info ;\n for ( i = 0 ;\n i < share -> keys ;\n i ++ , pos ++ ) {\n keydef [ i ] . flag = ( ( uint16 ) pos -> flags & ( HA_NOSAME | HA_FULLTEXT | HA_SPATIAL ) ) ;\n keydef [ i ] . key_alg = pos -> algorithm == HA_KEY_ALG_UNDEF ? ( pos -> flags & HA_SPATIAL ? HA_KEY_ALG_RTREE : HA_KEY_ALG_BTREE ) : pos -> algorithm ;\n keydef [ i ] . block_length = pos -> block_size ;\n keydef [ i ] . seg = keyseg ;\n keydef [ i ] . keysegs = pos -> key_parts ;\n for ( j = 0 ;\n j < pos -> key_parts ;\n j ++ ) {\n Field * field = pos -> key_part [ j ] . field ;\n type = field -> key_type ( ) ;\n keydef [ i ] . seg [ j ] . flag = pos -> key_part [ j ] . key_part_flag ;\n if ( options & HA_OPTION_PACK_KEYS || ( pos -> flags & ( HA_PACK_KEY | HA_BINARY_PACK_KEY | HA_SPACE_PACK_USED ) ) ) {\n if ( pos -> key_part [ j ] . length > 8 && ( type == HA_KEYTYPE_TEXT || type == HA_KEYTYPE_NUM || ( type == HA_KEYTYPE_BINARY && ! field -> zero_pack ( ) ) ) ) {\n if ( j == 0 ) keydef [ i ] . flag |= HA_PACK_KEY ;\n if ( ! ( field -> flags & ZEROFILL_FLAG ) && ( field -> type ( ) == MYSQL_TYPE_STRING || field -> type ( ) == MYSQL_TYPE_VAR_STRING || ( ( int ) ( pos -> key_part [ j ] . length - field -> decimals ( ) ) ) >= 4 ) ) keydef [ i ] . seg [ j ] . flag |= HA_SPACE_PACK ;\n }\n else if ( j == 0 && ( ! ( pos -> flags & HA_NOSAME ) || pos -> key_length > 16 ) ) keydef [ i ] . flag |= HA_BINARY_PACK_KEY ;\n }\n keydef [ i ] . seg [ j ] . type = ( int ) type ;\n keydef [ i ] . seg [ j ] . start = pos -> key_part [ j ] . offset ;\n keydef [ i ] . seg [ j ] . length = pos -> key_part [ j ] . length ;\n keydef [ i ] . seg [ j ] . bit_start = keydef [ i ] . seg [ j ] . bit_end = keydef [ i ] . seg [ j ] . bit_length = 0 ;\n keydef [ i ] . seg [ j ] . bit_pos = 0 ;\n keydef [ i ] . seg [ j ] . language = field -> charset_for_protocol ( ) -> number ;\n if ( field -> null_ptr ) {\n keydef [ i ] . seg [ j ] . null_bit = field -> null_bit ;\n keydef [ i ] . seg [ j ] . null_pos = ( uint ) ( field -> null_ptr - ( uchar * ) table_arg -> record [ 0 ] ) ;\n }\n else {\n keydef [ i ] . seg [ j ] . null_bit = 0 ;\n keydef [ i ] . seg [ j ] . null_pos = 0 ;\n }\n if ( field -> type ( ) == MYSQL_TYPE_BLOB || field -> type ( ) == MYSQL_TYPE_GEOMETRY ) {\n keydef [ i ] . seg [ j ] . flag |= HA_BLOB_PART ;\n keydef [ i ] . seg [ j ] . bit_start = ( uint ) ( field -> pack_length ( ) - share -> blob_ptr_size ) ;\n }\n else if ( field -> type ( ) == MYSQL_TYPE_BIT ) {\n keydef [ i ] . seg [ j ] . bit_length = ( ( Field_bit * ) field ) -> bit_len ;\n keydef [ i ] . seg [ j ] . bit_start = ( ( Field_bit * ) field ) -> bit_ofs ;\n keydef [ i ] . seg [ j ] . bit_pos = ( uint ) ( ( ( Field_bit * ) field ) -> bit_ptr - ( uchar * ) table_arg -> record [ 0 ] ) ;\n }\n }\n keyseg += pos -> key_parts ;\n }\n if ( table_arg -> found_next_number_field ) keydef [ share -> next_number_index ] . flag |= HA_AUTO_KEY ;\n record = table_arg -> record [ 0 ] ;\n recpos = 0 ;\n recinfo_pos = recinfo ;\n while ( recpos < ( uint ) share -> reclength ) {\n Field * * field , * found = 0 ;\n minpos = share -> reclength ;\n length = 0 ;\n for ( field = table_arg -> field ;\n * field ;\n field ++ ) {\n if ( ( fieldpos = ( * field ) -> offset ( record ) ) >= recpos && fieldpos <= minpos ) {\n if ( ! ( temp_length = ( * field ) -> pack_length_in_rec ( ) ) ) continue ;\n if ( ! found || fieldpos < minpos || ( fieldpos == minpos && temp_length < length ) ) {\n minpos = fieldpos ;\n found = * field ;\n length = temp_length ;\n }\n }\n }\n DBUG_PRINT ( \"loop\" , ( \"found: 0x%lx recpos: %d minpos: %d length: %d\" , ( long ) found , recpos , minpos , length ) ) ;\n if ( recpos != minpos ) {\n bzero ( ( char * ) recinfo_pos , sizeof ( * recinfo_pos ) ) ;\n recinfo_pos -> type = ( int ) FIELD_NORMAL ;\n recinfo_pos ++ -> length = ( uint16 ) ( minpos - recpos ) ;\n }\n if ( ! found ) break ;\n if ( found -> flags & BLOB_FLAG ) recinfo_pos -> type = ( int ) FIELD_BLOB ;\n else if ( found -> type ( ) == MYSQL_TYPE_VARCHAR ) recinfo_pos -> type = FIELD_VARCHAR ;\n else if ( ! ( options & HA_OPTION_PACK_RECORD ) ) recinfo_pos -> type = ( int ) FIELD_NORMAL ;\n else if ( found -> zero_pack ( ) ) recinfo_pos -> type = ( int ) FIELD_SKIP_ZERO ;\n else recinfo_pos -> type = ( int ) ( ( length <= 3 || ( found -> flags & ZEROFILL_FLAG ) ) ? FIELD_NORMAL : found -> type ( ) == MYSQL_TYPE_STRING || found -> type ( ) == MYSQL_TYPE_VAR_STRING ? FIELD_SKIP_ENDSPACE : FIELD_SKIP_PRESPACE ) ;\n if ( found -> null_ptr ) {\n recinfo_pos -> null_bit = found -> null_bit ;\n recinfo_pos -> null_pos = ( uint ) ( found -> null_ptr - ( uchar * ) table_arg -> record [ 0 ] ) ;\n }\n else {\n recinfo_pos -> null_bit = 0 ;\n recinfo_pos -> null_pos = 0 ;\n }\n ( recinfo_pos ++ ) -> length = ( uint16 ) length ;\n recpos = minpos + length ;\n DBUG_PRINT ( \"loop\" , ( \"length: %d type: %d\" , recinfo_pos [ - 1 ] . length , recinfo_pos [ - 1 ] . type ) ) ;\n }\n * records_out = ( uint ) ( recinfo_pos - recinfo ) ;\n DBUG_RETURN ( 0 ) ;\n }", "hash": 7783404437431406265, "project": "debian", "size": 109, "target": 0, "idx": 7680}
{"code": "static int myisam_init ( void * p ) {\n handlerton * myisam_hton ;\n # ifdef HAVE_PSI_INTERFACE init_myisam_psi_keys ( ) ;\n # endif if ( myisam_recover_options ) ha_open_options |= HA_OPEN_ABORT_IF_CRASHED ;\n else myisam_recover_options = HA_RECOVER_OFF ;\n myisam_block_size = ( uint ) 1 << my_bit_log2 ( opt_myisam_block_size ) ;\n myisam_hton = ( handlerton * ) p ;\n myisam_hton -> state = SHOW_OPTION_YES ;\n myisam_hton -> db_type = DB_TYPE_MYISAM ;\n myisam_hton -> create = myisam_create_handler ;\n myisam_hton -> panic = myisam_panic ;\n myisam_hton -> flags = HTON_CAN_RECREATE | HTON_SUPPORT_LOG_TABLES ;\n myisam_hton -> is_supported_system_table = myisam_is_supported_system_table ;\n return 0 ;\n }", "hash": 7783404437431406265, "project": "debian", "size": 15, "target": 0, "idx": 7685}
{"code": "static cmsBool isfirstidchar ( int c ) {\n return ! isdigit ( c ) && ismiddle ( c ) ;\n }", "hash": -4525941100783779911, "project": "debian", "size": 3, "target": 0, "idx": 7708}
{"code": "static void ReadReal ( cmsIT8 * it8 , cmsInt32Number inum ) {\n it8 -> dnum = ( cmsFloat64Number ) inum ;\n while ( isdigit ( it8 -> ch ) ) {\n it8 -> dnum = ( cmsFloat64Number ) it8 -> dnum * 10.0 + ( cmsFloat64Number ) ( it8 -> ch - '0' ) ;\n NextCh ( it8 ) ;\n }\n if ( it8 -> ch == '.' ) {\n cmsFloat64Number frac = 0.0 ;\n int prec = 0 ;\n NextCh ( it8 ) ;\n while ( isdigit ( it8 -> ch ) ) {\n frac = frac * 10.0 + ( cmsFloat64Number ) ( it8 -> ch - '0' ) ;\n prec ++ ;\n NextCh ( it8 ) ;\n }\n it8 -> dnum = it8 -> dnum + ( frac / xpow10 ( prec ) ) ;\n }\n if ( toupper ( it8 -> ch ) == 'E' ) {\n cmsInt32Number e ;\n cmsInt32Number sgn ;\n NextCh ( it8 ) ;\n sgn = 1 ;\n if ( it8 -> ch == '-' ) {\n sgn = - 1 ;\n NextCh ( it8 ) ;\n }\n else if ( it8 -> ch == '+' ) {\n sgn = + 1 ;\n NextCh ( it8 ) ;\n }\n e = 0 ;\n while ( isdigit ( it8 -> ch ) ) {\n cmsInt32Number digit = ( it8 -> ch - '0' ) ;\n if ( ( cmsFloat64Number ) e * 10.0 + ( cmsFloat64Number ) digit < ( cmsFloat64Number ) + 2147483647.0 ) e = e * 10 + digit ;\n NextCh ( it8 ) ;\n }\n e = sgn * e ;\n it8 -> dnum = it8 -> dnum * xpow10 ( e ) ;\n }\n }", "hash": -4525941100783779911, "project": "debian", "size": 40, "target": 0, "idx": 7715}
{"code": "int tmx_init_pretran_table ( void ) {\n int n ;\n int pn ;\n pn = get_max_procs ( ) ;\n if ( pn <= 0 ) return - 1 ;\n if ( _tmx_ptran_table != NULL ) return - 1 ;\n n = - 1 ;\n while ( pn >> ++ n > 0 ) ;\n n -- ;\n if ( n <= 1 ) n = 2 ;\n if ( n > 8 ) n = 8 ;\n _tmx_ptran_size = 1 << n ;\n _tmx_ptran_table = ( pretran_slot_t * ) shm_malloc ( _tmx_ptran_size * sizeof ( pretran_slot_t ) ) ;\n if ( _tmx_ptran_table == NULL ) {\n LM_ERR ( \"not enough shared memory\\n\" ) ;\n return - 1 ;\n }\n memset ( _tmx_ptran_table , 0 , _tmx_ptran_size * sizeof ( pretran_slot_t ) ) ;\n for ( n = 0 ;\n n < _tmx_ptran_size ;\n n ++ ) {\n if ( lock_init ( & _tmx_ptran_table [ n ] . lock ) == NULL ) {\n LM_ERR ( \"cannot init the lock %d\\n\" , n ) ;\n n -- ;\n while ( n >= 0 ) {\n lock_destroy ( & _tmx_ptran_table [ n ] . lock ) ;\n n -- ;\n }\n shm_free ( _tmx_ptran_table ) ;\n _tmx_ptran_table = 0 ;\n _tmx_ptran_size = 0 ;\n return - 1 ;\n }\n }\n return 0 ;\n }", "hash": -8503439282031333562, "project": "debian", "size": 36, "target": 0, "idx": 7724}
{"code": "picture_t * DecodeVideo ( decoder_t * p_dec , block_t * * pp_block ) {\n decoder_sys_t * p_sys = p_dec -> p_sys ;\n AVCodecContext * p_context = p_sys -> p_context ;\n int b_drawpicture ;\n block_t * p_block ;\n if ( ! pp_block ) return NULL ;\n if ( ! p_context -> extradata_size && p_dec -> fmt_in . i_extra ) {\n ffmpeg_InitCodec ( p_dec ) ;\n if ( p_sys -> b_delayed_open ) {\n if ( ffmpeg_OpenCodec ( p_dec ) ) msg_Err ( p_dec , \"cannot open codec (%s)\" , p_sys -> psz_namecodec ) ;\n }\n }\n p_block = * pp_block ;\n if ( ! p_block && ! ( p_sys -> p_codec -> capabilities & CODEC_CAP_DELAY ) ) return NULL ;\n if ( p_sys -> b_delayed_open ) {\n if ( p_block ) block_Release ( p_block ) ;\n return NULL ;\n }\n if ( p_block ) {\n if ( p_block -> i_flags & ( BLOCK_FLAG_DISCONTINUITY | BLOCK_FLAG_CORRUPTED ) ) {\n p_sys -> i_pts = VLC_TS_INVALID ;\n p_sys -> i_late_frames = 0 ;\n post_mt ( p_sys ) ;\n if ( p_block -> i_flags & BLOCK_FLAG_DISCONTINUITY ) avcodec_flush_buffers ( p_context ) ;\n wait_mt ( p_sys ) ;\n block_Release ( p_block ) ;\n return NULL ;\n }\n if ( p_block -> i_flags & BLOCK_FLAG_PREROLL ) {\n p_sys -> i_late_frames = 0 ;\n }\n }\n if ( ! p_dec -> b_pace_control && ( p_sys -> i_late_frames > 0 ) && ( mdate ( ) - p_sys -> i_late_frames_start > INT64_C ( 5000000 ) ) ) {\n if ( p_sys -> i_pts > VLC_TS_INVALID ) {\n p_sys -> i_pts = VLC_TS_INVALID ;\n }\n if ( p_block ) block_Release ( p_block ) ;\n p_sys -> i_late_frames -- ;\n msg_Err ( p_dec , \"more than 5 seconds of late video -> \" \"dropping frame (computer too slow ?)\" ) ;\n return NULL ;\n }\n if ( ! p_dec -> b_pace_control && p_sys -> b_hurry_up && ( p_sys -> i_late_frames > 4 ) ) {\n b_drawpicture = 0 ;\n if ( p_sys -> i_late_frames < 12 ) {\n p_context -> skip_frame = ( p_sys -> i_skip_frame <= AVDISCARD_NONREF ) ? AVDISCARD_NONREF : p_sys -> i_skip_frame ;\n }\n else {\n p_sys -> i_late_frames -- ;\n if ( p_block ) block_Release ( p_block ) ;\n msg_Warn ( p_dec , \"More than 4 late frames, dropping frame\" ) ;\n return NULL ;\n }\n }\n else {\n if ( p_sys -> b_hurry_up ) p_context -> skip_frame = p_sys -> i_skip_frame ;\n if ( ! p_block || ! ( p_block -> i_flags & BLOCK_FLAG_PREROLL ) ) b_drawpicture = 1 ;\n else b_drawpicture = 0 ;\n }\n if ( p_context -> width <= 0 || p_context -> height <= 0 ) {\n if ( p_sys -> b_hurry_up ) p_context -> skip_frame = p_sys -> i_skip_frame ;\n }\n else if ( ! b_drawpicture ) {\n # if 0 if ( p_sys -> b_hurry_up ) p_context -> skip_frame = __MAX ( p_context -> skip_frame , AVDISCARD_NONREF ) ;\n # endif }\n if ( p_block && p_block -> i_buffer > 0 ) {\n p_sys -> b_flush = ( p_block -> i_flags & BLOCK_FLAG_END_OF_SEQUENCE ) != 0 ;\n p_block = block_Realloc ( p_block , 0 , p_block -> i_buffer + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! p_block ) return NULL ;\n p_block -> i_buffer -= FF_INPUT_BUFFER_PADDING_SIZE ;\n * pp_block = p_block ;\n memset ( p_block -> p_buffer + p_block -> i_buffer , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n }\n while ( ! p_block || p_block -> i_buffer > 0 || p_sys -> b_flush ) {\n int i_used , b_gotpicture ;\n picture_t * p_pic ;\n AVPacket pkt ;\n post_mt ( p_sys ) ;\n av_init_packet ( & pkt ) ;\n if ( p_block && p_block -> i_buffer > 0 ) {\n pkt . data = p_block -> p_buffer ;\n pkt . size = p_block -> i_buffer ;\n pkt . pts = p_block -> i_pts ;\n pkt . dts = p_block -> i_dts ;\n }\n else {\n pkt . data = NULL ;\n pkt . size = 0 ;\n }\n # if LIBAVCODEC_VERSION_MAJOR >= 54 if ( ! p_sys -> palette_sent ) {\n uint8_t * pal = av_packet_new_side_data ( & pkt , AV_PKT_DATA_PALETTE , AVPALETTE_SIZE ) ;\n if ( pal ) {\n memcpy ( pal , p_dec -> fmt_in . video . p_palette -> palette , AVPALETTE_SIZE ) ;\n p_sys -> palette_sent = true ;\n }\n }\n # endif if ( p_block ) {\n p_block -> i_pts = p_block -> i_dts = VLC_TS_INVALID ;\n }\n i_used = avcodec_decode_video2 ( p_context , p_sys -> p_ff_pic , & b_gotpicture , & pkt ) ;\n wait_mt ( p_sys ) ;\n if ( p_sys -> b_flush ) p_sys -> b_first_frame = true ;\n if ( p_block ) {\n if ( p_block -> i_buffer <= 0 ) p_sys -> b_flush = false ;\n if ( i_used < 0 ) {\n if ( b_drawpicture ) msg_Warn ( p_dec , \"cannot decode one frame (%zu bytes)\" , p_block -> i_buffer ) ;\n block_Release ( p_block ) ;\n return NULL ;\n }\n else if ( ( unsigned ) i_used > p_block -> i_buffer || p_context -> thread_count > 1 ) {\n i_used = p_block -> i_buffer ;\n }\n p_block -> i_buffer -= i_used ;\n p_block -> p_buffer += i_used ;\n }\n if ( ! b_gotpicture ) {\n if ( i_used == 0 ) break ;\n continue ;\n }\n # if LIBAVCODEC_VERSION_MAJOR >= 54 if ( p_context -> pix_fmt == AV_PIX_FMT_PAL8 && ! p_dec -> fmt_out . video . p_palette && p_sys -> p_ff_pic -> data [ 1 ] ) {\n video_palette_t * p_palette ;\n p_palette = p_dec -> fmt_out . video . p_palette = malloc ( sizeof ( video_palette_t ) ) ;\n if ( ! p_palette ) {\n if ( p_block ) block_Release ( p_block ) ;\n return NULL ;\n }\n static_assert ( sizeof ( p_palette -> palette ) == AVPALETTE_SIZE , \"Palette size mismatch between vlc and libavutil\" ) ;\n memcpy ( p_palette -> palette , p_sys -> p_ff_pic -> data [ 1 ] , AVPALETTE_SIZE ) ;\n p_palette -> i_entries = AVPALETTE_COUNT ;\n }\n # endif if ( p_sys -> p_ff_pic -> pict_type == AV_PICTURE_TYPE_B ) {\n p_sys -> b_has_b_frames = true ;\n }\n mtime_t i_pts = p_sys -> p_ff_pic -> pkt_pts ;\n if ( i_pts <= VLC_TS_INVALID ) i_pts = p_sys -> p_ff_pic -> pkt_dts ;\n if ( i_pts <= VLC_TS_INVALID ) i_pts = p_sys -> i_pts ;\n if ( i_pts > VLC_TS_INVALID ) p_sys -> i_pts = i_pts ;\n if ( p_sys -> i_pts > VLC_TS_INVALID ) {\n if ( p_dec -> fmt_in . video . i_frame_rate > 0 && p_dec -> fmt_in . video . i_frame_rate_base > 0 ) {\n p_sys -> i_pts += INT64_C ( 1000000 ) * ( 2 + p_sys -> p_ff_pic -> repeat_pict ) * p_dec -> fmt_in . video . i_frame_rate_base / ( 2 * p_dec -> fmt_in . video . i_frame_rate ) ;\n }\n else if ( p_context -> time_base . den > 0 ) {\n int i_tick = p_context -> ticks_per_frame ;\n if ( i_tick <= 0 ) i_tick = 1 ;\n p_sys -> i_pts += INT64_C ( 1000000 ) * ( 2 + p_sys -> p_ff_pic -> repeat_pict ) * i_tick * p_context -> time_base . num / ( 2 * p_context -> time_base . den ) ;\n }\n }\n mtime_t i_display_date = 0 ;\n if ( ! p_block || ! ( p_block -> i_flags & BLOCK_FLAG_PREROLL ) ) i_display_date = decoder_GetDisplayDate ( p_dec , i_pts ) ;\n if ( i_display_date > 0 && i_display_date <= mdate ( ) ) {\n p_sys -> i_late_frames ++ ;\n if ( p_sys -> i_late_frames == 1 ) p_sys -> i_late_frames_start = mdate ( ) ;\n }\n else {\n p_sys -> i_late_frames = 0 ;\n }\n if ( ! b_drawpicture || ( ! p_sys -> p_va && ! p_sys -> p_ff_pic -> linesize [ 0 ] ) ) continue ;\n if ( p_sys -> p_va != NULL || p_sys -> p_ff_pic -> opaque == NULL ) {\n p_pic = ffmpeg_NewPictBuf ( p_dec , p_context ) ;\n if ( ! p_pic ) {\n if ( p_block ) block_Release ( p_block ) ;\n return NULL ;\n }\n ffmpeg_CopyPicture ( p_dec , p_pic , p_sys -> p_ff_pic ) ;\n }\n else {\n p_pic = ( picture_t * ) p_sys -> p_ff_pic -> opaque ;\n decoder_LinkPicture ( p_dec , p_pic ) ;\n }\n if ( ! p_dec -> fmt_in . video . i_sar_num || ! p_dec -> fmt_in . video . i_sar_den ) {\n p_dec -> fmt_out . video . i_sar_num = p_context -> sample_aspect_ratio . num ;\n p_dec -> fmt_out . video . i_sar_den = p_context -> sample_aspect_ratio . den ;\n if ( ! p_dec -> fmt_out . video . i_sar_num || ! p_dec -> fmt_out . video . i_sar_den ) {\n p_dec -> fmt_out . video . i_sar_num = 1 ;\n p_dec -> fmt_out . video . i_sar_den = 1 ;\n }\n }\n if ( i_pts > VLC_TS_INVALID ) {\n p_pic -> date = i_pts ;\n if ( p_sys -> b_first_frame ) {\n p_sys -> b_first_frame = false ;\n p_pic -> b_force = true ;\n }\n p_pic -> i_nb_fields = 2 + p_sys -> p_ff_pic -> repeat_pict ;\n p_pic -> b_progressive = ! p_sys -> p_ff_pic -> interlaced_frame ;\n p_pic -> b_top_field_first = p_sys -> p_ff_pic -> top_field_first ;\n return p_pic ;\n }\n else {\n decoder_DeletePicture ( p_dec , p_pic ) ;\n }\n }\n if ( p_block ) block_Release ( p_block ) ;\n return NULL ;\n }", "hash": 1949916022780590905, "project": "debian", "size": 194, "target": 0, "idx": 7739}
{"code": "int decode_msg ( struct sip_msg * msg , char * code , unsigned int len ) {\n unsigned short int h ;\n char * myerror = NULL ;\n memcpy ( & h , & code [ 2 ] , 2 ) ;\n h = ntohs ( h ) ;\n msg -> buf = & code [ h ] ;\n memcpy ( & h , & code [ 4 ] , 2 ) ;\n h = ntohs ( h ) ;\n msg -> len = h ;\n if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) {\n myerror = \"in parse_headers\" ;\n goto error ;\n }\n error : LM_ERR ( \"(%s)\\n\" , myerror ) ;\n return - 1 ;\n }", "hash": 3731043152202786975, "project": "debian", "size": 16, "target": 0, "idx": 7744}
{"code": "static int write_string ( buffer_t buffer , PyObject * py_string ) {\n Py_ssize_t string_length ;\n const char * string ;\n # if PY_MAJOR_VERSION >= 3 if ( PyUnicode_Check ( py_string ) ) {\n return write_unicode ( buffer , py_string ) ;\n }\n string = PyBytes_AsString ( py_string ) ;\n # else string = PyString_AsString ( py_string ) ;\n # endif if ( ! string ) {\n return 0 ;\n }\n # if PY_MAJOR_VERSION >= 3 string_length = PyBytes_Size ( py_string ) + 1 ;\n # else string_length = PyString_Size ( py_string ) + 1 ;\n # endif if ( ! buffer_write_bytes ( buffer , ( const char * ) & string_length , 4 ) ) {\n return 0 ;\n }\n if ( ! buffer_write_bytes ( buffer , string , string_length ) ) {\n return 0 ;\n }\n return 1 ;\n }", "hash": -5689214734378699681, "project": "debian", "size": 21, "target": 0, "idx": 7756}
{"code": "static long long millis_from_datetime ( PyObject * datetime ) {\n struct TM timeinfo ;\n long long millis ;\n timeinfo . tm_year = PyDateTime_GET_YEAR ( datetime ) - 1900 ;\n timeinfo . tm_mon = PyDateTime_GET_MONTH ( datetime ) - 1 ;\n timeinfo . tm_mday = PyDateTime_GET_DAY ( datetime ) ;\n timeinfo . tm_hour = PyDateTime_DATE_GET_HOUR ( datetime ) ;\n timeinfo . tm_min = PyDateTime_DATE_GET_MINUTE ( datetime ) ;\n timeinfo . tm_sec = PyDateTime_DATE_GET_SECOND ( datetime ) ;\n millis = timegm64 ( & timeinfo ) * 1000 ;\n millis += PyDateTime_DATE_GET_MICROSECOND ( datetime ) / 1000 ;\n return millis ;\n }", "hash": -5689214734378699681, "project": "debian", "size": 13, "target": 0, "idx": 7759}
{"code": "int mem_close ( gx_device * dev ) {\n gx_device_memory * const mdev = ( gx_device_memory * ) dev ;\n if ( mdev -> bitmap_memory != 0 ) {\n gs_free_object ( mdev -> bitmap_memory , mdev -> base , \"mem_close\" ) ;\n mdev -> base = 0 ;\n }\n else if ( mdev -> line_pointer_memory != 0 ) {\n gs_free_object ( mdev -> line_pointer_memory , mdev -> line_ptrs , \"mem_close\" ) ;\n mdev -> line_ptrs = 0 ;\n }\n return 0 ;\n }", "hash": 5918484636148310736, "project": "debian", "size": 12, "target": 0, "idx": 7784}
{"code": "int mem_open ( gx_device * dev ) {\n gx_device_memory * const mdev = ( gx_device_memory * ) dev ;\n if ( mdev -> is_planar ) return_error ( gs_error_rangecheck ) ;\n return gdev_mem_open_scan_lines ( mdev , dev -> height ) ;\n }", "hash": 5918484636148310736, "project": "debian", "size": 5, "target": 0, "idx": 7796}
{"code": "gx_color_index mem_mapped_map_rgb_color ( gx_device * dev , const gx_color_value cv [ ] ) {\n gx_device_memory * const mdev = ( gx_device_memory * ) dev ;\n byte br = gx_color_value_to_byte ( cv [ 0 ] ) ;\n register const byte * pptr = mdev -> palette . data ;\n int cnt = mdev -> palette . size ;\n const byte * which = 0 ;\n int best = 256 * 3 ;\n if ( mdev -> color_info . num_components != 1 ) {\n byte bg = gx_color_value_to_byte ( cv [ 1 ] ) ;\n byte bb = gx_color_value_to_byte ( cv [ 2 ] ) ;\n while ( ( cnt -= 3 ) >= 0 ) {\n register int diff = * pptr - br ;\n if ( diff < 0 ) diff = - diff ;\n if ( diff < best ) {\n int dg = pptr [ 1 ] - bg ;\n if ( dg < 0 ) dg = - dg ;\n if ( ( diff += dg ) < best ) {\n int db = pptr [ 2 ] - bb ;\n if ( db < 0 ) db = - db ;\n if ( ( diff += db ) < best ) which = pptr , best = diff ;\n }\n }\n if ( diff == 0 ) break ;\n pptr += 3 ;\n }\n }\n else {\n while ( ( cnt -= 3 ) >= 0 ) {\n register int diff = * pptr - br ;\n if ( diff < 0 ) diff = - diff ;\n if ( diff < best ) {\n which = pptr , best = diff ;\n }\n if ( diff == 0 ) break ;\n pptr += 3 ;\n }\n }\n return ( gx_color_index ) ( ( which - mdev -> palette . data ) / 3 ) ;\n }", "hash": 5918484636148310736, "project": "debian", "size": 39, "target": 0, "idx": 7800}
{"code": "static void stroke_list ( private_stroke_socket_t * this , stroke_msg_t * msg , FILE * out ) {\n if ( msg -> list . flags & LIST_CAINFOS ) {\n this -> ca -> list ( this -> ca , msg , out ) ;\n }\n this -> list -> list ( this -> list , msg , out ) ;\n }", "hash": -5260094338219889901, "project": "debian", "size": 6, "target": 0, "idx": 7805}
{"code": "static void dynstr_append_checked ( DYNAMIC_STRING * dest , const char * src ) {\n if ( dynstr_append ( dest , src ) ) die ( EX_MYSQLERR , DYNAMIC_STR_ERROR_MSG ) ;\n }", "hash": 6667142528452941476, "project": "debian", "size": 3, "target": 0, "idx": 7838}
{"code": "static int purge_bin_logs_to ( MYSQL * mysql_con , char * log_name ) {\n DYNAMIC_STRING str ;\n int err ;\n init_dynamic_string_checked ( & str , \"PURGE BINARY LOGS TO '\" , 1024 , 1024 ) ;\n dynstr_append_checked ( & str , log_name ) ;\n dynstr_append_checked ( & str , \"'\" ) ;\n err = mysql_query_with_error_report ( mysql_con , 0 , str . str ) ;\n dynstr_free ( & str ) ;\n return err ;\n }", "hash": 6667142528452941476, "project": "debian", "size": 10, "target": 0, "idx": 7846}
{"code": "static void print_xml_row ( FILE * xml_file , const char * row_name , MYSQL_RES * tableRes , MYSQL_ROW * row , const char * str_create ) {\n uint i ;\n my_bool body_found __attribute__ ( ( unused ) ) = 0 ;\n char * create_stmt_ptr = NULL ;\n ulong create_stmt_len = 0 ;\n MYSQL_FIELD * field ;\n ulong * lengths = mysql_fetch_lengths ( tableRes ) ;\n fprintf ( xml_file , \"\\t\\t<%s\" , row_name ) ;\n check_io ( xml_file ) ;\n mysql_field_seek ( tableRes , 0 ) ;\n for ( i = 0 ;\n ( field = mysql_fetch_field ( tableRes ) ) ;\n i ++ ) {\n if ( ( * row ) [ i ] ) {\n if ( ( str_create ) && ( strcmp ( str_create , field -> name ) == 0 ) ) {\n create_stmt_ptr = ( * row ) [ i ] ;\n create_stmt_len = lengths [ i ] ;\n # ifndef DBUG_OFF body_found = 1 ;\n # endif }\n else {\n fputc ( ' ' , xml_file ) ;\n print_quoted_xml ( xml_file , field -> name , field -> name_length , 1 ) ;\n fputs ( \"=\\\"\" , xml_file ) ;\n print_quoted_xml ( xml_file , ( * row ) [ i ] , lengths [ i ] , 0 ) ;\n fputc ( '\"' , xml_file ) ;\n check_io ( xml_file ) ;\n }\n }\n }\n if ( create_stmt_len ) {\n DBUG_ASSERT ( body_found ) ;\n fputs ( \">\\n\" , xml_file ) ;\n print_xml_cdata ( xml_file , create_stmt_ptr , create_stmt_len ) ;\n fprintf ( xml_file , \"\\t\\t</%s>\\n\" , row_name ) ;\n }\n else fputs ( \" />\\n\" , xml_file ) ;\n check_io ( xml_file ) ;\n }", "hash": 6667142528452941476, "project": "debian", "size": 38, "target": 0, "idx": 7870}
{"code": "static int connect_to_db ( char * host , char * user , char * passwd ) {\n char buff [ 20 + FN_REFLEN ] ;\n DBUG_ENTER ( \"connect_to_db\" ) ;\n verbose_msg ( \"-- Connecting to %s...\\n\" , host ? host : \"localhost\" ) ;\n mysql_init ( & mysql_connection ) ;\n if ( opt_compress ) mysql_options ( & mysql_connection , MYSQL_OPT_COMPRESS , NullS ) ;\n # ifdef HAVE_OPENSSL if ( opt_use_ssl ) mysql_ssl_set ( & mysql_connection , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ;\n mysql_options ( & mysql_connection , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ;\n # endif if ( opt_protocol ) mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ;\n # ifdef HAVE_SMEM if ( shared_memory_base_name ) mysql_options ( & mysql_connection , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ;\n # endif mysql_options ( & mysql_connection , MYSQL_SET_CHARSET_NAME , default_charset ) ;\n if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( & mysql_connection , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ;\n if ( opt_default_auth && * opt_default_auth ) mysql_options ( & mysql_connection , MYSQL_DEFAULT_AUTH , opt_default_auth ) ;\n mysql = & mysql_connection ;\n if ( ! mysql_real_connect ( & mysql_connection , host , user , passwd , NULL , opt_mysql_port , opt_mysql_unix_port , 0 ) ) {\n DB_error ( & mysql_connection , \"when trying to connect\" ) ;\n DBUG_RETURN ( 1 ) ;\n }\n if ( ( mysql_get_server_version ( & mysql_connection ) < 40100 ) || ( opt_compatible_mode & 3 ) ) {\n opt_set_charset = 0 ;\n server_supports_switching_charsets = FALSE ;\n }\n mysql -> reconnect = 0 ;\n my_snprintf ( buff , sizeof ( buff ) , \"/*!40100 SET @@SQL_MODE='%s' */\" , compatible_mode_normal_str ) ;\n if ( mysql_query_with_error_report ( mysql , 0 , buff ) ) DBUG_RETURN ( 1 ) ;\n if ( opt_tz_utc ) {\n my_snprintf ( buff , sizeof ( buff ) , \"/*!40103 SET TIME_ZONE='+00:00' */\" ) ;\n if ( mysql_query_with_error_report ( mysql , 0 , buff ) ) DBUG_RETURN ( 1 ) ;\n }\n DBUG_RETURN ( 0 ) ;\n }", "hash": 6667142528452941476, "project": "debian", "size": 31, "target": 0, "idx": 7874}
{"code": "static void print_comment ( FILE * sql_file , my_bool is_error , const char * format , ... ) {\n static char comment_buff [ COMMENT_LENGTH ] ;\n va_list args ;\n if ( ! is_error && ! opt_comments ) return ;\n va_start ( args , format ) ;\n my_vsnprintf ( comment_buff , COMMENT_LENGTH , format , args ) ;\n va_end ( args ) ;\n if ( ! opt_xml ) {\n fputs ( comment_buff , sql_file ) ;\n check_io ( sql_file ) ;\n return ;\n }\n print_xml_comment ( sql_file , strlen ( comment_buff ) , comment_buff ) ;\n }", "hash": 6667142528452941476, "project": "debian", "size": 14, "target": 0, "idx": 7879}
{"code": "static char * quote_for_like ( const char * name , char * buff ) {\n char * to = buff ;\n * to ++ = '\\'' ;\n while ( * name ) {\n if ( * name == '\\\\' ) {\n * to ++ = '\\\\' ;\n * to ++ = '\\\\' ;\n * to ++ = '\\\\' ;\n }\n else if ( * name == '\\'' || * name == '_' || * name == '%' ) * to ++ = '\\\\' ;\n * to ++ = * name ++ ;\n }\n to [ 0 ] = '\\'' ;\n to [ 1 ] = 0 ;\n return buff ;\n }", "hash": 6667142528452941476, "project": "debian", "size": 16, "target": 0, "idx": 7884}
{"code": "static void die ( int error_num , const char * fmt_reason , ... ) {\n char buffer [ 1000 ] ;\n va_list args ;\n va_start ( args , fmt_reason ) ;\n my_vsnprintf ( buffer , sizeof ( buffer ) , fmt_reason , args ) ;\n va_end ( args ) ;\n fprintf ( stderr , \"%s: %s\\n\" , my_progname_short , buffer ) ;\n fflush ( stderr ) ;\n ignore_errors = 0 ;\n maybe_exit ( error_num ) ;\n }", "hash": 6667142528452941476, "project": "debian", "size": 11, "target": 0, "idx": 7887}
{"code": "int ec_GF2m_simple_mul ( const EC_GROUP * group , EC_POINT * r , const BIGNUM * scalar , size_t num , const EC_POINT * points [ ] , const BIGNUM * scalars [ ] , BN_CTX * ctx ) {\n BN_CTX * new_ctx = NULL ;\n int ret = 0 ;\n size_t i ;\n EC_POINT * p = NULL ;\n EC_POINT * acc = NULL ;\n if ( ctx == NULL ) {\n ctx = new_ctx = BN_CTX_new ( ) ;\n if ( ctx == NULL ) return 0 ;\n }\n if ( ( scalar && ( num > 1 ) ) || ( num > 2 ) || ( num == 0 && EC_GROUP_have_precompute_mult ( group ) ) ) {\n ret = ec_wNAF_mul ( group , r , scalar , num , points , scalars , ctx ) ;\n goto err ;\n }\n if ( ( p = EC_POINT_new ( group ) ) == NULL ) goto err ;\n if ( ( acc = EC_POINT_new ( group ) ) == NULL ) goto err ;\n if ( ! EC_POINT_set_to_infinity ( group , acc ) ) goto err ;\n if ( scalar ) {\n if ( ! ec_GF2m_montgomery_point_multiply ( group , p , scalar , group -> generator , ctx ) ) goto err ;\n if ( BN_is_negative ( scalar ) ) if ( ! group -> meth -> invert ( group , p , ctx ) ) goto err ;\n if ( ! group -> meth -> add ( group , acc , acc , p , ctx ) ) goto err ;\n }\n for ( i = 0 ;\n i < num ;\n i ++ ) {\n if ( ! ec_GF2m_montgomery_point_multiply ( group , p , scalars [ i ] , points [ i ] , ctx ) ) goto err ;\n if ( BN_is_negative ( scalars [ i ] ) ) if ( ! group -> meth -> invert ( group , p , ctx ) ) goto err ;\n if ( ! group -> meth -> add ( group , acc , acc , p , ctx ) ) goto err ;\n }\n if ( ! EC_POINT_copy ( r , acc ) ) goto err ;\n ret = 1 ;\n err : if ( p ) EC_POINT_free ( p ) ;\n if ( acc ) EC_POINT_free ( acc ) ;\n if ( new_ctx != NULL ) BN_CTX_free ( new_ctx ) ;\n return ret ;\n }", "hash": 5468438784905165517, "project": "debian", "size": 36, "target": 0, "idx": 7939}
{"code": "extern int as_mysql_modify_resv ( mysql_conn_t * mysql_conn , slurmdb_reservation_rec_t * resv ) {\n MYSQL_RES * result = NULL ;\n MYSQL_ROW row ;\n int rc = SLURM_SUCCESS ;\n char * cols = NULL , * vals = NULL , * extra = NULL , * query = NULL ;\n time_t start = 0 , now = time ( NULL ) ;\n int i ;\n int set = 0 ;\n char * resv_req_inx [ ] = {\n \"assoclist\" , \"time_start\" , \"time_end\" , \"resv_name\" , \"nodelist\" , \"node_inx\" , \"flags\" , \"tres\" }\n ;\n enum {\n RESV_ASSOCS , RESV_START , RESV_END , RESV_NAME , RESV_NODES , RESV_NODE_INX , RESV_FLAGS , RESV_TRES , RESV_COUNT }\n ;\n if ( ! resv ) {\n error ( \"No reservation was given to edit\" ) ;\n return SLURM_ERROR ;\n }\n if ( ! resv -> id ) {\n error ( \"We need an id to edit a reservation.\" ) ;\n return SLURM_ERROR ;\n }\n if ( ! resv -> time_start ) {\n error ( \"We need a start time to edit a reservation.\" ) ;\n return SLURM_ERROR ;\n }\n if ( ! resv -> cluster || ! resv -> cluster [ 0 ] ) {\n error ( \"We need a cluster name to edit a reservation.\" ) ;\n return SLURM_ERROR ;\n }\n if ( ! resv -> time_start_prev ) {\n error ( \"We need a time to check for last \" \"start of reservation.\" ) ;\n return SLURM_ERROR ;\n }\n xstrfmtcat ( cols , \"%s\" , resv_req_inx [ 0 ] ) ;\n for ( i = 1 ;\n i < RESV_COUNT ;\n i ++ ) {\n xstrfmtcat ( cols , \", %s\" , resv_req_inx [ i ] ) ;\n }\n query = xstrdup_printf ( \"select %s from \\\"%s_%s\\\" where id_resv=%u \" \"and (time_start=%ld || time_start=%ld) \" \"and deleted=0 order by time_start desc \" \"limit 1 FOR UPDATE;\n\" , cols , resv -> cluster , resv_table , resv -> id , resv -> time_start , resv -> time_start_prev ) ;\n try_again : debug4 ( \"%d(%s:%d) query\\n%s\" , mysql_conn -> conn , THIS_FILE , __LINE__ , query ) ;\n if ( ! ( result = mysql_db_query_ret ( mysql_conn , query , 0 ) ) ) {\n rc = SLURM_ERROR ;\n goto end_it ;\n }\n if ( ! ( row = mysql_fetch_row ( result ) ) ) {\n rc = SLURM_ERROR ;\n mysql_free_result ( result ) ;\n error ( \"There is no reservation by id %u, \" \"time_start %ld, and cluster '%s'\" , resv -> id , resv -> time_start_prev , resv -> cluster ) ;\n if ( ! set && resv -> time_end ) {\n xfree ( query ) ;\n query = xstrdup_printf ( \"select %s from \\\"%s_%s\\\" where id_resv=%u \" \"and time_start <= %ld and deleted=0 \" \"order by time_start desc \" \"limit 1;\n\" , cols , resv -> cluster , resv_table , resv -> id , resv -> time_end ) ;\n set = 1 ;\n goto try_again ;\n }\n goto end_it ;\n }\n start = slurm_atoul ( row [ RESV_START ] ) ;\n xfree ( query ) ;\n xfree ( cols ) ;\n set = 0 ;\n if ( ! resv -> name && row [ RESV_NAME ] && row [ RESV_NAME ] [ 0 ] ) resv -> name = xstrdup ( row [ RESV_NAME ] ) ;\n if ( resv -> assocs ) set = 1 ;\n else if ( row [ RESV_ASSOCS ] && row [ RESV_ASSOCS ] [ 0 ] ) resv -> assocs = xstrdup ( row [ RESV_ASSOCS ] ) ;\n if ( resv -> flags != NO_VAL ) set = 1 ;\n else resv -> flags = slurm_atoul ( row [ RESV_FLAGS ] ) ;\n if ( resv -> nodes ) set = 1 ;\n else if ( row [ RESV_NODES ] && row [ RESV_NODES ] [ 0 ] ) {\n resv -> nodes = xstrdup ( row [ RESV_NODES ] ) ;\n resv -> node_inx = xstrdup ( row [ RESV_NODE_INX ] ) ;\n }\n if ( ! resv -> time_end ) resv -> time_end = slurm_atoul ( row [ RESV_END ] ) ;\n if ( resv -> tres_str ) set = 1 ;\n else if ( row [ RESV_TRES ] && row [ RESV_TRES ] [ 0 ] ) resv -> tres_str = xstrdup ( row [ RESV_TRES ] ) ;\n mysql_free_result ( result ) ;\n _setup_resv_limits ( resv , & cols , & vals , & extra ) ;\n if ( ( start > now ) || ! set ) {\n query = xstrdup_printf ( \"update \\\"%s_%s\\\" set deleted=0%s \" \"where deleted=0 and id_resv=%u \" \"and time_start=%ld;\n\" , resv -> cluster , resv_table , extra , resv -> id , start ) ;\n }\n else {\n query = xstrdup_printf ( \"update \\\"%s_%s\\\" set time_end=%ld \" \"where deleted=0 && id_resv=%u \" \"and time_start=%ld;\n\" , resv -> cluster , resv_table , resv -> time_start - 1 , resv -> id , start ) ;\n xstrfmtcat ( query , \"insert into \\\"%s_%s\\\" (id_resv%s) \" \"values (%u%s) \" \"on duplicate key update deleted=0%s;\n\" , resv -> cluster , resv_table , cols , resv -> id , vals , extra ) ;\n }\n if ( debug_flags & DEBUG_FLAG_DB_RESV ) DB_DEBUG ( mysql_conn -> conn , \"query\\n%s\" , query ) ;\n rc = mysql_db_query ( mysql_conn , query ) ;\n end_it : xfree ( query ) ;\n xfree ( cols ) ;\n xfree ( vals ) ;\n xfree ( extra ) ;\n return rc ;\n }", "hash": -2724676033474964439, "project": "debian", "size": 97, "target": 0, "idx": 7972}
{"code": "extern int as_mysql_step_start ( mysql_conn_t * mysql_conn , struct step_record * step_ptr ) {\n int tasks = 0 , nodes = 0 , task_dist = 0 ;\n int rc = SLURM_SUCCESS ;\n char temp_bit [ BUF_SIZE ] ;\n char node_list [ BUFFER_SIZE ] ;\n char * node_inx = NULL ;\n time_t start_time , submit_time ;\n char * query = NULL ;\n if ( ! step_ptr -> job_ptr -> db_index && ( ( ! step_ptr -> job_ptr -> details || ! step_ptr -> job_ptr -> details -> submit_time ) && ! step_ptr -> job_ptr -> resize_time ) ) {\n error ( \"as_mysql_step_start: \" \"Not inputing this job, it has no submit time.\" ) ;\n return SLURM_ERROR ;\n }\n if ( step_ptr -> job_ptr -> resize_time ) {\n submit_time = start_time = step_ptr -> job_ptr -> resize_time ;\n if ( step_ptr -> start_time > submit_time ) start_time = step_ptr -> start_time ;\n }\n else {\n start_time = step_ptr -> start_time ;\n submit_time = step_ptr -> job_ptr -> details -> submit_time ;\n }\n if ( check_connection ( mysql_conn ) != SLURM_SUCCESS ) return ESLURM_DB_CONNECTION ;\n if ( slurmdbd_conf ) {\n if ( step_ptr -> job_ptr -> details ) tasks = step_ptr -> job_ptr -> details -> num_tasks ;\n else tasks = step_ptr -> cpu_count ;\n snprintf ( node_list , BUFFER_SIZE , \"%s\" , step_ptr -> job_ptr -> nodes ) ;\n nodes = step_ptr -> step_layout -> node_cnt ;\n task_dist = step_ptr -> step_layout -> task_dist ;\n node_inx = step_ptr -> network ;\n }\n else if ( step_ptr -> step_id == SLURM_BATCH_SCRIPT ) {\n if ( step_ptr -> step_node_bitmap ) {\n node_inx = bit_fmt ( temp_bit , sizeof ( temp_bit ) , step_ptr -> step_node_bitmap ) ;\n }\n snprintf ( node_list , BUFFER_SIZE , \"%s\" , step_ptr -> gres ) ;\n nodes = tasks = 1 ;\n if ( ! step_ptr -> tres_alloc_str ) xstrfmtcat ( step_ptr -> tres_alloc_str , \"%s%u=%u,%u=%u\" , step_ptr -> tres_alloc_str ? \",\" : \"\" , TRES_CPU , 1 , TRES_NODE , 1 ) ;\n }\n else {\n char * ionodes = NULL , * temp_nodes = NULL ;\n if ( step_ptr -> step_node_bitmap ) {\n node_inx = bit_fmt ( temp_bit , sizeof ( temp_bit ) , step_ptr -> step_node_bitmap ) ;\n }\n if ( ! step_ptr -> step_layout || ! step_ptr -> step_layout -> task_cnt ) {\n if ( step_ptr -> cpu_count ) tasks = step_ptr -> cpu_count ;\n else {\n if ( ( tasks = slurmdb_find_tres_count_in_string ( step_ptr -> tres_alloc_str , TRES_CPU ) ) == INFINITE64 ) {\n if ( ( tasks = slurmdb_find_tres_count_in_string ( step_ptr -> job_ptr -> tres_alloc_str , TRES_CPU ) ) == INFINITE64 ) tasks = step_ptr -> job_ptr -> total_nodes ;\n }\n }\n nodes = step_ptr -> job_ptr -> total_nodes ;\n temp_nodes = step_ptr -> job_ptr -> nodes ;\n }\n else {\n tasks = step_ptr -> step_layout -> task_cnt ;\n # ifdef HAVE_BGQ select_g_select_jobinfo_get ( step_ptr -> select_jobinfo , SELECT_JOBDATA_NODE_CNT , & nodes ) ;\n # else nodes = step_ptr -> step_layout -> node_cnt ;\n # endif task_dist = step_ptr -> step_layout -> task_dist ;\n temp_nodes = step_ptr -> step_layout -> node_list ;\n }\n select_g_select_jobinfo_get ( step_ptr -> select_jobinfo , SELECT_JOBDATA_IONODES , & ionodes ) ;\n if ( ionodes ) {\n snprintf ( node_list , BUFFER_SIZE , \"%s[%s]\" , temp_nodes , ionodes ) ;\n xfree ( ionodes ) ;\n }\n else snprintf ( node_list , BUFFER_SIZE , \"%s\" , temp_nodes ) ;\n }\n if ( ! step_ptr -> job_ptr -> db_index ) {\n if ( ! ( step_ptr -> job_ptr -> db_index = _get_db_index ( mysql_conn , submit_time , step_ptr -> job_ptr -> job_id , step_ptr -> job_ptr -> assoc_id ) ) ) {\n if ( as_mysql_job_start ( mysql_conn , step_ptr -> job_ptr ) == SLURM_ERROR ) {\n error ( \"couldn't add job %u at step start\" , step_ptr -> job_ptr -> job_id ) ;\n return SLURM_SUCCESS ;\n }\n }\n }\n query = xstrdup_printf ( \"insert into \\\"%s_%s\\\" (job_db_inx, id_step, time_start, \" \"step_name, state, tres_alloc, \" \"nodes_alloc, task_cnt, nodelist, node_inx, \" \"task_dist, req_cpufreq, req_cpufreq_min, req_cpufreq_gov) \" \"values (%\" PRIu64 \", %d, %d, '%s', %d, '%s', %d, %d, \" \"'%s', '%s', %d, %u, %u, %u) \" \"on duplicate key update \" \"nodes_alloc=%d, task_cnt=%d, time_end=0, state=%d, \" \"nodelist='%s', node_inx='%s', task_dist=%d, \" \"req_cpufreq=%u, req_cpufreq_min=%u, req_cpufreq_gov=%u,\" \"tres_alloc='%s';\n\" , mysql_conn -> cluster_name , step_table , step_ptr -> job_ptr -> db_index , step_ptr -> step_id , ( int ) start_time , step_ptr -> name , JOB_RUNNING , step_ptr -> tres_alloc_str , nodes , tasks , node_list , node_inx , task_dist , step_ptr -> cpu_freq_max , step_ptr -> cpu_freq_min , step_ptr -> cpu_freq_gov , nodes , tasks , JOB_RUNNING , node_list , node_inx , task_dist , step_ptr -> cpu_freq_max , step_ptr -> cpu_freq_min , step_ptr -> cpu_freq_gov , step_ptr -> tres_alloc_str ) ;\n if ( debug_flags & DEBUG_FLAG_DB_STEP ) DB_DEBUG ( mysql_conn -> conn , \"query\\n%s\" , query ) ;\n rc = mysql_db_query ( mysql_conn , query ) ;\n xfree ( query ) ;\n return rc ;\n }", "hash": -483869641057106085, "project": "debian", "size": 81, "target": 0, "idx": 7977}
{"code": "gboolean logcat_text_process_dump_open ( wtap_dumper * wdh , int * err _U_ ) {\n struct dumper_t * dumper ;\n dumper = ( struct dumper_t * ) g_malloc ( sizeof ( struct dumper_t ) ) ;\n dumper -> type = DUMP_PROCESS ;\n wdh -> priv = dumper ;\n wdh -> subtype_write = logcat_dump_text ;\n wdh -> subtype_close = NULL ;\n return TRUE ;\n }", "hash": 3616225660295849566, "project": "debian", "size": 9, "target": 0, "idx": 7988}
{"code": "static inline bool alloc_array_check_size ( ulong num_elements , ulong elt_size , ulong * lsize ) {\n int64_t s = ( int64_t ) num_elements * elt_size ;\n if ( s > max_uint ) {\n return false ;\n }\n * lsize = ( ulong ) s ;\n return true ;\n }", "hash": 6600620671673714486, "project": "debian", "size": 8, "target": 0, "idx": 8001}
{"code": "static void i_defer_frees ( gs_memory_t * mem , int defer ) {\n }", "hash": 6600620671673714486, "project": "debian", "size": 2, "target": 0, "idx": 8002}
{"code": "static void i_status ( gs_memory_t * mem , gs_memory_status_t * pstat ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n ulong unused = imem -> lost . refs + imem -> lost . strings ;\n ulong inner = 0 ;\n clump_splay_walker sw ;\n clump_t * cp ;\n alloc_close_clump ( imem ) ;\n for ( cp = clump_splay_walk_init ( & sw , imem ) ;\n cp != NULL ;\n cp = clump_splay_walk_fwd ( & sw ) ) {\n unused += cp -> ctop - cp -> cbot ;\n if ( cp -> outer ) inner += cp -> cend - ( byte * ) cp -> chead ;\n }\n unused += compute_free_objects ( imem ) ;\n pstat -> used = imem -> allocated + inner - unused + imem -> previous_status . used ;\n pstat -> allocated = imem -> allocated + imem -> previous_status . allocated ;\n pstat -> max_used = 0 ;\n pstat -> is_thread_safe = false ;\n }", "hash": 6600620671673714486, "project": "debian", "size": 19, "target": 0, "idx": 8008}
{"code": "static void * i_alloc_struct_array ( gs_memory_t * mem , uint num_elements , gs_memory_type_ptr_t pstype , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n obj_header_t * obj ;\n ulong lsize ;\n # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;\n # endif ALLOC_CHECK_SIZE ( mem , pstype ) ;\n # ifdef DEBUG if ( pstype -> enum_ptrs == basic_enum_ptrs ) {\n dmprintf2 ( mem , \" i_alloc_struct_array: called with incorrect structure type (not element), struct='%s', client='%s'\\n\" , pstype -> sname , cname ) ;\n return NULL ;\n }\n # endif if ( alloc_array_check_size ( num_elements , pstype -> ssize , & lsize ) == false ) return NULL ;\n obj = alloc_obj ( imem , lsize , pstype , ALLOC_DIRECT , cname ) ;\n if_debug7m ( 'A' , mem , \"[a%d:+<.]%s %s*(%lu=%u*%u) = 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , struct_type_name_string ( pstype ) , ( ulong ) num_elements * pstype -> ssize , num_elements , pstype -> ssize , ( ulong ) obj ) ;\n return ( char * ) obj ;\n }", "hash": 6600620671673714486, "project": "debian", "size": 15, "target": 0, "idx": 8009}
{"code": "static void i_free_all ( gs_memory_t * mem , uint free_mask , client_name_t cname ) {\n gs_ref_memory_t * imem = ( gs_ref_memory_t * ) mem ;\n struct free_data fd ;\n fd . imem = imem ;\n fd . allocator = NULL ;\n if ( free_mask & FREE_ALL_DATA && imem -> root != NULL ) {\n clump_splay_app ( imem -> root , imem , free_all_not_allocator , & fd ) ;\n imem -> root = fd . allocator ;\n if ( fd . allocator ) fd . allocator -> parent = fd . allocator -> left = fd . allocator -> right = NULL ;\n }\n if ( free_mask & FREE_ALL_ALLOCATOR ) {\n clump_splay_app ( imem -> root , imem , free_all_allocator , & fd ) ;\n }\n }", "hash": 6600620671673714486, "project": "debian", "size": 14, "target": 0, "idx": 8010}
{"code": "static void * i_alloc_struct_array_immovable ( gs_memory_t * mem , uint num_elements , gs_memory_type_ptr_t pstype , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n obj_header_t * obj ;\n ulong lsize ;\n # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;\n # endif ALLOC_CHECK_SIZE ( mem , pstype ) ;\n if ( alloc_array_check_size ( num_elements , pstype -> ssize , & lsize ) == false ) return NULL ;\n obj = alloc_obj ( imem , lsize , pstype , ALLOC_IMMOVABLE | ALLOC_DIRECT , cname ) ;\n if_debug7m ( 'A' , mem , \"[a%d|+<.]%s %s*(%lu=%u*%u) = 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , struct_type_name_string ( pstype ) , ( ulong ) num_elements * pstype -> ssize , num_elements , pstype -> ssize , ( ulong ) obj ) ;\n return ( char * ) obj ;\n }", "hash": 6600620671673714486, "project": "debian", "size": 11, "target": 0, "idx": 8024}
{"code": "void ialloc_reset_free ( gs_ref_memory_t * mem ) {\n int i ;\n obj_header_t * * p ;\n mem -> lost . objects = 0 ;\n mem -> lost . refs = 0 ;\n mem -> lost . strings = 0 ;\n mem -> cfreed . cp = 0 ;\n for ( i = 0 , p = & mem -> freelists [ 0 ] ;\n i < num_freelists ;\n i ++ , p ++ ) * p = 0 ;\n mem -> largest_free_size = 0 ;\n }", "hash": 6600620671673714486, "project": "debian", "size": 12, "target": 0, "idx": 8028}
{"code": "static byte * i_alloc_string ( gs_memory_t * mem , uint nbytes , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n byte * str ;\n clump_splay_walker sw ;\n clump_t * cp = clump_splay_walk_init_mid ( & sw , imem -> cc ) ;\n if ( nbytes + ( uint ) HDR_ID_OFFSET < nbytes ) return NULL ;\n nbytes += HDR_ID_OFFSET ;\n # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;\n # endif if ( cp == 0 ) {\n imem -> cc = clump_splay_walk_init ( & sw , imem ) ;\n alloc_open_clump ( imem ) ;\n }\n top : if ( imem -> cc && imem -> cc -> ctop - imem -> cc -> cbot > nbytes ) {\n if_debug4m ( 'A' , mem , \"[a%d:+> ]%s(%u) = 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , nbytes , ( ulong ) ( imem -> cc -> ctop - nbytes ) ) ;\n str = imem -> cc -> ctop -= nbytes ;\n gs_alloc_fill ( str , gs_alloc_fill_alloc , nbytes ) ;\n str += HDR_ID_OFFSET ;\n ASSIGN_HDR_ID ( str ) ;\n return str ;\n }\n cp = clump_splay_walk_fwd ( & sw ) ;\n if ( cp != NULL ) {\n alloc_close_clump ( imem ) ;\n imem -> cc = cp ;\n alloc_open_clump ( imem ) ;\n goto top ;\n }\n if ( nbytes > string_space_quanta ( max_uint - sizeof ( clump_head_t ) ) * string_data_quantum ) {\n return 0 ;\n }\n if ( nbytes >= imem -> large_size ) {\n return i_alloc_string_immovable ( mem , nbytes , cname ) ;\n }\n else {\n cp = alloc_acquire_clump ( imem , ( ulong ) imem -> clump_size , true , \"clump\" ) ;\n if ( cp == 0 ) return 0 ;\n alloc_close_clump ( imem ) ;\n imem -> cc = clump_splay_walk_init_mid ( & sw , cp ) ;\n gs_alloc_fill ( imem -> cc -> cbase , gs_alloc_fill_free , imem -> cc -> climit - imem -> cc -> cbase ) ;\n goto top ;\n }\n }", "hash": 6600620671673714486, "project": "debian", "size": 42, "target": 0, "idx": 8032}
{"code": "void gs_memory_set_vm_reclaim ( gs_ref_memory_t * mem , bool enabled ) {\n gs_memory_gc_status_t stat ;\n gs_ref_memory_t * stable = ( gs_ref_memory_t * ) mem -> stable_memory ;\n gs_memory_gc_status ( mem , & stat ) ;\n stat . enabled = enabled ;\n gs_memory_set_gc_status ( mem , & stat ) ;\n gs_memory_gc_status ( stable , & stat ) ;\n stat . enabled = enabled ;\n gs_memory_set_gc_status ( stable , & stat ) ;\n }", "hash": 6600620671673714486, "project": "debian", "size": 10, "target": 0, "idx": 8037}
{"code": "static void i_free_string ( gs_memory_t * mem , byte * data , uint nbytes , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n if ( data ) {\n data -= HDR_ID_OFFSET ;\n nbytes += HDR_ID_OFFSET ;\n if ( imem -> cc && data == imem -> cc -> ctop ) {\n if_debug4m ( 'A' , mem , \"[a%d:-> ]%s(%u) 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , nbytes , ( ulong ) data ) ;\n imem -> cc -> ctop += nbytes ;\n }\n else {\n if_debug4m ( 'A' , mem , \"[a%d:->#]%s(%u) 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , nbytes , ( ulong ) data ) ;\n imem -> lost . strings += nbytes ;\n }\n gs_alloc_fill ( data , gs_alloc_fill_free , nbytes ) ;\n }\n }", "hash": 6600620671673714486, "project": "debian", "size": 16, "target": 0, "idx": 8039}
{"code": "void gs_memory_set_vm_threshold ( gs_ref_memory_t * mem , long val ) {\n gs_memory_gc_status_t stat ;\n gs_ref_memory_t * stable = ( gs_ref_memory_t * ) mem -> stable_memory ;\n gs_memory_gc_status ( mem , & stat ) ;\n stat . vm_threshold = val ;\n gs_memory_set_gc_status ( mem , & stat ) ;\n gs_memory_gc_status ( stable , & stat ) ;\n stat . vm_threshold = val ;\n gs_memory_set_gc_status ( stable , & stat ) ;\n }", "hash": 6600620671673714486, "project": "debian", "size": 10, "target": 0, "idx": 8044}
{"code": "static void ohci_bus_stop ( OHCIState * ohci ) {\n trace_usb_ohci_stop ( ohci -> name ) ;\n timer_del ( ohci -> eof_timer ) ;\n }", "hash": -398565394354770780, "project": "debian", "size": 4, "target": 0, "idx": 8052}
{"code": "static void usb_ohci_reset_pci ( DeviceState * d ) {\n PCIDevice * dev = PCI_DEVICE ( d ) ;\n OHCIPCIState * ohci = PCI_OHCI ( dev ) ;\n OHCIState * s = & ohci -> state ;\n ohci_hard_reset ( s ) ;\n }", "hash": -398565394354770780, "project": "debian", "size": 6, "target": 0, "idx": 8069}
{"code": "static bool ohci_eof_timer_needed ( void * opaque ) {\n OHCIState * ohci = opaque ;\n return timer_pending ( ohci -> eof_timer ) ;\n }", "hash": -398565394354770780, "project": "debian", "size": 4, "target": 0, "idx": 8078}
{"code": "static void ohci_process_lists ( OHCIState * ohci , int completion ) {\n if ( ( ohci -> ctl & OHCI_CTL_CLE ) && ( ohci -> status & OHCI_STATUS_CLF ) ) {\n if ( ohci -> ctrl_cur && ohci -> ctrl_cur != ohci -> ctrl_head ) {\n trace_usb_ohci_process_lists ( ohci -> ctrl_head , ohci -> ctrl_cur ) ;\n }\n if ( ! ohci_service_ed_list ( ohci , ohci -> ctrl_head , completion ) ) {\n ohci -> ctrl_cur = 0 ;\n ohci -> status &= ~ OHCI_STATUS_CLF ;\n }\n }\n if ( ( ohci -> ctl & OHCI_CTL_BLE ) && ( ohci -> status & OHCI_STATUS_BLF ) ) {\n if ( ! ohci_service_ed_list ( ohci , ohci -> bulk_head , completion ) ) {\n ohci -> bulk_cur = 0 ;\n ohci -> status &= ~ OHCI_STATUS_BLF ;\n }\n }\n }", "hash": -398565394354770780, "project": "debian", "size": 17, "target": 0, "idx": 8092}
{"code": "bool config_filter_match ( const struct config_filter * mask , const struct config_filter * filter ) {\n if ( ! config_filter_match_service ( mask , filter ) ) return FALSE ;\n return config_filter_match_rest ( mask , filter ) ;\n }", "hash": 2335116444795821310, "project": "debian", "size": 4, "target": 0, "idx": 8110}
{"code": "void config_filter_parsers_free ( struct config_module_parser * parsers ) {\n unsigned int i ;\n for ( i = 0 ;\n parsers [ i ] . root != NULL ;\n i ++ ) settings_parser_deinit ( & parsers [ i ] . parser ) ;\n }", "hash": 2335116444795821310, "project": "debian", "size": 6, "target": 0, "idx": 8114}
{"code": "static int do_execstack ( i_ctx_t * i_ctx_p , bool include_marks , bool include_oparrays , os_ptr op1 ) {\n os_ptr op = osp ;\n ref * arefs = op1 -> value . refs ;\n uint asize = r_size ( op1 ) ;\n uint i ;\n ref * rq ;\n for ( i = 0 , rq = arefs + asize ;\n rq != arefs ;\n ++ i ) {\n const ref * rp = ref_stack_index ( & e_stack , ( long ) i ) ;\n if ( r_has_type_attrs ( rp , t_null , a_executable ) && ! include_marks ) continue ;\n -- rq ;\n ref_assign_old ( op1 , rq , rp , \"execstack\" ) ;\n switch ( r_type ( rq ) ) {\n case t_operator : {\n uint opidx = op_index ( rq ) ;\n if ( opidx == 0 || op_def_is_internal ( op_index_def ( opidx ) ) ) r_clear_attrs ( rq , a_executable ) ;\n break ;\n }\n case t_struct : case t_astruct : {\n const char * tname = rq -> value . pstruct ? gs_struct_type_name_string ( gs_object_type ( imemory , rq -> value . pstruct ) ) : \"NULL\" ;\n make_const_string ( rq , a_readonly | avm_foreign , strlen ( tname ) , ( const byte * ) tname ) ;\n break ;\n }\n case t_array : case t_shortarray : case t_mixedarray : if ( ! include_oparrays && errorexec_find ( i_ctx_p , rq ) < 0 ) make_null ( rq ) ;\n break ;\n default : ;\n }\n }\n pop ( op - op1 ) ;\n return 0 ;\n }", "hash": -6119142299306266167, "project": "debian", "size": 32, "target": 0, "idx": 8126}
{"code": "static int err_end_runandhide ( i_ctx_t * i_ctx_p ) {\n int code ;\n if ( ( code = runandhide_restore_hidden ( i_ctx_p , esp + 3 , esp + 2 ) ) < 0 ) return code ;\n return 0 ;\n }", "hash": -6119142299306266167, "project": "debian", "size": 5, "target": 0, "idx": 8128}
{"code": "static int zneedinput ( i_ctx_t * i_ctx_p ) {\n return gs_error_NeedInput ;\n }", "hash": -6119142299306266167, "project": "debian", "size": 3, "target": 0, "idx": 8140}
{"code": "static int zstopped ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n check_op ( 1 ) ;\n check_estack ( 5 ) ;\n push_mark_estack ( es_stopped , no_cleanup ) ;\n ++ esp ;\n make_false ( esp ) ;\n ++ esp ;\n make_int ( esp , 1 ) ;\n push_op_estack ( stopped_push ) ;\n push_op_estack ( zexec ) ;\n return o_push_estack ;\n }", "hash": -6119142299306266167, "project": "debian", "size": 13, "target": 0, "idx": 8146}
{"code": "static int zquit ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n check_op ( 2 ) ;\n check_type ( * op , t_integer ) ;\n return_error ( gs_error_Quit ) ;\n }", "hash": -6119142299306266167, "project": "debian", "size": 6, "target": 0, "idx": 8168}
{"code": "int archive_read_support_format_all ( struct archive * a ) {\n archive_check_magic ( a , ARCHIVE_READ_MAGIC , ARCHIVE_STATE_NEW , \"archive_read_support_format_all\" ) ;\n archive_read_support_format_ar ( a ) ;\n archive_read_support_format_cpio ( a ) ;\n archive_read_support_format_empty ( a ) ;\n archive_read_support_format_lha ( a ) ;\n archive_read_support_format_mtree ( a ) ;\n archive_read_support_format_tar ( a ) ;\n archive_read_support_format_xar ( a ) ;\n archive_read_support_format_warc ( a ) ;\n archive_read_support_format_7zip ( a ) ;\n archive_read_support_format_cab ( a ) ;\n archive_read_support_format_rar ( a ) ;\n archive_read_support_format_iso9660 ( a ) ;\n archive_read_support_format_zip ( a ) ;\n archive_clear_error ( a ) ;\n return ( ARCHIVE_OK ) ;\n }", "hash": 2634052037515388009, "project": "debian", "size": 18, "target": 0, "idx": 8173}
{"code": "void relpTcpHintBurstBegin ( relpTcp_t * pThis ) {\n setCORKopt ( pThis -> sock , 1 ) ;\n }", "hash": 5835074581393329621, "project": "debian", "size": 3, "target": 0, "idx": 8180}
{"code": "relpRetVal relpTcpAbortDestruct ( relpTcp_t * * ppThis ) {\n struct linger ling ;\n ENTER_RELPFUNC ;\n assert ( ppThis != NULL ) ;\n RELPOBJ_assert ( ( * ppThis ) , Tcp ) ;\n if ( ( * ppThis ) -> sock != - 1 ) {\n ling . l_onoff = 1 ;\n ling . l_linger = 0 ;\n if ( setsockopt ( ( * ppThis ) -> sock , SOL_SOCKET , SO_LINGER , & ling , sizeof ( ling ) ) < 0 ) {\n ( * ppThis ) -> pEngine -> dbgprint ( \"could not set SO_LINGER, errno %d\\n\" , errno ) ;\n }\n }\n iRet = relpTcpDestruct ( ppThis ) ;\n LEAVE_RELPFUNC ;\n }", "hash": 5835074581393329621, "project": "debian", "size": 15, "target": 0, "idx": 8184}
{"code": "static inline void setCORKopt ( int sock , int onOff ) {\n # if defined ( TCP_CORK ) setsockopt ( sock , SOL_TCP , TCP_CORK , & onOff , sizeof ( onOff ) ) ;\n # elif defined ( TCP_NOPUSH ) setsockopt ( sock , IPPROTO_TCP , TCP_NOPUSH , & onOff , sizeof ( onOff ) ) ;\n # endif }", "hash": 5835074581393329621, "project": "debian", "size": 4, "target": 0, "idx": 8189}
{"code": "static iax_packet_data * iax_new_packet_data ( iax_call_data * call , gboolean reversed ) {\n iax_packet_data * p = wmem_new ( wmem_file_scope ( ) , iax_packet_data ) ;\n p -> first_time = TRUE ;\n p -> call_data = call ;\n p -> codec = 0 ;\n p -> reversed = reversed ;\n p -> abstime . secs = - 1 ;\n p -> abstime . nsecs = - 1 ;\n return p ;\n }", "hash": -4055702019813176658, "project": "debian", "size": 10, "target": 0, "idx": 8210}
{"code": "static iax_call_data * iax_lookup_call ( packet_info * pinfo , guint32 scallno , guint32 dcallno , gboolean * reversed_p ) {\n gboolean reversed = FALSE ;\n iax_call_data * iax_call = NULL ;\n guint src_circuit_id ;\n # ifdef DEBUG_HASHING gchar * srcstr , * dststr ;\n # endif # ifdef DEBUG_HASHING srcstr = address_to_str ( NULL , & pinfo -> src ) ;\n dststr = address_to_str ( NULL , & pinfo -> dst ) ;\n g_debug ( \"++ iax_lookup_circuit_details: Looking up circuit for frame %u, \" \"from {\n%s:%u:%u}\n to {\n%s:%u:%u}\n\" , pinfo -> fd -> num , srcstr , pinfo -> srcport , scallno , dststr , pinfo -> destport , dcallno ) ;\n wmem_free ( NULL , srcstr ) ;\n wmem_free ( NULL , dststr ) ;\n # endif src_circuit_id = iax_circuit_lookup ( & pinfo -> src , pinfo -> ptype , pinfo -> srcport , scallno ) ;\n if ( dcallno != 0 ) {\n guint dst_circuit_id ;\n # ifdef DEBUG_HASHING g_debug ( \"++ dcallno non-zero, looking up destination circuit\" ) ;\n # endif dst_circuit_id = iax_circuit_lookup ( & pinfo -> dst , pinfo -> ptype , pinfo -> destport , dcallno ) ;\n iax_call = iax_lookup_call_from_dest ( pinfo , NULL , src_circuit_id , dst_circuit_id , pinfo -> fd -> num , & reversed ) ;\n }\n else {\n circuit_t * src_circuit ;\n src_circuit = find_circuit ( CT_IAX2 , src_circuit_id , pinfo -> fd -> num ) ;\n if ( src_circuit ) {\n iax_call = ( iax_call_data * ) circuit_get_proto_data ( src_circuit , proto_iax2 ) ;\n DISSECTOR_ASSERT ( iax_call ) ;\n if ( is_forward_circuit ( src_circuit_id , iax_call ) ) reversed = FALSE ;\n else if ( is_reverse_circuit ( src_circuit_id , iax_call ) ) reversed = TRUE ;\n else {\n DISSECTOR_ASSERT_NOT_REACHED ( ) ;\n }\n }\n }\n if ( reversed_p ) * reversed_p = reversed ;\n # ifdef DEBUG_HASHING if ( iax_call ) {\n g_debug ( \"++ Found call for packet: id %u, reversed=%c\" , iax_call -> forward_circuit_ids [ 0 ] , reversed ? '1' : '0' ) ;\n }\n else {\n g_debug ( \"++ Call not found. Must have missed the NEW packet?\" ) ;\n }\n # endif return iax_call ;\n }", "hash": -4055702019813176658, "project": "debian", "size": 43, "target": 0, "idx": 8218}
{"code": "static guint32 dissect_minipacket ( tvbuff_t * tvb , guint32 offset , guint16 scallno , packet_info * pinfo , proto_tree * iax2_tree , proto_tree * main_tree ) {\n guint32 ts ;\n iax_packet_data * iax_packet ;\n proto_item * item ;\n ts = tvb_get_ntohs ( tvb , offset ) ;\n iax_packet = iax2_get_packet_data_for_minipacket ( pinfo , scallno , FALSE ) ;\n if ( iax2_tree ) {\n if ( iax_packet -> call_data ) {\n item = proto_tree_add_uint ( iax2_tree , hf_iax2_callno , tvb , 0 , 4 , iax_packet -> call_data -> forward_circuit_ids [ 0 ] ) ;\n PROTO_ITEM_SET_GENERATED ( item ) ;\n }\n proto_tree_add_uint ( iax2_tree , hf_iax2_minits , tvb , offset , 2 , ts ) ;\n iax2_add_ts_fields ( pinfo , iax2_tree , tvb , iax_packet , ( guint16 ) ts ) ;\n }\n else {\n iax2_add_ts_fields ( pinfo , iax2_tree , tvb , iax_packet , ( guint16 ) ts ) ;\n }\n offset += 2 ;\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"Mini packet, source call# %d, timestamp %ums\" , scallno , ts ) ;\n dissect_payload ( tvb , offset , pinfo , iax2_tree , main_tree , ts , FALSE , iax_packet ) ;\n iax_packet -> first_time = FALSE ;\n return offset ;\n }", "hash": -4055702019813176658, "project": "debian", "size": 23, "target": 0, "idx": 8220}
{"code": "static guint32 dissect_fullpacket ( tvbuff_t * tvb , guint32 offset , guint16 scallno , packet_info * pinfo , proto_tree * iax2_tree , proto_tree * main_tree ) {\n guint16 dcallno ;\n guint32 ts ;\n guint8 type ;\n guint8 csub ;\n guint32 codec ;\n proto_tree * packet_type_tree = NULL ;\n iax_call_data * iax_call ;\n iax_packet_data * iax_packet ;\n gboolean reversed ;\n gboolean rtp_marker ;\n dcallno = tvb_get_ntohs ( tvb , offset ) & 0x7FFF ;\n ts = tvb_get_ntohl ( tvb , offset + 2 ) ;\n type = tvb_get_guint8 ( tvb , offset + 8 ) ;\n csub = tvb_get_guint8 ( tvb , offset + 9 ) ;\n iax2_info -> ftype = type ;\n iax2_info -> csub = csub ;\n iax2_info -> scallno = scallno ;\n iax2_info -> dcallno = dcallno ;\n iax_packet = ( iax_packet_data * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_iax2 , 0 ) ;\n if ( ! iax_packet ) {\n if ( type == AST_FRAME_IAX && csub == IAX_COMMAND_NEW ) {\n iax_call = iax_new_call ( pinfo , scallno ) ;\n reversed = FALSE ;\n }\n else {\n iax_call = iax_lookup_call ( pinfo , scallno , dcallno , & reversed ) ;\n }\n iax_packet = iax_new_packet_data ( iax_call , reversed ) ;\n p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_iax2 , 0 , iax_packet ) ;\n }\n else {\n iax_call = iax_packet -> call_data ;\n reversed = iax_packet -> reversed ;\n }\n iax2_populate_pinfo_from_packet_data ( pinfo , iax_packet ) ;\n if ( iax2_tree ) {\n proto_item * packet_type_base ;\n proto_tree_add_item ( iax2_tree , hf_iax2_dcallno , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( iax2_tree , hf_iax2_retransmission , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n if ( iax_call ) {\n proto_item * item = proto_tree_add_uint ( iax2_tree , hf_iax2_callno , tvb , 0 , 4 , iax_call -> forward_circuit_ids [ 0 ] ) ;\n PROTO_ITEM_SET_GENERATED ( item ) ;\n }\n proto_tree_add_uint ( iax2_tree , hf_iax2_ts , tvb , offset + 2 , 4 , ts ) ;\n iax2_add_ts_fields ( pinfo , iax2_tree , tvb , iax_packet , ( guint16 ) ts ) ;\n proto_tree_add_item ( iax2_tree , hf_iax2_oseqno , tvb , offset + 6 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( iax2_tree , hf_iax2_iseqno , tvb , offset + 7 , 1 , ENC_BIG_ENDIAN ) ;\n packet_type_base = proto_tree_add_uint ( iax2_tree , hf_iax2_type , tvb , offset + 8 , 1 , type ) ;\n packet_type_tree = proto_item_add_subtree ( packet_type_base , ett_iax2_type ) ;\n }\n else {\n iax2_add_ts_fields ( pinfo , iax2_tree , tvb , iax_packet , ( guint16 ) ts ) ;\n }\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"%s, source call# %d, timestamp %ums\" , val_to_str_ext ( type , & iax_frame_types_ext , \"Unknown (0x%02x)\" ) , scallno , ts ) ;\n iax2_info -> messageName = val_to_str_ext ( type , & iax_frame_types_ext , \"Unknown (0x%02x)\" ) ;\n switch ( type ) {\n case AST_FRAME_IAX : offset = dissect_iax2_command ( tvb , offset + 9 , pinfo , packet_type_tree , iax_packet ) ;\n iax2_info -> messageName = val_to_str_ext ( csub , & iax_iax_subclasses_ext , \"unknown (0x%02x)\" ) ;\n if ( csub < NUM_TAP_IAX_VOIP_STATES ) iax2_info -> callState = tap_iax_voip_state [ csub ] ;\n break ;\n case AST_FRAME_DTMF_BEGIN : case AST_FRAME_DTMF_END : proto_tree_add_item ( packet_type_tree , hf_iax2_dtmf_csub , tvb , offset + 9 , 1 , ENC_ASCII | ENC_NA ) ;\n offset += 10 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" digit %c\" , csub ) ;\n break ;\n case AST_FRAME_CONTROL : proto_tree_add_uint ( packet_type_tree , hf_iax2_cmd_csub , tvb , offset + 9 , 1 , csub ) ;\n offset += 10 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" %s\" , val_to_str_ext ( csub , & iax_cmd_subclasses_ext , \"unknown (0x%02x)\" ) ) ;\n iax2_info -> messageName = val_to_str_ext ( csub , & iax_cmd_subclasses_ext , \"unknown (0x%02x)\" ) ;\n if ( csub < NUM_TAP_CMD_VOIP_STATES ) iax2_info -> callState = tap_cmd_voip_state [ csub ] ;\n break ;\n case AST_FRAME_VOICE : iax_packet -> codec = codec = uncompress_subclass ( csub ) ;\n if ( packet_type_tree ) {\n proto_item * item ;\n proto_tree_add_item ( packet_type_tree , hf_iax2_voice_csub , tvb , offset + 9 , 1 , ENC_BIG_ENDIAN ) ;\n item = proto_tree_add_uint ( packet_type_tree , hf_iax2_voice_codec , tvb , offset + 9 , 1 , codec ) ;\n PROTO_ITEM_SET_GENERATED ( item ) ;\n }\n offset += 10 ;\n if ( iax_call ) {\n if ( reversed ) {\n iax_call -> dst_codec = codec ;\n }\n else {\n iax_call -> src_codec = codec ;\n }\n }\n dissect_payload ( tvb , offset , pinfo , iax2_tree , main_tree , ts , FALSE , iax_packet ) ;\n break ;\n case AST_FRAME_VIDEO : rtp_marker = csub & 0x40 ? TRUE : FALSE ;\n iax_packet -> codec = codec = uncompress_subclass ( ( guint8 ) ( csub & ~ 40 ) ) ;\n if ( packet_type_tree ) {\n proto_item * item ;\n proto_tree_add_item ( packet_type_tree , hf_iax2_video_csub , tvb , offset + 9 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( packet_type_tree , hf_iax2_marker , tvb , offset + 9 , 1 , ENC_BIG_ENDIAN ) ;\n item = proto_tree_add_uint ( packet_type_tree , hf_iax2_video_codec , tvb , offset + 9 , 1 , codec ) ;\n PROTO_ITEM_SET_GENERATED ( item ) ;\n }\n offset += 10 ;\n if ( iax_call && iax_packet -> first_time ) {\n if ( reversed ) {\n iax_call -> dst_vformat = codec ;\n }\n else {\n iax_call -> src_vformat = codec ;\n }\n }\n if ( rtp_marker ) col_append_str ( pinfo -> cinfo , COL_INFO , \", Mark\" ) ;\n dissect_payload ( tvb , offset , pinfo , iax2_tree , main_tree , ts , TRUE , iax_packet ) ;\n break ;\n case AST_FRAME_MODEM : proto_tree_add_item ( packet_type_tree , hf_iax2_modem_csub , tvb , offset + 9 , 1 , ENC_BIG_ENDIAN ) ;\n offset += 10 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" %s\" , val_to_str ( csub , iax_modem_subclasses , \"unknown (0x%02x)\" ) ) ;\n break ;\n case AST_FRAME_TEXT : proto_tree_add_item ( packet_type_tree , hf_iax2_text_csub , tvb , offset + 9 , 1 , ENC_BIG_ENDIAN ) ;\n offset += 10 ;\n {\n int textlen = tvb_captured_length_remaining ( tvb , offset ) ;\n if ( textlen > 0 ) {\n proto_tree_add_item ( packet_type_tree , hf_iax2_text_text , tvb , offset , textlen , ENC_UTF_8 | ENC_NA ) ;\n offset += textlen ;\n }\n }\n break ;\n case AST_FRAME_HTML : proto_tree_add_item ( packet_type_tree , hf_iax2_html_csub , tvb , offset + 9 , 1 , ENC_BIG_ENDIAN ) ;\n offset += 10 ;\n if ( csub == 0x01 ) {\n int urllen = tvb_captured_length_remaining ( tvb , offset ) ;\n if ( urllen > 0 ) {\n proto_item * pi = proto_tree_add_item ( packet_type_tree , hf_iax2_html_url , tvb , offset , urllen , ENC_UTF_8 | ENC_NA ) ;\n PROTO_ITEM_SET_URL ( pi ) ;\n offset += urllen ;\n }\n }\n break ;\n case AST_FRAME_CNG : default : proto_tree_add_uint ( packet_type_tree , hf_iax2_csub , tvb , offset + 9 , 1 , csub ) ;\n offset += 10 ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" subclass %d\" , csub ) ;\n break ;\n }\n iax_packet -> first_time = FALSE ;\n return offset ;\n }", "hash": -4055702019813176658, "project": "debian", "size": 143, "target": 0, "idx": 8224}
{"code": "static void iax_cleanup_protocol ( void ) {\n g_hash_table_destroy ( iax_circuit_hashtab ) ;\n g_hash_table_destroy ( iax_fid_table ) ;\n reassembly_table_destroy ( & iax_reassembly_table ) ;\n }", "hash": -4055702019813176658, "project": "debian", "size": 5, "target": 0, "idx": 8225}
{"code": "static iax_packet_data * iax2_get_packet_data_for_minipacket ( packet_info * pinfo , guint16 scallno , gboolean video ) {\n iax_packet_data * p = ( iax_packet_data * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_iax2 , 0 ) ;\n if ( ! p ) {\n gboolean reversed ;\n iax_call_data * iax_call ;\n iax_call = iax_lookup_call ( pinfo , scallno , 0 , & reversed ) ;\n p = iax_new_packet_data ( iax_call , reversed ) ;\n p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_iax2 , 0 , p ) ;\n if ( iax_call ) {\n if ( video ) p -> codec = reversed ? iax_call -> dst_vformat : iax_call -> src_vformat ;\n else p -> codec = reversed ? iax_call -> dst_codec : iax_call -> src_codec ;\n }\n }\n iax2_populate_pinfo_from_packet_data ( pinfo , p ) ;\n return p ;\n }", "hash": -4055702019813176658, "project": "debian", "size": 16, "target": 0, "idx": 8236}
{"code": "static void ps2_set_ledstate ( PS2KbdState * s , int ledstate ) {\n trace_ps2_set_ledstate ( s , ledstate ) ;\n s -> ledstate = ledstate ;\n kbd_put_ledstate ( ledstate ) ;\n }", "hash": 3426991998365732450, "project": "debian", "size": 5, "target": 0, "idx": 8241}
{"code": "static void ps2_keyboard_event ( DeviceState * dev , QemuConsole * src , InputEvent * evt ) {\n PS2KbdState * s = ( PS2KbdState * ) dev ;\n InputKeyEvent * key = evt -> u . key . data ;\n int qcode ;\n uint16_t keycode ;\n int mod ;\n qemu_system_wakeup_request ( QEMU_WAKEUP_REASON_OTHER ) ;\n assert ( evt -> type == INPUT_EVENT_KIND_KEY ) ;\n qcode = qemu_input_key_value_to_qcode ( key -> key ) ;\n mod = ps2_modifier_bit ( qcode ) ;\n trace_ps2_keyboard_event ( s , qcode , key -> down , mod , s -> modifiers ) ;\n if ( key -> down ) {\n s -> modifiers |= mod ;\n }\n else {\n s -> modifiers &= ~ mod ;\n }\n if ( s -> scancode_set == 1 ) {\n if ( qcode == Q_KEY_CODE_PAUSE ) {\n if ( s -> modifiers & ( MOD_CTRL_L | MOD_CTRL_R ) ) {\n if ( key -> down ) {\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0x46 ) ;\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0xc6 ) ;\n }\n }\n else {\n if ( key -> down ) {\n ps2_put_keycode ( s , 0xe1 ) ;\n ps2_put_keycode ( s , 0x1d ) ;\n ps2_put_keycode ( s , 0x45 ) ;\n ps2_put_keycode ( s , 0xe1 ) ;\n ps2_put_keycode ( s , 0x9d ) ;\n ps2_put_keycode ( s , 0xc5 ) ;\n }\n }\n }\n else if ( qcode == Q_KEY_CODE_PRINT ) {\n if ( s -> modifiers & MOD_ALT_L ) {\n if ( key -> down ) {\n ps2_put_keycode ( s , 0xb8 ) ;\n ps2_put_keycode ( s , 0x38 ) ;\n ps2_put_keycode ( s , 0x54 ) ;\n }\n else {\n ps2_put_keycode ( s , 0xd4 ) ;\n ps2_put_keycode ( s , 0xb8 ) ;\n ps2_put_keycode ( s , 0x38 ) ;\n }\n }\n else if ( s -> modifiers & MOD_ALT_R ) {\n if ( key -> down ) {\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0xb8 ) ;\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0x38 ) ;\n ps2_put_keycode ( s , 0x54 ) ;\n }\n else {\n ps2_put_keycode ( s , 0xd4 ) ;\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0xb8 ) ;\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0x38 ) ;\n }\n }\n else if ( s -> modifiers & ( MOD_SHIFT_L | MOD_CTRL_L | MOD_SHIFT_R | MOD_CTRL_R ) ) {\n if ( key -> down ) {\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0x37 ) ;\n }\n else {\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0xb7 ) ;\n }\n }\n else {\n if ( key -> down ) {\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0x2a ) ;\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0x37 ) ;\n }\n else {\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0xb7 ) ;\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0xaa ) ;\n }\n }\n }\n else {\n keycode = qcode_to_keycode_set1 [ qcode ] ;\n if ( keycode ) {\n if ( keycode & 0xff00 ) {\n ps2_put_keycode ( s , keycode >> 8 ) ;\n }\n if ( ! key -> down ) {\n keycode |= 0x80 ;\n }\n ps2_put_keycode ( s , keycode & 0xff ) ;\n }\n else {\n qemu_log_mask ( LOG_UNIMP , \"ps2: ignoring key with qcode %d\\n\" , qcode ) ;\n }\n }\n }\n else if ( s -> scancode_set == 2 ) {\n if ( qcode == Q_KEY_CODE_PAUSE ) {\n if ( s -> modifiers & ( MOD_CTRL_L | MOD_CTRL_R ) ) {\n if ( key -> down ) {\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0x7e ) ;\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0xf0 ) ;\n ps2_put_keycode ( s , 0x7e ) ;\n }\n }\n else {\n if ( key -> down ) {\n ps2_put_keycode ( s , 0xe1 ) ;\n ps2_put_keycode ( s , 0x14 ) ;\n ps2_put_keycode ( s , 0x77 ) ;\n ps2_put_keycode ( s , 0xe1 ) ;\n ps2_put_keycode ( s , 0xf0 ) ;\n ps2_put_keycode ( s , 0x14 ) ;\n ps2_put_keycode ( s , 0xf0 ) ;\n ps2_put_keycode ( s , 0x77 ) ;\n }\n }\n }\n else if ( qcode == Q_KEY_CODE_PRINT ) {\n if ( s -> modifiers & MOD_ALT_L ) {\n if ( key -> down ) {\n ps2_put_keycode ( s , 0xf0 ) ;\n ps2_put_keycode ( s , 0x11 ) ;\n ps2_put_keycode ( s , 0x11 ) ;\n ps2_put_keycode ( s , 0x84 ) ;\n }\n else {\n ps2_put_keycode ( s , 0xf0 ) ;\n ps2_put_keycode ( s , 0x84 ) ;\n ps2_put_keycode ( s , 0xf0 ) ;\n ps2_put_keycode ( s , 0x11 ) ;\n ps2_put_keycode ( s , 0x11 ) ;\n }\n }\n else if ( s -> modifiers & MOD_ALT_R ) {\n if ( key -> down ) {\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0xf0 ) ;\n ps2_put_keycode ( s , 0x11 ) ;\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0x11 ) ;\n ps2_put_keycode ( s , 0x84 ) ;\n }\n else {\n ps2_put_keycode ( s , 0xf0 ) ;\n ps2_put_keycode ( s , 0x84 ) ;\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0xf0 ) ;\n ps2_put_keycode ( s , 0x11 ) ;\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0x11 ) ;\n }\n }\n else if ( s -> modifiers & ( MOD_SHIFT_L | MOD_CTRL_L | MOD_SHIFT_R | MOD_CTRL_R ) ) {\n if ( key -> down ) {\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0x7c ) ;\n }\n else {\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0xf0 ) ;\n ps2_put_keycode ( s , 0x7c ) ;\n }\n }\n else {\n if ( key -> down ) {\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0x12 ) ;\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0x7c ) ;\n }\n else {\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0xf0 ) ;\n ps2_put_keycode ( s , 0x7c ) ;\n ps2_put_keycode ( s , 0xe0 ) ;\n ps2_put_keycode ( s , 0xf0 ) ;\n ps2_put_keycode ( s , 0x12 ) ;\n }\n }\n }\n else {\n keycode = qcode_to_keycode_set2 [ qcode ] ;\n if ( keycode ) {\n if ( keycode & 0xff00 ) {\n ps2_put_keycode ( s , keycode >> 8 ) ;\n }\n if ( ! key -> down ) {\n ps2_put_keycode ( s , 0xf0 ) ;\n }\n ps2_put_keycode ( s , keycode & 0xff ) ;\n }\n else {\n qemu_log_mask ( LOG_UNIMP , \"ps2: ignoring key with qcode %d\\n\" , qcode ) ;\n }\n }\n }\n else if ( s -> scancode_set == 3 ) {\n keycode = qcode_to_keycode_set3 [ qcode ] ;\n if ( keycode ) {\n if ( ! key -> down ) {\n ps2_put_keycode ( s , 0xf0 ) ;\n }\n ps2_put_keycode ( s , keycode ) ;\n }\n else {\n qemu_log_mask ( LOG_UNIMP , \"ps2: ignoring key with qcode %d\\n\" , qcode ) ;\n }\n }\n }", "hash": 3426991998365732450, "project": "debian", "size": 224, "target": 0, "idx": 8251}
{"code": "static struct mspack_file * mspack_fmap_open ( struct mspack_system * self , const char * filename , int mode ) {\n struct mspack_name * mspack_name ;\n struct mspack_handle * mspack_handle ;\n struct mspack_system_ex * self_ex ;\n const char * fmode ;\n const struct mspack_system * mptr = self ;\n if ( ! filename ) {\n cli_dbgmsg ( \"%s() failed at %d\\n\" , __func__ , __LINE__ ) ;\n return NULL ;\n }\n mspack_handle = malloc ( sizeof ( * mspack_handle ) ) ;\n if ( ! mspack_handle ) {\n cli_dbgmsg ( \"%s() failed at %d\\n\" , __func__ , __LINE__ ) ;\n return NULL ;\n }\n switch ( mode ) {\n case MSPACK_SYS_OPEN_READ : mspack_handle -> type = FILETYPE_FMAP ;\n mspack_name = ( struct mspack_name * ) filename ;\n mspack_handle -> fmap = mspack_name -> fmap ;\n mspack_handle -> org = mspack_name -> org ;\n mspack_handle -> offset = 0 ;\n return ( struct mspack_file * ) mspack_handle ;\n case MSPACK_SYS_OPEN_WRITE : fmode = \"wb\" ;\n break ;\n case MSPACK_SYS_OPEN_UPDATE : fmode = \"r+b\" ;\n break ;\n case MSPACK_SYS_OPEN_APPEND : fmode = \"ab\" ;\n break ;\n default : cli_dbgmsg ( \"%s() wrong mode\\n\" , __func__ ) ;\n goto out_err ;\n }\n mspack_handle -> type = FILETYPE_FILENAME ;\n mspack_handle -> f = fopen ( filename , fmode ) ;\n if ( ! mspack_handle -> f ) {\n cli_dbgmsg ( \"%s() failed %d\\n\" , __func__ , __LINE__ ) ;\n goto out_err ;\n }\n self_ex = ( struct mspack_system_ex * ) ( ( char * ) mptr - offsetof ( struct mspack_system_ex , ops ) ) ;\n mspack_handle -> max_size = self_ex -> max_size ;\n return ( struct mspack_file * ) mspack_handle ;\n out_err : free ( mspack_handle ) ;\n return NULL ;\n }", "hash": 6028689830752105670, "project": "debian", "size": 43, "target": 0, "idx": 8285}
{"code": "static void sapi_uwsgi_log_message ( char * message TSRMLS_DC ) {\n # endif uwsgi_log ( \"%s\\n\" , message ) ;\n }", "hash": 4511225370772574632, "project": "debian", "size": 3, "target": 0, "idx": 8289}
{"code": "PHP_FUNCTION ( uwsgi_cache_clear ) {\n char * cache = NULL ;\n int cachelen = 0 ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|s\" , & cache , & cachelen ) == FAILURE ) {\n RETURN_NULL ( ) ;\n }\n if ( ! uwsgi_cache_magic_clear ( cache ) ) {\n RETURN_TRUE ;\n }\n RETURN_NULL ( ) ;\n }", "hash": 4511225370772574632, "project": "debian", "size": 11, "target": 0, "idx": 8291}
{"code": "static char * sapi_uwsgi_read_cookies ( TSRMLS_D ) {\n uint16_t len = 0 ;\n struct wsgi_request * wsgi_req = ( struct wsgi_request * ) SG ( server_context ) ;\n char * cookie = uwsgi_get_var ( wsgi_req , ( char * ) \"HTTP_COOKIE\" , 11 , & len ) ;\n if ( cookie ) {\n return estrndup ( cookie , len ) ;\n }\n return NULL ;\n }", "hash": 4511225370772574632, "project": "debian", "size": 9, "target": 0, "idx": 8303}
{"code": "void bn_sqr_words ( BN_ULONG * r , const BN_ULONG * a , int n ) {\n assert ( n >= 0 ) ;\n if ( n <= 0 ) return ;\n # ifndef OPENSSL_SMALL_FOOTPRINT while ( n & ~ 3 ) {\n sqr64 ( r [ 0 ] , r [ 1 ] , a [ 0 ] ) ;\n sqr64 ( r [ 2 ] , r [ 3 ] , a [ 1 ] ) ;\n sqr64 ( r [ 4 ] , r [ 5 ] , a [ 2 ] ) ;\n sqr64 ( r [ 6 ] , r [ 7 ] , a [ 3 ] ) ;\n a += 4 ;\n r += 8 ;\n n -= 4 ;\n }\n # endif while ( n ) {\n sqr64 ( r [ 0 ] , r [ 1 ] , a [ 0 ] ) ;\n a ++ ;\n r += 2 ;\n n -- ;\n }\n }", "hash": -2584200269856679124, "project": "debian", "size": 19, "target": 0, "idx": 8323}
{"code": "static void print_word ( BIO * bp , BN_ULONG w ) {\n # ifdef SIXTY_FOUR_BIT if ( sizeof ( w ) > sizeof ( unsigned long ) ) {\n unsigned long h = ( unsigned long ) ( w >> 32 ) , l = ( unsigned long ) ( w ) ;\n if ( h ) BIO_printf ( bp , \"%lX%08lX\" , h , l ) ;\n else BIO_printf ( bp , \"%lX\" , l ) ;\n return ;\n }\n # endif BIO_printf ( bp , BN_HEX_FMT1 , w ) ;\n }", "hash": -7553540414561818627, "project": "debian", "size": 9, "target": 0, "idx": 8335}
{"code": "int test_kron ( BIO * bp , BN_CTX * ctx ) {\n BN_GENCB cb ;\n BIGNUM * a , * b , * r , * t ;\n int i ;\n int legendre , kronecker ;\n int ret = 0 ;\n a = BN_new ( ) ;\n b = BN_new ( ) ;\n r = BN_new ( ) ;\n t = BN_new ( ) ;\n if ( a == NULL || b == NULL || r == NULL || t == NULL ) goto err ;\n BN_GENCB_set ( & cb , genprime_cb , NULL ) ;\n if ( ! BN_generate_prime_ex ( b , 512 , 0 , NULL , NULL , & cb ) ) goto err ;\n b -> neg = rand_neg ( ) ;\n putc ( '\\n' , stderr ) ;\n for ( i = 0 ;\n i < num0 ;\n i ++ ) {\n if ( ! BN_bntest_rand ( a , 512 , 0 , 0 ) ) goto err ;\n a -> neg = rand_neg ( ) ;\n if ( ! BN_copy ( t , b ) ) goto err ;\n t -> neg = 0 ;\n if ( ! BN_sub_word ( t , 1 ) ) goto err ;\n if ( ! BN_rshift1 ( t , t ) ) goto err ;\n b -> neg = 0 ;\n if ( ! BN_mod_exp_recp ( r , a , t , b , ctx ) ) goto err ;\n b -> neg = 1 ;\n if ( BN_is_word ( r , 1 ) ) legendre = 1 ;\n else if ( BN_is_zero ( r ) ) legendre = 0 ;\n else {\n if ( ! BN_add_word ( r , 1 ) ) goto err ;\n if ( 0 != BN_ucmp ( r , b ) ) {\n fprintf ( stderr , \"Legendre symbol computation failed\\n\" ) ;\n goto err ;\n }\n legendre = - 1 ;\n }\n kronecker = BN_kronecker ( a , b , ctx ) ;\n if ( kronecker < - 1 ) goto err ;\n if ( a -> neg && b -> neg ) kronecker = - kronecker ;\n if ( legendre != kronecker ) {\n fprintf ( stderr , \"legendre != kronecker;\n a = \" ) ;\n BN_print_fp ( stderr , a ) ;\n fprintf ( stderr , \", b = \" ) ;\n BN_print_fp ( stderr , b ) ;\n fprintf ( stderr , \"\\n\" ) ;\n goto err ;\n }\n putc ( '.' , stderr ) ;\n fflush ( stderr ) ;\n }\n putc ( '\\n' , stderr ) ;\n fflush ( stderr ) ;\n ret = 1 ;\n err : if ( a != NULL ) BN_free ( a ) ;\n if ( b != NULL ) BN_free ( b ) ;\n if ( r != NULL ) BN_free ( r ) ;\n if ( t != NULL ) BN_free ( t ) ;\n return ret ;\n }", "hash": -7553540414561818627, "project": "debian", "size": 61, "target": 0, "idx": 8337}
{"code": "int test_rshift1 ( BIO * bp ) {\n BIGNUM * a , * b , * c ;\n int i ;\n a = BN_new ( ) ;\n b = BN_new ( ) ;\n c = BN_new ( ) ;\n BN_bntest_rand ( a , 200 , 0 , 0 ) ;\n a -> neg = rand_neg ( ) ;\n for ( i = 0 ;\n i < num0 ;\n i ++ ) {\n BN_rshift1 ( b , a ) ;\n if ( bp != NULL ) {\n if ( ! results ) {\n BN_print ( bp , a ) ;\n BIO_puts ( bp , \" / 2\" ) ;\n BIO_puts ( bp , \" - \" ) ;\n }\n BN_print ( bp , b ) ;\n BIO_puts ( bp , \"\\n\" ) ;\n }\n BN_sub ( c , a , b ) ;\n BN_sub ( c , c , b ) ;\n if ( ! BN_is_zero ( c ) && ! BN_abs_is_word ( c , 1 ) ) {\n fprintf ( stderr , \"Right shift one test failed!\\n\" ) ;\n return 0 ;\n }\n BN_copy ( a , b ) ;\n }\n BN_free ( a ) ;\n BN_free ( b ) ;\n BN_free ( c ) ;\n return ( 1 ) ;\n }", "hash": -7553540414561818627, "project": "debian", "size": 34, "target": 0, "idx": 8338}
{"code": "int test_gf2m_mod_inv ( BIO * bp , BN_CTX * ctx ) {\n BIGNUM * a , * b [ 2 ] , * c , * d ;\n int i , j , ret = 0 ;\n int p0 [ ] = {\n 163 , 7 , 6 , 3 , 0 , - 1 }\n ;\n int p1 [ ] = {\n 193 , 15 , 0 , - 1 }\n ;\n a = BN_new ( ) ;\n b [ 0 ] = BN_new ( ) ;\n b [ 1 ] = BN_new ( ) ;\n c = BN_new ( ) ;\n d = BN_new ( ) ;\n BN_GF2m_arr2poly ( p0 , b [ 0 ] ) ;\n BN_GF2m_arr2poly ( p1 , b [ 1 ] ) ;\n for ( i = 0 ;\n i < num0 ;\n i ++ ) {\n BN_bntest_rand ( a , 512 , 0 , 0 ) ;\n for ( j = 0 ;\n j < 2 ;\n j ++ ) {\n BN_GF2m_mod_inv ( c , a , b [ j ] , ctx ) ;\n BN_GF2m_mod_mul ( d , a , c , b [ j ] , ctx ) ;\n # if 0 if ( bp != NULL ) {\n if ( ! results ) {\n BN_print ( bp , a ) ;\n BIO_puts ( bp , \" * \" ) ;\n BN_print ( bp , c ) ;\n BIO_puts ( bp , \" - 1 % \" ) ;\n BN_print ( bp , b [ j ] ) ;\n BIO_puts ( bp , \"\\n\" ) ;\n }\n }\n # endif if ( ! BN_is_one ( d ) ) {\n fprintf ( stderr , \"GF(2^m) modular inversion test failed!\\n\" ) ;\n goto err ;\n }\n }\n }\n ret = 1 ;\n err : BN_free ( a ) ;\n BN_free ( b [ 0 ] ) ;\n BN_free ( b [ 1 ] ) ;\n BN_free ( c ) ;\n BN_free ( d ) ;\n return ret ;\n }", "hash": -7553540414561818627, "project": "debian", "size": 49, "target": 0, "idx": 8345}
{"code": "int test_gf2m_mod_solve_quad ( BIO * bp , BN_CTX * ctx ) {\n BIGNUM * a , * b [ 2 ] , * c , * d , * e ;\n int i , j , s = 0 , t , ret = 0 ;\n int p0 [ ] = {\n 163 , 7 , 6 , 3 , 0 , - 1 }\n ;\n int p1 [ ] = {\n 193 , 15 , 0 , - 1 }\n ;\n a = BN_new ( ) ;\n b [ 0 ] = BN_new ( ) ;\n b [ 1 ] = BN_new ( ) ;\n c = BN_new ( ) ;\n d = BN_new ( ) ;\n e = BN_new ( ) ;\n BN_GF2m_arr2poly ( p0 , b [ 0 ] ) ;\n BN_GF2m_arr2poly ( p1 , b [ 1 ] ) ;\n for ( i = 0 ;\n i < num0 ;\n i ++ ) {\n BN_bntest_rand ( a , 512 , 0 , 0 ) ;\n for ( j = 0 ;\n j < 2 ;\n j ++ ) {\n t = BN_GF2m_mod_solve_quad ( c , a , b [ j ] , ctx ) ;\n if ( t ) {\n s ++ ;\n BN_GF2m_mod_sqr ( d , c , b [ j ] , ctx ) ;\n BN_GF2m_add ( d , c , d ) ;\n BN_GF2m_mod ( e , a , b [ j ] ) ;\n # if 0 if ( bp != NULL ) {\n if ( ! results ) {\n BN_print ( bp , c ) ;\n BIO_puts ( bp , \" is root of z^2 + z = \" ) ;\n BN_print ( bp , a ) ;\n BIO_puts ( bp , \" % \" ) ;\n BN_print ( bp , b [ j ] ) ;\n BIO_puts ( bp , \"\\n\" ) ;\n }\n }\n # endif BN_GF2m_add ( e , e , d ) ;\n if ( ! BN_is_zero ( e ) ) {\n fprintf ( stderr , \"GF(2^m) modular solve quadratic test failed!\\n\" ) ;\n goto err ;\n }\n }\n else {\n # if 0 if ( bp != NULL ) {\n if ( ! results ) {\n BIO_puts ( bp , \"There are no roots of z^2 + z = \" ) ;\n BN_print ( bp , a ) ;\n BIO_puts ( bp , \" % \" ) ;\n BN_print ( bp , b [ j ] ) ;\n BIO_puts ( bp , \"\\n\" ) ;\n }\n }\n # endif }\n }\n }\n if ( s == 0 ) {\n fprintf ( stderr , \"All %i tests of GF(2^m) modular solve quadratic resulted in no roots;\n\\n\" , num0 ) ;\n fprintf ( stderr , \"this is very unlikely and probably indicates an error.\\n\" ) ;\n goto err ;\n }\n ret = 1 ;\n err : BN_free ( a ) ;\n BN_free ( b [ 0 ] ) ;\n BN_free ( b [ 1 ] ) ;\n BN_free ( c ) ;\n BN_free ( d ) ;\n BN_free ( e ) ;\n return ret ;\n }", "hash": -7553540414561818627, "project": "debian", "size": 74, "target": 0, "idx": 8357}
{"code": "int test_div_word ( BIO * bp ) {\n BIGNUM a , b ;\n BN_ULONG r , s ;\n int i ;\n BN_init ( & a ) ;\n BN_init ( & b ) ;\n for ( i = 0 ;\n i < num0 ;\n i ++ ) {\n do {\n BN_bntest_rand ( & a , 512 , - 1 , 0 ) ;\n BN_bntest_rand ( & b , BN_BITS2 , - 1 , 0 ) ;\n s = b . d [ 0 ] ;\n }\n while ( ! s ) ;\n BN_copy ( & b , & a ) ;\n r = BN_div_word ( & b , s ) ;\n if ( bp != NULL ) {\n if ( ! results ) {\n BN_print ( bp , & a ) ;\n BIO_puts ( bp , \" / \" ) ;\n print_word ( bp , s ) ;\n BIO_puts ( bp , \" - \" ) ;\n }\n BN_print ( bp , & b ) ;\n BIO_puts ( bp , \"\\n\" ) ;\n if ( ! results ) {\n BN_print ( bp , & a ) ;\n BIO_puts ( bp , \" % \" ) ;\n print_word ( bp , s ) ;\n BIO_puts ( bp , \" - \" ) ;\n }\n print_word ( bp , r ) ;\n BIO_puts ( bp , \"\\n\" ) ;\n }\n BN_mul_word ( & b , s ) ;\n BN_add_word ( & b , r ) ;\n BN_sub ( & b , & a , & b ) ;\n if ( ! BN_is_zero ( & b ) ) {\n fprintf ( stderr , \"Division (word) test failed!\\n\" ) ;\n return 0 ;\n }\n }\n BN_free ( & a ) ;\n BN_free ( & b ) ;\n return ( 1 ) ;\n }", "hash": -7553540414561818627, "project": "debian", "size": 47, "target": 0, "idx": 8367}
{"code": "int test_exp ( BIO * bp , BN_CTX * ctx ) {\n BIGNUM * a , * b , * d , * e , * one ;\n int i ;\n a = BN_new ( ) ;\n b = BN_new ( ) ;\n d = BN_new ( ) ;\n e = BN_new ( ) ;\n one = BN_new ( ) ;\n BN_one ( one ) ;\n for ( i = 0 ;\n i < num2 ;\n i ++ ) {\n BN_bntest_rand ( a , 20 + i * 5 , 0 , 0 ) ;\n BN_bntest_rand ( b , 2 + i , 0 , 0 ) ;\n if ( BN_exp ( d , a , b , ctx ) <= 0 ) return ( 0 ) ;\n if ( bp != NULL ) {\n if ( ! results ) {\n BN_print ( bp , a ) ;\n BIO_puts ( bp , \" ^ \" ) ;\n BN_print ( bp , b ) ;\n BIO_puts ( bp , \" - \" ) ;\n }\n BN_print ( bp , d ) ;\n BIO_puts ( bp , \"\\n\" ) ;\n }\n BN_one ( e ) ;\n for ( ;\n ! BN_is_zero ( b ) ;\n BN_sub ( b , b , one ) ) BN_mul ( e , e , a , ctx ) ;\n BN_sub ( e , e , d ) ;\n if ( ! BN_is_zero ( e ) ) {\n fprintf ( stderr , \"Exponentiation test failed!\\n\" ) ;\n return 0 ;\n }\n }\n BN_free ( a ) ;\n BN_free ( b ) ;\n BN_free ( d ) ;\n BN_free ( e ) ;\n BN_free ( one ) ;\n return ( 1 ) ;\n }", "hash": -7553540414561818627, "project": "debian", "size": 42, "target": 0, "idx": 8368}
{"code": "static int mainwindows_compare_reverse ( MAIN_WINDOW_REC * w1 , MAIN_WINDOW_REC * w2 ) {\n return w1 -> first_line < w2 -> first_line ? 1 : w1 -> first_line > w2 -> first_line ? - 1 : w1 -> first_column < w2 -> first_column ? 1 : w1 -> first_column > w2 -> first_column ? - 1 : 0 ;\n }", "hash": -2908211205972632000, "project": "debian", "size": 3, "target": 0, "idx": 8370}
{"code": "static void cmd_window_dright ( void ) {\n MAIN_WINDOW_REC * rec ;\n rec = mainwindows_find_right ( active_mainwin , FALSE ) ;\n if ( rec == NULL ) rec = mainwindows_find_right ( active_mainwin , TRUE ) ;\n if ( rec != NULL ) window_set_active ( rec -> active ) ;\n }", "hash": -2908211205972632000, "project": "debian", "size": 6, "target": 0, "idx": 8379}
{"code": "static MAIN_WINDOW_REC * mainwindows_find_right ( MAIN_WINDOW_REC * window , int find_first ) {\n int first_line , last_line , last_column ;\n MAIN_WINDOW_REC * best ;\n GSList * tmp ;\n if ( window != NULL ) {\n first_line = window -> first_line ;\n last_line = window -> last_line ;\n last_column = window -> last_column ;\n }\n else {\n first_line = last_line = last_column = - 1 ;\n }\n if ( find_first ) last_column = - 1 ;\n best = NULL ;\n for ( tmp = mainwindows ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n MAIN_WINDOW_REC * rec = tmp -> data ;\n if ( rec -> first_line >= first_line && rec -> last_line <= last_line && rec -> first_column > last_column && ( best == NULL || rec -> first_column < best -> first_column ) ) best = rec ;\n }\n return best ;\n }", "hash": -2908211205972632000, "project": "debian", "size": 22, "target": 0, "idx": 8386}
{"code": "static void cmd_window_ddown ( void ) {\n MAIN_WINDOW_REC * rec ;\n rec = mainwindows_find_lower ( active_mainwin ) ;\n if ( rec == NULL ) rec = mainwindows_find_lower ( NULL ) ;\n if ( rec != NULL ) window_set_active ( rec -> active ) ;\n }", "hash": -2908211205972632000, "project": "debian", "size": 6, "target": 0, "idx": 8407}
{"code": "void mainwindows_recreate ( void ) {\n GSList * tmp ;\n for ( tmp = mainwindows ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n MAIN_WINDOW_REC * rec = tmp -> data ;\n rec -> screen_win = mainwindow_create_screen ( rec ) ;\n rec -> dirty = TRUE ;\n textbuffer_view_set_window ( WINDOW_GUI ( rec -> active ) -> view , rec -> screen_win ) ;\n }\n }", "hash": -2908211205972632000, "project": "debian", "size": 11, "target": 0, "idx": 8416}
{"code": "static MAIN_WINDOW_REC * mainwindows_find_upper_left ( MAIN_WINDOW_REC * window ) {\n MAIN_WINDOW_REC * best ;\n best = mainwindows_find_left ( window , FALSE ) ;\n if ( best == NULL ) best = mainwindows_find_upper ( window ) ;\n return best ;\n }", "hash": -2908211205972632000, "project": "debian", "size": 6, "target": 0, "idx": 8417}
{"code": "void mainwindow_destroy_half ( MAIN_WINDOW_REC * window ) {\n int really_quitting = quitting ;\n quitting = TRUE ;\n mainwindow_destroy ( window ) ;\n quitting = really_quitting ;\n }", "hash": -2908211205972632000, "project": "debian", "size": 6, "target": 0, "idx": 8441}
{"code": "static void cmd_window_move_right ( void ) {\n int refnum ;\n refnum = window_refnum_right ( active_win -> refnum , TRUE ) ;\n if ( refnum != - 1 ) window_set_refnum ( active_win , refnum ) ;\n }", "hash": -2908211205972632000, "project": "debian", "size": 5, "target": 0, "idx": 8445}
{"code": "GSList * mainwindows_get_line ( MAIN_WINDOW_REC * rec ) {\n MAIN_WINDOW_REC * win ;\n GSList * list ;\n list = NULL ;\n for ( win = mainwindows_find_left ( rec , FALSE ) ;\n win != NULL ;\n win = mainwindows_find_left ( win , FALSE ) ) {\n list = g_slist_append ( list , win ) ;\n }\n if ( rec != NULL ) list = g_slist_append ( list , rec ) ;\n for ( win = mainwindows_find_right ( rec , FALSE ) ;\n win != NULL ;\n win = mainwindows_find_right ( win , FALSE ) ) {\n list = g_slist_append ( list , win ) ;\n }\n return list ;\n }", "hash": -2908211205972632000, "project": "debian", "size": 17, "target": 0, "idx": 8449}
{"code": "static diam_avp_t * build_appid_avp ( const avp_type_t * type , guint32 code , diam_vnd_t * vendor , const char * name , const value_string * vs _U_ , void * data _U_ ) {\n diam_avp_t * a ;\n field_display_e base ;\n a = ( diam_avp_t * ) wmem_alloc0 ( wmem_epan_scope ( ) , sizeof ( diam_avp_t ) ) ;\n a -> code = code ;\n a -> vendor = vendor ;\n a -> dissector_v16 = type -> v16 ;\n a -> dissector_rfc = type -> rfc ;\n a -> ett = - 1 ;\n a -> hf_value = - 1 ;\n if ( vs != NULL ) {\n report_failure ( \"Diameter Dictionary: AVP '%s' (of type AppId) has a list of values but the list won't be used\\n\" , name ) ;\n }\n base = ( field_display_e ) ( type -> base | BASE_EXT_STRING ) ;\n basic_avp_reginfo ( a , name , type -> ft , base , dictionary . applications ) ;\n return a ;\n }", "hash": -3502382902740740634, "project": "debian", "size": 17, "target": 0, "idx": 8485}
{"code": "static const char * float64_avp ( diam_ctx_t * c , diam_avp_t * a , tvbuff_t * tvb , diam_sub_dis_t * diam_sub_dis_inf _U_ ) {\n char * label = NULL ;\n proto_item * pi ;\n gint length = tvb_reported_length ( tvb ) ;\n if ( length == 8 ) {\n if ( c -> tree ) {\n pi = proto_tree_add_item ( c -> tree , a -> hf_value , tvb , 0 , length , ENC_BIG_ENDIAN ) ;\n label = ( char * ) wmem_alloc ( wmem_packet_scope ( ) , ITEM_LABEL_LENGTH + 1 ) ;\n proto_item_fill_label ( PITEM_FINFO ( pi ) , label ) ;\n label = strstr ( label , \": \" ) + 2 ;\n }\n }\n else {\n pi = proto_tree_add_bytes_format ( c -> tree , hf_diameter_avp_data_wrong_length , tvb , 0 , length , NULL , \"Error! Bad Float64 Length\" ) ;\n expert_add_info_format ( c -> pinfo , pi , & ei_diameter_avp_len , \"Bad Float64 Length (%u)\" , length ) ;\n PROTO_ITEM_SET_GENERATED ( pi ) ;\n }\n return label ;\n }", "hash": -3502382902740740634, "project": "debian", "size": 19, "target": 0, "idx": 8499}
{"code": "void proto_reg_handoff_diameter ( void ) {\n static gboolean Initialized = FALSE ;\n static range_t * diameter_tcp_port_range ;\n static range_t * diameter_sctp_port_range ;\n static range_t * diameter_udp_port_range ;\n if ( ! Initialized ) {\n diameter_sctp_handle = find_dissector ( \"diameter\" ) ;\n diameter_tcp_handle = new_create_dissector_handle ( dissect_diameter_tcp , proto_diameter ) ;\n diameter_udp_handle = new_create_dissector_handle ( dissect_diameter , proto_diameter ) ;\n data_handle = find_dissector ( \"data\" ) ;\n eap_handle = find_dissector ( \"eap\" ) ;\n dissector_add_uint ( \"sctp.ppi\" , DIAMETER_PROTOCOL_ID , diameter_sctp_handle ) ;\n dissector_add_uint ( \"diameter.base\" , 1 , new_create_dissector_handle ( dissect_diameter_user_name , proto_diameter ) ) ;\n dissector_add_uint ( \"diameter.base\" , 97 , new_create_dissector_handle ( dissect_diameter_base_framed_ipv6_prefix , proto_diameter ) ) ;\n dissector_add_uint ( \"diameter.base\" , 265 , new_create_dissector_handle ( dissect_diameter_vendor_id , proto_diameter ) ) ;\n dissector_add_uint ( \"diameter.base\" , 266 , new_create_dissector_handle ( dissect_diameter_vendor_id , proto_diameter ) ) ;\n dissector_add_uint ( \"diameter.base\" , 443 , new_create_dissector_handle ( dissect_diameter_subscription_id , proto_diameter ) ) ;\n dissector_add_uint ( \"diameter.base\" , 450 , new_create_dissector_handle ( dissect_diameter_subscription_id_type , proto_diameter ) ) ;\n dissector_add_uint ( \"diameter.base\" , 444 , new_create_dissector_handle ( dissect_diameter_subscription_id_data , proto_diameter ) ) ;\n dissector_add_uint ( \"diameter.base\" , 462 , new_create_dissector_handle ( dissect_diameter_eap_payload , proto_diameter ) ) ;\n dissector_add_uint ( \"diameter.base\" , 463 , new_create_dissector_handle ( dissect_diameter_eap_payload , proto_diameter ) ) ;\n dissector_add_uint ( \"diameter.vnd_exp_res\" , VENDOR_THE3GPP2 , new_create_dissector_handle ( dissect_diameter_3gpp2_exp_res , proto_diameter ) ) ;\n Initialized = TRUE ;\n }\n else {\n dissector_delete_uint_range ( \"tcp.port\" , diameter_tcp_port_range , diameter_tcp_handle ) ;\n dissector_delete_uint_range ( \"sctp.port\" , diameter_sctp_port_range , diameter_sctp_handle ) ;\n dissector_delete_uint_range ( \"udp.port\" , diameter_udp_port_range , diameter_udp_handle ) ;\n g_free ( diameter_tcp_port_range ) ;\n g_free ( diameter_sctp_port_range ) ;\n g_free ( diameter_udp_port_range ) ;\n }\n diameter_tcp_port_range = range_copy ( global_diameter_tcp_port_range ) ;\n diameter_sctp_port_range = range_copy ( global_diameter_sctp_port_range ) ;\n diameter_udp_port_range = range_copy ( global_diameter_udp_port_range ) ;\n dissector_add_uint_range ( \"tcp.port\" , diameter_tcp_port_range , diameter_tcp_handle ) ;\n dissector_add_uint_range ( \"sctp.port\" , diameter_sctp_port_range , diameter_sctp_handle ) ;\n dissector_add_uint_range ( \"udp.port\" , diameter_udp_port_range , diameter_udp_handle ) ;\n exported_pdu_tap = find_tap_id ( EXPORT_PDU_TAP_NAME_LAYER_7 ) ;\n }", "hash": -3502382902740740634, "project": "debian", "size": 40, "target": 0, "idx": 8506}
{"code": "static const char * float32_avp ( diam_ctx_t * c , diam_avp_t * a , tvbuff_t * tvb , diam_sub_dis_t * diam_sub_dis_inf _U_ ) {\n char * label = NULL ;\n proto_item * pi ;\n gint length = tvb_reported_length ( tvb ) ;\n if ( length == 4 ) {\n if ( c -> tree ) {\n pi = proto_tree_add_item ( c -> tree , a -> hf_value , tvb , 0 , length , ENC_BIG_ENDIAN ) ;\n label = ( char * ) wmem_alloc ( wmem_packet_scope ( ) , ITEM_LABEL_LENGTH + 1 ) ;\n proto_item_fill_label ( PITEM_FINFO ( pi ) , label ) ;\n label = strstr ( label , \": \" ) + 2 ;\n }\n }\n else {\n pi = proto_tree_add_bytes_format ( c -> tree , hf_diameter_avp_data_wrong_length , tvb , 0 , length , NULL , \"Error! Bad Float32 Length\" ) ;\n expert_add_info_format ( c -> pinfo , pi , & ei_diameter_avp_len , \"Bad Float32 Length (%u)\" , length ) ;\n PROTO_ITEM_SET_GENERATED ( pi ) ;\n }\n return label ;\n }", "hash": -3502382902740740634, "project": "debian", "size": 19, "target": 0, "idx": 8507}
{"code": "void vp9_read_frame_size ( struct vp9_read_bit_buffer * rb , int * width , int * height ) {\n const int w = vp9_rb_read_literal ( rb , 16 ) + 1 ;\n const int h = vp9_rb_read_literal ( rb , 16 ) + 1 ;\n * width = w ;\n * height = h ;\n }", "hash": 252275190935145023, "project": "debian", "size": 6, "target": 0, "idx": 8520}
{"code": "static struct vp9_read_bit_buffer * init_read_bit_buffer ( VP9Decoder * pbi , struct vp9_read_bit_buffer * rb , const uint8_t * data , const uint8_t * data_end , uint8_t * clear_data ) {\n rb -> bit_offset = 0 ;\n rb -> error_handler = error_handler ;\n rb -> error_handler_data = & pbi -> common ;\n if ( pbi -> decrypt_cb ) {\n const int n = ( int ) MIN ( MAX_VP9_HEADER_SIZE , data_end - data ) ;\n pbi -> decrypt_cb ( pbi -> decrypt_state , data , clear_data , n ) ;\n rb -> bit_buffer = clear_data ;\n rb -> bit_buffer_end = clear_data + n ;\n }\n else {\n rb -> bit_buffer = data ;\n rb -> bit_buffer_end = data_end ;\n }\n return rb ;\n }", "hash": 252275190935145023, "project": "debian", "size": 16, "target": 0, "idx": 8538}
{"code": "static void setup_token_decoder ( const uint8_t * data , const uint8_t * data_end , size_t read_size , struct vpx_internal_error_info * error_info , vp9_reader * r , vpx_decrypt_cb decrypt_cb , void * decrypt_state ) {\n if ( ! read_is_valid ( data , read_size , data_end ) ) vpx_internal_error ( error_info , VPX_CODEC_CORRUPT_FRAME , \"Truncated packet or corrupt tile length\" ) ;\n if ( vp9_reader_init ( r , data , read_size , decrypt_cb , decrypt_state ) ) vpx_internal_error ( error_info , VPX_CODEC_MEM_ERROR , \"Failed to allocate bool decoder %d\" , 1 ) ;\n }", "hash": 252275190935145023, "project": "debian", "size": 4, "target": 0, "idx": 8547}
{"code": "static void read_mv_probs ( nmv_context * ctx , int allow_hp , vp9_reader * r ) {\n int i , j ;\n update_mv_probs ( ctx -> joints , MV_JOINTS - 1 , r ) ;\n for ( i = 0 ;\n i < 2 ;\n ++ i ) {\n nmv_component * const comp_ctx = & ctx -> comps [ i ] ;\n update_mv_probs ( & comp_ctx -> sign , 1 , r ) ;\n update_mv_probs ( comp_ctx -> classes , MV_CLASSES - 1 , r ) ;\n update_mv_probs ( comp_ctx -> class0 , CLASS0_SIZE - 1 , r ) ;\n update_mv_probs ( comp_ctx -> bits , MV_OFFSET_BITS , r ) ;\n }\n for ( i = 0 ;\n i < 2 ;\n ++ i ) {\n nmv_component * const comp_ctx = & ctx -> comps [ i ] ;\n for ( j = 0 ;\n j < CLASS0_SIZE ;\n ++ j ) update_mv_probs ( comp_ctx -> class0_fp [ j ] , MV_FP_SIZE - 1 , r ) ;\n update_mv_probs ( comp_ctx -> fp , 3 , r ) ;\n }\n if ( allow_hp ) {\n for ( i = 0 ;\n i < 2 ;\n ++ i ) {\n nmv_component * const comp_ctx = & ctx -> comps [ i ] ;\n update_mv_probs ( & comp_ctx -> class0_hp , 1 , r ) ;\n update_mv_probs ( & comp_ctx -> hp , 1 , r ) ;\n }\n }\n }", "hash": 252275190935145023, "project": "debian", "size": 31, "target": 0, "idx": 8550}
{"code": "static void setup_frame_size_with_refs ( VP9_COMMON * cm , struct vp9_read_bit_buffer * rb ) {\n int width , height ;\n int found = 0 , i ;\n for ( i = 0 ;\n i < REFS_PER_FRAME ;\n ++ i ) {\n if ( vp9_rb_read_bit ( rb ) ) {\n YV12_BUFFER_CONFIG * const buf = cm -> frame_refs [ i ] . buf ;\n width = buf -> y_crop_width ;\n height = buf -> y_crop_height ;\n found = 1 ;\n break ;\n }\n }\n if ( ! found ) vp9_read_frame_size ( rb , & width , & height ) ;\n for ( i = 0 ;\n i < REFS_PER_FRAME ;\n ++ i ) {\n RefBuffer * const ref_frame = & cm -> frame_refs [ i ] ;\n const int ref_width = ref_frame -> buf -> y_width ;\n const int ref_height = ref_frame -> buf -> y_height ;\n if ( ! valid_ref_frame_size ( ref_width , ref_height , width , height ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , \"Referenced frame has invalid size\" ) ;\n }\n apply_frame_size ( cm , width , height ) ;\n setup_display_size ( cm , rb ) ;\n }", "hash": 252275190935145023, "project": "debian", "size": 26, "target": 0, "idx": 8556}
{"code": "static PARTITION_TYPE read_partition ( VP9_COMMON * cm , MACROBLOCKD * xd , int hbs , int mi_row , int mi_col , BLOCK_SIZE bsize , vp9_reader * r ) {\n const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;\n const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ;\n const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ;\n const int has_cols = ( mi_col + hbs ) < cm -> mi_cols ;\n PARTITION_TYPE p ;\n if ( has_rows && has_cols ) p = ( PARTITION_TYPE ) vp9_read_tree ( r , vp9_partition_tree , probs ) ;\n else if ( ! has_rows && has_cols ) p = vp9_read ( r , probs [ 1 ] ) ? PARTITION_SPLIT : PARTITION_HORZ ;\n else if ( has_rows && ! has_cols ) p = vp9_read ( r , probs [ 2 ] ) ? PARTITION_SPLIT : PARTITION_VERT ;\n else p = PARTITION_SPLIT ;\n if ( ! cm -> frame_parallel_decoding_mode ) ++ cm -> counts . partition [ ctx ] [ p ] ;\n return p ;\n }", "hash": 252275190935145023, "project": "debian", "size": 13, "target": 0, "idx": 8562}
{"code": "static void setup_frame_size ( VP9_COMMON * cm , struct vp9_read_bit_buffer * rb ) {\n int width , height ;\n vp9_read_frame_size ( rb , & width , & height ) ;\n apply_frame_size ( cm , width , height ) ;\n setup_display_size ( cm , rb ) ;\n }", "hash": 252275190935145023, "project": "debian", "size": 6, "target": 0, "idx": 8563}
{"code": "static int read_delta_q ( struct vp9_read_bit_buffer * rb , int * delta_q ) {\n const int old = * delta_q ;\n * delta_q = vp9_rb_read_bit ( rb ) ? vp9_rb_read_signed_literal ( rb , 4 ) : 0 ;\n return old != * delta_q ;\n }", "hash": 252275190935145023, "project": "debian", "size": 5, "target": 0, "idx": 8565}
{"code": "static Asn1Generic * DecodeAsn1DerT61String ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {\n Asn1Generic * a ;\n a = DecodeAsn1DerIA5String ( buffer , max_size , depth , errcode ) ;\n if ( a != NULL ) a -> type = ASN1_T61STRING ;\n return a ;\n }", "hash": 2917602761308156638, "project": "debian", "size": 6, "target": 0, "idx": 8613}
{"code": "static Asn1Generic * DecodeAsn1DerSequence ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {\n const unsigned char * d_ptr = buffer ;\n uint32_t d_length , parsed_bytes , numbytes , el_max_size ;\n uint8_t c ;\n uint32_t seq_index ;\n Asn1Generic * node ;\n d_ptr ++ ;\n node = Asn1GenericNew ( ) ;\n if ( node == NULL ) return NULL ;\n node -> type = ASN1_SEQUENCE ;\n c = d_ptr [ 0 ] ;\n if ( ( c & ( 1 << 7 ) ) >> 7 == 0 ) {\n d_length = c ;\n d_ptr ++ ;\n }\n else {\n numbytes = c & 0x7f ;\n d_ptr ++ ;\n if ( DecodeAsn1BuildValue ( & d_ptr , & d_length , numbytes , errcode ) == - 1 ) {\n SCFree ( node ) ;\n return NULL ;\n }\n }\n node -> length = d_length + ( d_ptr - buffer ) ;\n if ( node -> length > max_size || node -> length < d_length ) {\n if ( errcode ) * errcode = ERR_DER_ELEMENT_SIZE_TOO_BIG ;\n SCFree ( node ) ;\n return NULL ;\n }\n parsed_bytes = 0 ;\n seq_index = 0 ;\n while ( parsed_bytes < d_length ) {\n el_max_size = max_size - ( d_ptr - buffer ) ;\n Asn1Generic * child = DecodeAsn1DerGeneric ( d_ptr , el_max_size , depth , seq_index , errcode ) ;\n if ( child == NULL ) {\n if ( errcode && * errcode != 0 ) {\n DerFree ( node ) ;\n return NULL ;\n }\n break ;\n }\n int ret = Asn1SequenceAppend ( node , child ) ;\n if ( ret == - 1 ) {\n DerFree ( child ) ;\n break ;\n }\n parsed_bytes += child -> length ;\n d_ptr += child -> length ;\n seq_index ++ ;\n }\n return ( Asn1Generic * ) node ;\n }", "hash": 2917602761308156638, "project": "debian", "size": 52, "target": 0, "idx": 8621}
{"code": "void PNGAPI png_set_keep_unknown_chunks ( png_structp png_ptr , int keep , png_bytep chunk_list , int num_chunks ) {\n png_bytep new_list , p ;\n int i , old_num_chunks ;\n if ( png_ptr == NULL ) return ;\n if ( num_chunks == 0 ) {\n if ( keep == PNG_HANDLE_CHUNK_ALWAYS || keep == PNG_HANDLE_CHUNK_IF_SAFE ) png_ptr -> flags |= PNG_FLAG_KEEP_UNKNOWN_CHUNKS ;\n else png_ptr -> flags &= ~ PNG_FLAG_KEEP_UNKNOWN_CHUNKS ;\n if ( keep == PNG_HANDLE_CHUNK_ALWAYS ) png_ptr -> flags |= PNG_FLAG_KEEP_UNSAFE_CHUNKS ;\n else png_ptr -> flags &= ~ PNG_FLAG_KEEP_UNSAFE_CHUNKS ;\n return ;\n }\n if ( chunk_list == NULL ) return ;\n old_num_chunks = png_ptr -> num_chunk_list ;\n new_list = ( png_bytep ) png_malloc ( png_ptr , ( png_uint_32 ) ( 5 * ( num_chunks + old_num_chunks ) ) ) ;\n if ( png_ptr -> chunk_list != NULL ) {\n png_memcpy ( new_list , png_ptr -> chunk_list , ( png_size_t ) ( 5 * old_num_chunks ) ) ;\n png_free ( png_ptr , png_ptr -> chunk_list ) ;\n png_ptr -> chunk_list = NULL ;\n }\n png_memcpy ( new_list + 5 * old_num_chunks , chunk_list , ( png_size_t ) ( 5 * num_chunks ) ) ;\n for ( p = new_list + 5 * old_num_chunks + 4 , i = 0 ;\n i < num_chunks ;\n i ++ , p += 5 ) * p = ( png_byte ) keep ;\n png_ptr -> num_chunk_list = old_num_chunks + num_chunks ;\n png_ptr -> chunk_list = new_list ;\n # ifdef PNG_FREE_ME_SUPPORTED png_ptr -> free_me |= PNG_FREE_LIST ;\n # endif }", "hash": -704025756752474526, "project": "debian", "size": 27, "target": 0, "idx": 8636}
{"code": "void PNGAPI png_set_sPLT ( png_structp png_ptr , png_infop info_ptr , png_sPLT_tp entries , int nentries ) {\n png_sPLT_tp np ;\n int i ;\n if ( png_ptr == NULL || info_ptr == NULL ) return ;\n np = ( png_sPLT_tp ) png_malloc_warn ( png_ptr , ( info_ptr -> splt_palettes_num + nentries ) * ( png_uint_32 ) png_sizeof ( png_sPLT_t ) ) ;\n if ( np == NULL ) {\n png_warning ( png_ptr , \"No memory for sPLT palettes.\" ) ;\n return ;\n }\n png_memcpy ( np , info_ptr -> splt_palettes , info_ptr -> splt_palettes_num * png_sizeof ( png_sPLT_t ) ) ;\n png_free ( png_ptr , info_ptr -> splt_palettes ) ;\n info_ptr -> splt_palettes = NULL ;\n for ( i = 0 ;\n i < nentries ;\n i ++ ) {\n png_sPLT_tp to = np + info_ptr -> splt_palettes_num + i ;\n png_sPLT_tp from = entries + i ;\n png_uint_32 length ;\n length = png_strlen ( from -> name ) + 1 ;\n to -> name = ( png_charp ) png_malloc_warn ( png_ptr , length ) ;\n if ( to -> name == NULL ) {\n png_warning ( png_ptr , \"Out of memory while processing sPLT chunk\" ) ;\n continue ;\n }\n png_memcpy ( to -> name , from -> name , length ) ;\n to -> entries = ( png_sPLT_entryp ) png_malloc_warn ( png_ptr , ( png_uint_32 ) ( from -> nentries * png_sizeof ( png_sPLT_entry ) ) ) ;\n if ( to -> entries == NULL ) {\n png_warning ( png_ptr , \"Out of memory while processing sPLT chunk\" ) ;\n png_free ( png_ptr , to -> name ) ;\n to -> name = NULL ;\n continue ;\n }\n png_memcpy ( to -> entries , from -> entries , from -> nentries * png_sizeof ( png_sPLT_entry ) ) ;\n to -> nentries = from -> nentries ;\n to -> depth = from -> depth ;\n }\n info_ptr -> splt_palettes = np ;\n info_ptr -> splt_palettes_num += nentries ;\n info_ptr -> valid |= PNG_INFO_sPLT ;\n # ifdef PNG_FREE_ME_SUPPORTED info_ptr -> free_me |= PNG_FREE_SPLT ;\n # endif }", "hash": -704025756752474526, "project": "debian", "size": 41, "target": 0, "idx": 8638}
{"code": "static void help ( ) {\n extern char * __progname ;\n fprintf ( stderr , \"iodine IP over DNS tunneling server\\n\" ) ;\n fprintf ( stderr , \"Usage: %s [-v] [-h] [-c] [-s] [-f] [-D] [-u user] \" \"[-t chrootdir] [-d device] [-m mtu] [-z context] \" \"[-l ip address to listen on] [-p port] [-n external ip] [-b dnsport] [-P password] \" \"[-F pidfile] tunnel_ip[etmask] topdomain\\n\" , __progname ) ;\n fprintf ( stderr , \" -v to print version info and exit\\n\" ) ;\n fprintf ( stderr , \" -h to print this help and exit\\n\" ) ;\n fprintf ( stderr , \" -c to disable check of client IP/port on each request\\n\" ) ;\n fprintf ( stderr , \" -s to skip creating and configuring the tun device, \" \"which then has to be created manually\\n\" ) ;\n fprintf ( stderr , \" -f to keep running in foreground\\n\" ) ;\n fprintf ( stderr , \" -D to increase debug level\\n\" ) ;\n fprintf ( stderr , \" (using -DD in UTF-8 terminal: \\\"LC_ALL=C luit iodined -DD ...\\\")\\n\" ) ;\n fprintf ( stderr , \" -u name to drop privileges and run as user 'name'\\n\" ) ;\n fprintf ( stderr , \" -t dir to chroot to directory dir\\n\" ) ;\n fprintf ( stderr , \" -d device to set tunnel device name\\n\" ) ;\n fprintf ( stderr , \" -m mtu to set tunnel device mtu\\n\" ) ;\n fprintf ( stderr , \" -z context to apply SELinux context after initialization\\n\" ) ;\n fprintf ( stderr , \" -l ip address to listen on for incoming dns traffic \" \"(default 0.0.0.0)\\n\" ) ;\n fprintf ( stderr , \" -p port to listen on for incoming dns traffic (default 53)\\n\" ) ;\n fprintf ( stderr , \" -n ip to respond with to NS queries\\n\" ) ;\n fprintf ( stderr , \" -b port to forward normal DNS queries to (on localhost)\\n\" ) ;\n fprintf ( stderr , \" -P password used for authentication (max 32 chars will be used)\\n\" ) ;\n fprintf ( stderr , \" -F pidfile to write pid to a file\\n\" ) ;\n fprintf ( stderr , \" -i maximum idle time before shutting down\\n\" ) ;\n fprintf ( stderr , \"tunnel_ip is the IP number of the local tunnel interface.\\n\" ) ;\n fprintf ( stderr , \" etmask sets the size of the tunnel network.\\n\" ) ;\n fprintf ( stderr , \"topdomain is the FQDN that is delegated to this server.\\n\" ) ;\n exit ( 0 ) ;\n }", "hash": 3246343243711264189, "project": "debian", "size": 28, "target": 0, "idx": 8688}
{"code": "static void search_stack_free ( void * key , void * data ) {\n ber_memfree_x ( data , NULL ) ;\n }", "hash": 7295169435648525618, "project": "debian", "size": 3, "target": 0, "idx": 8700}
{"code": "static int selinux_file_send_sigiotask ( struct task_struct * tsk , struct fown_struct * fown , int signum ) {\n struct file * file ;\n u32 sid = task_sid ( tsk ) ;\n u32 perm ;\n struct file_security_struct * fsec ;\n file = container_of ( fown , struct file , f_owner ) ;\n fsec = file -> f_security ;\n if ( ! signum ) perm = signal_to_av ( SIGIO ) ;\n else perm = signal_to_av ( signum ) ;\n return avc_has_perm ( fsec -> fown_sid , sid , SECCLASS_PROCESS , perm , NULL ) ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 11, "target": 0, "idx": 8713}
{"code": "static int selinux_vm_enough_memory ( struct mm_struct * mm , long pages ) {\n int rc , cap_sys_admin = 0 ;\n rc = cred_has_capability ( current_cred ( ) , CAP_SYS_ADMIN , SECURITY_CAP_NOAUDIT , true ) ;\n if ( rc == 0 ) cap_sys_admin = 1 ;\n return cap_sys_admin ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 6, "target": 0, "idx": 8714}
{"code": "static int ipc_has_perm ( struct kern_ipc_perm * ipc_perms , u32 perms ) {\n struct ipc_security_struct * isec ;\n struct common_audit_data ad ;\n u32 sid = current_sid ( ) ;\n isec = ipc_perms -> security ;\n ad . type = LSM_AUDIT_DATA_IPC ;\n ad . u . ipc_id = ipc_perms -> key ;\n return avc_has_perm ( sid , isec -> sid , isec -> sclass , perms , & ad ) ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 9, "target": 0, "idx": 8724}
{"code": "static inline u32 task_sid ( const struct task_struct * task ) {\n u32 sid ;\n rcu_read_lock ( ) ;\n sid = cred_sid ( __task_cred ( task ) ) ;\n rcu_read_unlock ( ) ;\n return sid ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 7, "target": 0, "idx": 8734}
{"code": "static int selinux_inode_follow_link ( struct dentry * dentry , struct inode * inode , bool rcu ) {\n const struct cred * cred = current_cred ( ) ;\n struct common_audit_data ad ;\n struct inode_security_struct * isec ;\n u32 sid ;\n validate_creds ( cred ) ;\n ad . type = LSM_AUDIT_DATA_DENTRY ;\n ad . u . dentry = dentry ;\n sid = cred_sid ( cred ) ;\n isec = inode_security_rcu ( inode , rcu ) ;\n if ( IS_ERR ( isec ) ) return PTR_ERR ( isec ) ;\n return avc_has_perm_flags ( sid , isec -> sid , isec -> sclass , FILE__READ , & ad , rcu ? MAY_NOT_BLOCK : 0 ) ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 13, "target": 0, "idx": 8741}
{"code": "static int sb_finish_set_opts ( struct super_block * sb ) {\n struct superblock_security_struct * sbsec = sb -> s_security ;\n struct dentry * root = sb -> s_root ;\n struct inode * root_inode = d_backing_inode ( root ) ;\n int rc = 0 ;\n if ( sbsec -> behavior == SECURITY_FS_USE_XATTR ) {\n if ( ! ( root_inode -> i_opflags & IOP_XATTR ) ) {\n printk ( KERN_WARNING \"SELinux: (dev %s, type %s) has no \" \"xattr support\\n\" , sb -> s_id , sb -> s_type -> name ) ;\n rc = - EOPNOTSUPP ;\n goto out ;\n }\n rc = __vfs_getxattr ( root , root_inode , XATTR_NAME_SELINUX , NULL , 0 ) ;\n if ( rc < 0 && rc != - ENODATA ) {\n if ( rc == - EOPNOTSUPP ) printk ( KERN_WARNING \"SELinux: (dev %s, type \" \"%s) has no security xattr handler\\n\" , sb -> s_id , sb -> s_type -> name ) ;\n else printk ( KERN_WARNING \"SELinux: (dev %s, type \" \"%s) getxattr errno %d\\n\" , sb -> s_id , sb -> s_type -> name , - rc ) ;\n goto out ;\n }\n }\n if ( sbsec -> behavior > ARRAY_SIZE ( labeling_behaviors ) ) printk ( KERN_ERR \"SELinux: initialized (dev %s, type %s), unknown behavior\\n\" , sb -> s_id , sb -> s_type -> name ) ;\n sbsec -> flags |= SE_SBINITIALIZED ;\n if ( selinux_is_sblabel_mnt ( sb ) ) sbsec -> flags |= SBLABEL_MNT ;\n rc = inode_doinit_with_dentry ( root_inode , root ) ;\n spin_lock ( & sbsec -> isec_lock ) ;\n next_inode : if ( ! list_empty ( & sbsec -> isec_head ) ) {\n struct inode_security_struct * isec = list_entry ( sbsec -> isec_head . next , struct inode_security_struct , list ) ;\n struct inode * inode = isec -> inode ;\n list_del_init ( & isec -> list ) ;\n spin_unlock ( & sbsec -> isec_lock ) ;\n inode = igrab ( inode ) ;\n if ( inode ) {\n if ( ! IS_PRIVATE ( inode ) ) inode_doinit ( inode ) ;\n iput ( inode ) ;\n }\n spin_lock ( & sbsec -> isec_lock ) ;\n goto next_inode ;\n }\n spin_unlock ( & sbsec -> isec_lock ) ;\n out : return rc ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 39, "target": 0, "idx": 8765}
{"code": "static int may_create ( struct inode * dir , struct dentry * dentry , u16 tclass ) {\n const struct task_security_struct * tsec = current_security ( ) ;\n struct inode_security_struct * dsec ;\n struct superblock_security_struct * sbsec ;\n u32 sid , newsid ;\n struct common_audit_data ad ;\n int rc ;\n dsec = inode_security ( dir ) ;\n sbsec = dir -> i_sb -> s_security ;\n sid = tsec -> sid ;\n ad . type = LSM_AUDIT_DATA_DENTRY ;\n ad . u . dentry = dentry ;\n rc = avc_has_perm ( sid , dsec -> sid , SECCLASS_DIR , DIR__ADD_NAME | DIR__SEARCH , & ad ) ;\n if ( rc ) return rc ;\n rc = selinux_determine_inode_label ( current_security ( ) , dir , & dentry -> d_name , tclass , & newsid ) ;\n if ( rc ) return rc ;\n rc = avc_has_perm ( sid , newsid , tclass , FILE__CREATE , & ad ) ;\n if ( rc ) return rc ;\n return avc_has_perm ( newsid , sbsec -> sid , SECCLASS_FILESYSTEM , FILESYSTEM__ASSOCIATE , & ad ) ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 20, "target": 0, "idx": 8782}
{"code": "static inline u32 signal_to_av ( int sig ) {\n u32 perm = 0 ;\n switch ( sig ) {\n case SIGCHLD : perm = PROCESS__SIGCHLD ;\n break ;\n case SIGKILL : perm = PROCESS__SIGKILL ;\n break ;\n case SIGSTOP : perm = PROCESS__SIGSTOP ;\n break ;\n default : perm = PROCESS__SIGNAL ;\n break ;\n }\n return perm ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 14, "target": 0, "idx": 8793}
{"code": "static int selinux_inode_listsecurity ( struct inode * inode , char * buffer , size_t buffer_size ) {\n const int len = sizeof ( XATTR_NAME_SELINUX ) ;\n if ( buffer && len <= buffer_size ) memcpy ( buffer , XATTR_NAME_SELINUX , len ) ;\n return len ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 5, "target": 0, "idx": 8818}
{"code": "static int selinux_inode_readlink ( struct dentry * dentry ) {\n const struct cred * cred = current_cred ( ) ;\n return dentry_has_perm ( cred , dentry , FILE__READ ) ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 4, "target": 0, "idx": 8830}
{"code": "static int selinux_nlmsg_perm ( struct sock * sk , struct sk_buff * skb ) {\n int err = 0 ;\n u32 perm ;\n struct nlmsghdr * nlh ;\n struct sk_security_struct * sksec = sk -> sk_security ;\n if ( skb -> len < NLMSG_HDRLEN ) {\n err = - EINVAL ;\n goto out ;\n }\n nlh = nlmsg_hdr ( skb ) ;\n err = selinux_nlmsg_lookup ( sksec -> sclass , nlh -> nlmsg_type , & perm ) ;\n if ( err ) {\n if ( err == - EINVAL ) {\n pr_warn_ratelimited ( \"SELinux: unrecognized netlink\" \" message: protocol=%hu nlmsg_type=%hu sclass=%s\" \" pig=%d comm=%s\\n\" , sk -> sk_protocol , nlh -> nlmsg_type , secclass_map [ sksec -> sclass - 1 ] . name , task_pid_nr ( current ) , current -> comm ) ;\n if ( ! selinux_enforcing || security_get_allow_unknown ( ) ) err = 0 ;\n }\n if ( err == - ENOENT ) err = 0 ;\n goto out ;\n }\n err = sock_has_perm ( current , sk , perm ) ;\n out : return err ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 22, "target": 0, "idx": 8839}
{"code": "static int selinux_task_setnice ( struct task_struct * p , int nice ) {\n return current_has_perm ( p , PROCESS__SETSCHED ) ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 3, "target": 0, "idx": 8847}
{"code": "static int socket_sockcreate_sid ( const struct task_security_struct * tsec , u16 secclass , u32 * socksid ) {\n if ( tsec -> sockcreate_sid > SECSID_NULL ) {\n * socksid = tsec -> sockcreate_sid ;\n return 0 ;\n }\n return security_transition_sid ( tsec -> sid , tsec -> sid , secclass , NULL , socksid ) ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 7, "target": 0, "idx": 8853}
{"code": "static inline void flush_unauthorized_files ( const struct cred * cred , struct files_struct * files ) {\n struct file * file , * devnull = NULL ;\n struct tty_struct * tty ;\n int drop_tty = 0 ;\n unsigned n ;\n tty = get_current_tty ( ) ;\n if ( tty ) {\n spin_lock ( & tty -> files_lock ) ;\n if ( ! list_empty ( & tty -> tty_files ) ) {\n struct tty_file_private * file_priv ;\n file_priv = list_first_entry ( & tty -> tty_files , struct tty_file_private , list ) ;\n file = file_priv -> file ;\n if ( file_path_has_perm ( cred , file , FILE__READ | FILE__WRITE ) ) drop_tty = 1 ;\n }\n spin_unlock ( & tty -> files_lock ) ;\n tty_kref_put ( tty ) ;\n }\n if ( drop_tty ) no_tty ( ) ;\n n = iterate_fd ( files , 0 , match_file , cred ) ;\n if ( ! n ) return ;\n devnull = dentry_open ( & selinux_null , O_RDWR , cred ) ;\n if ( IS_ERR ( devnull ) ) devnull = NULL ;\n do {\n replace_fd ( n - 1 , devnull , 0 ) ;\n }\n while ( ( n = iterate_fd ( files , n , match_file , cred ) ) != 0 ) ;\n if ( devnull ) fput ( devnull ) ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 28, "target": 0, "idx": 8903}
{"code": "static int selinux_set_mnt_opts ( struct super_block * sb , struct security_mnt_opts * opts , unsigned long kern_flags , unsigned long * set_kern_flags ) {\n const struct cred * cred = current_cred ( ) ;\n int rc = 0 , i ;\n struct superblock_security_struct * sbsec = sb -> s_security ;\n const char * name = sb -> s_type -> name ;\n struct dentry * root = sbsec -> sb -> s_root ;\n struct inode_security_struct * root_isec ;\n u32 fscontext_sid = 0 , context_sid = 0 , rootcontext_sid = 0 ;\n u32 defcontext_sid = 0 ;\n char * * mount_options = opts -> mnt_opts ;\n int * flags = opts -> mnt_opts_flags ;\n int num_opts = opts -> num_mnt_opts ;\n mutex_lock ( & sbsec -> lock ) ;\n if ( ! ss_initialized ) {\n if ( ! num_opts ) {\n goto out ;\n }\n rc = - EINVAL ;\n printk ( KERN_WARNING \"SELinux: Unable to set superblock options \" \"before the security server is initialized\\n\" ) ;\n goto out ;\n }\n if ( kern_flags && ! set_kern_flags ) {\n rc = - EINVAL ;\n goto out ;\n }\n if ( ( sbsec -> flags & SE_SBINITIALIZED ) && ( sb -> s_type -> fs_flags & FS_BINARY_MOUNTDATA ) && ( num_opts == 0 ) ) goto out ;\n root_isec = backing_inode_security_novalidate ( root ) ;\n for ( i = 0 ;\n i < num_opts ;\n i ++ ) {\n u32 sid ;\n if ( flags [ i ] == SBLABEL_MNT ) continue ;\n rc = security_context_str_to_sid ( mount_options [ i ] , & sid , GFP_KERNEL ) ;\n if ( rc ) {\n printk ( KERN_WARNING \"SELinux: security_context_str_to_sid\" \"(%s) failed for (dev %s, type %s) errno=%d\\n\" , mount_options [ i ] , sb -> s_id , name , rc ) ;\n goto out ;\n }\n switch ( flags [ i ] ) {\n case FSCONTEXT_MNT : fscontext_sid = sid ;\n if ( bad_option ( sbsec , FSCONTEXT_MNT , sbsec -> sid , fscontext_sid ) ) goto out_double_mount ;\n sbsec -> flags |= FSCONTEXT_MNT ;\n break ;\n case CONTEXT_MNT : context_sid = sid ;\n if ( bad_option ( sbsec , CONTEXT_MNT , sbsec -> mntpoint_sid , context_sid ) ) goto out_double_mount ;\n sbsec -> flags |= CONTEXT_MNT ;\n break ;\n case ROOTCONTEXT_MNT : rootcontext_sid = sid ;\n if ( bad_option ( sbsec , ROOTCONTEXT_MNT , root_isec -> sid , rootcontext_sid ) ) goto out_double_mount ;\n sbsec -> flags |= ROOTCONTEXT_MNT ;\n break ;\n case DEFCONTEXT_MNT : defcontext_sid = sid ;\n if ( bad_option ( sbsec , DEFCONTEXT_MNT , sbsec -> def_sid , defcontext_sid ) ) goto out_double_mount ;\n sbsec -> flags |= DEFCONTEXT_MNT ;\n break ;\n default : rc = - EINVAL ;\n goto out ;\n }\n }\n if ( sbsec -> flags & SE_SBINITIALIZED ) {\n if ( ( sbsec -> flags & SE_MNTMASK ) && ! num_opts ) goto out_double_mount ;\n rc = 0 ;\n goto out ;\n }\n if ( strcmp ( sb -> s_type -> name , \"proc\" ) == 0 ) sbsec -> flags |= SE_SBPROC | SE_SBGENFS ;\n if ( ! strcmp ( sb -> s_type -> name , \"debugfs\" ) || ! strcmp ( sb -> s_type -> name , \"sysfs\" ) || ! strcmp ( sb -> s_type -> name , \"pstore\" ) ) sbsec -> flags |= SE_SBGENFS ;\n if ( ! sbsec -> behavior ) {\n rc = security_fs_use ( sb ) ;\n if ( rc ) {\n printk ( KERN_WARNING \"%s: security_fs_use(%s) returned %d\\n\" , __func__ , sb -> s_type -> name , rc ) ;\n goto out ;\n }\n }\n if ( sb -> s_user_ns != & init_user_ns ) {\n if ( context_sid || fscontext_sid || rootcontext_sid || defcontext_sid ) {\n rc = - EACCES ;\n goto out ;\n }\n if ( sbsec -> behavior == SECURITY_FS_USE_XATTR ) {\n sbsec -> behavior = SECURITY_FS_USE_MNTPOINT ;\n rc = security_transition_sid ( current_sid ( ) , current_sid ( ) , SECCLASS_FILE , NULL , & sbsec -> mntpoint_sid ) ;\n if ( rc ) goto out ;\n }\n goto out_set_opts ;\n }\n if ( fscontext_sid ) {\n rc = may_context_mount_sb_relabel ( fscontext_sid , sbsec , cred ) ;\n if ( rc ) goto out ;\n sbsec -> sid = fscontext_sid ;\n }\n if ( kern_flags & SECURITY_LSM_NATIVE_LABELS && ! context_sid ) {\n sbsec -> behavior = SECURITY_FS_USE_NATIVE ;\n * set_kern_flags |= SECURITY_LSM_NATIVE_LABELS ;\n }\n if ( context_sid ) {\n if ( ! fscontext_sid ) {\n rc = may_context_mount_sb_relabel ( context_sid , sbsec , cred ) ;\n if ( rc ) goto out ;\n sbsec -> sid = context_sid ;\n }\n else {\n rc = may_context_mount_inode_relabel ( context_sid , sbsec , cred ) ;\n if ( rc ) goto out ;\n }\n if ( ! rootcontext_sid ) rootcontext_sid = context_sid ;\n sbsec -> mntpoint_sid = context_sid ;\n sbsec -> behavior = SECURITY_FS_USE_MNTPOINT ;\n }\n if ( rootcontext_sid ) {\n rc = may_context_mount_inode_relabel ( rootcontext_sid , sbsec , cred ) ;\n if ( rc ) goto out ;\n root_isec -> sid = rootcontext_sid ;\n root_isec -> initialized = LABEL_INITIALIZED ;\n }\n if ( defcontext_sid ) {\n if ( sbsec -> behavior != SECURITY_FS_USE_XATTR && sbsec -> behavior != SECURITY_FS_USE_NATIVE ) {\n rc = - EINVAL ;\n printk ( KERN_WARNING \"SELinux: defcontext option is \" \"invalid for this filesystem type\\n\" ) ;\n goto out ;\n }\n if ( defcontext_sid != sbsec -> def_sid ) {\n rc = may_context_mount_inode_relabel ( defcontext_sid , sbsec , cred ) ;\n if ( rc ) goto out ;\n }\n sbsec -> def_sid = defcontext_sid ;\n }\n out_set_opts : rc = sb_finish_set_opts ( sb ) ;\n out : mutex_unlock ( & sbsec -> lock ) ;\n return rc ;\n out_double_mount : rc = - EINVAL ;\n printk ( KERN_WARNING \"SELinux: mount invalid. Same superblock, different \" \"security settings for (dev %s, type %s)\\n\" , sb -> s_id , name ) ;\n goto out ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 132, "target": 0, "idx": 8938}
{"code": "static void selinux_msg_msg_free_security ( struct msg_msg * msg ) {\n msg_msg_free_security ( msg ) ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 3, "target": 0, "idx": 8946}
{"code": "static int selinux_ptrace_traceme ( struct task_struct * parent ) {\n return task_has_perm ( parent , current , PROCESS__PTRACE ) ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 3, "target": 0, "idx": 8951}
{"code": "static int may_context_mount_sb_relabel ( u32 sid , struct superblock_security_struct * sbsec , const struct cred * cred ) {\n const struct task_security_struct * tsec = cred -> security ;\n int rc ;\n rc = avc_has_perm ( tsec -> sid , sbsec -> sid , SECCLASS_FILESYSTEM , FILESYSTEM__RELABELFROM , NULL ) ;\n if ( rc ) return rc ;\n rc = avc_has_perm ( tsec -> sid , sid , SECCLASS_FILESYSTEM , FILESYSTEM__RELABELTO , NULL ) ;\n return rc ;\n }", "hash": 4180964683905830761, "project": "debian", "size": 8, "target": 0, "idx": 8959}
{"code": "static int leap_file ( FILE * fp ) {\n char buf [ NTP_MAXSTRLEN ] ;\n u_long leap ;\n u_long expire ;\n int offset ;\n int i ;\n offset = 0 ;\n leap = 0 ;\n expire = 0 ;\n i = 10 ;\n while ( fgets ( buf , NTP_MAXSTRLEN - 1 , fp ) != NULL ) {\n if ( strlen ( buf ) < 1 ) continue ;\n if ( buf [ 0 ] == '#' ) {\n if ( strlen ( buf ) < 3 ) continue ;\n if ( buf [ 1 ] == '@' || buf [ 1 ] == '$' ) {\n if ( sscanf ( & buf [ 2 ] , \"%lu\" , & expire ) != 1 ) return ( - 1 ) ;\n continue ;\n }\n }\n if ( sscanf ( buf , \"%lu %d\" , & leap , & offset ) == 2 ) {\n if ( i ++ != offset ) return ( - 1 ) ;\n }\n }\n if ( i == 10 ) return ( - 1 ) ;\n leap_tai = offset ;\n leap_sec = leap ;\n leap_expire = expire ;\n return ( 0 ) ;\n }", "hash": 415966375198131126, "project": "debian", "size": 29, "target": 0, "idx": 8977}
{"code": "int mprintf_clock_stats ( sockaddr_u * addr , const char * fmt , ... ) {\n va_list ap ;\n int rc ;\n char msg [ 512 ] ;\n va_start ( ap , fmt ) ;\n rc = mvsnprintf ( msg , sizeof ( msg ) , fmt , ap ) ;\n va_end ( ap ) ;\n if ( stats_control ) record_clock_stats ( addr , msg ) ;\n return rc ;\n }", "hash": 415966375198131126, "project": "debian", "size": 10, "target": 0, "idx": 8978}
{"code": "void save_and_apply_config_tree ( void ) {\n config_tree * ptree ;\n # ifndef SAVECONFIG config_tree * punlinked ;\n # endif ptree = emalloc ( sizeof ( * ptree ) ) ;\n memcpy ( ptree , & cfgt , sizeof ( * ptree ) ) ;\n memset ( & cfgt , 0 , sizeof ( cfgt ) ) ;\n LINK_TAIL_SLIST ( cfg_tree_history , ptree , link , config_tree ) ;\n # ifdef SAVECONFIG if ( HAVE_OPT ( SAVECONFIGQUIT ) ) {\n FILE * dumpfile ;\n int err ;\n int dumpfailed ;\n dumpfile = fopen ( OPT_ARG ( SAVECONFIGQUIT ) , \"w\" ) ;\n if ( NULL == dumpfile ) {\n err = errno ;\n fprintf ( stderr , \"can not create save file %s, error %d %s\\n\" , OPT_ARG ( SAVECONFIGQUIT ) , err , strerror ( err ) ) ;\n exit ( err ) ;\n }\n dumpfailed = dump_all_config_trees ( dumpfile , 0 ) ;\n if ( dumpfailed ) fprintf ( stderr , \"--saveconfigquit %s error %d\\n\" , OPT_ARG ( SAVECONFIGQUIT ) , dumpfailed ) ;\n else fprintf ( stderr , \"configuration saved to %s\\n\" , OPT_ARG ( SAVECONFIGQUIT ) ) ;\n exit ( dumpfailed ) ;\n }\n # endif # ifndef SIM config_ntpd ( ptree ) ;\n # else config_ntpdsim ( ptree ) ;\n # endif # ifndef SAVECONFIG UNLINK_SLIST ( punlinked , cfg_tree_history , ptree , link , config_tree ) ;\n NTP_INSIST ( punlinked == ptree ) ;\n free_config_tree ( ptree ) ;\n # endif }", "hash": 6249489553242542670, "project": "debian", "size": 28, "target": 0, "idx": 8983}
{"code": "static unsigned long get_match ( char * s , struct masks * m ) {\n while ( m -> name ) {\n if ( strcmp ( s , m -> name ) == 0 ) return m -> mask ;\n else m ++ ;\n }\n return 0 ;\n }", "hash": 6249489553242542670, "project": "debian", "size": 7, "target": 0, "idx": 8984}
{"code": "static void config_setvar ( config_tree * ptree ) {\n setvar_node * my_node ;\n size_t varlen , vallen , octets ;\n char * str ;\n str = NULL ;\n my_node = HEAD_PFIFO ( ptree -> setvar ) ;\n for ( ;\n my_node != NULL ;\n my_node = my_node -> link ) {\n varlen = strlen ( my_node -> var ) ;\n vallen = strlen ( my_node -> val ) ;\n octets = varlen + vallen + 1 + 1 ;\n str = erealloc ( str , octets ) ;\n snprintf ( str , octets , \"%s=%s\" , my_node -> var , my_node -> val ) ;\n set_sys_var ( str , octets , ( my_node -> isdefault ) ? DEF : 0 ) ;\n }\n if ( str != NULL ) free ( str ) ;\n }", "hash": 6249489553242542670, "project": "debian", "size": 18, "target": 0, "idx": 9002}
{"code": "sim_node * create_sim_node ( attr_val_fifo * init_opts , server_info_fifo * servers ) {\n sim_node * my_node ;\n my_node = emalloc ( sizeof ( * my_node ) ) ;\n my_node -> init_opts = init_opts ;\n my_node -> servers = servers ;\n return my_node ;\n }", "hash": 6249489553242542670, "project": "debian", "size": 7, "target": 0, "idx": 9004}
{"code": "filegen_node * create_filegen_node ( int filegen_token , attr_val_fifo * options ) {\n filegen_node * my_node ;\n my_node = emalloc_zero ( sizeof ( * my_node ) ) ;\n my_node -> filegen_token = filegen_token ;\n my_node -> options = options ;\n return my_node ;\n }", "hash": 6249489553242542670, "project": "debian", "size": 7, "target": 0, "idx": 9005}
{"code": "static void init_syntax_tree ( config_tree * ptree ) {\n memset ( ptree , 0 , sizeof ( * ptree ) ) ;\n }", "hash": 6249489553242542670, "project": "debian", "size": 3, "target": 0, "idx": 9006}
{"code": "int_node * create_int_node ( int val ) {\n int_node * i_n ;\n i_n = emalloc_zero ( sizeof ( * i_n ) ) ;\n i_n -> i = val ;\n return i_n ;\n }", "hash": 6249489553242542670, "project": "debian", "size": 6, "target": 0, "idx": 9009}
{"code": "peer_node * create_peer_node ( int hmode , address_node * addr , attr_val_fifo * options ) {\n peer_node * my_node ;\n attr_val * option ;\n int freenode ;\n int errflag = 0 ;\n my_node = emalloc_zero ( sizeof ( * my_node ) ) ;\n my_node -> peerversion = NTP_VERSION ;\n my_node -> host_mode = hmode ;\n my_node -> addr = addr ;\n while ( options != NULL ) {\n UNLINK_FIFO ( option , * options , link ) ;\n if ( NULL == option ) {\n free ( options ) ;\n break ;\n }\n freenode = 1 ;\n switch ( option -> attr ) {\n case T_Flag : APPEND_G_FIFO ( my_node -> peerflags , option ) ;\n freenode = 0 ;\n break ;\n case T_Minpoll : if ( option -> value . i < NTP_MINPOLL || option -> value . i > UCHAR_MAX ) {\n msyslog ( LOG_INFO , \"minpoll: provided value (%d) is out of range [%d-%d])\" , option -> value . i , NTP_MINPOLL , UCHAR_MAX ) ;\n my_node -> minpoll = NTP_MINPOLL ;\n }\n else {\n my_node -> minpoll = ( u_char ) option -> value . u ;\n }\n break ;\n case T_Maxpoll : if ( option -> value . i < 0 || option -> value . i > NTP_MAXPOLL ) {\n msyslog ( LOG_INFO , \"maxpoll: provided value (%d) is out of range [0-%d])\" , option -> value . i , NTP_MAXPOLL ) ;\n my_node -> maxpoll = NTP_MAXPOLL ;\n }\n else {\n my_node -> maxpoll = ( u_char ) option -> value . u ;\n }\n break ;\n case T_Ttl : if ( option -> value . u >= MAX_TTL ) {\n msyslog ( LOG_ERR , \"ttl: invalid argument\" ) ;\n errflag = 1 ;\n }\n else {\n my_node -> ttl = ( u_char ) option -> value . u ;\n }\n break ;\n case T_Mode : if ( option -> value . u >= UCHAR_MAX ) {\n msyslog ( LOG_ERR , \"mode: invalid argument\" ) ;\n errflag = 1 ;\n }\n else {\n my_node -> ttl = ( u_char ) option -> value . u ;\n }\n break ;\n case T_Key : if ( option -> value . u >= KEYID_T_MAX ) {\n msyslog ( LOG_ERR , \"key: invalid argument\" ) ;\n errflag = 1 ;\n }\n else {\n my_node -> peerkey = ( keyid_t ) option -> value . u ;\n }\n break ;\n case T_Version : if ( option -> value . u >= UCHAR_MAX ) {\n msyslog ( LOG_ERR , \"version: invalid argument\" ) ;\n errflag = 1 ;\n }\n else {\n my_node -> peerversion = ( u_char ) option -> value . u ;\n }\n break ;\n case T_Ident : my_node -> group = option -> value . s ;\n break ;\n default : msyslog ( LOG_ERR , \"Unknown peer/server option token %s\" , token_name ( option -> attr ) ) ;\n errflag = 1 ;\n }\n if ( freenode ) free ( option ) ;\n }\n if ( errflag ) {\n free ( my_node ) ;\n my_node = NULL ;\n }\n return my_node ;\n }", "hash": 6249489553242542670, "project": "debian", "size": 81, "target": 0, "idx": 9021}
{"code": "static void destroy_string_fifo ( string_fifo * fifo ) {\n string_node * sn ;\n if ( fifo != NULL ) {\n do {\n UNLINK_FIFO ( sn , * fifo , link ) ;\n if ( sn != NULL ) {\n if ( sn -> s != NULL ) free ( sn -> s ) ;\n free ( sn ) ;\n }\n }\n while ( sn != NULL ) ;\n free ( fifo ) ;\n }\n }", "hash": 6249489553242542670, "project": "debian", "size": 14, "target": 0, "idx": 9035}
{"code": "static unsigned long get_pfxmatch ( char * * s , struct masks * m ) {\n while ( m -> name ) {\n if ( strncmp ( * s , m -> name , strlen ( m -> name ) ) == 0 ) {\n * s += strlen ( m -> name ) ;\n return m -> mask ;\n }\n else {\n m ++ ;\n }\n }\n return 0 ;\n }", "hash": 6249489553242542670, "project": "debian", "size": 12, "target": 0, "idx": 9036}
{"code": "static int getnetnum ( const char * num , sockaddr_u * addr , int complain , enum gnn_type a_type ) {\n NTP_REQUIRE ( AF_UNSPEC == AF ( addr ) || AF_INET == AF ( addr ) || AF_INET6 == AF ( addr ) ) ;\n if ( ! is_ip_address ( num , AF ( addr ) , addr ) ) return 0 ;\n if ( IS_IPV6 ( addr ) && ! ipv6_works ) return - 1 ;\n # ifdef ISC_PLATFORM_HAVESALEN addr -> sa . sa_len = SIZEOF_SOCKADDR ( AF ( addr ) ) ;\n # endif SET_PORT ( addr , NTP_PORT ) ;\n DPRINTF ( 2 , ( \"getnetnum given %s, got %s\\n\" , num , stoa ( addr ) ) ) ;\n return 1 ;\n }", "hash": 6249489553242542670, "project": "debian", "size": 9, "target": 0, "idx": 9039}
{"code": "static bool compare_hostname ( const acl_host_and_ip * host , const char * hostname , const char * ip ) {\n long tmp ;\n if ( host -> ip_mask && ip && calc_ip ( ip , & tmp , '\\0' ) ) {\n return ( tmp & host -> ip_mask ) == host -> ip ;\n }\n return ( ! host -> hostname || ( hostname && ! wild_case_compare ( system_charset_info , hostname , host -> hostname ) ) || ( ip && ! wild_compare ( ip , host -> hostname , 0 ) ) ) ;\n }", "hash": 3804373597256531021, "project": "debian", "size": 7, "target": 0, "idx": 9045}
{"code": "inline GRANT_NAME * routine_hash_search ( const char * host , const char * ip , const char * db , const char * user , const char * tname , bool proc , bool exact ) {\n return ( GRANT_TABLE * ) name_hash_search ( proc ? & proc_priv_hash : & func_priv_hash , host , ip , db , user , tname , exact , TRUE ) ;\n }", "hash": 3804373597256531021, "project": "debian", "size": 3, "target": 0, "idx": 9062}
{"code": "int fill_schema_schema_privileges ( THD * thd , TABLE_LIST * tables , COND * cond ) {\n # ifndef NO_EMBEDDED_ACCESS_CHECKS int error = 0 ;\n uint counter ;\n ACL_DB * acl_db ;\n ulong want_access ;\n char buff [ 100 ] ;\n TABLE * table = tables -> table ;\n bool no_global_access = check_access ( thd , SELECT_ACL , \"mysql\" , 0 , 1 , 1 , 0 ) ;\n char * curr_host = thd -> security_ctx -> priv_host_name ( ) ;\n DBUG_ENTER ( \"fill_schema_schema_privileges\" ) ;\n if ( ! initialized ) DBUG_RETURN ( 0 ) ;\n pthread_mutex_lock ( & acl_cache -> lock ) ;\n for ( counter = 0 ;\n counter < acl_dbs . elements ;\n counter ++ ) {\n const char * user , * host , * is_grantable = \"YES\" ;\n acl_db = dynamic_element ( & acl_dbs , counter , ACL_DB * ) ;\n if ( ! ( user = acl_db -> user ) ) user = \"\" ;\n if ( ! ( host = acl_db -> host . hostname ) ) host = \"\" ;\n if ( no_global_access && ( strcmp ( thd -> security_ctx -> priv_user , user ) || my_strcasecmp ( system_charset_info , curr_host , host ) ) ) continue ;\n want_access = acl_db -> access ;\n if ( want_access ) {\n if ( ! ( want_access & GRANT_ACL ) ) {\n is_grantable = \"NO\" ;\n }\n strxmov ( buff , \"'\" , user , \"'@'\" , host , \"'\" , NullS ) ;\n if ( ! ( want_access & ~ GRANT_ACL ) ) {\n if ( update_schema_privilege ( thd , table , buff , acl_db -> db , 0 , 0 , 0 , STRING_WITH_LEN ( \"USAGE\" ) , is_grantable ) ) {\n error = 1 ;\n goto err ;\n }\n }\n else {\n int cnt ;\n ulong j , test_access = want_access & ~ GRANT_ACL ;\n for ( cnt = 0 , j = SELECT_ACL ;\n j <= DB_ACLS ;\n cnt ++ , j <<= 1 ) if ( test_access & j ) {\n if ( update_schema_privilege ( thd , table , buff , acl_db -> db , 0 , 0 , 0 , command_array [ cnt ] , command_lengths [ cnt ] , is_grantable ) ) {\n error = 1 ;\n goto err ;\n }\n }\n }\n }\n }\n err : pthread_mutex_unlock ( & acl_cache -> lock ) ;\n DBUG_RETURN ( error ) ;\n # else return ( 0 ) ;\n # endif }", "hash": 3804373597256531021, "project": "debian", "size": 50, "target": 0, "idx": 9113}
{"code": "bool mysql_revoke_all ( THD * thd , List < LEX_USER > & list ) {\n uint counter , revoked , is_proc ;\n int result ;\n ACL_DB * acl_db ;\n TABLE_LIST tables [ GRANT_TABLES ] ;\n bool save_binlog_row_based ;\n DBUG_ENTER ( \"mysql_revoke_all\" ) ;\n save_binlog_row_based = thd -> current_stmt_binlog_row_based ;\n thd -> clear_current_stmt_binlog_row_based ( ) ;\n if ( ( result = open_grant_tables ( thd , tables ) ) ) {\n thd -> current_stmt_binlog_row_based = save_binlog_row_based ;\n DBUG_RETURN ( result != 1 ) ;\n }\n rw_wrlock ( & LOCK_grant ) ;\n VOID ( pthread_mutex_lock ( & acl_cache -> lock ) ) ;\n LEX_USER * lex_user , * tmp_lex_user ;\n List_iterator < LEX_USER > user_list ( list ) ;\n while ( ( tmp_lex_user = user_list ++ ) ) {\n if ( ! ( lex_user = get_current_user ( thd , tmp_lex_user ) ) ) {\n result = - 1 ;\n continue ;\n }\n if ( ! find_acl_user ( lex_user -> host . str , lex_user -> user . str , TRUE ) ) {\n result = - 1 ;\n continue ;\n }\n if ( replace_user_table ( thd , tables [ 0 ] . table , * lex_user , ~ ( ulong ) 0 , 1 , 0 , 0 ) ) {\n result = - 1 ;\n continue ;\n }\n do {\n for ( counter = 0 , revoked = 0 ;\n counter < acl_dbs . elements ;\n ) {\n const char * user , * host ;\n acl_db = dynamic_element ( & acl_dbs , counter , ACL_DB * ) ;\n if ( ! ( user = acl_db -> user ) ) user = \"\" ;\n if ( ! ( host = acl_db -> host . hostname ) ) host = \"\" ;\n if ( ! strcmp ( lex_user -> user . str , user ) && ! strcmp ( lex_user -> host . str , host ) ) {\n if ( ! replace_db_table ( tables [ 1 ] . table , acl_db -> db , * lex_user , ~ ( ulong ) 0 , 1 ) ) {\n revoked = 1 ;\n continue ;\n }\n result = - 1 ;\n }\n counter ++ ;\n }\n }\n while ( revoked ) ;\n do {\n for ( counter = 0 , revoked = 0 ;\n counter < column_priv_hash . records ;\n ) {\n const char * user , * host ;\n GRANT_TABLE * grant_table = ( GRANT_TABLE * ) hash_element ( & column_priv_hash , counter ) ;\n if ( ! ( user = grant_table -> user ) ) user = \"\" ;\n if ( ! ( host = grant_table -> host . hostname ) ) host = \"\" ;\n if ( ! strcmp ( lex_user -> user . str , user ) && ! strcmp ( lex_user -> host . str , host ) ) {\n if ( replace_table_table ( thd , grant_table , tables [ 2 ] . table , * lex_user , grant_table -> db , grant_table -> tname , ~ ( ulong ) 0 , 0 , 1 ) ) {\n result = - 1 ;\n }\n else {\n if ( ! grant_table -> cols ) {\n revoked = 1 ;\n continue ;\n }\n List < LEX_COLUMN > columns ;\n if ( ! replace_column_table ( grant_table , tables [ 3 ] . table , * lex_user , columns , grant_table -> db , grant_table -> tname , ~ ( ulong ) 0 , 1 ) ) {\n revoked = 1 ;\n continue ;\n }\n result = - 1 ;\n }\n }\n counter ++ ;\n }\n }\n while ( revoked ) ;\n for ( is_proc = 0 ;\n is_proc < 2 ;\n is_proc ++ ) do {\n HASH * hash = is_proc ? & proc_priv_hash : & func_priv_hash ;\n for ( counter = 0 , revoked = 0 ;\n counter < hash -> records ;\n ) {\n const char * user , * host ;\n GRANT_NAME * grant_proc = ( GRANT_NAME * ) hash_element ( hash , counter ) ;\n if ( ! ( user = grant_proc -> user ) ) user = \"\" ;\n if ( ! ( host = grant_proc -> host . hostname ) ) host = \"\" ;\n if ( ! strcmp ( lex_user -> user . str , user ) && ! strcmp ( lex_user -> host . str , host ) ) {\n if ( replace_routine_table ( thd , grant_proc , tables [ 4 ] . table , * lex_user , grant_proc -> db , grant_proc -> tname , is_proc , ~ ( ulong ) 0 , 1 ) == 0 ) {\n revoked = 1 ;\n continue ;\n }\n result = - 1 ;\n }\n counter ++ ;\n }\n }\n while ( revoked ) ;\n }\n VOID ( pthread_mutex_unlock ( & acl_cache -> lock ) ) ;\n if ( result ) my_message ( ER_REVOKE_GRANTS , ER ( ER_REVOKE_GRANTS ) , MYF ( 0 ) ) ;\n result = result | write_bin_log ( thd , FALSE , thd -> query ( ) , thd -> query_length ( ) ) ;\n rw_unlock ( & LOCK_grant ) ;\n close_thread_tables ( thd ) ;\n thd -> current_stmt_binlog_row_based = save_binlog_row_based ;\n DBUG_RETURN ( result ) ;\n }", "hash": 3804373597256531021, "project": "debian", "size": 109, "target": 0, "idx": 9114}
{"code": "static int handle_grant_table ( TABLE_LIST * tables , uint table_no , bool drop , LEX_USER * user_from , LEX_USER * user_to ) {\n int result = 0 ;\n int error ;\n TABLE * table = tables [ table_no ] . table ;\n Field * host_field = table -> field [ 0 ] ;\n Field * user_field = table -> field [ table_no ? 2 : 1 ] ;\n char * host_str = user_from -> host . str ;\n char * user_str = user_from -> user . str ;\n const char * host ;\n const char * user ;\n uchar user_key [ MAX_KEY_LENGTH ] ;\n uint key_prefix_length ;\n DBUG_ENTER ( \"handle_grant_table\" ) ;\n THD * thd = current_thd ;\n table -> use_all_columns ( ) ;\n if ( ! table_no ) {\n DBUG_PRINT ( \"info\" , ( \"read table: '%s' search: '%s'@'%s'\" , table -> s -> table_name . str , user_str , host_str ) ) ;\n host_field -> store ( host_str , user_from -> host . length , system_charset_info ) ;\n user_field -> store ( user_str , user_from -> user . length , system_charset_info ) ;\n key_prefix_length = ( table -> key_info -> key_part [ 0 ] . store_length + table -> key_info -> key_part [ 1 ] . store_length ) ;\n key_copy ( user_key , table -> record [ 0 ] , table -> key_info , key_prefix_length ) ;\n if ( ( error = table -> file -> index_read_idx_map ( table -> record [ 0 ] , 0 , user_key , ( key_part_map ) 3 , HA_READ_KEY_EXACT ) ) ) {\n if ( error != HA_ERR_KEY_NOT_FOUND && error != HA_ERR_END_OF_FILE ) {\n table -> file -> print_error ( error , MYF ( 0 ) ) ;\n result = - 1 ;\n }\n }\n else {\n result = ( ( drop || user_to ) && modify_grant_table ( table , host_field , user_field , user_to ) ) ? - 1 : 1 ;\n }\n DBUG_PRINT ( \"info\" , ( \"read result: %d\" , result ) ) ;\n }\n else {\n if ( ( error = table -> file -> ha_rnd_init ( 1 ) ) ) {\n table -> file -> print_error ( error , MYF ( 0 ) ) ;\n result = - 1 ;\n }\n else {\n # ifdef EXTRA_DEBUG DBUG_PRINT ( \"info\" , ( \"scan table: '%s' search: '%s'@'%s'\" , table -> s -> table_name . str , user_str , host_str ) ) ;\n # endif while ( ( error = table -> file -> rnd_next ( table -> record [ 0 ] ) ) != HA_ERR_END_OF_FILE ) {\n if ( error ) {\n DBUG_PRINT ( \"info\" , ( \"scan error: %d\" , error ) ) ;\n continue ;\n }\n if ( ! ( host = get_field ( thd -> mem_root , host_field ) ) ) host = \"\" ;\n if ( ! ( user = get_field ( thd -> mem_root , user_field ) ) ) user = \"\" ;\n # ifdef EXTRA_DEBUG DBUG_PRINT ( \"loop\" , ( \"scan fields: '%s'@'%s' '%s' '%s' '%s'\" , user , host , get_field ( thd -> mem_root , table -> field [ 1 ] ) , get_field ( thd -> mem_root , table -> field [ 3 ] ) , get_field ( thd -> mem_root , table -> field [ 4 ] ) ) ) ;\n # endif if ( strcmp ( user_str , user ) || my_strcasecmp ( system_charset_info , host_str , host ) ) continue ;\n result = ( ( drop || user_to ) && modify_grant_table ( table , host_field , user_field , user_to ) ) ? - 1 : result ? result : 1 ;\n if ( ! drop && ! user_to ) break ;\n }\n ( void ) table -> file -> ha_rnd_end ( ) ;\n DBUG_PRINT ( \"info\" , ( \"scan result: %d\" , result ) ) ;\n }\n }\n DBUG_RETURN ( result ) ;\n }", "hash": 3804373597256531021, "project": "debian", "size": 57, "target": 0, "idx": 9125}
{"code": "ulong get_column_grant ( THD * thd , GRANT_INFO * grant , const char * db_name , const char * table_name , const char * field_name ) {\n GRANT_TABLE * grant_table ;\n GRANT_COLUMN * grant_column ;\n ulong priv ;\n rw_rdlock ( & LOCK_grant ) ;\n if ( grant -> version != grant_version ) {\n Security_context * sctx = thd -> security_ctx ;\n grant -> grant_table = table_hash_search ( sctx -> host , sctx -> ip , db_name , sctx -> priv_user , table_name , 0 ) ;\n grant -> version = grant_version ;\n }\n if ( ! ( grant_table = grant -> grant_table ) ) priv = grant -> privilege ;\n else {\n grant_column = column_hash_search ( grant_table , field_name , ( uint ) strlen ( field_name ) ) ;\n if ( ! grant_column ) priv = ( grant -> privilege | grant_table -> privs ) ;\n else priv = ( grant -> privilege | grant_table -> privs | grant_column -> rights ) ;\n }\n rw_unlock ( & LOCK_grant ) ;\n return priv ;\n }", "hash": 3804373597256531021, "project": "debian", "size": 19, "target": 0, "idx": 9127}
{"code": "void irc_ctcp_display_reply_from_nick ( struct t_irc_server * server , time_t date , const char * command , const char * nick , const char * address , char * arguments ) {\n char * pos_end , * pos_space , * pos_args , * pos_usec ;\n struct timeval tv ;\n long sec1 , usec1 , sec2 , usec2 , difftime ;\n while ( arguments && arguments [ 0 ] ) {\n pos_end = strrchr ( arguments + 1 , '\\01' ) ;\n if ( pos_end ) pos_end [ 0 ] = '\\0' ;\n pos_space = strchr ( arguments + 1 , ' ' ) ;\n if ( pos_space ) {\n pos_space [ 0 ] = '\\0' ;\n pos_args = pos_space + 1 ;\n while ( pos_args [ 0 ] == ' ' ) {\n pos_args ++ ;\n }\n if ( strcmp ( arguments + 1 , \"PING\" ) == 0 ) {\n pos_usec = strchr ( pos_args , ' ' ) ;\n if ( pos_usec ) {\n pos_usec [ 0 ] = '\\0' ;\n gettimeofday ( & tv , NULL ) ;\n sec1 = atol ( pos_args ) ;\n usec1 = atol ( pos_usec + 1 ) ;\n sec2 = tv . tv_sec ;\n usec2 = tv . tv_usec ;\n difftime = ( ( sec2 * 1000000 ) + usec2 ) - ( ( sec1 * 1000000 ) + usec1 ) ;\n weechat_printf_date_tags ( irc_msgbuffer_get_target_buffer ( server , nick , NULL , \"ctcp\" , NULL ) , date , irc_protocol_tags ( command , \"irc_ctcp\" , NULL , NULL ) , _ ( \"%sCTCP reply from %s%s%s: %s%s%s %.3fs\" ) , weechat_prefix ( \"network\" ) , irc_nick_color_for_msg ( server , 0 , NULL , nick ) , nick , IRC_COLOR_RESET , IRC_COLOR_CHAT_CHANNEL , arguments + 1 , IRC_COLOR_RESET , ( float ) difftime / 1000000.0 ) ;\n pos_usec [ 0 ] = ' ' ;\n }\n }\n else {\n weechat_printf_date_tags ( irc_msgbuffer_get_target_buffer ( server , nick , NULL , \"ctcp\" , NULL ) , date , irc_protocol_tags ( command , \"irc_ctcp\" , NULL , address ) , _ ( \"%sCTCP reply from %s%s%s: %s%s%s%s%s\" ) , weechat_prefix ( \"network\" ) , irc_nick_color_for_msg ( server , 0 , NULL , nick ) , nick , IRC_COLOR_RESET , IRC_COLOR_CHAT_CHANNEL , arguments + 1 , IRC_COLOR_RESET , \" \" , pos_args ) ;\n }\n pos_space [ 0 ] = ' ' ;\n }\n else {\n weechat_printf_date_tags ( irc_msgbuffer_get_target_buffer ( server , nick , NULL , \"ctcp\" , NULL ) , date , irc_protocol_tags ( command , NULL , NULL , address ) , _ ( \"%sCTCP reply from %s%s%s: %s%s%s%s%s\" ) , weechat_prefix ( \"network\" ) , irc_nick_color_for_msg ( server , 0 , NULL , nick ) , nick , IRC_COLOR_RESET , IRC_COLOR_CHAT_CHANNEL , arguments + 1 , \"\" , \"\" , \"\" ) ;\n }\n if ( pos_end ) pos_end [ 0 ] = '\\01' ;\n arguments = ( pos_end ) ? pos_end + 1 : NULL ;\n }\n }", "hash": 2518148041181868265, "project": "debian", "size": 40, "target": 0, "idx": 9137}
{"code": "int xml_process_chunk ( modsec_rec * msr , const char * buf , unsigned int size , char * * error_msg ) {\n if ( error_msg == NULL ) return - 1 ;\n * error_msg = NULL ;\n if ( msr -> xml -> parsing_ctx == NULL ) {\n msr_log ( msr , 4 , \"XML: Initialising parser.\" ) ;\n msr -> xml -> parsing_ctx = xmlCreatePushParserCtxt ( NULL , NULL , buf , size , \"body.xml\" ) ;\n if ( msr -> xml -> parsing_ctx == NULL ) {\n * error_msg = apr_psprintf ( msr -> mp , \"XML: Failed to create parsing context.\" ) ;\n return - 1 ;\n }\n }\n else {\n xmlParseChunk ( msr -> xml -> parsing_ctx , buf , size , 0 ) ;\n if ( msr -> xml -> parsing_ctx -> wellFormed != 1 ) {\n * error_msg = apr_psprintf ( msr -> mp , \"XML: Failed parsing document.\" ) ;\n return - 1 ;\n }\n }\n return 1 ;\n }", "hash": 3315269357322037767, "project": "debian", "size": 20, "target": 0, "idx": 9144}
{"code": "static const char * cmd_xml_external_entity ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n if ( dcfg == NULL ) return NULL ;\n if ( strcasecmp ( p1 , \"on\" ) == 0 ) {\n dcfg -> xml_external_entity = 1 ;\n }\n else if ( strcasecmp ( p1 , \"off\" ) == 0 ) {\n dcfg -> xml_external_entity = 0 ;\n }\n else return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid value for SecXmlExternalEntity: %s\" , p1 ) ;\n return NULL ;\n }", "hash": -5493081488206619677, "project": "debian", "size": 12, "target": 0, "idx": 9146}
{"code": "static const char * cmd_rule_update_action_by_id ( cmd_parms * cmd , void * _dcfg , const char * p1 , const char * p2 ) {\n int offset = 0 , rule_id = atoi ( p1 ) ;\n char * opt = strchr ( p1 , ':' ) ;\n char * savedptr = NULL ;\n char * param = apr_pstrdup ( cmd -> pool , p1 ) ;\n if ( ( rule_id == LONG_MAX ) || ( rule_id == LONG_MIN ) || ( rule_id <= 0 ) ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid value for ID for update action: %s\" , p1 ) ;\n }\n if ( opt != NULL ) {\n opt ++ ;\n offset = atoi ( opt ) ;\n opt = apr_strtok ( param , \":\" , & savedptr ) ;\n return update_rule_action ( cmd , ( directory_config * ) _dcfg , ( const char * ) opt , p2 , offset ) ;\n }\n return update_rule_action ( cmd , ( directory_config * ) _dcfg , p1 , p2 , offset ) ;\n }", "hash": -5493081488206619677, "project": "debian", "size": 16, "target": 0, "idx": 9148}
{"code": "static const char * cmd_rule_update_target_by_tag ( cmd_parms * cmd , void * _dcfg , const char * p1 , const char * p2 , const char * p3 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n rule_exception * re = apr_pcalloc ( cmd -> pool , sizeof ( rule_exception ) ) ;\n if ( dcfg == NULL ) return NULL ;\n if ( p1 == NULL ) {\n return apr_psprintf ( cmd -> pool , \"Updating target by tag with no tag\" ) ;\n }\n re -> type = RULE_EXCEPTION_REMOVE_TAG ;\n re -> param = p1 ;\n re -> param_data = msc_pregcomp ( cmd -> pool , p1 , 0 , NULL , NULL ) ;\n if ( re -> param_data == NULL ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid regular expression: %s\" , p1 ) ;\n }\n return msre_ruleset_rule_update_target_matching_exception ( NULL , dcfg -> ruleset , re , p2 , p3 ) ;\n }", "hash": -5493081488206619677, "project": "debian", "size": 15, "target": 0, "idx": 9149}
{"code": "static const char * cmd_audit_log_type ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = _dcfg ;\n if ( strcasecmp ( p1 , \"Serial\" ) == 0 ) dcfg -> auditlog_type = AUDITLOG_SERIAL ;\n else if ( strcasecmp ( p1 , \"Concurrent\" ) == 0 ) dcfg -> auditlog_type = AUDITLOG_CONCURRENT ;\n else return ( const char * ) apr_psprintf ( cmd -> pool , \"ModSecurity: Unrecognised parameter value for SecAuditLogType: %s\" , p1 ) ;\n return NULL ;\n }", "hash": -5493081488206619677, "project": "debian", "size": 7, "target": 0, "idx": 9174}
{"code": "static const char * cmd_cache_transformations ( cmd_parms * cmd , void * _dcfg , const char * p1 , const char * p2 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n if ( dcfg == NULL ) return NULL ;\n if ( strcasecmp ( p1 , \"on\" ) == 0 ) dcfg -> cache_trans = MODSEC_CACHE_ENABLED ;\n else if ( strcasecmp ( p1 , \"off\" ) == 0 ) dcfg -> cache_trans = MODSEC_CACHE_DISABLED ;\n else return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid value for SecCacheTransformations: %s\" , p1 ) ;\n if ( p2 != NULL ) {\n apr_table_t * vartable = apr_table_make ( cmd -> pool , 4 ) ;\n apr_status_t rc ;\n char * error_msg = NULL ;\n const char * charval = NULL ;\n apr_int64_t intval = 0 ;\n if ( vartable == NULL ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: Unable to process options for SecCacheTransformations\" ) ;\n }\n rc = msre_parse_generic ( cmd -> pool , p2 , vartable , & error_msg ) ;\n if ( rc < 0 ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: Unable to parse options for SecCacheTransformations: %s\" , error_msg ) ;\n }\n charval = apr_table_get ( vartable , \"incremental\" ) ;\n if ( charval != NULL ) {\n if ( strcasecmp ( charval , \"on\" ) == 0 ) dcfg -> cache_trans_incremental = 1 ;\n else if ( strcasecmp ( charval , \"off\" ) == 0 ) dcfg -> cache_trans_incremental = 0 ;\n else return apr_psprintf ( cmd -> pool , \"ModSecurity: SecCacheTransformations invalid incremental value: %s\" , charval ) ;\n }\n charval = apr_table_get ( vartable , \"minlen\" ) ;\n if ( charval != NULL ) {\n intval = apr_atoi64 ( charval ) ;\n if ( errno == ERANGE ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: SecCacheTransformations minlen out of range: %s\" , charval ) ;\n }\n if ( intval < 0 ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: SecCacheTransformations minlen must be positive: %s\" , charval ) ;\n }\n if ( ( unsigned long ) intval >= ( unsigned long ) NOT_SET ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: SecCacheTransformations minlen must be less than: %lu\" , ( unsigned long ) NOT_SET ) ;\n }\n dcfg -> cache_trans_min = ( apr_size_t ) intval ;\n }\n charval = apr_table_get ( vartable , \"maxlen\" ) ;\n if ( charval != NULL ) {\n intval = apr_atoi64 ( charval ) ;\n if ( errno == ERANGE ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: SecCacheTransformations maxlen out of range: %s\" , charval ) ;\n }\n if ( intval < 0 ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: SecCacheTransformations maxlen must be positive: %s\" , charval ) ;\n }\n if ( ( unsigned long ) intval >= ( unsigned long ) NOT_SET ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: SecCacheTransformations maxlen must be less than: %lu\" , ( unsigned long ) NOT_SET ) ;\n }\n if ( ( intval != 0 ) && ( ( apr_size_t ) intval < dcfg -> cache_trans_min ) ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: SecCacheTransformations maxlen must not be less than minlen: %lu < %\" APR_SIZE_T_FMT , ( unsigned long ) intval , dcfg -> cache_trans_min ) ;\n }\n dcfg -> cache_trans_max = ( apr_size_t ) intval ;\n }\n charval = apr_table_get ( vartable , \"maxitems\" ) ;\n if ( charval != NULL ) {\n intval = apr_atoi64 ( charval ) ;\n if ( errno == ERANGE ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: SecCacheTransformations maxitems out of range: %s\" , charval ) ;\n }\n if ( intval < 0 ) {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: SecCacheTransformations maxitems must be positive: %s\" , charval ) ;\n }\n dcfg -> cache_trans_maxitems = ( apr_size_t ) intval ;\n }\n }\n return NULL ;\n }", "hash": -5493081488206619677, "project": "debian", "size": 70, "target": 0, "idx": 9184}
{"code": "static const char * cmd_hash_engine ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n if ( dcfg == NULL ) return NULL ;\n if ( strcasecmp ( p1 , \"on\" ) == 0 ) {\n dcfg -> hash_is_enabled = HASH_ENABLED ;\n dcfg -> hash_enforcement = HASH_ENABLED ;\n }\n else if ( strcasecmp ( p1 , \"off\" ) == 0 ) {\n dcfg -> hash_is_enabled = HASH_DISABLED ;\n dcfg -> hash_enforcement = HASH_DISABLED ;\n }\n else return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid value for SexHashEngine: %s\" , p1 ) ;\n return NULL ;\n }", "hash": -5493081488206619677, "project": "debian", "size": 14, "target": 0, "idx": 9193}
{"code": "static const char * cmd_component_signature ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n * ( char * * ) apr_array_push ( dcfg -> component_signatures ) = ( char * ) p1 ;\n return NULL ;\n }", "hash": -5493081488206619677, "project": "debian", "size": 5, "target": 0, "idx": 9199}
{"code": "static const char * cmd_cookie_format ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n if ( strcmp ( p1 , \"0\" ) == 0 ) dcfg -> cookie_format = COOKIES_V0 ;\n else if ( strcmp ( p1 , \"1\" ) == 0 ) dcfg -> cookie_format = COOKIES_V1 ;\n else {\n return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid cookie format: %s\" , p1 ) ;\n }\n return NULL ;\n }", "hash": -5493081488206619677, "project": "debian", "size": 9, "target": 0, "idx": 9206}
{"code": "static int nsv_read_chunk ( AVFormatContext * s , int fill_header ) {\n NSVContext * nsv = s -> priv_data ;\n AVIOContext * pb = s -> pb ;\n AVStream * st [ 2 ] = {\n NULL , NULL }\n ;\n NSVStream * nst ;\n AVPacket * pkt ;\n int i , err = 0 ;\n uint8_t auxcount ;\n uint32_t vsize ;\n uint16_t asize ;\n uint16_t auxsize ;\n int ret ;\n if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ;\n null_chunk_retry : if ( avio_feof ( pb ) ) return - 1 ;\n for ( i = 0 ;\n i < NSV_MAX_RESYNC_TRIES && nsv -> state < NSV_FOUND_NSVS && ! err ;\n i ++ ) err = nsv_resync ( s ) ;\n if ( err < 0 ) return err ;\n if ( nsv -> state == NSV_FOUND_NSVS ) err = nsv_parse_NSVs_header ( s ) ;\n if ( err < 0 ) return err ;\n if ( nsv -> state != NSV_HAS_READ_NSVS && nsv -> state != NSV_FOUND_BEEF ) return - 1 ;\n auxcount = avio_r8 ( pb ) ;\n vsize = avio_rl16 ( pb ) ;\n asize = avio_rl16 ( pb ) ;\n vsize = ( vsize << 4 ) | ( auxcount >> 4 ) ;\n auxcount &= 0x0f ;\n av_log ( s , AV_LOG_TRACE , \"NSV CHUNK %d aux, %\" PRIu32 \" bytes video, %d bytes audio\\n\" , auxcount , vsize , asize ) ;\n for ( i = 0 ;\n i < auxcount ;\n i ++ ) {\n uint32_t av_unused auxtag ;\n auxsize = avio_rl16 ( pb ) ;\n auxtag = avio_rl32 ( pb ) ;\n avio_skip ( pb , auxsize ) ;\n vsize -= auxsize + sizeof ( uint16_t ) + sizeof ( uint32_t ) ;\n }\n if ( avio_feof ( pb ) ) return - 1 ;\n if ( ! vsize && ! asize ) {\n nsv -> state = NSV_UNSYNC ;\n goto null_chunk_retry ;\n }\n if ( s -> nb_streams > 0 ) st [ s -> streams [ 0 ] -> id ] = s -> streams [ 0 ] ;\n if ( s -> nb_streams > 1 ) st [ s -> streams [ 1 ] -> id ] = s -> streams [ 1 ] ;\n if ( vsize && st [ NSV_ST_VIDEO ] ) {\n nst = st [ NSV_ST_VIDEO ] -> priv_data ;\n pkt = & nsv -> ahead [ NSV_ST_VIDEO ] ;\n if ( ( ret = av_get_packet ( pb , pkt , vsize ) ) < 0 ) return ret ;\n pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ;\n pkt -> dts = nst -> frame_offset ;\n pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ;\n for ( i = 0 ;\n i < FFMIN ( 8 , vsize ) ;\n i ++ ) av_log ( s , AV_LOG_TRACE , \"NSV video: [%d] = %02x\\n\" , i , pkt -> data [ i ] ) ;\n }\n if ( st [ NSV_ST_VIDEO ] ) ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset ++ ;\n if ( asize && st [ NSV_ST_AUDIO ] ) {\n nst = st [ NSV_ST_AUDIO ] -> priv_data ;\n pkt = & nsv -> ahead [ NSV_ST_AUDIO ] ;\n if ( asize && st [ NSV_ST_AUDIO ] -> codecpar -> codec_tag == MKTAG ( 'P' , 'C' , 'M' , ' ' ) ) {\n uint8_t bps ;\n uint8_t channels ;\n uint16_t samplerate ;\n bps = avio_r8 ( pb ) ;\n channels = avio_r8 ( pb ) ;\n samplerate = avio_rl16 ( pb ) ;\n if ( ! channels || ! samplerate ) return AVERROR_INVALIDDATA ;\n asize -= 4 ;\n av_log ( s , AV_LOG_TRACE , \"NSV RAWAUDIO: bps %d, nchan %d, srate %d\\n\" , bps , channels , samplerate ) ;\n if ( fill_header ) {\n st [ NSV_ST_AUDIO ] -> need_parsing = AVSTREAM_PARSE_NONE ;\n if ( bps != 16 ) {\n av_log ( s , AV_LOG_TRACE , \"NSV AUDIO bit/sample != 16 (%d)!!!\\n\" , bps ) ;\n }\n bps /= channels ;\n if ( bps == 8 ) st [ NSV_ST_AUDIO ] -> codecpar -> codec_id = AV_CODEC_ID_PCM_U8 ;\n samplerate /= 4 ;\n channels = 1 ;\n st [ NSV_ST_AUDIO ] -> codecpar -> channels = channels ;\n st [ NSV_ST_AUDIO ] -> codecpar -> sample_rate = samplerate ;\n av_log ( s , AV_LOG_TRACE , \"NSV RAWAUDIO: bps %d, nchan %d, srate %d\\n\" , bps , channels , samplerate ) ;\n }\n }\n if ( ( ret = av_get_packet ( pb , pkt , asize ) ) < 0 ) return ret ;\n pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ;\n pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ;\n if ( nsv -> state == NSV_HAS_READ_NSVS && st [ NSV_ST_VIDEO ] ) {\n pkt -> dts = ( ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset - 1 ) ;\n pkt -> dts *= ( int64_t ) 1000 * nsv -> framerate . den ;\n pkt -> dts += ( int64_t ) nsv -> avsync * nsv -> framerate . num ;\n av_log ( s , AV_LOG_TRACE , \"NSV AUDIO: sync:%d, dts:%\" PRId64 , nsv -> avsync , pkt -> dts ) ;\n }\n nst -> frame_offset ++ ;\n }\n nsv -> state = NSV_UNSYNC ;\n return 0 ;\n }", "hash": 6138954447623141313, "project": "debian", "size": 98, "target": 0, "idx": 9228}
{"code": "static int nsv_resync ( AVFormatContext * s ) {\n NSVContext * nsv = s -> priv_data ;\n AVIOContext * pb = s -> pb ;\n uint32_t v = 0 ;\n int i ;\n for ( i = 0 ;\n i < NSV_MAX_RESYNC ;\n i ++ ) {\n if ( avio_feof ( pb ) ) {\n av_log ( s , AV_LOG_TRACE , \"NSV EOF\\n\" ) ;\n nsv -> state = NSV_UNSYNC ;\n return - 1 ;\n }\n v <<= 8 ;\n v |= avio_r8 ( pb ) ;\n if ( i < 8 ) {\n av_log ( s , AV_LOG_TRACE , \"NSV resync: [%d] = %02\" PRIx32 \"\\n\" , i , v & 0x0FF ) ;\n }\n if ( ( v & 0x0000ffff ) == 0xefbe ) {\n av_log ( s , AV_LOG_TRACE , \"NSV resynced on BEEF after %d bytes\\n\" , i + 1 ) ;\n nsv -> state = NSV_FOUND_BEEF ;\n return 0 ;\n }\n if ( v == TB_NSVF ) {\n av_log ( s , AV_LOG_TRACE , \"NSV resynced on NSVf after %d bytes\\n\" , i + 1 ) ;\n nsv -> state = NSV_FOUND_NSVF ;\n return 0 ;\n }\n if ( v == MKBETAG ( 'N' , 'S' , 'V' , 's' ) ) {\n av_log ( s , AV_LOG_TRACE , \"NSV resynced on NSVs after %d bytes\\n\" , i + 1 ) ;\n nsv -> state = NSV_FOUND_NSVS ;\n return 0 ;\n }\n }\n av_log ( s , AV_LOG_TRACE , \"NSV sync lost\\n\" ) ;\n return - 1 ;\n }", "hash": 6138954447623141313, "project": "debian", "size": 37, "target": 0, "idx": 9229}
{"code": "static int nsv_parse_NSVf_header ( AVFormatContext * s ) {\n NSVContext * nsv = s -> priv_data ;\n AVIOContext * pb = s -> pb ;\n unsigned int av_unused file_size ;\n unsigned int size ;\n int64_t duration ;\n int strings_size ;\n int table_entries ;\n int table_entries_used ;\n nsv -> state = NSV_UNSYNC ;\n size = avio_rl32 ( pb ) ;\n if ( size < 28 ) return - 1 ;\n nsv -> NSVf_end = size ;\n file_size = ( uint32_t ) avio_rl32 ( pb ) ;\n av_log ( s , AV_LOG_TRACE , \"NSV NSVf chunk_size %u\\n\" , size ) ;\n av_log ( s , AV_LOG_TRACE , \"NSV NSVf file_size %u\\n\" , file_size ) ;\n nsv -> duration = duration = avio_rl32 ( pb ) ;\n av_log ( s , AV_LOG_TRACE , \"NSV NSVf duration %\" PRId64 \" ms\\n\" , duration ) ;\n strings_size = avio_rl32 ( pb ) ;\n table_entries = avio_rl32 ( pb ) ;\n table_entries_used = avio_rl32 ( pb ) ;\n av_log ( s , AV_LOG_TRACE , \"NSV NSVf info-strings size: %d, table entries: %d, bis %d\\n\" , strings_size , table_entries , table_entries_used ) ;\n if ( avio_feof ( pb ) ) return - 1 ;\n av_log ( s , AV_LOG_TRACE , \"NSV got header;\n filepos %\" PRId64 \"\\n\" , avio_tell ( pb ) ) ;\n if ( strings_size > 0 ) {\n char * strings ;\n char * p , * endp ;\n char * token , * value ;\n char quote ;\n p = strings = av_mallocz ( ( size_t ) strings_size + 1 ) ;\n if ( ! p ) return AVERROR ( ENOMEM ) ;\n endp = strings + strings_size ;\n avio_read ( pb , strings , strings_size ) ;\n while ( p < endp ) {\n while ( * p == ' ' ) p ++ ;\n if ( p >= endp - 2 ) break ;\n token = p ;\n p = strchr ( p , '=' ) ;\n if ( ! p || p >= endp - 2 ) break ;\n * p ++ = '\\0' ;\n quote = * p ++ ;\n value = p ;\n p = strchr ( p , quote ) ;\n if ( ! p || p >= endp ) break ;\n * p ++ = '\\0' ;\n av_log ( s , AV_LOG_TRACE , \"NSV NSVf INFO: %s='%s'\\n\" , token , value ) ;\n av_dict_set ( & s -> metadata , token , value , 0 ) ;\n }\n av_free ( strings ) ;\n }\n if ( avio_feof ( pb ) ) return - 1 ;\n av_log ( s , AV_LOG_TRACE , \"NSV got infos;\n filepos %\" PRId64 \"\\n\" , avio_tell ( pb ) ) ;\n if ( table_entries_used > 0 ) {\n int i ;\n nsv -> index_entries = table_entries_used ;\n if ( ( unsigned ) table_entries_used >= UINT_MAX / sizeof ( uint32_t ) ) return - 1 ;\n nsv -> nsvs_file_offset = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ;\n if ( ! nsv -> nsvs_file_offset ) return AVERROR ( ENOMEM ) ;\n for ( i = 0 ;\n i < table_entries_used ;\n i ++ ) {\n if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;\n nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ;\n }\n if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) {\n nsv -> nsvs_timestamps = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ;\n if ( ! nsv -> nsvs_timestamps ) return AVERROR ( ENOMEM ) ;\n for ( i = 0 ;\n i < table_entries_used ;\n i ++ ) {\n nsv -> nsvs_timestamps [ i ] = avio_rl32 ( pb ) ;\n }\n }\n }\n av_log ( s , AV_LOG_TRACE , \"NSV got index;\n filepos %\" PRId64 \"\\n\" , avio_tell ( pb ) ) ;\n avio_seek ( pb , nsv -> base_offset + size , SEEK_SET ) ;\n if ( avio_feof ( pb ) ) return - 1 ;\n nsv -> state = NSV_HAS_READ_NSVF ;\n return 0 ;\n }", "hash": 6138954447623141313, "project": "debian", "size": 83, "target": 0, "idx": 9230}
{"code": "static int nsv_parse_NSVs_header ( AVFormatContext * s ) {\n NSVContext * nsv = s -> priv_data ;\n AVIOContext * pb = s -> pb ;\n uint32_t vtag , atag ;\n uint16_t vwidth , vheight ;\n AVRational framerate ;\n int i ;\n AVStream * st ;\n NSVStream * nst ;\n vtag = avio_rl32 ( pb ) ;\n atag = avio_rl32 ( pb ) ;\n vwidth = avio_rl16 ( pb ) ;\n vheight = avio_rl16 ( pb ) ;\n i = avio_r8 ( pb ) ;\n av_log ( s , AV_LOG_TRACE , \"NSV NSVs framerate code %2x\\n\" , i ) ;\n if ( i & 0x80 ) {\n int t = ( i & 0x7F ) >> 2 ;\n if ( t < 16 ) framerate = ( AVRational ) {\n 1 , t + 1 }\n ;\n else framerate = ( AVRational ) {\n t - 15 , 1 }\n ;\n if ( i & 1 ) {\n framerate . num *= 1000 ;\n framerate . den *= 1001 ;\n }\n if ( ( i & 3 ) == 3 ) framerate . num *= 24 ;\n else if ( ( i & 3 ) == 2 ) framerate . num *= 25 ;\n else framerate . num *= 30 ;\n }\n else framerate = ( AVRational ) {\n i , 1 }\n ;\n nsv -> avsync = avio_rl16 ( pb ) ;\n nsv -> framerate = framerate ;\n av_log ( s , AV_LOG_TRACE , \"NSV NSVs vsize %dx%d\\n\" , vwidth , vheight ) ;\n if ( s -> nb_streams == 0 ) {\n nsv -> vtag = vtag ;\n nsv -> atag = atag ;\n nsv -> vwidth = vwidth ;\n nsv -> vheight = vwidth ;\n if ( vtag != T_NONE ) {\n int i ;\n st = avformat_new_stream ( s , NULL ) ;\n if ( ! st ) goto fail ;\n st -> id = NSV_ST_VIDEO ;\n nst = av_mallocz ( sizeof ( NSVStream ) ) ;\n if ( ! nst ) goto fail ;\n st -> priv_data = nst ;\n st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ;\n st -> codecpar -> codec_tag = vtag ;\n st -> codecpar -> codec_id = ff_codec_get_id ( nsv_codec_video_tags , vtag ) ;\n st -> codecpar -> width = vwidth ;\n st -> codecpar -> height = vheight ;\n st -> codecpar -> bits_per_coded_sample = 24 ;\n avpriv_set_pts_info ( st , 64 , framerate . den , framerate . num ) ;\n st -> start_time = 0 ;\n st -> duration = av_rescale ( nsv -> duration , framerate . num , 1000 * framerate . den ) ;\n for ( i = 0 ;\n i < nsv -> index_entries ;\n i ++ ) {\n if ( nsv -> nsvs_timestamps ) {\n av_add_index_entry ( st , nsv -> nsvs_file_offset [ i ] , nsv -> nsvs_timestamps [ i ] , 0 , 0 , AVINDEX_KEYFRAME ) ;\n }\n else {\n int64_t ts = av_rescale ( i * nsv -> durationsv -> index_entries , framerate . num , 1000 * framerate . den ) ;\n av_add_index_entry ( st , nsv -> nsvs_file_offset [ i ] , ts , 0 , 0 , AVINDEX_KEYFRAME ) ;\n }\n }\n }\n if ( atag != T_NONE ) {\n st = avformat_new_stream ( s , NULL ) ;\n if ( ! st ) goto fail ;\n st -> id = NSV_ST_AUDIO ;\n nst = av_mallocz ( sizeof ( NSVStream ) ) ;\n if ( ! nst ) goto fail ;\n st -> priv_data = nst ;\n st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ;\n st -> codecpar -> codec_tag = atag ;\n st -> codecpar -> codec_id = ff_codec_get_id ( nsv_codec_audio_tags , atag ) ;\n st -> need_parsing = AVSTREAM_PARSE_FULL ;\n avpriv_set_pts_info ( st , 64 , 1 , framerate . num * 1000 ) ;\n st -> start_time = 0 ;\n st -> duration = ( int64_t ) nsv -> duration * framerate . num ;\n }\n }\n else {\n if ( nsv -> vtag != vtag || nsv -> atag != atag || nsv -> vwidth != vwidth || nsv -> vheight != vwidth ) {\n av_log ( s , AV_LOG_TRACE , \"NSV NSVs header values differ from the first one!!!\\n\" ) ;\n }\n }\n nsv -> state = NSV_HAS_READ_NSVS ;\n return 0 ;\n fail : nsv -> state = NSV_UNSYNC ;\n return - 1 ;\n }", "hash": 6138954447623141313, "project": "debian", "size": 97, "target": 0, "idx": 9234}
{"code": "static int SpoolssReplyOpenPrinter_r ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep _U_ ) {\n dcerpc_call_value * dcv = ( dcerpc_call_value * ) di -> call_data ;\n e_ctx_hnd policy_hnd ;\n proto_item * hnd_item ;\n guint32 status ;\n offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , & policy_hnd , & hnd_item , TRUE , FALSE ) ;\n offset = dissect_doserror ( tvb , offset , pinfo , tree , di , drep , hf_rc , & status ) ;\n if ( status == 0 ) {\n const char * pol_name ;\n if ( dcv -> se_data ) {\n pol_name = wmem_strdup_printf ( wmem_packet_scope ( ) , \"ReplyOpenPrinter(%s)\" , ( char * ) dcv -> se_data ) ;\n }\n else {\n pol_name = \"Unknown ReplyOpenPrinter() handle\" ;\n }\n if ( ! pinfo -> fd -> flags . visited ) {\n dcerpc_store_polhnd_name ( & policy_hnd , pinfo , pol_name ) ;\n }\n if ( hnd_item ) proto_item_append_text ( hnd_item , \": %s\" , pol_name ) ;\n }\n return offset ;\n }", "hash": -6552851419396579257, "project": "debian", "size": 22, "target": 0, "idx": 9256}
{"code": "static int SpoolssEnumPrinterKey_r ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n offset = dissect_spoolss_keybuffer ( tvb , offset , pinfo , tree , di , drep ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_needed , NULL ) ;\n offset = dissect_doserror ( tvb , offset , pinfo , tree , di , drep , hf_rc , NULL ) ;\n return offset ;\n }", "hash": -6552851419396579257, "project": "debian", "size": 6, "target": 0, "idx": 9257}
{"code": "static int SpoolssGetPrinterDriverDirectory_q ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n guint32 level ;\n offset = dissect_ndr_str_pointer_item ( tvb , offset , pinfo , tree , di , drep , NDR_POINTER_UNIQUE , \"Name\" , hf_servername , 0 ) ;\n offset = dissect_ndr_str_pointer_item ( tvb , offset , pinfo , tree , di , drep , NDR_POINTER_UNIQUE , \"Environment\" , hf_environment , 0 ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_level , & level ) ;\n offset = dissect_spoolss_buffer ( tvb , offset , pinfo , tree , di , drep , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_offered , NULL ) ;\n return offset ;\n }", "hash": -6552851419396579257, "project": "debian", "size": 9, "target": 0, "idx": 9271}
{"code": "static int dissect_job_status ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n guint32 status ;\n static const int * hf_status [ ] = {\n & hf_job_status_user_intervention , & hf_job_status_blocked , & hf_job_status_deleted , & hf_job_status_printed , & hf_job_status_paperout , & hf_job_status_offline , & hf_job_status_printing , & hf_job_status_spooling , & hf_job_status_deleting , & hf_job_status_error , & hf_job_status_paused , NULL }\n ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , NULL , di , drep , - 1 , & status ) ;\n proto_tree_add_bitmask_value_with_flags ( tree , tvb , offset - 4 , hf_job_status , ett_job_status , hf_status , status , BMT_NO_APPEND ) ;\n return offset ;\n }", "hash": -6552851419396579257, "project": "debian", "size": 9, "target": 0, "idx": 9274}
{"code": "static void cb_notify_str_postprocess ( packet_info * pinfo _U_ , proto_tree * tree _U_ , proto_item * item , dcerpc_info * di _U_ , tvbuff_t * tvb , int start_offset , int end_offset , void * callback_args ) {\n gint levels , hf_index = GPOINTER_TO_INT ( callback_args ) ;\n guint32 len ;\n char * s ;\n proto_item * hidden_item ;\n if ( start_offset % 4 ) start_offset += 4 - ( start_offset % 4 ) ;\n len = tvb_get_letohl ( tvb , start_offset ) ;\n s = tvb_get_string_enc ( NULL , tvb , start_offset + 4 , ( end_offset - start_offset - 4 ) , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ;\n levels = 2 ;\n if ( levels > 0 && item && s && s [ 0 ] ) {\n proto_item_append_text ( item , \": %s\" , s ) ;\n item = item -> parent ;\n levels -- ;\n if ( levels > 0 ) {\n proto_item_append_text ( item , \": %s\" , s ) ;\n item = item -> parent ;\n levels -- ;\n while ( levels > 0 ) {\n proto_item_append_text ( item , \" %s\" , s ) ;\n item = item -> parent ;\n levels -- ;\n }\n }\n }\n if ( hf_index != - 1 ) {\n hidden_item = proto_tree_add_string ( tree , hf_index , tvb , start_offset , len , s ) ;\n PROTO_ITEM_SET_HIDDEN ( hidden_item ) ;\n }\n g_free ( s ) ;\n }", "hash": -6552851419396579257, "project": "debian", "size": 30, "target": 0, "idx": 9288}
{"code": "static int dissect_printer_attributes ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n guint32 attributes ;\n static const int * hf_attributes [ ] = {\n & hf_printer_attributes_published , & hf_printer_attributes_raw_only , & hf_printer_attributes_enable_bidi , & hf_printer_attributes_work_offline , & hf_printer_attributes_do_complete_first , & hf_printer_attributes_keep_printed_jobs , & hf_printer_attributes_enable_devq , & hf_printer_attributes_local , & hf_printer_attributes_hidden , & hf_printer_attributes_network , & hf_printer_attributes_shared , & hf_printer_attributes_default , & hf_printer_attributes_direct , & hf_printer_attributes_queued , NULL }\n ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , NULL , di , drep , - 1 , & attributes ) ;\n proto_tree_add_bitmask_value_with_flags ( tree , tvb , offset - 4 , hf_printer_attributes , ett_printer_attributes , hf_attributes , attributes , BMT_NO_APPEND ) ;\n return offset ;\n }", "hash": -6552851419396579257, "project": "debian", "size": 9, "target": 0, "idx": 9292}
{"code": "static int dissect_spoolss_printer_enum_values ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n guint32 start_offset = offset ;\n guint32 name_offset , name_len , val_offset , val_len , val_type ;\n char * name ;\n proto_item * item ;\n proto_tree * subtree ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , NULL , di , drep , hf_enumprinterdataex_name_offset , & name_offset ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , NULL , di , drep , hf_enumprinterdataex_name_len , & name_len ) ;\n dissect_spoolss_uint16uni ( tvb , start_offset + name_offset , pinfo , NULL , drep , & name , hf_enumprinterdataex_name ) ;\n subtree = proto_tree_add_subtree_format ( tree , tvb , offset , 0 , ett_printer_enumdataex_value , & item , \"Name: %s\" , name ) ;\n proto_tree_add_uint ( subtree , hf_enumprinterdataex_name_offset , tvb , offset - 8 , 4 , name_offset ) ;\n proto_tree_add_uint ( subtree , hf_enumprinterdataex_name_len , tvb , offset - 4 , 4 , name_len ) ;\n proto_tree_add_string ( subtree , hf_enumprinterdataex_name , tvb , start_offset + name_offset , ( ( int ) strlen ( name ) + 1 ) * 2 , name ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_printerdata_type , & val_type ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_enumprinterdataex_val_offset , & val_offset ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_enumprinterdataex_val_len , & val_len ) ;\n if ( val_len == 0 ) {\n proto_tree_add_uint_format_value ( subtree , hf_enumprinterdataex_value_null , tvb , start_offset + val_offset , 4 , 0 , \"(null)\" ) ;\n goto done ;\n }\n switch ( val_type ) {\n case DCERPC_REG_DWORD : {\n guint32 value ;\n guint16 low , high ;\n int offset2 = start_offset + val_offset ;\n offset2 = dissect_ndr_uint16 ( tvb , offset2 , pinfo , subtree , di , drep , hf_enumprinterdataex_val_dword_low , & low ) ;\n dissect_ndr_uint16 ( tvb , offset2 , pinfo , subtree , di , drep , hf_enumprinterdataex_val_dword_high , & high ) ;\n value = ( high << 16 ) | low ;\n proto_tree_add_uint ( subtree , hf_enumprinterdataex_value_uint , tvb , start_offset + val_offset , 4 , value ) ;\n proto_item_append_text ( item , \", Value: %d\" , value ) ;\n break ;\n }\n case DCERPC_REG_SZ : {\n char * value ;\n dissect_spoolss_uint16uni ( tvb , start_offset + val_offset , pinfo , subtree , drep , & value , hf_value_string ) ;\n proto_item_append_text ( item , \", Value: %s\" , value ) ;\n g_free ( value ) ;\n break ;\n }\n case DCERPC_REG_BINARY : proto_tree_add_bytes_format_value ( subtree , hf_enumprinterdataex_value_binary , tvb , start_offset + val_offset , val_len , NULL , \"<binary data>\" ) ;\n break ;\n case DCERPC_REG_MULTI_SZ : proto_tree_add_bytes_format_value ( subtree , hf_enumprinterdataex_value_multi_sz , tvb , start_offset + val_offset , val_len , NULL , \"<REG_MULTI_SZ not implemented>\" ) ;\n break ;\n default : proto_tree_add_expert_format ( subtree , pinfo , & ei_enumprinterdataex_value , tvb , start_offset + val_offset , val_len , \"%s: unknown type %d\" , name , val_type ) ;\n }\n done : g_free ( name ) ;\n return offset ;\n }", "hash": -6552851419396579257, "project": "debian", "size": 48, "target": 0, "idx": 9303}
{"code": "static int dissect_NOTIFY_INFO_DATA_printer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , proto_item * item , dcerpc_info * di , guint8 * drep , guint16 field ) {\n guint32 value1 ;\n switch ( field ) {\n case PRINTER_NOTIFY_SERVER_NAME : case PRINTER_NOTIFY_PRINTER_NAME : case PRINTER_NOTIFY_SHARE_NAME : case PRINTER_NOTIFY_DRIVER_NAME : case PRINTER_NOTIFY_COMMENT : case PRINTER_NOTIFY_LOCATION : case PRINTER_NOTIFY_SEPFILE : case PRINTER_NOTIFY_PRINT_PROCESSOR : case PRINTER_NOTIFY_PARAMETERS : case PRINTER_NOTIFY_DATATYPE : case PRINTER_NOTIFY_PORT_NAME : offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_notify_info_data_bufsize , & value1 ) ;\n offset = dissect_ndr_pointer_cb ( tvb , offset , pinfo , tree , di , drep , dissect_notify_info_data_buffer , NDR_POINTER_UNIQUE , \"String\" , hf_notify_info_data_buffer , cb_notify_str_postprocess , GINT_TO_POINTER ( printer_notify_hf_index ( field ) ) ) ;\n break ;\n case PRINTER_NOTIFY_ATTRIBUTES : offset = dissect_printer_attributes ( tvb , offset , pinfo , tree , di , drep ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , NULL , di , drep , hf_notify_info_data_value2 , NULL ) ;\n break ;\n case PRINTER_NOTIFY_STATUS : {\n guint32 status ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_printer_status , & status ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , NULL , di , drep , hf_notify_info_data_value2 , NULL ) ;\n proto_item_append_text ( item , \": %s\" , val_to_str_ext_const ( status , & printer_status_vals_ext , \"Unknown\" ) ) ;\n break ;\n }\n case PRINTER_NOTIFY_SECURITY_DESCRIPTOR : case PRINTER_NOTIFY_DEVMODE : offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_notify_info_data_bufsize , & value1 ) ;\n offset = dissect_ndr_pointer ( tvb , offset , pinfo , tree , di , drep , dissect_notify_info_data_buffer , NDR_POINTER_UNIQUE , \"Buffer\" , hf_notify_info_data_buffer ) ;\n break ;\n default : offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_notify_info_data_value1 , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_notify_info_data_value2 , NULL ) ;\n break ;\n }\n return offset ;\n }", "hash": -6552851419396579257, "project": "debian", "size": 25, "target": 0, "idx": 9308}
{"code": "static int dissect_SPOOL_PRINTER_INFO ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n proto_tree * subtree ;\n guint32 level ;\n proto_tree * item ;\n subtree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_SPOOL_PRINTER_INFO_LEVEL , & item , \"Spool printer info level\" ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_level , & level ) ;\n switch ( level ) {\n case 3 : {\n guint32 devmode_ptr , secdesc_ptr ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_spool_printer_info_devmode_ptr , & devmode_ptr ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_spool_printer_info_secdesc_ptr , & secdesc_ptr ) ;\n if ( devmode_ptr ) offset = dissect_DEVMODE_CTR ( tvb , offset , pinfo , subtree , di , drep ) ;\n if ( secdesc_ptr ) offset = dissect_SEC_DESC_BUF ( tvb , offset , pinfo , subtree , di , drep ) ;\n break ;\n }\n case 2 : default : expert_add_info_format ( pinfo , item , & ei_spool_printer_info_level , \"Unknown spool printer info level %d\" , level ) ;\n break ;\n }\n return offset ;\n }", "hash": -6552851419396579257, "project": "debian", "size": 20, "target": 0, "idx": 9310}
{"code": "static int SpoolssAddForm_r ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep _U_ ) {\n proto_item * hidden_item ;\n hidden_item = proto_tree_add_uint ( tree , hf_form , tvb , offset , 0 , 1 ) ;\n PROTO_ITEM_SET_HIDDEN ( hidden_item ) ;\n offset = dissect_doserror ( tvb , offset , pinfo , tree , di , drep , hf_rc , NULL ) ;\n return offset ;\n }", "hash": -6552851419396579257, "project": "debian", "size": 7, "target": 0, "idx": 9339}
{"code": "static int dissect_PRINTER_INFO_1 ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_printer_flags , NULL ) ;\n offset = dissect_spoolss_relstr ( tvb , offset , pinfo , tree , di , drep , hf_printerdesc , 0 , NULL ) ;\n offset = dissect_spoolss_relstr ( tvb , offset , pinfo , tree , di , drep , hf_printername , 0 , NULL ) ;\n offset = dissect_spoolss_relstr ( tvb , offset , pinfo , tree , di , drep , hf_printercomment , 0 , NULL ) ;\n return offset ;\n }", "hash": -6552851419396579257, "project": "debian", "size": 7, "target": 0, "idx": 9342}
{"code": "void pdf_map_range_to_range ( fz_context * ctx , pdf_cmap * cmap , unsigned int low , unsigned int high , int out ) {\n add_range ( ctx , cmap , low , high , out , 1 , 0 ) ;\n }", "hash": -7042392412001533358, "project": "debian", "size": 3, "target": 0, "idx": 9399}
{"code": "static int rm_read_close ( AVFormatContext * s ) {\n int i ;\n for ( i = 0 ;\n i < s -> nb_streams ;\n i ++ ) ff_rm_free_rmstream ( s -> streams [ i ] -> priv_data ) ;\n return 0 ;\n }", "hash": -649112636673899765, "project": "debian", "size": 7, "target": 0, "idx": 9422}
{"code": "static int readfull ( AVFormatContext * s , AVIOContext * pb , uint8_t * dst , int n ) {\n int ret = avio_read ( pb , dst , n ) ;\n if ( ret != n ) {\n if ( ret >= 0 ) memset ( dst + ret , 0 , n - ret ) ;\n else memset ( dst , 0 , n ) ;\n av_log ( s , AV_LOG_ERROR , \"Failed to fully read block\\n\" ) ;\n }\n return ret ;\n }", "hash": -649112636673899765, "project": "debian", "size": 9, "target": 0, "idx": 9425}
{"code": "static inline void rm_ac3_swap_bytes ( AVStream * st , AVPacket * pkt ) {\n uint8_t * ptr ;\n int j ;\n if ( st -> codecpar -> codec_id == AV_CODEC_ID_AC3 ) {\n ptr = pkt -> data ;\n for ( j = 0 ;\n j < pkt -> size ;\n j += 2 ) {\n FFSWAP ( int , ptr [ 0 ] , ptr [ 1 ] ) ;\n ptr += 2 ;\n }\n }\n }", "hash": -649112636673899765, "project": "debian", "size": 13, "target": 0, "idx": 9429}
{"code": "static int rm_read_header ( AVFormatContext * s ) {\n RMDemuxContext * rm = s -> priv_data ;\n AVStream * st ;\n AVIOContext * pb = s -> pb ;\n unsigned int tag ;\n int tag_size ;\n unsigned int start_time , duration ;\n unsigned int data_off = 0 , indx_off = 0 ;\n char buf [ 128 ] , mime [ 128 ] ;\n int flags = 0 ;\n int ret = - 1 ;\n unsigned size , v ;\n int64_t codec_pos ;\n tag = avio_rl32 ( pb ) ;\n if ( tag == MKTAG ( '.' , 'r' , 'a' , 0xfd ) ) {\n return rm_read_header_old ( s ) ;\n }\n else if ( tag != MKTAG ( '.' , 'R' , 'M' , 'F' ) ) {\n return AVERROR ( EIO ) ;\n }\n tag_size = avio_rb32 ( pb ) ;\n avio_skip ( pb , tag_size - 8 ) ;\n for ( ;\n ;\n ) {\n if ( avio_feof ( pb ) ) goto fail ;\n tag = avio_rl32 ( pb ) ;\n tag_size = avio_rb32 ( pb ) ;\n avio_rb16 ( pb ) ;\n av_log ( s , AV_LOG_TRACE , \"tag=%s size=%d\\n\" , av_fourcc2str ( tag ) , tag_size ) ;\n if ( tag_size < 10 && tag != MKTAG ( 'D' , 'A' , 'T' , 'A' ) ) goto fail ;\n switch ( tag ) {\n case MKTAG ( 'P' , 'R' , 'O' , 'P' ) : avio_rb32 ( pb ) ;\n avio_rb32 ( pb ) ;\n avio_rb32 ( pb ) ;\n avio_rb32 ( pb ) ;\n avio_rb32 ( pb ) ;\n duration = avio_rb32 ( pb ) ;\n s -> duration = av_rescale ( duration , AV_TIME_BASE , 1000 ) ;\n avio_rb32 ( pb ) ;\n indx_off = avio_rb32 ( pb ) ;\n data_off = avio_rb32 ( pb ) ;\n avio_rb16 ( pb ) ;\n flags = avio_rb16 ( pb ) ;\n break ;\n case MKTAG ( 'C' , 'O' , 'N' , 'T' ) : rm_read_metadata ( s , pb , 1 ) ;\n break ;\n case MKTAG ( 'M' , 'D' , 'P' , 'R' ) : st = avformat_new_stream ( s , NULL ) ;\n if ( ! st ) {\n ret = AVERROR ( ENOMEM ) ;\n goto fail ;\n }\n st -> id = avio_rb16 ( pb ) ;\n avio_rb32 ( pb ) ;\n st -> codecpar -> bit_rate = avio_rb32 ( pb ) ;\n avio_rb32 ( pb ) ;\n avio_rb32 ( pb ) ;\n start_time = avio_rb32 ( pb ) ;\n avio_rb32 ( pb ) ;\n duration = avio_rb32 ( pb ) ;\n st -> start_time = start_time ;\n st -> duration = duration ;\n if ( duration > 0 ) s -> duration = AV_NOPTS_VALUE ;\n get_str8 ( pb , buf , sizeof ( buf ) ) ;\n get_str8 ( pb , mime , sizeof ( mime ) ) ;\n st -> codecpar -> codec_type = AVMEDIA_TYPE_DATA ;\n st -> priv_data = ff_rm_alloc_rmstream ( ) ;\n if ( ! st -> priv_data ) return AVERROR ( ENOMEM ) ;\n size = avio_rb32 ( pb ) ;\n codec_pos = avio_tell ( pb ) ;\n ffio_ensure_seekback ( pb , 4 ) ;\n v = avio_rb32 ( pb ) ;\n if ( v == MKBETAG ( 'M' , 'L' , 'T' , 'I' ) ) {\n ret = rm_read_multi ( s , s -> pb , st , mime ) ;\n if ( ret < 0 ) goto fail ;\n avio_seek ( pb , codec_pos + size , SEEK_SET ) ;\n }\n else {\n avio_skip ( pb , - 4 ) ;\n if ( ff_rm_read_mdpr_codecdata ( s , s -> pb , st , st -> priv_data , size , mime ) < 0 ) goto fail ;\n }\n break ;\n case MKTAG ( 'D' , 'A' , 'T' , 'A' ) : goto header_end ;\n default : avio_skip ( pb , tag_size - 10 ) ;\n break ;\n }\n }\n header_end : rm -> nb_packets = avio_rb32 ( pb ) ;\n if ( ! rm -> nb_packets && ( flags & 4 ) ) rm -> nb_packets = 3600 * 25 ;\n avio_rb32 ( pb ) ;\n if ( ! data_off ) data_off = avio_tell ( pb ) - 18 ;\n if ( indx_off && ( pb -> seekable & AVIO_SEEKABLE_NORMAL ) && ! ( s -> flags & AVFMT_FLAG_IGNIDX ) && avio_seek ( pb , indx_off , SEEK_SET ) >= 0 ) {\n rm_read_index ( s ) ;\n avio_seek ( pb , data_off + 18 , SEEK_SET ) ;\n }\n return 0 ;\n fail : rm_read_close ( s ) ;\n return ret ;\n }", "hash": -649112636673899765, "project": "debian", "size": 99, "target": 0, "idx": 9430}
{"code": "SRP_user_pwd * SRP_VBASE_get_by_user ( SRP_VBASE * vb , char * username ) {\n return find_user ( vb , username ) ;\n }", "hash": -331579171381918893, "project": "debian", "size": 3, "target": 0, "idx": 9452}
{"code": "int SRP_create_verifier_BN ( const char * user , const char * pass , BIGNUM * * salt , BIGNUM * * verifier , BIGNUM * N , BIGNUM * g ) {\n int result = 0 ;\n BIGNUM * x = NULL ;\n BN_CTX * bn_ctx = BN_CTX_new ( ) ;\n unsigned char tmp2 [ MAX_LEN ] ;\n BIGNUM * salttmp = NULL ;\n if ( ( user == NULL ) || ( pass == NULL ) || ( salt == NULL ) || ( verifier == NULL ) || ( N == NULL ) || ( g == NULL ) || ( bn_ctx == NULL ) ) goto err ;\n srp_bn_print ( N ) ;\n srp_bn_print ( g ) ;\n if ( * salt == NULL ) {\n if ( RAND_pseudo_bytes ( tmp2 , SRP_RANDOM_SALT_LEN ) < 0 ) goto err ;\n salttmp = BN_bin2bn ( tmp2 , SRP_RANDOM_SALT_LEN , NULL ) ;\n }\n else {\n salttmp = * salt ;\n }\n x = SRP_Calc_x ( salttmp , user , pass ) ;\n * verifier = BN_new ( ) ;\n if ( * verifier == NULL ) goto err ;\n if ( ! BN_mod_exp ( * verifier , g , x , N , bn_ctx ) ) {\n BN_clear_free ( * verifier ) ;\n goto err ;\n }\n srp_bn_print ( * verifier ) ;\n result = 1 ;\n * salt = salttmp ;\n err : if ( * salt != salttmp ) BN_clear_free ( salttmp ) ;\n BN_clear_free ( x ) ;\n BN_CTX_free ( bn_ctx ) ;\n return result ;\n }", "hash": -331579171381918893, "project": "debian", "size": 31, "target": 0, "idx": 9465}
{"code": "static SRP_gN * SRP_get_gN_by_id ( const char * id , STACK_OF ( SRP_gN ) * gN_tab ) {\n int i ;\n SRP_gN * gN ;\n if ( gN_tab != NULL ) for ( i = 0 ;\n i < sk_SRP_gN_num ( gN_tab ) ;\n i ++ ) {\n gN = sk_SRP_gN_value ( gN_tab , i ) ;\n if ( gN && ( id == NULL || strcmp ( gN -> id , id ) == 0 ) ) return gN ;\n }\n return SRP_get_default_gN ( id ) ;\n }", "hash": -331579171381918893, "project": "debian", "size": 11, "target": 0, "idx": 9466}
{"code": "static inline void pcnet_rmd_store ( PCNetState * s , struct pcnet_RMD * rmd , hwaddr addr ) {\n if ( ! BCR_SSIZE32 ( s ) ) {\n struct {\n uint32_t rbadr ;\n int16_t buf_length ;\n int16_t msg_length ;\n }\n rda ;\n rda . rbadr = cpu_to_le32 ( ( rmd -> rbadr & 0xffffff ) | ( ( rmd -> status & 0xff00 ) << 16 ) ) ;\n rda . buf_length = cpu_to_le16 ( rmd -> buf_length ) ;\n rda . msg_length = cpu_to_le16 ( rmd -> msg_length ) ;\n s -> phys_mem_write ( s -> dma_opaque , addr , ( void * ) & rda , sizeof ( rda ) , 0 ) ;\n }\n else {\n struct {\n uint32_t rbadr ;\n int16_t buf_length ;\n int16_t status ;\n uint32_t msg_length ;\n uint32_t res ;\n }\n rda ;\n rda . rbadr = cpu_to_le32 ( rmd -> rbadr ) ;\n rda . buf_length = cpu_to_le16 ( rmd -> buf_length ) ;\n rda . status = cpu_to_le16 ( rmd -> status ) ;\n rda . msg_length = cpu_to_le32 ( rmd -> msg_length ) ;\n rda . res = cpu_to_le32 ( rmd -> res ) ;\n if ( BCR_SWSTYLE ( s ) == 3 ) {\n uint32_t tmp = rda . rbadr ;\n rda . rbadr = rda . msg_length ;\n rda . msg_length = tmp ;\n }\n s -> phys_mem_write ( s -> dma_opaque , addr , ( void * ) & rda , sizeof ( rda ) , 0 ) ;\n }\n }", "hash": 8193534372312945122, "project": "debian", "size": 35, "target": 0, "idx": 9490}
{"code": "static inline int64_t pcnet_get_next_poll_time ( PCNetState * s , int64_t current_time ) {\n int64_t next_time = current_time + ( 65536 - ( CSR_SPND ( s ) ? 0 : CSR_POLL ( s ) ) ) * 30 ;\n if ( next_time <= current_time ) {\n next_time = current_time + 1 ;\n }\n return next_time ;\n }", "hash": 8193534372312945122, "project": "debian", "size": 7, "target": 0, "idx": 9491}
{"code": "static void Win32WarningHandler ( const char * module , const char * fmt , va_list ap ) {\n # ifndef TIF_PLATFORM_CONSOLE LPTSTR szTitle ;\n LPTSTR szTmp ;\n LPCTSTR szTitleText = \"%s Warning\" ;\n LPCTSTR szDefaultModule = \"LIBTIFF\" ;\n LPCTSTR szTmpModule = ( module == NULL ) ? szDefaultModule : module ;\n SIZE_T nBufSize = ( strlen ( szTmpModule ) + strlen ( szTitleText ) + strlen ( fmt ) + 256 ) * sizeof ( char ) ;\n if ( ( szTitle = ( LPTSTR ) LocalAlloc ( LMEM_FIXED , nBufSize ) ) == NULL ) return ;\n sprintf ( szTitle , szTitleText , szTmpModule ) ;\n szTmp = szTitle + ( strlen ( szTitle ) + 2 ) * sizeof ( char ) ;\n vsnprintf ( szTmp , nBufSize - ( strlen ( szTitle ) + 2 ) * sizeof ( char ) , fmt , ap ) ;\n MessageBoxA ( GetFocus ( ) , szTmp , szTitle , MB_OK | MB_ICONINFORMATION ) ;\n LocalFree ( szTitle ) ;\n return ;\n # else if ( module != NULL ) fprintf ( stderr , \"%s: \" , module ) ;\n fprintf ( stderr , \"Warning, \" ) ;\n vfprintf ( stderr , fmt , ap ) ;\n fprintf ( stderr , \".\\n\" ) ;\n # endif }", "hash": -3725939782329394029, "project": "debian", "size": 19, "target": 0, "idx": 9505}
{"code": "tdata_t _TIFFrealloc ( tdata_t p , tsize_t s ) {\n return ( realloc ( p , ( size_t ) s ) ) ;\n }", "hash": -6468986929796051453, "project": "debian", "size": 3, "target": 0, "idx": 9530}
{"code": "static toff_t _tiffSizeProc ( thandle_t fd ) {\n _TIFF_stat_s sb ;\n return ( toff_t ) ( _TIFF_fstat_f ( ( int ) fd , & sb ) < 0 ? 0 : sb . st_size ) ;\n }", "hash": -6468986929796051453, "project": "debian", "size": 4, "target": 0, "idx": 9533}
{"code": "static void vmsWarningHandler ( const char * module , const char * fmt , va_list ap ) {\n if ( module != NULL ) fprintf ( stderr , \"%s: \" , module ) ;\n fprintf ( stderr , \"Warning, \" ) ;\n vfprintf ( stderr , fmt , ap ) ;\n fprintf ( stderr , \".\\n\" ) ;\n }", "hash": -6468986929796051453, "project": "debian", "size": 6, "target": 0, "idx": 9536}
{"code": "static int _tiffCloseProc ( thandle_t fd ) {\n fd_as_handle_union_t fdh ;\n fdh . h = fd ;\n return ( close ( fdh . fd ) ) ;\n }", "hash": -3630680866895641146, "project": "debian", "size": 5, "target": 0, "idx": 9549}
{"code": "static void pdf_run_q ( fz_context * ctx , pdf_processor * proc ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gsave ( ctx , pr ) ;\n }", "hash": -2423144171479606949, "project": "debian", "size": 4, "target": 0, "idx": 9570}
{"code": "static void end_softmask ( fz_context * ctx , pdf_run_processor * pr , softmask_save * save ) {\n pdf_gstate * gstate = pr -> gstate + pr -> gtop ;\n if ( save -> softmask == NULL ) return ;\n gstate -> softmask = save -> softmask ;\n gstate -> softmask_resources = save -> page_resources ;\n gstate -> softmask_ctm = save -> ctm ;\n fz_pop_clip ( ctx , pr -> dev ) ;\n }", "hash": -2423144171479606949, "project": "debian", "size": 8, "target": 0, "idx": 9571}
{"code": "static void pdf_unset_pattern ( fz_context * ctx , pdf_run_processor * pr , int what ) {\n pdf_gstate * gs = pr -> gstate + pr -> gtop ;\n pdf_material * mat ;\n mat = what == PDF_FILL ? & gs -> fill : & gs -> stroke ;\n if ( mat -> kind == PDF_MAT_PATTERN ) {\n pdf_drop_pattern ( ctx , mat -> pattern ) ;\n mat -> pattern = NULL ;\n mat -> kind = PDF_MAT_COLOR ;\n }\n }", "hash": -2423144171479606949, "project": "debian", "size": 10, "target": 0, "idx": 9578}
{"code": "static pdf_gstate * begin_softmask ( fz_context * ctx , pdf_run_processor * pr , softmask_save * save ) {\n pdf_gstate * gstate = pr -> gstate + pr -> gtop ;\n pdf_xobject * softmask = gstate -> softmask ;\n fz_rect mask_bbox ;\n fz_matrix tos_save [ 2 ] , save_ctm ;\n fz_matrix mask_matrix ;\n fz_colorspace * mask_colorspace ;\n save -> softmask = softmask ;\n if ( softmask == NULL ) return gstate ;\n save -> page_resources = gstate -> softmask_resources ;\n save -> ctm = gstate -> softmask_ctm ;\n save_ctm = gstate -> ctm ;\n pdf_xobject_bbox ( ctx , softmask , & mask_bbox ) ;\n pdf_xobject_matrix ( ctx , softmask , & mask_matrix ) ;\n pdf_tos_save ( ctx , & pr -> tos , tos_save ) ;\n if ( gstate -> luminosity ) mask_bbox = fz_infinite_rect ;\n else {\n fz_transform_rect ( & mask_bbox , & mask_matrix ) ;\n fz_transform_rect ( & mask_bbox , & gstate -> softmask_ctm ) ;\n }\n gstate -> softmask = NULL ;\n gstate -> softmask_resources = NULL ;\n gstate -> ctm = gstate -> softmask_ctm ;\n mask_colorspace = pdf_xobject_colorspace ( ctx , softmask ) ;\n if ( gstate -> luminosity && ! mask_colorspace ) mask_colorspace = fz_keep_colorspace ( ctx , fz_device_gray ( ctx ) ) ;\n fz_try ( ctx ) {\n fz_begin_mask ( ctx , pr -> dev , & mask_bbox , gstate -> luminosity , mask_colorspace , gstate -> softmask_bc , & gstate -> fill . color_params ) ;\n pdf_run_xobject ( ctx , pr , softmask , save -> page_resources , & fz_identity , 1 ) ;\n }\n fz_always ( ctx ) fz_drop_colorspace ( ctx , mask_colorspace ) ;\n fz_catch ( ctx ) {\n fz_rethrow_if ( ctx , FZ_ERROR_TRYLATER ) ;\n }\n fz_end_mask ( ctx , pr -> dev ) ;\n pdf_tos_restore ( ctx , & pr -> tos , tos_save ) ;\n gstate = pr -> gstate + pr -> gtop ;\n gstate -> ctm = save_ctm ;\n return gstate ;\n }", "hash": -2423144171479606949, "project": "debian", "size": 39, "target": 0, "idx": 9584}
{"code": "static void pdf_run_xobject ( fz_context * ctx , pdf_run_processor * proc , pdf_xobject * xobj , pdf_obj * page_resources , const fz_matrix * transform , int is_smask ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gstate * gstate = NULL ;\n int oldtop = 0 ;\n int oldbot = - 1 ;\n fz_matrix local_transform = * transform ;\n softmask_save softmask = {\n NULL }\n ;\n int gparent_save ;\n fz_matrix gparent_save_ctm ;\n int cleanup_state = 0 ;\n char errmess [ 256 ] = \"\" ;\n pdf_obj * resources ;\n fz_rect xobj_bbox ;\n fz_matrix xobj_matrix ;\n int transparency = 0 ;\n pdf_document * doc ;\n fz_colorspace * cs = NULL ;\n fz_default_colorspaces * saved_def_cs = NULL ;\n if ( xobj == NULL || pdf_mark_obj ( ctx , xobj -> obj ) ) return ;\n fz_var ( cleanup_state ) ;\n fz_var ( gstate ) ;\n fz_var ( oldtop ) ;\n fz_var ( oldbot ) ;\n fz_var ( cs ) ;\n fz_var ( saved_def_cs ) ;\n gparent_save = pr -> gparent ;\n pr -> gparent = pr -> gtop ;\n oldtop = pr -> gtop ;\n fz_try ( ctx ) {\n pdf_gsave ( ctx , pr ) ;\n gstate = pr -> gstate + pr -> gtop ;\n pdf_xobject_bbox ( ctx , xobj , & xobj_bbox ) ;\n pdf_xobject_matrix ( ctx , xobj , & xobj_matrix ) ;\n transparency = pdf_xobject_transparency ( ctx , xobj ) ;\n fz_concat ( & local_transform , & xobj_matrix , & local_transform ) ;\n fz_concat ( & gstate -> ctm , & local_transform , & gstate -> ctm ) ;\n gparent_save_ctm = pr -> gstate [ pr -> gparent ] . ctm ;\n pr -> gstate [ pr -> gparent ] . ctm = gstate -> ctm ;\n if ( transparency ) {\n fz_rect bbox ;\n int isolated = pdf_xobject_isolated ( ctx , xobj ) ;\n bbox = xobj_bbox ;\n fz_transform_rect ( & bbox , & gstate -> ctm ) ;\n cleanup_state = 1 ;\n gstate = begin_softmask ( ctx , pr , & softmask ) ;\n cleanup_state = 2 ;\n if ( isolated ) cs = pdf_xobject_colorspace ( ctx , xobj ) ;\n fz_begin_group ( ctx , pr -> dev , & bbox , cs , ( is_smask ? 1 : isolated ) , pdf_xobject_knockout ( ctx , xobj ) , gstate -> blendmode , gstate -> fill . alpha ) ;\n gstate -> blendmode = 0 ;\n gstate -> stroke . alpha = 1 ;\n gstate -> fill . alpha = 1 ;\n }\n cleanup_state = 3 ;\n pdf_gsave ( ctx , pr ) ;\n fz_moveto ( ctx , pr -> path , xobj_bbox . x0 , xobj_bbox . y0 ) ;\n fz_lineto ( ctx , pr -> path , xobj_bbox . x1 , xobj_bbox . y0 ) ;\n fz_lineto ( ctx , pr -> path , xobj_bbox . x1 , xobj_bbox . y1 ) ;\n fz_lineto ( ctx , pr -> path , xobj_bbox . x0 , xobj_bbox . y1 ) ;\n fz_closepath ( ctx , pr -> path ) ;\n pr -> clip = 1 ;\n pdf_show_path ( ctx , pr , 0 , 0 , 0 , 0 ) ;\n resources = pdf_xobject_resources ( ctx , xobj ) ;\n if ( ! resources ) resources = page_resources ;\n saved_def_cs = pr -> default_cs ;\n pr -> default_cs = NULL ;\n pr -> default_cs = pdf_update_default_colorspaces ( ctx , saved_def_cs , resources ) ;\n if ( pr -> default_cs != saved_def_cs ) fz_set_default_colorspaces ( ctx , pr -> dev , pr -> default_cs ) ;\n doc = pdf_get_bound_document ( ctx , xobj -> obj ) ;\n oldbot = pr -> gbot ;\n pr -> gbot = pr -> gtop ;\n pdf_process_contents ( ctx , ( pdf_processor * ) pr , doc , resources , xobj -> obj , NULL ) ;\n }\n fz_always ( ctx ) {\n fz_drop_colorspace ( ctx , cs ) ;\n if ( saved_def_cs ) {\n fz_drop_default_colorspaces ( ctx , pr -> default_cs ) ;\n pr -> default_cs = saved_def_cs ;\n fz_try ( ctx ) {\n fz_set_default_colorspaces ( ctx , pr -> dev , pr -> default_cs ) ;\n }\n fz_catch ( ctx ) {\n strcpy ( errmess , fz_caught_message ( ctx ) ) ;\n }\n }\n if ( oldbot != - 1 ) {\n while ( pr -> gtop > pr -> gbot ) {\n pdf_grestore ( ctx , pr ) ;\n }\n pr -> gbot = oldbot ;\n }\n if ( cleanup_state >= 3 ) pdf_grestore ( ctx , pr ) ;\n if ( transparency ) {\n if ( cleanup_state >= 2 ) {\n fz_try ( ctx ) {\n fz_end_group ( ctx , pr -> dev ) ;\n }\n fz_catch ( ctx ) {\n if ( errmess [ 0 ] ) fz_warn ( ctx , \"%s\" , errmess ) ;\n strcpy ( errmess , fz_caught_message ( ctx ) ) ;\n }\n }\n if ( cleanup_state >= 1 ) {\n fz_try ( ctx ) {\n end_softmask ( ctx , pr , & softmask ) ;\n }\n fz_catch ( ctx ) {\n if ( errmess [ 0 ] ) fz_warn ( ctx , \"%s\" , errmess ) ;\n strcpy ( errmess , fz_caught_message ( ctx ) ) ;\n }\n }\n }\n pr -> gstate [ pr -> gparent ] . ctm = gparent_save_ctm ;\n pr -> gparent = gparent_save ;\n while ( oldtop < pr -> gtop ) pdf_grestore ( ctx , pr ) ;\n pdf_unmark_obj ( ctx , xobj -> obj ) ;\n }\n fz_catch ( ctx ) {\n fz_rethrow ( ctx ) ;\n }\n if ( errmess [ 0 ] ) fz_throw ( ctx , FZ_ERROR_GENERIC , \"%s\" , errmess ) ;\n }", "hash": -2423144171479606949, "project": "debian", "size": 123, "target": 0, "idx": 9603}
{"code": "static void pdf_run_gs_BM ( fz_context * ctx , pdf_processor * proc , const char * blendmode ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gstate * gstate = pdf_flush_text ( ctx , pr ) ;\n gstate -> blendmode = fz_lookup_blendmode ( blendmode ) ;\n }", "hash": -2423144171479606949, "project": "debian", "size": 5, "target": 0, "idx": 9621}
{"code": "static void pdf_run_S ( fz_context * ctx , pdf_processor * proc ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_show_path ( ctx , pr , 0 , 0 , 1 , 0 ) ;\n }", "hash": -2423144171479606949, "project": "debian", "size": 4, "target": 0, "idx": 9629}
{"code": "static void pdf_run_SC_pattern ( fz_context * ctx , pdf_processor * proc , const char * name , pdf_pattern * pat , int n , float * color ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pr -> dev -> flags &= ~ FZ_DEVFLAG_STROKECOLOR_UNDEFINED ;\n pdf_set_pattern ( ctx , pr , PDF_STROKE , pat , color ) ;\n }", "hash": -2423144171479606949, "project": "debian", "size": 5, "target": 0, "idx": 9630}
{"code": "static void pdf_run_Tf ( fz_context * ctx , pdf_processor * proc , const char * name , pdf_font_desc * font , float size ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gstate * gstate = pr -> gstate + pr -> gtop ;\n pdf_drop_font ( ctx , gstate -> text . font ) ;\n gstate -> text . font = pdf_keep_font ( ctx , font ) ;\n gstate -> text . size = size ;\n }", "hash": -2423144171479606949, "project": "debian", "size": 7, "target": 0, "idx": 9665}
{"code": "static void pdf_set_color ( fz_context * ctx , pdf_run_processor * pr , int what , float * v ) {\n pdf_gstate * gstate = pr -> gstate + pr -> gtop ;\n pdf_material * mat ;\n gstate = pdf_flush_text ( ctx , pr ) ;\n mat = what == PDF_FILL ? & gstate -> fill : & gstate -> stroke ;\n switch ( mat -> kind ) {\n case PDF_MAT_PATTERN : case PDF_MAT_COLOR : fz_clamp_color ( ctx , mat -> colorspace , v , mat -> v ) ;\n break ;\n default : fz_warn ( ctx , \"color incompatible with material\" ) ;\n }\n mat -> gstate_num = pr -> gparent ;\n }", "hash": -2423144171479606949, "project": "debian", "size": 12, "target": 0, "idx": 9667}
{"code": "static char * fstrndup ( const char * ptr , unsigned long len ) {\n char * result ;\n if ( len <= 0 ) return NULL ;\n result = ALLOC_N ( char , len ) ;\n memcpy ( result , ptr , len ) ;\n return result ;\n }", "hash": 3668456668028959955, "project": "debian", "size": 7, "target": 0, "idx": 9697}
{"code": "static VALUE cState_max_nesting ( VALUE self ) {\n GET_STATE ( self ) ;\n return LONG2FIX ( state -> max_nesting ) ;\n }", "hash": 3668456668028959955, "project": "debian", "size": 4, "target": 0, "idx": 9713}
{"code": "static inline uint8_t NVRAM_get_byte ( m48t59_t * nvram , uint32_t addr ) {\n m48t59_set_addr ( nvram , addr ) ;\n return m48t59_read ( nvram ) ;\n }", "hash": 8460430819945784394, "project": "debian", "size": 4, "target": 0, "idx": 9756}
{"code": "static inline void qemu_put_be16s ( QEMUFile * f , const uint16_t * pv ) {\n qemu_put_be16 ( f , * pv ) ;\n }", "hash": 3487452046891662469, "project": "debian", "size": 3, "target": 0, "idx": 9780}
{"code": "static void virtio_net_reset ( VirtIODevice * vdev ) {\n VirtIONet * n = to_virtio_net ( vdev ) ;\n n -> promisc = 1 ;\n n -> allmulti = 0 ;\n n -> alluni = 0 ;\n n -> nomulti = 0 ;\n n -> nouni = 0 ;\n n -> nobcast = 0 ;\n n -> mac_table . in_use = 0 ;\n n -> mac_table . first_multi = 0 ;\n n -> mac_table . multi_overflow = 0 ;\n n -> mac_table . uni_overflow = 0 ;\n memset ( n -> mac_table . macs , 0 , MAC_TABLE_ENTRIES * ETH_ALEN ) ;\n memset ( n -> vlans , 0 , MAX_VLAN >> 3 ) ;\n }", "hash": -8365810778652022218, "project": "debian", "size": 15, "target": 0, "idx": 9804}
{"code": "static int virtio_net_handle_vlan_table ( VirtIONet * n , uint8_t cmd , VirtQueueElement * elem ) {\n uint16_t vid ;\n if ( elem -> out_num != 2 || elem -> out_sg [ 1 ] . iov_len != sizeof ( vid ) ) {\n error_report ( \"virtio-net ctrl invalid vlan command\" ) ;\n return VIRTIO_NET_ERR ;\n }\n vid = lduw_p ( elem -> out_sg [ 1 ] . iov_base ) ;\n if ( vid >= MAX_VLAN ) return VIRTIO_NET_ERR ;\n if ( cmd == VIRTIO_NET_CTRL_VLAN_ADD ) n -> vlans [ vid >> 5 ] |= ( 1U << ( vid & 0x1f ) ) ;\n else if ( cmd == VIRTIO_NET_CTRL_VLAN_DEL ) n -> vlans [ vid >> 5 ] &= ~ ( 1U << ( vid & 0x1f ) ) ;\n else return VIRTIO_NET_ERR ;\n return VIRTIO_NET_OK ;\n }", "hash": -8365810778652022218, "project": "debian", "size": 13, "target": 0, "idx": 9807}
{"code": "static uint32_t virtio_net_bad_features ( VirtIODevice * vdev ) {\n uint32_t features = 0 ;\n features |= ( 1 << VIRTIO_NET_F_MAC ) ;\n features |= ( 1 << VIRTIO_NET_F_CSUM ) ;\n features |= ( 1 << VIRTIO_NET_F_HOST_TSO4 ) ;\n features |= ( 1 << VIRTIO_NET_F_HOST_TSO6 ) ;\n features |= ( 1 << VIRTIO_NET_F_HOST_ECN ) ;\n return features ;\n }", "hash": -8365810778652022218, "project": "debian", "size": 9, "target": 0, "idx": 9808}
{"code": "static void virtio_balloon_save ( QEMUFile * f , void * opaque ) {\n VirtIOBalloon * s = opaque ;\n virtio_save ( & s -> vdev , f ) ;\n qemu_put_be32 ( f , s -> num_pages ) ;\n qemu_put_be32 ( f , s -> actual ) ;\n }", "hash": -5673151078622202536, "project": "debian", "size": 6, "target": 0, "idx": 9821}
{"code": "static VirtIOBalloon * to_virtio_balloon ( VirtIODevice * vdev ) {\n return ( VirtIOBalloon * ) vdev ;\n }", "hash": -5673151078622202536, "project": "debian", "size": 3, "target": 0, "idx": 9834}
{"code": "int ssl23_get_client_hello ( SSL * s ) {\n char buf_space [ 11 ] ;\n char * buf = & ( buf_space [ 0 ] ) ;\n unsigned char * p , * d , * d_len , * dd ;\n unsigned int i ;\n unsigned int csl , sil , cl ;\n int n = 0 , j ;\n int type = 0 ;\n int v [ 2 ] ;\n if ( s -> state == SSL23_ST_SR_CLNT_HELLO_A ) {\n v [ 0 ] = v [ 1 ] = 0 ;\n if ( ! ssl3_setup_buffers ( s ) ) goto err ;\n n = ssl23_read_bytes ( s , sizeof buf_space ) ;\n if ( n != sizeof buf_space ) return ( n ) ;\n p = s -> packet ;\n memcpy ( buf , p , n ) ;\n if ( ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) ) {\n if ( ( p [ 3 ] == 0x00 ) && ( p [ 4 ] == 0x02 ) ) {\n v [ 0 ] = p [ 3 ] ;\n v [ 1 ] = p [ 4 ] ;\n if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) ) type = 1 ;\n }\n else if ( p [ 3 ] == SSL3_VERSION_MAJOR ) {\n v [ 0 ] = p [ 3 ] ;\n v [ 1 ] = p [ 4 ] ;\n if ( p [ 4 ] >= TLS1_VERSION_MINOR ) {\n if ( p [ 4 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) ) {\n s -> version = TLS1_2_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( p [ 4 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) ) {\n s -> version = TLS1_1_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) ) {\n s -> version = TLS1_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n s -> version = SSL3_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) ) {\n type = 1 ;\n }\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n s -> version = SSL3_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) ) type = 1 ;\n }\n }\n else if ( ( p [ 0 ] == SSL3_RT_HANDSHAKE ) && ( p [ 1 ] == SSL3_VERSION_MAJOR ) && ( p [ 5 ] == SSL3_MT_CLIENT_HELLO ) && ( ( p [ 3 ] == 0 && p [ 4 ] < 5 ) || ( p [ 9 ] >= p [ 1 ] ) ) ) {\n v [ 0 ] = p [ 1 ] ;\n if ( p [ 3 ] == 0 && p [ 4 ] < 6 ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_TOO_SMALL ) ;\n goto err ;\n }\n if ( p [ 9 ] > SSL3_VERSION_MAJOR ) v [ 1 ] = 0xff ;\n else v [ 1 ] = p [ 10 ] ;\n if ( v [ 1 ] >= TLS1_VERSION_MINOR ) {\n if ( v [ 1 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) ) {\n s -> version = TLS1_2_VERSION ;\n type = 3 ;\n }\n else if ( v [ 1 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) ) {\n s -> version = TLS1_1_VERSION ;\n type = 3 ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) ) {\n s -> version = TLS1_VERSION ;\n type = 3 ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n s -> version = SSL3_VERSION ;\n type = 3 ;\n }\n }\n else {\n if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n s -> version = SSL3_VERSION ;\n type = 3 ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) ) {\n s -> version = TLS1_VERSION ;\n type = 3 ;\n }\n }\n }\n else if ( ( strncmp ( \"GET \" , ( char * ) p , 4 ) == 0 ) || ( strncmp ( \"POST \" , ( char * ) p , 5 ) == 0 ) || ( strncmp ( \"HEAD \" , ( char * ) p , 5 ) == 0 ) || ( strncmp ( \"PUT \" , ( char * ) p , 4 ) == 0 ) ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_HTTP_REQUEST ) ;\n goto err ;\n }\n else if ( strncmp ( \"CONNECT\" , ( char * ) p , 7 ) == 0 ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_HTTPS_PROXY_REQUEST ) ;\n goto err ;\n }\n }\n OPENSSL_assert ( s -> version <= TLS_MAX_VERSION ) ;\n # ifdef OPENSSL_FIPS if ( FIPS_mode ( ) && ( s -> version < TLS1_VERSION ) ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE ) ;\n goto err ;\n }\n # endif if ( s -> state == SSL23_ST_SR_CLNT_HELLO_B ) {\n type = 2 ;\n p = s -> packet ;\n v [ 0 ] = p [ 3 ] ;\n v [ 1 ] = p [ 4 ] ;\n n = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ] ;\n if ( n > ( 1024 * 4 ) ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_TOO_LARGE ) ;\n goto err ;\n }\n if ( n < 9 ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH ) ;\n goto err ;\n }\n j = ssl23_read_bytes ( s , n + 2 ) ;\n if ( j <= 0 ) return ( j ) ;\n ssl3_finish_mac ( s , s -> packet + 2 , s -> packet_length - 2 ) ;\n if ( s -> msg_callback ) s -> msg_callback ( 0 , SSL2_VERSION , 0 , s -> packet + 2 , s -> packet_length - 2 , s , s -> msg_callback_arg ) ;\n p = s -> packet ;\n p += 5 ;\n n2s ( p , csl ) ;\n n2s ( p , sil ) ;\n n2s ( p , cl ) ;\n d = ( unsigned char * ) s -> init_buf -> data ;\n if ( ( csl + sil + cl + 11 ) != s -> packet_length ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH ) ;\n goto err ;\n }\n * ( d ++ ) = SSL3_MT_CLIENT_HELLO ;\n d_len = d ;\n d += 3 ;\n * ( d ++ ) = SSL3_VERSION_MAJOR ;\n * ( d ++ ) = v [ 1 ] ;\n i = ( cl > SSL3_RANDOM_SIZE ) ? SSL3_RANDOM_SIZE : cl ;\n memset ( d , 0 , SSL3_RANDOM_SIZE ) ;\n memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ) ;\n d += SSL3_RANDOM_SIZE ;\n * ( d ++ ) = 0 ;\n j = 0 ;\n dd = d ;\n d += 2 ;\n for ( i = 0 ;\n i < csl ;\n i += 3 ) {\n if ( p [ i ] != 0 ) continue ;\n * ( d ++ ) = p [ i + 1 ] ;\n * ( d ++ ) = p [ i + 2 ] ;\n j += 2 ;\n }\n s2n ( j , dd ) ;\n * ( d ++ ) = 1 ;\n * ( d ++ ) = 0 ;\n # if 0 p = p + csl + sil + cl ;\n while ( p < s -> packet + s -> packet_length ) {\n * ( d ++ ) = * ( p ++ ) ;\n }\n # endif i = ( d - ( unsigned char * ) s -> init_buf -> data ) - 4 ;\n l2n3 ( ( long ) i , d_len ) ;\n s -> s3 -> tmp . reuse_message = 1 ;\n s -> s3 -> tmp . message_type = SSL3_MT_CLIENT_HELLO ;\n s -> s3 -> tmp . message_size = i ;\n }\n if ( type == 1 ) {\n # ifdef OPENSSL_NO_SSL2 SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNSUPPORTED_PROTOCOL ) ;\n goto err ;\n # else if ( s -> s2 == NULL ) {\n if ( ! ssl2_new ( s ) ) goto err ;\n }\n else ssl2_clear ( s ) ;\n if ( s -> s3 != NULL ) ssl3_free ( s ) ;\n if ( ! BUF_MEM_grow_clean ( s -> init_buf , SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER ) ) {\n goto err ;\n }\n s -> state = SSL2_ST_GET_CLIENT_HELLO_A ;\n if ( s -> options & SSL_OP_NO_TLSv1 && s -> options & SSL_OP_NO_SSLv3 ) s -> s2 -> ssl2_rollback = 0 ;\n else s -> s2 -> ssl2_rollback = 1 ;\n s -> rstate = SSL_ST_READ_HEADER ;\n s -> packet_length = n ;\n s -> packet = & ( s -> s2 -> rbuf [ 0 ] ) ;\n memcpy ( s -> packet , buf , n ) ;\n s -> s2 -> rbuf_left = n ;\n s -> s2 -> rbuf_offs = 0 ;\n s -> method = SSLv2_server_method ( ) ;\n s -> handshake_func = s -> method -> ssl_accept ;\n # endif }\n if ( ( type == 2 ) || ( type == 3 ) ) {\n const SSL_METHOD * new_method ;\n new_method = ssl23_get_server_method ( s -> version ) ;\n if ( new_method == NULL ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNSUPPORTED_PROTOCOL ) ;\n goto err ;\n }\n s -> method = new_method ;\n if ( ! ssl_init_wbio_buffer ( s , 1 ) ) goto err ;\n s -> state = SSL3_ST_SR_CLNT_HELLO_A ;\n if ( type == 3 ) {\n s -> rstate = SSL_ST_READ_HEADER ;\n s -> packet_length = n ;\n if ( s -> s3 -> rbuf . buf == NULL ) if ( ! ssl3_setup_read_buffer ( s ) ) goto err ;\n s -> packet = & ( s -> s3 -> rbuf . buf [ 0 ] ) ;\n memcpy ( s -> packet , buf , n ) ;\n s -> s3 -> rbuf . left = n ;\n s -> s3 -> rbuf . offset = 0 ;\n }\n else {\n s -> packet_length = 0 ;\n s -> s3 -> rbuf . left = 0 ;\n s -> s3 -> rbuf . offset = 0 ;\n }\n # if 0 s -> client_version = ( v [ 0 ] << 8 ) | v [ 1 ] ;\n # endif s -> handshake_func = s -> method -> ssl_accept ;\n }\n if ( ( type < 1 ) || ( type > 3 ) ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNKNOWN_PROTOCOL ) ;\n goto err ;\n }\n s -> init_num = 0 ;\n if ( buf != buf_space ) OPENSSL_free ( buf ) ;\n return ( SSL_accept ( s ) ) ;\n err : if ( buf != buf_space ) OPENSSL_free ( buf ) ;\n return ( - 1 ) ;\n }", "hash": 6709099320123900016, "project": "debian", "size": 226, "target": 0, "idx": 9836}
{"code": "static void compressed_sl_print ( netdissect_options * ndo , const u_char * chdr , const struct ip * ip , u_int length , int dir ) {\n register const u_char * cp = chdr ;\n register u_int flags , hlen ;\n flags = * cp ++ ;\n if ( flags & NEW_C ) {\n lastconn = * cp ++ ;\n ND_PRINT ( ( ndo , \"ctcp %d\" , lastconn ) ) ;\n }\n else ND_PRINT ( ( ndo , \"ctcp *\" ) ) ;\n cp += 2 ;\n switch ( flags & SPECIALS_MASK ) {\n case SPECIAL_I : ND_PRINT ( ( ndo , \" *SA+%d\" , lastlen [ dir ] [ lastconn ] ) ) ;\n break ;\n case SPECIAL_D : ND_PRINT ( ( ndo , \" *S+%d\" , lastlen [ dir ] [ lastconn ] ) ) ;\n break ;\n default : if ( flags & NEW_U ) cp = print_sl_change ( ndo , \"U=\" , cp ) ;\n if ( flags & NEW_W ) cp = print_sl_winchange ( ndo , cp ) ;\n if ( flags & NEW_A ) cp = print_sl_change ( ndo , \"A+\" , cp ) ;\n if ( flags & NEW_S ) cp = print_sl_change ( ndo , \"S+\" , cp ) ;\n break ;\n }\n if ( flags & NEW_I ) cp = print_sl_change ( ndo , \"I+\" , cp ) ;\n hlen = IP_HL ( ip ) ;\n hlen += TH_OFF ( ( const struct tcphdr * ) & ( ( const int32_t * ) ip ) [ hlen ] ) ;\n lastlen [ dir ] [ lastconn ] = length - ( hlen << 2 ) ;\n ND_PRINT ( ( ndo , \" %d (%ld)\" , lastlen [ dir ] [ lastconn ] , ( long ) ( cp - chdr ) ) ) ;\n }", "hash": -8054970867770516573, "project": "debian", "size": 27, "target": 0, "idx": 9839}
{"code": "static const u_char * print_sl_change ( netdissect_options * ndo , const char * str , register const u_char * cp ) {\n register u_int i ;\n if ( ( i = * cp ++ ) == 0 ) {\n i = EXTRACT_16BITS ( cp ) ;\n cp += 2 ;\n }\n ND_PRINT ( ( ndo , \" %s%d\" , str , i ) ) ;\n return ( cp ) ;\n }", "hash": -8054970867770516573, "project": "debian", "size": 9, "target": 0, "idx": 9840}
{"code": "static void sliplink_print ( netdissect_options * ndo , register const u_char * p , register const struct ip * ip , register u_int length ) {\n int dir ;\n u_int hlen ;\n dir = p [ SLX_DIR ] ;\n switch ( dir ) {\n case SLIPDIR_IN : ND_PRINT ( ( ndo , \"I \" ) ) ;\n break ;\n case SLIPDIR_OUT : ND_PRINT ( ( ndo , \"O \" ) ) ;\n break ;\n default : ND_PRINT ( ( ndo , \"Invalid direction %d \" , dir ) ) ;\n dir = - 1 ;\n break ;\n }\n if ( ndo -> ndo_nflag ) {\n register int i ;\n for ( i = SLX_CHDR ;\n i < SLX_CHDR + CHDR_LEN - 1 ;\n ++ i ) ND_PRINT ( ( ndo , \"%02x.\" , p [ i ] ) ) ;\n ND_PRINT ( ( ndo , \"%02x: \" , p [ SLX_CHDR + CHDR_LEN - 1 ] ) ) ;\n return ;\n }\n switch ( p [ SLX_CHDR ] & 0xf0 ) {\n case TYPE_IP : ND_PRINT ( ( ndo , \"ip %d: \" , length + SLIP_HDRLEN ) ) ;\n break ;\n case TYPE_UNCOMPRESSED_TCP : lastconn = ( ( const struct ip * ) & p [ SLX_CHDR ] ) -> ip_p ;\n ND_PRINT ( ( ndo , \"utcp %d: \" , lastconn ) ) ;\n if ( dir == - 1 ) {\n return ;\n }\n hlen = IP_HL ( ip ) ;\n hlen += TH_OFF ( ( const struct tcphdr * ) & ( ( const int * ) ip ) [ hlen ] ) ;\n lastlen [ dir ] [ lastconn ] = length - ( hlen << 2 ) ;\n break ;\n default : if ( dir == - 1 ) {\n return ;\n }\n if ( p [ SLX_CHDR ] & TYPE_COMPRESSED_TCP ) {\n compressed_sl_print ( ndo , & p [ SLX_CHDR ] , ip , length , dir ) ;\n ND_PRINT ( ( ndo , \": \" ) ) ;\n }\n else ND_PRINT ( ( ndo , \"slip-%d!: \" , p [ SLX_CHDR ] ) ) ;\n }\n }", "hash": -8054970867770516573, "project": "debian", "size": 43, "target": 0, "idx": 9842}
{"code": "static const u_char * print_sl_winchange ( netdissect_options * ndo , register const u_char * cp ) {\n register short i ;\n if ( ( i = * cp ++ ) == 0 ) {\n i = EXTRACT_16BITS ( cp ) ;\n cp += 2 ;\n }\n if ( i >= 0 ) ND_PRINT ( ( ndo , \" W+%d\" , i ) ) ;\n else ND_PRINT ( ( ndo , \" W%d\" , i ) ) ;\n return ( cp ) ;\n }", "hash": -8054970867770516573, "project": "debian", "size": 10, "target": 0, "idx": 9843}
{"code": "static int send_xmessage_using_XAUTHORITY ( struct proclistlist * pll , int lokke , char * message ) {\n if ( lokke == pll -> length ) return 0 ;\n {\n char * xa_filename = get_pid_environ_val ( pll -> proclist [ lokke ] . pid , \"XAUTHORITY\" ) ;\n if ( xa_filename != NULL ) {\n if ( send_xmessage ( xa_filename , message ) == 1 ) {\n free ( xa_filename ) ;\n return 1 ;\n }\n }\n free ( xa_filename ) ;\n }\n return send_xmessage_using_XAUTHORITY ( pll , lokke + 1 , message ) ;\n }", "hash": -2424348134098907053, "project": "debian", "size": 14, "target": 0, "idx": 9844}
{"code": "static int send_xmessage ( char * xa_filename , char * message ) {\n if ( access ( xa_filename , R_OK ) == 0 ) {\n setenv ( \"XAUTHORITY\" , xa_filename , 1 ) ;\n if ( verbose ) print_error ( stdout , \"Trying xauth file \\\"%s\\\"\" , xa_filename ) ;\n if ( system ( message ) == 0 ) return 1 ;\n }\n return 0 ;\n }", "hash": -2424348134098907053, "project": "debian", "size": 8, "target": 0, "idx": 9849}
{"code": "static void * counter_func ( void * arg ) {\n {\n set_pid_priority ( 0 , SCHED_FIFO , sched_get_priority_min ( SCHED_FIFO ) , \"Unable to set SCHED_FIFO for %d (\\\"%s\\\"). (%s)\" , \"the counter_func\" ) ;\n }\n for ( ;\n ;\n ) {\n counter ++ ;\n if ( verbose ) print_error ( stderr , \"counter set to %d\" , counter ) ;\n sleep ( increasetime ) ;\n }\n return NULL ;\n }", "hash": -2424348134098907053, "project": "debian", "size": 13, "target": 0, "idx": 9856}
{"code": "static void process_dl_debug ( const char * dl_debug ) {\n static const struct {\n unsigned char len ;\n const char name [ 10 ] ;\n const char helptext [ 41 ] ;\n unsigned short int mask ;\n }\n debopts [ ] = {\n # define LEN_AND_STR ( str ) sizeof ( str ) - 1 , str {\n LEN_AND_STR ( \"libs\" ) , \"display library search paths\" , DL_DEBUG_LIBS | DL_DEBUG_IMPCALLS }\n , {\n LEN_AND_STR ( \"reloc\" ) , \"display relocation processing\" , DL_DEBUG_RELOC | DL_DEBUG_IMPCALLS }\n , {\n LEN_AND_STR ( \"files\" ) , \"display progress for input file\" , DL_DEBUG_FILES | DL_DEBUG_IMPCALLS }\n , {\n LEN_AND_STR ( \"symbols\" ) , \"display symbol table processing\" , DL_DEBUG_SYMBOLS | DL_DEBUG_IMPCALLS }\n , {\n LEN_AND_STR ( \"bindings\" ) , \"display information about symbol binding\" , DL_DEBUG_BINDINGS | DL_DEBUG_IMPCALLS }\n , {\n LEN_AND_STR ( \"versions\" ) , \"display version dependencies\" , DL_DEBUG_VERSIONS | DL_DEBUG_IMPCALLS }\n , {\n LEN_AND_STR ( \"scopes\" ) , \"display scope information\" , DL_DEBUG_SCOPES }\n , {\n LEN_AND_STR ( \"all\" ) , \"all previous options combined\" , DL_DEBUG_LIBS | DL_DEBUG_RELOC | DL_DEBUG_FILES | DL_DEBUG_SYMBOLS | DL_DEBUG_BINDINGS | DL_DEBUG_VERSIONS | DL_DEBUG_IMPCALLS | DL_DEBUG_SCOPES }\n , {\n LEN_AND_STR ( \"statistics\" ) , \"display relocation statistics\" , DL_DEBUG_STATISTICS }\n , {\n LEN_AND_STR ( \"unused\" ) , \"determined unused DSOs\" , DL_DEBUG_UNUSED }\n , {\n LEN_AND_STR ( \"help\" ) , \"display this help message and exit\" , DL_DEBUG_HELP }\n , }\n ;\n # define ndebopts ( sizeof ( debopts ) / sizeof ( debopts [ 0 ] ) ) while ( * dl_debug != '\\0' ) {\n if ( * dl_debug != ' ' && * dl_debug != ',' && * dl_debug != ':' ) {\n size_t cnt ;\n size_t len = 1 ;\n while ( dl_debug [ len ] != '\\0' && dl_debug [ len ] != ' ' && dl_debug [ len ] != ',' && dl_debug [ len ] != ':' ) ++ len ;\n for ( cnt = 0 ;\n cnt < ndebopts ;\n ++ cnt ) if ( debopts [ cnt ] . len == len && memcmp ( dl_debug , debopts [ cnt ] . name , len ) == 0 ) {\n GLRO ( dl_debug_mask ) |= debopts [ cnt ] . mask ;\n any_debug = 1 ;\n break ;\n }\n if ( cnt == ndebopts ) {\n char * copy = strndupa ( dl_debug , len ) ;\n _dl_error_printf ( \"\\ warning: debug option `%s' unknown;\n try LD_DEBUG=help\\n\" , copy ) ;\n }\n dl_debug += len ;\n continue ;\n }\n ++ dl_debug ;\n }\n if ( GLRO ( dl_debug_mask ) & DL_DEBUG_UNUSED ) {\n GLRO ( dl_lazy ) = 0 ;\n }\n if ( GLRO ( dl_debug_mask ) & DL_DEBUG_HELP ) {\n size_t cnt ;\n _dl_printf ( \"\\ Valid options for the LD_DEBUG environment variable are:\\n\\n\" ) ;\n for ( cnt = 0 ;\n cnt < ndebopts ;\n ++ cnt ) _dl_printf ( \" %.*s%s%s\\n\" , debopts [ cnt ] . len , debopts [ cnt ] . name , \" \" + debopts [ cnt ] . len - 3 , debopts [ cnt ] . helptext ) ;\n _dl_printf ( \"\\n\\ To direct the debugging output into a file instead of standard output\\n\\ a filename can be specified using the LD_DEBUG_OUTPUT environment variable.\\n\" ) ;\n _exit ( 0 ) ;\n }\n }", "hash": -5025430721469043309, "project": "debian", "size": 67, "target": 0, "idx": 9869}
{"code": "static void version_check_doit ( void * a ) {\n struct version_check_args * args = ( struct version_check_args * ) a ;\n if ( _dl_check_all_versions ( GL ( dl_ns ) [ LM_ID_BASE ] . _ns_loaded , 1 , args -> dotrace ) && args -> doexit ) _exit ( 1 ) ;\n }", "hash": -5025430721469043309, "project": "debian", "size": 4, "target": 0, "idx": 9873}
{"code": "static void relocate_doit ( void * a ) {\n struct relocate_args * args = ( struct relocate_args * ) a ;\n _dl_relocate_object ( args -> l , args -> l -> l_scope , args -> reloc_mode , 0 ) ;\n }", "hash": -5025430721469043309, "project": "debian", "size": 4, "target": 0, "idx": 9876}
{"code": "static void dissect_rsvp_integrity ( proto_item * ti _U_ , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length , int rsvp_class _U_ , int type ) {\n int offset2 = offset + 4 ;\n proto_tree * ti2 , * rsvp_integ_flags_tree ;\n proto_tree_add_uint ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type ) ;\n ti2 = proto_tree_add_item ( rsvp_object_tree , hf_rsvp_integrity_flags , tvb , offset2 , 1 , ENC_BIG_ENDIAN ) ;\n rsvp_integ_flags_tree = proto_item_add_subtree ( ti2 , TREE ( TT_INTEGRITY_FLAGS ) ) ;\n proto_tree_add_item ( rsvp_integ_flags_tree , hf_rsvp_integrity_flags_handshake , tvb , offset2 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_integrity_key_identifier , tvb , offset2 + 2 , 6 , ENC_NA ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_integrity_sequence_number , tvb , offset2 + 8 , 8 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_integrity_hash , tvb , offset2 + 16 , obj_length - 20 , ENC_NA ) ;\n }", "hash": 2388171415474875762, "project": "debian", "size": 11, "target": 0, "idx": 9879}
{"code": "static const char * rsvp_host_get_filter_type ( hostlist_talker_t * host _U_ , conv_filter_type_e filter ) {\n if ( ( filter == CONV_FT_ANY_ADDRESS ) && ( host -> myaddress . type == AT_IPv4 ) ) return \"ip.addr\" ;\n return CONV_FILTER_INVALID ;\n }", "hash": 2388171415474875762, "project": "debian", "size": 4, "target": 0, "idx": 9882}
{"code": "static void dissect_rsvp_restart_cap ( proto_tree * ti , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length , int rsvp_class _U_ , int type ) {\n int offset2 = offset + 4 ;\n guint restart , recovery ;\n proto_item_set_text ( ti , \"RESTART CAPABILITY: \" ) ;\n switch ( type ) {\n case 1 : proto_tree_add_uint ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type ) ;\n restart = tvb_get_ntohl ( tvb , offset2 ) ;\n proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_restart_cap_restart_time , tvb , offset2 , 4 , restart , \"%d ms\" , restart ) ;\n recovery = tvb_get_ntohl ( tvb , offset2 + 4 ) ;\n proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_restart_cap_recovery_time , tvb , offset2 + 4 , 4 , recovery , \"%d ms\" , recovery ) ;\n proto_item_append_text ( ti , \"Restart Time: %d ms. Recovery Time: %d ms.\" , restart , recovery ) ;\n break ;\n default : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"Unknown (%u)\" , type ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_restart_cap_data , tvb , offset2 , obj_length - 4 , ENC_NA ) ;\n break ;\n }\n }", "hash": 2388171415474875762, "project": "debian", "size": 17, "target": 0, "idx": 9898}
{"code": "static int rsvp_conversation_packet ( void * pct , packet_info * pinfo , epan_dissect_t * edt _U_ , const void * vip ) {\n conv_hash_t * hash = ( conv_hash_t * ) pct ;\n const rsvp_conversation_info * rsvph = ( const rsvp_conversation_info * ) vip ;\n add_conversation_table_data ( hash , & rsvph -> source , & rsvph -> destination , 0 , 0 , 1 , pinfo -> fd -> pkt_len , & pinfo -> rel_ts , & pinfo -> fd -> abs_ts , & rsvp_ct_dissector_info , PT_NONE ) ;\n return 1 ;\n }", "hash": 2388171415474875762, "project": "debian", "size": 6, "target": 0, "idx": 9910}
{"code": "static void dissect_rsvp_lsp_tunnel_if_id ( proto_tree * ti , packet_info * pinfo , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length , int rsvp_class _U_ , int type ) {\n proto_item_set_text ( ti , \"LSP INTERFACE-ID: \" ) ;\n switch ( type ) {\n case 1 : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"1 - Unnumbered interface\" ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_lsp_tunnel_if_id_router_id , tvb , offset + 4 , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_lsp_tunnel_if_id_interface_id , tvb , offset + 8 , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_set_text ( ti , \"LSP INTERFACE-ID: Unnumbered, Router-ID %s, Interface-ID %d\" , tvb_ip_to_str ( tvb , offset + 4 ) , tvb_get_ntohl ( tvb , offset + 8 ) ) ;\n break ;\n case 2 : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"2 - IPv4\" ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_lsp_tunnel_if_id_ipv4_interface_address , tvb , offset + 4 , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_lsp_tunnel_if_id_target_igp_instance , tvb , offset + 8 , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_set_text ( ti , \"LSP INTERFACE-ID: IPv4, interface address %s,\" \"IGP instance %s\" , tvb_ip_to_str ( tvb , offset + 4 ) , tvb_ip_to_str ( tvb , offset + 8 ) ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_lsp_tunnel_if_id_action , tvb , offset + 12 , 1 , ENC_BIG_ENDIAN ) ;\n dissect_rsvp_lsp_tunnel_if_id_tlv ( rsvp_object_tree , pinfo , tvb , offset + 16 , obj_length - 16 , TREE ( TT_LSP_TUNNEL_IF_ID_SUBTREE ) ) ;\n break ;\n case 3 : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"3 - IPv6\" ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_lsp_tunnel_if_id_ipv6_interface_address , tvb , offset + 4 , 16 , ENC_NA ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_lsp_tunnel_if_id_target_igp_instance , tvb , offset + 20 , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_set_text ( ti , \"LSP INTERFACE-ID: IPv6, interface address %s,\" \"IGP instance %s\" , tvb_ip6_to_str ( tvb , offset + 4 ) , tvb_ip_to_str ( tvb , offset + 20 ) ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_lsp_tunnel_if_id_action , tvb , offset + 24 , 1 , ENC_BIG_ENDIAN ) ;\n dissect_rsvp_lsp_tunnel_if_id_tlv ( rsvp_object_tree , pinfo , tvb , offset + 28 , obj_length - 28 , TREE ( TT_LSP_TUNNEL_IF_ID_SUBTREE ) ) ;\n break ;\n case 4 : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"4 - Unnumbered interface with target\" ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_lsp_tunnel_if_id_router_id , tvb , offset + 4 , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_lsp_tunnel_if_id_interface_id , tvb , offset + 8 , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_lsp_tunnel_if_id_target_igp_instance , tvb , offset + 12 , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_set_text ( ti , \"LSP INTERFACE-ID: Unnumbered with target, Router-ID %s,\" \" Interface-ID %d, IGP instance %s\" , tvb_ip_to_str ( tvb , offset + 4 ) , tvb_get_ntohl ( tvb , offset + 8 ) , tvb_ip_to_str ( tvb , offset + 12 ) ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_lsp_tunnel_if_id_action , tvb , offset + 16 , 1 , ENC_BIG_ENDIAN ) ;\n dissect_rsvp_lsp_tunnel_if_id_tlv ( rsvp_object_tree , pinfo , tvb , offset + 20 , obj_length - 20 , TREE ( TT_LSP_TUNNEL_IF_ID_SUBTREE ) ) ;\n break ;\n default : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"Unknown (%u)\" , type ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_lsp_tunnel_if_id_data , tvb , offset + 4 , obj_length - 4 , ENC_NA ) ;\n break ;\n }\n }", "hash": 2388171415474875762, "project": "debian", "size": 35, "target": 0, "idx": 9912}
{"code": "static void dissect_rsvp_protection_info ( proto_tree * ti , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length , int rsvp_class _U_ , int type ) {\n guint8 flags1 , lsp_flags , link_flags , seg_flags ;\n proto_tree * ti2 , * rsvp_pi_link_flags_tree , * rsvp_pi_lsp_flags_tree , * rsvp_pi_seg_flags_tree ;\n int offset2 = offset + 4 ;\n proto_item_set_text ( ti , \"PROTECTION_INFO: \" ) ;\n switch ( type ) {\n case 1 : proto_tree_add_uint ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type ) ;\n flags1 = tvb_get_guint8 ( tvb , offset2 ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_protection_info_flags_secondary_lsp , tvb , offset2 , 1 , ENC_BIG_ENDIAN ) ;\n link_flags = tvb_get_guint8 ( tvb , offset2 + 3 ) ;\n ti2 = proto_tree_add_item ( rsvp_object_tree , hf_rsvp_protection_info_link_flags , tvb , offset2 + 3 , 1 , ENC_BIG_ENDIAN ) ;\n rsvp_pi_link_flags_tree = proto_item_add_subtree ( ti2 , TREE ( TT_PROTECTION_INFO_LINK ) ) ;\n proto_tree_add_item ( rsvp_pi_link_flags_tree , hf_rsvp_pi_link_flags_extra_traffic , tvb , offset2 + 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_link_flags_tree , hf_rsvp_pi_link_flags_unprotected , tvb , offset2 + 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_link_flags_tree , hf_rsvp_pi_link_flags_shared , tvb , offset2 + 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_link_flags_tree , hf_rsvp_pi_link_flags_dedicated1_1 , tvb , offset2 + 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_link_flags_tree , hf_rsvp_pi_link_flags_dedicated1plus1 , tvb , offset2 + 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_link_flags_tree , hf_rsvp_pi_link_flags_enhanced , tvb , offset2 + 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \"%s%s%s%s%s%s%s.\" , flags1 & 0x80 ? \"SecondaryLSP \" : \"\" , link_flags & 0x01 ? \"ExtraTraffic \" : \"\" , link_flags & 0x02 ? \"Unprotected \" : \"\" , link_flags & 0x04 ? \"Shared \" : \"\" , link_flags & 0x08 ? \"Dedicated1:1 \" : \"\" , link_flags & 0x10 ? \"Dedicated1+1 \" : \"\" , link_flags & 0x20 ? \"Enhanced \" : \"\" ) ;\n break ;\n case 2 : proto_tree_add_uint ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type ) ;\n flags1 = tvb_get_guint8 ( tvb , offset2 ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_rfc4872_secondary , tvb , offset2 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_rfc4872_protecting , tvb , offset2 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_rfc4872_notification_msg , tvb , offset2 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_rfc4872_operational , tvb , offset2 , 1 , ENC_BIG_ENDIAN ) ;\n lsp_flags = tvb_get_guint8 ( tvb , offset2 + 1 ) ;\n rsvp_pi_lsp_flags_tree = proto_tree_add_subtree_format ( rsvp_object_tree , tvb , offset2 + 1 , 1 , TREE ( TT_PROTECTION_INFO_LSP ) , NULL , \"LSP Flags: 0x%02x -%s%s%s%s%s%s\" , lsp_flags , lsp_flags == 0 ? \" Unprotected\" : \"\" , lsp_flags & 0x01 ? \" Rerouting\" : \"\" , lsp_flags & 0x02 ? \" Rerouting with extra-traffic\" : \"\" , lsp_flags & 0x04 ? \" 1:N Protection with extra-traffic\" : \"\" , lsp_flags & 0x08 ? \" 1+1 Unidirectional protection\" : \"\" , lsp_flags & 0x10 ? \" 1+1 Bidirectional protection\" : \"\" ) ;\n proto_tree_add_item ( rsvp_pi_lsp_flags_tree , hf_rsvp_pi_lsp_flags_full_rerouting , tvb , offset2 + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_lsp_flags_tree , hf_rsvp_pi_lsp_flags_rerouting_extra , tvb , offset2 + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_lsp_flags_tree , hf_rsvp_pi_lsp_flags_1_n_protection , tvb , offset2 + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_lsp_flags_tree , hf_rsvp_pi_lsp_flags_1plus1_unidirectional , tvb , offset2 + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_lsp_flags_tree , hf_rsvp_pi_lsp_flags_1plus1_bidirectional , tvb , offset2 + 1 , 1 , ENC_BIG_ENDIAN ) ;\n link_flags = tvb_get_guint8 ( tvb , offset2 + 3 ) ;\n rsvp_pi_link_flags_tree = proto_tree_add_subtree_format ( rsvp_object_tree , tvb , offset2 + 3 , 1 , TREE ( TT_PROTECTION_INFO_LINK ) , NULL , \"Link Flags: 0x%02x -%s%s%s%s%s%s\" , link_flags , link_flags & 0x01 ? \" ExtraTraffic\" : \"\" , link_flags & 0x02 ? \" Unprotected\" : \"\" , link_flags & 0x04 ? \" Shared\" : \"\" , link_flags & 0x08 ? \" Dedicated1:1\" : \"\" , link_flags & 0x10 ? \" Dedicated1+1\" : \"\" , link_flags & 0x20 ? \" Enhanced\" : \"\" ) ;\n proto_tree_add_item ( rsvp_pi_link_flags_tree , hf_rsvp_pi_link_flags_extra , tvb , offset2 + 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_link_flags_tree , hf_rsvp_pi_link_flags_unprotected , tvb , offset2 + 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_link_flags_tree , hf_rsvp_pi_link_flags_shared , tvb , offset2 + 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_link_flags_tree , hf_rsvp_pi_link_flags_dedicated_1_1 , tvb , offset2 + 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_link_flags_tree , hf_rsvp_pi_link_flags_dedicated_1plus1 , tvb , offset2 + 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_link_flags_tree , hf_rsvp_pi_link_flags_enhanced , tvb , offset2 + 3 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_protection_info_in_place , tvb , offset2 + 4 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_protection_info_required , tvb , offset2 + 4 , 1 , ENC_BIG_ENDIAN ) ;\n seg_flags = tvb_get_guint8 ( tvb , offset2 + 5 ) ;\n rsvp_pi_seg_flags_tree = proto_tree_add_subtree_format ( rsvp_object_tree , tvb , offset2 + 5 , 1 , TREE ( TT_PROTECTION_INFO_SEG ) , NULL , \"Segment recovery Flags: 0x%02x - %s%s%s%s%s%s\" , seg_flags , seg_flags == 0 ? \" Unprotected\" : \"\" , seg_flags & 0x01 ? \" Rerouting\" : \"\" , seg_flags & 0x02 ? \" Rerouting with extra-traffic\" : \"\" , seg_flags & 0x04 ? \" 1:N Protection with extra-traffic\" : \"\" , seg_flags & 0x08 ? \" 1+1 Unidirectional protection\" : \"\" , seg_flags & 0x10 ? \" 1+1 Bidirectional protection\" : \"\" ) ;\n proto_tree_add_item ( rsvp_pi_seg_flags_tree , hf_rsvp_pi_seg_flags_full_rerouting , tvb , offset2 + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_seg_flags_tree , hf_rsvp_pi_seg_flags_rerouting_extra , tvb , offset2 + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_seg_flags_tree , hf_rsvp_pi_seg_flags_1_n_protection , tvb , offset2 + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_seg_flags_tree , hf_rsvp_pi_seg_flags_1plus1_unidirectional , tvb , offset2 + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_pi_seg_flags_tree , hf_rsvp_pi_seg_flags_1plus1_bidirectional , tvb , offset2 + 1 , 1 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \"%s%s%s%s Link:%s%s%s%s%s%s, LSP:%s%s%s%s%s%s.\" , flags1 & 0x80 ? \"SecondaryLSP \" : \"\" , flags1 & 0x40 ? \"ProtectingLSP \" : \"\" , flags1 & 0x20 ? \"Notification \" : \"\" , flags1 & 0x10 ? \"OperationalLSP \" : \"\" , link_flags & 0x01 ? \" ExtraTraffic\" : \"\" , link_flags & 0x02 ? \" Unprotected\" : \"\" , link_flags & 0x04 ? \" Shared\" : \"\" , link_flags & 0x08 ? \" Dedicated1:1\" : \"\" , link_flags & 0x10 ? \" Dedicated1+1\" : \"\" , link_flags & 0x20 ? \" Enhanced\" : \"\" , lsp_flags == 0 ? \" Unprotected\" : \"\" , lsp_flags & 0x01 ? \" Rerouting\" : \"\" , lsp_flags & 0x02 ? \" Rerouting with extra-traffic\" : \"\" , lsp_flags & 0x04 ? \" 1:N Protection with extra-traffic\" : \"\" , lsp_flags & 0x08 ? \" 1+1 Unidirectional protection\" : \"\" , lsp_flags & 0x10 ? \" 1+1 Bidirectional protection\" : \"\" ) ;\n break ;\n default : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"Unknown (%u)\" , type ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_protection_info_data , tvb , offset2 , obj_length - 4 , ENC_NA ) ;\n break ;\n }\n }", "hash": 2388171415474875762, "project": "debian", "size": 57, "target": 0, "idx": 9918}
{"code": "static void dissect_rsvp_message_id_list ( proto_tree * ti , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length , int rsvp_class _U_ , int type ) {\n int offset2 = offset + 4 ;\n int mylen ;\n switch ( type ) {\n case 1 : proto_tree_add_uint ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_message_id_list_flags , tvb , offset + 4 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_message_id_list_epoch , tvb , offset + 5 , 3 , ENC_BIG_ENDIAN ) ;\n for ( mylen = 8 ;\n mylen < obj_length ;\n mylen += 4 ) proto_tree_add_item ( rsvp_object_tree , hf_rsvp_message_id_list_message_id , tvb , offset + mylen , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_set_text ( ti , \"MESSAGE-ID LIST: %d IDs\" , ( obj_length - 8 ) / 4 ) ;\n break ;\n default : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"Unknown (%u)\" , type ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_message_id_list_data , tvb , offset2 , obj_length - 4 , ENC_NA ) ;\n break ;\n }\n }", "hash": 2388171415474875762, "project": "debian", "size": 17, "target": 0, "idx": 9925}
{"code": "static void dissect_rsvp_detour ( proto_tree * ti , packet_info * pinfo , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length , int rsvp_class _U_ , int type ) {\n int remaining_length , count ;\n int iter ;\n proto_item_set_text ( ti , \"DETOUR: \" ) ;\n switch ( type ) {\n case 7 : iter = 0 ;\n proto_tree_add_uint ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type ) ;\n for ( remaining_length = obj_length - 4 , count = 1 ;\n remaining_length > 0 ;\n remaining_length -= 8 , count ++ ) {\n if ( remaining_length < 8 ) {\n proto_tree_add_expert_format ( rsvp_object_tree , pinfo , & ei_rsvp_invalid_length , tvb , offset + remaining_length , obj_length - remaining_length , \"Invalid length: cannot decode\" ) ;\n proto_item_append_text ( ti , \"Invalid length\" ) ;\n break ;\n }\n iter ++ ;\n proto_tree_add_ipv4_format ( rsvp_object_tree , hf_rsvp_detour_plr_id , tvb , offset + ( 4 * iter ) , 4 , tvb_get_ntohl ( tvb , offset + ( 4 * iter ) ) , \"PLR ID %d: %s\" , count , tvb_ip_to_str ( tvb , offset + ( 4 * iter ) ) ) ;\n iter ++ ;\n proto_tree_add_ipv4_format ( rsvp_object_tree , hf_rsvp_detour_avoid_node_id , tvb , offset + ( 4 * iter ) , 4 , tvb_get_ntohl ( tvb , offset + ( 4 * iter ) ) , \"Avoid Node ID %d: %s\" , count , tvb_ip_to_str ( tvb , offset + ( 4 * iter ) ) ) ;\n }\n break ;\n default : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"Unknown (%u)\" , type ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_detour_data , tvb , offset + 4 , obj_length - 4 , ENC_NA ) ;\n break ;\n }\n }", "hash": 2388171415474875762, "project": "debian", "size": 26, "target": 0, "idx": 9927}
{"code": "static int ngsniffer_process_record ( wtap * wth , gboolean is_random , guint * padding , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) {\n ngsniffer_t * ngsniffer ;\n char record_type [ 2 ] ;\n char record_length [ 4 ] ;\n guint type , length ;\n struct frame2_rec frame2 ;\n struct frame4_rec frame4 ;\n struct frame6_rec frame6 ;\n guint16 time_low , time_med , true_size , size ;\n guint8 time_high , time_day ;\n guint64 t , tsecs , tpsecs ;\n if ( ! ng_read_bytes_or_eof ( wth , record_type , 2 , is_random , err , err_info ) ) {\n if ( * err != 0 ) return - 1 ;\n return REC_EOF ;\n }\n if ( ! ng_read_bytes ( wth , record_length , 4 , is_random , err , err_info ) ) return - 1 ;\n type = pletoh16 ( record_type ) ;\n length = pletoh16 ( record_length ) ;\n ngsniffer = ( ngsniffer_t * ) wth -> priv ;\n switch ( type ) {\n case REC_FRAME2 : if ( ngsniffer -> network == NETWORK_ATM ) {\n * err = WTAP_ERR_BAD_FILE ;\n * err_info = g_strdup ( \"ngsniffer: REC_FRAME2 record in an ATM Sniffer file\" ) ;\n return - 1 ;\n }\n if ( length < sizeof frame2 ) {\n * err = WTAP_ERR_BAD_FILE ;\n * err_info = g_strdup ( \"ngsniffer: REC_FRAME2 record length is less than record header length\" ) ;\n return - 1 ;\n }\n if ( ! ng_read_bytes ( wth , & frame2 , ( unsigned int ) sizeof frame2 , is_random , err , err_info ) ) return - 1 ;\n time_low = pletoh16 ( & frame2 . time_low ) ;\n time_med = pletoh16 ( & frame2 . time_med ) ;\n time_high = frame2 . time_high ;\n time_day = frame2 . time_day ;\n size = pletoh16 ( & frame2 . size ) ;\n true_size = pletoh16 ( & frame2 . true_size ) ;\n length -= sizeof frame2 ;\n set_pseudo_header_frame2 ( wth , & phdr -> pseudo_header , & frame2 ) ;\n break ;\n case REC_FRAME4 : if ( ngsniffer -> network != NETWORK_ATM ) {\n * err = WTAP_ERR_BAD_FILE ;\n * err_info = g_strdup ( \"ngsniffer: REC_FRAME4 record in a non-ATM Sniffer file\" ) ;\n return - 1 ;\n }\n if ( ngsniffer -> maj_vers < 5 && ngsniffer -> min_vers >= 95 ) length += sizeof frame4 - sizeof frame2 ;\n if ( length < sizeof frame4 ) {\n * err = WTAP_ERR_BAD_FILE ;\n * err_info = g_strdup ( \"ngsniffer: REC_FRAME4 record length is less than record header length\" ) ;\n return - 1 ;\n }\n if ( ! ng_read_bytes ( wth , & frame4 , ( unsigned int ) sizeof frame4 , is_random , err , err_info ) ) return - 1 ;\n time_low = pletoh16 ( & frame4 . time_low ) ;\n time_med = pletoh16 ( & frame4 . time_med ) ;\n time_high = frame4 . time_high ;\n time_day = frame4 . time_day ;\n size = pletoh16 ( & frame4 . size ) ;\n true_size = pletoh16 ( & frame4 . true_size ) ;\n length -= sizeof frame4 ;\n set_pseudo_header_frame4 ( & phdr -> pseudo_header , & frame4 ) ;\n break ;\n case REC_FRAME6 : if ( length < sizeof frame6 ) {\n * err = WTAP_ERR_BAD_FILE ;\n * err_info = g_strdup ( \"ngsniffer: REC_FRAME6 record length is less than record header length\" ) ;\n return - 1 ;\n }\n if ( ! ng_read_bytes ( wth , & frame6 , ( unsigned int ) sizeof frame6 , is_random , err , err_info ) ) return - 1 ;\n time_low = pletoh16 ( & frame6 . time_low ) ;\n time_med = pletoh16 ( & frame6 . time_med ) ;\n time_high = frame6 . time_high ;\n time_day = frame6 . time_day ;\n size = pletoh16 ( & frame6 . size ) ;\n true_size = pletoh16 ( & frame6 . true_size ) ;\n length -= sizeof frame6 ;\n set_pseudo_header_frame6 ( wth , & phdr -> pseudo_header , & frame6 ) ;\n break ;\n case REC_EOF : * err = 0 ;\n return REC_EOF ;\n default : if ( padding != NULL ) {\n * padding = length ;\n }\n return type ;\n }\n if ( size > length ) {\n * err = WTAP_ERR_BAD_FILE ;\n * err_info = g_strdup ( \"ngsniffer: Record length is less than packet size\" ) ;\n return - 1 ;\n }\n if ( padding != NULL ) {\n * padding = length - size ;\n }\n phdr -> rec_type = REC_TYPE_PACKET ;\n phdr -> presence_flags = true_size ? WTAP_HAS_TS | WTAP_HAS_CAP_LEN : WTAP_HAS_TS ;\n phdr -> len = true_size ? true_size : size ;\n phdr -> caplen = size ;\n ws_buffer_assure_space ( buf , size ) ;\n if ( ! ng_read_bytes ( wth , ws_buffer_start_ptr ( buf ) , size , is_random , err , err_info ) ) return - 1 ;\n phdr -> pkt_encap = fix_pseudo_header ( wth -> file_encap , buf , size , & phdr -> pseudo_header ) ;\n t = ( ( ( guint64 ) time_high ) << 32 ) | ( ( ( guint64 ) time_med ) << 16 ) | time_low ;\n t *= ngsniffer -> timeunit ;\n tsecs = t / G_GUINT64_CONSTANT ( 1000000000000 ) ;\n tpsecs = t - tsecs * G_GUINT64_CONSTANT ( 1000000000000 ) ;\n tsecs += time_day * 86400 ;\n tsecs += ngsniffer -> start ;\n phdr -> ts . secs = ( time_t ) tsecs ;\n phdr -> ts . nsecs = ( int ) ( tpsecs / 1000 ) ;\n return type ;\n }", "hash": -1381237731082039179, "project": "debian", "size": 108, "target": 0, "idx": 9959}
{"code": "static gboolean ngsniffer_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) {\n int ret ;\n if ( ! ng_file_seek_rand ( wth , seek_off , err , err_info ) ) return FALSE ;\n ret = ngsniffer_process_record ( wth , TRUE , NULL , phdr , buf , err , err_info ) ;\n if ( ret < 0 ) {\n return FALSE ;\n }\n switch ( ret ) {\n case REC_FRAME2 : case REC_FRAME4 : case REC_FRAME6 : break ;\n default : g_assert_not_reached ( ) ;\n return FALSE ;\n }\n return TRUE ;\n }", "hash": -1381237731082039179, "project": "debian", "size": 14, "target": 0, "idx": 9960}
{"code": "static void set_pseudo_header_frame4 ( union wtap_pseudo_header * pseudo_header , struct frame4_rec * frame4 ) {\n guint32 StatusWord ;\n guint8 aal_type , hl_type ;\n guint16 vpi , vci ;\n pseudo_header -> atm . flags = 0 ;\n StatusWord = pletoh32 ( & frame4 -> atm_info . StatusWord ) ;\n if ( StatusWord & SW_RAW_CELL ) pseudo_header -> atm . flags |= ATM_RAW_CELL ;\n aal_type = frame4 -> atm_info . AppTrafType & ATT_AALTYPE ;\n hl_type = frame4 -> atm_info . AppTrafType & ATT_HLTYPE ;\n vpi = pletoh16 ( & frame4 -> atm_info . Vpi ) ;\n vci = pletoh16 ( & frame4 -> atm_info . Vci ) ;\n switch ( aal_type ) {\n case ATT_AAL_UNKNOWN : if ( vpi == 0 && vci == 5 ) pseudo_header -> atm . aal = AAL_SIGNALLING ;\n else pseudo_header -> atm . aal = AAL_UNKNOWN ;\n pseudo_header -> atm . type = TRAF_UNKNOWN ;\n pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n case ATT_AAL1 : pseudo_header -> atm . aal = AAL_1 ;\n pseudo_header -> atm . type = TRAF_UNKNOWN ;\n pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n case ATT_AAL3_4 : pseudo_header -> atm . aal = AAL_3_4 ;\n pseudo_header -> atm . type = TRAF_UNKNOWN ;\n pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n case ATT_AAL5 : pseudo_header -> atm . aal = AAL_5 ;\n switch ( hl_type ) {\n case ATT_HL_UNKNOWN : pseudo_header -> atm . type = TRAF_UNKNOWN ;\n pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n case ATT_HL_LLCMX : pseudo_header -> atm . type = TRAF_LLCMX ;\n pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n case ATT_HL_VCMX : pseudo_header -> atm . type = TRAF_VCMX ;\n switch ( frame4 -> atm_info . AppHLType ) {\n case AHLT_UNKNOWN : pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n case AHLT_VCMX_802_3_FCS : pseudo_header -> atm . subtype = TRAF_ST_VCMX_802_3_FCS ;\n break ;\n case AHLT_VCMX_802_4_FCS : pseudo_header -> atm . subtype = TRAF_ST_VCMX_802_4_FCS ;\n break ;\n case AHLT_VCMX_802_5_FCS : pseudo_header -> atm . subtype = TRAF_ST_VCMX_802_5_FCS ;\n break ;\n case AHLT_VCMX_FDDI_FCS : pseudo_header -> atm . subtype = TRAF_ST_VCMX_FDDI_FCS ;\n break ;\n case AHLT_VCMX_802_6_FCS : pseudo_header -> atm . subtype = TRAF_ST_VCMX_802_6_FCS ;\n break ;\n case AHLT_VCMX_802_3 : pseudo_header -> atm . subtype = TRAF_ST_VCMX_802_3 ;\n break ;\n case AHLT_VCMX_802_4 : pseudo_header -> atm . subtype = TRAF_ST_VCMX_802_4 ;\n break ;\n case AHLT_VCMX_802_5 : pseudo_header -> atm . subtype = TRAF_ST_VCMX_802_5 ;\n break ;\n case AHLT_VCMX_FDDI : pseudo_header -> atm . subtype = TRAF_ST_VCMX_FDDI ;\n break ;\n case AHLT_VCMX_802_6 : pseudo_header -> atm . subtype = TRAF_ST_VCMX_802_6 ;\n break ;\n case AHLT_VCMX_FRAGMENTS : pseudo_header -> atm . subtype = TRAF_ST_VCMX_FRAGMENTS ;\n break ;\n case AHLT_VCMX_BPDU : pseudo_header -> atm . subtype = TRAF_ST_VCMX_BPDU ;\n break ;\n default : pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n }\n break ;\n case ATT_HL_LANE : pseudo_header -> atm . type = TRAF_LANE ;\n switch ( frame4 -> atm_info . AppHLType ) {\n case AHLT_UNKNOWN : pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n case AHLT_LANE_LE_CTRL : pseudo_header -> atm . subtype = TRAF_ST_LANE_LE_CTRL ;\n break ;\n case AHLT_LANE_802_3 : pseudo_header -> atm . subtype = TRAF_ST_LANE_802_3 ;\n break ;\n case AHLT_LANE_802_5 : pseudo_header -> atm . subtype = TRAF_ST_LANE_802_5 ;\n break ;\n case AHLT_LANE_802_3_MC : pseudo_header -> atm . subtype = TRAF_ST_LANE_802_3_MC ;\n break ;\n case AHLT_LANE_802_5_MC : pseudo_header -> atm . subtype = TRAF_ST_LANE_802_5_MC ;\n break ;\n default : pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n }\n break ;\n case ATT_HL_ILMI : pseudo_header -> atm . type = TRAF_ILMI ;\n pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n case ATT_HL_FRMR : pseudo_header -> atm . type = TRAF_FR ;\n pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n case ATT_HL_SPANS : pseudo_header -> atm . type = TRAF_SPANS ;\n pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n case ATT_HL_IPSILON : pseudo_header -> atm . type = TRAF_IPSILON ;\n switch ( frame4 -> atm_info . AppHLType ) {\n case AHLT_UNKNOWN : pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n case AHLT_IPSILON_FT0 : pseudo_header -> atm . subtype = TRAF_ST_IPSILON_FT0 ;\n break ;\n case AHLT_IPSILON_FT1 : pseudo_header -> atm . subtype = TRAF_ST_IPSILON_FT1 ;\n break ;\n case AHLT_IPSILON_FT2 : pseudo_header -> atm . subtype = TRAF_ST_IPSILON_FT2 ;\n break ;\n default : pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n }\n break ;\n default : pseudo_header -> atm . type = TRAF_UNKNOWN ;\n pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n }\n break ;\n case ATT_AAL_USER : pseudo_header -> atm . aal = AAL_USER ;\n pseudo_header -> atm . type = TRAF_UNKNOWN ;\n pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n case ATT_AAL_SIGNALLING : pseudo_header -> atm . aal = AAL_SIGNALLING ;\n pseudo_header -> atm . type = TRAF_UNKNOWN ;\n pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n case ATT_OAMCELL : pseudo_header -> atm . aal = AAL_OAMCELL ;\n pseudo_header -> atm . type = TRAF_UNKNOWN ;\n pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n default : pseudo_header -> atm . aal = AAL_UNKNOWN ;\n pseudo_header -> atm . type = TRAF_UNKNOWN ;\n pseudo_header -> atm . subtype = TRAF_ST_UNKNOWN ;\n break ;\n }\n pseudo_header -> atm . vpi = vpi ;\n pseudo_header -> atm . vci = vci ;\n pseudo_header -> atm . channel = pletoh16 ( & frame4 -> atm_info . channel ) ;\n pseudo_header -> atm . cells = pletoh16 ( & frame4 -> atm_info . cells ) ;\n pseudo_header -> atm . aal5t_u2u = pletoh16 ( & frame4 -> atm_info . Trailer . aal5t_u2u ) ;\n pseudo_header -> atm . aal5t_len = pletoh16 ( & frame4 -> atm_info . Trailer . aal5t_len ) ;\n pseudo_header -> atm . aal5t_chksum = pntoh32 ( & frame4 -> atm_info . Trailer . aal5t_chksum ) ;\n }", "hash": -1381237731082039179, "project": "debian", "size": 136, "target": 0, "idx": 9973}
{"code": "int ngsniffer_dump_can_write_encap ( int encap ) {\n if ( encap == WTAP_ENCAP_PER_PACKET ) return WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED ;\n if ( encap < 0 || ( unsigned ) encap >= NUM_WTAP_ENCAPS || wtap_encap [ encap ] == - 1 ) return WTAP_ERR_UNWRITABLE_ENCAP ;\n return 0 ;\n }", "hash": -1381237731082039179, "project": "debian", "size": 5, "target": 0, "idx": 9974}
{"code": "static void dissect_zcl_color_control_move_color_temp ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_move_mode , tvb , * offset , 1 , ENC_LITTLE_ENDIAN ) ;\n * offset += 1 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_enhanced_rate , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_color_temp_min , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_color_temp_max , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n }", "hash": -7236893719053583356, "project": "debian", "size": 10, "target": 0, "idx": 9998}
{"code": "static void dissect_zcl_color_control_move_to_hue_and_saturation ( tvbuff_t * tvb , proto_tree * tree , guint * offset , gboolean enhanced ) {\n if ( enhanced ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_enhanced_hue , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n }\n else {\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_hue , tvb , * offset , 1 , ENC_LITTLE_ENDIAN ) ;\n * offset += 1 ;\n }\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_saturation , tvb , * offset , 1 , ENC_LITTLE_ENDIAN ) ;\n * offset += 1 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_transit_time , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n }", "hash": -7236893719053583356, "project": "debian", "size": 14, "target": 0, "idx": 10004}
{"code": "static int dissect_zbee_zcl_color_control ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n proto_tree * payload_tree ;\n zbee_zcl_packet * zcl ;\n guint offset = 0 ;\n guint8 cmd_id ;\n gint rem_len ;\n if ( data == NULL ) return 0 ;\n zcl = ( zbee_zcl_packet * ) data ;\n cmd_id = zcl -> cmd_id ;\n if ( zcl -> direction == ZBEE_ZCL_FCF_TO_SERVER ) {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"%s, Seq: %u\" , val_to_str_const ( cmd_id , zbee_zcl_color_control_srv_rx_cmd_names , \"Unknown Command\" ) , zcl -> tran_seqno ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_color_control_srv_rx_cmd_id , tvb , offset , 1 , cmd_id ) ;\n rem_len = tvb_reported_length_remaining ( tvb , ++ offset ) ;\n if ( rem_len > 0 ) {\n payload_tree = proto_tree_add_subtree ( tree , tvb , offset , rem_len , ett_zbee_zcl_color_control , NULL , \"Payload\" ) ;\n switch ( cmd_id ) {\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_MOVE_TO_HUE : dissect_zcl_color_control_move_to_hue ( tvb , payload_tree , & offset , ZBEE_ZCL_NORMAL_HUE ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_MOVE_HUE : dissect_zcl_color_control_move_hue_saturation ( tvb , payload_tree , & offset , ZBEE_ZCL_NORMAL_HUE ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_STEP_HUE : dissect_zcl_color_control_step_hue_saturation ( tvb , payload_tree , & offset , ZBEE_ZCL_NORMAL_HUE ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_MOVE_TO_SATURATION : dissect_zcl_color_control_move_to_saturation ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_MOVE_SATURATION : dissect_zcl_color_control_move_hue_saturation ( tvb , payload_tree , & offset , ZBEE_ZCL_NORMAL_HUE ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_STEP_SATURATION : dissect_zcl_color_control_step_hue_saturation ( tvb , payload_tree , & offset , ZBEE_ZCL_NORMAL_HUE ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_MOVE_TO_HUE_AND_SATURATION : dissect_zcl_color_control_move_to_hue_and_saturation ( tvb , payload_tree , & offset , ZBEE_ZCL_NORMAL_HUE ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_MOVE_TO_COLOR : dissect_zcl_color_control_move_to_color ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_MOVE_COLOR : dissect_zcl_color_control_move_color ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_STEP_COLOR : dissect_zcl_color_control_step_color ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_MOVE_TO_COLOR_TEMP : dissect_zcl_color_control_move_to_color_temp ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_ENHANCED_MOVE_TO_HUE : dissect_zcl_color_control_move_to_hue ( tvb , payload_tree , & offset , ZBEE_ZCL_ENHANCED_HUE ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_ENHANCED_MOVE_HUE : dissect_zcl_color_control_move_hue_saturation ( tvb , payload_tree , & offset , ZBEE_ZCL_ENHANCED_HUE ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_ENHANCED_STEP_HUE : dissect_zcl_color_control_step_hue_saturation ( tvb , payload_tree , & offset , ZBEE_ZCL_ENHANCED_HUE ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_ENHANCED_MOVE_TO_HUE_AND_SATURATION : dissect_zcl_color_control_move_to_hue_and_saturation ( tvb , payload_tree , & offset , ZBEE_ZCL_ENHANCED_HUE ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_COLOR_LOOP_SET : dissect_zcl_color_control_color_loop_set ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_MOVE_COLOR_TEMP : dissect_zcl_color_control_move_color_temp ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_STEP_COLOR_TEMP : dissect_zcl_color_control_step_color_temp ( tvb , payload_tree , & offset ) ;\n break ;\n case ZBEE_ZCL_CMD_ID_COLOR_CONTROL_STOP_MOVE_STEP : default : break ;\n }\n }\n }\n return tvb_captured_length ( tvb ) ;\n }", "hash": -7236893719053583356, "project": "debian", "size": 58, "target": 0, "idx": 10011}
{"code": "int qemuMonitorTextGetBlockIoThrottle ( qemuMonitorPtr mon , const char * device , virDomainBlockIoTuneInfoPtr reply ) {\n char * result = NULL ;\n int ret = 0 ;\n const char * cmd_name = \"info block\" ;\n if ( qemuMonitorHMPCommand ( mon , cmd_name , & result ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"cannot run monitor command\" ) ) ;\n ret = - 1 ;\n goto cleanup ;\n }\n if ( qemuMonitorTextCommandNotFound ( cmd_name , result ) ) {\n qemuReportError ( VIR_ERR_OPERATION_INVALID , _ ( \"Command '%s' is not found\" ) , cmd_name ) ;\n ret = - 1 ;\n goto cleanup ;\n }\n ret = qemuMonitorTextParseBlockIoThrottle ( result , device , reply ) ;\n cleanup : VIR_FREE ( result ) ;\n return ret ;\n }", "hash": 378220832151730865, "project": "debian", "size": 18, "target": 0, "idx": 10017}
{"code": "int qemuMonitorTextGraphicsRelocate ( qemuMonitorPtr mon , int type , const char * hostname , int port , int tlsPort , const char * tlsSubject ) {\n char * cmd ;\n char * info = NULL ;\n if ( virAsprintf ( & cmd , \"client_migrate_info %s %s %d %d %s\" , type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE ? \"spice\" : \"vnc\" , hostname , port , tlsPort , tlsSubject ? tlsSubject : \"\" ) < 0 ) {\n virReportOOMError ( ) ;\n return - 1 ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & info ) < 0 ) {\n VIR_FREE ( cmd ) ;\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"cannot run monitor command to relocate graphics client\" ) ) ;\n return - 1 ;\n }\n VIR_FREE ( cmd ) ;\n VIR_FREE ( info ) ;\n return 0 ;\n }", "hash": 378220832151730865, "project": "debian", "size": 16, "target": 0, "idx": 10026}
{"code": "int qemuMonitorTextGetPtyPaths ( qemuMonitorPtr mon , virHashTablePtr paths ) {\n char * reply = NULL ;\n int ret = - 1 ;\n if ( qemuMonitorHMPCommand ( mon , \"info chardev\" , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"failed to retrieve chardev info in qemu with 'info chardev'\" ) ) ;\n return - 1 ;\n }\n char * pos ;\n char * next = reply ;\n char * eol ;\n char * end = reply + strlen ( reply ) ;\n while ( next ) {\n pos = next ;\n eol = memchr ( pos , '\\n' , end - pos ) ;\n if ( eol == NULL ) {\n eol = end ;\n next = NULL ;\n }\n else {\n next = eol + 1 ;\n }\n while ( eol > pos && c_isspace ( * ( eol - 1 ) ) ) eol -= 1 ;\n # define NEEDLE \"filename=pty:\" char * needle = memmem ( pos , eol - pos , NEEDLE , strlen ( NEEDLE ) ) ;\n if ( ! needle ) continue ;\n char * colon = memchr ( pos , ':' , needle - pos ) ;\n if ( colon == NULL ) continue ;\n * colon = '\\0' ;\n char * id = pos ;\n * eol = '\\0' ;\n char * path = strdup ( needle + strlen ( NEEDLE ) ) ;\n if ( path == NULL ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( virHashAddEntry ( paths , id , path ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"failed to save chardev path '%s'\" ) , path ) ;\n VIR_FREE ( path ) ;\n goto cleanup ;\n }\n # undef NEEDLE }\n ret = 0 ;\n cleanup : VIR_FREE ( reply ) ;\n return ret ;\n }", "hash": 378220832151730865, "project": "debian", "size": 44, "target": 0, "idx": 10027}
{"code": "int qemuMonitorTextMigrate ( qemuMonitorPtr mon , unsigned int flags , const char * dest ) {\n char * cmd = NULL ;\n char * info = NULL ;\n int ret = - 1 ;\n char * safedest = qemuMonitorEscapeArg ( dest ) ;\n virBuffer extra = VIR_BUFFER_INITIALIZER ;\n char * extrastr = NULL ;\n if ( ! safedest ) {\n virReportOOMError ( ) ;\n return - 1 ;\n }\n if ( flags & QEMU_MONITOR_MIGRATE_BACKGROUND ) virBufferAddLit ( & extra , \" -d\" ) ;\n if ( flags & QEMU_MONITOR_MIGRATE_NON_SHARED_DISK ) virBufferAddLit ( & extra , \" -b\" ) ;\n if ( flags & QEMU_MONITOR_MIGRATE_NON_SHARED_INC ) virBufferAddLit ( & extra , \" -i\" ) ;\n if ( virBufferError ( & extra ) ) {\n virBufferFreeAndReset ( & extra ) ;\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n extrastr = virBufferContentAndReset ( & extra ) ;\n if ( virAsprintf ( & cmd , \"migrate %s\\\"%s\\\"\" , extrastr ? extrastr : \"\" , safedest ) < 0 ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & info ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"unable to start migration to %s\" ) , dest ) ;\n goto cleanup ;\n }\n if ( strstr ( info , \"fail\" ) != NULL ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"migration to '%s' failed: %s\" ) , dest , info ) ;\n goto cleanup ;\n }\n if ( strstr ( info , \"unknown command:\" ) ) {\n qemuReportError ( VIR_ERR_OPERATION_INVALID , _ ( \"migration to '%s' not supported by this qemu: %s\" ) , dest , info ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( extrastr ) ;\n VIR_FREE ( safedest ) ;\n VIR_FREE ( info ) ;\n VIR_FREE ( cmd ) ;\n return ret ;\n }", "hash": 378220832151730865, "project": "debian", "size": 43, "target": 0, "idx": 10030}
{"code": "int qemuMonitorTextSetDrivePassphrase ( qemuMonitorPtr mon , const char * alias , const char * passphrase ) {\n char * cmd = NULL ;\n char * reply = NULL ;\n int ret = - 1 ;\n char * safe_str ;\n safe_str = qemuMonitorEscapeArg ( passphrase ) ;\n if ( ! safe_str ) {\n virReportOOMError ( ) ;\n return - 1 ;\n }\n if ( virAsprintf ( & cmd , \"block_passwd %s%s \\\"%s\\\"\" , QEMU_DRIVE_HOST_PREFIX , alias , safe_str ) < 0 ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"failed to set disk password\" ) ) ;\n goto cleanup ;\n }\n if ( strstr ( reply , \"unknown command:\" ) ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"setting disk password is not supported\" ) ) ;\n goto cleanup ;\n }\n else if ( strstr ( reply , \"The entered password is invalid\" ) ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"the disk password is incorrect\" ) ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( cmd ) ;\n VIR_FREE ( reply ) ;\n VIR_FREE ( safe_str ) ;\n return ret ;\n }", "hash": 378220832151730865, "project": "debian", "size": 32, "target": 0, "idx": 10039}
{"code": "int qemuMonitorTextAddDrive ( qemuMonitorPtr mon , const char * drivestr ) {\n char * cmd = NULL ;\n char * reply = NULL ;\n int ret = - 1 ;\n char * safe_str ;\n safe_str = qemuMonitorEscapeArg ( drivestr ) ;\n if ( ! safe_str ) {\n virReportOOMError ( ) ;\n return - 1 ;\n }\n if ( virAsprintf ( & cmd , \"drive_add dummy %s\" , safe_str ) < 0 ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"failed to add drive '%s'\" ) , drivestr ) ;\n goto cleanup ;\n }\n if ( strstr ( reply , \"unknown command:\" ) ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"drive hotplug is not supported\" ) ) ;\n goto cleanup ;\n }\n if ( strstr ( reply , \"could not open disk image\" ) ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"open disk image file failed\" ) ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( cmd ) ;\n VIR_FREE ( reply ) ;\n VIR_FREE ( safe_str ) ;\n return ret ;\n }", "hash": 378220832151730865, "project": "debian", "size": 32, "target": 0, "idx": 10052}
{"code": "static int qemuMonitorTextCommandNotFound ( const char * cmd , const char * reply ) {\n if ( STRPREFIX ( cmd , \"info \" ) ) {\n if ( strstr ( reply , \"info version\" ) ) return 1 ;\n }\n else {\n if ( strstr ( reply , \"unknown command:\" ) ) return 1 ;\n }\n return 0 ;\n }", "hash": 378220832151730865, "project": "debian", "size": 9, "target": 0, "idx": 10059}
{"code": "int qemuMonitorTextGetAllPCIAddresses ( qemuMonitorPtr mon , qemuMonitorPCIAddress * * retaddrs ) {\n char * reply ;\n qemuMonitorPCIAddress * addrs = NULL ;\n int naddrs = 0 ;\n char * p ;\n * retaddrs = NULL ;\n if ( qemuMonitorHMPCommand ( mon , \"info pci\" , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"cannot query PCI addresses\" ) ) ;\n return - 1 ;\n }\n p = reply ;\n while ( p ) {\n unsigned int bus , slot , func , vendor , product ;\n SKIP_TO ( p , \" Bus\" ) ;\n CHECK_END ( p ) ;\n SKIP_SPACE ( p ) ;\n GET_INT ( p , 10 , bus ) ;\n CHECK_END ( p ) ;\n SKIP_TO ( p , \", device\" ) ;\n CHECK_END ( p ) ;\n SKIP_SPACE ( p ) ;\n GET_INT ( p , 10 , slot ) ;\n CHECK_END ( p ) ;\n SKIP_TO ( p , \", function\" ) ;\n CHECK_END ( p ) ;\n SKIP_SPACE ( p ) ;\n GET_INT ( p , 10 , func ) ;\n CHECK_END ( p ) ;\n SKIP_TO ( p , \"PCI device\" ) ;\n CHECK_END ( p ) ;\n SKIP_SPACE ( p ) ;\n GET_INT ( p , 16 , vendor ) ;\n CHECK_END ( p ) ;\n if ( * p != ':' ) break ;\n p ++ ;\n GET_INT ( p , 16 , product ) ;\n if ( VIR_REALLOC_N ( addrs , naddrs + 1 ) < 0 ) {\n virReportOOMError ( ) ;\n goto error ;\n }\n addrs [ naddrs ] . addr . domain = 0 ;\n addrs [ naddrs ] . addr . bus = bus ;\n addrs [ naddrs ] . addr . slot = slot ;\n addrs [ naddrs ] . addr . function = func ;\n addrs [ naddrs ] . vendor = vendor ;\n addrs [ naddrs ] . product = product ;\n naddrs ++ ;\n VIR_DEBUG ( \"Got dev %d:%d:%d %x:%x\" , bus , slot , func , vendor , product ) ;\n }\n VIR_FREE ( reply ) ;\n * retaddrs = addrs ;\n return naddrs ;\n error : VIR_FREE ( addrs ) ;\n VIR_FREE ( reply ) ;\n return - 1 ;\n }", "hash": 378220832151730865, "project": "debian", "size": 56, "target": 0, "idx": 10060}
{"code": "int qemuMonitorTextScreendump ( qemuMonitorPtr mon , const char * file ) {\n char * cmd = NULL ;\n char * reply = NULL ;\n int ret = - 1 ;\n if ( virAsprintf ( & cmd , \"screendump %s\" , file ) < 0 ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"taking screenshot failed\" ) ) ;\n goto cleanup ;\n }\n if ( strstr ( reply , \"unknown command:\" ) ) {\n ret = - 2 ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( reply ) ;\n VIR_FREE ( cmd ) ;\n return ret ;\n }", "hash": 378220832151730865, "project": "debian", "size": 21, "target": 0, "idx": 10063}
{"code": "int qemuMonitorTextArbitraryCommand ( qemuMonitorPtr mon , const char * cmd , char * * reply ) {\n char * safecmd = NULL ;\n int ret ;\n if ( ! ( safecmd = qemuMonitorEscapeArg ( cmd ) ) ) {\n virReportOOMError ( ) ;\n return - 1 ;\n }\n ret = qemuMonitorHMPCommand ( mon , safecmd , reply ) ;\n if ( ret != 0 ) qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"failed to run cmd '%s'\" ) , safecmd ) ;\n VIR_FREE ( safecmd ) ;\n return ret ;\n }", "hash": 378220832151730865, "project": "debian", "size": 12, "target": 0, "idx": 10065}
{"code": "int qemuMonitorTextGetMemoryStats ( qemuMonitorPtr mon , virDomainMemoryStatPtr stats , unsigned int nr_stats ) {\n char * reply = NULL ;\n int ret = 0 ;\n char * offset ;\n if ( qemuMonitorHMPCommand ( mon , \"info balloon\" , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"could not query memory balloon statistics\" ) ) ;\n return - 1 ;\n }\n if ( ( offset = strstr ( reply , BALLOON_PREFIX ) ) != NULL ) {\n offset += strlen ( BALLOON_PREFIX ) ;\n ret = qemuMonitorParseBalloonInfo ( offset , stats , nr_stats ) ;\n }\n VIR_FREE ( reply ) ;\n return ret ;\n }", "hash": 378220832151730865, "project": "debian", "size": 15, "target": 0, "idx": 10066}
{"code": "int qemuMonitorTextSetPassword ( qemuMonitorPtr mon , const char * protocol , const char * password , const char * action_if_connected ) {\n char * cmd = NULL ;\n char * reply = NULL ;\n int ret = - 1 ;\n if ( virAsprintf ( & cmd , \"set_password %s \\\"%s\\\" %s\" , protocol , password , action_if_connected ) < 0 ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"setting password failed\" ) ) ;\n goto cleanup ;\n }\n if ( strstr ( reply , \"unknown command:\" ) ) {\n ret = - 2 ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( reply ) ;\n VIR_FREE ( cmd ) ;\n return ret ;\n }", "hash": 378220832151730865, "project": "debian", "size": 21, "target": 0, "idx": 10088}
{"code": "static int qemuMonitorTextAddUSBDevice ( qemuMonitorPtr mon , const char * addr ) {\n char * cmd ;\n char * reply = NULL ;\n int ret = - 1 ;\n if ( virAsprintf ( & cmd , \"usb_add %s\" , addr ) < 0 ) {\n virReportOOMError ( ) ;\n return - 1 ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"cannot attach usb device\" ) ) ;\n goto cleanup ;\n }\n if ( strstr ( reply , \"Could not add \" ) ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"adding usb device failed\" ) ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( cmd ) ;\n VIR_FREE ( reply ) ;\n return ret ;\n }", "hash": 378220832151730865, "project": "debian", "size": 21, "target": 0, "idx": 10094}
{"code": "static int qemuMonitorJSONGetGuestDriveAddress ( virJSONValuePtr reply , virDomainDeviceDriveAddress * driveAddr ) {\n virJSONValuePtr addr ;\n addr = virJSONValueObjectGet ( reply , \"return\" ) ;\n if ( ! addr || addr -> type != VIR_JSON_TYPE_OBJECT ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"drive_add reply was missing device address\" ) ) ;\n return - 1 ;\n }\n if ( virJSONValueObjectGetNumberUint ( addr , \"bus\" , & driveAddr -> bus ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"drive_add reply was missing device bus number\" ) ) ;\n return - 1 ;\n }\n if ( virJSONValueObjectGetNumberUint ( addr , \"unit\" , & driveAddr -> unit ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"drive_add reply was missing device unit number\" ) ) ;\n return - 1 ;\n }\n return 0 ;\n }", "hash": 7651945086108393719, "project": "debian", "size": 17, "target": 0, "idx": 10102}
{"code": "static int qemuMonitorJSONGetBlockJobInfoOne ( virJSONValuePtr entry , const char * device , virDomainBlockJobInfoPtr info ) {\n const char * this_dev ;\n const char * type ;\n unsigned long long speed_bytes ;\n if ( ( this_dev = virJSONValueObjectGetString ( entry , \"device\" ) ) == NULL ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"entry was missing 'device'\" ) ) ;\n return - 1 ;\n }\n if ( ! STREQ ( this_dev , device ) ) return - 1 ;\n type = virJSONValueObjectGetString ( entry , \"type\" ) ;\n if ( ! type ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"entry was missing 'type'\" ) ) ;\n return - 1 ;\n }\n if ( STREQ ( type , \"stream\" ) ) info -> type = VIR_DOMAIN_BLOCK_JOB_TYPE_PULL ;\n else info -> type = VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN ;\n if ( virJSONValueObjectGetNumberUlong ( entry , \"speed\" , & speed_bytes ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"entry was missing 'speed'\" ) ) ;\n return - 1 ;\n }\n info -> bandwidth = speed_bytes / 1024ULL / 1024ULL ;\n if ( virJSONValueObjectGetNumberUlong ( entry , \"offset\" , & info -> cur ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"entry was missing 'offset'\" ) ) ;\n return - 1 ;\n }\n if ( virJSONValueObjectGetNumberUlong ( entry , \"len\" , & info -> end ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"entry was missing 'len'\" ) ) ;\n return - 1 ;\n }\n return 0 ;\n }", "hash": 7651945086108393719, "project": "debian", "size": 31, "target": 0, "idx": 10108}
{"code": "int qemuMonitorJSONEjectMedia ( qemuMonitorPtr mon , const char * dev_name , bool force ) {\n int ret ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( \"eject\" , \"s:device\" , dev_name , \"b:force\" , force ? 1 : 0 , NULL ) ;\n virJSONValuePtr reply = NULL ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "hash": 7651945086108393719, "project": "debian", "size": 11, "target": 0, "idx": 10112}
{"code": "int qemuMonitorJSONHumanCommandWithFd ( qemuMonitorPtr mon , const char * cmd_str , int scm_fd , char * * reply_str ) {\n virJSONValuePtr cmd = NULL ;\n virJSONValuePtr reply = NULL ;\n virJSONValuePtr obj ;\n int ret = - 1 ;\n cmd = qemuMonitorJSONMakeCommand ( \"human-monitor-command\" , \"s:command-line\" , cmd_str , NULL ) ;\n if ( ! cmd || qemuMonitorJSONCommandWithFd ( mon , cmd , scm_fd , & reply ) < 0 ) goto cleanup ;\n if ( qemuMonitorJSONCheckError ( cmd , reply ) ) goto cleanup ;\n if ( ! ( obj = virJSONValueObjectGet ( reply , \"return\" ) ) ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"human monitor command was missing return data\" ) ) ;\n goto cleanup ;\n }\n if ( reply_str ) {\n const char * data ;\n if ( ( data = virJSONValueGetString ( obj ) ) ) * reply_str = strdup ( data ) ;\n else * reply_str = strdup ( \"\" ) ;\n if ( ! * reply_str ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n }\n ret = 0 ;\n cleanup : virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "hash": 7651945086108393719, "project": "debian", "size": 26, "target": 0, "idx": 10116}
{"code": "int qemuMonitorJSONAddDrive ( qemuMonitorPtr mon , const char * drivestr ) {\n int ret ;\n virJSONValuePtr cmd ;\n virJSONValuePtr reply = NULL ;\n cmd = qemuMonitorJSONMakeCommand ( \"drive_add\" , \"s:pci_addr\" , \"dummy\" , \"s:opts\" , drivestr , NULL ) ;\n if ( ! cmd ) return - 1 ;\n if ( ( ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) < 0 ) ) goto cleanup ;\n if ( qemuMonitorJSONHasError ( reply , \"CommandNotFound\" ) && qemuMonitorCheckHMP ( mon , \"drive_add\" ) ) {\n VIR_DEBUG ( \"drive_add command not found, trying HMP\" ) ;\n ret = qemuMonitorTextAddDrive ( mon , drivestr ) ;\n goto cleanup ;\n }\n ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n cleanup : virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "hash": 7651945086108393719, "project": "debian", "size": 17, "target": 0, "idx": 10119}
{"code": "int qemuMonitorJSONMigrate ( qemuMonitorPtr mon , unsigned int flags , const char * uri ) {\n int ret ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( \"migrate\" , \"b:detach\" , flags & QEMU_MONITOR_MIGRATE_BACKGROUND ? 1 : 0 , \"b:blk\" , flags & QEMU_MONITOR_MIGRATE_NON_SHARED_DISK ? 1 : 0 , \"b:inc\" , flags & QEMU_MONITOR_MIGRATE_NON_SHARED_INC ? 1 : 0 , \"s:uri\" , uri , NULL ) ;\n virJSONValuePtr reply = NULL ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "hash": 7651945086108393719, "project": "debian", "size": 11, "target": 0, "idx": 10128}
{"code": "static int qemuMonitorJSONSaveMemory ( qemuMonitorPtr mon , const char * cmdtype , unsigned long long offset , size_t length , const char * path ) {\n int ret ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( cmdtype , \"U:val\" , offset , \"u:size\" , length , \"s:filename\" , path , NULL ) ;\n virJSONValuePtr reply = NULL ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "hash": 7651945086108393719, "project": "debian", "size": 11, "target": 0, "idx": 10132}
{"code": "int qemuMonitorJSONGetBlockExtent ( qemuMonitorPtr mon , const char * dev_name , unsigned long long * extent ) {\n int ret = - 1 ;\n int i ;\n int found = 0 ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( \"query-blockstats\" , NULL ) ;\n virJSONValuePtr reply = NULL ;\n virJSONValuePtr devices ;\n * extent = 0 ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n if ( ret < 0 ) goto cleanup ;\n ret = - 1 ;\n devices = virJSONValueObjectGet ( reply , \"return\" ) ;\n if ( ! devices || devices -> type != VIR_JSON_TYPE_ARRAY ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"blockstats reply was missing device list\" ) ) ;\n goto cleanup ;\n }\n for ( i = 0 ;\n i < virJSONValueArraySize ( devices ) ;\n i ++ ) {\n virJSONValuePtr dev = virJSONValueArrayGet ( devices , i ) ;\n virJSONValuePtr stats ;\n virJSONValuePtr parent ;\n const char * thisdev ;\n if ( ! dev || dev -> type != VIR_JSON_TYPE_OBJECT ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"blockstats device entry was not in expected format\" ) ) ;\n goto cleanup ;\n }\n if ( ( thisdev = virJSONValueObjectGetString ( dev , \"device\" ) ) == NULL ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"blockstats device entry was not in expected format\" ) ) ;\n goto cleanup ;\n }\n if ( STRPREFIX ( thisdev , QEMU_DRIVE_HOST_PREFIX ) ) thisdev += strlen ( QEMU_DRIVE_HOST_PREFIX ) ;\n if ( STRNEQ ( thisdev , dev_name ) ) continue ;\n found = 1 ;\n if ( ( parent = virJSONValueObjectGet ( dev , \"parent\" ) ) == NULL || parent -> type != VIR_JSON_TYPE_OBJECT ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"blockstats parent entry was not in expected format\" ) ) ;\n goto cleanup ;\n }\n if ( ( stats = virJSONValueObjectGet ( parent , \"stats\" ) ) == NULL || stats -> type != VIR_JSON_TYPE_OBJECT ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"blockstats stats entry was not in expected format\" ) ) ;\n goto cleanup ;\n }\n if ( virJSONValueObjectGetNumberUlong ( stats , \"wr_highest_offset\" , extent ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot read %s statistic\" ) , \"wr_highest_offset\" ) ;\n goto cleanup ;\n }\n }\n if ( ! found ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( \"cannot find statistics for device '%s'\" ) , dev_name ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "hash": 7651945086108393719, "project": "debian", "size": 58, "target": 0, "idx": 10135}
{"code": "int qemuMonitorJSONSystemReset ( qemuMonitorPtr mon ) {\n int ret ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( \"system_reset\" , NULL ) ;\n virJSONValuePtr reply = NULL ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "hash": 7651945086108393719, "project": "debian", "size": 11, "target": 0, "idx": 10136}
{"code": "int qemuMonitorJSONGetCPUInfo ( qemuMonitorPtr mon , int * * pids ) {\n int ret ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( \"query-cpus\" , NULL ) ;\n virJSONValuePtr reply = NULL ;\n * pids = NULL ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONExtractCPUInfo ( reply , pids ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "hash": 7651945086108393719, "project": "debian", "size": 13, "target": 0, "idx": 10139}
{"code": "int qemuMonitorJSONSystemPowerdown ( qemuMonitorPtr mon ) {\n int ret ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( \"system_powerdown\" , NULL ) ;\n virJSONValuePtr reply = NULL ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "hash": 7651945086108393719, "project": "debian", "size": 11, "target": 0, "idx": 10141}
{"code": "static MagickBooleanType IsIPL ( const unsigned char * magick , const size_t length ) {\n if ( length < 4 ) return ( MagickFalse ) ;\n if ( LocaleNCompare ( ( const char * ) magick , \"data\" , 4 ) == 0 ) return ( MagickTrue ) ;\n return ( MagickFalse ) ;\n }", "hash": 3167715554364353813, "project": "debian", "size": 5, "target": 0, "idx": 10187}
{"code": "int jas_stream_putc_func ( jas_stream_t * stream , int c ) {\n assert ( stream -> ptr_ - stream -> bufstart_ <= stream -> bufsize_ ) ;\n return jas_stream_putc_macro ( stream , c ) ;\n }", "hash": 6675626110148442062, "project": "debian", "size": 4, "target": 0, "idx": 10200}
{"code": "int jas_stream_ungetc ( jas_stream_t * stream , int c ) {\n if ( ! stream -> ptr_ || stream -> ptr_ == stream -> bufbase_ ) {\n return - 1 ;\n }\n stream -> flags_ &= ~ JAS_STREAM_EOF ;\n -- stream -> rwcnt_ ;\n -- stream -> ptr_ ;\n ++ stream -> cnt_ ;\n * stream -> ptr_ = c ;\n return 0 ;\n }", "hash": 6675626110148442062, "project": "debian", "size": 11, "target": 0, "idx": 10211}
{"code": "static void jas_stream_initbuf ( jas_stream_t * stream , int bufmode , char * buf , int bufsize ) {\n assert ( ! stream -> bufbase_ ) ;\n if ( bufmode != JAS_STREAM_UNBUF ) {\n if ( ! buf ) {\n if ( ( stream -> bufbase_ = jas_malloc ( JAS_STREAM_BUFSIZE + JAS_STREAM_MAXPUTBACK ) ) ) {\n stream -> bufmode_ |= JAS_STREAM_FREEBUF ;\n stream -> bufsize_ = JAS_STREAM_BUFSIZE ;\n }\n else {\n stream -> bufbase_ = stream -> tinybuf_ ;\n stream -> bufsize_ = 1 ;\n }\n }\n else {\n assert ( bufsize > JAS_STREAM_MAXPUTBACK ) ;\n stream -> bufbase_ = JAS_CAST ( uchar * , buf ) ;\n stream -> bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK ;\n }\n }\n else {\n assert ( ! buf ) ;\n stream -> bufbase_ = stream -> tinybuf_ ;\n stream -> bufsize_ = 1 ;\n }\n stream -> bufstart_ = & stream -> bufbase_ [ JAS_STREAM_MAXPUTBACK ] ;\n stream -> ptr_ = stream -> bufstart_ ;\n stream -> cnt_ = 0 ;\n stream -> bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK ;\n }", "hash": 6675626110148442062, "project": "debian", "size": 29, "target": 0, "idx": 10215}
{"code": "int jas_stream_printf ( jas_stream_t * stream , const char * fmt , ... ) {\n va_list ap ;\n char buf [ 4096 ] ;\n int ret ;\n va_start ( ap , fmt ) ;\n ret = vsnprintf ( buf , sizeof buf , fmt , ap ) ;\n jas_stream_puts ( stream , buf ) ;\n va_end ( ap ) ;\n return ret ;\n }", "hash": 6675626110148442062, "project": "debian", "size": 10, "target": 0, "idx": 10218}
{"code": "static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) {\n unsigned char * buf ;\n assert ( bufsize >= 0 ) ;\n if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) {\n return - 1 ;\n }\n m -> buf_ = buf ;\n m -> bufsize_ = bufsize ;\n return 0 ;\n }", "hash": 6675626110148442062, "project": "debian", "size": 10, "target": 0, "idx": 10228}
{"code": "long jas_stream_seek ( jas_stream_t * stream , long offset , int origin ) {\n long newpos ;\n assert ( ! ( ( stream -> bufmode_ & JAS_STREAM_RDBUF ) && ( stream -> bufmode_ & JAS_STREAM_WRBUF ) ) ) ;\n stream -> flags_ &= ~ JAS_STREAM_EOF ;\n if ( stream -> bufmode_ & JAS_STREAM_RDBUF ) {\n if ( origin == SEEK_CUR ) {\n offset -= stream -> cnt_ ;\n }\n }\n else if ( stream -> bufmode_ & JAS_STREAM_WRBUF ) {\n if ( jas_stream_flush ( stream ) ) {\n return - 1 ;\n }\n }\n stream -> cnt_ = 0 ;\n stream -> ptr_ = stream -> bufstart_ ;\n stream -> bufmode_ &= ~ ( JAS_STREAM_RDBUF | JAS_STREAM_WRBUF ) ;\n if ( ( newpos = ( * stream -> ops_ -> seek_ ) ( stream -> obj_ , offset , origin ) ) < 0 ) {\n return - 1 ;\n }\n return newpos ;\n }", "hash": 6675626110148442062, "project": "debian", "size": 22, "target": 0, "idx": 10229}
{"code": "apr_status_t mgs_cleanup_pre_config ( void * data __attribute__ ( ( unused ) ) ) {\n gnutls_free ( session_ticket_key . data ) ;\n session_ticket_key . data = NULL ;\n session_ticket_key . size = 0 ;\n gnutls_global_deinit ( ) ;\n return APR_SUCCESS ;\n }", "hash": 9173748358801811781, "project": "debian", "size": 7, "target": 0, "idx": 10236}
{"code": "static int mgs_select_virtual_server_cb ( gnutls_session_t session ) {\n mgs_handle_t * ctxt = NULL ;\n mgs_srvconf_rec * tsc = NULL ;\n int ret = 0 ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n ctxt = gnutls_transport_get_ptr ( session ) ;\n tsc = mgs_find_sni_server ( session ) ;\n if ( tsc != NULL ) {\n ctxt -> sc = tsc ;\n }\n gnutls_certificate_server_set_request ( session , ctxt -> sc -> client_verify_mode ) ;\n gnutls_credentials_set ( session , GNUTLS_CRD_CERTIFICATE , ctxt -> sc -> certs ) ;\n gnutls_credentials_set ( session , GNUTLS_CRD_ANON , ctxt -> sc -> anon_creds ) ;\n # ifdef ENABLE_SRP if ( ctxt -> sc -> srp_tpasswd_conf_file != NULL && ctxt -> sc -> srp_tpasswd_file != NULL ) {\n gnutls_credentials_set ( session , GNUTLS_CRD_SRP , ctxt -> sc -> srp_creds ) ;\n }\n # endif ret = gnutls_priority_set ( session , ctxt -> sc -> priorities ) ;\n return ret ;\n }", "hash": 9173748358801811781, "project": "debian", "size": 19, "target": 0, "idx": 10240}
{"code": "mgs_srvconf_rec * mgs_find_sni_server ( gnutls_session_t session ) {\n int rv ;\n unsigned int sni_type ;\n size_t data_len = MAX_HOST_LEN ;\n char sni_name [ MAX_HOST_LEN ] ;\n mgs_handle_t * ctxt ;\n # if USING_2_1_RECENT vhost_cb_rec cbx ;\n # else server_rec * s ;\n mgs_srvconf_rec * tsc ;\n # endif if ( session == NULL ) return NULL ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n ctxt = gnutls_transport_get_ptr ( session ) ;\n rv = gnutls_server_name_get ( ctxt -> session , sni_name , & data_len , & sni_type , 0 ) ;\n if ( rv != 0 ) {\n return NULL ;\n }\n if ( sni_type != GNUTLS_NAME_DNS ) {\n ap_log_error ( APLOG_MARK , APLOG_CRIT , 0 , ctxt -> c -> base_server , \"GnuTLS: Unknown type '%d' for SNI: \" \"'%s'\" , sni_type , sni_name ) ;\n return NULL ;\n }\n # if USING_2_1_RECENT cbx . ctxt = ctxt ;\n cbx . sc = NULL ;\n cbx . sni_name = sni_name ;\n rv = ap_vhost_iterate_given_conn ( ctxt -> c , vhost_cb , & cbx ) ;\n if ( rv == 1 ) {\n return cbx . sc ;\n }\n # else for ( s = ap_server_conf ;\n s ;\n s = s -> next ) {\n tsc = ( mgs_srvconf_rec * ) ap_get_module_config ( s -> module_config , & gnutls_module ) ;\n if ( tsc -> enabled != GNUTLS_ENABLED_TRUE ) {\n continue ;\n }\n if ( check_server_aliases ( x , s , tsc ) ) {\n return tsc ;\n }\n # endif return NULL ;\n }\n static void create_gnutls_handle ( conn_rec * c ) {\n mgs_srvconf_rec * sc = ( mgs_srvconf_rec * ) ap_get_module_config ( c -> base_server -> module_config , & gnutls_module ) ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n mgs_handle_t * ctxt = ( mgs_handle_t * ) ap_get_module_config ( c -> conn_config , & gnutls_module ) ;\n if ( ctxt == NULL ) {\n ap_log_cerror ( APLOG_MARK , APLOG_DEBUG , 0 , c , \"%s: allocating connection memory\" , __func__ ) ;\n ctxt = apr_pcalloc ( c -> pool , sizeof ( * ctxt ) ) ;\n ap_set_module_config ( c -> conn_config , & gnutls_module , ctxt ) ;\n }\n ctxt -> enabled = GNUTLS_ENABLED_TRUE ;\n ctxt -> c = c ;\n ctxt -> sc = sc ;\n ctxt -> status = 0 ;\n ctxt -> input_rc = APR_SUCCESS ;\n ctxt -> input_bb = apr_brigade_create ( c -> pool , c -> bucket_alloc ) ;\n ctxt -> input_cbuf . length = 0 ;\n ctxt -> output_rc = APR_SUCCESS ;\n ctxt -> output_bb = apr_brigade_create ( c -> pool , c -> bucket_alloc ) ;\n ctxt -> output_blen = 0 ;\n ctxt -> output_length = 0 ;\n int err = gnutls_init ( & ctxt -> session , GNUTLS_SERVER ) ;\n if ( err != GNUTLS_E_SUCCESS ) ap_log_cerror ( APLOG_MARK , APLOG_ERR , err , c , \"gnutls_init failed!\" ) ;\n if ( session_ticket_key . data != NULL && ctxt -> sc -> tickets != 0 ) {\n err = gnutls_session_ticket_enable_server ( ctxt -> session , & session_ticket_key ) ;\n if ( err != GNUTLS_E_SUCCESS ) ap_log_cerror ( APLOG_MARK , APLOG_ERR , err , c , \"gnutls_session_ticket_enable_server failed!\" ) ;\n }\n err = gnutls_priority_set_direct ( ctxt -> session , \"NORMAL\" , NULL ) ;\n if ( err != GNUTLS_E_SUCCESS ) ap_log_cerror ( APLOG_MARK , APLOG_ERR , err , c , \"gnutls_priority_set_direct failed!\" ) ;\n gnutls_handshake_set_post_client_hello_function ( ctxt -> session , mgs_select_virtual_server_cb ) ;\n mgs_cache_session_init ( ctxt ) ;\n gnutls_transport_set_pull_function ( ctxt -> session , mgs_transport_read ) ;\n gnutls_transport_set_push_function ( ctxt -> session , mgs_transport_write ) ;\n gnutls_transport_set_ptr ( ctxt -> session , ctxt ) ;\n ctxt -> input_filter = ap_add_input_filter ( GNUTLS_INPUT_FILTER_NAME , ctxt , NULL , c ) ;\n ctxt -> output_filter = ap_add_output_filter ( GNUTLS_OUTPUT_FILTER_NAME , ctxt , NULL , c ) ;\n }\n int mgs_hook_pre_connection ( conn_rec * c , void * csd __attribute__ ( ( unused ) ) ) {\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n mgs_srvconf_rec * sc = ( mgs_srvconf_rec * ) ap_get_module_config ( c -> base_server -> module_config , & gnutls_module ) ;\n mgs_handle_t * ctxt = ( mgs_handle_t * ) ap_get_module_config ( c -> conn_config , & gnutls_module ) ;\n if ( ( sc && ( ! sc -> enabled || sc -> proxy_enabled == GNUTLS_ENABLED_TRUE ) ) || ( ctxt && ctxt -> enabled == GNUTLS_ENABLED_FALSE ) ) {\n ap_log_cerror ( APLOG_MARK , APLOG_DEBUG , 0 , c , \"%s declined connection\" , __func__ ) ;\n return DECLINED ;\n }\n create_gnutls_handle ( c ) ;\n return OK ;\n }\n int mgs_hook_fixups ( request_rec * r ) {\n unsigned char sbuf [ GNUTLS_MAX_SESSION_ID ] ;\n char buf [ AP_IOBUFSIZE ] ;\n const char * tmp ;\n size_t len ;\n mgs_handle_t * ctxt ;\n int rv = OK ;\n if ( r == NULL ) return DECLINED ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n apr_table_t * env = r -> subprocess_env ;\n ctxt = ap_get_module_config ( r -> connection -> conn_config , & gnutls_module ) ;\n if ( ! ctxt || ctxt -> enabled != GNUTLS_ENABLED_TRUE || ctxt -> session == NULL ) {\n ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , \"request declined in %s\" , __func__ ) ;\n return DECLINED ;\n }\n apr_table_setn ( env , \"HTTPS\" , \"on\" ) ;\n apr_table_setn ( env , \"SSL_VERSION_LIBRARY\" , \"GnuTLS/\" LIBGNUTLS_VERSION ) ;\n apr_table_setn ( env , \"SSL_VERSION_INTERFACE\" , \"mod_gnutls/\" MOD_GNUTLS_VERSION ) ;\n apr_table_setn ( env , \"SSL_PROTOCOL\" , gnutls_protocol_get_name ( gnutls_protocol_get_version ( ctxt -> session ) ) ) ;\n apr_table_setn ( env , \"SSL_CIPHER\" , gnutls_cipher_suite_get_name ( gnutls_kx_get ( ctxt -> session ) , gnutls_cipher_get ( ctxt -> session ) , gnutls_mac_get ( ctxt -> session ) ) ) ;\n apr_table_setn ( env , \"SSL_COMPRESS_METHOD\" , gnutls_compression_get_name ( gnutls_compression_get ( ctxt -> session ) ) ) ;\n # ifdef ENABLE_SRP if ( ctxt -> sc -> srp_tpasswd_conf_file != NULL && ctxt -> sc -> srp_tpasswd_file != NULL ) {\n tmp = gnutls_srp_server_get_username ( ctxt -> session ) ;\n apr_table_setn ( env , \"SSL_SRP_USER\" , ( tmp != NULL ) ? tmp : \"\" ) ;\n }\n else {\n apr_table_unset ( env , \"SSL_SRP_USER\" ) ;\n }\n # endif if ( apr_table_get ( env , \"SSL_CLIENT_VERIFY\" ) == NULL ) apr_table_setn ( env , \"SSL_CLIENT_VERIFY\" , \"NONE\" ) ;\n unsigned int key_size = 8 * gnutls_cipher_get_key_size ( gnutls_cipher_get ( ctxt -> session ) ) ;\n tmp = apr_psprintf ( r -> pool , \"%u\" , key_size ) ;\n apr_table_setn ( env , \"SSL_CIPHER_USEKEYSIZE\" , tmp ) ;\n apr_table_setn ( env , \"SSL_CIPHER_ALGKEYSIZE\" , tmp ) ;\n apr_table_setn ( env , \"SSL_CIPHER_EXPORT\" , ( key_size <= 40 ) ? \"true\" : \"false\" ) ;\n int dhsize = gnutls_dh_get_prime_bits ( ctxt -> session ) ;\n if ( dhsize > 0 ) {\n tmp = apr_psprintf ( r -> pool , \"%d\" , dhsize ) ;\n apr_table_setn ( env , \"SSL_DH_PRIME_BITS\" , tmp ) ;\n }\n len = sizeof ( sbuf ) ;\n gnutls_session_get_id ( ctxt -> session , sbuf , & len ) ;\n tmp = mgs_session_id2sz ( sbuf , len , buf , sizeof ( buf ) ) ;\n apr_table_setn ( env , \"SSL_SESSION_ID\" , apr_pstrdup ( r -> pool , tmp ) ) ;\n if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_X509 ) {\n mgs_add_common_cert_vars ( r , ctxt -> sc -> certs_x509_chain [ 0 ] , 0 , ctxt -> sc -> export_certificates_size ) ;\n }\n else if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_OPENPGP ) {\n mgs_add_common_pgpcert_vars ( r , ctxt -> sc -> cert_pgp , 0 , ctxt -> sc -> export_certificates_size ) ;\n }\n return rv ;\n }\n int mgs_hook_authz ( request_rec * r ) {\n int rv ;\n mgs_handle_t * ctxt ;\n mgs_dirconf_rec * dc ;\n if ( r == NULL ) return DECLINED ;\n dc = ap_get_module_config ( r -> per_dir_config , & gnutls_module ) ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n ctxt = ap_get_module_config ( r -> connection -> conn_config , & gnutls_module ) ;\n if ( ! ctxt || ctxt -> session == NULL ) {\n return DECLINED ;\n }\n if ( dc -> client_verify_mode == GNUTLS_CERT_IGNORE ) {\n ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , \"GnuTLS: Directory set to Ignore Client Certificate!\" ) ;\n }\n else {\n if ( ctxt -> sc -> client_verify_mode < dc -> client_verify_mode ) {\n ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , \"GnuTLS: Attempting to rehandshake with peer. %d %d\" , ctxt -> sc -> client_verify_mode , dc -> client_verify_mode ) ;\n rv = mgs_cert_verify ( r , ctxt ) ;\n if ( rv != DECLINED && rv != HTTP_FORBIDDEN ) return rv ;\n gnutls_certificate_server_set_request ( ctxt -> session , dc -> client_verify_mode ) ;\n if ( mgs_rehandshake ( ctxt ) != 0 ) {\n return HTTP_FORBIDDEN ;\n }\n }\n else if ( ctxt -> sc -> client_verify_mode == GNUTLS_CERT_IGNORE ) {\n # if MOD_GNUTLS_DEBUG ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Peer is set to IGNORE\" ) ;\n # endif return DECLINED ;\n }\n rv = mgs_cert_verify ( r , ctxt ) ;\n if ( rv != DECLINED && ( rv != HTTP_FORBIDDEN || dc -> client_verify_mode == GNUTLS_CERT_REQUIRE || ( dc -> client_verify_mode == - 1 && ctxt -> sc -> client_verify_mode == GNUTLS_CERT_REQUIRE ) ) ) {\n return rv ;\n }\n }\n return DECLINED ;\n }\n # define MGS_SIDE ( suffix ) ( ( side == 0 ) ? \"SSL_SERVER\" suffix : \"SSL_CLIENT\" suffix ) static void mgs_add_common_cert_vars ( request_rec * r , gnutls_x509_crt_t cert , int side , size_t export_cert_size ) {\n unsigned char sbuf [ 64 ] ;\n char buf [ AP_IOBUFSIZE ] ;\n const char * tmp ;\n char * tmp2 ;\n size_t len ;\n int ret , i ;\n if ( r == NULL ) return ;\n apr_table_t * env = r -> subprocess_env ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n if ( export_cert_size > 0 ) {\n len = 0 ;\n ret = gnutls_x509_crt_export ( cert , GNUTLS_X509_FMT_PEM , NULL , & len ) ;\n if ( ret == GNUTLS_E_SHORT_MEMORY_BUFFER ) {\n if ( len >= export_cert_size ) {\n apr_table_setn ( env , MGS_SIDE ( \"_CERT\" ) , \"GNUTLS_CERTIFICATE_SIZE_LIMIT_EXCEEDED\" ) ;\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to export too-large X.509 certificate to environment\" ) ;\n }\n else {\n char * cert_buf = apr_palloc ( r -> pool , len + 1 ) ;\n if ( cert_buf != NULL && gnutls_x509_crt_export ( cert , GNUTLS_X509_FMT_PEM , cert_buf , & len ) >= 0 ) {\n cert_buf [ len ] = 0 ;\n apr_table_setn ( env , MGS_SIDE ( \"_CERT\" ) , cert_buf ) ;\n }\n else {\n ap_log_rerror ( APLOG_MARK , APLOG_WARNING , 0 , r , \"GnuTLS: failed to export X.509 certificate\" ) ;\n }\n }\n }\n else {\n ap_log_rerror ( APLOG_MARK , APLOG_WARNING , 0 , r , \"GnuTLS: dazed and confused about X.509 certificate size\" ) ;\n }\n }\n len = sizeof ( buf ) ;\n gnutls_x509_crt_get_dn ( cert , buf , & len ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_S_DN\" ) , apr_pstrmemdup ( r -> pool , buf , len ) ) ;\n len = sizeof ( buf ) ;\n gnutls_x509_crt_get_issuer_dn ( cert , buf , & len ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_I_DN\" ) , apr_pstrmemdup ( r -> pool , buf , len ) ) ;\n len = sizeof ( sbuf ) ;\n gnutls_x509_crt_get_serial ( cert , sbuf , & len ) ;\n tmp = mgs_session_id2sz ( sbuf , len , buf , sizeof ( buf ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_M_SERIAL\" ) , apr_pstrdup ( r -> pool , tmp ) ) ;\n ret = gnutls_x509_crt_get_version ( cert ) ;\n if ( ret > 0 ) apr_table_setn ( env , MGS_SIDE ( \"_M_VERSION\" ) , apr_psprintf ( r -> pool , \"%u\" , ret ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_CERT_TYPE\" ) , \"X.509\" ) ;\n tmp = mgs_time2sz ( gnutls_x509_crt_get_expiration_time ( cert ) , buf , sizeof ( buf ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_V_END\" ) , apr_pstrdup ( r -> pool , tmp ) ) ;\n tmp = mgs_time2sz ( gnutls_x509_crt_get_activation_time ( cert ) , buf , sizeof ( buf ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_V_START\" ) , apr_pstrdup ( r -> pool , tmp ) ) ;\n ret = gnutls_x509_crt_get_signature_algorithm ( cert ) ;\n if ( ret >= 0 ) {\n apr_table_setn ( env , MGS_SIDE ( \"_A_SIG\" ) , gnutls_sign_algorithm_get_name ( ret ) ) ;\n }\n ret = gnutls_x509_crt_get_pk_algorithm ( cert , NULL ) ;\n if ( ret >= 0 ) {\n apr_table_setn ( env , MGS_SIDE ( \"_A_KEY\" ) , gnutls_pk_algorithm_get_name ( ret ) ) ;\n }\n for ( i = 0 ;\n ! ( ret < 0 ) ;\n i ++ ) {\n const char * san , * sanlabel ;\n len = 0 ;\n ret = gnutls_x509_crt_get_subject_alt_name ( cert , i , NULL , & len , NULL ) ;\n if ( ret == GNUTLS_E_SHORT_MEMORY_BUFFER && len > 1 ) {\n tmp2 = apr_palloc ( r -> pool , len + 1 ) ;\n ret = gnutls_x509_crt_get_subject_alt_name ( cert , i , tmp2 , & len , NULL ) ;\n tmp2 [ len ] = 0 ;\n sanlabel = apr_psprintf ( r -> pool , \"%s%u\" , MGS_SIDE ( \"_S_AN\" ) , i ) ;\n if ( ret == GNUTLS_SAN_DNSNAME ) {\n san = apr_psprintf ( r -> pool , \"DNSNAME:%s\" , tmp2 ) ;\n }\n else if ( ret == GNUTLS_SAN_RFC822NAME ) {\n san = apr_psprintf ( r -> pool , \"RFC822NAME:%s\" , tmp2 ) ;\n }\n else if ( ret == GNUTLS_SAN_URI ) {\n san = apr_psprintf ( r -> pool , \"URI:%s\" , tmp2 ) ;\n }\n else {\n san = \"UNSUPPORTED\" ;\n }\n apr_table_setn ( env , sanlabel , san ) ;\n }\n }\n }\n static void mgs_add_common_pgpcert_vars ( request_rec * r , gnutls_openpgp_crt_t cert , int side , size_t export_cert_size ) {\n unsigned char sbuf [ 64 ] ;\n char buf [ AP_IOBUFSIZE ] ;\n const char * tmp ;\n size_t len ;\n int ret ;\n if ( r == NULL ) return ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n apr_table_t * env = r -> subprocess_env ;\n if ( export_cert_size > 0 ) {\n len = 0 ;\n ret = gnutls_openpgp_crt_export ( cert , GNUTLS_OPENPGP_FMT_BASE64 , NULL , & len ) ;\n if ( ret == GNUTLS_E_SHORT_MEMORY_BUFFER ) {\n if ( len >= export_cert_size ) {\n apr_table_setn ( env , MGS_SIDE ( \"_CERT\" ) , \"GNUTLS_CERTIFICATE_SIZE_LIMIT_EXCEEDED\" ) ;\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to export too-large OpenPGP certificate to environment\" ) ;\n }\n else {\n char * cert_buf = apr_palloc ( r -> pool , len + 1 ) ;\n if ( cert_buf != NULL && gnutls_openpgp_crt_export ( cert , GNUTLS_OPENPGP_FMT_BASE64 , cert_buf , & len ) >= 0 ) {\n cert_buf [ len ] = 0 ;\n apr_table_setn ( env , MGS_SIDE ( \"_CERT\" ) , cert_buf ) ;\n }\n else {\n ap_log_rerror ( APLOG_MARK , APLOG_WARNING , 0 , r , \"GnuTLS: failed to export OpenPGP certificate\" ) ;\n }\n }\n }\n else {\n ap_log_rerror ( APLOG_MARK , APLOG_WARNING , 0 , r , \"GnuTLS: dazed and confused about OpenPGP certificate size\" ) ;\n }\n }\n len = sizeof ( buf ) ;\n gnutls_openpgp_crt_get_name ( cert , 0 , buf , & len ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_NAME\" ) , apr_pstrmemdup ( r -> pool , buf , len ) ) ;\n len = sizeof ( sbuf ) ;\n gnutls_openpgp_crt_get_fingerprint ( cert , sbuf , & len ) ;\n tmp = mgs_session_id2sz ( sbuf , len , buf , sizeof ( buf ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_FINGERPRINT\" ) , apr_pstrdup ( r -> pool , tmp ) ) ;\n ret = gnutls_openpgp_crt_get_version ( cert ) ;\n if ( ret > 0 ) apr_table_setn ( env , MGS_SIDE ( \"_M_VERSION\" ) , apr_psprintf ( r -> pool , \"%u\" , ret ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_CERT_TYPE\" ) , \"OPENPGP\" ) ;\n tmp = mgs_time2sz ( gnutls_openpgp_crt_get_expiration_time ( cert ) , buf , sizeof ( buf ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_V_END\" ) , apr_pstrdup ( r -> pool , tmp ) ) ;\n tmp = mgs_time2sz ( gnutls_openpgp_crt_get_creation_time ( cert ) , buf , sizeof ( buf ) ) ;\n apr_table_setn ( env , MGS_SIDE ( \"_V_START\" ) , apr_pstrdup ( r -> pool , tmp ) ) ;\n ret = gnutls_openpgp_crt_get_pk_algorithm ( cert , NULL ) ;\n if ( ret >= 0 ) {\n apr_table_setn ( env , MGS_SIDE ( \"_A_KEY\" ) , gnutls_pk_algorithm_get_name ( ret ) ) ;\n }\n }\n static int mgs_cert_verify ( request_rec * r , mgs_handle_t * ctxt ) {\n const gnutls_datum_t * cert_list ;\n unsigned int cert_list_size , status ;\n int rv = GNUTLS_E_NO_CERTIFICATE_FOUND , ret ;\n unsigned int ch_size = 0 ;\n union {\n gnutls_x509_crt_t x509 [ MAX_CHAIN_SIZE ] ;\n gnutls_openpgp_crt_t pgp ;\n }\n cert ;\n apr_time_t expiration_time , cur_time ;\n if ( r == NULL || ctxt == NULL || ctxt -> session == NULL ) return HTTP_FORBIDDEN ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n cert_list = gnutls_certificate_get_peers ( ctxt -> session , & cert_list_size ) ;\n if ( cert_list == NULL || cert_list_size == 0 ) {\n if ( ctxt -> sc -> client_verify_mode == GNUTLS_CERT_REQUEST ) return OK ;\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to Verify Peer: \" \"Client did not submit a certificate\" ) ;\n return HTTP_FORBIDDEN ;\n }\n if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_X509 ) {\n ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , \"GnuTLS: A Chain of %d certificate(s) was provided for validation\" , cert_list_size ) ;\n for ( ch_size = 0 ;\n ch_size < cert_list_size ;\n ch_size ++ ) {\n gnutls_x509_crt_init ( & cert . x509 [ ch_size ] ) ;\n rv = gnutls_x509_crt_import ( cert . x509 [ ch_size ] , & cert_list [ ch_size ] , GNUTLS_X509_FMT_DER ) ;\n if ( rv != GNUTLS_E_SUCCESS ) {\n if ( ch_size < 1 ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to Verify Peer: \" \"Failed to import peer certificates.\" ) ;\n ret = HTTP_FORBIDDEN ;\n goto exit ;\n }\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to import some peer certificates. Using %d certificates\" , ch_size ) ;\n rv = GNUTLS_E_SUCCESS ;\n break ;\n }\n }\n }\n else if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_OPENPGP ) {\n if ( cert_list_size > 1 ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to Verify Peer: \" \"Chained Client Certificates are not supported.\" ) ;\n return HTTP_FORBIDDEN ;\n }\n gnutls_openpgp_crt_init ( & cert . pgp ) ;\n rv = gnutls_openpgp_crt_import ( cert . pgp , & cert_list [ 0 ] , GNUTLS_OPENPGP_FMT_RAW ) ;\n }\n else return HTTP_FORBIDDEN ;\n if ( rv < 0 ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to Verify Peer: \" \"Failed to import peer certificates.\" ) ;\n ret = HTTP_FORBIDDEN ;\n goto exit ;\n }\n if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_X509 ) {\n apr_time_ansi_put ( & expiration_time , gnutls_x509_crt_get_expiration_time ( cert . x509 [ 0 ] ) ) ;\n ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , \"GnuTLS: Verifying list of %d certificate(s) via method '%s'\" , ch_size , mgs_readable_cvm ( ctxt -> sc -> client_verify_method ) ) ;\n switch ( ctxt -> sc -> client_verify_method ) {\n case mgs_cvm_cartel : rv = gnutls_x509_crt_list_verify ( cert . x509 , ch_size , ctxt -> sc -> ca_list , ctxt -> sc -> ca_list_size , NULL , 0 , 0 , & status ) ;\n break ;\n # ifdef ENABLE_MSVA case mgs_cvm_msva : {\n struct msv_response * resp = NULL ;\n struct msv_query q = {\n . context = \"https\" , . peertype = \"client\" , . pkctype = \"x509pem\" }\n ;\n msv_ctxt_t ctx = msv_ctxt_init ( NULL ) ;\n char cert_pem_buf [ 10 * 1024 ] ;\n size_t len = sizeof ( cert_pem_buf ) ;\n rv = 0 ;\n if ( gnutls_x509_crt_export ( cert . x509 [ 0 ] , GNUTLS_X509_FMT_PEM , cert_pem_buf , & len ) >= 0 ) {\n q . peername = mgs_x509_construct_uid ( r , cert . x509 [ 0 ] ) ;\n q . pkcdata = cert_pem_buf ;\n rv = msv_query_agent ( ctx , q , & resp ) ;\n if ( rv == LIBMSV_ERROR_SUCCESS ) {\n status = 0 ;\n }\n else if ( rv == LIBMSV_ERROR_INVALID ) {\n ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , \"GnuTLS: Monkeysphere validation failed: (message: %s)\" , resp -> message ) ;\n status = GNUTLS_CERT_INVALID ;\n }\n else {\n ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , \"GnuTLS: Error communicating with the Monkeysphere Validation Agent: (%d) %s\" , rv , msv_strerror ( ctx , rv ) ) ;\n status = GNUTLS_CERT_INVALID ;\n rv = - 1 ;\n }\n }\n else {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Could not convert the client certificate to PEM format\" ) ;\n status = GNUTLS_CERT_INVALID ;\n rv = GNUTLS_E_ASN1_ELEMENT_NOT_FOUND ;\n }\n msv_response_destroy ( resp ) ;\n msv_ctxt_destroy ( ctx ) ;\n }\n break ;\n # endif default : ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to Verify X.509 Peer: method '%s' is not supported\" , mgs_readable_cvm ( ctxt -> sc -> client_verify_method ) ) ;\n }\n }\n else {\n apr_time_ansi_put ( & expiration_time , gnutls_openpgp_crt_get_expiration_time ( cert . pgp ) ) ;\n switch ( ctxt -> sc -> client_verify_method ) {\n case mgs_cvm_cartel : rv = gnutls_openpgp_crt_verify_ring ( cert . pgp , ctxt -> sc -> pgp_list , 0 , & status ) ;\n break ;\n # ifdef ENABLE_MSVA case mgs_cvm_msva : ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: OpenPGP verification via MSVA is not yet implemented\" ) ;\n rv = GNUTLS_E_UNIMPLEMENTED_FEATURE ;\n break ;\n # endif default : ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to Verify OpenPGP Peer: method '%s' is not supported\" , mgs_readable_cvm ( ctxt -> sc -> client_verify_method ) ) ;\n }\n }\n if ( rv < 0 ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Failed to Verify Peer certificate: (%d) %s\" , rv , gnutls_strerror ( rv ) ) ;\n if ( rv == GNUTLS_E_NO_CERTIFICATE_FOUND ) ap_log_rerror ( APLOG_MARK , APLOG_EMERG , 0 , r , \"GnuTLS: No certificate was found for verification. Did you set the GnuTLSX509CAFile or GnuTLSPGPKeyringFile directives?\" ) ;\n ret = HTTP_FORBIDDEN ;\n goto exit ;\n }\n cur_time = apr_time_now ( ) ;\n if ( status & GNUTLS_CERT_SIGNER_NOT_FOUND ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Could not find Signer for Peer Certificate\" ) ;\n }\n if ( status & GNUTLS_CERT_SIGNER_NOT_CA ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Peer's Certificate signer is not a CA\" ) ;\n }\n if ( status & GNUTLS_CERT_INSECURE_ALGORITHM ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Peer's Certificate is using insecure algorithms\" ) ;\n }\n if ( status & GNUTLS_CERT_EXPIRED || status & GNUTLS_CERT_NOT_ACTIVATED ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Peer's Certificate signer is expired or not yet activated\" ) ;\n }\n if ( status & GNUTLS_CERT_INVALID ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Peer Certificate is invalid.\" ) ;\n }\n else if ( status & GNUTLS_CERT_REVOKED ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Peer Certificate is revoked.\" ) ;\n }\n if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_X509 ) mgs_add_common_cert_vars ( r , cert . x509 [ 0 ] , 1 , ctxt -> sc -> export_certificates_size ) ;\n else if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_OPENPGP ) mgs_add_common_pgpcert_vars ( r , cert . pgp , 1 , ctxt -> sc -> export_certificates_size ) ;\n {\n unsigned long remain = ( apr_time_sec ( expiration_time ) - apr_time_sec ( cur_time ) ) / 86400 ;\n apr_table_setn ( r -> subprocess_env , \"SSL_CLIENT_V_REMAIN\" , apr_psprintf ( r -> pool , \"%lu\" , remain ) ) ;\n }\n if ( status == 0 ) {\n apr_table_setn ( r -> subprocess_env , \"SSL_CLIENT_VERIFY\" , \"SUCCESS\" ) ;\n ret = OK ;\n }\n else {\n apr_table_setn ( r -> subprocess_env , \"SSL_CLIENT_VERIFY\" , \"FAILED\" ) ;\n if ( ctxt -> sc -> client_verify_mode == GNUTLS_CERT_REQUEST ) ret = OK ;\n else ret = HTTP_FORBIDDEN ;\n }\n exit : if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_X509 ) {\n unsigned int i ;\n for ( i = 0 ;\n i < ch_size ;\n i ++ ) {\n gnutls_x509_crt_deinit ( cert . x509 [ i ] ) ;\n }\n }\n else if ( gnutls_certificate_type_get ( ctxt -> session ) == GNUTLS_CRT_OPENPGP ) gnutls_openpgp_crt_deinit ( cert . pgp ) ;\n return ret ;\n }\n # ifdef ENABLE_MSVA static const char * mgs_x509_leaf_oid_from_dn ( apr_pool_t * pool , const char * oid , gnutls_x509_crt_t cert ) {\n int rv = GNUTLS_E_SUCCESS , i ;\n size_t sz = 0 , lastsz = 0 ;\n char * data = NULL ;\n i = - 1 ;\n while ( rv != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE ) {\n i ++ ;\n lastsz = sz ;\n sz = 0 ;\n rv = gnutls_x509_crt_get_dn_by_oid ( cert , oid , i , 0 , NULL , & sz ) ;\n }\n if ( i > 0 ) {\n data = apr_palloc ( pool , lastsz ) ;\n sz = lastsz ;\n rv = gnutls_x509_crt_get_dn_by_oid ( cert , oid , i - 1 , 0 , data , & sz ) ;\n if ( rv == GNUTLS_E_SUCCESS ) return data ;\n }\n return NULL ;\n }\n static const char * mgs_x509_first_type_from_san ( apr_pool_t * pool , gnutls_x509_subject_alt_name_t target , gnutls_x509_crt_t cert ) {\n int rv = GNUTLS_E_SUCCESS ;\n size_t sz ;\n char * data = NULL ;\n unsigned int i ;\n gnutls_x509_subject_alt_name_t thistype ;\n i = 0 ;\n while ( rv != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE ) {\n sz = 0 ;\n rv = gnutls_x509_crt_get_subject_alt_name2 ( cert , i , NULL , & sz , & thistype , NULL ) ;\n if ( rv == GNUTLS_E_SHORT_MEMORY_BUFFER && thistype == target ) {\n data = apr_palloc ( pool , sz ) ;\n rv = gnutls_x509_crt_get_subject_alt_name2 ( cert , i , data , & sz , & thistype , NULL ) ;\n if ( rv >= 0 && ( thistype == target ) ) return data ;\n }\n i ++ ;\n }\n return NULL ;\n }\n static const char * mgs_x509_construct_uid ( request_rec * r , gnutls_x509_crt_t cert ) {\n apr_pool_t * pool = r -> pool ;\n const char * name = NULL , * comment = NULL , * email = NULL ;\n const char * ret = NULL ;\n apr_pool_t * sp = NULL ;\n if ( APR_SUCCESS != apr_pool_create ( & sp , pool ) ) return NULL ;\n name = mgs_x509_leaf_oid_from_dn ( sp , GNUTLS_OID_X520_COMMON_NAME , cert ) ;\n comment = mgs_x509_leaf_oid_from_dn ( sp , GNUTLS_OID_X520_PSEUDONYM , cert ) ;\n email = mgs_x509_first_type_from_san ( sp , GNUTLS_SAN_RFC822NAME , cert ) ;\n if ( email == NULL ) email = mgs_x509_leaf_oid_from_dn ( sp , GNUTLS_OID_PKCS9_EMAIL , cert ) ;\n if ( name == NULL && email == NULL ) {\n ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , \"GnuTLS: Need either a name or an e-mail address to get a User ID from an X.509 certificate.\" ) ;\n goto end ;\n }\n if ( name ) {\n if ( comment ) {\n if ( email ) {\n ret = apr_psprintf ( pool , \"%s (%s) <%s>\" , name , comment , email ) ;\n }\n else {\n ret = apr_psprintf ( pool , \"%s (%s)\" , name , comment ) ;\n }\n }\n else {\n if ( email ) {\n ret = apr_psprintf ( pool , \"%s <%s>\" , name , email ) ;\n }\n else {\n ret = apr_pstrdup ( pool , name ) ;\n }\n }\n }\n else {\n if ( comment ) {\n ret = apr_psprintf ( pool , \"(%s) <%s>\" , comment , email ) ;\n }\n else {\n ret = apr_psprintf ( pool , \"<%s>\" , email ) ;\n }\n }\n end : apr_pool_destroy ( sp ) ;\n return ret ;\n }\n # endif static int mgs_status_hook ( request_rec * r , int flags __attribute__ ( ( unused ) ) ) {\n mgs_srvconf_rec * sc ;\n if ( r == NULL ) return OK ;\n sc = ( mgs_srvconf_rec * ) ap_get_module_config ( r -> server -> module_config , & gnutls_module ) ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n ap_rputs ( \"<hr>\\n\" , r ) ;\n ap_rputs ( \"<h2>GnuTLS Information:</h2>\\n<dl>\\n\" , r ) ;\n ap_rprintf ( r , \"<dt>GnuTLS version:</dt><dd>%s</dd>\\n\" , gnutls_check_version ( NULL ) ) ;\n ap_rputs ( \"<dt>Built against:</dt><dd>\" GNUTLS_VERSION \"</dd>\\n\" , r ) ;\n ap_rprintf ( r , \"<dt>using TLS:</dt><dd>%s</dd>\\n\" , ( sc -> enabled == GNUTLS_ENABLED_FALSE ? \"no\" : \"yes\" ) ) ;\n if ( sc -> enabled != GNUTLS_ENABLED_FALSE ) {\n mgs_handle_t * ctxt ;\n ctxt = ap_get_module_config ( r -> connection -> conn_config , & gnutls_module ) ;\n if ( ctxt && ctxt -> session != NULL ) {\n # if GNUTLS_VERSION_MAJOR < 3 ap_rprintf ( r , \"<dt>This TLS Session:</dt><dd>%s</dd>\\n\" , gnutls_cipher_suite_get_name ( gnutls_kx_get ( ctxt -> session ) , gnutls_cipher_get ( ctxt -> session ) , gnutls_mac_get ( ctxt -> session ) ) ) ;\n # else char * z = NULL ;\n z = gnutls_session_get_desc ( ctxt -> session ) ;\n if ( z ) {\n ap_rprintf ( r , \"<dt>This TLS Session:</dt><dd>%s</dd>\\n\" , z ) ;\n gnutls_free ( z ) ;\n }\n # endif }\n }\n ap_rputs ( \"</dl>\\n\" , r ) ;\n return OK ;\n }", "hash": 9173748358801811781, "project": "debian", "size": 573, "target": 0, "idx": 10244}
{"code": "static krb5_error_code process_db_args ( krb5_context context , char * * db_args , xargs_t * xargs , OPERATION optype ) {\n int i = 0 ;\n krb5_error_code st = 0 ;\n char * arg = NULL , * arg_val = NULL ;\n char * * dptr = NULL ;\n unsigned int arg_val_len = 0 ;\n if ( db_args ) {\n for ( i = 0 ;\n db_args [ i ] ;\n ++ i ) {\n arg = strtok_r ( db_args [ i ] , \"=\" , & arg_val ) ;\n if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) {\n dptr = & xargs -> tktpolicydn ;\n }\n else {\n if ( strcmp ( arg , USERDN_ARG ) == 0 ) {\n if ( optype == MODIFY_PRINCIPAL || xargs -> dn != NULL || xargs -> containerdn != NULL || xargs -> linkdn != NULL ) {\n st = EINVAL ;\n k5_setmsg ( context , st , _ ( \"%s option not supported\" ) , arg ) ;\n goto cleanup ;\n }\n dptr = & xargs -> dn ;\n }\n else if ( strcmp ( arg , CONTAINERDN_ARG ) == 0 ) {\n if ( optype == MODIFY_PRINCIPAL || xargs -> dn != NULL || xargs -> containerdn != NULL ) {\n st = EINVAL ;\n k5_setmsg ( context , st , _ ( \"%s option not supported\" ) , arg ) ;\n goto cleanup ;\n }\n dptr = & xargs -> containerdn ;\n }\n else if ( strcmp ( arg , LINKDN_ARG ) == 0 ) {\n if ( xargs -> dn != NULL || xargs -> linkdn != NULL ) {\n st = EINVAL ;\n k5_setmsg ( context , st , _ ( \"%s option not supported\" ) , arg ) ;\n goto cleanup ;\n }\n dptr = & xargs -> linkdn ;\n }\n else {\n st = EINVAL ;\n k5_setmsg ( context , st , _ ( \"unknown option: %s\" ) , arg ) ;\n goto cleanup ;\n }\n xargs -> dn_from_kbd = TRUE ;\n if ( arg_val == NULL || strlen ( arg_val ) == 0 ) {\n st = EINVAL ;\n k5_setmsg ( context , st , _ ( \"%s option value missing\" ) , arg ) ;\n goto cleanup ;\n }\n }\n if ( arg_val == NULL ) {\n st = EINVAL ;\n k5_setmsg ( context , st , _ ( \"%s option value missing\" ) , arg ) ;\n goto cleanup ;\n }\n arg_val_len = strlen ( arg_val ) + 1 ;\n if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) {\n if ( ( st = krb5_ldap_name_to_policydn ( context , arg_val , dptr ) ) != 0 ) goto cleanup ;\n }\n else {\n * dptr = k5memdup ( arg_val , arg_val_len , & st ) ;\n if ( * dptr == NULL ) goto cleanup ;\n }\n }\n }\n cleanup : return st ;\n }", "hash": -4432585791636767127, "project": "debian", "size": 68, "target": 0, "idx": 10246}
{"code": "static void cmd_channel_add ( const char * data ) {\n cmd_channel_add_modify ( data , TRUE ) ;\n }", "hash": 1773163316021227217, "project": "debian", "size": 3, "target": 0, "idx": 10286}
{"code": "static void sig_server_looking ( SERVER_REC * server ) {\n g_return_if_fail ( server != NULL ) ;\n printformat ( server , NULL , MSGLEVEL_CLIENTNOTICE , TXT_LOOKING_UP , server -> connrec -> address ) ;\n }", "hash": -7777331401175181229, "project": "debian", "size": 4, "target": 0, "idx": 10307}
{"code": "static void sig_server_connected ( SERVER_REC * server ) {\n g_return_if_fail ( server != NULL ) ;\n printformat ( server , NULL , MSGLEVEL_CLIENTNOTICE , TXT_CONNECTION_ESTABLISHED , server -> connrec -> address ) ;\n }", "hash": -7777331401175181229, "project": "debian", "size": 4, "target": 0, "idx": 10308}
{"code": "void fe_server_init ( void ) {\n command_bind ( \"server\" , NULL , ( SIGNAL_FUNC ) cmd_server ) ;\n command_bind ( \"server connect\" , NULL , ( SIGNAL_FUNC ) cmd_server_connect ) ;\n command_bind ( \"server add\" , NULL , ( SIGNAL_FUNC ) cmd_server_add ) ;\n command_bind ( \"server modify\" , NULL , ( SIGNAL_FUNC ) cmd_server_modify ) ;\n command_bind ( \"server remove\" , NULL , ( SIGNAL_FUNC ) cmd_server_remove ) ;\n command_bind_first ( \"server\" , NULL , ( SIGNAL_FUNC ) server_command ) ;\n command_bind_first ( \"disconnect\" , NULL , ( SIGNAL_FUNC ) server_command ) ;\n command_set_options ( \"server add\" , \"4 6 !! ssl nossl +ssl_cert +ssl_pkey +ssl_pass ssl_verify nossl_verify +ssl_cafile +ssl_capath +ssl_ciphers +ssl_fingerprint tls notls +tls_cert +tls_pkey +tls_pass tls_verify notls_verify +tls_cafile +tls_capath +tls_ciphers +tls_pinned_cert +tls_pinned_pubkey auto noauto proxy noproxy -host -port noautosendcmd\" ) ;\n command_set_options ( \"server modify\" , \"4 6 !! ssl nossl +ssl_cert +ssl_pkey +ssl_pass ssl_verify nossl_verify +ssl_cafile +ssl_capath +ssl_ciphers +ssl_fingerprint tls notls +tls_cert +tls_pkey +tls_pass tls_verify notls_verify +tls_cafile +tls_capath +tls_ciphers +tls_pinned_cert +tls_pinned_pubkey auto noauto proxy noproxy -host -port noautosendcmd\" ) ;\n signal_add ( \"server looking\" , ( SIGNAL_FUNC ) sig_server_looking ) ;\n signal_add ( \"server connecting\" , ( SIGNAL_FUNC ) sig_server_connecting ) ;\n signal_add ( \"server connected\" , ( SIGNAL_FUNC ) sig_server_connected ) ;\n signal_add ( \"server connect failed\" , ( SIGNAL_FUNC ) sig_connect_failed ) ;\n signal_add ( \"server disconnected\" , ( SIGNAL_FUNC ) sig_server_disconnected ) ;\n signal_add ( \"server quit\" , ( SIGNAL_FUNC ) sig_server_quit ) ;\n signal_add ( \"server lag disconnect\" , ( SIGNAL_FUNC ) sig_server_lag_disconnected ) ;\n signal_add ( \"server reconnect remove\" , ( SIGNAL_FUNC ) sig_server_reconnect_removed ) ;\n signal_add ( \"server reconnect not found\" , ( SIGNAL_FUNC ) sig_server_reconnect_not_found ) ;\n signal_add ( \"chat protocol unknown\" , ( SIGNAL_FUNC ) sig_chat_protocol_unknown ) ;\n }", "hash": -7777331401175181229, "project": "debian", "size": 21, "target": 0, "idx": 10313}
{"code": "static void sig_server_reconnect_removed ( RECONNECT_REC * reconnect ) {\n g_return_if_fail ( reconnect != NULL ) ;\n printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , TXT_RECONNECT_REMOVED , reconnect -> conn -> address , reconnect -> conn -> port , reconnect -> conn -> chatnet == NULL ? \"\" : reconnect -> conn -> chatnet ) ;\n }", "hash": -7777331401175181229, "project": "debian", "size": 4, "target": 0, "idx": 10314}
{"code": "static void cmd_server_remove ( const char * data ) {\n SERVER_SETUP_REC * rec ;\n char * addr , * port , * chatnet ;\n void * free_arg ;\n if ( ! cmd_get_params ( data , & free_arg , 3 , & addr , & port , & chatnet ) ) return ;\n if ( * addr == '\\0' ) cmd_param_error ( CMDERR_NOT_ENOUGH_PARAMS ) ;\n if ( * port == '\\0' ) {\n if ( * chatnet == '\\0' ) rec = server_setup_find ( addr , - 1 , NULL ) ;\n else rec = server_setup_find ( addr , - 1 , chatnet ) ;\n }\n else {\n if ( * chatnet == '\\0' ) rec = server_setup_find ( addr , atoi ( port ) , NULL ) ;\n else rec = server_setup_find ( addr , atoi ( port ) , chatnet ) ;\n }\n if ( rec == NULL ) printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , TXT_SETUPSERVER_NOT_FOUND , addr , port ) ;\n else {\n server_setup_remove ( rec ) ;\n printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , TXT_SETUPSERVER_REMOVED , addr , port ) ;\n }\n cmd_params_free ( free_arg ) ;\n }", "hash": -7777331401175181229, "project": "debian", "size": 21, "target": 0, "idx": 10317}
{"code": "static void print_servers ( void ) {\n GSList * tmp ;\n for ( tmp = servers ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n SERVER_REC * rec = tmp -> data ;\n printformat ( NULL , NULL , MSGLEVEL_CRAP , TXT_SERVER_LIST , rec -> tag , rec -> connrec -> address , rec -> connrec -> port , rec -> connrec -> chatnet == NULL ? \"\" : rec -> connrec -> chatnet , rec -> connrec -> nick ) ;\n }\n }", "hash": -7777331401175181229, "project": "debian", "size": 9, "target": 0, "idx": 10323}
{"code": "static void sig_chat_protocol_unknown ( const char * protocol ) {\n g_return_if_fail ( protocol != NULL ) ;\n printformat ( NULL , NULL , MSGLEVEL_CLIENTERROR , TXT_UNKNOWN_CHAT_PROTOCOL , protocol ) ;\n }", "hash": -7777331401175181229, "project": "debian", "size": 4, "target": 0, "idx": 10324}
{"code": "static void server_command ( const char * data , SERVER_REC * server , WI_ITEM_REC * item ) {\n if ( server == NULL ) {\n server = active_win -> connect_server ;\n }\n signal_continue ( 3 , data , server , item ) ;\n }", "hash": -7777331401175181229, "project": "debian", "size": 6, "target": 0, "idx": 10327}
{"code": "static guint32 parse_wbxml_tag_defined ( proto_tree * tree , tvbuff_t * tvb , guint32 offset , guint32 str_tbl , guint8 * level , guint8 * codepage_stag , guint8 * codepage_attr , const wbxml_decoding * map ) {\n guint32 tvb_len = tvb_reported_length ( tvb ) ;\n guint32 off = offset , last_off ;\n guint32 len ;\n guint str_len ;\n guint32 ent ;\n guint32 idx ;\n guint8 peek ;\n guint32 tag_len ;\n guint8 tag_save_known = 0 ;\n guint8 tag_new_known = 0 ;\n const char * tag_save_literal ;\n const char * tag_new_literal ;\n guint8 parsing_tag_content = FALSE ;\n tag_save_literal = NULL ;\n DebugLog ( ( \"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\" , * level , offset ) ) ;\n last_off = off ;\n while ( off < tvb_len ) {\n peek = tvb_get_guint8 ( tvb , off ) ;\n DebugLog ( ( \"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\" , * level , peek , off , tvb_len ) ) ;\n if ( ( peek & 0x3F ) < 4 ) switch ( peek ) {\n case 0x00 : * codepage_stag = tvb_get_guint8 ( tvb , off + 1 ) ;\n proto_tree_add_text ( tree , tvb , off , 2 , \" | Tag | T -->%3d \" \"| SWITCH_PAGE (Tag code page) \" \"|\" , * codepage_stag ) ;\n off += 2 ;\n break ;\n case 0x01 : if ( tag_save_known ) {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| END (Known Tag 0x%02X) \" \"| %s</%s>\" , * level , * codepage_stag , tag_save_known , Indent ( * level ) , tag_save_literal ) ;\n }\n else {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| END (Literal Tag) \" \"| %s</%s>\" , * level , * codepage_stag , Indent ( * level ) , tag_save_literal ? tag_save_literal : \"\" ) ;\n }\n ( * level ) -- ;\n off ++ ;\n DebugLog ( ( \"STAG: level = %u, Return: len = %u\\n\" , * level , off - offset ) ) ;\n return ( off - offset ) ;\n case 0x02 : ent = tvb_get_guintvar ( tvb , off + 1 , & len ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Tag | T %3d \" \"| ENTITY \" \"| %s'&#%u;\n'\" , * level , * codepage_stag , Indent ( * level ) , ent ) ;\n off += 1 + len ;\n break ;\n case 0x03 : len = tvb_strsize ( tvb , off + 1 ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Tag | T %3d \" \"| STR_I (Inline string) \" \"| %s\\'%s\\'\" , * level , * codepage_stag , Indent ( * level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ;\n off += 1 + len ;\n break ;\n case 0x40 : case 0x41 : case 0x42 : len = tvb_strsize ( tvb , off + 1 ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Tag | T %3d \" \"| EXT_I_%1x (Extension Token) \" \"| %s(%s: \\'%s\\')\" , * level , * codepage_stag , peek & 0x0f , Indent ( * level ) , map_token ( map -> global , 0 , peek ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ;\n off += 1 + len ;\n break ;\n case 0x43 : proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| PI (XML Processing Instruction) \" \"| %s<?xml\" , * level , * codepage_stag , Indent ( * level ) ) ;\n len = parse_wbxml_attribute_list_defined ( tree , tvb , off , str_tbl , * level , codepage_attr , map ) ;\n off += len ;\n if ( off >= tvb_len ) {\n DebugLog ( ( \"STAG: level = %u, ThrowException: len = %u (short frame)\\n\" , * level , off - offset ) ) ;\n THROW ( ReportedBoundsError ) ;\n }\n proto_tree_add_text ( tree , tvb , off - 1 , 1 , \" %3d | Tag | T %3d \" \"| END (PI) \" \"| %s?>\" , * level , * codepage_stag , Indent ( * level ) ) ;\n break ;\n case 0x80 : case 0x81 : case 0x82 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ;\n {\n char * s ;\n if ( map -> ext_t [ peek & 0x03 ] ) s = ( map -> ext_t [ peek & 0x03 ] ) ( tvb , idx , str_tbl ) ;\n else s = wmem_strdup_printf ( wmem_packet_scope ( ) , \"EXT_T_%1x (%s)\" , peek & 0x03 , map_token ( map -> global , 0 , peek ) ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Tag | T %3d \" \"| EXT_T_%1x (Extension Token) \" \"| %s%s\" , * level , * codepage_stag , peek & 0x0f , Indent ( * level ) , s ) ;\n }\n off += 1 + len ;\n break ;\n case 0x83 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ;\n str_len = tvb_strsize ( tvb , str_tbl + idx ) ;\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Tag | T %3d \" \"| STR_T (Tableref string) \" \"| %s\\'%s\\'\" , * level , * codepage_stag , Indent ( * level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ;\n off += 1 + len ;\n break ;\n case 0xC0 : case 0xC1 : case 0xC2 : proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| EXT_%1x (Extension Token) \" \"| %s(%s)\" , * level , * codepage_stag , peek & 0x0f , Indent ( * level ) , map_token ( map -> global , 0 , peek ) ) ;\n off ++ ;\n break ;\n case 0xC3 : if ( tvb_get_guint8 ( tvb , 0 ) ) {\n char * str ;\n if ( tag_save_known ) {\n if ( map -> opaque_binary_tag ) {\n str = map -> opaque_binary_tag ( tvb , off + 1 , tag_save_known , * codepage_stag , & len ) ;\n }\n else {\n str = default_opaque_binary_tag ( tvb , off + 1 , tag_save_known , * codepage_stag , & len ) ;\n }\n }\n else {\n if ( map -> opaque_literal_tag ) {\n str = map -> opaque_literal_tag ( tvb , off + 1 , tag_save_literal , * codepage_stag , & len ) ;\n }\n else {\n str = default_opaque_literal_tag ( tvb , off + 1 , tag_save_literal , * codepage_stag , & len ) ;\n }\n }\n proto_tree_add_text ( tree , tvb , off , 1 + len , \" %3d | Tag | T %3d \" \"| OPAQUE (Opaque data) \" \"| %s%s\" , * level , * codepage_stag , Indent ( * level ) , str ) ;\n off += 1 + len ;\n }\n else {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| RESERVED_2 (Invalid Token!) \" \"| WBXML 1.0 parsing stops here.\" , * level , * codepage_stag ) ;\n off = tvb_len ;\n DebugLog ( ( \"STAG: level = %u, Return: len = %u\\n\" , * level , off - offset ) ) ;\n return ( off - offset ) ;\n }\n break ;\n }\n else {\n tag_len = 0 ;\n if ( ( peek & 0x3F ) == 4 ) {\n DebugLog ( ( \"STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\" , peek , off ) ) ;\n idx = tvb_get_guintvar ( tvb , off + 1 , & tag_len ) ;\n str_len = tvb_strsize ( tvb , str_tbl + idx ) ;\n tag_new_literal = ( const gchar * ) tvb_get_ptr ( tvb , str_tbl + idx , str_len ) ;\n tag_new_known = 0 ;\n }\n else {\n tag_new_known = peek & 0x3F ;\n tag_new_literal = map_token ( map -> tags , * codepage_stag , tag_new_known ) ;\n }\n if ( peek & 0x40 ) {\n if ( parsing_tag_content ) {\n DebugLog ( ( \"STAG: Tag in Tag - RECURSE! (off = %u)\\n\" , off ) ) ;\n ( * level ) ++ ;\n len = parse_wbxml_tag_defined ( tree , tvb , off , str_tbl , level , codepage_stag , codepage_attr , map ) ;\n off += len ;\n }\n else {\n if ( ( peek & 0x3F ) == 4 ) {\n tag_save_literal = tag_new_literal ;\n tag_save_known = 0 ;\n }\n else {\n tag_save_known = tag_new_known ;\n tag_save_literal = tag_new_literal ;\n }\n if ( peek & 0x80 ) {\n if ( tag_new_known ) {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| Known Tag 0x%02X (AC) \" \"| %s<%s\" , * level , * codepage_stag , tag_new_known , Indent ( * level ) , tag_new_literal ) ;\n off ++ ;\n }\n else {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| LITERAL_AC (Literal tag) (AC) \" \"| %s<%s\" , * level , * codepage_stag , Indent ( * level ) , tag_new_literal ) ;\n off += 1 + tag_len ;\n }\n len = parse_wbxml_attribute_list_defined ( tree , tvb , off , str_tbl , * level , codepage_attr , map ) ;\n off += len ;\n if ( off >= tvb_len ) {\n DebugLog ( ( \"STAG: level = %u, ThrowException: len = %u (short frame)\\n\" , * level , off - offset ) ) ;\n THROW ( ReportedBoundsError ) ;\n }\n proto_tree_add_text ( tree , tvb , off - 1 , 1 , \" %3d | Tag | T %3d \" \"| END (attribute list) \" \"| %s>\" , * level , * codepage_stag , Indent ( * level ) ) ;\n }\n else {\n if ( tag_new_known ) {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| Known Tag 0x%02X (.C) \" \"| %s<%s>\" , * level , * codepage_stag , tag_new_known , Indent ( * level ) , tag_new_literal ) ;\n off ++ ;\n }\n else {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| LITERAL_C (Literal Tag) (.C) \" \"| %s<%s>\" , * level , * codepage_stag , Indent ( * level ) , tag_new_literal ) ;\n off += 1 + tag_len ;\n }\n }\n parsing_tag_content = TRUE ;\n DebugLog ( ( \"Tag in Tag - No recursion this time! (off = %u)\\n\" , off ) ) ;\n }\n }\n else {\n DebugLog ( ( \"<Tag/> in Tag - No recursion! (off = %u)\\n\" , off ) ) ;\n ( * level ) ++ ;\n if ( peek & 0x80 ) {\n if ( tag_new_known ) {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| Known Tag 0x%02X (A.) \" \"| %s<%s\" , * level , * codepage_stag , tag_new_known , Indent ( * level ) , tag_new_literal ) ;\n off ++ ;\n len = parse_wbxml_attribute_list_defined ( tree , tvb , off , str_tbl , * level , codepage_attr , map ) ;\n off += len ;\n if ( off > tvb_len ) {\n DebugLog ( ( \"STAG: level = %u, ThrowException: len = %u (short frame)\\n\" , * level , off - offset ) ) ;\n THROW ( ReportedBoundsError ) ;\n }\n proto_tree_add_text ( tree , tvb , off - 1 , 1 , \" %3d | Tag | T %3d \" \"| END (Known Tag) \" \"| %s/>\" , * level , * codepage_stag , Indent ( * level ) ) ;\n }\n else {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| LITERAL_A (Literal Tag) (A.) \" \"| %s<%s\" , * level , * codepage_stag , Indent ( * level ) , tag_new_literal ) ;\n off += 1 + tag_len ;\n len = parse_wbxml_attribute_list_defined ( tree , tvb , off , str_tbl , * level , codepage_attr , map ) ;\n off += len ;\n if ( off >= tvb_len ) {\n DebugLog ( ( \"STAG: level = %u, ThrowException: len = %u (short frame)\\n\" , * level , off - offset ) ) ;\n THROW ( ReportedBoundsError ) ;\n }\n proto_tree_add_text ( tree , tvb , off - 1 , 1 , \" %3d | Tag | T %3d \" \"| END (Literal Tag) \" \"| %s/>\" , * level , * codepage_stag , Indent ( * level ) ) ;\n }\n }\n else {\n if ( tag_new_known ) {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| Known Tag 0x%02x (..) \" \"| %s<%s />\" , * level , * codepage_stag , tag_new_known , Indent ( * level ) , tag_new_literal ) ;\n off ++ ;\n }\n else {\n proto_tree_add_text ( tree , tvb , off , 1 , \" %3d | Tag | T %3d \" \"| LITERAL (Literal Tag) (..) \" \"| %s<%s />\" , * level , * codepage_stag , Indent ( * level ) , tag_new_literal ) ;\n off += 1 + tag_len ;\n }\n }\n ( * level ) -- ;\n }\n }\n if ( off < last_off ) {\n THROW ( ReportedBoundsError ) ;\n }\n last_off = off ;\n }\n DebugLog ( ( \"STAG: level = %u, Return: len = %u (end of function body)\\n\" , * level , off - offset ) ) ;\n return ( off - offset ) ;\n }", "hash": -6580451576689962916, "project": "debian", "size": 211, "target": 0, "idx": 10334}
{"code": "static char * sic10_opaque_binary_attr ( tvbuff_t * tvb , guint32 offset , guint8 token , guint8 codepage , guint32 * length ) {\n guint32 data_len = tvb_get_guintvar ( tvb , offset , length ) ;\n char * str = NULL ;\n switch ( codepage ) {\n case 0 : switch ( token ) {\n case 0x0A : case 0x10 : str = date_time_from_opaque ( tvb , offset + * length , data_len ) ;\n break ;\n default : break ;\n }\n break ;\n default : break ;\n }\n if ( str == NULL ) {\n str = wmem_strdup_printf ( wmem_packet_scope ( ) , \"(%d bytes of unparsed opaque data)\" , data_len ) ;\n }\n * length += data_len ;\n return str ;\n }", "hash": -6580451576689962916, "project": "debian", "size": 18, "target": 0, "idx": 10336}
{"code": "static FileType get_file_type ( const u_char * filename , unsigned int throttle_rate ) {\n struct stat buf ;\n int ret ;\n ret = pp_cached_file_stat_perform ( pp_stat_cache , ( const char * ) filename , & buf , throttle_rate ) ;\n if ( ret == 0 ) {\n if ( S_ISREG ( buf . st_mode ) ) {\n return FT_FILE ;\n }\n else if ( S_ISDIR ( buf . st_mode ) ) {\n return FT_DIRECTORY ;\n }\n else {\n return FT_OTHER ;\n }\n }\n else {\n return FT_ERROR ;\n }\n }", "hash": 3766491362463647945, "project": "debian", "size": 19, "target": 0, "idx": 10378}
{"code": "static ngx_int_t process_header ( ngx_http_request_t * r ) {\n ngx_str_t * status_line ;\n ngx_int_t rc , status ;\n ngx_table_elt_t * h ;\n ngx_http_upstream_t * u ;\n ngx_http_upstream_header_t * hh ;\n ngx_http_upstream_main_conf_t * umcf ;\n ngx_http_core_loc_conf_t * clcf ;\n passenger_loc_conf_t * slcf ;\n umcf = ngx_http_get_module_main_conf ( r , ngx_http_upstream_module ) ;\n clcf = ngx_http_get_module_loc_conf ( r , ngx_http_core_module ) ;\n slcf = ngx_http_get_module_loc_conf ( r , ngx_http_passenger_module ) ;\n for ( ;\n ;\n ) {\n rc = ngx_http_parse_header_line ( r , & r -> upstream -> buffer , 1 ) ;\n if ( rc == NGX_OK ) {\n h = ngx_list_push ( & r -> upstream -> headers_in . headers ) ;\n if ( h == NULL ) {\n return NGX_ERROR ;\n }\n h -> hash = r -> header_hash ;\n h -> key . len = r -> header_name_end - r -> header_name_start ;\n h -> value . len = r -> header_end - r -> header_start ;\n h -> key . data = ngx_pnalloc ( r -> pool , h -> key . len + 1 + h -> value . len + 1 + h -> key . len ) ;\n if ( h -> key . data == NULL ) {\n return NGX_ERROR ;\n }\n h -> value . data = h -> key . data + h -> key . len + 1 ;\n h -> lowcase_key = h -> key . data + h -> key . len + 1 + h -> value . len + 1 ;\n ngx_memcpy ( h -> key . data , r -> header_name_start , h -> key . len ) ;\n h -> key . data [ h -> key . len ] = '\\0' ;\n ngx_memcpy ( h -> value . data , r -> header_start , h -> value . len ) ;\n h -> value . data [ h -> value . len ] = '\\0' ;\n if ( h -> key . len == r -> lowcase_index ) {\n ngx_memcpy ( h -> lowcase_key , r -> lowcase_header , h -> key . len ) ;\n }\n else {\n ngx_strlow ( h -> lowcase_key , h -> key . data , h -> key . len ) ;\n }\n hh = ngx_hash_find ( & umcf -> headers_in_hash , h -> hash , h -> lowcase_key , h -> key . len ) ;\n if ( hh && hh -> handler ( r , h , hh -> offset ) != NGX_OK ) {\n return NGX_ERROR ;\n }\n ngx_log_debug2 ( NGX_LOG_DEBUG_HTTP , r -> connection -> log , 0 , \"http scgi header: \\\"%V: %V\\\"\" , & h -> key , & h -> value ) ;\n continue ;\n }\n if ( rc == NGX_HTTP_PARSE_HEADER_DONE ) {\n ngx_log_debug0 ( NGX_LOG_DEBUG_HTTP , r -> connection -> log , 0 , \"http scgi header done\" ) ;\n if ( r -> upstream -> headers_in . server == NULL ) {\n h = ngx_list_push ( & r -> upstream -> headers_in . headers ) ;\n if ( h == NULL ) {\n return NGX_HTTP_INTERNAL_SERVER_ERROR ;\n }\n h -> hash = ngx_hash ( ngx_hash ( ngx_hash ( ngx_hash ( ngx_hash ( 's' , 'e' ) , 'r' ) , 'v' ) , 'e' ) , 'r' ) ;\n h -> key . len = sizeof ( \"Server\" ) - 1 ;\n h -> key . data = ( u_char * ) \"Server\" ;\n if ( slcf -> show_version_in_header == 0 ) {\n if ( clcf -> server_tokens ) {\n h -> value . data = ( u_char * ) ( NGINX_VER \" + Phusion Passenger\" ) ;\n }\n else {\n h -> value . data = ( u_char * ) ( \"nginx + Phusion Passenger\" ) ;\n }\n }\n else {\n if ( clcf -> server_tokens ) {\n h -> value . data = ( u_char * ) ( NGINX_VER \" + Phusion Passenger \" PASSENGER_VERSION ) ;\n }\n else {\n h -> value . data = ( u_char * ) ( \"nginx + Phusion Passenger \" PASSENGER_VERSION ) ;\n }\n }\n h -> value . len = ngx_strlen ( h -> value . data ) ;\n h -> lowcase_key = ( u_char * ) \"server\" ;\n }\n if ( r -> upstream -> headers_in . date == NULL ) {\n h = ngx_list_push ( & r -> upstream -> headers_in . headers ) ;\n if ( h == NULL ) {\n return NGX_HTTP_INTERNAL_SERVER_ERROR ;\n }\n h -> hash = ngx_hash ( ngx_hash ( ngx_hash ( 'd' , 'a' ) , 't' ) , 'e' ) ;\n h -> key . len = sizeof ( \"Date\" ) - 1 ;\n h -> key . data = ( u_char * ) \"Date\" ;\n h -> value . len = 0 ;\n h -> value . data = NULL ;\n h -> lowcase_key = ( u_char * ) \"date\" ;\n }\n u = r -> upstream ;\n if ( u -> headers_in . status_n ) {\n goto done ;\n }\n if ( u -> headers_in . status ) {\n status_line = & u -> headers_in . status -> value ;\n status = ngx_atoi ( status_line -> data , 3 ) ;\n if ( status == NGX_ERROR ) {\n ngx_log_error ( NGX_LOG_ERR , r -> connection -> log , 0 , \"upstream sent invalid status \\\"%V\\\"\" , status_line ) ;\n return NGX_HTTP_UPSTREAM_INVALID_HEADER ;\n }\n u -> headers_in . status_n = status ;\n u -> headers_in . status_line = * status_line ;\n }\n else if ( u -> headers_in . location ) {\n u -> headers_in . status_n = 302 ;\n ngx_str_set ( & u -> headers_in . status_line , \"302 Moved Temporarily\" ) ;\n }\n else {\n u -> headers_in . status_n = 200 ;\n ngx_str_set ( & u -> headers_in . status_line , \"200 OK\" ) ;\n }\n if ( u -> state ) {\n u -> state -> status = u -> headers_in . status_n ;\n }\n done : # ifdef NGX_HTTP_SWITCHING_PROTOCOLS if ( u -> headers_in . status_n == NGX_HTTP_SWITCHING_PROTOCOLS && r -> headers_in . upgrade ) {\n u -> upgrade = 1 ;\n }\n # endif return NGX_OK ;\n }\n if ( rc == NGX_AGAIN ) {\n return NGX_AGAIN ;\n }\n ngx_log_error ( NGX_LOG_ERR , r -> connection -> log , 0 , \"upstream sent invalid header\" ) ;\n return NGX_HTTP_UPSTREAM_INVALID_HEADER ;\n }\n }", "hash": 3766491362463647945, "project": "debian", "size": 125, "target": 0, "idx": 10381}
{"code": "static ngx_int_t reinit_request ( ngx_http_request_t * r ) {\n passenger_context_t * context ;\n context = ngx_http_get_module_ctx ( r , ngx_http_passenger_module ) ;\n if ( context == NULL ) {\n return NGX_OK ;\n }\n context -> status = 0 ;\n context -> status_count = 0 ;\n context -> status_start = NULL ;\n context -> status_end = NULL ;\n r -> upstream -> process_header = process_status_line ;\n r -> state = 0 ;\n return NGX_OK ;\n }", "hash": 3766491362463647945, "project": "debian", "size": 14, "target": 0, "idx": 10387}
{"code": "static void rfc2231_escape ( string_t * dest , const char * src ) {\n for ( ;\n * src != '\\0' ;\n src ++ ) {\n if ( * src == '%' ) str_append ( dest , \"%25\" ) ;\n else str_append_c ( dest , * src ) ;\n }\n }", "hash": 6562213886666176620, "project": "debian", "size": 8, "target": 0, "idx": 10389}
{"code": "int tm_subscribe ( tm_task_id tid , char * name , void * info , int len , int * info_len , tm_event_t * event ) {\n int rc = TM_SUCCESS ;\n task_info * tp ;\n struct tcp_chan * chan = NULL ;\n struct infohold * ihold ;\n if ( ! init_done ) {\n rc = TM_BADINIT ;\n goto tm_subscribe_cleanup ;\n }\n if ( ( tp = find_task ( tid ) ) == NULL ) {\n rc = TM_ENOTFOUND ;\n goto tm_subscribe_cleanup ;\n }\n * event = new_event ( ) ;\n if ( startcom ( TM_GETINFO , * event , & chan ) != DIS_SUCCESS ) {\n rc = TM_ESYSTEM ;\n goto tm_subscribe_cleanup ;\n }\n if ( diswsi ( chan , tp -> t_node ) != DIS_SUCCESS ) {\n rc = TM_ESYSTEM ;\n goto tm_subscribe_cleanup ;\n }\n if ( diswsi ( chan , tid ) != DIS_SUCCESS ) {\n rc = TM_ESYSTEM ;\n goto tm_subscribe_cleanup ;\n }\n if ( diswst ( chan , name ) != DIS_SUCCESS ) {\n rc = TM_ESYSTEM ;\n goto tm_subscribe_cleanup ;\n }\n DIS_tcp_wflush ( chan ) ;\n ihold = ( struct infohold * ) calloc ( 1 , sizeof ( struct infohold ) ) ;\n assert ( ihold != NULL ) ;\n ihold -> info = info ;\n ihold -> len = len ;\n ihold -> info_len = info_len ;\n add_event ( * event , tp -> t_node , TM_GETINFO , ( void * ) ihold ) ;\n tm_subscribe_cleanup : if ( chan != NULL ) DIS_tcp_cleanup ( chan ) ;\n return rc ;\n }", "hash": -2325305888478261876, "project": "debian", "size": 40, "target": 0, "idx": 10403}
{"code": "int tm_init ( void * info , struct tm_roots * roots ) {\n tm_event_t nevent , revent ;\n char * env , * hold ;\n int err ;\n int nerr = 0 ;\n struct tcp_chan * chan = NULL ;\n if ( init_done ) {\n return ( TM_BADINIT ) ;\n }\n if ( ( tm_jobid = getenv ( \"PBS_JOBID\" ) ) == NULL ) {\n return ( TM_EBADENVIRONMENT ) ;\n }\n tm_jobid_len = strlen ( tm_jobid ) ;\n if ( ( tm_jobcookie = getenv ( \"PBS_JOBCOOKIE\" ) ) == NULL ) return TM_EBADENVIRONMENT ;\n tm_jobcookie_len = strlen ( tm_jobcookie ) ;\n if ( ( env = getenv ( \"PBS_NODENUM\" ) ) == NULL ) return TM_EBADENVIRONMENT ;\n tm_jobndid = ( tm_node_id ) strtol ( env , & hold , 10 ) ;\n if ( env == hold ) return TM_EBADENVIRONMENT ;\n if ( ( env = getenv ( \"PBS_TASKNUM\" ) ) == NULL ) return TM_EBADENVIRONMENT ;\n if ( ( tm_jobtid = atoi ( env ) ) == 0 ) return TM_EBADENVIRONMENT ;\n if ( ( env = getenv ( \"PBS_MOMPORT\" ) ) == NULL ) return TM_EBADENVIRONMENT ;\n if ( ( tm_momport = atoi ( env ) ) == 0 ) return TM_EBADENVIRONMENT ;\n init_done = 1 ;\n nevent = new_event ( ) ;\n if ( startcom ( TM_INIT , nevent , & chan ) != DIS_SUCCESS ) return TM_ESYSTEM ;\n DIS_tcp_wflush ( chan ) ;\n DIS_tcp_cleanup ( chan ) ;\n add_event ( nevent , TM_ERROR_NODE , TM_INIT , ( void * ) roots ) ;\n while ( TRUE ) {\n if ( ( err = tm_poll ( TM_NULL_EVENT , & revent , 1 , & nerr ) ) != TM_SUCCESS ) return err ;\n if ( event_count == 0 ) break ;\n }\n return nerr ;\n }", "hash": -2325305888478261876, "project": "debian", "size": 34, "target": 0, "idx": 10407}
{"code": "SPL_METHOD ( SplDoublyLinkedList , current ) {\n spl_dllist_object * intern = ( spl_dllist_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n spl_ptr_llist_element * element = intern -> traverse_pointer ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n if ( element == NULL || element -> data == NULL ) {\n RETURN_NULL ( ) ;\n }\n else {\n zval * data = ( zval * ) element -> data ;\n RETURN_ZVAL ( data , 1 , 0 ) ;\n }\n }", "hash": 8445816931248660591, "project": "debian", "size": 14, "target": 0, "idx": 10447}
{"code": "static void spl_dllist_it_get_current_key ( zend_object_iterator * iter , zval * key TSRMLS_DC ) {\n spl_dllist_it * iterator = ( spl_dllist_it * ) iter ;\n ZVAL_LONG ( key , iterator -> traverse_position ) ;\n }", "hash": 8445816931248660591, "project": "debian", "size": 4, "target": 0, "idx": 10454}
{"code": "zend_object_iterator * spl_dllist_get_iterator ( zend_class_entry * ce , zval * object , int by_ref TSRMLS_DC ) {\n spl_dllist_it * iterator ;\n spl_dllist_object * dllist_object = ( spl_dllist_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ;\n if ( by_ref ) {\n zend_throw_exception ( spl_ce_RuntimeException , \"An iterator cannot be used with foreach by reference\" , 0 TSRMLS_CC ) ;\n return NULL ;\n }\n Z_ADDREF_P ( object ) ;\n iterator = emalloc ( sizeof ( spl_dllist_it ) ) ;\n iterator -> intern . it . data = ( void * ) object ;\n iterator -> intern . it . funcs = & spl_dllist_it_funcs ;\n iterator -> intern . ce = ce ;\n iterator -> intern . value = NULL ;\n iterator -> traverse_position = dllist_object -> traverse_position ;\n iterator -> traverse_pointer = dllist_object -> traverse_pointer ;\n iterator -> flags = dllist_object -> flags & SPL_DLLIST_IT_MASK ;\n iterator -> object = dllist_object ;\n SPL_LLIST_CHECK_ADDREF ( iterator -> traverse_pointer ) ;\n return ( zend_object_iterator * ) iterator ;\n }", "hash": 8445816931248660591, "project": "debian", "size": 20, "target": 0, "idx": 10459}
{"code": "static void spl_ptr_llist_unshift ( spl_ptr_llist * llist , void * data TSRMLS_DC ) {\n spl_ptr_llist_element * elem = emalloc ( sizeof ( spl_ptr_llist_element ) ) ;\n elem -> data = data ;\n elem -> rc = 1 ;\n elem -> prev = NULL ;\n elem -> next = llist -> head ;\n if ( llist -> head ) {\n llist -> head -> prev = elem ;\n }\n else {\n llist -> tail = elem ;\n }\n llist -> head = elem ;\n llist -> count ++ ;\n if ( llist -> ctor ) {\n llist -> ctor ( elem TSRMLS_CC ) ;\n }\n }", "hash": 8445816931248660591, "project": "debian", "size": 18, "target": 0, "idx": 10461}
{"code": "SPL_METHOD ( SplDoublyLinkedList , key ) {\n spl_dllist_object * intern = ( spl_dllist_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_LONG ( intern -> traverse_position ) ;\n }", "hash": 8445816931248660591, "project": "debian", "size": 7, "target": 0, "idx": 10476}
{"code": "static spl_ptr_llist * spl_ptr_llist_init ( spl_ptr_llist_ctor_func ctor , spl_ptr_llist_dtor_func dtor ) {\n spl_ptr_llist * llist = emalloc ( sizeof ( spl_ptr_llist ) ) ;\n llist -> head = NULL ;\n llist -> tail = NULL ;\n llist -> count = 0 ;\n llist -> dtor = dtor ;\n llist -> ctor = ctor ;\n return llist ;\n }", "hash": 8445816931248660591, "project": "debian", "size": 9, "target": 0, "idx": 10479}
{"code": "static int spl_dllist_it_valid ( zend_object_iterator * iter TSRMLS_DC ) {\n spl_dllist_it * iterator = ( spl_dllist_it * ) iter ;\n spl_ptr_llist_element * element = iterator -> traverse_pointer ;\n return ( element != NULL ? SUCCESS : FAILURE ) ;\n }", "hash": 8445816931248660591, "project": "debian", "size": 5, "target": 0, "idx": 10483}
{"code": "static uint8_t record_byte_getter ( Gif_Reader * grr ) {\n if ( grr -> pos < grr -> length ) return grr -> v [ grr -> pos ++ ] ;\n else return 0 ;\n }", "hash": -9197960073880365676, "project": "debian", "size": 4, "target": 0, "idx": 10491}
{"code": "int Gif_FullUncompressImage ( Gif_Stream * gfs , Gif_Image * gfi , Gif_ReadErrorHandler h ) {\n Gif_Context gfc ;\n Gif_Reader grr ;\n int ok = 0 ;\n if ( gfi -> img ) return 2 ;\n if ( gfi -> image_data ) return 0 ;\n gfc . stream = gfs ;\n gfc . gfi = gfi ;\n gfc . prefix = Gif_NewArray ( Gif_Code , GIF_MAX_CODE ) ;\n gfc . suffix = Gif_NewArray ( uint8_t , GIF_MAX_CODE ) ;\n gfc . length = Gif_NewArray ( uint16_t , GIF_MAX_CODE ) ;\n gfc . handler = h ;\n gfc . errors [ 0 ] = gfc . errors [ 1 ] = 0 ;\n if ( gfc . prefix && gfc . suffix && gfc . length && gfi -> compressed ) {\n make_data_reader ( & grr , gfi -> compressed , gfi -> compressed_len ) ;\n ok = uncompress_image ( & gfc , gfi , & grr ) ;\n }\n Gif_DeleteArray ( gfc . prefix ) ;\n Gif_DeleteArray ( gfc . suffix ) ;\n Gif_DeleteArray ( gfc . length ) ;\n if ( gfc . errors [ 0 ] || gfc . errors [ 1 ] ) gif_read_error ( & gfc , - 1 , 0 ) ;\n return ok && ! gfc . errors [ 1 ] ;\n }", "hash": -9197960073880365676, "project": "debian", "size": 23, "target": 0, "idx": 10495}
{"code": "static int read_unknown_extension ( Gif_Context * gfc , Gif_Reader * grr , int kind , char * appname , int applength ) {\n uint8_t block_len = gifgetbyte ( grr ) ;\n uint8_t * data = 0 ;\n int data_len = 0 ;\n Gif_Extension * gfex = 0 ;\n while ( block_len > 0 ) {\n Gif_ReArray ( data , uint8_t , data_len + block_len + 2 ) ;\n if ( ! data ) goto done ;\n data [ data_len ] = block_len ;\n gifgetblock ( data + data_len + 1 , block_len , grr ) ;\n data_len += block_len + 1 ;\n block_len = gifgetbyte ( grr ) ;\n }\n if ( data ) gfex = Gif_NewExtension ( kind , appname , applength ) ;\n if ( gfex ) {\n gfex -> data = data ;\n gfex -> free_data = Gif_Free ;\n gfex -> length = data_len ;\n gfex -> packetized = 1 ;\n data [ data_len ] = 0 ;\n Gif_AddExtension ( gfc -> stream , gfc -> gfi , gfex ) ;\n }\n done : if ( ! gfex ) Gif_DeleteArray ( data ) ;\n while ( block_len > 0 ) {\n uint8_t buffer [ GIF_MAX_BLOCK ] ;\n gifgetblock ( buffer , block_len , grr ) ;\n block_len = gifgetbyte ( grr ) ;\n }\n return gfex != 0 ;\n }", "hash": -9197960073880365676, "project": "debian", "size": 30, "target": 0, "idx": 10507}
{"code": "static Gif_Stream * read_gif ( Gif_Reader * grr , int read_flags , const char * landmark , Gif_ReadErrorHandler handler ) {\n Gif_Stream * gfs ;\n Gif_Image * gfi ;\n Gif_Context gfc ;\n int unknown_block_type = 0 ;\n if ( gifgetc ( grr ) != 'G' || gifgetc ( grr ) != 'I' || gifgetc ( grr ) != 'F' ) return 0 ;\n ( void ) gifgetc ( grr ) ;\n ( void ) gifgetc ( grr ) ;\n ( void ) gifgetc ( grr ) ;\n gfs = Gif_NewStream ( ) ;\n gfi = Gif_NewImage ( ) ;\n gfc . stream = gfs ;\n gfc . prefix = Gif_NewArray ( Gif_Code , GIF_MAX_CODE ) ;\n gfc . suffix = Gif_NewArray ( uint8_t , GIF_MAX_CODE ) ;\n gfc . length = Gif_NewArray ( uint16_t , GIF_MAX_CODE ) ;\n gfc . handler = handler ;\n gfc . gfi = gfi ;\n gfc . errors [ 0 ] = gfc . errors [ 1 ] = 0 ;\n if ( ! gfs || ! gfi || ! gfc . prefix || ! gfc . suffix || ! gfc . length ) goto done ;\n gfs -> landmark = landmark ;\n GIF_DEBUG ( ( \"\\nGIF \" ) ) ;\n if ( ! read_logical_screen_descriptor ( gfs , grr ) ) goto done ;\n GIF_DEBUG ( ( \"logscrdesc \" ) ) ;\n while ( ! gifeof ( grr ) ) {\n uint8_t block = gifgetbyte ( grr ) ;\n switch ( block ) {\n case ',' : GIF_DEBUG ( ( \"imageread %d \" , gfs -> nimages ) ) ;\n gfi -> identifier = last_name ;\n last_name = 0 ;\n if ( ! Gif_AddImage ( gfs , gfi ) ) goto done ;\n else if ( ! read_image ( grr , & gfc , gfi , read_flags ) ) {\n Gif_RemoveImage ( gfs , gfs -> nimages - 1 ) ;\n gfi = 0 ;\n goto done ;\n }\n gfc . gfi = gfi = Gif_NewImage ( ) ;\n if ( ! gfi ) goto done ;\n break ;\n case ';\n' : GIF_DEBUG ( ( \"term\\n\" ) ) ;\n goto done ;\n case '!' : block = gifgetbyte ( grr ) ;\n GIF_DEBUG ( ( \"ext(0x%02X) \" , block ) ) ;\n switch ( block ) {\n case 0xF9 : read_graphic_control_extension ( & gfc , gfi , grr ) ;\n break ;\n case 0xCE : last_name = suck_data ( last_name , 0 , grr ) ;\n break ;\n case 0xFE : if ( ! read_comment_extension ( gfi , grr ) ) goto done ;\n break ;\n case 0xFF : read_application_extension ( & gfc , grr ) ;\n break ;\n default : read_unknown_extension ( & gfc , grr , block , 0 , 0 ) ;\n break ;\n }\n break ;\n default : if ( ! unknown_block_type ) {\n char buf [ 256 ] ;\n sprintf ( buf , \"unknown block type %d at file offset %u\" , block , grr -> pos - 1 ) ;\n gif_read_error ( & gfc , 1 , buf ) ;\n unknown_block_type = 1 ;\n }\n break ;\n }\n }\n done : if ( gfs && gfi ) {\n Gif_Extension * gfex ;\n gfs -> end_comment = gfi -> comment ;\n gfi -> comment = 0 ;\n gfs -> end_extension_list = gfi -> extension_list ;\n gfi -> extension_list = 0 ;\n for ( gfex = gfs -> end_extension_list ;\n gfex ;\n gfex = gfex -> next ) gfex -> image = NULL ;\n }\n Gif_DeleteImage ( gfi ) ;\n Gif_DeleteArray ( last_name ) ;\n Gif_DeleteArray ( gfc . prefix ) ;\n Gif_DeleteArray ( gfc . suffix ) ;\n Gif_DeleteArray ( gfc . length ) ;\n gfc . gfi = 0 ;\n if ( gfs ) gfs -> errors = gfc . errors [ 1 ] ;\n if ( gfs && gfc . errors [ 1 ] == 0 && ! ( read_flags & GIF_READ_TRAILING_GARBAGE_OK ) && ! grr -> eofer ( grr ) ) gif_read_error ( & gfc , 0 , \"trailing garbage after GIF ignored\" ) ;\n gif_read_error ( & gfc , - 1 , 0 ) ;\n return gfs ;\n }", "hash": -9197960073880365676, "project": "debian", "size": 86, "target": 0, "idx": 10518}
{"code": "CURLcode Curl_getformdata ( struct SessionHandle * data , struct FormData * * finalform , struct curl_httppost * post , const char * custom_content_type , curl_off_t * sizep ) {\n struct FormData * form = NULL ;\n struct FormData * firstform ;\n struct curl_httppost * file ;\n CURLcode result = CURLE_OK ;\n curl_off_t size = 0 ;\n char * boundary ;\n char * fileboundary = NULL ;\n struct curl_slist * curList ;\n * finalform = NULL ;\n if ( ! post ) return result ;\n boundary = formboundary ( data ) ;\n if ( ! boundary ) return CURLE_OUT_OF_MEMORY ;\n result = AddFormDataf ( & form , NULL , \"%s;\n boundary=%s\\r\\n\" , custom_content_type ? custom_content_type : \"Content-Type: multipart/form-data\" , boundary ) ;\n if ( result ) {\n Curl_safefree ( boundary ) ;\n return result ;\n }\n firstform = form ;\n do {\n if ( size ) {\n result = AddFormDataf ( & form , & size , \"\\r\\n\" ) ;\n if ( result ) break ;\n }\n result = AddFormDataf ( & form , & size , \"--%s\\r\\n\" , boundary ) ;\n if ( result ) break ;\n result = AddFormDataf ( & form , & size , \"Content-Disposition: form-data;\n name=\\\"\" ) ;\n if ( result ) break ;\n result = AddFormData ( & form , FORM_DATA , post -> name , post -> namelength , & size ) ;\n if ( result ) break ;\n result = AddFormDataf ( & form , & size , \"\\\"\" ) ;\n if ( result ) break ;\n if ( post -> more ) {\n Curl_safefree ( fileboundary ) ;\n fileboundary = formboundary ( data ) ;\n if ( ! fileboundary ) {\n result = CURLE_OUT_OF_MEMORY ;\n break ;\n }\n result = AddFormDataf ( & form , & size , \"\\r\\nContent-Type: multipart/mixed;\n\" \" boundary=%s\\r\\n\" , fileboundary ) ;\n if ( result ) break ;\n }\n file = post ;\n do {\n if ( post -> more ) {\n result = AddFormDataf ( & form , & size , \"\\r\\n--%s\\r\\nContent-Disposition: \" \"attachment\" , fileboundary ) ;\n if ( result ) break ;\n result = formdata_add_filename ( file , & form , & size ) ;\n if ( result ) break ;\n }\n else if ( post -> flags & ( HTTPPOST_FILENAME | HTTPPOST_BUFFER | HTTPPOST_CALLBACK ) ) {\n if ( post -> showfilename || ( post -> flags & HTTPPOST_FILENAME ) ) {\n result = formdata_add_filename ( post , & form , & size ) ;\n }\n if ( result ) break ;\n }\n if ( file -> contenttype ) {\n result = AddFormDataf ( & form , & size , \"\\r\\nContent-Type: %s\" , file -> contenttype ) ;\n if ( result ) break ;\n }\n curList = file -> contentheader ;\n while ( curList ) {\n result = AddFormDataf ( & form , & size , \"\\r\\n%s\" , curList -> data ) ;\n if ( result ) break ;\n curList = curList -> next ;\n }\n if ( result ) break ;\n result = AddFormDataf ( & form , & size , \"\\r\\n\\r\\n\" ) ;\n if ( result ) break ;\n if ( ( post -> flags & HTTPPOST_FILENAME ) || ( post -> flags & HTTPPOST_READFILE ) ) {\n FILE * fileread ;\n fileread = strequal ( \"-\" , file -> contents ) ? stdin : fopen ( file -> contents , \"rb\" ) ;\n if ( fileread ) {\n if ( fileread != stdin ) {\n fclose ( fileread ) ;\n result = AddFormData ( & form , FORM_FILE , file -> contents , 0 , & size ) ;\n }\n else {\n size_t nread ;\n char buffer [ 512 ] ;\n while ( ( nread = fread ( buffer , 1 , sizeof ( buffer ) , fileread ) ) != 0 ) {\n result = AddFormData ( & form , FORM_CONTENT , buffer , nread , & size ) ;\n if ( result ) break ;\n }\n }\n }\n else {\n if ( data ) failf ( data , \"couldn't open file \\\"%s\\\"\" , file -> contents ) ;\n * finalform = NULL ;\n result = CURLE_READ_ERROR ;\n }\n }\n else if ( post -> flags & HTTPPOST_BUFFER ) result = AddFormData ( & form , FORM_CONTENT , post -> buffer , post -> bufferlength , & size ) ;\n else if ( post -> flags & HTTPPOST_CALLBACK ) result = AddFormData ( & form , FORM_CALLBACK , post -> userp , post -> contentslength , & size ) ;\n else result = AddFormData ( & form , FORM_CONTENT , post -> contents , post -> contentslength , & size ) ;\n file = file -> more ;\n }\n while ( file && ! result ) ;\n if ( result ) break ;\n if ( post -> more ) {\n result = AddFormDataf ( & form , & size , \"\\r\\n--%s--\" , fileboundary ) ;\n if ( result ) break ;\n }\n }\n while ( ( post = post -> next ) != NULL ) ;\n if ( ! result ) result = AddFormDataf ( & form , & size , \"\\r\\n--%s--\\r\\n\" , boundary ) ;\n if ( result ) {\n Curl_formclean ( & firstform ) ;\n Curl_safefree ( fileboundary ) ;\n Curl_safefree ( boundary ) ;\n return result ;\n }\n * sizep = size ;\n Curl_safefree ( fileboundary ) ;\n Curl_safefree ( boundary ) ;\n * finalform = firstform ;\n return result ;\n }", "hash": -4635544075321012404, "project": "debian", "size": 121, "target": 0, "idx": 10533}
{"code": "static CURLcode AddFormDataf ( struct FormData * * formp , curl_off_t * size , const char * fmt , ... ) {\n char s [ 4096 ] ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n vsnprintf ( s , sizeof ( s ) , fmt , ap ) ;\n va_end ( ap ) ;\n return AddFormData ( formp , FORM_DATA , s , 0 , size ) ;\n }", "hash": -4635544075321012404, "project": "debian", "size": 8, "target": 0, "idx": 10536}
{"code": "static subpicture_t * ParseText ( decoder_t * p_dec , block_t * p_block ) {\n decoder_sys_t * p_sys = p_dec -> p_sys ;\n subpicture_t * p_spu = NULL ;\n char * psz_subtitle = NULL ;\n if ( p_block -> i_pts <= VLC_TS_INVALID ) {\n msg_Warn ( p_dec , \"subtitle without a date\" ) ;\n return NULL ;\n }\n if ( p_block -> i_buffer < 1 ) {\n msg_Warn ( p_dec , \"no subtitle data\" ) ;\n return NULL ;\n }\n psz_subtitle = malloc ( p_block -> i_buffer + 1 ) ;\n if ( psz_subtitle == NULL ) return NULL ;\n memcpy ( psz_subtitle , p_block -> p_buffer , p_block -> i_buffer ) ;\n psz_subtitle [ p_block -> i_buffer ] = '\\0' ;\n if ( p_sys -> iconv_handle == ( vlc_iconv_t ) - 1 ) {\n if ( EnsureUTF8 ( psz_subtitle ) == NULL ) {\n msg_Err ( p_dec , \"failed to convert subtitle encoding.\\n\" \"Try manually setting a character-encoding \" \"before you open the file.\" ) ;\n }\n }\n else {\n if ( p_sys -> b_autodetect_utf8 ) {\n if ( IsUTF8 ( psz_subtitle ) == NULL ) {\n msg_Dbg ( p_dec , \"invalid UTF-8 sequence: \" \"disabling UTF-8 subtitles autodetection\" ) ;\n p_sys -> b_autodetect_utf8 = false ;\n }\n }\n if ( ! p_sys -> b_autodetect_utf8 ) {\n size_t inbytes_left = strlen ( psz_subtitle ) ;\n size_t outbytes_left = 6 * inbytes_left ;\n char * psz_new_subtitle = xmalloc ( outbytes_left + 1 ) ;\n char * psz_convert_buffer_out = psz_new_subtitle ;\n const char * psz_convert_buffer_in = psz_subtitle ;\n size_t ret = vlc_iconv ( p_sys -> iconv_handle , & psz_convert_buffer_in , & inbytes_left , & psz_convert_buffer_out , & outbytes_left ) ;\n * psz_convert_buffer_out ++ = '\\0' ;\n free ( psz_subtitle ) ;\n if ( ( ret == ( size_t ) ( - 1 ) ) || inbytes_left ) {\n free ( psz_new_subtitle ) ;\n msg_Err ( p_dec , \"failed to convert subtitle encoding.\\n\" \"Try manually setting a character-encoding \" \"before you open the file.\" ) ;\n return NULL ;\n }\n psz_subtitle = realloc ( psz_new_subtitle , psz_convert_buffer_out - psz_new_subtitle ) ;\n if ( ! psz_subtitle ) psz_subtitle = psz_new_subtitle ;\n }\n }\n p_spu = decoder_NewSubpictureText ( p_dec ) ;\n if ( ! p_spu ) {\n free ( psz_subtitle ) ;\n return NULL ;\n }\n p_spu -> i_start = p_block -> i_pts ;\n p_spu -> i_stop = p_block -> i_pts + p_block -> i_length ;\n p_spu -> b_ephemer = ( p_block -> i_length == 0 ) ;\n p_spu -> b_absolute = false ;\n subpicture_updater_sys_t * p_spu_sys = p_spu -> updater . p_sys ;\n p_spu_sys -> align = SUBPICTURE_ALIGN_BOTTOM | p_sys -> i_align ;\n p_spu_sys -> text = StripTags ( psz_subtitle ) ;\n if ( var_InheritBool ( p_dec , \"subsdec-formatted\" ) ) p_spu_sys -> html = CreateHtmlSubtitle ( & p_spu_sys -> align , psz_subtitle ) ;\n free ( psz_subtitle ) ;\n return p_spu ;\n }", "hash": -275948070528829821, "project": "debian", "size": 62, "target": 0, "idx": 10540}
{"code": "static guint16 de_add_upd_params ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n curr_offset = offset ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , ( curr_offset << 3 ) + 4 , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_dtap_csmo , tvb , ( curr_offset << 3 ) + 6 , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_dtap_csmt , tvb , ( curr_offset << 3 ) + 7 , 1 , ENC_BIG_ENDIAN ) ;\n return ( len ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 8, "target": 0, "idx": 10566}
{"code": "static void dtap_cc_hold_rej ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_FALSE ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_DTAP , DE_CAUSE , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 10, "target": 0, "idx": 10575}
{"code": "static void dtap_gcc_setup ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_GCC_CALL_REF , NULL ) ;\n ELEM_OPT_TLV ( 0x7e , GSM_A_PDU_TYPE_DTAP , DE_USER_USER , NULL ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 9, "target": 0, "idx": 10582}
{"code": "guint16 de_bearer_cap_uplink ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len , gchar * add_string , int string_len ) {\n is_uplink = IS_UPLINK_TRUE ;\n return de_bearer_cap ( tvb , tree , pinfo , offset , len , add_string , string_len ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 4, "target": 0, "idx": 10613}
{"code": "static void dtap_bcc_imm_setup2 ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n guint8 oct ;\n proto_tree * subtree ;\n curr_offset = offset ;\n curr_len = len ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , curr_offset << 3 , 4 , ENC_BIG_ENDIAN ) ;\n subtree = proto_tree_add_subtree ( tree , tvb , curr_offset , 1 , ett_gsm_common_elem [ DE_CIPH_KEY_SEQ_NUM ] , NULL , val_to_str_ext_const ( DE_CIPH_KEY_SEQ_NUM , & gsm_common_elem_strings_ext , \"\" ) ) ;\n proto_tree_add_bits_item ( subtree , hf_gsm_a_spare_bits , tvb , ( curr_offset << 3 ) + 4 , 1 , ENC_BIG_ENDIAN ) ;\n switch ( oct & 0x07 ) {\n case 0x07 : proto_tree_add_uint_format_value ( subtree , hf_gsm_a_dtap_ciphering_key_sequence_number , tvb , curr_offset , 1 , oct , \"No key is available\" ) ;\n break ;\n default : proto_tree_add_item ( subtree , hf_gsm_a_dtap_ciphering_key_sequence_number , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n break ;\n }\n curr_offset ++ ;\n curr_len -- ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_COMMON , DE_MS_CM_2 , NULL ) ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_RR , DE_TMSI_STAT , NULL ) ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_BCC_CALL_REF , \"(Group identity)\" ) ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_BCC_COMPR_OTDI , NULL ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 24, "target": 0, "idx": 10636}
{"code": "guint16 de_rej_cause ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint8 oct ;\n const gchar * str ;\n oct = tvb_get_guint8 ( tvb , offset ) ;\n str = try_rval_to_str ( oct , gsm_a_dtap_rej_cause_vals ) ;\n if ( ! str ) {\n if ( is_uplink == IS_UPLINK_TRUE ) str = \"Protocol error, unspecified\" ;\n else str = \"Service option temporarily out of order\" ;\n }\n proto_tree_add_uint_format_value ( tree , hf_gsm_a_dtap_rej_cause , tvb , offset , 1 , oct , \"%s (%u)\" , str , oct ) ;\n return ( 1 ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 12, "target": 0, "idx": 10637}
{"code": "static guint16 de_tp_epc_ue_test_loop_mode ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n guint32 bit_offset ;\n curr_offset = offset ;\n bit_offset = curr_offset << 3 ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , bit_offset , 6 , ENC_BIG_ENDIAN ) ;\n bit_offset += 6 ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_dtap_epc_ue_tl_mode , tvb , bit_offset , 2 , ENC_BIG_ENDIAN ) ;\n epc_test_loop_mode = tvb_get_guint8 ( tvb , curr_offset ) & 0x03 ;\n curr_offset ++ ;\n return ( curr_offset - offset ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 12, "target": 0, "idx": 10638}
{"code": "static void dtap_cc_start_dtmf ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_TRUE ;\n ELEM_MAND_TV ( 0x2c , GSM_A_PDU_TYPE_DTAP , DE_KEYPAD_FACILITY , NULL , ei_gsm_a_dtap_missing_mandatory_element ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 10, "target": 0, "idx": 10646}
{"code": "static guint16 de_tp_epc_ue_positioning_technology ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n curr_offset = offset ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_dtap_epc_ue_positioning_technology , tvb , curr_offset << 3 , 8 , ENC_BIG_ENDIAN ) ;\n curr_offset ++ ;\n return ( curr_offset - offset ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 7, "target": 0, "idx": 10658}
{"code": "static void dtap_gcc_term_rej ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_DTAP , DE_GCC_CAUSE , \"(Reject Cause)\" ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 8, "target": 0, "idx": 10675}
{"code": "static void dtap_cc_user_info ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_TRUE ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_DTAP , DE_USER_USER , NULL ) ;\n ELEM_OPT_T ( 0xa0 , GSM_A_PDU_TYPE_DTAP , DE_MORE_DATA , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 11, "target": 0, "idx": 10684}
{"code": "static void dtap_bcc_set_param ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , curr_offset << 3 , 4 , ENC_NA ) ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_BCC_STATE_ATTR , NULL ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 9, "target": 0, "idx": 10695}
{"code": "static guint16 de_cc_cap ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len , gchar * add_string _U_ , int string_len _U_ ) {\n guint8 oct ;\n guint32 curr_offset ;\n curr_offset = offset ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n if ( ( ( oct & 0xf0 ) >> 4 ) == 0 ) {\n proto_tree_add_uint_format_value ( tree , hf_gsm_a_dtap_maximum_number_of_supported_bearers , tvb , curr_offset , 1 , 0 , \"1\" ) ;\n }\n else {\n proto_tree_add_item ( tree , hf_gsm_a_dtap_maximum_number_of_supported_bearers , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n }\n proto_tree_add_item ( tree , hf_gsm_a_dtap_mcat , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_enicm , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_pcp , tvb , curr_offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_dtmf , tvb , curr_offset , 1 , ENC_NA ) ;\n curr_offset ++ ;\n NO_MORE_DATA_CHECK ( len ) ;\n proto_tree_add_bits_item ( tree , hf_gsm_a_spare_bits , tvb , curr_offset << 3 , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_max_num_of_speech_bearers , tvb , curr_offset , 1 , ENC_BIG_ENDIAN ) ;\n curr_offset ++ ;\n EXTRANEOUS_DATA_CHECK ( len , curr_offset - offset , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n return ( curr_offset - offset ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 23, "target": 0, "idx": 10696}
{"code": "void proto_reg_handoff_gsm_a_dtap ( void ) {\n dissector_handle_t dtap_handle ;\n dtap_handle = find_dissector ( \"gsm_a_dtap\" ) ;\n dissector_add_uint ( \"bssap.pdu_type\" , BSSAP_PDU_TYPE_DTAP , dtap_handle ) ;\n dissector_add_uint ( \"ranap.nas_pdu\" , BSSAP_PDU_TYPE_DTAP , dtap_handle ) ;\n dissector_add_uint ( \"llcgprs.sapi\" , 1 , dtap_handle ) ;\n dissector_add_uint ( \"llcgprs.sapi\" , 7 , dtap_handle ) ;\n dissector_add_uint ( \"lapdm.sapi\" , 0 , dtap_handle ) ;\n dissector_add_uint ( \"lapdm.sapi\" , 3 , dtap_handle ) ;\n gsm_map_handle = find_dissector_add_dependency ( \"gsm_map\" , proto_a_dtap ) ;\n rp_handle = find_dissector_add_dependency ( \"gsm_a_rp\" , proto_a_dtap ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 12, "target": 0, "idx": 10703}
{"code": "static guint16 de_call_state ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint8 oct , coding_standard , call_state ;\n proto_tree * subtree ;\n subtree = proto_tree_add_subtree ( tree , tvb , offset , 1 , ett_gsm_dtap_elem [ DE_CALL_STATE ] , NULL , val_to_str_ext_const ( DE_CALL_STATE , & gsm_dtap_elem_strings_ext , \"\" ) ) ;\n proto_tree_add_item ( subtree , hf_gsm_a_dtap_coding_standard , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n oct = tvb_get_guint8 ( tvb , offset ) ;\n coding_standard = ( oct & 0xc0 ) >> 6 ;\n call_state = oct & 0x3f ;\n switch ( coding_standard ) {\n case 0 : proto_tree_add_uint_format_value ( subtree , hf_gsm_a_dtap_call_state , tvb , offset , 1 , call_state , \"%s (%u)\" , val_to_str_ext_const ( call_state , & q931_call_state_vals_ext , \"Reserved\" ) , call_state ) ;\n break ;\n case 1 : case 2 : proto_tree_add_item ( subtree , hf_gsm_a_dtap_call_state , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n break ;\n default : proto_tree_add_uint_format_value ( subtree , hf_gsm_a_dtap_call_state , tvb , offset , 1 , call_state , \"%s (%u)\" , val_to_str_const ( call_state , gsm_a_dtap_call_state_vals , \"Reserved\" ) , call_state ) ;\n break ;\n }\n return ( 1 ) ;\n }", "hash": 7039307292471244756, "project": "debian", "size": 18, "target": 0, "idx": 10706}
{"code": "static int cpu_post_load ( void * opaque , int version_id ) {\n X86CPU * cpu = opaque ;\n CPUState * cs = CPU ( cpu ) ;\n CPUX86State * env = & cpu -> env ;\n int i ;\n if ( env -> tsc_khz && env -> user_tsc_khz && env -> tsc_khz != env -> user_tsc_khz ) {\n error_report ( \"Mismatch between user-specified TSC frequency and \" \"migrated TSC frequency\" ) ;\n return - EINVAL ;\n }\n if ( env -> fpregs_format_vmstate ) {\n error_report ( \"Unsupported old non-softfloat CPU state\" ) ;\n return - EINVAL ;\n }\n if ( ! ( env -> cr [ 0 ] & CR0_PE_MASK ) && ( env -> segs [ R_CS ] . flags >> DESC_DPL_SHIFT & 3 ) != 0 ) {\n env -> segs [ R_CS ] . flags &= ~ ( env -> segs [ R_CS ] . flags & DESC_DPL_MASK ) ;\n env -> segs [ R_DS ] . flags &= ~ ( env -> segs [ R_DS ] . flags & DESC_DPL_MASK ) ;\n env -> segs [ R_ES ] . flags &= ~ ( env -> segs [ R_ES ] . flags & DESC_DPL_MASK ) ;\n env -> segs [ R_FS ] . flags &= ~ ( env -> segs [ R_FS ] . flags & DESC_DPL_MASK ) ;\n env -> segs [ R_GS ] . flags &= ~ ( env -> segs [ R_GS ] . flags & DESC_DPL_MASK ) ;\n env -> segs [ R_SS ] . flags &= ~ ( env -> segs [ R_SS ] . flags & DESC_DPL_MASK ) ;\n }\n env -> hflags &= ~ HF_CPL_MASK ;\n env -> hflags |= ( env -> segs [ R_SS ] . flags >> DESC_DPL_SHIFT ) & HF_CPL_MASK ;\n env -> fpstt = ( env -> fpus_vmstate >> 11 ) & 7 ;\n env -> fpus = env -> fpus_vmstate & ~ 0x3800 ;\n env -> fptag_vmstate ^= 0xff ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n env -> fptags [ i ] = ( env -> fptag_vmstate >> i ) & 1 ;\n }\n if ( tcg_enabled ( ) ) {\n target_ulong dr7 ;\n update_fp_status ( env ) ;\n update_mxcsr_status ( env ) ;\n cpu_breakpoint_remove_all ( cs , BP_CPU ) ;\n cpu_watchpoint_remove_all ( cs , BP_CPU ) ;\n dr7 = env -> dr [ 7 ] ;\n env -> dr [ 7 ] = dr7 & ~ ( DR7_GLOBAL_BP_MASK | DR7_LOCAL_BP_MASK ) ;\n cpu_x86_update_dr7 ( env , dr7 ) ;\n }\n tlb_flush ( cs ) ;\n return 0 ;\n }", "hash": 8388187431631506723, "project": "debian", "size": 44, "target": 0, "idx": 10721}
{"code": "static bool hyperv_time_enable_needed ( void * opaque ) {\n X86CPU * cpu = opaque ;\n CPUX86State * env = & cpu -> env ;\n return env -> msr_hv_tsc != 0 ;\n }", "hash": 8388187431631506723, "project": "debian", "size": 5, "target": 0, "idx": 10728}
{"code": "static int fpreg_pre_save ( void * opaque ) {\n x86_FPReg_tmp * tmp = opaque ;\n cpu_get_fp80 ( & tmp -> tmp_mant , & tmp -> tmp_exp , tmp -> parent -> d ) ;\n return 0 ;\n }", "hash": 8388187431631506723, "project": "debian", "size": 5, "target": 0, "idx": 10731}
{"code": "static bool steal_time_msr_needed ( void * opaque ) {\n X86CPU * cpu = opaque ;\n return cpu -> env . steal_time_msr != 0 ;\n }", "hash": 8388187431631506723, "project": "debian", "size": 4, "target": 0, "idx": 10742}
{"code": "static bool spec_ctrl_needed ( void * opaque ) {\n X86CPU * cpu = opaque ;\n CPUX86State * env = & cpu -> env ;\n return env -> spec_ctrl != 0 ;\n }", "hash": 8388187431631506723, "project": "debian", "size": 5, "target": 0, "idx": 10745}
{"code": "static int fpreg_post_load ( void * opaque , int version ) {\n x86_FPReg_tmp * tmp = opaque ;\n tmp -> parent -> d = cpu_set_fp80 ( tmp -> tmp_mant , tmp -> tmp_exp ) ;\n return 0 ;\n }", "hash": 8388187431631506723, "project": "debian", "size": 5, "target": 0, "idx": 10748}
{"code": "static bool host_tsx_blacklisted ( void ) {\n int family , model , stepping ;\n char vendor [ CPUID_VENDOR_SZ + 1 ] ;\n host_vendor_fms ( vendor , & family , & model , & stepping ) ;\n return ! strcmp ( vendor , CPUID_VENDOR_INTEL ) && ( family == 6 ) && ( ( model == 63 && stepping < 4 ) || model == 60 || model == 69 || model == 70 ) ;\n }", "hash": -7455544248455991006, "project": "debian", "size": 6, "target": 0, "idx": 10755}
{"code": "bool kvm_device_msix_supported ( KVMState * s ) {\n return kvm_vm_ioctl ( s , KVM_ASSIGN_SET_MSIX_NR , NULL ) == - EFAULT ;\n }", "hash": -7455544248455991006, "project": "debian", "size": 3, "target": 0, "idx": 10779}
{"code": "void kvm_arch_remove_all_hw_breakpoints ( void ) {\n nb_hw_breakpoint = 0 ;\n }", "hash": -7455544248455991006, "project": "debian", "size": 3, "target": 0, "idx": 10785}
{"code": "bool kvm_allows_irq0_override ( void ) {\n return ! kvm_irqchip_in_kernel ( ) || kvm_has_gsi_routing ( ) ;\n }", "hash": -7455544248455991006, "project": "debian", "size": 3, "target": 0, "idx": 10796}
{"code": "static bool hyperv_hypercall_available ( X86CPU * cpu ) {\n return cpu -> hyperv_vapic || ( cpu -> hyperv_spinlock_attempts != HYPERV_SPINLOCK_NEVER_RETRY ) ;\n }", "hash": -7455544248455991006, "project": "debian", "size": 3, "target": 0, "idx": 10802}
{"code": "static int kvm_inject_mce_oldstyle ( X86CPU * cpu ) {\n CPUX86State * env = & cpu -> env ;\n if ( ! kvm_has_vcpu_events ( ) && env -> exception_injected == EXCP12_MCHK ) {\n unsigned int bank , bank_num = env -> mcg_cap & 0xff ;\n struct kvm_x86_mce mce ;\n env -> exception_injected = - 1 ;\n for ( bank = 0 ;\n bank < bank_num ;\n bank ++ ) {\n if ( env -> mce_banks [ bank * 4 + 1 ] & MCI_STATUS_VAL ) {\n break ;\n }\n }\n assert ( bank < bank_num ) ;\n mce . bank = bank ;\n mce . status = env -> mce_banks [ bank * 4 + 1 ] ;\n mce . mcg_status = env -> mcg_status ;\n mce . addr = env -> mce_banks [ bank * 4 + 2 ] ;\n mce . misc = env -> mce_banks [ bank * 4 + 3 ] ;\n return kvm_vcpu_ioctl ( CPU ( cpu ) , KVM_X86_SET_MCE , & mce ) ;\n }\n return 0 ;\n }", "hash": -7455544248455991006, "project": "debian", "size": 23, "target": 0, "idx": 10818}
{"code": "int kvm_device_msi_assign ( KVMState * s , uint32_t dev_id , int virq ) {\n return kvm_assign_irq_internal ( s , dev_id , KVM_DEV_IRQ_HOST_MSI | KVM_DEV_IRQ_GUEST_MSI , virq ) ;\n }", "hash": -7455544248455991006, "project": "debian", "size": 3, "target": 0, "idx": 10823}
{"code": "int kvm_device_msix_assign ( KVMState * s , uint32_t dev_id ) {\n return kvm_assign_irq_internal ( s , dev_id , KVM_DEV_IRQ_HOST_MSIX | KVM_DEV_IRQ_GUEST_MSIX , 0 ) ;\n }", "hash": -7455544248455991006, "project": "debian", "size": 3, "target": 0, "idx": 10846}
{"code": "static void set_v8086_seg ( struct kvm_segment * lhs , const SegmentCache * rhs ) {\n lhs -> selector = rhs -> selector ;\n lhs -> base = rhs -> base ;\n lhs -> limit = rhs -> limit ;\n lhs -> type = 3 ;\n lhs -> present = 1 ;\n lhs -> dpl = 3 ;\n lhs -> db = 0 ;\n lhs -> s = 1 ;\n lhs -> l = 0 ;\n lhs -> g = 0 ;\n lhs -> avl = 0 ;\n lhs -> unusable = 0 ;\n }", "hash": -7455544248455991006, "project": "debian", "size": 14, "target": 0, "idx": 10847}
{"code": "bool kvm_has_x2apic_api ( void ) {\n return has_x2apic_api ;\n }", "hash": -7455544248455991006, "project": "debian", "size": 3, "target": 0, "idx": 10850}
{"code": "static struct kvm_cpuid2 * get_supported_cpuid ( KVMState * s ) {\n struct kvm_cpuid2 * cpuid ;\n int max = 1 ;\n if ( cpuid_cache != NULL ) {\n return cpuid_cache ;\n }\n while ( ( cpuid = try_get_cpuid ( s , max ) ) == NULL ) {\n max *= 2 ;\n }\n cpuid_cache = cpuid ;\n return cpuid ;\n }", "hash": -7455544248455991006, "project": "debian", "size": 12, "target": 0, "idx": 10854}
{"code": "static int dissect_h225_T_h245IpxAddress ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_T_h245IpxAddress , T_h245IpxAddress_sequence ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 10857}
{"code": "static int dissect_h225_T_h245IpAddress ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_T_h245IpAddress , T_h245IpAddress_sequence ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 10875}
{"code": "static int dissect_h225_OCTET_STRING_SIZE_2_32 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , 2 , 32 , FALSE , NULL ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 10876}
{"code": "static int dissect_h225_CallProceeding_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 489 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_CallProceeding_UUIE , CallProceeding_UUIE_sequence ) ;\n # line 493 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_CALL_PROCEDING ;\n if ( contains_faststart ) {\n char temp [ 50 ] ;\n g_snprintf ( temp , 50 , \"%s OLC (%s)\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) , h225_pi -> frame_label ) ;\n g_strlcpy ( h225_pi -> frame_label , temp , 50 ) ;\n }\n else g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 15, "target": 0, "idx": 10898}
{"code": "static int dissect_h225_T_h245Route ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_T_h245Route , T_h245Route_sequence_of ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 10905}
{"code": "static int dissect_h225_BMPString_SIZE_1_512 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_BMPString ( tvb , offset , actx , tree , hf_index , 1 , 512 , FALSE ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 10914}
{"code": "static int dissect_h225_T_oid ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 883 \"./asn1/h225/h225.cnf\" const gchar * oid_str = NULL ;\n gef_ctx_t * gefx ;\n offset = dissect_per_object_identifier_str ( tvb , offset , actx , tree , hf_index , & oid_str ) ;\n gefx = gef_ctx_get ( actx -> private_data ) ;\n if ( gefx ) gefx -> id = oid_str ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 8, "target": 0, "idx": 10923}
{"code": "static int dissect_h225_NonStandardIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 783 \"./asn1/h225/h225.cnf\" gint32 value ;\n nsiOID = \"\" ;\n h221NonStandard = 0 ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_NonStandardIdentifier , NonStandardIdentifier_choice , & value ) ;\n switch ( value ) {\n case 0 : nsp_handle = dissector_get_string_handle ( nsp_object_dissector_table , nsiOID ) ;\n break ;\n case 1 : nsp_handle = dissector_get_uint_handle ( nsp_h221_dissector_table , h221NonStandard ) ;\n break ;\n default : nsp_handle = NULL ;\n }\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 14, "target": 0, "idx": 10931}
{"code": "static int dissect_h225_T_associatedSessionIds ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_T_associatedSessionIds , T_associatedSessionIds_sequence_of ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 10938}
{"code": "static int dissect_h225_T_h323_message_body ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 241 \"./asn1/h225/h225.cnf\" gint32 message_body_val ;\n h225_packet_info * h225_pi ;\n contains_faststart = FALSE ;\n call_id_guid = NULL ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_T_h323_message_body , T_h323_message_body_choice , & message_body_val ) ;\n col_append_fstr ( actx -> pinfo -> cinfo , COL_INFO , \"CS: %s \" , val_to_str ( message_body_val , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n if ( h225_pi -> msg_type == H225_CS ) {\n h225_pi -> msg_tag = message_body_val ;\n }\n if ( call_id_guid ) {\n h225_pi -> guid = * call_id_guid ;\n }\n }\n if ( contains_faststart == TRUE ) {\n col_append_str ( actx -> pinfo -> cinfo , COL_INFO , \"OpenLogicalChannel \" ) ;\n }\n col_set_fence ( actx -> pinfo -> cinfo , COL_INFO ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 22, "target": 0, "idx": 10945}
{"code": "static int dissect_h225_ServiceControlDescriptor ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_ServiceControlDescriptor , ServiceControlDescriptor_choice , NULL ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 10946}
{"code": "int dissect_h225_SupportedProtocols ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_SupportedProtocols , SupportedProtocols_choice , NULL ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 10962}
{"code": "static int dissect_h225_Language ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_Language , Language_sequence_of ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 10967}
{"code": "static int dissect_h225_CapacityReportingSpecification_when ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_CapacityReportingSpecification_when , CapacityReportingSpecification_when_sequence ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 10988}
{"code": "static int dissect_h225_UUIEsRequested ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_UUIEsRequested , UUIEsRequested_sequence ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 10989}
{"code": "static int dissect_h225_FeatureDescriptor ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 852 \"./asn1/h225/h225.cnf\" void * priv_data = actx -> private_data ;\n actx -> private_data = gef_ctx_alloc ( NULL , \"FeatureDescriptor\" ) ;\n offset = dissect_h225_GenericData ( tvb , offset , actx , tree , hf_index ) ;\n # line 855 \"./asn1/h225/h225.cnf\" actx -> private_data = priv_data ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 7, "target": 0, "idx": 10999}
{"code": "int dissect_h225_TransportAddress ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_TransportAddress , TransportAddress_choice , NULL ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 11020}
{"code": "static int dissect_h225_IA5String_SIZE_0_512 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_IA5String ( tvb , offset , actx , tree , hf_index , 0 , 512 , FALSE ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 11026}
{"code": "static int dissect_h225_IsupNumber ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_IsupNumber , IsupNumber_choice , NULL ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 11029}
{"code": "int dissect_h225_GatekeeperIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_BMPString ( tvb , offset , actx , tree , hf_index , 1 , 128 , FALSE ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 11039}
{"code": "static int dissect_h225_T_pdu ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_T_pdu , T_pdu_sequence_of ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 11071}
{"code": "static int dissect_h225_T_h245Tunnelling ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 458 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n offset = dissect_per_boolean ( tvb , offset , actx , tree , hf_index , & ( h225_pi -> is_h245Tunneling ) ) ;\n # line 466 \"./asn1/h225/h225.cnf\" }\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 8, "target": 0, "idx": 11077}
{"code": "static int dissect_h225_T_cryptoGKPwdHash ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_T_cryptoGKPwdHash , T_cryptoGKPwdHash_sequence ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 11082}
{"code": "static int dissect_h225_SEQUENCE_OF_AliasAddress ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_OF_AliasAddress , SEQUENCE_OF_AliasAddress_sequence_of ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 11089}
{"code": "static int dissect_h225_DisengageConfirm ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_DisengageConfirm , DisengageConfirm_sequence ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 11094}
{"code": "static int dissect_h225_IA5String_SIZE_1_64 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_IA5String ( tvb , offset , actx , tree , hf_index , 1 , 64 , FALSE ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 11128}
{"code": "static int dissect_h225_SetupAcknowledge_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 432 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_SetupAcknowledge_UUIE , SetupAcknowledge_UUIE_sequence ) ;\n # line 436 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_SETUP_ACK ;\n g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 10, "target": 0, "idx": 11133}
{"code": "static int dissect_h225_T_result ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_T_result , T_result_choice , NULL ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 11136}
{"code": "static int dissect_h225_DisengageReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 648 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_DisengageReason , DisengageReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 10, "target": 0, "idx": 11142}
{"code": "static int dissect_h225_T_ipSourceRoute ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_T_ipSourceRoute , T_ipSourceRoute_sequence ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 11155}
{"code": "static int dissect_h225_UnregRequestReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 615 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_UnregRequestReason , UnregRequestReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 10, "target": 0, "idx": 11183}
{"code": "int dissect_h225_AlternateTransportAddresses ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_AlternateTransportAddresses , AlternateTransportAddresses_sequence ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 11188}
{"code": "static int dissect_h225_SEQUENCE_OF_DisplayName ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_OF_DisplayName , SEQUENCE_OF_DisplayName_sequence_of ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 11189}
{"code": "static int dissect_h225_CallCapacityInfo ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_CallCapacityInfo , CallCapacityInfo_sequence ) ;\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 4, "target": 0, "idx": 11191}
{"code": "static bool has_parallel_hazard_checker ( Oid func_id , void * context ) {\n char proparallel = func_parallel ( func_id ) ;\n if ( ( ( has_parallel_hazard_arg * ) context ) -> allow_restricted ) return ( proparallel == PROPARALLEL_UNSAFE ) ;\n else return ( proparallel != PROPARALLEL_SAFE ) ;\n }", "hash": -3559021711340554904, "project": "debian", "size": 5, "target": 0, "idx": 11214}
{"code": "Expr * make_notclause ( Expr * notclause ) {\n BoolExpr * expr = makeNode ( BoolExpr ) ;\n expr -> boolop = NOT_EXPR ;\n expr -> args = list_make1 ( notclause ) ;\n expr -> location = - 1 ;\n return ( Expr * ) expr ;\n }", "hash": -3559021711340554904, "project": "debian", "size": 7, "target": 0, "idx": 11227}
{"code": "static bool contain_nonstrict_functions_walker ( Node * node , void * context ) {\n if ( node == NULL ) return false ;\n if ( IsA ( node , Aggref ) ) {\n return true ;\n }\n if ( IsA ( node , GroupingFunc ) ) {\n return true ;\n }\n if ( IsA ( node , WindowFunc ) ) {\n return true ;\n }\n if ( IsA ( node , ArrayRef ) ) {\n if ( ( ( ArrayRef * ) node ) -> refassgnexpr != NULL ) return true ;\n }\n if ( IsA ( node , DistinctExpr ) ) {\n return true ;\n }\n if ( IsA ( node , NullIfExpr ) ) {\n return true ;\n }\n if ( IsA ( node , BoolExpr ) ) {\n BoolExpr * expr = ( BoolExpr * ) node ;\n switch ( expr -> boolop ) {\n case AND_EXPR : case OR_EXPR : return true ;\n default : break ;\n }\n }\n if ( IsA ( node , SubLink ) ) {\n return true ;\n }\n if ( IsA ( node , SubPlan ) ) return true ;\n if ( IsA ( node , AlternativeSubPlan ) ) return true ;\n if ( IsA ( node , FieldStore ) ) return true ;\n if ( IsA ( node , CaseExpr ) ) return true ;\n if ( IsA ( node , ArrayExpr ) ) return true ;\n if ( IsA ( node , RowExpr ) ) return true ;\n if ( IsA ( node , RowCompareExpr ) ) return true ;\n if ( IsA ( node , CoalesceExpr ) ) return true ;\n if ( IsA ( node , MinMaxExpr ) ) return true ;\n if ( IsA ( node , XmlExpr ) ) return true ;\n if ( IsA ( node , NullTest ) ) return true ;\n if ( IsA ( node , BooleanTest ) ) return true ;\n if ( ! IsA ( node , ArrayCoerceExpr ) && check_functions_in_node ( node , contain_nonstrict_functions_checker , context ) ) return true ;\n return expression_tree_walker ( node , contain_nonstrict_functions_walker , context ) ;\n }", "hash": -3559021711340554904, "project": "debian", "size": 45, "target": 0, "idx": 11239}
{"code": "static Expr * simplify_function ( Oid funcid , Oid result_type , int32 result_typmod , Oid result_collid , Oid input_collid , List * * args_p , bool funcvariadic , bool process_args , bool allow_non_const , eval_const_expressions_context * context ) {\n List * args = * args_p ;\n HeapTuple func_tuple ;\n Form_pg_proc func_form ;\n Expr * newexpr ;\n func_tuple = SearchSysCache1 ( PROCOID , ObjectIdGetDatum ( funcid ) ) ;\n if ( ! HeapTupleIsValid ( func_tuple ) ) elog ( ERROR , \"cache lookup failed for function %u\" , funcid ) ;\n func_form = ( Form_pg_proc ) GETSTRUCT ( func_tuple ) ;\n if ( process_args ) {\n args = expand_function_arguments ( args , result_type , func_tuple ) ;\n args = ( List * ) expression_tree_mutator ( ( Node * ) args , eval_const_expressions_mutator , ( void * ) context ) ;\n * args_p = args ;\n }\n newexpr = evaluate_function ( funcid , result_type , result_typmod , result_collid , input_collid , args , funcvariadic , func_tuple , context ) ;\n if ( ! newexpr && allow_non_const && OidIsValid ( func_form -> protransform ) ) {\n FuncExpr fexpr ;\n fexpr . xpr . type = T_FuncExpr ;\n fexpr . funcid = funcid ;\n fexpr . funcresulttype = result_type ;\n fexpr . funcretset = func_form -> proretset ;\n fexpr . funcvariadic = funcvariadic ;\n fexpr . funcformat = COERCE_EXPLICIT_CALL ;\n fexpr . funccollid = result_collid ;\n fexpr . inputcollid = input_collid ;\n fexpr . args = args ;\n fexpr . location = - 1 ;\n newexpr = ( Expr * ) DatumGetPointer ( OidFunctionCall1 ( func_form -> protransform , PointerGetDatum ( & fexpr ) ) ) ;\n }\n if ( ! newexpr && allow_non_const ) newexpr = inline_function ( funcid , result_type , result_collid , input_collid , args , funcvariadic , func_tuple , context ) ;\n ReleaseSysCache ( func_tuple ) ;\n return newexpr ;\n }", "hash": -3559021711340554904, "project": "debian", "size": 32, "target": 0, "idx": 11262}
{"code": "double tlist_returns_set_rows ( List * tlist ) {\n double result = 1 ;\n ListCell * lc ;\n foreach ( lc , tlist ) {\n TargetEntry * tle = ( TargetEntry * ) lfirst ( lc ) ;\n double colresult ;\n colresult = expression_returns_set_rows ( ( Node * ) tle -> expr ) ;\n if ( result < colresult ) result = colresult ;\n }\n return result ;\n }", "hash": -3559021711340554904, "project": "debian", "size": 11, "target": 0, "idx": 11278}
{"code": "ExprState * ExecInitExpr ( Expr * node , PlanState * parent ) {\n ExprState * state ;\n if ( node == NULL ) return NULL ;\n check_stack_depth ( ) ;\n switch ( nodeTag ( node ) ) {\n case T_Var : if ( ( ( Var * ) node ) -> varattno == InvalidAttrNumber ) {\n WholeRowVarExprState * wstate = makeNode ( WholeRowVarExprState ) ;\n wstate -> parent = parent ;\n wstate -> wrv_tupdesc = NULL ;\n wstate -> wrv_junkFilter = NULL ;\n state = ( ExprState * ) wstate ;\n state -> evalfunc = ( ExprStateEvalFunc ) ExecEvalWholeRowVar ;\n }\n else {\n state = ( ExprState * ) makeNode ( ExprState ) ;\n state -> evalfunc = ExecEvalScalarVar ;\n }\n break ;\n case T_Const : state = ( ExprState * ) makeNode ( ExprState ) ;\n state -> evalfunc = ExecEvalConst ;\n break ;\n case T_Param : state = ( ExprState * ) makeNode ( ExprState ) ;\n switch ( ( ( Param * ) node ) -> paramkind ) {\n case PARAM_EXEC : state -> evalfunc = ExecEvalParamExec ;\n break ;\n case PARAM_EXTERN : state -> evalfunc = ExecEvalParamExtern ;\n break ;\n default : elog ( ERROR , \"unrecognized paramkind: %d\" , ( int ) ( ( Param * ) node ) -> paramkind ) ;\n break ;\n }\n break ;\n case T_CoerceToDomainValue : state = ( ExprState * ) makeNode ( ExprState ) ;\n state -> evalfunc = ExecEvalCoerceToDomainValue ;\n break ;\n case T_CaseTestExpr : state = ( ExprState * ) makeNode ( ExprState ) ;\n state -> evalfunc = ExecEvalCaseTestExpr ;\n break ;\n case T_Aggref : {\n AggrefExprState * astate = makeNode ( AggrefExprState ) ;\n astate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalAggref ;\n if ( parent && IsA ( parent , AggState ) ) {\n AggState * aggstate = ( AggState * ) parent ;\n aggstate -> aggs = lcons ( astate , aggstate -> aggs ) ;\n aggstate -> numaggs ++ ;\n }\n else {\n elog ( ERROR , \"Aggref found in non-Agg plan node\" ) ;\n }\n state = ( ExprState * ) astate ;\n }\n break ;\n case T_GroupingFunc : {\n GroupingFunc * grp_node = ( GroupingFunc * ) node ;\n GroupingFuncExprState * grp_state = makeNode ( GroupingFuncExprState ) ;\n Agg * agg = NULL ;\n if ( ! parent || ! IsA ( parent , AggState ) || ! IsA ( parent -> plan , Agg ) ) elog ( ERROR , \"parent of GROUPING is not Agg node\" ) ;\n grp_state -> aggstate = ( AggState * ) parent ;\n agg = ( Agg * ) ( parent -> plan ) ;\n if ( agg -> groupingSets ) grp_state -> clauses = grp_node -> cols ;\n else grp_state -> clauses = NIL ;\n state = ( ExprState * ) grp_state ;\n state -> evalfunc = ( ExprStateEvalFunc ) ExecEvalGroupingFuncExpr ;\n }\n break ;\n case T_WindowFunc : {\n WindowFunc * wfunc = ( WindowFunc * ) node ;\n WindowFuncExprState * wfstate = makeNode ( WindowFuncExprState ) ;\n wfstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalWindowFunc ;\n if ( parent && IsA ( parent , WindowAggState ) ) {\n WindowAggState * winstate = ( WindowAggState * ) parent ;\n int nfuncs ;\n winstate -> funcs = lcons ( wfstate , winstate -> funcs ) ;\n nfuncs = ++ winstate -> numfuncs ;\n if ( wfunc -> winagg ) winstate -> numaggs ++ ;\n wfstate -> args = ( List * ) ExecInitExpr ( ( Expr * ) wfunc -> args , parent ) ;\n wfstate -> aggfilter = ExecInitExpr ( wfunc -> aggfilter , parent ) ;\n if ( nfuncs != winstate -> numfuncs ) ereport ( ERROR , ( errcode ( ERRCODE_WINDOWING_ERROR ) , errmsg ( \"window function calls cannot be nested\" ) ) ) ;\n }\n else {\n elog ( ERROR , \"WindowFunc found in non-WindowAgg plan node\" ) ;\n }\n state = ( ExprState * ) wfstate ;\n }\n break ;\n case T_ArrayRef : {\n ArrayRef * aref = ( ArrayRef * ) node ;\n ArrayRefExprState * astate = makeNode ( ArrayRefExprState ) ;\n astate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalArrayRef ;\n astate -> refupperindexpr = ( List * ) ExecInitExpr ( ( Expr * ) aref -> refupperindexpr , parent ) ;\n astate -> reflowerindexpr = ( List * ) ExecInitExpr ( ( Expr * ) aref -> reflowerindexpr , parent ) ;\n astate -> refexpr = ExecInitExpr ( aref -> refexpr , parent ) ;\n astate -> refassgnexpr = ExecInitExpr ( aref -> refassgnexpr , parent ) ;\n astate -> refattrlength = get_typlen ( aref -> refarraytype ) ;\n get_typlenbyvalalign ( aref -> refelemtype , & astate -> refelemlength , & astate -> refelembyval , & astate -> refelemalign ) ;\n state = ( ExprState * ) astate ;\n }\n break ;\n case T_FuncExpr : {\n FuncExpr * funcexpr = ( FuncExpr * ) node ;\n FuncExprState * fstate = makeNode ( FuncExprState ) ;\n fstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalFunc ;\n fstate -> args = ( List * ) ExecInitExpr ( ( Expr * ) funcexpr -> args , parent ) ;\n fstate -> func . fn_oid = InvalidOid ;\n state = ( ExprState * ) fstate ;\n }\n break ;\n case T_OpExpr : {\n OpExpr * opexpr = ( OpExpr * ) node ;\n FuncExprState * fstate = makeNode ( FuncExprState ) ;\n fstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalOper ;\n fstate -> args = ( List * ) ExecInitExpr ( ( Expr * ) opexpr -> args , parent ) ;\n fstate -> func . fn_oid = InvalidOid ;\n state = ( ExprState * ) fstate ;\n }\n break ;\n case T_DistinctExpr : {\n DistinctExpr * distinctexpr = ( DistinctExpr * ) node ;\n FuncExprState * fstate = makeNode ( FuncExprState ) ;\n fstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalDistinct ;\n fstate -> args = ( List * ) ExecInitExpr ( ( Expr * ) distinctexpr -> args , parent ) ;\n fstate -> func . fn_oid = InvalidOid ;\n state = ( ExprState * ) fstate ;\n }\n break ;\n case T_NullIfExpr : {\n NullIfExpr * nullifexpr = ( NullIfExpr * ) node ;\n FuncExprState * fstate = makeNode ( FuncExprState ) ;\n fstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalNullIf ;\n fstate -> args = ( List * ) ExecInitExpr ( ( Expr * ) nullifexpr -> args , parent ) ;\n fstate -> func . fn_oid = InvalidOid ;\n state = ( ExprState * ) fstate ;\n }\n break ;\n case T_ScalarArrayOpExpr : {\n ScalarArrayOpExpr * opexpr = ( ScalarArrayOpExpr * ) node ;\n ScalarArrayOpExprState * sstate = makeNode ( ScalarArrayOpExprState ) ;\n sstate -> fxprstate . xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalScalarArrayOp ;\n sstate -> fxprstate . args = ( List * ) ExecInitExpr ( ( Expr * ) opexpr -> args , parent ) ;\n sstate -> fxprstate . func . fn_oid = InvalidOid ;\n sstate -> element_type = InvalidOid ;\n state = ( ExprState * ) sstate ;\n }\n break ;\n case T_BoolExpr : {\n BoolExpr * boolexpr = ( BoolExpr * ) node ;\n BoolExprState * bstate = makeNode ( BoolExprState ) ;\n switch ( boolexpr -> boolop ) {\n case AND_EXPR : bstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalAnd ;\n break ;\n case OR_EXPR : bstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalOr ;\n break ;\n case NOT_EXPR : bstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalNot ;\n break ;\n default : elog ( ERROR , \"unrecognized boolop: %d\" , ( int ) boolexpr -> boolop ) ;\n break ;\n }\n bstate -> args = ( List * ) ExecInitExpr ( ( Expr * ) boolexpr -> args , parent ) ;\n state = ( ExprState * ) bstate ;\n }\n break ;\n case T_SubPlan : {\n SubPlan * subplan = ( SubPlan * ) node ;\n SubPlanState * sstate ;\n if ( ! parent ) elog ( ERROR , \"SubPlan found with no parent plan\" ) ;\n sstate = ExecInitSubPlan ( subplan , parent ) ;\n parent -> subPlan = lappend ( parent -> subPlan , sstate ) ;\n state = ( ExprState * ) sstate ;\n }\n break ;\n case T_AlternativeSubPlan : {\n AlternativeSubPlan * asplan = ( AlternativeSubPlan * ) node ;\n AlternativeSubPlanState * asstate ;\n if ( ! parent ) elog ( ERROR , \"AlternativeSubPlan found with no parent plan\" ) ;\n asstate = ExecInitAlternativeSubPlan ( asplan , parent ) ;\n state = ( ExprState * ) asstate ;\n }\n break ;\n case T_FieldSelect : {\n FieldSelect * fselect = ( FieldSelect * ) node ;\n FieldSelectState * fstate = makeNode ( FieldSelectState ) ;\n fstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalFieldSelect ;\n fstate -> arg = ExecInitExpr ( fselect -> arg , parent ) ;\n fstate -> argdesc = NULL ;\n state = ( ExprState * ) fstate ;\n }\n break ;\n case T_FieldStore : {\n FieldStore * fstore = ( FieldStore * ) node ;\n FieldStoreState * fstate = makeNode ( FieldStoreState ) ;\n fstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalFieldStore ;\n fstate -> arg = ExecInitExpr ( fstore -> arg , parent ) ;\n fstate -> newvals = ( List * ) ExecInitExpr ( ( Expr * ) fstore -> newvals , parent ) ;\n fstate -> argdesc = NULL ;\n state = ( ExprState * ) fstate ;\n }\n break ;\n case T_RelabelType : {\n RelabelType * relabel = ( RelabelType * ) node ;\n GenericExprState * gstate = makeNode ( GenericExprState ) ;\n gstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalRelabelType ;\n gstate -> arg = ExecInitExpr ( relabel -> arg , parent ) ;\n state = ( ExprState * ) gstate ;\n }\n break ;\n case T_CoerceViaIO : {\n CoerceViaIO * iocoerce = ( CoerceViaIO * ) node ;\n CoerceViaIOState * iostate = makeNode ( CoerceViaIOState ) ;\n Oid iofunc ;\n bool typisvarlena ;\n iostate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalCoerceViaIO ;\n iostate -> arg = ExecInitExpr ( iocoerce -> arg , parent ) ;\n getTypeInputInfo ( iocoerce -> resulttype , & iofunc , & iostate -> intypioparam ) ;\n fmgr_info ( iofunc , & iostate -> infunc ) ;\n getTypeOutputInfo ( exprType ( ( Node * ) iocoerce -> arg ) , & iofunc , & typisvarlena ) ;\n fmgr_info ( iofunc , & iostate -> outfunc ) ;\n state = ( ExprState * ) iostate ;\n }\n break ;\n case T_ArrayCoerceExpr : {\n ArrayCoerceExpr * acoerce = ( ArrayCoerceExpr * ) node ;\n ArrayCoerceExprState * astate = makeNode ( ArrayCoerceExprState ) ;\n astate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalArrayCoerceExpr ;\n astate -> arg = ExecInitExpr ( acoerce -> arg , parent ) ;\n astate -> resultelemtype = get_element_type ( acoerce -> resulttype ) ;\n if ( astate -> resultelemtype == InvalidOid ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_PARAMETER_VALUE ) , errmsg ( \"target type is not an array\" ) ) ) ;\n Assert ( getBaseType ( astate -> resultelemtype ) == astate -> resultelemtype ) ;\n astate -> elemfunc . fn_oid = InvalidOid ;\n astate -> amstate = ( ArrayMapState * ) palloc0 ( sizeof ( ArrayMapState ) ) ;\n state = ( ExprState * ) astate ;\n }\n break ;\n case T_ConvertRowtypeExpr : {\n ConvertRowtypeExpr * convert = ( ConvertRowtypeExpr * ) node ;\n ConvertRowtypeExprState * cstate = makeNode ( ConvertRowtypeExprState ) ;\n cstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalConvertRowtype ;\n cstate -> arg = ExecInitExpr ( convert -> arg , parent ) ;\n state = ( ExprState * ) cstate ;\n }\n break ;\n case T_CaseExpr : {\n CaseExpr * caseexpr = ( CaseExpr * ) node ;\n CaseExprState * cstate = makeNode ( CaseExprState ) ;\n List * outlist = NIL ;\n ListCell * l ;\n cstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalCase ;\n cstate -> arg = ExecInitExpr ( caseexpr -> arg , parent ) ;\n foreach ( l , caseexpr -> args ) {\n CaseWhen * when = ( CaseWhen * ) lfirst ( l ) ;\n CaseWhenState * wstate = makeNode ( CaseWhenState ) ;\n Assert ( IsA ( when , CaseWhen ) ) ;\n wstate -> xprstate . evalfunc = NULL ;\n wstate -> xprstate . expr = ( Expr * ) when ;\n wstate -> expr = ExecInitExpr ( when -> expr , parent ) ;\n wstate -> result = ExecInitExpr ( when -> result , parent ) ;\n outlist = lappend ( outlist , wstate ) ;\n }\n cstate -> args = outlist ;\n cstate -> defresult = ExecInitExpr ( caseexpr -> defresult , parent ) ;\n state = ( ExprState * ) cstate ;\n }\n break ;\n case T_ArrayExpr : {\n ArrayExpr * arrayexpr = ( ArrayExpr * ) node ;\n ArrayExprState * astate = makeNode ( ArrayExprState ) ;\n List * outlist = NIL ;\n ListCell * l ;\n astate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalArray ;\n foreach ( l , arrayexpr -> elements ) {\n Expr * e = ( Expr * ) lfirst ( l ) ;\n ExprState * estate ;\n estate = ExecInitExpr ( e , parent ) ;\n outlist = lappend ( outlist , estate ) ;\n }\n astate -> elements = outlist ;\n get_typlenbyvalalign ( arrayexpr -> element_typeid , & astate -> elemlength , & astate -> elembyval , & astate -> elemalign ) ;\n state = ( ExprState * ) astate ;\n }\n break ;\n case T_RowExpr : {\n RowExpr * rowexpr = ( RowExpr * ) node ;\n RowExprState * rstate = makeNode ( RowExprState ) ;\n Form_pg_attribute * attrs ;\n List * outlist = NIL ;\n ListCell * l ;\n int i ;\n rstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalRow ;\n if ( rowexpr -> row_typeid == RECORDOID ) {\n rstate -> tupdesc = ExecTypeFromExprList ( rowexpr -> args ) ;\n }\n else {\n rstate -> tupdesc = lookup_rowtype_tupdesc_copy ( rowexpr -> row_typeid , - 1 ) ;\n }\n ExecTypeSetColNames ( rstate -> tupdesc , rowexpr -> colnames ) ;\n BlessTupleDesc ( rstate -> tupdesc ) ;\n Assert ( list_length ( rowexpr -> args ) <= rstate -> tupdesc -> natts ) ;\n attrs = rstate -> tupdesc -> attrs ;\n i = 0 ;\n foreach ( l , rowexpr -> args ) {\n Expr * e = ( Expr * ) lfirst ( l ) ;\n ExprState * estate ;\n if ( ! attrs [ i ] -> attisdropped ) {\n if ( exprType ( ( Node * ) e ) != attrs [ i ] -> atttypid ) ereport ( ERROR , ( errcode ( ERRCODE_DATATYPE_MISMATCH ) , errmsg ( \"ROW() column has type %s instead of type %s\" , format_type_be ( exprType ( ( Node * ) e ) ) , format_type_be ( attrs [ i ] -> atttypid ) ) ) ) ;\n }\n else {\n e = ( Expr * ) makeNullConst ( INT4OID , - 1 , InvalidOid ) ;\n }\n estate = ExecInitExpr ( e , parent ) ;\n outlist = lappend ( outlist , estate ) ;\n i ++ ;\n }\n rstate -> args = outlist ;\n state = ( ExprState * ) rstate ;\n }\n break ;\n case T_RowCompareExpr : {\n RowCompareExpr * rcexpr = ( RowCompareExpr * ) node ;\n RowCompareExprState * rstate = makeNode ( RowCompareExprState ) ;\n int nopers = list_length ( rcexpr -> opnos ) ;\n List * outlist ;\n ListCell * l ;\n ListCell * l2 ;\n ListCell * l3 ;\n int i ;\n rstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalRowCompare ;\n Assert ( list_length ( rcexpr -> largs ) == nopers ) ;\n outlist = NIL ;\n foreach ( l , rcexpr -> largs ) {\n Expr * e = ( Expr * ) lfirst ( l ) ;\n ExprState * estate ;\n estate = ExecInitExpr ( e , parent ) ;\n outlist = lappend ( outlist , estate ) ;\n }\n rstate -> largs = outlist ;\n Assert ( list_length ( rcexpr -> rargs ) == nopers ) ;\n outlist = NIL ;\n foreach ( l , rcexpr -> rargs ) {\n Expr * e = ( Expr * ) lfirst ( l ) ;\n ExprState * estate ;\n estate = ExecInitExpr ( e , parent ) ;\n outlist = lappend ( outlist , estate ) ;\n }\n rstate -> rargs = outlist ;\n Assert ( list_length ( rcexpr -> opfamilies ) == nopers ) ;\n rstate -> funcs = ( FmgrInfo * ) palloc ( nopers * sizeof ( FmgrInfo ) ) ;\n rstate -> collations = ( Oid * ) palloc ( nopers * sizeof ( Oid ) ) ;\n i = 0 ;\n forthree ( l , rcexpr -> opnos , l2 , rcexpr -> opfamilies , l3 , rcexpr -> inputcollids ) {\n Oid opno = lfirst_oid ( l ) ;\n Oid opfamily = lfirst_oid ( l2 ) ;\n Oid inputcollid = lfirst_oid ( l3 ) ;\n int strategy ;\n Oid lefttype ;\n Oid righttype ;\n Oid proc ;\n get_op_opfamily_properties ( opno , opfamily , false , & strategy , & lefttype , & righttype ) ;\n proc = get_opfamily_proc ( opfamily , lefttype , righttype , BTORDER_PROC ) ;\n fmgr_info ( proc , & ( rstate -> funcs [ i ] ) ) ;\n rstate -> collations [ i ] = inputcollid ;\n i ++ ;\n }\n state = ( ExprState * ) rstate ;\n }\n break ;\n case T_CoalesceExpr : {\n CoalesceExpr * coalesceexpr = ( CoalesceExpr * ) node ;\n CoalesceExprState * cstate = makeNode ( CoalesceExprState ) ;\n List * outlist = NIL ;\n ListCell * l ;\n cstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalCoalesce ;\n foreach ( l , coalesceexpr -> args ) {\n Expr * e = ( Expr * ) lfirst ( l ) ;\n ExprState * estate ;\n estate = ExecInitExpr ( e , parent ) ;\n outlist = lappend ( outlist , estate ) ;\n }\n cstate -> args = outlist ;\n state = ( ExprState * ) cstate ;\n }\n break ;\n case T_MinMaxExpr : {\n MinMaxExpr * minmaxexpr = ( MinMaxExpr * ) node ;\n MinMaxExprState * mstate = makeNode ( MinMaxExprState ) ;\n List * outlist = NIL ;\n ListCell * l ;\n TypeCacheEntry * typentry ;\n mstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalMinMax ;\n foreach ( l , minmaxexpr -> args ) {\n Expr * e = ( Expr * ) lfirst ( l ) ;\n ExprState * estate ;\n estate = ExecInitExpr ( e , parent ) ;\n outlist = lappend ( outlist , estate ) ;\n }\n mstate -> args = outlist ;\n typentry = lookup_type_cache ( minmaxexpr -> minmaxtype , TYPECACHE_CMP_PROC ) ;\n if ( ! OidIsValid ( typentry -> cmp_proc ) ) ereport ( ERROR , ( errcode ( ERRCODE_UNDEFINED_FUNCTION ) , errmsg ( \"could not identify a comparison function for type %s\" , format_type_be ( minmaxexpr -> minmaxtype ) ) ) ) ;\n fmgr_info ( typentry -> cmp_proc , & ( mstate -> cfunc ) ) ;\n state = ( ExprState * ) mstate ;\n }\n break ;\n case T_XmlExpr : {\n XmlExpr * xexpr = ( XmlExpr * ) node ;\n XmlExprState * xstate = makeNode ( XmlExprState ) ;\n List * outlist ;\n ListCell * arg ;\n xstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalXml ;\n outlist = NIL ;\n foreach ( arg , xexpr -> named_args ) {\n Expr * e = ( Expr * ) lfirst ( arg ) ;\n ExprState * estate ;\n estate = ExecInitExpr ( e , parent ) ;\n outlist = lappend ( outlist , estate ) ;\n }\n xstate -> named_args = outlist ;\n outlist = NIL ;\n foreach ( arg , xexpr -> args ) {\n Expr * e = ( Expr * ) lfirst ( arg ) ;\n ExprState * estate ;\n estate = ExecInitExpr ( e , parent ) ;\n outlist = lappend ( outlist , estate ) ;\n }\n xstate -> args = outlist ;\n state = ( ExprState * ) xstate ;\n }\n break ;\n case T_NullTest : {\n NullTest * ntest = ( NullTest * ) node ;\n NullTestState * nstate = makeNode ( NullTestState ) ;\n nstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalNullTest ;\n nstate -> arg = ExecInitExpr ( ntest -> arg , parent ) ;\n nstate -> argdesc = NULL ;\n state = ( ExprState * ) nstate ;\n }\n break ;\n case T_BooleanTest : {\n BooleanTest * btest = ( BooleanTest * ) node ;\n GenericExprState * gstate = makeNode ( GenericExprState ) ;\n gstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalBooleanTest ;\n gstate -> arg = ExecInitExpr ( btest -> arg , parent ) ;\n state = ( ExprState * ) gstate ;\n }\n break ;\n case T_CoerceToDomain : {\n CoerceToDomain * ctest = ( CoerceToDomain * ) node ;\n CoerceToDomainState * cstate = makeNode ( CoerceToDomainState ) ;\n cstate -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecEvalCoerceToDomain ;\n cstate -> arg = ExecInitExpr ( ctest -> arg , parent ) ;\n cstate -> constraint_ref = ( DomainConstraintRef * ) palloc ( sizeof ( DomainConstraintRef ) ) ;\n InitDomainConstraintRef ( ctest -> resulttype , cstate -> constraint_ref , CurrentMemoryContext ) ;\n state = ( ExprState * ) cstate ;\n }\n break ;\n case T_CurrentOfExpr : state = ( ExprState * ) makeNode ( ExprState ) ;\n state -> evalfunc = ExecEvalCurrentOfExpr ;\n break ;\n case T_TargetEntry : {\n TargetEntry * tle = ( TargetEntry * ) node ;\n GenericExprState * gstate = makeNode ( GenericExprState ) ;\n gstate -> xprstate . evalfunc = NULL ;\n gstate -> arg = ExecInitExpr ( tle -> expr , parent ) ;\n state = ( ExprState * ) gstate ;\n }\n break ;\n case T_List : {\n List * outlist = NIL ;\n ListCell * l ;\n foreach ( l , ( List * ) node ) {\n outlist = lappend ( outlist , ExecInitExpr ( ( Expr * ) lfirst ( l ) , parent ) ) ;\n }\n return ( ExprState * ) outlist ;\n }\n default : elog ( ERROR , \"unrecognized node type: %d\" , ( int ) nodeTag ( node ) ) ;\n state = NULL ;\n break ;\n }\n state -> expr = node ;\n return state ;\n }", "hash": 6458694302493204858, "project": "debian", "size": 477, "target": 0, "idx": 11297}
{"code": "static Datum ExecEvalWholeRowSlow ( WholeRowVarExprState * wrvstate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n Var * variable = ( Var * ) wrvstate -> xprstate . expr ;\n TupleTableSlot * slot ;\n HeapTuple tuple ;\n TupleDesc tupleDesc ;\n TupleDesc var_tupdesc ;\n HeapTupleHeader dtuple ;\n int i ;\n if ( isDone ) * isDone = ExprSingleResult ;\n * isNull = false ;\n switch ( variable -> varno ) {\n case INNER_VAR : slot = econtext -> ecxt_innertuple ;\n break ;\n case OUTER_VAR : slot = econtext -> ecxt_outertuple ;\n break ;\n default : slot = econtext -> ecxt_scantuple ;\n break ;\n }\n if ( wrvstate -> wrv_junkFilter != NULL ) slot = ExecFilterJunk ( wrvstate -> wrv_junkFilter , slot ) ;\n tuple = ExecFetchSlotTuple ( slot ) ;\n tupleDesc = slot -> tts_tupleDescriptor ;\n Assert ( variable -> vartype != RECORDOID ) ;\n var_tupdesc = wrvstate -> wrv_tupdesc ;\n for ( i = 0 ;\n i < var_tupdesc -> natts ;\n i ++ ) {\n Form_pg_attribute vattr = var_tupdesc -> attrs [ i ] ;\n Form_pg_attribute sattr = tupleDesc -> attrs [ i ] ;\n if ( ! vattr -> attisdropped ) continue ;\n if ( heap_attisnull ( tuple , i + 1 ) ) continue ;\n if ( vattr -> attlen != sattr -> attlen || vattr -> attalign != sattr -> attalign ) ereport ( ERROR , ( errcode ( ERRCODE_DATATYPE_MISMATCH ) , errmsg ( \"table row type and query-specified row type do not match\" ) , errdetail ( \"Physical storage mismatch on dropped attribute at ordinal position %d.\" , i + 1 ) ) ) ;\n }\n dtuple = DatumGetHeapTupleHeader ( ExecFetchSlotTupleDatum ( slot ) ) ;\n HeapTupleHeaderSetTypeId ( dtuple , wrvstate -> wrv_tupdesc -> tdtypeid ) ;\n HeapTupleHeaderSetTypMod ( dtuple , wrvstate -> wrv_tupdesc -> tdtypmod ) ;\n return PointerGetDatum ( dtuple ) ;\n }", "hash": 6458694302493204858, "project": "debian", "size": 37, "target": 0, "idx": 11301}
{"code": "ExprState * ExecPrepareExpr ( Expr * node , EState * estate ) {\n ExprState * result ;\n MemoryContext oldcontext ;\n oldcontext = MemoryContextSwitchTo ( estate -> es_query_cxt ) ;\n node = expression_planner ( node ) ;\n result = ExecInitExpr ( node , NULL ) ;\n MemoryContextSwitchTo ( oldcontext ) ;\n return result ;\n }", "hash": 6458694302493204858, "project": "debian", "size": 9, "target": 0, "idx": 11302}
{"code": "int ExecCleanTargetListLength ( List * targetlist ) {\n int len = 0 ;\n ListCell * tl ;\n foreach ( tl , targetlist ) {\n TargetEntry * curTle = ( TargetEntry * ) lfirst ( tl ) ;\n Assert ( IsA ( curTle , TargetEntry ) ) ;\n if ( ! curTle -> resjunk ) len ++ ;\n }\n return len ;\n }", "hash": 6458694302493204858, "project": "debian", "size": 10, "target": 0, "idx": 11308}
{"code": "static Datum ExecEvalArray ( ArrayExprState * astate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n ArrayExpr * arrayExpr = ( ArrayExpr * ) astate -> xprstate . expr ;\n ArrayType * result ;\n ListCell * element ;\n Oid element_type = arrayExpr -> element_typeid ;\n int ndims = 0 ;\n int dims [ MAXDIM ] ;\n int lbs [ MAXDIM ] ;\n * isNull = false ;\n if ( isDone ) * isDone = ExprSingleResult ;\n if ( ! arrayExpr -> multidims ) {\n int nelems ;\n Datum * dvalues ;\n bool * dnulls ;\n int i = 0 ;\n ndims = 1 ;\n nelems = list_length ( astate -> elements ) ;\n if ( nelems == 0 ) return PointerGetDatum ( construct_empty_array ( element_type ) ) ;\n dvalues = ( Datum * ) palloc ( nelems * sizeof ( Datum ) ) ;\n dnulls = ( bool * ) palloc ( nelems * sizeof ( bool ) ) ;\n foreach ( element , astate -> elements ) {\n ExprState * e = ( ExprState * ) lfirst ( element ) ;\n dvalues [ i ] = ExecEvalExpr ( e , econtext , & dnulls [ i ] , NULL ) ;\n i ++ ;\n }\n dims [ 0 ] = nelems ;\n lbs [ 0 ] = 1 ;\n result = construct_md_array ( dvalues , dnulls , ndims , dims , lbs , element_type , astate -> elemlength , astate -> elembyval , astate -> elemalign ) ;\n }\n else {\n int nbytes = 0 ;\n int nitems = 0 ;\n int outer_nelems = 0 ;\n int elem_ndims = 0 ;\n int * elem_dims = NULL ;\n int * elem_lbs = NULL ;\n bool firstone = true ;\n bool havenulls = false ;\n bool haveempty = false ;\n char * * subdata ;\n bits8 * * subbitmaps ;\n int * subbytes ;\n int * subnitems ;\n int i ;\n int32 dataoffset ;\n char * dat ;\n int iitem ;\n i = list_length ( astate -> elements ) ;\n subdata = ( char * * ) palloc ( i * sizeof ( char * ) ) ;\n subbitmaps = ( bits8 * * ) palloc ( i * sizeof ( bits8 * ) ) ;\n subbytes = ( int * ) palloc ( i * sizeof ( int ) ) ;\n subnitems = ( int * ) palloc ( i * sizeof ( int ) ) ;\n foreach ( element , astate -> elements ) {\n ExprState * e = ( ExprState * ) lfirst ( element ) ;\n bool eisnull ;\n Datum arraydatum ;\n ArrayType * array ;\n int this_ndims ;\n arraydatum = ExecEvalExpr ( e , econtext , & eisnull , NULL ) ;\n if ( eisnull ) {\n haveempty = true ;\n continue ;\n }\n array = DatumGetArrayTypeP ( arraydatum ) ;\n if ( element_type != ARR_ELEMTYPE ( array ) ) ereport ( ERROR , ( errcode ( ERRCODE_DATATYPE_MISMATCH ) , errmsg ( \"cannot merge incompatible arrays\" ) , errdetail ( \"Array with element type %s cannot be \" \"included in ARRAY construct with element type %s.\" , format_type_be ( ARR_ELEMTYPE ( array ) ) , format_type_be ( element_type ) ) ) ) ;\n this_ndims = ARR_NDIM ( array ) ;\n if ( this_ndims <= 0 ) {\n haveempty = true ;\n continue ;\n }\n if ( firstone ) {\n elem_ndims = this_ndims ;\n ndims = elem_ndims + 1 ;\n if ( ndims <= 0 || ndims > MAXDIM ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( \"number of array dimensions (%d) exceeds \" \\ \"the maximum allowed (%d)\" , ndims , MAXDIM ) ) ) ;\n elem_dims = ( int * ) palloc ( elem_ndims * sizeof ( int ) ) ;\n memcpy ( elem_dims , ARR_DIMS ( array ) , elem_ndims * sizeof ( int ) ) ;\n elem_lbs = ( int * ) palloc ( elem_ndims * sizeof ( int ) ) ;\n memcpy ( elem_lbs , ARR_LBOUND ( array ) , elem_ndims * sizeof ( int ) ) ;\n firstone = false ;\n }\n else {\n if ( elem_ndims != this_ndims || memcmp ( elem_dims , ARR_DIMS ( array ) , elem_ndims * sizeof ( int ) ) != 0 || memcmp ( elem_lbs , ARR_LBOUND ( array ) , elem_ndims * sizeof ( int ) ) != 0 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( \"multidimensional arrays must have array \" \"expressions with matching dimensions\" ) ) ) ;\n }\n subdata [ outer_nelems ] = ARR_DATA_PTR ( array ) ;\n subbitmaps [ outer_nelems ] = ARR_NULLBITMAP ( array ) ;\n subbytes [ outer_nelems ] = ARR_SIZE ( array ) - ARR_DATA_OFFSET ( array ) ;\n nbytes += subbytes [ outer_nelems ] ;\n subnitems [ outer_nelems ] = ArrayGetNItems ( this_ndims , ARR_DIMS ( array ) ) ;\n nitems += subnitems [ outer_nelems ] ;\n havenulls |= ARR_HASNULL ( array ) ;\n outer_nelems ++ ;\n }\n if ( haveempty ) {\n if ( ndims == 0 ) return PointerGetDatum ( construct_empty_array ( element_type ) ) ;\n ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( \"multidimensional arrays must have array \" \"expressions with matching dimensions\" ) ) ) ;\n }\n dims [ 0 ] = outer_nelems ;\n lbs [ 0 ] = 1 ;\n for ( i = 1 ;\n i < ndims ;\n i ++ ) {\n dims [ i ] = elem_dims [ i - 1 ] ;\n lbs [ i ] = elem_lbs [ i - 1 ] ;\n }\n if ( havenulls ) {\n dataoffset = ARR_OVERHEAD_WITHNULLS ( ndims , nitems ) ;\n nbytes += dataoffset ;\n }\n else {\n dataoffset = 0 ;\n nbytes += ARR_OVERHEAD_NONULLS ( ndims ) ;\n }\n result = ( ArrayType * ) palloc ( nbytes ) ;\n SET_VARSIZE ( result , nbytes ) ;\n result -> ndim = ndims ;\n result -> dataoffset = dataoffset ;\n result -> elemtype = element_type ;\n memcpy ( ARR_DIMS ( result ) , dims , ndims * sizeof ( int ) ) ;\n memcpy ( ARR_LBOUND ( result ) , lbs , ndims * sizeof ( int ) ) ;\n dat = ARR_DATA_PTR ( result ) ;\n iitem = 0 ;\n for ( i = 0 ;\n i < outer_nelems ;\n i ++ ) {\n memcpy ( dat , subdata [ i ] , subbytes [ i ] ) ;\n dat += subbytes [ i ] ;\n if ( havenulls ) array_bitmap_copy ( ARR_NULLBITMAP ( result ) , iitem , subbitmaps [ i ] , 0 , subnitems [ i ] ) ;\n iitem += subnitems [ i ] ;\n }\n }\n return PointerGetDatum ( result ) ;\n }", "hash": 6458694302493204858, "project": "debian", "size": 132, "target": 0, "idx": 11321}
{"code": "static void init_fcache ( Oid foid , Oid input_collation , FuncExprState * fcache , MemoryContext fcacheCxt , bool needDescForSets ) {\n AclResult aclresult ;\n aclresult = pg_proc_aclcheck ( foid , GetUserId ( ) , ACL_EXECUTE ) ;\n if ( aclresult != ACLCHECK_OK ) aclcheck_error ( aclresult , ACL_KIND_PROC , get_func_name ( foid ) ) ;\n InvokeFunctionExecuteHook ( foid ) ;\n if ( list_length ( fcache -> args ) > FUNC_MAX_ARGS ) ereport ( ERROR , ( errcode ( ERRCODE_TOO_MANY_ARGUMENTS ) , errmsg_plural ( \"cannot pass more than %d argument to a function\" , \"cannot pass more than %d arguments to a function\" , FUNC_MAX_ARGS , FUNC_MAX_ARGS ) ) ) ;\n fmgr_info_cxt ( foid , & ( fcache -> func ) , fcacheCxt ) ;\n fmgr_info_set_expr ( ( Node * ) fcache -> xprstate . expr , & ( fcache -> func ) ) ;\n InitFunctionCallInfoData ( fcache -> fcinfo_data , & ( fcache -> func ) , list_length ( fcache -> args ) , input_collation , NULL , NULL ) ;\n if ( fcache -> func . fn_retset && needDescForSets ) {\n TypeFuncClass functypclass ;\n Oid funcrettype ;\n TupleDesc tupdesc ;\n MemoryContext oldcontext ;\n functypclass = get_expr_result_type ( fcache -> func . fn_expr , & funcrettype , & tupdesc ) ;\n oldcontext = MemoryContextSwitchTo ( fcacheCxt ) ;\n if ( functypclass == TYPEFUNC_COMPOSITE ) {\n Assert ( tupdesc ) ;\n fcache -> funcResultDesc = CreateTupleDescCopy ( tupdesc ) ;\n fcache -> funcReturnsTuple = true ;\n }\n else if ( functypclass == TYPEFUNC_SCALAR ) {\n tupdesc = CreateTemplateTupleDesc ( 1 , false ) ;\n TupleDescInitEntry ( tupdesc , ( AttrNumber ) 1 , NULL , funcrettype , - 1 , 0 ) ;\n fcache -> funcResultDesc = tupdesc ;\n fcache -> funcReturnsTuple = false ;\n }\n else if ( functypclass == TYPEFUNC_RECORD ) {\n fcache -> funcResultDesc = NULL ;\n fcache -> funcReturnsTuple = true ;\n }\n else {\n fcache -> funcResultDesc = NULL ;\n }\n MemoryContextSwitchTo ( oldcontext ) ;\n }\n else fcache -> funcResultDesc = NULL ;\n fcache -> funcResultStore = NULL ;\n fcache -> funcResultSlot = NULL ;\n fcache -> setArgsValid = false ;\n fcache -> shutdown_reg = false ;\n }", "hash": 6458694302493204858, "project": "debian", "size": 42, "target": 0, "idx": 11328}
{"code": "static Datum ExecEvalScalarVar ( ExprState * exprstate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n Var * variable = ( Var * ) exprstate -> expr ;\n TupleTableSlot * slot ;\n AttrNumber attnum ;\n if ( isDone ) * isDone = ExprSingleResult ;\n switch ( variable -> varno ) {\n case INNER_VAR : slot = econtext -> ecxt_innertuple ;\n break ;\n case OUTER_VAR : slot = econtext -> ecxt_outertuple ;\n break ;\n default : slot = econtext -> ecxt_scantuple ;\n break ;\n }\n attnum = variable -> varattno ;\n Assert ( attnum != InvalidAttrNumber ) ;\n if ( attnum > 0 ) {\n TupleDesc slot_tupdesc = slot -> tts_tupleDescriptor ;\n Form_pg_attribute attr ;\n if ( attnum > slot_tupdesc -> natts ) elog ( ERROR , \"attribute number %d exceeds number of columns %d\" , attnum , slot_tupdesc -> natts ) ;\n attr = slot_tupdesc -> attrs [ attnum - 1 ] ;\n if ( ! attr -> attisdropped ) {\n if ( variable -> vartype != attr -> atttypid ) ereport ( ERROR , ( errcode ( ERRCODE_DATATYPE_MISMATCH ) , errmsg ( \"attribute %d has wrong type\" , attnum ) , errdetail ( \"Table has type %s, but query expects %s.\" , format_type_be ( attr -> atttypid ) , format_type_be ( variable -> vartype ) ) ) ) ;\n }\n }\n exprstate -> evalfunc = ExecEvalScalarVarFast ;\n return slot_getattr ( slot , attnum , isNull ) ;\n }", "hash": 6458694302493204858, "project": "debian", "size": 27, "target": 0, "idx": 11332}
{"code": "int qemuAgentGetVCPUs ( qemuAgentPtr mon , qemuAgentCPUInfoPtr * info ) {\n int ret = - 1 ;\n size_t i ;\n virJSONValuePtr cmd ;\n virJSONValuePtr reply = NULL ;\n virJSONValuePtr data = NULL ;\n ssize_t ndata ;\n if ( ! ( cmd = qemuAgentMakeCommand ( \"guest-get-vcpus\" , NULL ) ) ) return - 1 ;\n if ( qemuAgentCommand ( mon , cmd , & reply , true , VIR_DOMAIN_QEMU_AGENT_COMMAND_BLOCK ) < 0 ) goto cleanup ;\n if ( ! ( data = virJSONValueObjectGet ( reply , \"return\" ) ) ) {\n virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"guest-get-vcpus reply was missing return data\" ) ) ;\n goto cleanup ;\n }\n if ( data -> type != VIR_JSON_TYPE_ARRAY ) {\n virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"guest-get-vcpus return information was not an array\" ) ) ;\n goto cleanup ;\n }\n ndata = virJSONValueArraySize ( data ) ;\n if ( VIR_ALLOC_N ( * info , ndata ) < 0 ) goto cleanup ;\n for ( i = 0 ;\n i < ndata ;\n i ++ ) {\n virJSONValuePtr entry = virJSONValueArrayGet ( data , i ) ;\n qemuAgentCPUInfoPtr in = * info + i ;\n if ( ! entry ) {\n virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"array element missing in guest-get-vcpus return \" \"value\" ) ) ;\n goto cleanup ;\n }\n if ( virJSONValueObjectGetNumberUint ( entry , \"logical-id\" , & in -> id ) < 0 ) {\n virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"'logical-id' missing in reply of guest-get-vcpus\" ) ) ;\n goto cleanup ;\n }\n if ( virJSONValueObjectGetBoolean ( entry , \"online\" , & in -> online ) < 0 ) {\n virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"'online' missing in reply of guest-get-vcpus\" ) ) ;\n goto cleanup ;\n }\n if ( virJSONValueObjectGetBoolean ( entry , \"can-offline\" , & in -> offlinable ) < 0 ) {\n virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"'can-offline' missing in reply of guest-get-vcpus\" ) ) ;\n goto cleanup ;\n }\n }\n ret = ndata ;\n cleanup : virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "hash": -3299391226809811274, "project": "debian", "size": 46, "target": 0, "idx": 11362}
{"code": "static int qemuAgentSend ( qemuAgentPtr mon , qemuAgentMessagePtr msg , int seconds ) {\n int ret = - 1 ;\n unsigned long long then = 0 ;\n if ( mon -> lastError . code != VIR_ERR_OK ) {\n VIR_DEBUG ( \"Attempt to send command while error is set %s\" , NULLSTR ( mon -> lastError . message ) ) ;\n virSetError ( & mon -> lastError ) ;\n return - 1 ;\n }\n if ( seconds > VIR_DOMAIN_QEMU_AGENT_COMMAND_BLOCK ) {\n unsigned long long now ;\n if ( virTimeMillisNow ( & now ) < 0 ) return - 1 ;\n if ( seconds == VIR_DOMAIN_QEMU_AGENT_COMMAND_DEFAULT ) seconds = QEMU_AGENT_WAIT_TIME ;\n then = now + seconds * 1000ull ;\n }\n mon -> msg = msg ;\n qemuAgentUpdateWatch ( mon ) ;\n while ( ! mon -> msg -> finished ) {\n if ( ( then && virCondWaitUntil ( & mon -> notify , & mon -> parent . lock , then ) < 0 ) || ( ! then && virCondWait ( & mon -> notify , & mon -> parent . lock ) < 0 ) ) {\n if ( errno == ETIMEDOUT ) {\n virReportError ( VIR_ERR_AGENT_UNRESPONSIVE , \"%s\" , _ ( \"Guest agent not available for now\" ) ) ;\n ret = - 2 ;\n }\n else {\n virReportSystemError ( errno , \"%s\" , _ ( \"Unable to wait on agent monitor \" \"condition\" ) ) ;\n }\n goto cleanup ;\n }\n }\n if ( mon -> lastError . code != VIR_ERR_OK ) {\n VIR_DEBUG ( \"Send command resulted in error %s\" , NULLSTR ( mon -> lastError . message ) ) ;\n virSetError ( & mon -> lastError ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : mon -> msg = NULL ;\n qemuAgentUpdateWatch ( mon ) ;\n return ret ;\n }", "hash": -3299391226809811274, "project": "debian", "size": 38, "target": 0, "idx": 11364}
{"code": "int qemuAgentSuspend ( qemuAgentPtr mon , unsigned int target ) {\n int ret = - 1 ;\n virJSONValuePtr cmd ;\n virJSONValuePtr reply = NULL ;\n cmd = qemuAgentMakeCommand ( qemuAgentSuspendModeTypeToString ( target ) , NULL ) ;\n if ( ! cmd ) return - 1 ;\n mon -> await_event = QEMU_AGENT_EVENT_SUSPEND ;\n ret = qemuAgentCommand ( mon , cmd , & reply , false , VIR_DOMAIN_QEMU_AGENT_COMMAND_BLOCK ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "hash": -3299391226809811274, "project": "debian", "size": 12, "target": 0, "idx": 11377}
{"code": "int qemuAgentFSTrim ( qemuAgentPtr mon , unsigned long long minimum ) {\n int ret = - 1 ;\n virJSONValuePtr cmd ;\n virJSONValuePtr reply = NULL ;\n cmd = qemuAgentMakeCommand ( \"guest-fstrim\" , \"U:minimum\" , minimum , NULL ) ;\n if ( ! cmd ) return ret ;\n ret = qemuAgentCommand ( mon , cmd , & reply , false , VIR_DOMAIN_QEMU_AGENT_COMMAND_BLOCK ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }", "hash": -3299391226809811274, "project": "debian", "size": 11, "target": 0, "idx": 11379}
{"code": "static int qemuAgentGuestSync ( qemuAgentPtr mon ) {\n int ret = - 1 ;\n int send_ret ;\n unsigned long long id ;\n qemuAgentMessage sync_msg ;\n memset ( & sync_msg , 0 , sizeof ( sync_msg ) ) ;\n sync_msg . first = true ;\n retry : if ( virTimeMillisNow ( & id ) < 0 ) return - 1 ;\n if ( virAsprintf ( & sync_msg . txBuffer , \"{\n\\\"execute\\\":\\\"guest-sync\\\", \" \"\\\"arguments\\\":{\n\\\"id\\\":%llu}\n}\n\\n\" , id ) < 0 ) return - 1 ;\n sync_msg . txLength = strlen ( sync_msg . txBuffer ) ;\n sync_msg . sync = true ;\n sync_msg . id = id ;\n VIR_DEBUG ( \"Sending guest-sync command with ID: %llu\" , id ) ;\n send_ret = qemuAgentSend ( mon , & sync_msg , VIR_DOMAIN_QEMU_AGENT_COMMAND_DEFAULT ) ;\n VIR_DEBUG ( \"qemuAgentSend returned: %d\" , send_ret ) ;\n if ( send_ret < 0 ) goto cleanup ;\n if ( ! sync_msg . rxObject ) {\n if ( sync_msg . first ) {\n VIR_FREE ( sync_msg . txBuffer ) ;\n memset ( & sync_msg , 0 , sizeof ( sync_msg ) ) ;\n goto retry ;\n }\n else {\n if ( mon -> running ) virReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"Missing monitor reply object\" ) ) ;\n else virReportError ( VIR_ERR_AGENT_UNRESPONSIVE , \"%s\" , _ ( \"Guest agent disappeared while executing command\" ) ) ;\n goto cleanup ;\n }\n }\n ret = 0 ;\n cleanup : virJSONValueFree ( sync_msg . rxObject ) ;\n VIR_FREE ( sync_msg . txBuffer ) ;\n return ret ;\n }", "hash": -3299391226809811274, "project": "debian", "size": 37, "target": 0, "idx": 11387}
{"code": "void key_type_put ( struct key_type * ktype ) {\n up_read ( & key_types_sem ) ;\n }", "hash": -1145838621747570454, "project": "debian", "size": 3, "target": 0, "idx": 11391}
{"code": "int key_reject_and_link ( struct key * key , unsigned timeout , unsigned error , struct key * keyring , struct key * authkey ) {\n struct assoc_array_edit * edit ;\n struct timespec now ;\n int ret , awaken , link_ret = 0 ;\n key_check ( key ) ;\n key_check ( keyring ) ;\n awaken = 0 ;\n ret = - EBUSY ;\n if ( keyring ) {\n if ( keyring -> restrict_link ) return - EPERM ;\n link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ;\n }\n mutex_lock ( & key_construction_mutex ) ;\n if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) {\n atomic_inc ( & key -> user -> nikeys ) ;\n key -> reject_error = - error ;\n smp_wmb ( ) ;\n set_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ;\n set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ;\n now = current_kernel_time ( ) ;\n key -> expiry = now . tv_sec + timeout ;\n key_schedule_gc ( key -> expiry + key_gc_delay ) ;\n if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ;\n ret = 0 ;\n if ( keyring && link_ret == 0 ) __key_link ( key , & edit ) ;\n if ( authkey ) key_revoke ( authkey ) ;\n }\n mutex_unlock ( & key_construction_mutex ) ;\n if ( keyring && link_ret == 0 ) __key_link_end ( keyring , & key -> index_key , edit ) ;\n if ( awaken ) wake_up_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT ) ;\n return ret == 0 ? link_ret : ret ;\n }", "hash": -1145838621747570454, "project": "debian", "size": 32, "target": 0, "idx": 11409}
{"code": "static int parsedate ( const char * date , time_t * output ) {\n time_t t = 0 ;\n int wdaynum = - 1 ;\n int monnum = - 1 ;\n int mdaynum = - 1 ;\n int hournum = - 1 ;\n int minnum = - 1 ;\n int secnum = - 1 ;\n int yearnum = - 1 ;\n int tzoff = - 1 ;\n struct my_tm tm ;\n enum assume dignext = DATE_MDAY ;\n const char * indate = date ;\n int part = 0 ;\n while ( * date && ( part < 6 ) ) {\n bool found = FALSE ;\n skip ( & date ) ;\n if ( ISALPHA ( * date ) ) {\n char buf [ 32 ] = \"\" ;\n size_t len ;\n if ( sscanf ( date , \"%31[ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"abcdefghijklmnopqrstuvwxyz]\" , buf ) ) len = strlen ( buf ) ;\n else len = 0 ;\n if ( wdaynum == - 1 ) {\n wdaynum = checkday ( buf , len ) ;\n if ( wdaynum != - 1 ) found = TRUE ;\n }\n if ( ! found && ( monnum == - 1 ) ) {\n monnum = checkmonth ( buf ) ;\n if ( monnum != - 1 ) found = TRUE ;\n }\n if ( ! found && ( tzoff == - 1 ) ) {\n tzoff = checktz ( buf ) ;\n if ( tzoff != - 1 ) found = TRUE ;\n }\n if ( ! found ) return PARSEDATE_FAIL ;\n date += len ;\n }\n else if ( ISDIGIT ( * date ) ) {\n int val ;\n char * end ;\n int len = 0 ;\n if ( ( secnum == - 1 ) && ( 3 == sscanf ( date , \"%02d:%02d:%02d%n\" , & hournum , & minnum , & secnum , & len ) ) ) {\n date += len ;\n }\n else if ( ( secnum == - 1 ) && ( 2 == sscanf ( date , \"%02d:%02d%n\" , & hournum , & minnum , & len ) ) ) {\n date += len ;\n secnum = 0 ;\n }\n else {\n long lval ;\n int error ;\n int old_errno ;\n old_errno = ERRNO ;\n SET_ERRNO ( 0 ) ;\n lval = strtol ( date , & end , 10 ) ;\n error = ERRNO ;\n if ( error != old_errno ) SET_ERRNO ( old_errno ) ;\n if ( error ) return PARSEDATE_FAIL ;\n # if LONG_MAX != INT_MAX if ( ( lval > ( long ) INT_MAX ) || ( lval < ( long ) INT_MIN ) ) return PARSEDATE_FAIL ;\n # endif val = curlx_sltosi ( lval ) ;\n if ( ( tzoff == - 1 ) && ( ( end - date ) == 4 ) && ( val <= 1400 ) && ( indate < date ) && ( ( date [ - 1 ] == '+' || date [ - 1 ] == '-' ) ) ) {\n found = TRUE ;\n tzoff = ( val / 100 * 60 + val % 100 ) * 60 ;\n tzoff = date [ - 1 ] == '+' ? - tzoff : tzoff ;\n }\n if ( ( ( end - date ) == 8 ) && ( yearnum == - 1 ) && ( monnum == - 1 ) && ( mdaynum == - 1 ) ) {\n found = TRUE ;\n yearnum = val / 10000 ;\n monnum = ( val % 10000 ) / 100 - 1 ;\n mdaynum = val % 100 ;\n }\n if ( ! found && ( dignext == DATE_MDAY ) && ( mdaynum == - 1 ) ) {\n if ( ( val > 0 ) && ( val < 32 ) ) {\n mdaynum = val ;\n found = TRUE ;\n }\n dignext = DATE_YEAR ;\n }\n if ( ! found && ( dignext == DATE_YEAR ) && ( yearnum == - 1 ) ) {\n yearnum = val ;\n found = TRUE ;\n if ( yearnum < 1900 ) {\n if ( yearnum > 70 ) yearnum += 1900 ;\n else yearnum += 2000 ;\n }\n if ( mdaynum == - 1 ) dignext = DATE_MDAY ;\n }\n if ( ! found ) return PARSEDATE_FAIL ;\n date = end ;\n }\n }\n part ++ ;\n }\n if ( - 1 == secnum ) secnum = minnum = hournum = 0 ;\n if ( ( - 1 == mdaynum ) || ( - 1 == monnum ) || ( - 1 == yearnum ) ) return PARSEDATE_FAIL ;\n # if SIZEOF_TIME_T < 5 if ( yearnum > 2037 ) {\n * output = 0x7fffffff ;\n return PARSEDATE_LATER ;\n }\n # endif if ( yearnum < 1970 ) {\n * output = 0 ;\n return PARSEDATE_SOONER ;\n }\n if ( ( mdaynum > 31 ) || ( monnum > 11 ) || ( hournum > 23 ) || ( minnum > 59 ) || ( secnum > 60 ) ) return PARSEDATE_FAIL ;\n tm . tm_sec = secnum ;\n tm . tm_min = minnum ;\n tm . tm_hour = hournum ;\n tm . tm_mday = mdaynum ;\n tm . tm_mon = monnum ;\n tm . tm_year = yearnum - 1900 ;\n t = my_timegm ( & tm ) ;\n if ( - 1 != ( int ) t ) {\n long delta = ( long ) ( tzoff != - 1 ? tzoff : 0 ) ;\n if ( ( delta > 0 ) && ( t > LONG_MAX - delta ) ) {\n * output = 0x7fffffff ;\n return PARSEDATE_LATER ;\n }\n t += delta ;\n }\n * output = t ;\n return PARSEDATE_OK ;\n }", "hash": -7256256713578558606, "project": "debian", "size": 122, "target": 0, "idx": 11428}
{"code": "static int http_server_session_sharing_cb ( const char * name , RecDataT dtype , RecData data , void * cookie ) {\n bool valid_p = true ;\n HttpConfigParams * c = static_cast < HttpConfigParams * > ( cookie ) ;\n if ( 0 == strcasecmp ( \"proxy.config.http.server_session_sharing.match\" , name ) ) {\n MgmtByte & match = c -> oride . server_session_sharing_match ;\n if ( RECD_INT == dtype ) {\n match = static_cast < TSServerSessionSharingMatchType > ( data . rec_int ) ;\n }\n else if ( RECD_STRING == dtype && http_config_enum_search ( data . rec_string , SessionSharingMatchStrings , match ) ) {\n }\n else {\n valid_p = false ;\n }\n }\n else {\n valid_p = false ;\n }\n if ( valid_p ) {\n http_config_cb ( name , dtype , data , cookie ) ;\n }\n return REC_ERR_OKAY ;\n }", "hash": -7646792761994281873, "project": "debian", "size": 22, "target": 0, "idx": 11439}
{"code": "static int ts_lua_http_timeout_set ( lua_State * L ) {\n int conf ;\n int value ;\n ts_lua_http_ctx * http_ctx ;\n GET_HTTP_CONTEXT ( http_ctx , L ) ;\n conf = luaL_checkinteger ( L , 1 ) ;\n value = luaL_checkinteger ( L , 2 ) ;\n switch ( conf ) {\n case TS_LUA_TIMEOUT_ACTIVE : TSDebug ( TS_LUA_DEBUG_TAG , \"setting active timeout\" ) ;\n TSHttpTxnActiveTimeoutSet ( http_ctx -> txnp , value ) ;\n break ;\n case TS_LUA_TIMEOUT_CONNECT : TSDebug ( TS_LUA_DEBUG_TAG , \"setting connect timeout\" ) ;\n TSHttpTxnConnectTimeoutSet ( http_ctx -> txnp , value ) ;\n break ;\n case TS_LUA_TIMEOUT_DNS : TSDebug ( TS_LUA_DEBUG_TAG , \"setting dns timeout\" ) ;\n TSHttpTxnDNSTimeoutSet ( http_ctx -> txnp , value ) ;\n break ;\n case TS_LUA_TIMEOUT_NO_ACTIVITY : TSDebug ( TS_LUA_DEBUG_TAG , \"setting no activity timeout\" ) ;\n TSHttpTxnNoActivityTimeoutSet ( http_ctx -> txnp , value ) ;\n break ;\n default : TSError ( \"[ts_lua] Unsupported timeout config option for lua plugin\" ) ;\n break ;\n }\n return 0 ;\n }", "hash": -8115807672627724050, "project": "debian", "size": 25, "target": 0, "idx": 11454}
{"code": "REGRESSION_TEST ( SDK_API_TSContSchedule ) ( RegressionTest * test , int , int * pstatus ) {\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n SDK_ContSchedule_test = test ;\n SDK_ContSchedule_pstatus = pstatus ;\n TSCont contp = TSContCreate ( cont_schedule_handler , TSMutexCreate ( ) ) ;\n TSCont contp2 = TSContCreate ( cont_schedule_handler , TSMutexCreate ( ) ) ;\n TSContSchedule ( contp , 0 , TS_THREAD_POOL_DEFAULT ) ;\n TSContSchedule ( contp2 , 10 , TS_THREAD_POOL_DEFAULT ) ;\n }", "hash": -866921002076081979, "project": "debian", "size": 9, "target": 0, "idx": 11457}
{"code": "static void * thread_create_handler ( void * ) {\n TSThread athread ;\n sleep ( 10 ) ;\n athread = TSThreadSelf ( ) ;\n if ( athread == nullptr ) {\n thread_err_count ++ ;\n SDK_RPRINT ( SDK_Thread_test , \"TSThreadCreate\" , \"TestCase2\" , TC_FAIL , \"can't get thread\" ) ;\n }\n else {\n SDK_RPRINT ( SDK_Thread_test , \"TSThreadCreate\" , \"TestCase2\" , TC_PASS , \"ok\" ) ;\n }\n if ( thread_err_count > 0 ) {\n * SDK_Thread_pstatus = REGRESSION_TEST_FAILED ;\n }\n else {\n * SDK_Thread_pstatus = REGRESSION_TEST_PASSED ;\n }\n return nullptr ;\n }", "hash": -866921002076081979, "project": "debian", "size": 19, "target": 0, "idx": 11487}
{"code": "static int checkHttpTxnClientReqGet ( SocketTest * test , void * data ) {\n TSMBuffer bufp ;\n TSMLoc mloc ;\n TSHttpTxn txnp = ( TSHttpTxn ) data ;\n if ( TSHttpTxnClientReqGet ( txnp , & bufp , & mloc ) != TS_SUCCESS ) {\n test -> test_client_req_get = false ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnClientReqGet\" , \"TestCase1\" , TC_FAIL , \"Unable to get handle to client request\" ) ;\n return TS_EVENT_CONTINUE ;\n }\n if ( ( bufp == reinterpret_cast < TSMBuffer > ( & ( ( HttpSM * ) txnp ) -> t_state . hdr_info . client_request ) ) && ( mloc == reinterpret_cast < TSMLoc > ( ( ( HttpSM * ) txnp ) -> t_state . hdr_info . client_request . m_http ) ) ) {\n test -> test_client_req_get = true ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnClientReqGet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n }\n else {\n test -> test_client_req_get = false ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnClientReqGet\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch\" ) ;\n }\n return TS_EVENT_CONTINUE ;\n }", "hash": -866921002076081979, "project": "debian", "size": 19, "target": 0, "idx": 11493}
{"code": "static int checkHttpTxnServerReqGet ( SocketTest * test , void * data ) {\n TSMBuffer bufp ;\n TSMLoc mloc ;\n TSHttpTxn txnp = ( TSHttpTxn ) data ;\n if ( TSHttpTxnServerReqGet ( txnp , & bufp , & mloc ) != TS_SUCCESS ) {\n test -> test_server_req_get = false ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnServerReqGet\" , \"TestCase1\" , TC_FAIL , \"Unable to get handle to server request\" ) ;\n return TS_EVENT_CONTINUE ;\n }\n if ( ( bufp == reinterpret_cast < TSMBuffer > ( & ( ( HttpSM * ) txnp ) -> t_state . hdr_info . server_request ) ) && ( mloc == reinterpret_cast < TSMLoc > ( ( ( HttpSM * ) txnp ) -> t_state . hdr_info . server_request . m_http ) ) ) {\n test -> test_server_req_get = true ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnServerReqGet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n }\n else {\n test -> test_server_req_get = false ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnServerReqGet\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch\" ) ;\n }\n return TS_EVENT_CONTINUE ;\n }", "hash": -866921002076081979, "project": "debian", "size": 19, "target": 0, "idx": 11496}
{"code": "static int transformable ( TSHttpTxn txnp , TransformTestData * data ) {\n TSMBuffer bufp ;\n TSMLoc hdr_loc ;\n if ( TSHttpTxnServerRespGet ( txnp , & bufp , & hdr_loc ) != TS_SUCCESS ) {\n SDK_RPRINT ( data -> test , \"TSHttpTxnTransform\" , \"\" , TC_FAIL , \"[transformable]: TSHttpTxnServerRespGet return 0\" ) ;\n }\n if ( TS_HTTP_STATUS_OK == TSHttpHdrStatusGet ( bufp , hdr_loc ) ) {\n return 1 ;\n }\n return 0 ;\n }", "hash": -866921002076081979, "project": "debian", "size": 11, "target": 0, "idx": 11497}
{"code": "EXCLUSIVE_REGRESSION_TEST ( SDK_API_TSHttpConnectIntercept ) ( RegressionTest * test , int , int * pstatus ) {\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n TSDebug ( UTDBG_TAG , \"Starting test TSHttpConnectIntercept\" ) ;\n TSCont cont_test = TSContCreate ( cont_test_handler , TSMutexCreate ( ) ) ;\n ConnectTestData * data = ( ConnectTestData * ) TSmalloc ( sizeof ( ConnectTestData ) ) ;\n TSContDataSet ( cont_test , data ) ;\n data -> test = test ;\n data -> pstatus = pstatus ;\n data -> magic = MAGIC_ALIVE ;\n data -> test_case = TEST_CASE_CONNECT_ID1 ;\n TSHttpHookAdd ( TS_HTTP_READ_REQUEST_HDR_HOOK , cont_test ) ;\n data -> os = synserver_create ( SYNSERVER_DUMMY_PORT ) ;\n data -> browser = synclient_txn_create ( ) ;\n data -> request = generate_request ( 9 ) ;\n sockaddr_in addr ;\n ats_ip4_set ( & addr , 1 , 1 ) ;\n data -> vc = TSHttpConnect ( ats_ip_sa_cast ( & addr ) ) ;\n if ( TSVConnClosedGet ( data -> vc ) ) {\n SDK_RPRINT ( data -> test , \"TSHttpConnect\" , \"TestCase 1\" , TC_FAIL , \"Connect reported as closed immediately after open\" ) ;\n }\n synclient_txn_send_request_to_vc ( data -> browser , data -> request , data -> vc ) ;\n TSContSchedule ( cont_test , 25 , TS_THREAD_POOL_DEFAULT ) ;\n return ;\n }", "hash": -866921002076081979, "project": "debian", "size": 24, "target": 0, "idx": 11521}
{"code": "static int checkHttpTxnClientRespGet ( SocketTest * test , void * data ) {\n TSMBuffer bufp ;\n TSMLoc mloc ;\n TSHttpTxn txnp = ( TSHttpTxn ) data ;\n if ( TSHttpTxnClientRespGet ( txnp , & bufp , & mloc ) != TS_SUCCESS ) {\n test -> test_client_resp_get = false ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnClientRespGet\" , \"TestCase1\" , TC_FAIL , \"Unable to get handle to client response\" ) ;\n return TS_EVENT_CONTINUE ;\n }\n if ( ( bufp == reinterpret_cast < TSMBuffer > ( & ( ( HttpSM * ) txnp ) -> t_state . hdr_info . client_response ) ) && ( mloc == reinterpret_cast < TSMLoc > ( ( ( HttpSM * ) txnp ) -> t_state . hdr_info . client_response . m_http ) ) ) {\n test -> test_client_resp_get = true ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnClientRespGet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n }\n else {\n test -> test_client_resp_get = false ;\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnClientRespGet\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch\" ) ;\n }\n return TS_EVENT_CONTINUE ;\n }", "hash": -866921002076081979, "project": "debian", "size": 19, "target": 0, "idx": 11528}
{"code": "static int checkHttpTxnClientAddrGet ( SocketTest * test , void * data ) {\n uint16_t port ;\n uint16_t browser_port ;\n TSHttpTxn txnp = ( TSHttpTxn ) data ;\n sockaddr const * ptr = TSHttpTxnClientAddrGet ( txnp ) ;\n browser_port = test -> browser -> local_port ;\n if ( nullptr == ptr ) {\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnClientClientAddrGet\" , \"TestCase2\" , TC_FAIL , \"TSHttpTxnClientAddrGet returned 0 pointer.\" ) ;\n test -> test_client_remote_port_get = false ;\n return TS_EVENT_CONTINUE ;\n }\n port = ats_ip_port_host_order ( ptr ) ;\n TSDebug ( UTDBG_TAG , \"Browser port = %x, Txn remote port = %x\" , browser_port , port ) ;\n if ( port == browser_port ) {\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnClientAddrGet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test -> test_client_remote_port_get = true ;\n }\n else {\n SDK_RPRINT ( test -> regtest , \"TSHttpTxnClientAddrGet\" , \"TestCase1\" , TC_FAIL , \"Value's Mismatch. From Function: %d Expected Value: %d\" , port , browser_port ) ;\n test -> test_client_remote_port_get = false ;\n }\n return TS_EVENT_CONTINUE ;\n }", "hash": -866921002076081979, "project": "debian", "size": 23, "target": 0, "idx": 11534}
{"code": "REGRESSION_TEST ( SDK_API_TSConfig ) ( RegressionTest * test , int , int * pstatus ) {\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n ConfigData * config = ( ConfigData * ) TSmalloc ( sizeof ( ConfigData ) ) ;\n config -> a = \"unit\" ;\n config -> b = \"test\" ;\n my_config_id = TSConfigSet ( 0 , config , config_destroy_func ) ;\n TSConfig test_config = nullptr ;\n test_config = TSConfigGet ( my_config_id ) ;\n if ( ! test_config ) {\n SDK_RPRINT ( test , \"TSConfigSet\" , \"TestCase1\" , TC_FAIL , \"can't correctly set global config structure\" ) ;\n SDK_RPRINT ( test , \"TSConfigGet\" , \"TestCase1\" , TC_FAIL , \"can't correctly get global config structure\" ) ;\n TSConfigRelease ( my_config_id , reinterpret_cast < TSConfig > ( config ) ) ;\n * pstatus = REGRESSION_TEST_FAILED ;\n return ;\n }\n if ( TSConfigDataGet ( test_config ) != config ) {\n SDK_RPRINT ( test , \"TSConfigDataGet\" , \"TestCase1\" , TC_FAIL , \"failed to get config data\" ) ;\n TSConfigRelease ( my_config_id , reinterpret_cast < TSConfig > ( config ) ) ;\n * pstatus = REGRESSION_TEST_FAILED ;\n return ;\n }\n SDK_RPRINT ( test , \"TSConfigGet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n SDK_RPRINT ( test , \"TSConfigSet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n SDK_RPRINT ( test , \"TSConfigDataGet\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n TSConfigRelease ( my_config_id , reinterpret_cast < TSConfig > ( config ) ) ;\n * pstatus = REGRESSION_TEST_PASSED ;\n return ;\n }", "hash": -866921002076081979, "project": "debian", "size": 28, "target": 0, "idx": 11543}
{"code": "int TSHttpCurrentServerConnectionsGet ( void ) {\n int64_t S ;\n HTTP_READ_GLOBAL_DYN_SUM ( http_current_server_connections_stat , S ) ;\n return ( int ) S ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 5, "target": 0, "idx": 11549}
{"code": "int TSHttpSsnIsInternal ( TSHttpSsn ssnp ) {\n ProxyClientSession * cs = reinterpret_cast < ProxyClientSession * > ( ssnp ) ;\n if ( ! cs ) {\n return 0 ;\n }\n NetVConnection * vc = cs -> get_netvc ( ) ;\n if ( ! vc ) {\n return 0 ;\n }\n return vc -> get_is_internal_request ( ) ? 1 : 0 ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 11, "target": 0, "idx": 11556}
{"code": "void TSHttpParserClear ( TSHttpParser parser ) {\n sdk_assert ( sdk_sanity_check_http_parser ( parser ) == TS_SUCCESS ) ;\n http_parser_clear ( ( HTTPParser * ) parser ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 4, "target": 0, "idx": 11566}
{"code": "int TSIsDebugTagSet ( const char * t ) {\n return is_debug_tag_set ( t ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 3, "target": 0, "idx": 11569}
{"code": "time_t TSCacheHttpInfoReqSentTimeGet ( TSCacheHttpInfo infop ) {\n CacheHTTPInfo * info = ( CacheHTTPInfo * ) infop ;\n return info -> request_sent_time_get ( ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 4, "target": 0, "idx": 11575}
{"code": "TSVConn TSHttpConnectTransparent ( sockaddr const * client_addr , sockaddr const * server_addr ) {\n sdk_assert ( ats_is_ip ( client_addr ) ) ;\n sdk_assert ( ats_is_ip ( server_addr ) ) ;\n sdk_assert ( ! ats_is_ip_any ( client_addr ) ) ;\n sdk_assert ( ats_ip_port_cast ( client_addr ) ) ;\n sdk_assert ( ! ats_is_ip_any ( server_addr ) ) ;\n sdk_assert ( ats_ip_port_cast ( server_addr ) ) ;\n if ( plugin_http_transparent_accept ) {\n PluginVCCore * new_pvc = PluginVCCore : : alloc ( plugin_http_transparent_accept ) ;\n new_pvc -> set_active_addr ( client_addr ) ;\n new_pvc -> set_passive_addr ( server_addr ) ;\n new_pvc -> set_transparent ( true , true ) ;\n PluginVC * return_vc = new_pvc -> connect ( ) ;\n if ( return_vc != nullptr ) {\n PluginVC * other_side = return_vc -> get_other_side ( ) ;\n if ( other_side != nullptr ) {\n other_side -> set_is_internal_request ( true ) ;\n }\n }\n return reinterpret_cast < TSVConn > ( return_vc ) ;\n }\n return nullptr ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 23, "target": 0, "idx": 11609}
{"code": "TSReturnCode TSPluginRegister ( const TSPluginRegistrationInfo * plugin_info ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) plugin_info ) == TS_SUCCESS ) ;\n if ( ! plugin_reg_current ) {\n return TS_ERROR ;\n }\n plugin_reg_current -> plugin_registered = true ;\n if ( plugin_info -> plugin_name ) {\n plugin_reg_current -> plugin_name = ats_strdup ( plugin_info -> plugin_name ) ;\n }\n if ( plugin_info -> vendor_name ) {\n plugin_reg_current -> vendor_name = ats_strdup ( plugin_info -> vendor_name ) ;\n }\n if ( plugin_info -> support_email ) {\n plugin_reg_current -> support_email = ats_strdup ( plugin_info -> support_email ) ;\n }\n return TS_SUCCESS ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 17, "target": 0, "idx": 11613}
{"code": "TSReturnCode TSMgmtIntGet ( const char * var_name , TSMgmtInt * result ) {\n return RecGetRecordInt ( ( char * ) var_name , ( RecInt * ) result ) == REC_ERR_OKAY ? TS_SUCCESS : TS_ERROR ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 3, "target": 0, "idx": 11633}
{"code": "TSVConn TSVConnCreate ( TSEventFunc event_funcp , TSMutex mutexp ) {\n if ( mutexp == nullptr ) {\n mutexp = ( TSMutex ) new_ProxyMutex ( ) ;\n }\n sdk_assert ( sdk_sanity_check_mutex ( mutexp ) == TS_SUCCESS ) ;\n INKVConnInternal * i = INKVConnAllocator . alloc ( ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) i ) == TS_SUCCESS ) ;\n i -> init ( event_funcp , mutexp ) ;\n return reinterpret_cast < TSVConn > ( i ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 10, "target": 0, "idx": 11646}
{"code": "TSReturnCode TSHttpTxnCacheLookupUrlGet ( TSHttpTxn txnp , TSMBuffer bufp , TSMLoc obj ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_url_handle ( obj ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n URL u , * l_url ;\n u . m_heap = ( ( HdrHeapSDKHandle * ) bufp ) -> m_heap ;\n u . m_url_impl = ( URLImpl * ) obj ;\n if ( ! u . valid ( ) ) {\n return TS_ERROR ;\n }\n l_url = sm -> t_state . cache_info . lookup_url ;\n if ( l_url && l_url -> valid ( ) ) {\n u . copy ( l_url ) ;\n return TS_SUCCESS ;\n }\n return TS_ERROR ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 18, "target": 0, "idx": 11682}
{"code": "TSReturnCode TSHttpSsnClientFdGet ( TSHttpSsn ssnp , int * fdp ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) fdp ) == TS_SUCCESS ) ;\n VConnection * basecs = reinterpret_cast < VConnection * > ( ssnp ) ;\n ProxyClientSession * cs = dynamic_cast < ProxyClientSession * > ( basecs ) ;\n if ( cs == nullptr ) {\n return TS_ERROR ;\n }\n NetVConnection * vc = cs -> get_netvc ( ) ;\n if ( vc == nullptr ) {\n return TS_ERROR ;\n }\n * fdp = vc -> get_socket ( ) ;\n return TS_SUCCESS ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 14, "target": 0, "idx": 11687}
{"code": "int64_t TSVConnCacheObjectSizeGet ( TSVConn connp ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( connp ) == TS_SUCCESS ) ;\n CacheVC * vc = ( CacheVC * ) connp ;\n return vc -> get_object_size ( ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 5, "target": 0, "idx": 11709}
{"code": "void TSHttpSsnDebugSet ( TSHttpSsn ssnp , int on ) {\n sdk_assert ( sdk_sanity_check_http_ssn ( ssnp ) == TS_SUCCESS ) ;\n ( reinterpret_cast < ProxyClientSession * > ( ssnp ) ) -> debug_on = on ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 4, "target": 0, "idx": 11725}
{"code": "TSReturnCode TSMimeHdrCopy ( TSMBuffer dest_bufp , TSMLoc dest_obj , TSMBuffer src_bufp , TSMLoc src_obj ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( src_bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_mbuffer ( dest_bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( src_obj ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( src_obj ) == TS_SUCCESS ) ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( dest_obj ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( dest_obj ) == TS_SUCCESS ) ) ;\n if ( ! isWriteable ( dest_bufp ) ) {\n return TS_ERROR ;\n }\n HdrHeap * s_heap , * d_heap ;\n MIMEHdrImpl * s_mh , * d_mh ;\n s_heap = ( ( HdrHeapSDKHandle * ) src_bufp ) -> m_heap ;\n d_heap = ( ( HdrHeapSDKHandle * ) dest_bufp ) -> m_heap ;\n s_mh = _hdr_mloc_to_mime_hdr_impl ( src_obj ) ;\n d_mh = _hdr_mloc_to_mime_hdr_impl ( dest_obj ) ;\n mime_hdr_fields_clear ( d_heap , d_mh ) ;\n mime_hdr_copy_onto ( s_mh , s_heap , d_mh , d_heap , ( s_heap != d_heap ) ) ;\n return TS_SUCCESS ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 18, "target": 0, "idx": 11732}
{"code": "void * TSHttpSsnArgGet ( TSHttpSsn ssnp , int arg_idx ) {\n sdk_assert ( sdk_sanity_check_http_ssn ( ssnp ) == TS_SUCCESS ) ;\n sdk_assert ( arg_idx >= 0 && arg_idx < HTTP_SSN_TXN_MAX_USER_ARG ) ;\n ProxyClientSession * cs = reinterpret_cast < ProxyClientSession * > ( ssnp ) ;\n return cs -> get_user_arg ( arg_idx ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 6, "target": 0, "idx": 11752}
{"code": "TSReturnCode TSMgmtSourceGet ( const char * var_name , TSMgmtSource * source ) {\n return REC_ERR_OKAY == RecGetRecordSource ( var_name , reinterpret_cast < RecSourceT * > ( source ) ) ? TS_SUCCESS : TS_ERROR ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 3, "target": 0, "idx": 11756}
{"code": "TSReturnCode TSMimeHdrFieldValueDelete ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , int idx ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( hdr ) == TS_SUCCESS ) ) ;\n sdk_assert ( sdk_sanity_check_field_handle ( field , hdr ) == TS_SUCCESS ) ;\n sdk_assert ( idx >= 0 ) ;\n if ( ! isWriteable ( bufp ) ) {\n return TS_ERROR ;\n }\n MIMEFieldSDKHandle * handle = ( MIMEFieldSDKHandle * ) field ;\n HdrHeap * heap = ( ( HdrHeapSDKHandle * ) bufp ) -> m_heap ;\n mime_field_value_delete_comma_val ( heap , handle -> mh , handle -> field_ptr , idx ) ;\n return TS_SUCCESS ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 13, "target": 0, "idx": 11762}
{"code": "TSReturnCode TSHttpHdrTypeSet ( TSMBuffer bufp , TSMLoc obj , TSHttpType type ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_http_hdr_handle ( obj ) == TS_SUCCESS ) ;\n sdk_assert ( ( type >= TS_HTTP_TYPE_UNKNOWN ) && ( type <= TS_HTTP_TYPE_RESPONSE ) ) ;\n if ( ! isWriteable ( bufp ) ) {\n return TS_ERROR ;\n }\n HTTPHdr h ;\n SET_HTTP_HDR ( h , bufp , obj ) ;\n ink_assert ( h . m_http -> m_type == HDR_HEAP_OBJ_HTTP_HEADER ) ;\n if ( h . m_http -> m_polarity == HTTP_TYPE_UNKNOWN ) {\n if ( type == ( TSHttpType ) HTTP_TYPE_REQUEST ) {\n h . m_http -> u . req . m_url_impl = url_create ( h . m_heap ) ;\n h . m_http -> m_polarity = ( HTTPType ) type ;\n }\n else if ( type == ( TSHttpType ) HTTP_TYPE_RESPONSE ) {\n h . m_http -> m_polarity = ( HTTPType ) type ;\n }\n }\n return TS_SUCCESS ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 21, "target": 0, "idx": 11767}
{"code": "TSSslConnection TSVConnSSLConnectionGet ( TSVConn sslp ) {\n TSSslConnection ssl = nullptr ;\n NetVConnection * vc = reinterpret_cast < NetVConnection * > ( sslp ) ;\n SSLNetVConnection * ssl_vc = dynamic_cast < SSLNetVConnection * > ( vc ) ;\n if ( ssl_vc != nullptr ) {\n ssl = reinterpret_cast < TSSslConnection > ( ssl_vc -> ssl ) ;\n }\n return ssl ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 9, "target": 0, "idx": 11770}
{"code": "TSVConn TSHttpConnectWithPluginId ( sockaddr const * addr , const char * tag , int64_t id ) {\n sdk_assert ( addr ) ;\n sdk_assert ( ats_is_ip ( addr ) ) ;\n sdk_assert ( ats_ip_port_cast ( addr ) ) ;\n if ( plugin_http_accept ) {\n PluginVCCore * new_pvc = PluginVCCore : : alloc ( plugin_http_accept ) ;\n new_pvc -> set_active_addr ( addr ) ;\n new_pvc -> set_plugin_id ( id ) ;\n new_pvc -> set_plugin_tag ( tag ) ;\n PluginVC * return_vc = new_pvc -> connect ( ) ;\n if ( return_vc != nullptr ) {\n PluginVC * other_side = return_vc -> get_other_side ( ) ;\n if ( other_side != nullptr ) {\n other_side -> set_is_internal_request ( true ) ;\n }\n }\n return reinterpret_cast < TSVConn > ( return_vc ) ;\n }\n return nullptr ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 20, "target": 0, "idx": 11772}
{"code": "const char * TSHttpTxnRedirectUrlGet ( TSHttpTxn txnp , int * url_len_ptr ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n * url_len_ptr = sm -> redirect_url_len ;\n return sm -> redirect_url ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 6, "target": 0, "idx": 11775}
{"code": "TSReturnCode TSMBufferDestroy ( TSMBuffer bufp ) {\n if ( ! isWriteable ( bufp ) ) {\n return TS_ERROR ;\n }\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n HdrHeapSDKHandle * sdk_heap = ( HdrHeapSDKHandle * ) bufp ;\n sdk_heap -> m_heap -> destroy ( ) ;\n delete sdk_heap ;\n return TS_SUCCESS ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 10, "target": 0, "idx": 11779}
{"code": "void TSContDataSet ( TSCont contp , void * data ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( contp ) == TS_SUCCESS ) ;\n INKContInternal * i = ( INKContInternal * ) contp ;\n i -> mdata = data ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 5, "target": 0, "idx": 11794}
{"code": "int TSHttpTxnServerRespHdrBytesGet ( TSHttpTxn txnp ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * sm = ( HttpSM * ) txnp ;\n return sm -> server_response_hdr_bytes ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 5, "target": 0, "idx": 11798}
{"code": "static TSReturnCode sdk_sanity_check_stat_id ( int id ) {\n if ( id < 0 || id >= api_rsb -> max_stats ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 6, "target": 0, "idx": 11800}
{"code": "TSReturnCode sdk_sanity_check_fetch_sm ( TSFetchSM fetch_sm ) {\n if ( fetch_sm == nullptr ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 6, "target": 0, "idx": 11852}
{"code": "TSParseResult TSHttpHdrParseResp ( TSHttpParser parser , TSMBuffer bufp , TSMLoc obj , const char * * start , const char * end ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_http_hdr_handle ( obj ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) start ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) * start ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) end ) == TS_SUCCESS ) ;\n if ( ! isWriteable ( bufp ) ) {\n return TS_PARSE_ERROR ;\n }\n HTTPHdr h ;\n SET_HTTP_HDR ( h , bufp , obj ) ;\n ink_assert ( h . m_http -> m_type == HDR_HEAP_OBJ_HTTP_HEADER ) ;\n TSHttpHdrTypeSet ( bufp , obj , TS_HTTP_TYPE_RESPONSE ) ;\n return ( TSParseResult ) h . parse_resp ( ( HTTPParser * ) parser , start , end , false ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 15, "target": 0, "idx": 11859}
{"code": "void TSVConnClose ( TSVConn connp ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( connp ) == TS_SUCCESS ) ;\n VConnection * vc = ( VConnection * ) connp ;\n vc -> do_io_close ( ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 5, "target": 0, "idx": 11881}
{"code": "void TSLifecycleHookAdd ( TSLifecycleHookID id , TSCont contp ) {\n sdk_assert ( sdk_sanity_check_continuation ( contp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_lifecycle_hook_id ( id ) == TS_SUCCESS ) ;\n lifecycle_hooks -> append ( id , ( INKContInternal * ) contp ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 5, "target": 0, "idx": 11898}
{"code": "const char * TSRuntimeDirGet ( void ) {\n static std : : string runtimedir = RecConfigReadRuntimeDir ( ) ;\n return runtimedir . c_str ( ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 4, "target": 0, "idx": 11900}
{"code": "void TSConfigRelease ( unsigned int id , TSConfig configp ) {\n configProcessor . release ( id , ( ConfigInfo * ) configp ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 3, "target": 0, "idx": 11903}
{"code": "const char * TSPluginDirGet ( void ) {\n static std : : string path = RecConfigReadPluginDir ( ) ;\n return path . c_str ( ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 4, "target": 0, "idx": 11918}
{"code": "void TSRecordDump ( int rec_type , TSRecordDumpCb callback , void * edata ) {\n RecDumpRecords ( ( RecT ) rec_type , ( RecDumpEntryCb ) callback , edata ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 3, "target": 0, "idx": 11919}
{"code": "TSParseResult TSUrlParse ( TSMBuffer bufp , TSMLoc obj , const char * * start , const char * end ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_url_handle ( obj ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) start ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) * start ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) end ) == TS_SUCCESS ) ;\n if ( ! isWriteable ( bufp ) ) {\n return TS_PARSE_ERROR ;\n }\n URL u ;\n u . m_heap = ( ( HdrHeapSDKHandle * ) bufp ) -> m_heap ;\n u . m_url_impl = ( URLImpl * ) obj ;\n url_clear ( u . m_url_impl ) ;\n return ( TSParseResult ) u . parse ( start , end ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 15, "target": 0, "idx": 11932}
{"code": "TSReturnCode sdk_sanity_check_http_parser ( TSHttpParser parser ) {\n if ( parser == nullptr ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 6, "target": 0, "idx": 11940}
{"code": "TSReturnCode TSHttpTxnNewCacheLookupDo ( TSHttpTxn txnp , TSMBuffer bufp , TSMLoc url_loc ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_url_handle ( url_loc ) == TS_SUCCESS ) ;\n URL new_url , * client_url , * l_url , * o_url ;\n INK_MD5 md51 , md52 ;\n new_url . m_heap = ( ( HdrHeapSDKHandle * ) bufp ) -> m_heap ;\n new_url . m_url_impl = ( URLImpl * ) url_loc ;\n if ( ! new_url . valid ( ) ) {\n return TS_ERROR ;\n }\n HttpSM * sm = ( HttpSM * ) txnp ;\n HttpTransact : : State * s = & ( sm -> t_state ) ;\n client_url = s -> hdr_info . client_request . url_get ( ) ;\n if ( ! ( client_url -> valid ( ) ) ) {\n return TS_ERROR ;\n }\n l_url = s -> cache_info . lookup_url ;\n if ( ! l_url || ! l_url -> valid ( ) ) {\n s -> cache_info . lookup_url_storage . create ( nullptr ) ;\n s -> cache_info . lookup_url = & ( s -> cache_info . lookup_url_storage ) ;\n l_url = s -> cache_info . lookup_url ;\n }\n else {\n l_url -> hash_get ( & md51 ) ;\n new_url . hash_get ( & md52 ) ;\n if ( md51 == md52 ) {\n return TS_ERROR ;\n }\n o_url = & ( s -> cache_info . original_url ) ;\n if ( ! o_url -> valid ( ) ) {\n o_url -> create ( nullptr ) ;\n o_url -> copy ( l_url ) ;\n }\n }\n l_url -> copy ( & new_url ) ;\n s -> transact_return_point = HttpTransact : : DecideCacheLookup ;\n s -> cache_info . action = HttpTransact : : CACHE_DO_LOOKUP ;\n sm -> add_cache_sm ( ) ;\n s -> api_cleanup_cache_read = true ;\n return TS_SUCCESS ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 42, "target": 0, "idx": 11947}
{"code": "TSAction TSCacheWrite ( TSCont contp , TSCacheKey key ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( contp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_cachekey ( key ) == TS_SUCCESS ) ;\n FORCE_PLUGIN_SCOPED_MUTEX ( contp ) ;\n CacheInfo * info = ( CacheInfo * ) key ;\n Continuation * i = ( INKContInternal * ) contp ;\n return ( TSAction ) cacheProcessor . open_write ( i , & info -> cache_key , true , info -> frag_type , 0 , false , info -> pin_in_cache , info -> hostname , info -> len ) ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 8, "target": 0, "idx": 11948}
{"code": "TSReturnCode TSStringPercentDecode ( const char * str , size_t str_len , char * dst , size_t dst_size , size_t * length ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) str ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) dst ) == TS_SUCCESS ) ;\n if ( 0 == str_len ) {\n str_len = strlen ( str ) ;\n }\n char * buffer = dst ;\n const char * src = str ;\n int s = 0 ;\n unescape_str ( buffer , buffer + dst_size , src , src + str_len , s ) ;\n size_t data_written = std : : min < size_t > ( buffer - dst , dst_size - 1 ) ;\n * ( dst + data_written ) = '\\0' ;\n if ( length ) {\n * length = ( data_written ) ;\n }\n return TS_SUCCESS ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 17, "target": 0, "idx": 11953}
{"code": "TSReturnCode sdk_sanity_check_continuation ( TSCont cont ) {\n if ( ( cont == nullptr ) || ( ( ( INKContInternal * ) cont ) -> m_free_magic == INKCONT_INTERN_MAGIC_DEAD ) ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }", "hash": 1760449185745615462, "project": "debian", "size": 6, "target": 0, "idx": 11965}
{"code": "void proto_reg_handoff_cipsafety ( void ) {\n dissector_handle_t cip_class_s_supervisor_handle ;\n cip_class_s_supervisor_handle = create_dissector_handle ( dissect_cip_class_s_supervisor , proto_cip_class_s_supervisor ) ;\n dissector_add_uint ( \"cip.class.iface\" , CI_CLS_SAFETY_SUPERVISOR , cip_class_s_supervisor_handle ) ;\n cip_class_s_validator_handle = create_dissector_handle ( dissect_cip_class_s_validator , proto_cip_class_s_validator ) ;\n dissector_add_uint ( \"cip.class.iface\" , CI_CLS_SAFETY_VALIDATOR , cip_class_s_validator_handle ) ;\n heur_dissector_add ( \"cip.sc\" , dissect_class_svalidator_heur , \"CIP Safety Validator\" , \"s_validator_cip\" , proto_cip_class_s_validator , HEURISTIC_ENABLE ) ;\n dissector_add_for_decode_as ( \"enip.io\" , cipsafety_handle ) ;\n proto_cip = proto_get_id_by_filter_name ( \"cip\" ) ;\n subdissector_class_table = find_dissector_table ( \"cip.class.iface\" ) ;\n }", "hash": -8919449269326401539, "project": "debian", "size": 11, "target": 0, "idx": 11992}
{"code": "void dissect_cipsafety_ssn ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , int hf_real_datetime , int hf_date , int hf_time ) {\n guint16 date ;\n date = tvb_get_letohs ( tvb , offset ) ;\n if ( ( date >= 11688 ) && ( date <= 65534 ) ) {\n dissect_cip_date_and_time ( tree , tvb , offset , hf_real_datetime ) ;\n }\n else {\n proto_tree_add_item ( tree , hf_date , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_time , tvb , offset + 2 , 4 , ENC_LITTLE_ENDIAN ) ;\n }\n }", "hash": -8919449269326401539, "project": "debian", "size": 11, "target": 0, "idx": 11999}
{"code": "static int dissect_s_validator_app_data_path ( packet_info * pinfo , proto_tree * tree , proto_item * item _U_ , tvbuff_t * tvb , int offset , int total_len ) {\n proto_item * pi ;\n proto_tree * epath_tree = proto_tree_add_subtree ( tree , NULL , 0 , 0 , ett_path , & pi , \"Application Data Path: \" ) ;\n dissect_epath ( tvb , pinfo , epath_tree , pi , offset , total_len , FALSE , FALSE , NULL , NULL , NO_DISPLAY , NULL , FALSE ) ;\n return total_len ;\n }", "hash": -8919449269326401539, "project": "debian", "size": 6, "target": 0, "idx": 12002}
{"code": "static void dissect_ack_byte ( proto_tree * tree , tvbuff_t * tvb , int offset , packet_info * pinfo _U_ ) {\n proto_item * ack_item ;\n proto_tree * ack_tree ;\n # if 0 guint8 ack_byte ;\n ack_byte = tvb_get_guint8 ( tvb , offset ) ;\n # endif if ( ! tree ) return ;\n ack_item = proto_tree_add_item ( tree , hf_cipsafety_ack_byte , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n ack_tree = proto_item_add_subtree ( ack_item , ett_cipsafety_ack_byte ) ;\n proto_tree_add_item ( ack_tree , hf_cipsafety_ack_byte_ping_count_reply , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( ack_tree , hf_cipsafety_ack_byte_reserved1 , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( ack_tree , hf_cipsafety_ack_byte_ping_response , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( ack_tree , hf_cipsafety_ack_byte_reserved2 , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( ack_tree , hf_cipsafety_ack_byte_parity_even , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n }", "hash": -8919449269326401539, "project": "debian", "size": 14, "target": 0, "idx": 12003}
{"code": "static int dissect_s_supervisor_exception_detail ( proto_tree * tree , proto_item * item , tvbuff_t * tvb , int offset , int hf_size , int hf_data ) {\n int size ;\n proto_tree_add_item ( tree , hf_size , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n size = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_data , tvb , offset + 1 , size , ENC_NA ) ;\n proto_item_set_len ( item , size + 1 ) ;\n return size + 1 ;\n }", "hash": -8919449269326401539, "project": "debian", "size": 8, "target": 0, "idx": 12007}
{"code": "static int dissect_s_supervisor_exception_detail_warning ( packet_info * pinfo , proto_tree * tree , proto_item * item , tvbuff_t * tvb , int offset , int total_len ) {\n proto_item * pi ;\n proto_tree * item_tree ;\n int total_size = 0 , size ;\n item_tree = proto_tree_add_subtree ( tree , tvb , offset , 1 , ett_exception_detail_warning_common , & pi , \"Common Exception Detail\" ) ;\n size = dissect_s_supervisor_exception_detail ( item_tree , pi , tvb , offset , hf_cip_ssupervisor_exception_detail_warning_ced_size , hf_cip_ssupervisor_exception_detail_warning_ced_detail ) ;\n if ( size == 0 ) {\n expert_add_info ( pinfo , item , & ei_mal_ssupervisor_detail_warning_ced ) ;\n return total_len ;\n }\n total_size += size ;\n item_tree = proto_tree_add_subtree ( tree , tvb , offset , 1 , ett_exception_detail_warning_device , & pi , \"Device Exception Detail\" ) ;\n size = dissect_s_supervisor_exception_detail ( item_tree , pi , tvb , offset , hf_cip_ssupervisor_exception_detail_warning_ded_size , hf_cip_ssupervisor_exception_detail_warning_ded_detail ) ;\n if ( size == 0 ) {\n expert_add_info ( pinfo , item , & ei_mal_ssupervisor_detail_warning_ded ) ;\n return total_len ;\n }\n total_size += size ;\n item_tree = proto_tree_add_subtree ( tree , tvb , offset , 1 , ett_exception_detail_warning_manufacturer , & pi , \"Manufacturer Exception Detail\" ) ;\n size = dissect_s_supervisor_exception_detail ( item_tree , pi , tvb , offset , hf_cip_ssupervisor_exception_detail_warning_med_size , hf_cip_ssupervisor_exception_detail_warning_med_detail ) ;\n if ( size == 0 ) {\n expert_add_info ( pinfo , item , & ei_mal_ssupervisor_detail_warning_med ) ;\n return total_len ;\n }\n total_size += size ;\n return total_size ;\n }", "hash": -8919449269326401539, "project": "debian", "size": 27, "target": 0, "idx": 12020}
{"code": "void pdf_update_xobject_contents ( fz_context * ctx , pdf_document * doc , pdf_xobject * form , fz_buffer * buffer ) {\n pdf_update_stream ( ctx , doc , form -> obj , buffer , 0 ) ;\n form -> iteration ++ ;\n }", "hash": -4034210238312760680, "project": "debian", "size": 4, "target": 0, "idx": 12031}
{"code": "pdf_obj * pdf_xobject_resources ( fz_context * ctx , pdf_xobject * xobj ) {\n return pdf_dict_get ( ctx , xobj -> obj , PDF_NAME_Resources ) ;\n }", "hash": -4034210238312760680, "project": "debian", "size": 3, "target": 0, "idx": 12033}
{"code": "static void pdf_process_BDC ( fz_context * ctx , pdf_processor * proc , pdf_csi * csi ) {\n if ( proc -> op_BDC ) proc -> op_BDC ( ctx , proc , csi -> name , csi -> obj , resolve_properties ( ctx , csi , csi -> obj ) ) ;\n if ( proc -> hidden > 0 ) {\n ++ proc -> hidden ;\n return ;\n }\n if ( strcmp ( csi -> name , \"OC\" ) ) return ;\n if ( pdf_is_hidden_ocg ( ctx , csi -> doc -> ocg , csi -> rdb , proc -> usage , csi -> obj ) ) ++ proc -> hidden ;\n }", "hash": 6120640898537304364, "project": "debian", "size": 9, "target": 0, "idx": 12038}
{"code": "static void pdf_process_CS ( fz_context * ctx , pdf_processor * proc , pdf_csi * csi , int stroke ) {\n if ( ! proc -> op_CS || ! proc -> op_cs ) return ;\n if ( ! strcmp ( csi -> name , \"Pattern\" ) ) {\n if ( stroke ) proc -> op_CS ( ctx , proc , \"Pattern\" , NULL ) ;\n else proc -> op_cs ( ctx , proc , \"Pattern\" , NULL ) ;\n }\n else {\n fz_colorspace * cs ;\n if ( ! strcmp ( csi -> name , \"DeviceGray\" ) ) cs = fz_keep_colorspace ( ctx , fz_device_gray ( ctx ) ) ;\n else if ( ! strcmp ( csi -> name , \"DeviceRGB\" ) ) cs = fz_keep_colorspace ( ctx , fz_device_rgb ( ctx ) ) ;\n else if ( ! strcmp ( csi -> name , \"DeviceCMYK\" ) ) cs = fz_keep_colorspace ( ctx , fz_device_cmyk ( ctx ) ) ;\n else {\n pdf_obj * csres , * csobj ;\n csres = pdf_dict_get ( ctx , csi -> rdb , PDF_NAME_ColorSpace ) ;\n if ( ! csres ) fz_throw ( ctx , FZ_ERROR_SYNTAX , \"cannot find ColorSpace dictionary\" ) ;\n csobj = pdf_dict_gets ( ctx , csres , csi -> name ) ;\n if ( ! csobj ) fz_throw ( ctx , FZ_ERROR_SYNTAX , \"cannot find ColorSpace resource '%s'\" , csi -> name ) ;\n cs = pdf_load_colorspace ( ctx , csobj ) ;\n }\n fz_try ( ctx ) {\n if ( stroke ) proc -> op_CS ( ctx , proc , csi -> name , cs ) ;\n else proc -> op_cs ( ctx , proc , csi -> name , cs ) ;\n }\n fz_always ( ctx ) fz_drop_colorspace ( ctx , cs ) ;\n fz_catch ( ctx ) fz_rethrow ( ctx ) ;\n }\n }", "hash": 6120640898537304364, "project": "debian", "size": 27, "target": 0, "idx": 12041}
{"code": "void pdf_tos_reset ( fz_context * ctx , pdf_text_object_state * tos , int render ) {\n tos -> text = fz_new_text ( ctx ) ;\n tos -> text_mode = render ;\n tos -> text_bbox = fz_empty_rect ;\n }", "hash": 6120640898537304364, "project": "debian", "size": 5, "target": 0, "idx": 12066}
{"code": "int ECDSA_do_verify ( const unsigned char * dgst , int dgst_len , const ECDSA_SIG * sig , EC_KEY * eckey ) {\n ECDSA_DATA * ecdsa = ecdsa_check ( eckey ) ;\n if ( ecdsa == NULL ) return 0 ;\n return ecdsa -> meth -> ecdsa_do_verify ( dgst , dgst_len , sig , eckey ) ;\n }", "hash": 1821643036167179721, "project": "debian", "size": 5, "target": 0, "idx": 12068}
{"code": "static int dsa_cb ( int operation , ASN1_VALUE * * pval , const ASN1_ITEM * it , void * exarg ) {\n if ( operation == ASN1_OP_NEW_PRE ) {\n * pval = ( ASN1_VALUE * ) DSA_new ( ) ;\n if ( * pval ) return 2 ;\n return 0 ;\n }\n else if ( operation == ASN1_OP_FREE_PRE ) {\n DSA_free ( ( DSA * ) * pval ) ;\n * pval = NULL ;\n return 2 ;\n }\n return 1 ;\n }", "hash": -9129169564020831625, "project": "debian", "size": 13, "target": 0, "idx": 12073}
{"code": "int i2d_DSAPrivateKey_bio ( BIO * bp , DSA * dsa ) {\n return ASN1_i2d_bio_of_const ( DSA , i2d_DSAPrivateKey , bp , dsa ) ;\n }", "hash": 2578089348587614328, "project": "debian", "size": 3, "target": 0, "idx": 12079}
{"code": "int X509_digest ( const X509 * data , const EVP_MD * type , unsigned char * md , unsigned int * len ) {\n return ( ASN1_item_digest ( ASN1_ITEM_rptr ( X509 ) , type , ( char * ) data , md , len ) ) ;\n }", "hash": 2578089348587614328, "project": "debian", "size": 3, "target": 0, "idx": 12084}
{"code": "int i2d_X509_fp ( FILE * fp , X509 * x509 ) {\n return ASN1_item_i2d_fp ( ASN1_ITEM_rptr ( X509 ) , fp , x509 ) ;\n }", "hash": 2578089348587614328, "project": "debian", "size": 3, "target": 0, "idx": 12086}
{"code": "int i2d_PKCS7_bio ( BIO * bp , PKCS7 * p7 ) {\n return ASN1_item_i2d_bio ( ASN1_ITEM_rptr ( PKCS7 ) , bp , p7 ) ;\n }", "hash": 2578089348587614328, "project": "debian", "size": 3, "target": 0, "idx": 12097}
{"code": "DSA * d2i_DSAPrivateKey_bio ( BIO * bp , DSA * * dsa ) {\n return ASN1_d2i_bio_of ( DSA , DSA_new , d2i_DSAPrivateKey , bp , dsa ) ;\n }", "hash": 2578089348587614328, "project": "debian", "size": 3, "target": 0, "idx": 12101}
{"code": "int i2d_X509_bio ( BIO * bp , X509 * x509 ) {\n return ASN1_item_i2d_bio ( ASN1_ITEM_rptr ( X509 ) , bp , x509 ) ;\n }", "hash": 2578089348587614328, "project": "debian", "size": 3, "target": 0, "idx": 12121}
{"code": "int i2d_PUBKEY_fp ( FILE * fp , EVP_PKEY * pkey ) {\n return ASN1_i2d_fp_of ( EVP_PKEY , i2d_PUBKEY , fp , pkey ) ;\n }", "hash": 2578089348587614328, "project": "debian", "size": 3, "target": 0, "idx": 12127}
{"code": "EC_KEY * d2i_ECPrivateKey_bio ( BIO * bp , EC_KEY * * eckey ) {\n return ASN1_d2i_bio_of ( EC_KEY , EC_KEY_new , d2i_ECPrivateKey , bp , eckey ) ;\n }", "hash": 2578089348587614328, "project": "debian", "size": 3, "target": 0, "idx": 12130}
{"code": "PKCS8_PRIV_KEY_INFO * d2i_PKCS8_PRIV_KEY_INFO_bio ( BIO * bp , PKCS8_PRIV_KEY_INFO * * p8inf ) {\n return ASN1_d2i_bio_of ( PKCS8_PRIV_KEY_INFO , PKCS8_PRIV_KEY_INFO_new , d2i_PKCS8_PRIV_KEY_INFO , bp , p8inf ) ;\n }", "hash": 2578089348587614328, "project": "debian", "size": 3, "target": 0, "idx": 12132}
{"code": "X509_REQ * d2i_X509_REQ_bio ( BIO * bp , X509_REQ * * req ) {\n return ASN1_item_d2i_bio ( ASN1_ITEM_rptr ( X509_REQ ) , bp , req ) ;\n }", "hash": 2578089348587614328, "project": "debian", "size": 3, "target": 0, "idx": 12137}
{"code": "RSA * d2i_RSA_PUBKEY_bio ( BIO * bp , RSA * * rsa ) {\n return ASN1_d2i_bio_of ( RSA , RSA_new , d2i_RSA_PUBKEY , bp , rsa ) ;\n }", "hash": 2578089348587614328, "project": "debian", "size": 3, "target": 0, "idx": 12143}
{"code": "int i2d_PKCS8PrivateKeyInfo_bio ( BIO * bp , EVP_PKEY * key ) {\n PKCS8_PRIV_KEY_INFO * p8inf ;\n int ret ;\n p8inf = EVP_PKEY2PKCS8 ( key ) ;\n if ( ! p8inf ) return 0 ;\n ret = i2d_PKCS8_PRIV_KEY_INFO_bio ( bp , p8inf ) ;\n PKCS8_PRIV_KEY_INFO_free ( p8inf ) ;\n return ret ;\n }", "hash": 2578089348587614328, "project": "debian", "size": 9, "target": 0, "idx": 12147}
{"code": "int i2d_X509_CRL_fp ( FILE * fp , X509_CRL * crl ) {\n return ASN1_item_i2d_fp ( ASN1_ITEM_rptr ( X509_CRL ) , fp , crl ) ;\n }", "hash": 2578089348587614328, "project": "debian", "size": 3, "target": 0, "idx": 12149}
{"code": "static int zrcheck ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n int code = access_check ( i_ctx_p , a_read , false ) ;\n if ( code >= 0 ) make_bool ( op , code ) , code = 0 ;\n return code ;\n }", "hash": 7607805321589710329, "project": "debian", "size": 6, "target": 0, "idx": 12155}
{"code": "static void dissect_coap_opt_ctype ( tvbuff_t * tvb , proto_item * head_item , proto_tree * subtree , gint offset , gint opt_length , int hf , coap_info * coinfo ) {\n if ( opt_length == 0 ) {\n coinfo -> ctype_value = 0 ;\n }\n else {\n coinfo -> ctype_value = coap_get_opt_uint ( tvb , offset , opt_length ) ;\n }\n coinfo -> ctype_str = val_to_str ( coinfo -> ctype_value , vals_ctype , \"Unknown Type %u\" ) ;\n proto_tree_add_string ( subtree , hf , tvb , offset , opt_length , coinfo -> ctype_str ) ;\n proto_item_append_text ( head_item , \": %s\" , coinfo -> ctype_str ) ;\n }", "hash": 2636502839178711655, "project": "debian", "size": 11, "target": 0, "idx": 12184}
{"code": "int dissect_coap_options ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * coap_tree , gint offset , gint offset_end , coap_info * coinfo , coap_common_dissect_t * dissect_hf ) {\n guint opt_num = 0 ;\n int i ;\n guint8 endmarker ;\n for ( i = 1 ;\n offset < offset_end ;\n i ++ ) {\n offset = dissect_coap_options_main ( tvb , pinfo , coap_tree , offset , i , & opt_num , offset_end , coinfo , dissect_hf ) ;\n if ( offset == - 1 ) return - 1 ;\n if ( offset >= offset_end ) break ;\n endmarker = tvb_get_guint8 ( tvb , offset ) ;\n if ( endmarker == 0xff ) {\n proto_tree_add_item ( coap_tree , dissect_hf -> hf . opt_end_marker , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset += 1 ;\n break ;\n }\n }\n return offset ;\n }", "hash": 2636502839178711655, "project": "debian", "size": 19, "target": 0, "idx": 12191}
{"code": "static gint dissect_sep ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , guint32 interface_id , guint32 adapter_id , guint32 chandle ) {\n proto_tree * sep_tree ;\n proto_item * sep_item ;\n guint i_sep = 1 ;\n guint media_type ;\n guint type ;\n guint seid ;\n guint in_use ;\n guint items ;\n guint32 direction ;\n direction = ( pinfo -> p2p_dir == P2P_DIR_SENT ) ? P2P_DIR_RECV : P2P_DIR_SENT ;\n items = tvb_reported_length_remaining ( tvb , offset ) / 2 ;\n while ( tvb_reported_length_remaining ( tvb , offset ) > 0 ) {\n seid = tvb_get_guint8 ( tvb , offset ) ;\n in_use = seid & 0x02 ;\n seid = seid >> 2 ;\n media_type = tvb_get_guint8 ( tvb , offset + 1 ) >> 4 ;\n type = ( tvb_get_guint8 ( tvb , offset + 1 ) & 0x08 ) >> 3 ;\n sep_item = proto_tree_add_none_format ( tree , hf_btavdtp_acp_sep , tvb , offset , 2 , \"ACP SEP [%u - %s %s] item %u/%u\" , seid , val_to_str_const ( media_type , media_type_vals , \"unknown\" ) , val_to_str_const ( type , sep_type_vals , \"unknown\" ) , i_sep , items ) ;\n sep_tree = proto_item_add_subtree ( sep_item , ett_btavdtp_sep ) ;\n proto_tree_add_item ( sep_tree , hf_btavdtp_sep_seid , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( sep_tree , hf_btavdtp_sep_inuse , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( sep_tree , hf_btavdtp_sep_rfa0 , tvb , offset , 1 , ENC_NA ) ;\n offset += 1 ;\n proto_tree_add_item ( sep_tree , hf_btavdtp_sep_media_type , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( sep_tree , hf_btavdtp_sep_type , tvb , offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( sep_tree , hf_btavdtp_sep_rfa1 , tvb , offset , 1 , ENC_NA ) ;\n if ( ! pinfo -> fd -> flags . visited ) {\n sep_entry_t * sep_data ;\n wmem_tree_key_t key [ 7 ] ;\n guint32 frame_number = pinfo -> num ;\n key [ 0 ] . length = 1 ;\n key [ 0 ] . key = & interface_id ;\n key [ 1 ] . length = 1 ;\n key [ 1 ] . key = & adapter_id ;\n key [ 2 ] . length = 1 ;\n key [ 2 ] . key = & chandle ;\n key [ 3 ] . length = 1 ;\n key [ 3 ] . key = & direction ;\n key [ 4 ] . length = 1 ;\n key [ 4 ] . key = & seid ;\n key [ 5 ] . length = 1 ;\n key [ 5 ] . key = & frame_number ;\n key [ 6 ] . length = 0 ;\n key [ 6 ] . key = NULL ;\n sep_data = wmem_new0 ( wmem_file_scope ( ) , sep_entry_t ) ;\n sep_data -> seid = seid ;\n sep_data -> type = type ;\n sep_data -> media_type = media_type ;\n sep_data -> codec = - 1 ;\n if ( in_use ) {\n sep_data -> state = SEP_STATE_IN_USE ;\n }\n else {\n sep_data -> state = SEP_STATE_FREE ;\n }\n wmem_tree_insert32_array ( sep_list , key , sep_data ) ;\n }\n offset += 1 ;\n i_sep += 1 ;\n }\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" - items: %u\" , items ) ;\n return offset ;\n }", "hash": -6856626433814917486, "project": "debian", "size": 64, "target": 0, "idx": 12202}
{"code": "static const char * get_sep_type ( guint32 interface_id , guint32 adapter_id , guint32 chandle , guint32 direction , guint32 seid , guint32 frame_number ) {\n wmem_tree_key_t key [ 6 ] ;\n wmem_tree_t * subtree ;\n sep_entry_t * sep ;\n key [ 0 ] . length = 1 ;\n key [ 0 ] . key = & interface_id ;\n key [ 1 ] . length = 1 ;\n key [ 1 ] . key = & adapter_id ;\n key [ 2 ] . length = 1 ;\n key [ 2 ] . key = & chandle ;\n key [ 3 ] . length = 1 ;\n key [ 3 ] . key = & direction ;\n key [ 4 ] . length = 1 ;\n key [ 4 ] . key = & seid ;\n key [ 5 ] . length = 0 ;\n key [ 5 ] . key = NULL ;\n subtree = ( wmem_tree_t * ) wmem_tree_lookup32_array ( sep_list , key ) ;\n sep = ( subtree ) ? ( sep_entry_t * ) wmem_tree_lookup32_le ( subtree , frame_number ) : NULL ;\n if ( sep ) {\n return val_to_str_const ( sep -> type , sep_type_vals , \"unknown\" ) ;\n }\n return \"unknown\" ;\n }", "hash": -6856626433814917486, "project": "debian", "size": 23, "target": 0, "idx": 12209}
{"code": "static gint handle_message_body_parameters ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * header_tree , guint encoding , gint offset , gint32 body_length , guint8 * signature , guint8 signature_length ) {\n gint packet_length , end_of_body ;\n proto_tree * tree ;\n proto_item * item ;\n const gint starting_offset = offset ;\n packet_length = tvb_reported_length ( tvb ) ;\n item = proto_tree_add_item ( header_tree , hf_alljoyn_mess_body_parameters , tvb , offset , body_length , ENC_NA ) ;\n tree = proto_item_add_subtree ( item , ett_alljoyn_mess_body_parameters ) ;\n end_of_body = offset + body_length ;\n if ( end_of_body > packet_length ) {\n end_of_body = packet_length ;\n }\n while ( offset < end_of_body && signature && * signature ) {\n offset = parse_arg ( tvb , pinfo , NULL , encoding , offset , tree , FALSE , * signature , HDR_INVALID , & signature , & signature_length , starting_offset ) ;\n }\n return offset ;\n }", "hash": -2242211406757466627, "project": "debian", "size": 17, "target": 0, "idx": 12234}
{"code": "static void add_padding_item ( gint padding_start , gint padding_end , tvbuff_t * tvb , proto_tree * tree ) {\n if ( padding_end > padding_start && padding_end < ( gint ) tvb_reported_length ( tvb ) ) {\n gint padding_length = padding_end - padding_start ;\n if ( padding_length <= MAX_ROUND_TO_BYTES ) {\n proto_tree_add_item ( tree , hf_padding , tvb , padding_start , padding_length , ENC_NA ) ;\n }\n }\n }", "hash": -2242211406757466627, "project": "debian", "size": 8, "target": 0, "idx": 12240}
{"code": "static void ssl3_take_mac ( SSL * s ) {\n const char * sender ;\n int slen ;\n if ( s -> state & SSL_ST_CONNECT ) {\n sender = s -> method -> ssl3_enc -> server_finished_label ;\n slen = s -> method -> ssl3_enc -> server_finished_label_len ;\n }\n else {\n sender = s -> method -> ssl3_enc -> client_finished_label ;\n slen = s -> method -> ssl3_enc -> client_finished_label_len ;\n }\n s -> s3 -> tmp . peer_finish_md_len = s -> method -> ssl3_enc -> final_finish_mac ( s , sender , slen , s -> s3 -> tmp . peer_finish_md ) ;\n }", "hash": 5524055408114021500, "project": "debian", "size": 13, "target": 0, "idx": 12245}
{"code": "static int tls1_PRF ( long digest_mask , const void * seed1 , int seed1_len , const void * seed2 , int seed2_len , const void * seed3 , int seed3_len , const void * seed4 , int seed4_len , const void * seed5 , int seed5_len , const unsigned char * sec , int slen , unsigned char * out1 , unsigned char * out2 , int olen ) {\n int len , i , idx , count ;\n const unsigned char * S1 ;\n long m ;\n const EVP_MD * md ;\n int ret = 0 ;\n count = 0 ;\n for ( idx = 0 ;\n ssl_get_handshake_digest ( idx , & m , & md ) ;\n idx ++ ) {\n if ( ( m << TLS1_PRF_DGST_SHIFT ) & digest_mask ) count ++ ;\n }\n len = slen / count ;\n if ( count == 1 ) slen = 0 ;\n S1 = sec ;\n memset ( out1 , 0 , olen ) ;\n for ( idx = 0 ;\n ssl_get_handshake_digest ( idx , & m , & md ) ;\n idx ++ ) {\n if ( ( m << TLS1_PRF_DGST_SHIFT ) & digest_mask ) {\n if ( ! md ) {\n SSLerr ( SSL_F_TLS1_PRF , SSL_R_UNSUPPORTED_DIGEST_TYPE ) ;\n goto err ;\n }\n if ( ! tls1_P_hash ( md , S1 , len + ( slen & 1 ) , seed1 , seed1_len , seed2 , seed2_len , seed3 , seed3_len , seed4 , seed4_len , seed5 , seed5_len , out2 , olen ) ) goto err ;\n S1 += len ;\n for ( i = 0 ;\n i < olen ;\n i ++ ) {\n out1 [ i ] ^= out2 [ i ] ;\n }\n }\n }\n ret = 1 ;\n err : return ret ;\n }", "hash": 370610032569630438, "project": "debian", "size": 36, "target": 0, "idx": 12266}
{"code": "int tls1_mac ( SSL * ssl , unsigned char * md , int send ) {\n SSL3_RECORD * rec ;\n unsigned char * seq ;\n EVP_MD_CTX * hash ;\n size_t md_size , orig_len ;\n int i ;\n EVP_MD_CTX hmac , * mac_ctx ;\n unsigned char header [ 13 ] ;\n int stream_mac = ( send ? ( ssl -> mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM ) : ( ssl -> mac_flags & SSL_MAC_FLAG_READ_MAC_STREAM ) ) ;\n int t ;\n if ( send ) {\n rec = & ( ssl -> s3 -> wrec ) ;\n seq = & ( ssl -> s3 -> write_sequence [ 0 ] ) ;\n hash = ssl -> write_hash ;\n }\n else {\n rec = & ( ssl -> s3 -> rrec ) ;\n seq = & ( ssl -> s3 -> read_sequence [ 0 ] ) ;\n hash = ssl -> read_hash ;\n }\n t = EVP_MD_CTX_size ( hash ) ;\n OPENSSL_assert ( t >= 0 ) ;\n md_size = t ;\n if ( stream_mac ) {\n mac_ctx = hash ;\n }\n else {\n EVP_MD_CTX_copy ( & hmac , hash ) ;\n mac_ctx = & hmac ;\n }\n if ( ssl -> version == DTLS1_VERSION || ssl -> version == DTLS1_BAD_VER ) {\n unsigned char dtlsseq [ 8 ] , * p = dtlsseq ;\n s2n ( send ? ssl -> d1 -> w_epoch : ssl -> d1 -> r_epoch , p ) ;\n memcpy ( p , & seq [ 2 ] , 6 ) ;\n memcpy ( header , dtlsseq , 8 ) ;\n }\n else memcpy ( header , seq , 8 ) ;\n orig_len = rec -> length + md_size + ( ( unsigned int ) rec -> type >> 8 ) ;\n rec -> type &= 0xff ;\n header [ 8 ] = rec -> type ;\n header [ 9 ] = ( unsigned char ) ( ssl -> version >> 8 ) ;\n header [ 10 ] = ( unsigned char ) ( ssl -> version ) ;\n header [ 11 ] = ( rec -> length ) >> 8 ;\n header [ 12 ] = ( rec -> length ) & 0xff ;\n if ( ! send && EVP_CIPHER_CTX_mode ( ssl -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && ssl3_cbc_record_digest_supported ( mac_ctx ) ) {\n ssl3_cbc_digest_record ( mac_ctx , md , & md_size , header , rec -> input , rec -> length + md_size , orig_len , ssl -> s3 -> read_mac_secret , ssl -> s3 -> read_mac_secret_size , 0 ) ;\n }\n else {\n EVP_DigestSignUpdate ( mac_ctx , header , sizeof ( header ) ) ;\n EVP_DigestSignUpdate ( mac_ctx , rec -> input , rec -> length ) ;\n t = EVP_DigestSignFinal ( mac_ctx , md , & md_size ) ;\n OPENSSL_assert ( t > 0 ) ;\n # ifdef OPENSSL_FIPS if ( ! send && FIPS_mode ( ) ) tls_fips_digest_extra ( ssl -> enc_read_ctx , mac_ctx , rec -> input , rec -> length , orig_len ) ;\n # endif }\n if ( ! stream_mac ) EVP_MD_CTX_cleanup ( & hmac ) ;\n # ifdef TLS_DEBUG printf ( \"sec=\" ) ;\n {\n unsigned int z ;\n for ( z = 0 ;\n z < md_size ;\n z ++ ) printf ( \"%02X \" , mac_sec [ z ] ) ;\n printf ( \"\\n\" ) ;\n }\n printf ( \"seq=\" ) ;\n {\n int z ;\n for ( z = 0 ;\n z < 8 ;\n z ++ ) printf ( \"%02X \" , seq [ z ] ) ;\n printf ( \"\\n\" ) ;\n }\n printf ( \"buf=\" ) ;\n {\n int z ;\n for ( z = 0 ;\n z < 5 ;\n z ++ ) printf ( \"%02X \" , buf [ z ] ) ;\n printf ( \"\\n\" ) ;\n }\n printf ( \"rec=\" ) ;\n {\n unsigned int z ;\n for ( z = 0 ;\n z < rec -> length ;\n z ++ ) printf ( \"%02X \" , buf [ z ] ) ;\n printf ( \"\\n\" ) ;\n }\n # endif if ( ssl -> version != DTLS1_VERSION && ssl -> version != DTLS1_BAD_VER ) {\n for ( i = 7 ;\n i >= 0 ;\n i -- ) {\n ++ seq [ i ] ;\n if ( seq [ i ] != 0 ) break ;\n }\n }\n # ifdef TLS_DEBUG {\n unsigned int z ;\n for ( z = 0 ;\n z < md_size ;\n z ++ ) printf ( \"%02X \" , md [ z ] ) ;\n printf ( \"\\n\" ) ;\n }\n # endif return ( md_size ) ;\n }", "hash": 370610032569630438, "project": "debian", "size": 104, "target": 0, "idx": 12271}
{"code": "static void ImportOpacityQuantum ( const Image * image , QuantumInfo * quantum_info , const MagickSizeType number_pixels , const unsigned char * magick_restrict p , Quantum * magick_restrict q , ExceptionInfo * exception ) {\n QuantumAny range ;\n register ssize_t x ;\n unsigned int pixel ;\n assert ( image != ( Image * ) NULL ) ;\n assert ( image -> signature == MagickCoreSignature ) ;\n switch ( quantum_info -> depth ) {\n case 8 : {\n unsigned char pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushCharPixel ( p , & pixel ) ;\n SetPixelOpacity ( image , ScaleCharToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 16 : {\n unsigned short pixel ;\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelOpacity ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelOpacity ( image , ScaleShortToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 32 : {\n unsigned int pixel ;\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n float pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushFloatPixel ( quantum_info , p , & pixel ) ;\n SetPixelOpacity ( image , ClampToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelOpacity ( image , ScaleLongToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 64 : {\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n double pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushDoublePixel ( quantum_info , p , & pixel ) ;\n SetPixelOpacity ( image , ClampToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n }\n default : {\n range = GetQuantumRange ( quantum_info -> depth ) ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelOpacity ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n }\n }", "hash": 594127775011357110, "project": "debian", "size": 94, "target": 0, "idx": 12283}
{"code": "static inline const unsigned char * PushQuantumPixel ( QuantumInfo * quantum_info , const unsigned char * magick_restrict pixels , unsigned int * quantum ) {\n register ssize_t i ;\n register size_t quantum_bits ;\n * quantum = ( QuantumAny ) 0 ;\n for ( i = ( ssize_t ) quantum_info -> depth ;\n i > 0L ;\n ) {\n if ( quantum_info -> state . bits == 0UL ) {\n quantum_info -> state . pixel = ( * pixels ++ ) ;\n quantum_info -> state . bits = 8UL ;\n }\n quantum_bits = ( size_t ) i ;\n if ( quantum_bits > quantum_info -> state . bits ) quantum_bits = quantum_info -> state . bits ;\n i -= ( ssize_t ) quantum_bits ;\n quantum_info -> state . bits -= quantum_bits ;\n * quantum = ( unsigned int ) ( ( * quantum << quantum_bits ) | ( ( quantum_info -> state . pixel >> quantum_info -> state . bits ) & ~ ( ( ~ 0UL ) << quantum_bits ) ) ) ;\n }\n return ( pixels ) ;\n }", "hash": 594127775011357110, "project": "debian", "size": 19, "target": 0, "idx": 12290}
{"code": "static void ImportGrayQuantum ( const Image * image , QuantumInfo * quantum_info , const MagickSizeType number_pixels , const unsigned char * magick_restrict p , Quantum * magick_restrict q , ExceptionInfo * exception ) {\n QuantumAny range ;\n register ssize_t x ;\n ssize_t bit ;\n unsigned int pixel ;\n assert ( image != ( Image * ) NULL ) ;\n assert ( image -> signature == MagickCoreSignature ) ;\n switch ( quantum_info -> depth ) {\n case 1 : {\n register Quantum black , white ;\n black = 0 ;\n white = QuantumRange ;\n if ( quantum_info -> min_is_white != MagickFalse ) {\n black = QuantumRange ;\n white = 0 ;\n }\n for ( x = 0 ;\n x < ( ( ssize_t ) number_pixels - 7 ) ;\n x += 8 ) {\n for ( bit = 0 ;\n bit < 8 ;\n bit ++ ) {\n SetPixelGray ( image , ( ( * p ) & ( 1 << ( 7 - bit ) ) ) == 0 ? black : white , q ) ;\n q += GetPixelChannels ( image ) ;\n }\n p ++ ;\n }\n for ( bit = 0 ;\n bit < ( ssize_t ) ( number_pixels % 8 ) ;\n bit ++ ) {\n SetPixelGray ( image , ( ( * p ) & ( 0x01 << ( 7 - bit ) ) ) == 0 ? black : white , q ) ;\n q += GetPixelChannels ( image ) ;\n }\n if ( bit != 0 ) p ++ ;\n break ;\n }\n case 4 : {\n register unsigned char pixel ;\n range = GetQuantumRange ( quantum_info -> depth ) ;\n for ( x = 0 ;\n x < ( ( ssize_t ) number_pixels - 1 ) ;\n x += 2 ) {\n pixel = ( unsigned char ) ( ( * p >> 4 ) & 0xf ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n q += GetPixelChannels ( image ) ;\n pixel = ( unsigned char ) ( ( * p ) & 0xf ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n p ++ ;\n q += GetPixelChannels ( image ) ;\n }\n for ( bit = 0 ;\n bit < ( ssize_t ) ( number_pixels % 2 ) ;\n bit ++ ) {\n pixel = ( unsigned char ) ( * p ++ >> 4 ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 8 : {\n unsigned char pixel ;\n if ( quantum_info -> min_is_white != MagickFalse ) {\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushCharPixel ( p , & pixel ) ;\n SetPixelGray ( image , ScaleCharToQuantum ( pixel ) , q ) ;\n SetPixelAlpha ( image , OpaqueAlpha , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushCharPixel ( p , & pixel ) ;\n SetPixelGray ( image , ScaleCharToQuantum ( pixel ) , q ) ;\n SetPixelAlpha ( image , OpaqueAlpha , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 10 : {\n range = GetQuantumRange ( quantum_info -> depth ) ;\n if ( quantum_info -> pack == MagickFalse ) {\n if ( image -> endian == LSBEndian ) {\n for ( x = 0 ;\n x < ( ssize_t ) ( number_pixels - 2 ) ;\n x += 3 ) {\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , range ) , q ) ;\n q += GetPixelChannels ( image ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ;\n q += GetPixelChannels ( image ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , range ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n if ( x ++ < ( ssize_t ) ( number_pixels - 1 ) ) {\n SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , range ) , q ) ;\n q += GetPixelChannels ( image ) ;\n }\n if ( x ++ < ( ssize_t ) number_pixels ) {\n SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) ( number_pixels - 2 ) ;\n x += 3 ) {\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , range ) , q ) ;\n q += GetPixelChannels ( image ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ;\n q += GetPixelChannels ( image ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , range ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n if ( x ++ < ( ssize_t ) ( number_pixels - 1 ) ) {\n SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , range ) , q ) ;\n q += GetPixelChannels ( image ) ;\n }\n if ( x ++ < ( ssize_t ) number_pixels ) {\n SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , q ) ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 12 : {\n range = GetQuantumRange ( quantum_info -> depth ) ;\n if ( quantum_info -> pack == MagickFalse ) {\n unsigned short pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) ( number_pixels - 1 ) ;\n x += 2 ) {\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , range ) , q ) ;\n q += GetPixelChannels ( image ) ;\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , range ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n for ( bit = 0 ;\n bit < ( ssize_t ) ( number_pixels % 2 ) ;\n bit ++ ) {\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , range ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n if ( bit != 0 ) p ++ ;\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 16 : {\n unsigned short pixel ;\n if ( quantum_info -> min_is_white != MagickFalse ) {\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGray ( image , ScaleShortToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGray ( image , ClampToQuantum ( QuantumRange * HalfToSinglePrecision ( pixel ) ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGray ( image , ScaleShortToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 32 : {\n unsigned int pixel ;\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n float pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushFloatPixel ( quantum_info , p , & pixel ) ;\n SetPixelGray ( image , ClampToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ;\n SetPixelGray ( image , ScaleLongToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n case 64 : {\n if ( quantum_info -> format == FloatingPointQuantumFormat ) {\n double pixel ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushDoublePixel ( quantum_info , p , & pixel ) ;\n SetPixelGray ( image , ClampToQuantum ( pixel ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n }\n default : {\n range = GetQuantumRange ( quantum_info -> depth ) ;\n for ( x = 0 ;\n x < ( ssize_t ) number_pixels ;\n x ++ ) {\n p = PushQuantumPixel ( quantum_info , p , & pixel ) ;\n SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ;\n p += quantum_info -> pad ;\n q += GetPixelChannels ( image ) ;\n }\n break ;\n }\n }\n }", "hash": 594127775011357110, "project": "debian", "size": 266, "target": 0, "idx": 12291}
{"code": "static cmsBool WriteSegmentedCurve ( cmsIOHANDLER * io , cmsToneCurve * g ) {\n cmsUInt32Number i , j ;\n cmsCurveSegment * Segments = g -> Segments ;\n cmsUInt32Number nSegments = g -> nSegments ;\n if ( ! _cmsWriteUInt32Number ( io , cmsSigSegmentedCurve ) ) goto Error ;\n if ( ! _cmsWriteUInt32Number ( io , 0 ) ) goto Error ;\n if ( ! _cmsWriteUInt16Number ( io , ( cmsUInt16Number ) nSegments ) ) goto Error ;\n if ( ! _cmsWriteUInt16Number ( io , 0 ) ) goto Error ;\n for ( i = 0 ;\n i < nSegments - 1 ;\n i ++ ) {\n if ( ! _cmsWriteFloat32Number ( io , Segments [ i ] . x1 ) ) goto Error ;\n }\n for ( i = 0 ;\n i < g -> nSegments ;\n i ++ ) {\n cmsCurveSegment * ActualSeg = Segments + i ;\n if ( ActualSeg -> Type == 0 ) {\n if ( ! _cmsWriteUInt32Number ( io , ( cmsUInt32Number ) cmsSigSampledCurveSeg ) ) goto Error ;\n if ( ! _cmsWriteUInt32Number ( io , 0 ) ) goto Error ;\n if ( ! _cmsWriteUInt32Number ( io , ActualSeg -> nGridPoints ) ) goto Error ;\n for ( j = 0 ;\n j < g -> Segments [ i ] . nGridPoints ;\n j ++ ) {\n if ( ! _cmsWriteFloat32Number ( io , ActualSeg -> SampledPoints [ j ] ) ) goto Error ;\n }\n }\n else {\n int Type ;\n cmsUInt32Number ParamsByType [ ] = {\n 4 , 5 , 5 }\n ;\n if ( ! _cmsWriteUInt32Number ( io , ( cmsUInt32Number ) cmsSigFormulaCurveSeg ) ) goto Error ;\n if ( ! _cmsWriteUInt32Number ( io , 0 ) ) goto Error ;\n Type = ActualSeg -> Type - 6 ;\n if ( Type > 2 || Type < 0 ) goto Error ;\n if ( ! _cmsWriteUInt16Number ( io , ( cmsUInt16Number ) Type ) ) goto Error ;\n if ( ! _cmsWriteUInt16Number ( io , 0 ) ) goto Error ;\n for ( j = 0 ;\n j < ParamsByType [ Type ] ;\n j ++ ) {\n if ( ! _cmsWriteFloat32Number ( io , ( cmsFloat32Number ) ActualSeg -> Params [ j ] ) ) goto Error ;\n }\n }\n }\n return TRUE ;\n Error : return FALSE ;\n }", "hash": -1929262071302712016, "project": "debian", "size": 48, "target": 0, "idx": 12312}
{"code": "static void * Type_ColorantOrderType_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {\n cmsUInt8Number * ColorantOrder ;\n cmsUInt32Number Count ;\n * nItems = 0 ;\n if ( ! _cmsReadUInt32Number ( io , & Count ) ) return NULL ;\n if ( Count > cmsMAXCHANNELS ) return NULL ;\n ColorantOrder = ( cmsUInt8Number * ) _cmsCalloc ( self -> ContextID , cmsMAXCHANNELS , sizeof ( cmsUInt8Number ) ) ;\n if ( ColorantOrder == NULL ) return NULL ;\n memset ( ColorantOrder , 0xFF , cmsMAXCHANNELS * sizeof ( cmsUInt8Number ) ) ;\n if ( io -> Read ( io , ColorantOrder , sizeof ( cmsUInt8Number ) , Count ) != Count ) {\n _cmsFree ( self -> ContextID , ( void * ) ColorantOrder ) ;\n return NULL ;\n }\n * nItems = 1 ;\n return ( void * ) ColorantOrder ;\n cmsUNUSED_PARAMETER ( SizeOfTag ) ;\n }", "hash": -1929262071302712016, "project": "debian", "size": 17, "target": 0, "idx": 12318}
{"code": "static cmsBool Type_ColorantTable_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsNAMEDCOLORLIST * NamedColorList = ( cmsNAMEDCOLORLIST * ) Ptr ;\n int i , nColors ;\n nColors = cmsNamedColorCount ( NamedColorList ) ;\n if ( ! _cmsWriteUInt32Number ( io , nColors ) ) return FALSE ;\n for ( i = 0 ;\n i < nColors ;\n i ++ ) {\n char root [ 33 ] ;\n cmsUInt16Number PCS [ 3 ] ;\n if ( ! cmsNamedColorInfo ( NamedColorList , i , root , NULL , NULL , PCS , NULL ) ) return 0 ;\n root [ 32 ] = 0 ;\n if ( ! io -> Write ( io , 32 , root ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Array ( io , 3 , PCS ) ) return FALSE ;\n }\n return TRUE ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "hash": -1929262071302712016, "project": "debian", "size": 19, "target": 0, "idx": 12323}
{"code": "static cmsBool WriteMatrix ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsStage * mpe ) {\n _cmsStageMatrixData * m = ( _cmsStageMatrixData * ) mpe -> Data ;\n if ( ! _cmsWrite15Fixed16Number ( io , m -> Double [ 0 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , m -> Double [ 1 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , m -> Double [ 2 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , m -> Double [ 3 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , m -> Double [ 4 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , m -> Double [ 5 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , m -> Double [ 6 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , m -> Double [ 7 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , m -> Double [ 8 ] ) ) return FALSE ;\n if ( m -> Offset != NULL ) {\n if ( ! _cmsWrite15Fixed16Number ( io , m -> Offset [ 0 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , m -> Offset [ 1 ] ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , m -> Offset [ 2 ] ) ) return FALSE ;\n }\n else {\n if ( ! _cmsWrite15Fixed16Number ( io , 0 ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , 0 ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , 0 ) ) return FALSE ;\n }\n return TRUE ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "hash": -1929262071302712016, "project": "debian", "size": 24, "target": 0, "idx": 12331}
{"code": "static cmsBool ReadOneWChar ( cmsIOHANDLER * io , _cmsDICelem * e , cmsUInt32Number i , wchar_t * * wcstr ) {\n cmsUInt32Number nChars ;\n if ( e -> Offsets [ i ] == 0 ) {\n * wcstr = NULL ;\n return TRUE ;\n }\n if ( ! io -> Seek ( io , e -> Offsets [ i ] ) ) return FALSE ;\n nChars = e -> Sizes [ i ] / sizeof ( cmsUInt16Number ) ;\n * wcstr = ( wchar_t * ) _cmsMallocZero ( e -> ContextID , ( nChars + 1 ) * sizeof ( wchar_t ) ) ;\n if ( * wcstr == NULL ) return FALSE ;\n if ( ! _cmsReadWCharArray ( io , nChars , * wcstr ) ) {\n _cmsFree ( e -> ContextID , * wcstr ) ;\n return FALSE ;\n }\n ( * wcstr ) [ nChars ] = 0 ;\n return TRUE ;\n }", "hash": -1929262071302712016, "project": "debian", "size": 17, "target": 0, "idx": 12345}
{"code": "cmsTagTypeHandler * _cmsGetTagTypeHandler ( cmsContext ContextID , cmsTagTypeSignature sig ) {\n _cmsTagTypePluginChunkType * ctx = ( _cmsTagTypePluginChunkType * ) _cmsContextGetClientChunk ( ContextID , TagTypePlugin ) ;\n return GetHandler ( sig , ctx -> TagTypes , SupportedTagTypes ) ;\n }", "hash": -1929262071302712016, "project": "debian", "size": 4, "target": 0, "idx": 12356}
{"code": "static void Type_vcgt_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n cmsFreeToneCurveTriple ( ( cmsToneCurve * * ) Ptr ) ;\n _cmsFree ( self -> ContextID , Ptr ) ;\n }", "hash": -1929262071302712016, "project": "debian", "size": 4, "target": 0, "idx": 12389}
{"code": "static cmsBool Type_MPEclut_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsUInt8Number Dimensions8 [ 16 ] ;\n cmsUInt32Number i ;\n cmsStage * mpe = ( cmsStage * ) Ptr ;\n _cmsStageCLutData * clut = ( _cmsStageCLutData * ) mpe -> Data ;\n if ( mpe -> InputChannels > MAX_INPUT_DIMENSIONS ) return FALSE ;\n if ( clut -> HasFloatValues == FALSE ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , ( cmsUInt16Number ) mpe -> InputChannels ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , ( cmsUInt16Number ) mpe -> OutputChannels ) ) return FALSE ;\n memset ( Dimensions8 , 0 , sizeof ( Dimensions8 ) ) ;\n for ( i = 0 ;\n i < mpe -> InputChannels ;\n i ++ ) Dimensions8 [ i ] = ( cmsUInt8Number ) clut -> Params -> nSamples [ i ] ;\n if ( ! io -> Write ( io , 16 , Dimensions8 ) ) return FALSE ;\n for ( i = 0 ;\n i < clut -> nEntries ;\n i ++ ) {\n if ( ! _cmsWriteFloat32Number ( io , clut -> Tab . TFloat [ i ] ) ) return FALSE ;\n }\n return TRUE ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "hash": -1929262071302712016, "project": "debian", "size": 23, "target": 0, "idx": 12394}
{"code": "static cmsBool Type_vcgt_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsToneCurve * * Curves = ( cmsToneCurve * * ) Ptr ;\n cmsUInt32Number i , j ;\n if ( cmsGetToneCurveParametricType ( Curves [ 0 ] ) == 5 && cmsGetToneCurveParametricType ( Curves [ 1 ] ) == 5 && cmsGetToneCurveParametricType ( Curves [ 2 ] ) == 5 ) {\n if ( ! _cmsWriteUInt32Number ( io , cmsVideoCardGammaFormulaType ) ) return FALSE ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n _cmsVCGTGAMMA v ;\n v . Gamma = Curves [ i ] -> Segments [ 0 ] . Params [ 0 ] ;\n v . Min = Curves [ i ] -> Segments [ 0 ] . Params [ 5 ] ;\n v . Max = pow ( Curves [ i ] -> Segments [ 0 ] . Params [ 1 ] , v . Gamma ) + v . Min ;\n if ( ! _cmsWrite15Fixed16Number ( io , v . Gamma ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , v . Min ) ) return FALSE ;\n if ( ! _cmsWrite15Fixed16Number ( io , v . Max ) ) return FALSE ;\n }\n }\n else {\n if ( ! _cmsWriteUInt32Number ( io , cmsVideoCardGammaTableType ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , 3 ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , 256 ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , 2 ) ) return FALSE ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n for ( j = 0 ;\n j < 256 ;\n j ++ ) {\n cmsFloat32Number v = cmsEvalToneCurveFloat ( Curves [ i ] , ( cmsFloat32Number ) ( j / 255.0 ) ) ;\n cmsUInt16Number n = _cmsQuickSaturateWord ( v * 65535.0 ) ;\n if ( ! _cmsWriteUInt16Number ( io , n ) ) return FALSE ;\n }\n }\n }\n return TRUE ;\n cmsUNUSED_PARAMETER ( self ) ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n }", "hash": -1929262071302712016, "project": "debian", "size": 38, "target": 0, "idx": 12427}
{"code": "static void * Type_LUTA2B_Dup ( struct _cms_typehandler_struct * self , const void * Ptr , cmsUInt32Number n ) {\n return ( void * ) cmsPipelineDup ( ( cmsPipeline * ) Ptr ) ;\n cmsUNUSED_PARAMETER ( n ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "hash": -1929262071302712016, "project": "debian", "size": 5, "target": 0, "idx": 12450}
{"code": "static cmsBool WriteOffsetArray ( cmsIOHANDLER * io , _cmsDICarray * a , cmsUInt32Number Count , cmsUInt32Number Length ) {\n cmsUInt32Number i ;\n for ( i = 0 ;\n i < Count ;\n i ++ ) {\n if ( ! WriteOneElem ( io , & a -> Name , i ) ) return FALSE ;\n if ( ! WriteOneElem ( io , & a -> Value , i ) ) return FALSE ;\n if ( Length > 16 ) {\n if ( ! WriteOneElem ( io , & a -> DisplayName , i ) ) return FALSE ;\n }\n if ( Length > 24 ) {\n if ( ! WriteOneElem ( io , & a -> DisplayValue , i ) ) return FALSE ;\n }\n }\n return TRUE ;\n }", "hash": -1929262071302712016, "project": "debian", "size": 16, "target": 0, "idx": 12458}
{"code": "static cmsBool Write8bitTables ( cmsContext ContextID , cmsIOHANDLER * io , cmsUInt32Number n , _cmsStageToneCurvesData * Tables ) {\n int j ;\n cmsUInt32Number i ;\n cmsUInt8Number val ;\n for ( i = 0 ;\n i < n ;\n i ++ ) {\n if ( Tables ) {\n if ( ( Tables -> TheCurves [ i ] -> nEntries == 2 ) && ( Tables -> TheCurves [ i ] -> Table16 [ 0 ] == 0 ) && ( Tables -> TheCurves [ i ] -> Table16 [ 1 ] == 65535 ) ) {\n for ( j = 0 ;\n j < 256 ;\n j ++ ) {\n if ( ! _cmsWriteUInt8Number ( io , ( cmsUInt8Number ) j ) ) return FALSE ;\n }\n }\n else if ( Tables -> TheCurves [ i ] -> nEntries != 256 ) {\n cmsSignalError ( ContextID , cmsERROR_RANGE , \"LUT8 needs 256 entries on prelinearization\" ) ;\n return FALSE ;\n }\n else for ( j = 0 ;\n j < 256 ;\n j ++ ) {\n val = ( cmsUInt8Number ) FROM_16_TO_8 ( Tables -> TheCurves [ i ] -> Table16 [ j ] ) ;\n if ( ! _cmsWriteUInt8Number ( io , val ) ) return FALSE ;\n }\n }\n }\n return TRUE ;\n }", "hash": -1929262071302712016, "project": "debian", "size": 29, "target": 0, "idx": 12465}
{"code": "void _cmsAllocTagTypePluginChunk ( struct _cmsContext_struct * ctx , const struct _cmsContext_struct * src ) {\n if ( src != NULL ) {\n DupTagTypeList ( ctx , src , TagTypePlugin ) ;\n }\n else {\n static _cmsTagTypePluginChunkType TagTypePluginChunk = {\n NULL }\n ;\n ctx -> chunks [ TagTypePlugin ] = _cmsSubAllocDup ( ctx -> MemPool , & TagTypePluginChunk , sizeof ( _cmsTagTypePluginChunkType ) ) ;\n }\n }", "hash": -1929262071302712016, "project": "debian", "size": 11, "target": 0, "idx": 12475}
{"code": "static cmsBool Type_Chromaticity_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n cmsCIExyYTRIPLE * chrm = ( cmsCIExyYTRIPLE * ) Ptr ;\n if ( ! _cmsWriteUInt16Number ( io , 3 ) ) return FALSE ;\n if ( ! _cmsWriteUInt16Number ( io , 0 ) ) return FALSE ;\n if ( ! SaveOneChromaticity ( chrm -> Red . x , chrm -> Red . y , io ) ) return FALSE ;\n if ( ! SaveOneChromaticity ( chrm -> Green . x , chrm -> Green . y , io ) ) return FALSE ;\n if ( ! SaveOneChromaticity ( chrm -> Blue . x , chrm -> Blue . y , io ) ) return FALSE ;\n return TRUE ;\n cmsUNUSED_PARAMETER ( nItems ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }", "hash": -1929262071302712016, "project": "debian", "size": 11, "target": 0, "idx": 12478}
{"code": "static inline Quantum ClampPixel ( const MagickRealType value ) {\n # if ! defined ( MAGICKCORE_HDRI_SUPPORT ) return ( ( Quantum ) value ) ;\n # else if ( value < 0.0 ) return ( ( Quantum ) 0.0 ) ;\n if ( value >= ( MagickRealType ) QuantumRange ) return ( ( Quantum ) QuantumRange ) ;\n return ( ( Quantum ) value ) ;\n # endif }", "hash": 313627013719508831, "project": "debian", "size": 6, "target": 0, "idx": 12488}
{"code": "static inline Quantum GetPixelAlpha ( const Image * restrict image , const Quantum * restrict pixel ) {\n if ( image -> channel_map [ AlphaPixelChannel ] . traits == UndefinedPixelTrait ) return ( OpaqueAlpha ) ;\n return ( pixel [ image -> channel_map [ AlphaPixelChannel ] . offset ] ) ;\n }", "hash": 313627013719508831, "project": "debian", "size": 4, "target": 0, "idx": 12490}
{"code": "static inline void SetPixelGrayTraits ( Image * image , const PixelTrait traits ) {\n image -> channel_map [ GrayPixelChannel ] . traits = traits ;\n }", "hash": 313627013719508831, "project": "debian", "size": 3, "target": 0, "idx": 12503}
{"code": "static inline Quantum GetPixelRed ( const Image * restrict image , const Quantum * restrict pixel ) {\n return ( pixel [ image -> channel_map [ RedPixelChannel ] . offset ] ) ;\n }", "hash": 313627013719508831, "project": "debian", "size": 3, "target": 0, "idx": 12512}
{"code": "static inline PixelTrait GetPixelReadMaskTraits ( const Image * restrict image ) {\n return ( image -> channel_map [ ReadMaskPixelChannel ] . traits ) ;\n }", "hash": 313627013719508831, "project": "debian", "size": 3, "target": 0, "idx": 12520}
{"code": "static inline void SetPixelAlphaTraits ( Image * image , const PixelTrait traits ) {\n image -> channel_map [ AlphaPixelChannel ] . traits = traits ;\n }", "hash": 313627013719508831, "project": "debian", "size": 3, "target": 0, "idx": 12526}
{"code": "static inline void SetPixelReadMask ( const Image * restrict image , const Quantum mask , Quantum * restrict pixel ) {\n if ( image -> channel_map [ ReadMaskPixelChannel ] . traits != UndefinedPixelTrait ) pixel [ image -> channel_map [ ReadMaskPixelChannel ] . offset ] = mask ;\n }", "hash": 313627013719508831, "project": "debian", "size": 3, "target": 0, "idx": 12538}
{"code": "static inline void SetPixelBlueTraits ( Image * image , const PixelTrait traits ) {\n image -> channel_map [ BluePixelChannel ] . traits = traits ;\n }", "hash": 313627013719508831, "project": "debian", "size": 3, "target": 0, "idx": 12539}
{"code": "static inline Quantum GetPixelY ( const Image * restrict image , const Quantum * restrict pixel ) {\n return ( pixel [ image -> channel_map [ YPixelChannel ] . offset ] ) ;\n }", "hash": 313627013719508831, "project": "debian", "size": 3, "target": 0, "idx": 12547}
{"code": "static inline void SetPixelChannelTraits ( Image * image , const PixelChannel channel , const PixelTrait traits ) {\n image -> channel_map [ channel ] . traits = traits ;\n }", "hash": 313627013719508831, "project": "debian", "size": 3, "target": 0, "idx": 12555}
{"code": "static inline void SetPixelIndex ( const Image * restrict image , const Quantum index , Quantum * restrict pixel ) {\n if ( image -> channel_map [ IndexPixelChannel ] . traits != UndefinedPixelTrait ) pixel [ image -> channel_map [ IndexPixelChannel ] . offset ] = index ;\n }", "hash": 313627013719508831, "project": "debian", "size": 3, "target": 0, "idx": 12568}
{"code": "static bool Curl_isunreserved ( unsigned char in ) {\n switch ( in ) {\n case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : case 'g' : case 'h' : case 'i' : case 'j' : case 'k' : case 'l' : case 'm' : case 'n' : case 'o' : case 'p' : case 'q' : case 'r' : case 's' : case 't' : case 'u' : case 'v' : case 'w' : case 'x' : case 'y' : case 'z' : case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : case 'H' : case 'I' : case 'J' : case 'K' : case 'L' : case 'M' : case 'N' : case 'O' : case 'P' : case 'Q' : case 'R' : case 'S' : case 'T' : case 'U' : case 'V' : case 'W' : case 'X' : case 'Y' : case 'Z' : case '-' : case '.' : case '_' : case '~' : return TRUE ;\n default : break ;\n }\n return FALSE ;\n }", "hash": -7549575329765818478, "project": "debian", "size": 7, "target": 0, "idx": 12589}
{"code": "static gboolean k12_dump ( wtap_dumper * wdh , const struct wtap_pkthdr * phdr , const guint8 * pd , int * err , gchar * * err_info _U_ ) {\n const union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ;\n k12_dump_t * k12 = ( k12_dump_t * ) wdh -> priv ;\n guint32 len ;\n union {\n guint8 buffer [ 8192 ] ;\n struct {\n guint32 len ;\n guint32 type ;\n guint32 frame_len ;\n guint32 input ;\n guint32 datum_1 ;\n guint32 datum_2 ;\n guint64 ts ;\n guint8 frame [ 0x1fc0 ] ;\n }\n record ;\n }\n obj ;\n if ( phdr -> rec_type != REC_TYPE_PACKET ) {\n * err = WTAP_ERR_UNWRITABLE_REC_TYPE ;\n return FALSE ;\n }\n if ( k12 -> num_of_records == 0 ) {\n k12_t * file_data = ( k12_t * ) pseudo_header -> k12 . stuff ;\n g_hash_table_foreach ( file_data -> src_by_id , k12_dump_src_setting , wdh ) ;\n }\n obj . record . len = 0x20 + phdr -> caplen ;\n obj . record . len += ( obj . record . len % 4 ) ? 4 - obj . record . len % 4 : 0 ;\n len = obj . record . len ;\n obj . record . len = g_htonl ( obj . record . len ) ;\n obj . record . type = g_htonl ( K12_REC_PACKET ) ;\n obj . record . frame_len = g_htonl ( phdr -> caplen ) ;\n obj . record . input = g_htonl ( pseudo_header -> k12 . input ) ;\n obj . record . ts = GUINT64_TO_BE ( ( ( ( guint64 ) phdr -> ts . secs - 631152000 ) * 2000000 ) + ( phdr -> ts . nsecs / 1000 * 2 ) ) ;\n memcpy ( obj . record . frame , pd , phdr -> caplen ) ;\n return k12_dump_record ( wdh , len , obj . buffer , err ) ;\n }", "hash": -5511323081862746166, "project": "debian", "size": 38, "target": 0, "idx": 12601}
{"code": "static uint32_t e1000e_mac_icr_read ( E1000ECore * core , int index ) {\n uint32_t ret = core -> mac [ ICR ] ;\n trace_e1000e_irq_icr_read_entry ( ret ) ;\n if ( core -> mac [ IMS ] == 0 ) {\n trace_e1000e_irq_icr_clear_zero_ims ( ) ;\n core -> mac [ ICR ] = 0 ;\n }\n if ( ( core -> mac [ ICR ] & E1000_ICR_ASSERTED ) && ( core -> mac [ CTRL_EXT ] & E1000_CTRL_EXT_IAME ) ) {\n trace_e1000e_irq_icr_clear_iame ( ) ;\n core -> mac [ ICR ] = 0 ;\n trace_e1000e_irq_icr_process_iame ( ) ;\n e1000e_clear_ims_bits ( core , core -> mac [ IAM ] ) ;\n }\n trace_e1000e_irq_icr_read_exit ( core -> mac [ ICR ] ) ;\n e1000e_update_interrupt_state ( core ) ;\n return ret ;\n }", "hash": 5357882892791796049, "project": "debian", "size": 17, "target": 0, "idx": 12614}
{"code": "static void e1000e_set_ctrl ( E1000ECore * core , int index , uint32_t val ) {\n trace_e1000e_core_ctrl_write ( index , val ) ;\n core -> mac [ CTRL ] = val & ~ E1000_CTRL_RST ;\n core -> mac [ CTRL_DUP ] = core -> mac [ CTRL ] ;\n trace_e1000e_link_set_params ( ! ! ( val & E1000_CTRL_ASDE ) , ( val & E1000_CTRL_SPD_SEL ) >> E1000_CTRL_SPD_SHIFT , ! ! ( val & E1000_CTRL_FRCSPD ) , ! ! ( val & E1000_CTRL_FRCDPX ) , ! ! ( val & E1000_CTRL_RFCE ) , ! ! ( val & E1000_CTRL_TFCE ) ) ;\n if ( val & E1000_CTRL_RST ) {\n trace_e1000e_core_ctrl_sw_reset ( ) ;\n e1000x_reset_mac_addr ( core -> owner_nic , core -> mac , core -> permanent_mac ) ;\n }\n if ( val & E1000_CTRL_PHY_RST ) {\n trace_e1000e_core_ctrl_phy_reset ( ) ;\n core -> mac [ STATUS ] |= E1000_STATUS_PHYRA ;\n }\n }", "hash": 5357882892791796049, "project": "debian", "size": 14, "target": 0, "idx": 12630}
{"code": "static inline bool e1000e_ring_empty ( E1000ECore * core , const E1000E_RingInfo * r ) {\n return core -> mac [ r -> dh ] == core -> mac [ r -> dt ] || core -> mac [ r -> dt ] >= core -> mac [ r -> dlen ] / E1000_RING_DESC_LEN ;\n }", "hash": 5357882892791796049, "project": "debian", "size": 3, "target": 0, "idx": 12646}
{"code": "static uint32_t e1000e_get_tarc ( E1000ECore * core , int index ) {\n return core -> mac [ index ] & ( ( BIT ( 11 ) - 1 ) | BIT ( 27 ) | BIT ( 28 ) | BIT ( 29 ) | BIT ( 30 ) ) ;\n }", "hash": 5357882892791796049, "project": "debian", "size": 3, "target": 0, "idx": 12659}
{"code": "static inline void e1000e_fix_icr_asserted ( E1000ECore * core ) {\n core -> mac [ ICR ] &= ~ E1000_ICR_ASSERTED ;\n if ( core -> mac [ ICR ] ) {\n core -> mac [ ICR ] |= E1000_ICR_ASSERTED ;\n }\n trace_e1000e_irq_fix_icr_asserted ( core -> mac [ ICR ] ) ;\n }", "hash": 5357882892791796049, "project": "debian", "size": 7, "target": 0, "idx": 12664}
{"code": "static void e1000e_intrmgr_on_timer ( void * opaque ) {\n E1000IntrDelayTimer * timer = opaque ;\n trace_e1000e_irq_throttling_timer ( timer -> delay_reg << 2 ) ;\n timer -> running = false ;\n e1000e_intrmgr_fire_delayed_interrupts ( timer -> core ) ;\n }", "hash": 5357882892791796049, "project": "debian", "size": 6, "target": 0, "idx": 12670}
{"code": "static void e1000e_set_status ( E1000ECore * core , int index , uint32_t val ) {\n if ( ( val & E1000_STATUS_PHYRA ) == 0 ) {\n core -> mac [ index ] &= ~ E1000_STATUS_PHYRA ;\n }\n }", "hash": 5357882892791796049, "project": "debian", "size": 5, "target": 0, "idx": 12671}
{"code": "static void e1000e_set_interrupt_cause ( E1000ECore * core , uint32_t val ) {\n trace_e1000e_irq_set_cause_entry ( val , core -> mac [ ICR ] ) ;\n val |= e1000e_intmgr_collect_delayed_causes ( core ) ;\n core -> mac [ ICR ] |= val ;\n trace_e1000e_irq_set_cause_exit ( val , core -> mac [ ICR ] ) ;\n e1000e_update_interrupt_state ( core ) ;\n }", "hash": 5357882892791796049, "project": "debian", "size": 7, "target": 0, "idx": 12672}
{"code": "static void e1000e_intrmgr_fire_all_timers ( E1000ECore * core ) {\n int i ;\n uint32_t val = e1000e_intmgr_collect_delayed_causes ( core ) ;\n trace_e1000e_irq_adding_delayed_causes ( val , core -> mac [ ICR ] ) ;\n core -> mac [ ICR ] |= val ;\n if ( core -> itr . running ) {\n timer_del ( core -> itr . timer ) ;\n e1000e_intrmgr_on_throttling_timer ( & core -> itr ) ;\n }\n for ( i = 0 ;\n i < E1000E_MSIX_VEC_NUM ;\n i ++ ) {\n if ( core -> eitr [ i ] . running ) {\n timer_del ( core -> eitr [ i ] . timer ) ;\n e1000e_intrmgr_on_msix_throttling_timer ( & core -> eitr [ i ] ) ;\n }\n }\n }", "hash": 5357882892791796049, "project": "debian", "size": 18, "target": 0, "idx": 12674}
{"code": "static void e1000e_update_interrupt_state ( E1000ECore * core ) {\n bool interrupts_pending ;\n bool is_msix = msix_enabled ( core -> owner ) ;\n if ( is_msix ) {\n if ( core -> mac [ ICR ] & E1000_ICR_OTHER_CAUSES ) {\n core -> mac [ ICR ] |= E1000_ICR_OTHER ;\n trace_e1000e_irq_add_msi_other ( core -> mac [ ICR ] ) ;\n }\n }\n e1000e_fix_icr_asserted ( core ) ;\n core -> mac [ ICS ] = core -> mac [ ICR ] ;\n interrupts_pending = ( core -> mac [ IMS ] & core -> mac [ ICR ] ) ? true : false ;\n trace_e1000e_irq_pending_interrupts ( core -> mac [ ICR ] & core -> mac [ IMS ] , core -> mac [ ICR ] , core -> mac [ IMS ] ) ;\n if ( is_msix || msi_enabled ( core -> owner ) ) {\n if ( interrupts_pending ) {\n e1000e_send_msi ( core , is_msix ) ;\n }\n }\n else {\n if ( interrupts_pending ) {\n if ( ! e1000e_itr_should_postpone ( core ) ) {\n e1000e_raise_legacy_irq ( core ) ;\n }\n }\n else {\n e1000e_lower_legacy_irq ( core ) ;\n }\n }\n }", "hash": 5357882892791796049, "project": "debian", "size": 29, "target": 0, "idx": 12678}
{"code": "int e1000e_core_post_load ( E1000ECore * core ) {\n NetClientState * nc = qemu_get_queue ( core -> owner_nic ) ;\n nc -> link_down = ( core -> mac [ STATUS ] & E1000_STATUS_LU ) == 0 ;\n return 0 ;\n }", "hash": 5357882892791796049, "project": "debian", "size": 5, "target": 0, "idx": 12681}
{"code": "static inline bool e1000e_rx_descr_threshold_hit ( E1000ECore * core , const E1000E_RingInfo * rxi ) {\n return e1000e_ring_free_descr_num ( core , rxi ) == e1000e_ring_len ( core , rxi ) >> core -> rxbuf_min_shift ;\n }", "hash": 5357882892791796049, "project": "debian", "size": 3, "target": 0, "idx": 12700}
{"code": "static inline void e1000e_write_lgcy_rx_descr ( E1000ECore * core , uint8_t * desc , struct NetRxPkt * pkt , const E1000E_RSSInfo * rss_info , uint16_t length ) {\n uint32_t status_flags , rss , mrq ;\n uint16_t ip_id ;\n struct e1000_rx_desc * d = ( struct e1000_rx_desc * ) desc ;\n assert ( ! rss_info -> enabled ) ;\n d -> length = cpu_to_le16 ( length ) ;\n d -> csum = 0 ;\n e1000e_build_rx_metadata ( core , pkt , pkt != NULL , rss_info , & rss , & mrq , & status_flags , & ip_id , & d -> special ) ;\n d -> errors = ( uint8_t ) ( le32_to_cpu ( status_flags ) >> 24 ) ;\n d -> status = ( uint8_t ) le32_to_cpu ( status_flags ) ;\n d -> special = 0 ;\n }", "hash": 5357882892791796049, "project": "debian", "size": 12, "target": 0, "idx": 12707}
{"code": "static void e1000e_intmgr_timer_resume ( E1000IntrDelayTimer * timer ) {\n if ( timer -> running ) {\n e1000e_intrmgr_rearm_timer ( timer ) ;\n }\n }", "hash": 5357882892791796049, "project": "debian", "size": 5, "target": 0, "idx": 12712}
{"code": "static void e1000e_intmgr_timer_pause ( E1000IntrDelayTimer * timer ) {\n if ( timer -> running ) {\n timer_del ( timer -> timer ) ;\n }\n }", "hash": 5357882892791796049, "project": "debian", "size": 5, "target": 0, "idx": 12713}
{"code": "static void e1000e_set_mdic ( E1000ECore * core , int index , uint32_t val ) {\n uint32_t data = val & E1000_MDIC_DATA_MASK ;\n uint32_t addr = ( ( val & E1000_MDIC_REG_MASK ) >> E1000_MDIC_REG_SHIFT ) ;\n uint8_t page ;\n if ( ( val & E1000_MDIC_PHY_MASK ) >> E1000_MDIC_PHY_SHIFT != 1 ) {\n val = core -> mac [ MDIC ] | E1000_MDIC_ERROR ;\n }\n else if ( val & E1000_MDIC_OP_READ ) {\n if ( ! e1000e_phy_reg_check_cap ( core , addr , PHY_R , & page ) ) {\n trace_e1000e_core_mdic_read_unhandled ( page , addr ) ;\n val |= E1000_MDIC_ERROR ;\n }\n else {\n val = ( val ^ data ) | core -> phy [ page ] [ addr ] ;\n trace_e1000e_core_mdic_read ( page , addr , val ) ;\n }\n }\n else if ( val & E1000_MDIC_OP_WRITE ) {\n if ( ! e1000e_phy_reg_check_cap ( core , addr , PHY_W , & page ) ) {\n trace_e1000e_core_mdic_write_unhandled ( page , addr ) ;\n val |= E1000_MDIC_ERROR ;\n }\n else {\n trace_e1000e_core_mdic_write ( page , addr , data ) ;\n e1000e_phy_reg_write ( core , page , addr , data ) ;\n }\n }\n core -> mac [ MDIC ] = val | E1000_MDIC_READY ;\n if ( val & E1000_MDIC_INT_EN ) {\n e1000e_set_interrupt_cause ( core , E1000_ICR_MDAC ) ;\n }\n }", "hash": 5357882892791796049, "project": "debian", "size": 32, "target": 0, "idx": 12716}
{"code": "static inline bool e1000e_is_tcp_ack ( E1000ECore * core , struct NetRxPkt * rx_pkt ) {\n if ( ! net_rx_pkt_is_tcp_ack ( rx_pkt ) ) {\n return false ;\n }\n if ( core -> mac [ RFCTL ] & E1000_RFCTL_ACK_DATA_DIS ) {\n return ! net_rx_pkt_has_tcp_data ( rx_pkt ) ;\n }\n return true ;\n }", "hash": 5357882892791796049, "project": "debian", "size": 9, "target": 0, "idx": 12721}
{"code": "static void e1000e_set_ctrlext ( E1000ECore * core , int index , uint32_t val ) {\n trace_e1000e_link_set_ext_params ( ! ! ( val & E1000_CTRL_EXT_ASDCHK ) , ! ! ( val & E1000_CTRL_EXT_SPD_BYPS ) ) ;\n val &= ~ ( E1000_CTRL_EXT_ASDCHK | E1000_CTRL_EXT_EE_RST ) ;\n core -> mac [ CTRL_EXT ] = val ;\n }", "hash": 5357882892791796049, "project": "debian", "size": 5, "target": 0, "idx": 12753}
{"code": "static void e1000e_write_packet_to_guest ( E1000ECore * core , struct NetRxPkt * pkt , const E1000E_RxRing * rxr , const E1000E_RSSInfo * rss_info ) {\n PCIDevice * d = core -> owner ;\n dma_addr_t base ;\n uint8_t desc [ E1000_MAX_RX_DESC_LEN ] ;\n size_t desc_size ;\n size_t desc_offset = 0 ;\n size_t iov_ofs = 0 ;\n struct iovec * iov = net_rx_pkt_get_iovec ( pkt ) ;\n size_t size = net_rx_pkt_get_total_len ( pkt ) ;\n size_t total_size = size + e1000x_fcs_len ( core -> mac ) ;\n const E1000E_RingInfo * rxi ;\n size_t ps_hdr_len = 0 ;\n bool do_ps = e1000e_do_ps ( core , pkt , & ps_hdr_len ) ;\n bool is_first = true ;\n rxi = rxr -> i ;\n do {\n hwaddr ba [ MAX_PS_BUFFERS ] ;\n e1000e_ba_state bastate = {\n {\n 0 }\n }\n ;\n bool is_last = false ;\n desc_size = total_size - desc_offset ;\n if ( desc_size > core -> rx_desc_buf_size ) {\n desc_size = core -> rx_desc_buf_size ;\n }\n if ( e1000e_ring_empty ( core , rxi ) ) {\n return ;\n }\n base = e1000e_ring_head_descr ( core , rxi ) ;\n pci_dma_read ( d , base , & desc , core -> rx_desc_len ) ;\n trace_e1000e_rx_descr ( rxi -> idx , base , core -> rx_desc_len ) ;\n e1000e_read_rx_descr ( core , desc , & ba ) ;\n if ( ba [ 0 ] ) {\n if ( desc_offset < size ) {\n static const uint32_t fcs_pad ;\n size_t iov_copy ;\n size_t copy_size = size - desc_offset ;\n if ( copy_size > core -> rx_desc_buf_size ) {\n copy_size = core -> rx_desc_buf_size ;\n }\n if ( do_ps ) {\n if ( is_first ) {\n size_t ps_hdr_copied = 0 ;\n do {\n iov_copy = MIN ( ps_hdr_len - ps_hdr_copied , iov -> iov_len - iov_ofs ) ;\n e1000e_write_hdr_to_rx_buffers ( core , & ba , & bastate , iov -> iov_base , iov_copy ) ;\n copy_size -= iov_copy ;\n ps_hdr_copied += iov_copy ;\n iov_ofs += iov_copy ;\n if ( iov_ofs == iov -> iov_len ) {\n iov ++ ;\n iov_ofs = 0 ;\n }\n }\n while ( ps_hdr_copied < ps_hdr_len ) ;\n is_first = false ;\n }\n else {\n e1000e_write_hdr_to_rx_buffers ( core , & ba , & bastate , NULL , 0 ) ;\n }\n }\n while ( copy_size ) {\n iov_copy = MIN ( copy_size , iov -> iov_len - iov_ofs ) ;\n e1000e_write_to_rx_buffers ( core , & ba , & bastate , iov -> iov_base + iov_ofs , iov_copy ) ;\n copy_size -= iov_copy ;\n iov_ofs += iov_copy ;\n if ( iov_ofs == iov -> iov_len ) {\n iov ++ ;\n iov_ofs = 0 ;\n }\n }\n if ( desc_offset + desc_size >= total_size ) {\n e1000e_write_to_rx_buffers ( core , & ba , & bastate , ( const char * ) & fcs_pad , e1000x_fcs_len ( core -> mac ) ) ;\n }\n }\n desc_offset += desc_size ;\n if ( desc_offset >= total_size ) {\n is_last = true ;\n }\n }\n else {\n trace_e1000e_rx_null_descriptor ( ) ;\n }\n e1000e_write_rx_descr ( core , desc , is_last ? core -> rx_pkt : NULL , rss_info , do_ps ? ps_hdr_len : 0 , & bastate . written ) ;\n pci_dma_write ( d , base , & desc , core -> rx_desc_len ) ;\n e1000e_ring_advance ( core , rxi , core -> rx_desc_len / E1000_MIN_RX_DESC_LEN ) ;\n }\n while ( desc_offset < total_size ) ;\n e1000e_update_rx_stats ( core , size , total_size ) ;\n }", "hash": 5357882892791796049, "project": "debian", "size": 92, "target": 0, "idx": 12756}
{"code": "static void e1000e_set_phy_oem_bits ( E1000ECore * core , int index , uint16_t val ) {\n core -> phy [ 0 ] [ PHY_OEM_BITS ] = val & ~ BIT ( 10 ) ;\n if ( val & BIT ( 10 ) ) {\n e1000x_restart_autoneg ( core -> mac , core -> phy [ 0 ] , core -> autoneg_timer ) ;\n }\n }", "hash": 5357882892791796049, "project": "debian", "size": 6, "target": 0, "idx": 12760}
{"code": "static inline bool e1000e_rx_use_legacy_descriptor ( E1000ECore * core ) {\n return ( core -> mac [ RFCTL ] & E1000_RFCTL_EXTEN ) ? false : true ;\n }", "hash": 5357882892791796049, "project": "debian", "size": 3, "target": 0, "idx": 12768}
{"code": "int nntp_post ( const char * msg ) {\n struct NntpData * nntp_data , nntp_tmp ;\n char buf [ LONG_STRING ] ;\n if ( Context && Context -> magic == MUTT_NNTP ) nntp_data = Context -> data ;\n else {\n CurrentNewsSrv = nntp_select_server ( NewsServer , false ) ;\n if ( ! CurrentNewsSrv ) return - 1 ;\n nntp_data = & nntp_tmp ;\n nntp_data -> nserv = CurrentNewsSrv ;\n nntp_data -> group = NULL ;\n }\n FILE * fp = mutt_file_fopen ( msg , \"r\" ) ;\n if ( ! fp ) {\n mutt_perror ( msg ) ;\n return - 1 ;\n }\n mutt_str_strfcpy ( buf , \"POST\\r\\n\" , sizeof ( buf ) ) ;\n if ( nntp_query ( nntp_data , buf , sizeof ( buf ) ) < 0 ) {\n mutt_file_fclose ( & fp ) ;\n return - 1 ;\n }\n if ( buf [ 0 ] != '3' ) {\n mutt_error ( _ ( \"Can't post article: %s\" ) , buf ) ;\n mutt_file_fclose ( & fp ) ;\n return - 1 ;\n }\n buf [ 0 ] = '.' ;\n buf [ 1 ] = '\\0' ;\n while ( fgets ( buf + 1 , sizeof ( buf ) - 2 , fp ) ) {\n size_t len = strlen ( buf ) ;\n if ( buf [ len - 1 ] == '\\n' ) {\n buf [ len - 1 ] = '\\r' ;\n buf [ len ] = '\\n' ;\n len ++ ;\n buf [ len ] = '\\0' ;\n }\n if ( mutt_socket_send_d ( nntp_data -> nserv -> conn , buf [ 1 ] == '.' ? buf : buf + 1 , MUTT_SOCK_LOG_HDR ) < 0 ) {\n mutt_file_fclose ( & fp ) ;\n return nntp_connect_error ( nntp_data -> nserv ) ;\n }\n }\n mutt_file_fclose ( & fp ) ;\n if ( ( buf [ strlen ( buf ) - 1 ] != '\\n' && mutt_socket_send_d ( nntp_data -> nserv -> conn , \"\\r\\n\" , MUTT_SOCK_LOG_HDR ) < 0 ) || mutt_socket_send_d ( nntp_data -> nserv -> conn , \".\\r\\n\" , MUTT_SOCK_LOG_HDR ) < 0 || mutt_socket_readln ( buf , sizeof ( buf ) , nntp_data -> nserv -> conn ) < 0 ) {\n return nntp_connect_error ( nntp_data -> nserv ) ;\n }\n if ( buf [ 0 ] != '2' ) {\n mutt_error ( _ ( \"Can't post article: %s\" ) , buf ) ;\n return - 1 ;\n }\n return 0 ;\n }", "hash": 3309252579593081468, "project": "debian", "size": 51, "target": 0, "idx": 12791}
{"code": "bool type_is_collatable ( Oid typid ) {\n return OidIsValid ( get_typcollation ( typid ) ) ;\n }", "hash": -7855974557509681261, "project": "debian", "size": 3, "target": 0, "idx": 12804}
{"code": "Oid get_promoted_array_type ( Oid typid ) {\n Oid array_type = get_array_type ( typid ) ;\n if ( OidIsValid ( array_type ) ) return array_type ;\n if ( OidIsValid ( get_element_type ( typid ) ) ) return typid ;\n return InvalidOid ;\n }", "hash": -7855974557509681261, "project": "debian", "size": 6, "target": 0, "idx": 12818}
{"code": "char * get_namespace_name_or_temp ( Oid nspid ) {\n if ( isTempNamespace ( nspid ) ) return \"pg_temp\" ;\n else return get_namespace_name ( nspid ) ;\n }", "hash": -7855974557509681261, "project": "debian", "size": 4, "target": 0, "idx": 12820}
{"code": "List * get_mergejoin_opfamilies ( Oid opno ) {\n List * result = NIL ;\n CatCList * catlist ;\n int i ;\n catlist = SearchSysCacheList1 ( AMOPOPID , ObjectIdGetDatum ( opno ) ) ;\n for ( i = 0 ;\n i < catlist -> n_members ;\n i ++ ) {\n HeapTuple tuple = & catlist -> members [ i ] -> tuple ;\n Form_pg_amop aform = ( Form_pg_amop ) GETSTRUCT ( tuple ) ;\n if ( aform -> amopmethod == BTREE_AM_OID && aform -> amopstrategy == BTEqualStrategyNumber ) result = lappend_oid ( result , aform -> amopfamily ) ;\n }\n ReleaseSysCacheList ( catlist ) ;\n return result ;\n }", "hash": -7855974557509681261, "project": "debian", "size": 15, "target": 0, "idx": 12828}
{"code": "AttrNumber get_attnum ( Oid relid , const char * attname ) {\n HeapTuple tp ;\n tp = SearchSysCacheAttName ( relid , attname ) ;\n if ( HeapTupleIsValid ( tp ) ) {\n Form_pg_attribute att_tup = ( Form_pg_attribute ) GETSTRUCT ( tp ) ;\n AttrNumber result ;\n result = att_tup -> attnum ;\n ReleaseSysCache ( tp ) ;\n return result ;\n }\n else return InvalidAttrNumber ;\n }", "hash": -7855974557509681261, "project": "debian", "size": 12, "target": 0, "idx": 12838}
{"code": "RegProcedure get_opcode ( Oid opno ) {\n HeapTuple tp ;\n tp = SearchSysCache1 ( OPEROID , ObjectIdGetDatum ( opno ) ) ;\n if ( HeapTupleIsValid ( tp ) ) {\n Form_pg_operator optup = ( Form_pg_operator ) GETSTRUCT ( tp ) ;\n RegProcedure result ;\n result = optup -> oprcode ;\n ReleaseSysCache ( tp ) ;\n return result ;\n }\n else return ( RegProcedure ) InvalidOid ;\n }", "hash": -7855974557509681261, "project": "debian", "size": 12, "target": 0, "idx": 12848}
{"code": "Oid get_typmodin ( Oid typid ) {\n HeapTuple tp ;\n tp = SearchSysCache1 ( TYPEOID , ObjectIdGetDatum ( typid ) ) ;\n if ( HeapTupleIsValid ( tp ) ) {\n Form_pg_type typtup = ( Form_pg_type ) GETSTRUCT ( tp ) ;\n Oid result ;\n result = typtup -> typmodin ;\n ReleaseSysCache ( tp ) ;\n return result ;\n }\n else return InvalidOid ;\n }", "hash": -7855974557509681261, "project": "debian", "size": 12, "target": 0, "idx": 12855}
{"code": "Oid get_rel_namespace ( Oid relid ) {\n HeapTuple tp ;\n tp = SearchSysCache1 ( RELOID , ObjectIdGetDatum ( relid ) ) ;\n if ( HeapTupleIsValid ( tp ) ) {\n Form_pg_class reltup = ( Form_pg_class ) GETSTRUCT ( tp ) ;\n Oid result ;\n result = reltup -> relnamespace ;\n ReleaseSysCache ( tp ) ;\n return result ;\n }\n else return InvalidOid ;\n }", "hash": -7855974557509681261, "project": "debian", "size": 12, "target": 0, "idx": 12868}
{"code": "unsigned short _zip_read2 ( unsigned char * * a ) {\n unsigned short ret ;\n ret = ( * a ) [ 0 ] + ( ( * a ) [ 1 ] << 8 ) ;\n * a += 2 ;\n return ret ;\n }", "hash": -5861712607647761763, "project": "debian", "size": 6, "target": 0, "idx": 12895}
{"code": "static char * _zip_readstr ( unsigned char * * buf , int len , int nulp , struct zip_error * error ) {\n char * r , * o ;\n r = ( char * ) malloc ( nulp ? len + 1 : len ) ;\n if ( ! r ) {\n _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;\n return NULL ;\n }\n memcpy ( r , * buf , len ) ;\n * buf += len ;\n if ( nulp ) {\n r [ len ] = 0 ;\n for ( o = r ;\n o < r + len ;\n o ++ ) if ( * o == '\\0' ) * o = ' ' ;\n }\n return r ;\n }", "hash": -5861712607647761763, "project": "debian", "size": 17, "target": 0, "idx": 12902}
{"code": "void _zip_u2d_time ( time_t time , unsigned short * dtime , unsigned short * ddate ) {\n struct tm * tm ;\n tm = localtime ( & time ) ;\n * ddate = ( ( tm -> tm_year + 1900 - 1980 ) << 9 ) + ( ( tm -> tm_mon + 1 ) << 5 ) + tm -> tm_mday ;\n * dtime = ( ( tm -> tm_hour ) << 11 ) + ( ( tm -> tm_min ) << 5 ) + ( ( tm -> tm_sec ) >> 1 ) ;\n return ;\n }", "hash": -5861712607647761763, "project": "debian", "size": 7, "target": 0, "idx": 12906}
{"code": "ssize_t libevt_record_values_read ( libevt_record_values_t * record_values , libbfio_handle_t * file_io_handle , libevt_io_handle_t * io_handle , off64_t * file_offset , uint8_t strict_mode , libcerror_error_t * * error ) {\n uint8_t record_size_data [ 4 ] ;\n uint8_t * record_data = NULL ;\n static char * function = \"libevt_record_values_read\" ;\n size_t read_size = 0 ;\n size_t record_data_offset = 0 ;\n ssize_t read_count = 0 ;\n ssize_t total_read_count = 0 ;\n uint32_t record_data_size = 0 ;\n if ( record_values == NULL ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , \"%s: invalid record values.\" , function ) ;\n return ( - 1 ) ;\n }\n if ( io_handle == NULL ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , \"%s: invalid IO handle.\" , function ) ;\n return ( - 1 ) ;\n }\n if ( file_offset == NULL ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , \"%s: invalid file offset.\" , function ) ;\n return ( - 1 ) ;\n }\n record_values -> offset = * file_offset ;\n read_count = libbfio_handle_read_buffer ( file_io_handle , record_size_data , sizeof ( uint32_t ) , error ) ;\n if ( read_count != ( ssize_t ) sizeof ( uint32_t ) ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_IO , LIBCERROR_IO_ERROR_READ_FAILED , \"%s: unable to read record size data.\" , function ) ;\n goto on_error ;\n }\n * file_offset += read_count ;\n total_read_count = read_count ;\n byte_stream_copy_to_uint32_little_endian ( record_size_data , record_data_size ) ;\n if ( record_data_size < 4 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: record data size value out of bounds.\" , function ) ;\n goto on_error ;\n }\n # if SIZEOF_SIZE_T <= 4 if ( ( size_t ) record_data_size > ( size_t ) SSIZE_MAX ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_EXCEEDS_MAXIMUM , \"%s: invalid record data size value exceeds maximum.\" , function ) ;\n goto on_error ;\n }\n # endif record_data = ( uint8_t * ) memory_allocate ( sizeof ( uint8_t ) * record_data_size ) ;\n if ( record_data == NULL ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_MEMORY , LIBCERROR_MEMORY_ERROR_INSUFFICIENT , \"%s: unable to create record data.\" , function ) ;\n goto on_error ;\n }\n byte_stream_copy_from_uint32_little_endian ( record_data , record_data_size ) ;\n record_data_offset = 4 ;\n read_size = record_data_size - record_data_offset ;\n if ( ( ( size64_t ) * file_offset + read_size ) > io_handle -> file_size ) {\n read_size = ( size_t ) ( io_handle -> file_size - * file_offset ) ;\n }\n read_count = libbfio_handle_read_buffer ( file_io_handle , & ( record_data [ record_data_offset ] ) , read_size , error ) ;\n if ( read_count != ( ssize_t ) read_size ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_IO , LIBCERROR_IO_ERROR_READ_FAILED , \"%s: unable to read record data.\" , function ) ;\n goto on_error ;\n }\n * file_offset += read_count ;\n record_data_offset += read_count ;\n total_read_count += read_count ;\n if ( record_data_offset < ( size_t ) record_data_size ) {\n if ( libbfio_handle_seek_offset ( file_io_handle , ( off64_t ) sizeof ( evt_file_header_t ) , SEEK_SET , error ) == - 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_IO , LIBCERROR_IO_ERROR_SEEK_FAILED , \"%s: unable to seek file header offset: %\" PRIzd \".\" , function , sizeof ( evt_file_header_t ) ) ;\n goto on_error ;\n }\n * file_offset = ( off64_t ) sizeof ( evt_file_header_t ) ;\n read_size = ( size_t ) record_data_size - record_data_offset ;\n read_count = libbfio_handle_read_buffer ( file_io_handle , & ( record_data [ record_data_offset ] ) , read_size , error ) ;\n if ( read_count != ( ssize_t ) read_size ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_IO , LIBCERROR_IO_ERROR_READ_FAILED , \"%s: unable to read record data.\" , function ) ;\n goto on_error ;\n }\n * file_offset += read_count ;\n total_read_count += read_count ;\n }\n # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) {\n libcnotify_printf ( \"%s: record data:\\n\" , function ) ;\n libcnotify_print_data ( record_data , ( size_t ) record_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ;\n }\n # endif if ( memory_compare ( & ( record_data [ 4 ] ) , evt_file_signature , ) == 0 ) {\n record_values -> type = LIBEVT_RECORD_TYPE_EVENT ;\n }\n else if ( memory_compare ( & ( record_data [ 4 ] ) , evt_end_of_file_record_signature1 , ) == 0 ) {\n record_values -> type = LIBEVT_RECORD_TYPE_END_OF_FILE ;\n }\n else {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_UNSUPPORTED_VALUE , \"%s: unsupported record values signature.\" , function ) ;\n goto on_error ;\n }\n if ( record_values -> type == LIBEVT_RECORD_TYPE_EVENT ) {\n if ( libevt_record_values_read_event ( record_values , record_data , ( size_t ) record_data_size , strict_mode , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_IO , LIBCERROR_IO_ERROR_READ_FAILED , \"%s: unable to read event record values.\" , function ) ;\n goto on_error ;\n }\n }\n else if ( record_values -> type == LIBEVT_RECORD_TYPE_END_OF_FILE ) {\n if ( libevt_record_values_read_end_of_file ( record_values , record_data , ( size_t ) record_data_size , error ) != 1 ) {\n libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_IO , LIBCERROR_IO_ERROR_READ_FAILED , \"%s: unable to read end of file record values.\" , function ) ;\n goto on_error ;\n }\n }\n memory_free ( record_data ) ;\n return ( total_read_count ) ;\n on_error : if ( record_data != NULL ) {\n memory_free ( record_data ) ;\n }\n return ( - 1 ) ;\n }", "hash": -6357438421920978642, "project": "debian", "size": 105, "target": 0, "idx": 12916}
{"code": "enum nss_status CONCAT ( _nss_files_get , ENTNAME_r ) ( struct STRUCTURE * result , char * buffer , size_t buflen , int * errnop H_ERRNO_PROTO ) {\n enum nss_status status = NSS_STATUS_SUCCESS ;\n __libc_lock_lock ( lock ) ;\n if ( stream == NULL ) {\n int save_errno = errno ;\n status = internal_setent ( 0 ) ;\n __set_errno ( save_errno ) ;\n if ( status == NSS_STATUS_SUCCESS && fgetpos ( stream , & position ) < 0 ) {\n fclose ( stream ) ;\n stream = NULL ;\n status = NSS_STATUS_UNAVAIL ;\n }\n }\n if ( status == NSS_STATUS_SUCCESS ) {\n if ( last_use != getent ) {\n if ( fsetpos ( stream , & position ) < 0 ) status = NSS_STATUS_UNAVAIL ;\n else last_use = getent ;\n }\n if ( status == NSS_STATUS_SUCCESS ) {\n status = internal_getent ( result , buffer , buflen , errnop H_ERRNO_ARG EXTRA_ARGS_VALUE ) ;\n if ( status == NSS_STATUS_SUCCESS ) fgetpos ( stream , & position ) ;\n else last_use = nouse ;\n }\n }\n __libc_lock_unlock ( lock ) ;\n return status ;\n }", "hash": -942846491258578486, "project": "debian", "size": 27, "target": 0, "idx": 12921}
{"code": "static void option_export_pack_edges ( const char * edges ) {\n if ( pack_edges ) fclose ( pack_edges ) ;\n pack_edges = fopen ( edges , \"a\" ) ;\n if ( ! pack_edges ) die_errno ( \"Cannot open '%s'\" , edges ) ;\n }", "hash": -3889154245145551951, "project": "debian", "size": 5, "target": 0, "idx": 12930}
{"code": "static struct hash_list * parse_merge ( unsigned int * count ) {\n struct hash_list * list = NULL , * * tail = & list , * n ;\n const char * from ;\n struct branch * s ;\n * count = 0 ;\n while ( skip_prefix ( command_buf . buf , \"merge \" , & from ) ) {\n n = xmalloc ( sizeof ( * n ) ) ;\n s = lookup_branch ( from ) ;\n if ( s ) hashcpy ( n -> sha1 , s -> sha1 ) ;\n else if ( * from == ':' ) {\n uintmax_t idnum = parse_mark_ref_eol ( from ) ;\n struct object_entry * oe = find_mark ( idnum ) ;\n if ( oe -> type != OBJ_COMMIT ) die ( \"Mark :%\" PRIuMAX \" not a commit\" , idnum ) ;\n hashcpy ( n -> sha1 , oe -> idx . sha1 ) ;\n }\n else if ( ! get_sha1 ( from , n -> sha1 ) ) {\n unsigned long size ;\n char * buf = read_object_with_reference ( n -> sha1 , commit_type , & size , n -> sha1 ) ;\n if ( ! buf || size < 46 ) die ( \"Not a valid commit: %s\" , from ) ;\n free ( buf ) ;\n }\n else die ( \"Invalid ref name or SHA1 expression: %s\" , from ) ;\n n -> next = NULL ;\n * tail = n ;\n tail = & n -> next ;\n ( * count ) ++ ;\n read_next_command ( ) ;\n }\n return list ;\n }", "hash": -3889154245145551951, "project": "debian", "size": 30, "target": 0, "idx": 12964}
{"code": "static void note_change_n ( const char * p , struct branch * b , unsigned char * old_fanout ) {\n static struct strbuf uq = STRBUF_INIT ;\n struct object_entry * oe ;\n struct branch * s ;\n unsigned char sha1 [ 20 ] , commit_sha1 [ 20 ] ;\n char path [ 60 ] ;\n uint16_t inline_data = 0 ;\n unsigned char new_fanout ;\n if ( b -> num_notes == 0 && * old_fanout == 0 ) {\n b -> num_notes = change_note_fanout ( & b -> branch_tree , 0xff ) ;\n * old_fanout = convert_num_notes_to_fanout ( b -> num_notes ) ;\n }\n if ( * p == ':' ) {\n oe = find_mark ( parse_mark_ref_space ( & p ) ) ;\n hashcpy ( sha1 , oe -> idx . sha1 ) ;\n }\n else if ( skip_prefix ( p , \"inline \" , & p ) ) {\n inline_data = 1 ;\n oe = NULL ;\n }\n else {\n if ( get_sha1_hex ( p , sha1 ) ) die ( \"Invalid dataref: %s\" , command_buf . buf ) ;\n oe = find_object ( sha1 ) ;\n p += 40 ;\n if ( * p ++ != ' ' ) die ( \"Missing space after SHA1: %s\" , command_buf . buf ) ;\n }\n s = lookup_branch ( p ) ;\n if ( s ) {\n if ( is_null_sha1 ( s -> sha1 ) ) die ( \"Can't add a note on empty branch.\" ) ;\n hashcpy ( commit_sha1 , s -> sha1 ) ;\n }\n else if ( * p == ':' ) {\n uintmax_t commit_mark = parse_mark_ref_eol ( p ) ;\n struct object_entry * commit_oe = find_mark ( commit_mark ) ;\n if ( commit_oe -> type != OBJ_COMMIT ) die ( \"Mark :%\" PRIuMAX \" not a commit\" , commit_mark ) ;\n hashcpy ( commit_sha1 , commit_oe -> idx . sha1 ) ;\n }\n else if ( ! get_sha1 ( p , commit_sha1 ) ) {\n unsigned long size ;\n char * buf = read_object_with_reference ( commit_sha1 , commit_type , & size , commit_sha1 ) ;\n if ( ! buf || size < 46 ) die ( \"Not a valid commit: %s\" , p ) ;\n free ( buf ) ;\n }\n else die ( \"Invalid ref name or SHA1 expression: %s\" , p ) ;\n if ( inline_data ) {\n if ( p != uq . buf ) {\n strbuf_addstr ( & uq , p ) ;\n p = uq . buf ;\n }\n read_next_command ( ) ;\n parse_and_store_blob ( & last_blob , sha1 , 0 ) ;\n }\n else if ( oe ) {\n if ( oe -> type != OBJ_BLOB ) die ( \"Not a blob (actually a %s): %s\" , typename ( oe -> type ) , command_buf . buf ) ;\n }\n else if ( ! is_null_sha1 ( sha1 ) ) {\n enum object_type type = sha1_object_info ( sha1 , NULL ) ;\n if ( type < 0 ) die ( \"Blob not found: %s\" , command_buf . buf ) ;\n if ( type != OBJ_BLOB ) die ( \"Not a blob (actually a %s): %s\" , typename ( type ) , command_buf . buf ) ;\n }\n construct_path_with_fanout ( sha1_to_hex ( commit_sha1 ) , * old_fanout , path ) ;\n if ( tree_content_remove ( & b -> branch_tree , path , NULL , 0 ) ) b -> num_notes -- ;\n if ( is_null_sha1 ( sha1 ) ) return ;\n b -> num_notes ++ ;\n new_fanout = convert_num_notes_to_fanout ( b -> num_notes ) ;\n construct_path_with_fanout ( sha1_to_hex ( commit_sha1 ) , new_fanout , path ) ;\n tree_content_set ( & b -> branch_tree , path , sha1 , S_IFREG | 0644 , NULL ) ;\n }", "hash": -3889154245145551951, "project": "debian", "size": 68, "target": 0, "idx": 12967}
{"code": "static struct object_entry * parse_treeish_dataref ( const char * * p ) {\n unsigned char sha1 [ 20 ] ;\n struct object_entry * e ;\n if ( * * p == ':' ) {\n e = find_mark ( parse_mark_ref_space ( p ) ) ;\n if ( ! e ) die ( \"Unknown mark: %s\" , command_buf . buf ) ;\n hashcpy ( sha1 , e -> idx . sha1 ) ;\n }\n else {\n if ( get_sha1_hex ( * p , sha1 ) ) die ( \"Invalid dataref: %s\" , command_buf . buf ) ;\n e = find_object ( sha1 ) ;\n * p += 40 ;\n if ( * ( * p ) ++ != ' ' ) die ( \"Missing space after tree-ish: %s\" , command_buf . buf ) ;\n }\n while ( ! e || e -> type != OBJ_TREE ) e = dereference ( e , sha1 ) ;\n return e ;\n }", "hash": -3889154245145551951, "project": "debian", "size": 17, "target": 0, "idx": 12981}
{"code": "static uintmax_t parse_mark_ref ( const char * p , char * * endptr ) {\n uintmax_t mark ;\n assert ( * p == ':' ) ;\n p ++ ;\n mark = strtoumax ( p , endptr , 10 ) ;\n if ( * endptr == p ) die ( \"No value after ':' in mark: %s\" , command_buf . buf ) ;\n return mark ;\n }", "hash": -3889154245145551951, "project": "debian", "size": 8, "target": 0, "idx": 12982}
{"code": "static void load_branch ( struct branch * b ) {\n load_tree ( & b -> branch_tree ) ;\n if ( ! b -> active ) {\n b -> active = 1 ;\n b -> active_next_branch = active_branches ;\n active_branches = b ;\n cur_active_branches ++ ;\n branch_load_count ++ ;\n }\n }", "hash": -3889154245145551951, "project": "debian", "size": 10, "target": 0, "idx": 12991}
{"code": "static uintmax_t change_note_fanout ( struct tree_entry * root , unsigned char fanout ) {\n char hex_sha1 [ 40 ] , path [ 60 ] ;\n return do_change_note_fanout ( root , root , hex_sha1 , 0 , path , 0 , fanout ) ;\n }", "hash": -3889154245145551951, "project": "debian", "size": 4, "target": 0, "idx": 13023}
{"code": "static int dissect_nlm_test_res ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , int version , rpc_call_info_value * rpc_call ) {\n proto_item * lock_item = NULL ;\n proto_tree * lock_tree = NULL ;\n if ( nlm_match_msgres ) {\n if ( rpc_call -> proc == 11 ) {\n if ( ( ! pinfo -> fd -> flags . visited ) ) {\n nlm_register_unmatched_res ( pinfo , tvb , offset ) ;\n }\n else {\n nlm_print_msgres_reply ( pinfo , tree , tvb ) ;\n }\n if ( nfs_fhandle_reqrep_matching ) {\n nlm_match_fhandle_reply ( pinfo , tree ) ;\n }\n }\n }\n offset = dissect_rpc_data ( tvb , tree , hf_nlm_cookie , offset ) ;\n if ( tree ) {\n lock_item = proto_tree_add_item ( tree , hf_nlm_test_stat , tvb , offset , - 1 , ENC_NA ) ;\n lock_tree = proto_item_add_subtree ( lock_item , ett_nlm_lock ) ;\n }\n offset = dissect_rpc_uint32 ( tvb , lock_tree , hf_nlm_test_stat_stat , offset ) ;\n if ( tvb_reported_length_remaining ( tvb , offset ) == 0 ) {\n return offset ;\n }\n if ( tree ) {\n lock_item = proto_tree_add_item ( lock_tree , hf_nlm_holder , tvb , offset , - 1 , ENC_NA ) ;\n if ( lock_item ) lock_tree = proto_item_add_subtree ( lock_item , ett_nlm_lock ) ;\n }\n offset = dissect_rpc_bool ( tvb , lock_tree , hf_nlm_exclusive , offset ) ;\n offset = dissect_rpc_uint32 ( tvb , lock_tree , hf_nlm_lock_svid , offset ) ;\n offset = dissect_rpc_data ( tvb , lock_tree , hf_nlm_lock_owner , offset ) ;\n if ( version == 4 ) {\n offset = dissect_rpc_uint64 ( tvb , lock_tree , hf_nlm_lock_l_offset64 , offset ) ;\n offset = dissect_rpc_uint64 ( tvb , lock_tree , hf_nlm_lock_l_len64 , offset ) ;\n }\n else {\n offset = dissect_rpc_uint32 ( tvb , lock_tree , hf_nlm_lock_l_offset , offset ) ;\n offset = dissect_rpc_uint32 ( tvb , lock_tree , hf_nlm_lock_l_len , offset ) ;\n }\n return offset ;\n }", "hash": -7237039260294671485, "project": "debian", "size": 42, "target": 0, "idx": 13035}
{"code": "static int dissect_nlm_freeall ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , int version _U_ ) {\n guint32 nlm_stat ;\n offset = dissect_rpc_string ( tvb , tree , hf_nlm_share_name , offset , NULL ) ;\n nlm_stat = tvb_get_ntohl ( tvb , offset ) ;\n if ( nlm_stat ) {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" %s\" , val_to_str ( nlm_stat , names_nlm_stats , \"Unknown Status (%u)\" ) ) ;\n }\n offset = dissect_rpc_uint32 ( tvb , tree , hf_nlm_stat , offset ) ;\n return offset ;\n }", "hash": -7237039260294671485, "project": "debian", "size": 10, "target": 0, "idx": 13039}
{"code": "static int dissect_nlm_test ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , int version , rpc_call_info_value * rpc_call ) {\n if ( nlm_match_msgres ) {\n if ( rpc_call -> proc == 6 ) {\n if ( ( ! pinfo -> fd -> flags . visited ) ) {\n nlm_register_unmatched_msg ( pinfo , tvb , offset ) ;\n }\n else {\n nlm_print_msgres_request ( pinfo , tree , tvb ) ;\n }\n if ( nfs_fhandle_reqrep_matching ) {\n nlm_match_fhandle_request ( pinfo , tree ) ;\n }\n }\n }\n offset = dissect_rpc_data ( tvb , tree , hf_nlm_cookie , offset ) ;\n dissect_rpc_bool ( tvb , tree , hf_nlm_exclusive , offset ) ;\n offset += 4 ;\n offset = dissect_lock ( tvb , pinfo , tree , version , offset , rpc_call ) ;\n return offset ;\n }", "hash": -7237039260294671485, "project": "debian", "size": 20, "target": 0, "idx": 13040}
{"code": "static void nlm_register_unmatched_msg ( packet_info * pinfo , tvbuff_t * tvb , int offset ) {\n nlm_msg_res_unmatched_data * umd ;\n nlm_msg_res_unmatched_data * old_umd ;\n umd = ( nlm_msg_res_unmatched_data * ) g_malloc ( sizeof ( nlm_msg_res_unmatched_data ) ) ;\n umd -> req_frame = pinfo -> fd -> num ;\n umd -> ns = pinfo -> fd -> abs_ts ;\n umd -> cookie_len = tvb_get_ntohl ( tvb , offset ) ;\n umd -> cookie = ( const guint8 * ) tvb_memdup ( NULL , tvb , offset + 4 , umd -> cookie_len ) ;\n old_umd = ( nlm_msg_res_unmatched_data * ) g_hash_table_lookup ( nlm_msg_res_unmatched , ( gconstpointer ) umd ) ;\n if ( old_umd ) {\n g_hash_table_remove ( nlm_msg_res_unmatched , ( gconstpointer ) old_umd ) ;\n }\n g_hash_table_insert ( nlm_msg_res_unmatched , ( gpointer ) umd , ( gpointer ) umd ) ;\n }", "hash": -7237039260294671485, "project": "debian", "size": 14, "target": 0, "idx": 13043}
{"code": "static int dissect_nlm4_unlock ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n return dissect_nlm_unlock ( tvb , 0 , pinfo , tree , 4 , ( rpc_call_info_value * ) data ) ;\n }", "hash": -7237039260294671485, "project": "debian", "size": 3, "target": 0, "idx": 13044}
{"code": "static void nlm_msg_res_match_cleanup ( void ) {\n g_hash_table_destroy ( nlm_msg_res_unmatched ) ;\n g_hash_table_destroy ( nlm_msg_res_matched ) ;\n }", "hash": -7237039260294671485, "project": "debian", "size": 4, "target": 0, "idx": 13046}
{"code": "static int dissect_nlm_shareres ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , int version _U_ ) {\n guint32 nlm_stat ;\n offset = dissect_rpc_data ( tvb , tree , hf_nlm_cookie , offset ) ;\n nlm_stat = tvb_get_ntohl ( tvb , offset ) ;\n if ( nlm_stat ) {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" %s\" , val_to_str ( nlm_stat , names_nlm_stats , \"Unknown Status (%u)\" ) ) ;\n }\n offset = dissect_rpc_uint32 ( tvb , tree , hf_nlm_stat , offset ) ;\n offset = dissect_rpc_uint32 ( tvb , tree , hf_nlm_sequence , offset ) ;\n return offset ;\n }", "hash": -7237039260294671485, "project": "debian", "size": 11, "target": 0, "idx": 13066}
{"code": "static int dissect_nlm3_share ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n return dissect_nlm_share ( tvb , 0 , pinfo , tree , 3 , ( rpc_call_info_value * ) data ) ;\n }", "hash": -7237039260294671485, "project": "debian", "size": 3, "target": 0, "idx": 13069}
{"code": "static int dissect_nlm4_share ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n return dissect_nlm_share ( tvb , 0 , pinfo , tree , 4 , ( rpc_call_info_value * ) data ) ;\n }", "hash": -7237039260294671485, "project": "debian", "size": 3, "target": 0, "idx": 13070}
{"code": "afs_int32 SPR_ListOwned ( struct rx_call * call , afs_int32 aid , prlist * alist , afs_int32 * lastP ) {\n afs_int32 code ;\n afs_int32 cid = ANONYMOUSID ;\n code = listOwned ( call , aid , alist , lastP , & cid ) ;\n osi_auditU ( call , PTS_LstOwnEvent , code , AUD_ID , aid , AUD_END ) ;\n ViceLog ( 125 , ( \"PTS_ListOwned: code %d cid %d aid %d\\n\" , code , cid , aid ) ) ;\n return code ;\n }", "hash": 6343276067273564310, "project": "debian", "size": 8, "target": 0, "idx": 13087}
{"code": "afs_int32 SPR_NewEntry ( struct rx_call * call , char aname [ ] , afs_int32 flag , afs_int32 oid , afs_int32 * aid ) {\n afs_int32 code ;\n afs_int32 cid = ANONYMOUSID ;\n code = newEntry ( call , aname , flag , oid , aid , & cid ) ;\n osi_auditU ( call , PTS_NewEntEvent , code , AUD_ID , * aid , AUD_STR , aname , AUD_ID , oid , AUD_END ) ;\n ViceLog ( 5 , ( \"PTS_NewEntry: code %d cid %d aid %d aname %s oid %d\\n\" , code , cid , * aid , aname , oid ) ) ;\n return code ;\n }", "hash": 6343276067273564310, "project": "debian", "size": 8, "target": 0, "idx": 13091}
{"code": "static afs_int32 getCPS ( struct rx_call * call , afs_int32 aid , prlist * alist , afs_int32 * over , afs_int32 * cid ) {\n afs_int32 code ;\n struct ubik_trans * tt ;\n afs_int32 temp ;\n struct prentry tentry ;\n * over = 0 ;\n alist -> prlist_len = 0 ;\n alist -> prlist_val = NULL ;\n code = Initdb ( ) ;\n if ( code != PRSUCCESS ) return code ;\n code = ubik_BeginTransReadAny ( dbase , UBIK_READTRANS , & tt ) ;\n if ( code ) return code ;\n code = ubik_SetLock ( tt , 1 , 1 , LOCKREAD ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n code = read_DbHeader ( tt ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n temp = FindByID ( tt , aid ) ;\n if ( ! temp ) ABORT_WITH ( tt , PRNOENT ) ;\n code = pr_ReadEntry ( tt , 0 , temp , & tentry ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n code = WhoIsThis ( call , tt , cid ) ;\n if ( code || ! AccessOK ( tt , * cid , & tentry , PRP_MEMBER_MEM , PRP_MEMBER_ANY ) ) ABORT_WITH ( tt , PRPERM ) ;\n code = GetList ( tt , & tentry , alist , 1 ) ;\n if ( code != PRSUCCESS ) ABORT_WITH ( tt , code ) ;\n code = ubik_EndTrans ( tt ) ;\n return code ;\n }", "hash": 6343276067273564310, "project": "debian", "size": 27, "target": 0, "idx": 13096}
{"code": "afs_int32 SPR_SetMax ( struct rx_call * call , afs_int32 aid , afs_int32 gflag ) {\n afs_int32 code ;\n afs_int32 cid = ANONYMOUSID ;\n code = setMax ( call , aid , gflag , & cid ) ;\n osi_auditU ( call , PTS_SetMaxEvent , code , AUD_ID , aid , AUD_LONG , gflag , AUD_END ) ;\n ViceLog ( 125 , ( \"PTS_SetMax: code %d cid %d aid %d gflag %d\\n\" , code , cid , aid , gflag ) ) ;\n return code ;\n }", "hash": 6343276067273564310, "project": "debian", "size": 8, "target": 0, "idx": 13120}
{"code": "static void modsecurity_persist_data ( modsec_rec * msr ) {\n const apr_array_header_t * arr ;\n apr_table_entry_t * te ;\n apr_time_t time_before , time_after ;\n int i ;\n time_before = apr_time_now ( ) ;\n arr = apr_table_elts ( msr -> collections ) ;\n te = ( apr_table_entry_t * ) arr -> elts ;\n for ( i = 0 ;\n i < arr -> nelts ;\n i ++ ) {\n apr_table_t * col = ( apr_table_t * ) te [ i ] . val ;\n if ( apr_table_get ( msr -> collections_dirty , te [ i ] . key ) ) {\n collection_store ( msr , col ) ;\n }\n }\n time_after = apr_time_now ( ) ;\n msr -> time_storage_write += time_after - time_before ;\n if ( msr -> txcfg -> debuglog_level >= 4 ) {\n msr_log ( msr , 4 , \"Recording persistent data took %\" APR_TIME_T_FMT \" microseconds.\" , msr -> time_gc ) ;\n }\n srand ( time ( NULL ) ) ;\n if ( rand ( ) < RAND_MAX / 100 ) {\n arr = apr_table_elts ( msr -> collections ) ;\n te = ( apr_table_entry_t * ) arr -> elts ;\n for ( i = 0 ;\n i < arr -> nelts ;\n i ++ ) {\n collections_remove_stale ( msr , te [ i ] . key ) ;\n }\n msr -> time_gc = apr_time_now ( ) - time_after ;\n if ( msr -> txcfg -> debuglog_level >= 4 ) {\n msr_log ( msr , 4 , \"Garbage collection took %\" APR_TIME_T_FMT \" microseconds.\" , msr -> time_gc ) ;\n }\n }\n }", "hash": -7683902591435073306, "project": "debian", "size": 36, "target": 0, "idx": 13141}
{"code": "static int is_response_status_relevant ( modsec_rec * msr , int status ) {\n char * my_error_msg = NULL ;\n apr_status_t rc ;\n char buf [ 32 ] ;\n if ( ( msr -> txcfg -> auditlog_relevant_regex == NULL ) || ( msr -> txcfg -> auditlog_relevant_regex == NOT_SET_P ) ) {\n return 0 ;\n }\n apr_snprintf ( buf , sizeof ( buf ) , \"%d\" , status ) ;\n rc = msc_regexec ( msr -> txcfg -> auditlog_relevant_regex , buf , strlen ( buf ) , & my_error_msg ) ;\n if ( rc >= 0 ) return 1 ;\n if ( rc == PCRE_ERROR_NOMATCH ) return 0 ;\n msr_log ( msr , 1 , \"Regex processing failed (rc %d): %s\" , rc , my_error_msg ) ;\n return 0 ;\n }", "hash": -7683902591435073306, "project": "debian", "size": 14, "target": 0, "idx": 13144}
{"code": "int su_main ( int argc , char * * argv , int mode ) {\n int optc ;\n const char * new_user = DEFAULT_USER , * runuser_user = NULL ;\n char * command = NULL ;\n int request_same_session = 0 ;\n char * shell = NULL ;\n struct passwd * pw ;\n struct passwd pw_copy ;\n gid_t * groups = NULL ;\n size_t ngroups = 0 ;\n bool use_supp = false ;\n bool use_gid = false ;\n gid_t gid = 0 ;\n static const struct option longopts [ ] = {\n {\n \"command\" , required_argument , NULL , 'c' }\n , {\n \"session-command\" , required_argument , NULL , 'C' }\n , {\n \"fast\" , no_argument , NULL , 'f' }\n , {\n \"login\" , no_argument , NULL , 'l' }\n , {\n \"preserve-environment\" , no_argument , NULL , 'p' }\n , {\n \"shell\" , required_argument , NULL , 's' }\n , {\n \"group\" , required_argument , NULL , 'g' }\n , {\n \"supp-group\" , required_argument , NULL , 'G' }\n , {\n \"user\" , required_argument , NULL , 'u' }\n , {\n \"help\" , no_argument , 0 , 'h' }\n , {\n \"version\" , no_argument , 0 , 'V' }\n , {\n NULL , 0 , NULL , 0 }\n }\n ;\n setlocale ( LC_ALL , \"\" ) ;\n bindtextdomain ( PACKAGE , LOCALEDIR ) ;\n textdomain ( PACKAGE ) ;\n atexit ( close_stdout ) ;\n su_mode = mode ;\n fast_startup = false ;\n simulate_login = false ;\n change_environment = true ;\n while ( ( optc = getopt_long ( argc , argv , \"c:fg:G:lmps:u:hV\" , longopts , NULL ) ) != - 1 ) {\n switch ( optc ) {\n case 'c' : command = optarg ;\n break ;\n case 'C' : command = optarg ;\n request_same_session = 1 ;\n break ;\n case 'f' : fast_startup = true ;\n break ;\n case 'g' : use_gid = true ;\n gid = add_supp_group ( optarg , & groups , & ngroups ) ;\n break ;\n case 'G' : use_supp = true ;\n add_supp_group ( optarg , & groups , & ngroups ) ;\n break ;\n case 'l' : simulate_login = true ;\n break ;\n case 'm' : case 'p' : change_environment = false ;\n break ;\n case 's' : shell = optarg ;\n break ;\n case 'u' : if ( su_mode != RUNUSER_MODE ) usage ( EXIT_FAILURE ) ;\n runuser_user = optarg ;\n break ;\n case 'h' : usage ( 0 ) ;\n case 'V' : printf ( UTIL_LINUX_VERSION ) ;\n exit ( EXIT_SUCCESS ) ;\n default : errtryhelp ( EXIT_FAILURE ) ;\n }\n }\n restricted = evaluate_uid ( ) ;\n if ( optind < argc && ! strcmp ( argv [ optind ] , \"-\" ) ) {\n simulate_login = true ;\n ++ optind ;\n }\n if ( simulate_login && ! change_environment ) {\n warnx ( _ ( \"ignoring --preserve-environment, it's mutually exclusive with --login\" ) ) ;\n change_environment = true ;\n }\n switch ( su_mode ) {\n case RUNUSER_MODE : if ( runuser_user ) {\n new_user = runuser_user ;\n if ( shell || fast_startup || command || simulate_login ) {\n errx ( EXIT_FAILURE , _ ( \"options --{\nshell,fast,command,session-command,login}\n and \" \"--user are mutually exclusive\" ) ) ;\n }\n if ( optind == argc ) errx ( EXIT_FAILURE , _ ( \"no command was specified\" ) ) ;\n break ;\n }\n case SU_MODE : if ( optind < argc ) new_user = argv [ optind ++ ] ;\n break ;\n }\n if ( ( use_supp || use_gid ) && restricted ) errx ( EXIT_FAILURE , _ ( \"only root can specify alternative groups\" ) ) ;\n logindefs_load_defaults = load_config ;\n pw = getpwnam ( new_user ) ;\n if ( ! ( pw && pw -> pw_name && pw -> pw_name [ 0 ] && pw -> pw_dir && pw -> pw_dir [ 0 ] && pw -> pw_passwd ) ) errx ( EXIT_FAILURE , _ ( \"user %s does not exist\" ) , new_user ) ;\n pw_copy = * pw ;\n pw = & pw_copy ;\n pw -> pw_name = xstrdup ( pw -> pw_name ) ;\n pw -> pw_passwd = xstrdup ( pw -> pw_passwd ) ;\n pw -> pw_dir = xstrdup ( pw -> pw_dir ) ;\n pw -> pw_shell = xstrdup ( pw -> pw_shell && pw -> pw_shell [ 0 ] ? pw -> pw_shell : DEFAULT_SHELL ) ;\n endpwent ( ) ;\n if ( use_supp && ! use_gid ) pw -> pw_gid = groups [ 0 ] ;\n else if ( use_gid ) pw -> pw_gid = gid ;\n authenticate ( pw ) ;\n if ( request_same_session || ! command || ! pw -> pw_uid ) same_session = 1 ;\n if ( runuser_user ) {\n shell = NULL ;\n }\n else {\n if ( ! shell && ! change_environment ) shell = getenv ( \"SHELL\" ) ;\n if ( shell && getuid ( ) != 0 && restricted_shell ( pw -> pw_shell ) ) {\n warnx ( _ ( \"using restricted shell %s\" ) , pw -> pw_shell ) ;\n shell = NULL ;\n }\n shell = xstrdup ( shell ? shell : pw -> pw_shell ) ;\n }\n init_groups ( pw , groups , ngroups ) ;\n if ( ! simulate_login || command ) suppress_pam_info = 1 ;\n create_watching_parent ( ) ;\n change_identity ( pw ) ;\n if ( ! same_session ) setsid ( ) ;\n modify_environment ( pw , shell ) ;\n if ( simulate_login && chdir ( pw -> pw_dir ) != 0 ) warn ( _ ( \"warning: cannot change directory to %s\" ) , pw -> pw_dir ) ;\n if ( shell ) run_shell ( shell , command , argv + optind , max ( 0 , argc - optind ) ) ;\n else {\n execvp ( argv [ optind ] , & argv [ optind ] ) ;\n err ( EXIT_FAILURE , _ ( \"failed to execute %s\" ) , argv [ optind ] ) ;\n }\n }", "hash": 9009378236683657160, "project": "debian", "size": 140, "target": 0, "idx": 13146}
{"code": "static void authenticate ( const struct passwd * pw ) {\n const struct passwd * lpw = NULL ;\n const char * cp , * srvname = NULL ;\n int retval ;\n switch ( su_mode ) {\n case SU_MODE : srvname = simulate_login ? PAM_SRVNAME_SU_L : PAM_SRVNAME_SU ;\n break ;\n case RUNUSER_MODE : srvname = simulate_login ? PAM_SRVNAME_RUNUSER_L : PAM_SRVNAME_RUNUSER ;\n break ;\n default : abort ( ) ;\n break ;\n }\n retval = pam_start ( srvname , pw -> pw_name , & conv , & pamh ) ;\n if ( is_pam_failure ( retval ) ) goto done ;\n if ( isatty ( 0 ) && ( cp = ttyname ( 0 ) ) != NULL ) {\n const char * tty ;\n if ( strncmp ( cp , \"/dev/\" , 5 ) == 0 ) tty = cp + 5 ;\n else tty = cp ;\n retval = pam_set_item ( pamh , PAM_TTY , tty ) ;\n if ( is_pam_failure ( retval ) ) goto done ;\n }\n lpw = current_getpwuid ( ) ;\n if ( lpw && lpw -> pw_name ) {\n retval = pam_set_item ( pamh , PAM_RUSER , ( const void * ) lpw -> pw_name ) ;\n if ( is_pam_failure ( retval ) ) goto done ;\n }\n if ( su_mode == RUNUSER_MODE ) {\n if ( restricted ) errx ( EXIT_FAILURE , _ ( \"may not be used by non-root users\" ) ) ;\n return ;\n }\n retval = pam_authenticate ( pamh , 0 ) ;\n if ( is_pam_failure ( retval ) ) goto done ;\n retval = pam_acct_mgmt ( pamh , 0 ) ;\n if ( retval == PAM_NEW_AUTHTOK_REQD ) {\n retval = pam_chauthtok ( pamh , PAM_CHANGE_EXPIRED_AUTHTOK ) ;\n }\n done : log_syslog ( pw , ! is_pam_failure ( retval ) ) ;\n if ( is_pam_failure ( retval ) ) {\n const char * msg ;\n log_btmp ( pw ) ;\n msg = pam_strerror ( pamh , retval ) ;\n pam_end ( pamh , retval ) ;\n sleep ( getlogindefs_num ( \"FAIL_DELAY\" , 1 ) ) ;\n errx ( EXIT_FAILURE , \"%s\" , msg ? msg : _ ( \"incorrect password\" ) ) ;\n }\n }", "hash": 9009378236683657160, "project": "debian", "size": 46, "target": 0, "idx": 13149}
{"code": "static gid_t add_supp_group ( const char * name , gid_t * * groups , size_t * ngroups ) {\n struct group * gr ;\n if ( * ngroups >= NGROUPS_MAX ) errx ( EXIT_FAILURE , P_ ( \"specifying more than %d supplemental group is not possible\" , \"specifying more than %d supplemental groups is not possible\" , NGROUPS_MAX - 1 ) , NGROUPS_MAX - 1 ) ;\n gr = getgrnam ( name ) ;\n if ( ! gr ) errx ( EXIT_FAILURE , _ ( \"group %s does not exist\" ) , name ) ;\n * groups = xrealloc ( * groups , sizeof ( gid_t ) * ( * ngroups + 1 ) ) ;\n ( * groups ) [ * ngroups ] = gr -> gr_gid ;\n ( * ngroups ) ++ ;\n return gr -> gr_gid ;\n }", "hash": 9009378236683657160, "project": "debian", "size": 10, "target": 0, "idx": 13165}
{"code": "void archive_string_concat ( struct archive_string * dest , struct archive_string * src ) {\n if ( archive_string_append ( dest , src -> s , src -> length ) == NULL ) __archive_errx ( 1 , \"Out of memory\" ) ;\n }", "hash": -1102844685921778700, "project": "debian", "size": 3, "target": 0, "idx": 13182}
{"code": "static uint32_t get_nfc ( uint32_t uc , uint32_t uc2 ) {\n int t , b ;\n t = 0 ;\n b = sizeof ( u_composition_table ) / sizeof ( u_composition_table [ 0 ] ) - 1 ;\n while ( b >= t ) {\n int m = ( t + b ) / 2 ;\n if ( u_composition_table [ m ] . cp1 < uc ) t = m + 1 ;\n else if ( u_composition_table [ m ] . cp1 > uc ) b = m - 1 ;\n else if ( u_composition_table [ m ] . cp2 < uc2 ) t = m + 1 ;\n else if ( u_composition_table [ m ] . cp2 > uc2 ) b = m - 1 ;\n else return ( u_composition_table [ m ] . nfc ) ;\n }\n return ( 0 ) ;\n }", "hash": -1102844685921778700, "project": "debian", "size": 14, "target": 0, "idx": 13186}
{"code": "static int utf8_to_unicode ( uint32_t * pwc , const char * s , size_t n ) {\n int cnt ;\n cnt = _utf8_to_unicode ( pwc , s , n ) ;\n if ( cnt == 3 && IS_SURROGATE_PAIR_LA ( * pwc ) ) return ( - 3 ) ;\n return ( cnt ) ;\n }", "hash": -1102844685921778700, "project": "debian", "size": 6, "target": 0, "idx": 13188}
{"code": "int archive_mstring_get_mbs_l ( struct archive_mstring * aes , const char * * p , size_t * length , struct archive_string_conv * sc ) {\n int r , ret = 0 ;\n # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) if ( sc != NULL && ( aes -> aes_set & AES_SET_WCS ) != 0 ) {\n archive_string_empty ( & ( aes -> aes_mbs_in_locale ) ) ;\n r = archive_string_append_from_wcs_in_codepage ( & ( aes -> aes_mbs_in_locale ) , aes -> aes_wcs . s , aes -> aes_wcs . length , sc ) ;\n if ( r == 0 ) {\n * p = aes -> aes_mbs_in_locale . s ;\n if ( length != NULL ) * length = aes -> aes_mbs_in_locale . length ;\n return ( 0 ) ;\n }\n else if ( errno == ENOMEM ) return ( - 1 ) ;\n else ret = - 1 ;\n }\n # endif if ( ( aes -> aes_set & AES_SET_MBS ) == 0 && ( aes -> aes_set & AES_SET_WCS ) != 0 ) {\n archive_string_empty ( & ( aes -> aes_mbs ) ) ;\n r = archive_string_append_from_wcs ( & ( aes -> aes_mbs ) , aes -> aes_wcs . s , aes -> aes_wcs . length ) ;\n if ( r == 0 ) aes -> aes_set |= AES_SET_MBS ;\n else if ( errno == ENOMEM ) return ( - 1 ) ;\n else ret = - 1 ;\n }\n if ( aes -> aes_set & AES_SET_MBS ) {\n if ( sc == NULL ) {\n * p = aes -> aes_mbs . s ;\n if ( length != NULL ) * length = aes -> aes_mbs . length ;\n return ( 0 ) ;\n }\n ret = archive_strncpy_l ( & ( aes -> aes_mbs_in_locale ) , aes -> aes_mbs . s , aes -> aes_mbs . length , sc ) ;\n * p = aes -> aes_mbs_in_locale . s ;\n if ( length != NULL ) * length = aes -> aes_mbs_in_locale . length ;\n }\n else {\n * p = NULL ;\n if ( length != NULL ) * length = 0 ;\n }\n return ( ret ) ;\n }", "hash": -1102844685921778700, "project": "debian", "size": 36, "target": 0, "idx": 13198}
{"code": "int archive_strncpy_l ( struct archive_string * as , const void * _p , size_t n , struct archive_string_conv * sc ) {\n as -> length = 0 ;\n return ( archive_strncat_l ( as , _p , n , sc ) ) ;\n }", "hash": -1102844685921778700, "project": "debian", "size": 4, "target": 0, "idx": 13204}
{"code": "struct archive_string_conv * archive_string_conversion_to_charset ( struct archive * a , const char * charset , int best_effort ) {\n int flag = SCONV_TO_CHARSET ;\n if ( best_effort ) flag |= SCONV_BEST_EFFORT ;\n return ( get_sconv_object ( a , get_current_charset ( a ) , charset , flag ) ) ;\n }", "hash": -1102844685921778700, "project": "debian", "size": 5, "target": 0, "idx": 13217}
{"code": "struct archive_string_conv * archive_string_default_conversion_for_read ( struct archive * a ) {\n ( void ) a ;\n return ( NULL ) ;\n }", "hash": -1102844685921778700, "project": "debian", "size": 4, "target": 0, "idx": 13218}
{"code": "int archive_mstring_get_utf8 ( struct archive * a , struct archive_mstring * aes , const char * * p ) {\n struct archive_string_conv * sc ;\n int r ;\n if ( aes -> aes_set & AES_SET_UTF8 ) {\n * p = aes -> aes_utf8 . s ;\n return ( 0 ) ;\n }\n * p = NULL ;\n if ( aes -> aes_set & AES_SET_MBS ) {\n sc = archive_string_conversion_to_charset ( a , \"UTF-8\" , 1 ) ;\n if ( sc == NULL ) return ( - 1 ) ;\n r = archive_strncpy_l ( & ( aes -> aes_utf8 ) , aes -> aes_mbs . s , aes -> aes_mbs . length , sc ) ;\n if ( a == NULL ) free_sconv_object ( sc ) ;\n if ( r == 0 ) {\n aes -> aes_set |= AES_SET_UTF8 ;\n * p = aes -> aes_utf8 . s ;\n return ( 0 ) ;\n }\n else return ( - 1 ) ;\n }\n return ( 0 ) ;\n }", "hash": -1102844685921778700, "project": "debian", "size": 22, "target": 0, "idx": 13238}
{"code": "int archive_mstring_copy_mbs_len_l ( struct archive_mstring * aes , const char * mbs , size_t len , struct archive_string_conv * sc ) {\n int r ;\n if ( mbs == NULL ) {\n aes -> aes_set = 0 ;\n return ( 0 ) ;\n }\n archive_string_empty ( & ( aes -> aes_mbs ) ) ;\n archive_wstring_empty ( & ( aes -> aes_wcs ) ) ;\n archive_string_empty ( & ( aes -> aes_utf8 ) ) ;\n # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) if ( sc == NULL ) {\n if ( archive_string_append ( & ( aes -> aes_mbs ) , mbs , mbsnbytes ( mbs , len ) ) == NULL ) {\n aes -> aes_set = 0 ;\n r = - 1 ;\n }\n else {\n aes -> aes_set = AES_SET_MBS ;\n r = 0 ;\n }\n # if defined ( HAVE_ICONV ) }\n else if ( sc != NULL && sc -> cd_w != ( iconv_t ) - 1 ) {\n iconv_t cd = sc -> cd ;\n unsigned from_cp ;\n int flag ;\n sc -> cd = sc -> cd_w ;\n r = archive_strncpy_l ( & ( aes -> aes_utf8 ) , mbs , len , sc ) ;\n sc -> cd = cd ;\n if ( r != 0 ) {\n aes -> aes_set = 0 ;\n return ( r ) ;\n }\n aes -> aes_set = AES_SET_UTF8 ;\n flag = sc -> flag ;\n sc -> flag &= ~ ( SCONV_NORMALIZATION_C | SCONV_TO_UTF16 | SCONV_FROM_UTF16 ) ;\n from_cp = sc -> from_cp ;\n sc -> from_cp = CP_UTF8 ;\n r = archive_wstring_append_from_mbs_in_codepage ( & ( aes -> aes_wcs ) , aes -> aes_utf8 . s , aes -> aes_utf8 . length , sc ) ;\n sc -> flag = flag ;\n sc -> from_cp = from_cp ;\n if ( r == 0 ) aes -> aes_set |= AES_SET_WCS ;\n # endif }\n else {\n r = archive_wstring_append_from_mbs_in_codepage ( & ( aes -> aes_wcs ) , mbs , len , sc ) ;\n if ( r == 0 ) aes -> aes_set = AES_SET_WCS ;\n else aes -> aes_set = 0 ;\n }\n # else r = archive_strncpy_l ( & ( aes -> aes_mbs ) , mbs , len , sc ) ;\n if ( r == 0 ) aes -> aes_set = AES_SET_MBS ;\n else aes -> aes_set = 0 ;\n # endif return ( r ) ;\n }", "hash": -1102844685921778700, "project": "debian", "size": 50, "target": 0, "idx": 13239}
{"code": "static fragment_head * force_reassemble_seq ( reassembly_table * table , packet_info * pinfo , guint32 id ) {\n fragment_head * fd_head ;\n fragment_item * fd_i ;\n fragment_item * last_fd ;\n guint32 dfpos , size , packet_lost , burst_lost , seq_num ;\n guint8 * data ;\n fd_head = fragment_get ( table , pinfo , id , NULL ) ;\n if ( pinfo -> fd -> flags . visited ) {\n if ( fd_head != NULL && fd_head -> flags & FD_DEFRAGMENTED ) {\n return fd_head ;\n }\n else {\n return NULL ;\n }\n }\n if ( fd_head == NULL ) {\n return NULL ;\n }\n packet_lost = 0 ;\n burst_lost = 0 ;\n seq_num = 0 ;\n for ( fd_i = fd_head -> next ;\n fd_i ;\n fd_i = fd_i -> next ) {\n if ( seq_num != fd_i -> offset ) {\n packet_lost += fd_i -> offset - seq_num ;\n if ( ( fd_i -> offset - seq_num ) > burst_lost ) {\n burst_lost = fd_i -> offset - seq_num ;\n }\n }\n seq_num = fd_i -> offset + 1 ;\n }\n size = 0 ;\n last_fd = NULL ;\n for ( fd_i = fd_head -> next ;\n fd_i ;\n fd_i = fd_i -> next ) {\n if ( ! last_fd || last_fd -> offset != fd_i -> offset ) {\n size += fd_i -> len ;\n }\n last_fd = fd_i ;\n }\n data = ( guint8 * ) g_malloc ( size ) ;\n fd_head -> tvb_data = tvb_new_real_data ( data , size , size ) ;\n fd_head -> len = size ;\n dfpos = 0 ;\n last_fd = NULL ;\n for ( fd_i = fd_head -> next ;\n fd_i && fd_i -> len + dfpos <= size ;\n fd_i = fd_i -> next ) {\n if ( fd_i -> len ) {\n if ( ! last_fd || last_fd -> offset != fd_i -> offset ) {\n tvb_memcpy ( fd_i -> tvb_data , data + dfpos , 0 , fd_i -> len ) ;\n dfpos += fd_i -> len ;\n }\n else {\n fd_i -> flags |= FD_OVERLAP ;\n fd_head -> flags |= FD_OVERLAP ;\n if ( ( last_fd -> len != fd_i -> len ) || tvb_memeql ( last_fd -> tvb_data , 0 , tvb_get_ptr ( fd_i -> tvb_data , 0 , last_fd -> len ) , last_fd -> len ) ) {\n fd_i -> flags |= FD_OVERLAPCONFLICT ;\n fd_head -> flags |= FD_OVERLAPCONFLICT ;\n }\n }\n }\n last_fd = fd_i ;\n }\n for ( fd_i = fd_head -> next ;\n fd_i ;\n fd_i = fd_i -> next ) {\n if ( fd_i -> tvb_data ) {\n tvb_free ( fd_i -> tvb_data ) ;\n fd_i -> tvb_data = NULL ;\n }\n }\n fd_head -> flags |= FD_DEFRAGMENTED ;\n fd_head -> reassembled_in = pinfo -> fd -> num ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" (t4-data Reassembled: %d pack lost, %d pack burst lost)\" , packet_lost , burst_lost ) ;\n p_t38_packet_conv_info -> packet_lost = packet_lost ;\n p_t38_packet_conv_info -> burst_lost = burst_lost ;\n return fd_head ;\n }", "hash": -5640788001150418304, "project": "debian", "size": 81, "target": 0, "idx": 13244}
{"code": "void show_setup_info ( tvbuff_t * tvb , proto_tree * tree , t38_conv * p_t38_conversation ) {\n proto_tree * t38_setup_tree ;\n proto_item * ti ;\n if ( ! p_t38_conversation || p_t38_conversation -> setup_frame_number == 0 ) {\n return ;\n }\n ti = proto_tree_add_string_format ( tree , hf_t38_setup , tvb , 0 , 0 , \"\" , \"Stream setup by %s (frame %u)\" , p_t38_conversation -> setup_method , p_t38_conversation -> setup_frame_number ) ;\n PROTO_ITEM_SET_GENERATED ( ti ) ;\n t38_setup_tree = proto_item_add_subtree ( ti , ett_t38_setup ) ;\n if ( t38_setup_tree ) {\n proto_item * item = proto_tree_add_uint ( t38_setup_tree , hf_t38_setup_frame , tvb , 0 , 0 , p_t38_conversation -> setup_frame_number ) ;\n PROTO_ITEM_SET_GENERATED ( item ) ;\n item = proto_tree_add_string ( t38_setup_tree , hf_t38_setup_method , tvb , 0 , 0 , p_t38_conversation -> setup_method ) ;\n PROTO_ITEM_SET_GENERATED ( item ) ;\n }\n }", "hash": -5640788001150418304, "project": "debian", "size": 16, "target": 0, "idx": 13247}
{"code": "void proto_reg_handoff_t38 ( void ) {\n static gboolean t38_prefs_initialized = FALSE ;\n static guint tcp_port ;\n static guint udp_port ;\n if ( ! t38_prefs_initialized ) {\n t38_udp_handle = create_dissector_handle ( dissect_t38_udp , proto_t38 ) ;\n t38_tcp_handle = create_dissector_handle ( dissect_t38_tcp , proto_t38 ) ;\n t38_tcp_pdu_handle = create_dissector_handle ( dissect_t38_tcp_pdu , proto_t38 ) ;\n rtp_handle = find_dissector ( \"rtp\" ) ;\n t30_hdlc_handle = find_dissector ( \"t30.hdlc\" ) ;\n data_handle = find_dissector ( \"data\" ) ;\n t38_prefs_initialized = TRUE ;\n }\n else {\n dissector_delete_uint ( \"tcp.port\" , tcp_port , t38_tcp_handle ) ;\n dissector_delete_uint ( \"udp.port\" , udp_port , t38_udp_handle ) ;\n }\n tcp_port = global_t38_tcp_port ;\n udp_port = global_t38_udp_port ;\n dissector_add_uint ( \"tcp.port\" , tcp_port , t38_tcp_handle ) ;\n dissector_add_uint ( \"udp.port\" , udp_port , t38_udp_handle ) ;\n }", "hash": -5640788001150418304, "project": "debian", "size": 22, "target": 0, "idx": 13254}
{"code": "static int dissect_t38_Type_of_msg ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_t38_Type_of_msg , Type_of_msg_choice , & Type_of_msg_value ) ;\n # line 22 \"../../asn1/t38/t38.cnf\" if ( primary_part ) t38_info -> type_msg = Type_of_msg_value ;\n return offset ;\n }", "hash": 825216912438754622, "project": "debian", "size": 5, "target": 0, "idx": 13256}
{"code": "static int dissect_t38_UDPTLPacket ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 232 \"../../asn1/t38/t38.cnf\" Data_Field_field_type_value = 1 ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_t38_UDPTLPacket , UDPTLPacket_sequence ) ;\n return offset ;\n }", "hash": 825216912438754622, "project": "debian", "size": 5, "target": 0, "idx": 13258}
{"code": "static int dissect_IFPPacket_PDU ( tvbuff_t * tvb _U_ , packet_info * pinfo _U_ , proto_tree * tree _U_ , void * data _U_ ) {\n int offset = 0 ;\n asn1_ctx_t asn1_ctx ;\n asn1_ctx_init ( & asn1_ctx , ASN1_ENC_PER , TRUE , pinfo ) ;\n offset = dissect_t38_IFPPacket ( tvb , offset , & asn1_ctx , tree , hf_t38_IFPPacket_PDU ) ;\n offset += 7 ;\n offset >>= 3 ;\n return offset ;\n }", "hash": 825216912438754622, "project": "debian", "size": 9, "target": 0, "idx": 13262}
{"code": "static int dissect_t38_T_fec_info ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_t38_T_fec_info , T_fec_info_sequence ) ;\n return offset ;\n }", "hash": 825216912438754622, "project": "debian", "size": 4, "target": 0, "idx": 13264}
{"code": "static int dissect_t38_T_secondary_ifp_packets ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_t38_T_secondary_ifp_packets , T_secondary_ifp_packets_sequence_of ) ;\n return offset ;\n }", "hash": 825216912438754622, "project": "debian", "size": 4, "target": 0, "idx": 13270}
{"code": "static PyObject * authGSSServerInit ( PyObject * self , PyObject * args ) {\n const char * service = NULL ;\n gss_server_state * state ;\n PyObject * pystate ;\n int result = 0 ;\n if ( ! PyArg_ParseTuple ( args , \"s\" , & service ) ) return NULL ;\n state = ( gss_server_state * ) malloc ( sizeof ( gss_server_state ) ) ;\n # if PY_MAJOR_VERSION >= 3 pystate = PyCapsule_New ( state , NULL , NULL ) ;\n # else pystate = PyCObject_FromVoidPtr ( state , NULL ) ;\n # endif result = authenticate_gss_server_init ( service , state ) ;\n if ( result == AUTH_GSS_ERROR ) return NULL ;\n return Py_BuildValue ( \"(iO)\" , result , pystate ) ;\n }", "hash": 1750726979859153417, "project": "debian", "size": 13, "target": 0, "idx": 13277}
{"code": "void initkerberos ( void ) # endif {\n PyObject * m , * d ;\n # if PY_MAJOR_VERSION >= 3 m = PyModule_Create ( & moduledef ) ;\n # else m = Py_InitModule ( \"kerberos\" , KerberosMethods ) ;\n # endif d = PyModule_GetDict ( m ) ;\n if ( ! ( KrbException_class = PyErr_NewException ( \"kerberos.KrbError\" , NULL , NULL ) ) ) goto error ;\n PyDict_SetItemString ( d , \"KrbError\" , KrbException_class ) ;\n Py_INCREF ( KrbException_class ) ;\n if ( ! ( BasicAuthException_class = PyErr_NewException ( \"kerberos.BasicAuthError\" , KrbException_class , NULL ) ) ) goto error ;\n Py_INCREF ( BasicAuthException_class ) ;\n PyDict_SetItemString ( d , \"BasicAuthError\" , BasicAuthException_class ) ;\n if ( ! ( PwdChangeException_class = PyErr_NewException ( \"kerberos.PwdChangeError\" , KrbException_class , NULL ) ) ) goto error ;\n Py_INCREF ( PwdChangeException_class ) ;\n PyDict_SetItemString ( d , \"PwdChangeError\" , PwdChangeException_class ) ;\n if ( ! ( GssException_class = PyErr_NewException ( \"kerberos.GSSError\" , KrbException_class , NULL ) ) ) goto error ;\n Py_INCREF ( GssException_class ) ;\n PyDict_SetItemString ( d , \"GSSError\" , GssException_class ) ;\n PyDict_SetItemString ( d , \"AUTH_GSS_COMPLETE\" , PyInt_FromLong ( AUTH_GSS_COMPLETE ) ) ;\n PyDict_SetItemString ( d , \"AUTH_GSS_CONTINUE\" , PyInt_FromLong ( AUTH_GSS_CONTINUE ) ) ;\n PyDict_SetItemString ( d , \"GSS_C_DELEG_FLAG\" , PyInt_FromLong ( GSS_C_DELEG_FLAG ) ) ;\n PyDict_SetItemString ( d , \"GSS_C_MUTUAL_FLAG\" , PyInt_FromLong ( GSS_C_MUTUAL_FLAG ) ) ;\n PyDict_SetItemString ( d , \"GSS_C_REPLAY_FLAG\" , PyInt_FromLong ( GSS_C_REPLAY_FLAG ) ) ;\n PyDict_SetItemString ( d , \"GSS_C_SEQUENCE_FLAG\" , PyInt_FromLong ( GSS_C_SEQUENCE_FLAG ) ) ;\n PyDict_SetItemString ( d , \"GSS_C_CONF_FLAG\" , PyInt_FromLong ( GSS_C_CONF_FLAG ) ) ;\n PyDict_SetItemString ( d , \"GSS_C_INTEG_FLAG\" , PyInt_FromLong ( GSS_C_INTEG_FLAG ) ) ;\n PyDict_SetItemString ( d , \"GSS_C_ANON_FLAG\" , PyInt_FromLong ( GSS_C_ANON_FLAG ) ) ;\n PyDict_SetItemString ( d , \"GSS_C_PROT_READY_FLAG\" , PyInt_FromLong ( GSS_C_PROT_READY_FLAG ) ) ;\n PyDict_SetItemString ( d , \"GSS_C_TRANS_FLAG\" , PyInt_FromLong ( GSS_C_TRANS_FLAG ) ) ;\n error : if ( PyErr_Occurred ( ) ) PyErr_SetString ( PyExc_ImportError , \"kerberos: init failed\" ) ;\n # if PY_MAJOR_VERSION >= 3 return m ;\n # endif }", "hash": 1750726979859153417, "project": "debian", "size": 31, "target": 0, "idx": 13278}
{"code": "static PyObject * authGSSClientResponse ( PyObject * self , PyObject * args ) {\n gss_client_state * state ;\n PyObject * pystate ;\n if ( ! PyArg_ParseTuple ( args , \"O\" , & pystate ) ) return NULL ;\n # if PY_MAJOR_VERSION >= 3 if ( ! PyCapsule_CheckExact ( pystate ) ) {\n # else if ( ! PyCObject_Check ( pystate ) ) {\n # endif PyErr_SetString ( PyExc_TypeError , \"Expected a context object\" ) ;\n return NULL ;\n }\n # if PY_MAJOR_VERSION >= 3 state = PyCapsule_GetPointer ( pystate , NULL ) ;\n # else state = ( gss_client_state * ) PyCObject_AsVoidPtr ( pystate ) ;\n # endif if ( state == NULL ) return NULL ;\n return Py_BuildValue ( \"s\" , state -> response ) ;\n }", "hash": 1750726979859153417, "project": "debian", "size": 14, "target": 0, "idx": 13283}
{"code": "static PyObject * changePassword ( PyObject * self , PyObject * args ) {\n const char * newpswd = NULL ;\n const char * oldpswd = NULL ;\n const char * user = NULL ;\n int result = 0 ;\n if ( ! PyArg_ParseTuple ( args , \"sss\" , & user , & oldpswd , & newpswd ) ) return NULL ;\n result = change_user_krb5pwd ( user , oldpswd , newpswd ) ;\n if ( result ) return Py_INCREF ( Py_True ) , Py_True ;\n else return NULL ;\n }", "hash": 1750726979859153417, "project": "debian", "size": 10, "target": 0, "idx": 13292}
{"code": "int jpc_pchglist_numpchgs ( jpc_pchglist_t * pchglist ) {\n return pchglist -> numpchgs ;\n }", "hash": -2226094829431805196, "project": "debian", "size": 3, "target": 0, "idx": 13304}
{"code": "static void show_unhandled_type_error ( ActivateParametersInstall * parameters ) {\n GtkWidget * dialog ;\n char * mime_type = nautilus_file_get_mime_type ( parameters -> file ) ;\n char * error_message = get_application_no_mime_type_handler_message ( parameters -> file , parameters -> uri ) ;\n if ( g_content_type_is_unknown ( mime_type ) ) {\n dialog = gtk_message_dialog_new ( parameters -> parent_window , GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL , GTK_MESSAGE_ERROR , 0 , \"%s\" , error_message ) ;\n gtk_message_dialog_format_secondary_text ( GTK_MESSAGE_DIALOG ( dialog ) , _ ( \"The file is of an unknown type\" ) ) ;\n }\n else {\n char * text ;\n text = g_strdup_printf ( _ ( \"There is no application installed for \u201c%s\u201d files\" ) , g_content_type_get_description ( mime_type ) ) ;\n dialog = gtk_message_dialog_new ( parameters -> parent_window , GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL , GTK_MESSAGE_ERROR , 0 , \"%s\" , error_message ) ;\n gtk_message_dialog_format_secondary_text ( GTK_MESSAGE_DIALOG ( dialog ) , \"%s\" , text ) ;\n g_free ( text ) ;\n }\n gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( \"_Select Application\" ) , GTK_RESPONSE_ACCEPT ) ;\n gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( \"_OK\" ) , GTK_RESPONSE_OK ) ;\n gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_OK ) ;\n g_object_set_data_full ( G_OBJECT ( dialog ) , \"mime-action:file\" , nautilus_file_ref ( parameters -> file ) , ( GDestroyNotify ) nautilus_file_unref ) ;\n gtk_widget_show ( GTK_WIDGET ( dialog ) ) ;\n g_signal_connect ( dialog , \"response\" , G_CALLBACK ( choose_program ) , parameters ) ;\n g_free ( error_message ) ;\n g_free ( mime_type ) ;\n }", "hash": -6024601983167898950, "project": "debian", "size": 24, "target": 0, "idx": 13321}
{"code": "static gboolean confirm_multiple_windows ( GtkWindow * parent_window , int count , gboolean use_tabs ) {\n GtkDialog * dialog ;\n char * prompt ;\n char * detail ;\n int response ;\n if ( count <= SILENT_WINDOW_OPEN_LIMIT ) {\n return TRUE ;\n }\n prompt = _ ( \"Are you sure you want to open all files?\" ) ;\n if ( use_tabs ) {\n detail = g_strdup_printf ( ngettext ( \"This will open %d separate tab.\" , \"This will open %d separate tabs.\" , count ) , count ) ;\n }\n else {\n detail = g_strdup_printf ( ngettext ( \"This will open %d separate window.\" , \"This will open %d separate windows.\" , count ) , count ) ;\n }\n dialog = eel_show_yes_no_dialog ( prompt , detail , _ ( \"_OK\" ) , _ ( \"_Cancel\" ) , parent_window ) ;\n g_free ( detail ) ;\n response = gtk_dialog_run ( dialog ) ;\n gtk_widget_destroy ( GTK_WIDGET ( dialog ) ) ;\n return response == GTK_RESPONSE_YES ;\n }", "hash": -6024601983167898950, "project": "debian", "size": 21, "target": 0, "idx": 13322}
{"code": "static void list_to_parameters_foreach ( GAppInfo * application , GList * uris , GList * * ret ) {\n ApplicationLaunchParameters * parameters ;\n uris = g_list_reverse ( uris ) ;\n parameters = application_launch_parameters_new ( application , uris ) ;\n * ret = g_list_prepend ( * ret , parameters ) ;\n }", "hash": -6024601983167898950, "project": "debian", "size": 6, "target": 0, "idx": 13329}
{"code": "static void trash_or_delete_files ( GtkWindow * parent_window , const GList * files , gboolean delete_if_all_already_in_trash ) {\n GList * locations ;\n const GList * node ;\n locations = NULL ;\n for ( node = files ;\n node != NULL ;\n node = node -> next ) {\n locations = g_list_prepend ( locations , nautilus_file_get_location ( ( NautilusFile * ) node -> data ) ) ;\n }\n locations = g_list_reverse ( locations ) ;\n nautilus_file_operations_trash_or_delete ( locations , parent_window , NULL , NULL ) ;\n g_list_free_full ( locations , g_object_unref ) ;\n }", "hash": -6024601983167898950, "project": "debian", "size": 13, "target": 0, "idx": 13330}
{"code": "static gboolean file_was_cancelled ( NautilusFile * file ) {\n GError * error ;\n error = nautilus_file_get_file_info_error ( file ) ;\n return error != NULL && error -> domain == G_IO_ERROR && error -> code == G_IO_ERROR_CANCELLED ;\n }", "hash": -6024601983167898950, "project": "debian", "size": 5, "target": 0, "idx": 13344}
{"code": "static ActivationAction get_activation_action ( NautilusFile * file ) {\n ActivationAction action ;\n char * activation_uri ;\n gboolean can_extract ;\n can_extract = g_settings_get_boolean ( nautilus_preferences , NAUTILUS_PREFERENCES_AUTOMATIC_DECOMPRESSION ) ;\n if ( can_extract && nautilus_file_is_archive ( file ) ) {\n return ACTIVATION_ACTION_EXTRACT ;\n }\n if ( nautilus_file_is_nautilus_link ( file ) ) {\n return ACTIVATION_ACTION_LAUNCH_DESKTOP_FILE ;\n }\n activation_uri = nautilus_file_get_activation_uri ( file ) ;\n if ( activation_uri == NULL ) {\n activation_uri = nautilus_file_get_uri ( file ) ;\n }\n action = ACTIVATION_ACTION_DO_NOTHING ;\n if ( nautilus_file_is_launchable ( file ) ) {\n char * executable_path ;\n action = ACTIVATION_ACTION_LAUNCH ;\n executable_path = g_filename_from_uri ( activation_uri , NULL , NULL ) ;\n if ( ! executable_path ) {\n action = ACTIVATION_ACTION_DO_NOTHING ;\n }\n else if ( nautilus_file_contains_text ( file ) ) {\n action = get_default_executable_text_file_action ( ) ;\n }\n g_free ( executable_path ) ;\n }\n if ( action == ACTIVATION_ACTION_DO_NOTHING ) {\n if ( nautilus_file_opens_in_view ( file ) ) {\n action = ACTIVATION_ACTION_OPEN_IN_VIEW ;\n }\n else {\n action = ACTIVATION_ACTION_OPEN_IN_APPLICATION ;\n }\n }\n g_free ( activation_uri ) ;\n return action ;\n }", "hash": -6024601983167898950, "project": "debian", "size": 39, "target": 0, "idx": 13353}
{"code": "static void show_hidden_files_changed_callback ( gpointer callback_data ) {\n show_hidden_files = g_settings_get_boolean ( gtk_filechooser_preferences , NAUTILUS_PREFERENCES_SHOW_HIDDEN_FILES ) ;\n }", "hash": -5268859819325807498, "project": "debian", "size": 3, "target": 0, "idx": 13381}
{"code": "static void async_job_end ( NautilusDirectory * directory , const char * job ) {\n # ifdef DEBUG_ASYNC_JOBS char * key ;\n gpointer table_key , value ;\n # endif # ifdef DEBUG_START_STOP g_message ( \"stopping %s in %p\" , job , directory -> details -> location ) ;\n # endif g_assert ( async_job_count > 0 ) ;\n # ifdef DEBUG_ASYNC_JOBS {\n char * uri ;\n uri = nautilus_directory_get_uri ( directory ) ;\n g_assert ( async_jobs != NULL ) ;\n key = g_strconcat ( uri , \": \" , job , NULL ) ;\n if ( ! g_hash_table_lookup_extended ( async_jobs , key , & table_key , & value ) ) {\n g_warning ( \"ending job we didn't start: %s in %s\" , job , uri ) ;\n }\n else {\n g_hash_table_remove ( async_jobs , key ) ;\n g_free ( table_key ) ;\n }\n g_free ( uri ) ;\n g_free ( key ) ;\n }\n # endif async_job_count -= 1 ;\n }", "hash": -5268859819325807498, "project": "debian", "size": 22, "target": 0, "idx": 13382}
{"code": "static void thumbnail_loader_size_prepared ( GdkPixbufLoader * loader , int width , int height , gpointer user_data ) {\n int max_thumbnail_size ;\n double aspect_ratio ;\n aspect_ratio = ( ( double ) width ) / height ;\n max_thumbnail_size = NAUTILUS_CANVAS_ICON_SIZE_LARGER * cached_thumbnail_size / NAUTILUS_CANVAS_ICON_SIZE_SMALL ;\n if ( MAX ( width , height ) > max_thumbnail_size ) {\n if ( width > height ) {\n width = max_thumbnail_size ;\n height = width / aspect_ratio ;\n }\n else {\n height = max_thumbnail_size ;\n width = height * aspect_ratio ;\n }\n gdk_pixbuf_loader_set_size ( loader , width , height ) ;\n }\n }", "hash": -5268859819325807498, "project": "debian", "size": 17, "target": 0, "idx": 13398}
{"code": "static void mime_list_done ( MimeListState * state , gboolean success ) {\n NautilusFile * file ;\n NautilusDirectory * directory ;\n directory = state -> directory ;\n g_assert ( directory != NULL ) ;\n file = state -> mime_list_file ;\n file -> details -> mime_list_is_up_to_date = TRUE ;\n g_list_free_full ( file -> details -> mime_list , g_free ) ;\n if ( success ) {\n file -> details -> mime_list_failed = TRUE ;\n file -> details -> mime_list = NULL ;\n }\n else {\n file -> details -> got_mime_list = TRUE ;\n file -> details -> mime_list = istr_set_get_as_list ( state -> mime_list_hash ) ;\n }\n directory -> details -> mime_list_in_progress = NULL ;\n nautilus_file_changed ( file ) ;\n async_job_end ( directory , \"MIME list\" ) ;\n nautilus_directory_async_state_changed ( directory ) ;\n }", "hash": -5268859819325807498, "project": "debian", "size": 21, "target": 0, "idx": 13399}
{"code": "static void async_job_wake_up ( void ) {\n static gboolean already_waking_up = FALSE ;\n gpointer value ;\n g_assert ( async_job_count >= 0 ) ;\n g_assert ( async_job_count <= MAX_ASYNC_JOBS ) ;\n if ( already_waking_up ) {\n return ;\n }\n already_waking_up = TRUE ;\n while ( async_job_count < MAX_ASYNC_JOBS ) {\n value = get_one_value ( waiting_directories ) ;\n if ( value == NULL ) {\n break ;\n }\n g_hash_table_remove ( waiting_directories , value ) ;\n nautilus_directory_async_state_changed ( NAUTILUS_DIRECTORY ( value ) ) ;\n }\n already_waking_up = FALSE ;\n }", "hash": -5268859819325807498, "project": "debian", "size": 19, "target": 0, "idx": 13401}
{"code": "static void istr_set_insert ( GHashTable * table , const char * istr ) {\n char * key ;\n key = g_strdup ( istr ) ;\n g_hash_table_replace ( table , key , key ) ;\n }", "hash": -5268859819325807498, "project": "debian", "size": 5, "target": 0, "idx": 13402}
{"code": "static void link_info_stop ( NautilusDirectory * directory ) {\n NautilusFile * file ;\n if ( directory -> details -> link_info_read_state != NULL ) {\n file = directory -> details -> link_info_read_state -> file ;\n if ( file != NULL ) {\n g_assert ( NAUTILUS_IS_FILE ( file ) ) ;\n g_assert ( file -> details -> directory == directory ) ;\n if ( is_needy ( file , lacks_link_info , REQUEST_LINK_INFO ) ) {\n return ;\n }\n }\n link_info_cancel ( directory ) ;\n }\n }", "hash": -5268859819325807498, "project": "debian", "size": 14, "target": 0, "idx": 13403}
{"code": "static void directory_load_cancel ( NautilusDirectory * directory ) {\n NautilusFile * file ;\n DirectoryLoadState * state ;\n state = directory -> details -> directory_load_in_progress ;\n if ( state != NULL ) {\n file = state -> load_directory_file ;\n file -> details -> loading_directory = FALSE ;\n if ( file -> details -> directory != directory ) {\n nautilus_directory_async_state_changed ( file -> details -> directory ) ;\n }\n g_cancellable_cancel ( state -> cancellable ) ;\n state -> directory = NULL ;\n directory -> details -> directory_load_in_progress = NULL ;\n async_job_end ( directory , \"file list\" ) ;\n }\n }", "hash": -5268859819325807498, "project": "debian", "size": 16, "target": 0, "idx": 13405}
{"code": "static void cancel_deep_counts_for_file ( NautilusDirectory * directory , NautilusFile * file ) {\n if ( directory -> details -> deep_count_file == file ) {\n deep_count_cancel ( directory ) ;\n }\n }", "hash": -5268859819325807498, "project": "debian", "size": 5, "target": 0, "idx": 13425}
{"code": "static guint count_non_skipped_files ( GList * list ) {\n guint count ;\n GList * node ;\n GFileInfo * info ;\n count = 0 ;\n for ( node = list ;\n node != NULL ;\n node = node -> next ) {\n info = node -> data ;\n if ( ! should_skip_file ( NULL , info ) ) {\n count += 1 ;\n }\n }\n return count ;\n }", "hash": -5268859819325807498, "project": "debian", "size": 15, "target": 0, "idx": 13430}
{"code": "static void cancel_mime_list_for_file ( NautilusDirectory * directory , NautilusFile * file ) {\n if ( directory -> details -> mime_list_in_progress != NULL && directory -> details -> mime_list_in_progress -> mime_list_file == file ) {\n mime_list_cancel ( directory ) ;\n }\n }", "hash": -5268859819325807498, "project": "debian", "size": 5, "target": 0, "idx": 13439}
{"code": "static void thumbnail_cancel ( NautilusDirectory * directory ) {\n if ( directory -> details -> thumbnail_state != NULL ) {\n g_cancellable_cancel ( directory -> details -> thumbnail_state -> cancellable ) ;\n directory -> details -> thumbnail_state -> directory = NULL ;\n directory -> details -> thumbnail_state = NULL ;\n async_job_end ( directory , \"thumbnail\" ) ;\n }\n }", "hash": -5268859819325807498, "project": "debian", "size": 8, "target": 0, "idx": 13457}
{"code": "static void thumbnail_read_callback ( GObject * source_object , GAsyncResult * res , gpointer user_data ) {\n ThumbnailState * state ;\n gsize file_size ;\n char * file_contents ;\n gboolean result ;\n NautilusDirectory * directory ;\n GdkPixbuf * pixbuf ;\n GFile * location ;\n state = user_data ;\n if ( state -> directory == NULL ) {\n thumbnail_state_free ( state ) ;\n return ;\n }\n directory = nautilus_directory_ref ( state -> directory ) ;\n result = g_file_load_contents_finish ( G_FILE ( source_object ) , res , & file_contents , & file_size , NULL , NULL ) ;\n pixbuf = NULL ;\n if ( result ) {\n pixbuf = get_pixbuf_for_content ( file_size , file_contents ) ;\n g_free ( file_contents ) ;\n }\n if ( pixbuf == NULL && state -> trying_original ) {\n state -> trying_original = FALSE ;\n location = g_file_new_for_path ( state -> file -> details -> thumbnail_path ) ;\n g_file_load_contents_async ( location , state -> cancellable , thumbnail_read_callback , state ) ;\n g_object_unref ( location ) ;\n }\n else {\n state -> directory -> details -> thumbnail_state = NULL ;\n async_job_end ( state -> directory , \"thumbnail\" ) ;\n thumbnail_got_pixbuf ( state -> directory , state -> file , pixbuf , state -> tried_original ) ;\n thumbnail_state_free ( state ) ;\n }\n nautilus_directory_unref ( directory ) ;\n }", "hash": -5268859819325807498, "project": "debian", "size": 34, "target": 0, "idx": 13458}
{"code": "static void schedule_call_ready_callbacks ( NautilusDirectory * directory ) {\n if ( directory -> details -> call_ready_idle_id == 0 ) {\n directory -> details -> call_ready_idle_id = g_idle_add ( call_ready_callbacks_at_idle , directory ) ;\n }\n }", "hash": -5268859819325807498, "project": "debian", "size": 5, "target": 0, "idx": 13461}
{"code": "static void cancel_thumbnail_for_file ( NautilusDirectory * directory , NautilusFile * file ) {\n if ( directory -> details -> thumbnail_state != NULL && directory -> details -> thumbnail_state -> file == file ) {\n thumbnail_cancel ( directory ) ;\n }\n }", "hash": -5268859819325807498, "project": "debian", "size": 5, "target": 0, "idx": 13474}
{"code": "static gboolean lacks_directory_count ( NautilusFile * file ) {\n return ! file -> details -> directory_count_is_up_to_date && nautilus_file_should_show_directory_item_count ( file ) ;\n }", "hash": -5268859819325807498, "project": "debian", "size": 3, "target": 0, "idx": 13475}
{"code": "static void cancel_file_info_for_file ( NautilusDirectory * directory , NautilusFile * file ) {\n if ( directory -> details -> get_info_file == file ) {\n file_info_cancel ( directory ) ;\n }\n }", "hash": -5268859819325807498, "project": "debian", "size": 5, "target": 0, "idx": 13491}
{"code": "static void ready_callback_call ( NautilusDirectory * directory , const ReadyCallback * callback ) {\n GList * file_list ;\n if ( callback -> file != NULL ) {\n if ( callback -> callback . file ) {\n ( * callback -> callback . file ) ( callback -> file , callback -> callback_data ) ;\n }\n }\n else if ( callback -> callback . directory != NULL ) {\n if ( directory == NULL || ! REQUEST_WANTS_TYPE ( callback -> request , REQUEST_FILE_LIST ) ) {\n file_list = NULL ;\n }\n else {\n file_list = nautilus_directory_get_file_list ( directory ) ;\n }\n ( * callback -> callback . directory ) ( directory , file_list , callback -> callback_data ) ;\n nautilus_file_list_free ( file_list ) ;\n }\n }", "hash": -5268859819325807498, "project": "debian", "size": 18, "target": 0, "idx": 13499}
{"code": "static void new_files_state_unref ( NewFilesState * state ) {\n state -> count -- ;\n if ( state -> count == 0 ) {\n if ( state -> directory ) {\n state -> directory -> details -> new_files_in_progress = g_list_remove ( state -> directory -> details -> new_files_in_progress , state ) ;\n }\n g_object_unref ( state -> cancellable ) ;\n g_free ( state ) ;\n }\n }", "hash": -5268859819325807498, "project": "debian", "size": 10, "target": 0, "idx": 13503}
{"code": "static void request_counter_add_request ( RequestCounter counter , Request request ) {\n guint i ;\n for ( i = 0 ;\n i < REQUEST_TYPE_LAST ;\n i ++ ) {\n if ( REQUEST_WANTS_TYPE ( request , i ) ) {\n counter [ i ] ++ ;\n }\n }\n }", "hash": -5268859819325807498, "project": "debian", "size": 10, "target": 0, "idx": 13504}
{"code": "static void file_info_cancel ( NautilusDirectory * directory ) {\n if ( directory -> details -> get_info_in_progress != NULL ) {\n g_cancellable_cancel ( directory -> details -> get_info_in_progress -> cancellable ) ;\n directory -> details -> get_info_in_progress -> directory = NULL ;\n directory -> details -> get_info_in_progress = NULL ;\n directory -> details -> get_info_file = NULL ;\n async_job_end ( directory , \"file info\" ) ;\n }\n }", "hash": -5268859819325807498, "project": "debian", "size": 9, "target": 0, "idx": 13518}
{"code": "static void extract_task_done ( GObject * source_object , GAsyncResult * res , gpointer user_data ) {\n ExtractJob * extract_job ;\n extract_job = user_data ;\n if ( extract_job -> done_callback ) {\n extract_job -> done_callback ( extract_job -> output_files , extract_job -> done_callback_data ) ;\n }\n g_list_free_full ( extract_job -> source_files , g_object_unref ) ;\n g_list_free_full ( extract_job -> output_files , g_object_unref ) ;\n g_object_unref ( extract_job -> destination_directory ) ;\n finalize_common ( ( CommonJob * ) extract_job ) ;\n nautilus_file_changes_consume_changes ( TRUE ) ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 12, "target": 0, "idx": 13551}
{"code": "static void extract_job_on_error ( AutoarExtractor * extractor , GError * error , gpointer user_data ) {\n ExtractJob * extract_job = user_data ;\n GFile * source_file ;\n gint response_id ;\n source_file = autoar_extractor_get_source_file ( extractor ) ;\n if ( IS_IO_ERROR ( error , NOT_SUPPORTED ) ) {\n handle_unsupported_compressed_file ( extract_job -> common . parent_window , source_file ) ;\n return ;\n }\n nautilus_progress_info_take_status ( extract_job -> common . progress , f ( _ ( \"Error extracting \u201c%B\u201d\" ) , source_file ) ) ;\n response_id = run_warning ( ( CommonJob * ) extract_job , f ( _ ( \"There was an error while extracting \u201c%B\u201d.\" ) , source_file ) , g_strdup ( error -> message ) , NULL , FALSE , CANCEL , SKIP , NULL ) ;\n if ( response_id == 0 || response_id == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( ( CommonJob * ) extract_job ) ;\n }\n }", "hash": 1245821301839614810, "project": "debian", "size": 15, "target": 0, "idx": 13568}
{"code": "static char * make_next_duplicate_name ( const char * base , const char * suffix , int count , int max_length ) {\n const char * format ;\n char * result ;\n int unshortened_length ;\n gboolean use_count ;\n if ( count < 1 ) {\n g_warning ( \"bad count %d in get_duplicate_name\" , count ) ;\n count = 1 ;\n }\n if ( count <= 2 ) {\n switch ( count ) {\n default : {\n g_assert_not_reached ( ) ;\n }\n case 1 : {\n format = FIRST_COPY_DUPLICATE_FORMAT ;\n }\n break ;\n case 2 : {\n format = SECOND_COPY_DUPLICATE_FORMAT ;\n }\n break ;\n }\n use_count = FALSE ;\n }\n else {\n switch ( count % 100 ) {\n case 11 : {\n format = X11TH_COPY_DUPLICATE_FORMAT ;\n }\n break ;\n case 12 : {\n format = X12TH_COPY_DUPLICATE_FORMAT ;\n }\n break ;\n case 13 : {\n format = X13TH_COPY_DUPLICATE_FORMAT ;\n }\n break ;\n default : {\n format = NULL ;\n }\n break ;\n }\n if ( format == NULL ) {\n switch ( count % 10 ) {\n case 1 : {\n format = ST_COPY_DUPLICATE_FORMAT ;\n }\n break ;\n case 2 : {\n format = ND_COPY_DUPLICATE_FORMAT ;\n }\n break ;\n case 3 : {\n format = RD_COPY_DUPLICATE_FORMAT ;\n }\n break ;\n default : {\n format = TH_COPY_DUPLICATE_FORMAT ;\n }\n break ;\n }\n }\n use_count = TRUE ;\n }\n # pragma GCC diagnostic push # pragma GCC diagnostic ignored \"-Wformat-nonliteral\" if ( use_count ) {\n result = g_strdup_printf ( format , base , count , suffix ) ;\n }\n else {\n result = g_strdup_printf ( format , base , suffix ) ;\n }\n if ( max_length > 0 && ( unshortened_length = strlen ( result ) ) > max_length ) {\n char * new_base ;\n new_base = shorten_utf8_string ( base , unshortened_length - max_length ) ;\n if ( new_base ) {\n g_free ( result ) ;\n if ( use_count ) {\n result = g_strdup_printf ( format , new_base , count , suffix ) ;\n }\n else {\n result = g_strdup_printf ( format , new_base , suffix ) ;\n }\n g_assert ( strlen ( result ) <= max_length ) ;\n g_free ( new_base ) ;\n }\n }\n # pragma GCC diagnostic pop return result ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 89, "target": 0, "idx": 13591}
{"code": "static void report_preparing_move_progress ( CopyMoveJob * move_job , int total , int left ) {\n CommonJob * job ;\n job = ( CommonJob * ) move_job ;\n nautilus_progress_info_take_status ( job -> progress , f ( _ ( \"Preparing to move to \u201c%B\u201d\" ) , move_job -> destination ) ) ;\n nautilus_progress_info_take_details ( job -> progress , f ( ngettext ( \"Preparing to move %'d file\" , \"Preparing to move %'d files\" , left ) , left ) ) ;\n nautilus_progress_info_pulse_progress ( job -> progress ) ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 7, "target": 0, "idx": 13595}
{"code": "void nautilus_file_operations_copy_file ( GFile * source_file , GFile * target_dir , const gchar * source_display_name , const gchar * new_name , GtkWindow * parent_window , NautilusCopyCallback done_callback , gpointer done_callback_data ) {\n GTask * task ;\n CopyMoveJob * job ;\n job = op_job_new ( CopyMoveJob , parent_window ) ;\n job -> done_callback = done_callback ;\n job -> done_callback_data = done_callback_data ;\n job -> files = g_list_append ( NULL , g_object_ref ( source_file ) ) ;\n job -> destination = g_object_ref ( target_dir ) ;\n nautilus_progress_info_set_destination ( ( ( CommonJob * ) job ) -> progress , target_dir ) ;\n job -> target_name = g_strdup ( new_name ) ;\n job -> debuting_files = g_hash_table_new_full ( g_file_hash , ( GEqualFunc ) g_file_equal , g_object_unref , NULL ) ;\n if ( source_display_name != NULL ) {\n gchar * path ;\n path = g_build_filename ( \"/\" , source_display_name , NULL ) ;\n job -> fake_display_source = g_file_new_for_path ( path ) ;\n g_free ( path ) ;\n }\n inhibit_power_manager ( ( CommonJob * ) job , _ ( \"Copying Files\" ) ) ;\n task = g_task_new ( NULL , job -> common . cancellable , copy_task_done , job ) ;\n g_task_set_task_data ( task , job , NULL ) ;\n g_task_run_in_thread ( task , copy_task_thread_func ) ;\n g_object_unref ( task ) ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 23, "target": 0, "idx": 13608}
{"code": "static char * extract_string_until ( const char * original , const char * until_substring ) {\n char * result ;\n g_assert ( ( int ) strlen ( original ) >= until_substring - original ) ;\n g_assert ( until_substring - original >= 0 ) ;\n result = g_malloc ( until_substring - original + 1 ) ;\n strncpy ( result , original , until_substring - original ) ;\n result [ until_substring - original ] = '\\0' ;\n return result ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 9, "target": 0, "idx": 13612}
{"code": "void nautilus_file_operations_duplicate ( GList * files , GArray * relative_item_points , GtkWindow * parent_window , NautilusCopyCallback done_callback , gpointer done_callback_data ) {\n GTask * task ;\n CopyMoveJob * job ;\n GFile * parent ;\n job = op_job_new ( CopyMoveJob , parent_window ) ;\n job -> done_callback = done_callback ;\n job -> done_callback_data = done_callback_data ;\n job -> files = g_list_copy_deep ( files , ( GCopyFunc ) g_object_ref , NULL ) ;\n job -> destination = NULL ;\n parent = g_file_get_parent ( files -> data ) ;\n nautilus_progress_info_set_destination ( ( ( CommonJob * ) job ) -> progress , parent ) ;\n if ( relative_item_points != NULL && relative_item_points -> len > 0 ) {\n job -> icon_positions = g_memdup ( relative_item_points -> data , sizeof ( GdkPoint ) * relative_item_points -> len ) ;\n job -> n_icon_positions = relative_item_points -> len ;\n }\n job -> debuting_files = g_hash_table_new_full ( g_file_hash , ( GEqualFunc ) g_file_equal , g_object_unref , NULL ) ;\n if ( ! nautilus_file_undo_manager_is_operating ( ) ) {\n GFile * src_dir ;\n src_dir = g_file_get_parent ( files -> data ) ;\n job -> common . undo_info = nautilus_file_undo_info_ext_new ( NAUTILUS_FILE_UNDO_OP_DUPLICATE , g_list_length ( files ) , src_dir , src_dir ) ;\n g_object_unref ( src_dir ) ;\n }\n task = g_task_new ( NULL , job -> common . cancellable , copy_task_done , job ) ;\n g_task_set_task_data ( task , job , NULL ) ;\n g_task_run_in_thread ( task , copy_task_thread_func ) ;\n g_object_unref ( task ) ;\n g_object_unref ( parent ) ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 28, "target": 0, "idx": 13614}
{"code": "void nautilus_self_check_file_operations ( void ) {\n setlocale ( LC_MESSAGES , \"C\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \" (copy)\" , 1 , - 1 ) , \" (another copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo\" , 1 , - 1 ) , \"foo (copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \".bashrc\" , 1 , - 1 ) , \".bashrc (copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \".foo.txt\" , 1 , - 1 ) , \".foo (copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo foo\" , 1 , - 1 ) , \"foo foo (copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo.txt\" , 1 , - 1 ) , \"foo (copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo foo.txt\" , 1 , - 1 ) , \"foo foo (copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo foo.txt txt\" , 1 , - 1 ) , \"foo foo (copy).txt txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo...txt\" , 1 , - 1 ) , \"foo.. (copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo...\" , 1 , - 1 ) , \"foo... (copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo. (copy)\" , 1 , - 1 ) , \"foo. (another copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (copy)\" , 1 , - 1 ) , \"foo (another copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (copy).txt\" , 1 , - 1 ) , \"foo (another copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (another copy)\" , 1 , - 1 ) , \"foo (3rd copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (another copy).txt\" , 1 , - 1 ) , \"foo (3rd copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo foo (another copy).txt\" , 1 , - 1 ) , \"foo foo (3rd copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (13th copy)\" , 1 , - 1 ) , \"foo (14th copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (13th copy).txt\" , 1 , - 1 ) , \"foo (14th copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (21st copy)\" , 1 , - 1 ) , \"foo (22nd copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (21st copy).txt\" , 1 , - 1 ) , \"foo (22nd copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (22nd copy)\" , 1 , - 1 ) , \"foo (23rd copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (22nd copy).txt\" , 1 , - 1 ) , \"foo (23rd copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (23rd copy)\" , 1 , - 1 ) , \"foo (24th copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (23rd copy).txt\" , 1 , - 1 ) , \"foo (24th copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (24th copy)\" , 1 , - 1 ) , \"foo (25th copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (24th copy).txt\" , 1 , - 1 ) , \"foo (25th copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo foo (24th copy)\" , 1 , - 1 ) , \"foo foo (25th copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo foo (24th copy).txt\" , 1 , - 1 ) , \"foo foo (25th copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo foo (100000000000000th copy).txt\" , 1 , - 1 ) , \"foo foo (copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (10th copy)\" , 1 , - 1 ) , \"foo (11th copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (10th copy).txt\" , 1 , - 1 ) , \"foo (11th copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (11th copy)\" , 1 , - 1 ) , \"foo (12th copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (11th copy).txt\" , 1 , - 1 ) , \"foo (12th copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (12th copy)\" , 1 , - 1 ) , \"foo (13th copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (12th copy).txt\" , 1 , - 1 ) , \"foo (13th copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (110th copy)\" , 1 , - 1 ) , \"foo (111th copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (110th copy).txt\" , 1 , - 1 ) , \"foo (111th copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (122nd copy)\" , 1 , - 1 ) , \"foo (123rd copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (122nd copy).txt\" , 1 , - 1 ) , \"foo (123rd copy).txt\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (123rd copy)\" , 1 , - 1 ) , \"foo (124th copy)\" ) ;\n EEL_CHECK_STRING_RESULT ( get_duplicate_name ( \"foo (123rd copy).txt\" , 1 , - 1 ) , \"foo (124th copy).txt\" ) ;\n setlocale ( LC_MESSAGES , \"\" ) ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 45, "target": 0, "idx": 13632}
{"code": "static gboolean is_dir ( GFile * file ) {\n GFileInfo * info ;\n gboolean res ;\n res = FALSE ;\n info = g_file_query_info ( file , G_FILE_ATTRIBUTE_STANDARD_TYPE , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , NULL , NULL ) ;\n if ( info ) {\n res = g_file_info_get_file_type ( info ) == G_FILE_TYPE_DIRECTORY ;\n g_object_unref ( info ) ;\n }\n return res ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 11, "target": 0, "idx": 13633}
{"code": "static void custom_size_skip ( va_list * va ) {\n ( void ) va_arg ( * va , goffset ) ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 3, "target": 0, "idx": 13653}
{"code": "static gboolean make_file_name_valid_for_dest_fs ( char * filename , const char * dest_fs_type ) {\n if ( dest_fs_type != NULL && filename != NULL ) {\n if ( ! strcmp ( dest_fs_type , \"fat\" ) || ! strcmp ( dest_fs_type , \"vfat\" ) || ! strcmp ( dest_fs_type , \"msdos\" ) || ! strcmp ( dest_fs_type , \"msdosfs\" ) ) {\n gboolean ret ;\n int i , old_len ;\n ret = fat_str_replace ( filename , '_' ) ;\n old_len = strlen ( filename ) ;\n for ( i = 0 ;\n i < old_len ;\n i ++ ) {\n if ( filename [ i ] != ' ' ) {\n g_strchomp ( filename ) ;\n ret |= ( old_len != strlen ( filename ) ) ;\n break ;\n }\n }\n return ret ;\n }\n }\n return FALSE ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 21, "target": 0, "idx": 13659}
{"code": "static void delete_task_done ( GObject * source_object , GAsyncResult * res , gpointer user_data ) {\n DeleteJob * job ;\n GHashTable * debuting_uris ;\n job = user_data ;\n g_list_free_full ( job -> files , g_object_unref ) ;\n if ( job -> done_callback ) {\n debuting_uris = g_hash_table_new_full ( g_file_hash , ( GEqualFunc ) g_file_equal , g_object_unref , NULL ) ;\n job -> done_callback ( debuting_uris , job -> user_cancel , job -> done_callback_data ) ;\n g_hash_table_unref ( debuting_uris ) ;\n }\n finalize_common ( ( CommonJob * ) job ) ;\n nautilus_file_changes_consume_changes ( TRUE ) ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 13, "target": 0, "idx": 13665}
{"code": "static char * get_duplicate_name ( const char * name , int count_increment , int max_length ) {\n char * result ;\n char * name_base ;\n const char * suffix ;\n int count ;\n parse_previous_duplicate_name ( name , & name_base , & suffix , & count ) ;\n result = make_next_duplicate_name ( name_base , suffix , count + count_increment , max_length ) ;\n g_free ( name_base ) ;\n return result ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 10, "target": 0, "idx": 13674}
{"code": "static gboolean is_trusted_desktop_file ( GFile * file , GCancellable * cancellable ) {\n char * basename ;\n gboolean res ;\n GFileInfo * info ;\n if ( ! g_file_is_native ( file ) ) {\n return FALSE ;\n }\n basename = g_file_get_basename ( file ) ;\n if ( ! g_str_has_suffix ( basename , \".desktop\" ) ) {\n g_free ( basename ) ;\n return FALSE ;\n }\n g_free ( basename ) ;\n info = g_file_query_info ( file , G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , cancellable , NULL ) ;\n if ( info == NULL ) {\n return FALSE ;\n }\n res = FALSE ;\n if ( g_file_info_get_file_type ( info ) == G_FILE_TYPE_REGULAR && ! g_file_info_get_attribute_boolean ( info , G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE ) && nautilus_is_in_system_dir ( file ) ) {\n res = TRUE ;\n }\n g_object_unref ( info ) ;\n return res ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 24, "target": 0, "idx": 13675}
{"code": "static void abort_job ( CommonJob * job ) {\n g_clear_object ( & job -> undo_info ) ;\n g_cancellable_cancel ( job -> cancellable ) ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 4, "target": 0, "idx": 13679}
{"code": "static void report_copy_progress ( CopyMoveJob * copy_job , SourceInfo * source_info , TransferInfo * transfer_info ) {\n int files_left ;\n goffset total_size ;\n double elapsed , transfer_rate ;\n int remaining_time ;\n guint64 now ;\n CommonJob * job ;\n gboolean is_move ;\n gchar * status ;\n char * details ;\n job = ( CommonJob * ) copy_job ;\n is_move = copy_job -> is_move ;\n now = g_get_monotonic_time ( ) ;\n files_left = source_info -> num_files - transfer_info -> num_files ;\n if ( files_left < 0 ) {\n files_left = 0 ;\n }\n if ( transfer_info -> last_report_time != 0 && ABS ( ( gint64 ) ( transfer_info -> last_report_time - now ) ) < 100 * NSEC_PER_MICROSEC && files_left > 0 ) {\n return ;\n }\n transfer_info -> last_report_time = now ;\n if ( files_left != transfer_info -> last_reported_files_left || transfer_info -> last_reported_files_left == 0 ) {\n transfer_info -> last_reported_files_left = files_left ;\n if ( source_info -> num_files == 1 ) {\n if ( copy_job -> destination != NULL ) {\n if ( is_move ) {\n if ( files_left > 0 ) {\n status = _ ( \"Moving \u201c%B\u201d to \u201c%B\u201d\" ) ;\n }\n else {\n status = _ ( \"Moved \u201c%B\u201d to \u201c%B\u201d\" ) ;\n }\n }\n else {\n if ( files_left > 0 ) {\n status = _ ( \"Copying \u201c%B\u201d to \u201c%B\u201d\" ) ;\n }\n else {\n status = _ ( \"Copied \u201c%B\u201d to \u201c%B\u201d\" ) ;\n }\n }\n nautilus_progress_info_take_status ( job -> progress , f ( status , copy_job -> fake_display_source != NULL ? copy_job -> fake_display_source : ( GFile * ) copy_job -> files -> data , copy_job -> destination ) ) ;\n }\n else {\n if ( files_left > 0 ) {\n status = _ ( \"Duplicating \u201c%B\u201d\" ) ;\n }\n else {\n status = _ ( \"Duplicated \u201c%B\u201d\" ) ;\n }\n nautilus_progress_info_take_status ( job -> progress , f ( status , ( GFile * ) copy_job -> files -> data ) ) ;\n }\n }\n else if ( copy_job -> files != NULL ) {\n if ( copy_job -> destination != NULL ) {\n if ( files_left > 0 ) {\n if ( is_move ) {\n status = ngettext ( \"Moving %'d file to \u201c%B\u201d\" , \"Moving %'d files to \u201c%B\u201d\" , source_info -> num_files ) ;\n }\n else {\n status = ngettext ( \"Copying %'d file to \u201c%B\u201d\" , \"Copying %'d files to \u201c%B\u201d\" , source_info -> num_files ) ;\n }\n nautilus_progress_info_take_status ( job -> progress , f ( status , source_info -> num_files , ( GFile * ) copy_job -> destination ) ) ;\n }\n else {\n if ( is_move ) {\n status = ngettext ( \"Moved %'d file to \u201c%B\u201d\" , \"Moved %'d files to \u201c%B\u201d\" , source_info -> num_files ) ;\n }\n else {\n status = ngettext ( \"Copied %'d file to \u201c%B\u201d\" , \"Copied %'d files to \u201c%B\u201d\" , source_info -> num_files ) ;\n }\n nautilus_progress_info_take_status ( job -> progress , f ( status , source_info -> num_files , ( GFile * ) copy_job -> destination ) ) ;\n }\n }\n else {\n GFile * parent ;\n parent = g_file_get_parent ( copy_job -> files -> data ) ;\n if ( files_left > 0 ) {\n status = ngettext ( \"Duplicating %'d file in \u201c%B\u201d\" , \"Duplicating %'d files in \u201c%B\u201d\" , source_info -> num_files ) ;\n nautilus_progress_info_take_status ( job -> progress , f ( status , source_info -> num_files , parent ) ) ;\n }\n else {\n status = ngettext ( \"Duplicated %'d file in \u201c%B\u201d\" , \"Duplicated %'d files in \u201c%B\u201d\" , source_info -> num_files ) ;\n nautilus_progress_info_take_status ( job -> progress , f ( status , source_info -> num_files , parent ) ) ;\n }\n g_object_unref ( parent ) ;\n }\n }\n }\n total_size = MAX ( source_info -> num_bytes , transfer_info -> num_bytes ) ;\n elapsed = g_timer_elapsed ( job -> time , NULL ) ;\n transfer_rate = 0 ;\n remaining_time = INT_MAX ;\n if ( elapsed > 0 ) {\n transfer_rate = transfer_info -> num_bytes / elapsed ;\n if ( transfer_rate > 0 ) {\n remaining_time = ( total_size - transfer_info -> num_bytes ) / transfer_rate ;\n }\n }\n if ( elapsed < SECONDS_NEEDED_FOR_RELIABLE_TRANSFER_RATE && transfer_rate > 0 ) {\n if ( source_info -> num_files == 1 ) {\n details = f ( _ ( \"%S / %S\" ) , transfer_info -> num_bytes , total_size ) ;\n }\n else {\n if ( files_left > 0 ) {\n details = f ( _ ( \"%'d / %'d\" ) , transfer_info -> num_files + 1 , source_info -> num_files ) ;\n }\n else {\n details = f ( _ ( \"%'d / %'d\" ) , transfer_info -> num_files , source_info -> num_files ) ;\n }\n }\n }\n else {\n if ( source_info -> num_files == 1 ) {\n if ( files_left > 0 ) {\n details = f ( ngettext ( \"%S / %S \\xE2\\x80\\x94 %T left (%S/sec)\" , \"%S / %S \\xE2\\x80\\x94 %T left (%S/sec)\" , seconds_count_format_time_units ( remaining_time ) ) , transfer_info -> num_bytes , total_size , remaining_time , ( goffset ) transfer_rate ) ;\n }\n else {\n details = f ( _ ( \"%S / %S\" ) , transfer_info -> num_bytes , total_size ) ;\n }\n }\n else {\n if ( files_left > 0 ) {\n details = f ( ngettext ( \"%'d / %'d \\xE2\\x80\\x94 %T left (%S/sec)\" , \"%'d / %'d \\xE2\\x80\\x94 %T left (%S/sec)\" , seconds_count_format_time_units ( remaining_time ) ) , transfer_info -> num_files + 1 , source_info -> num_files , remaining_time , ( goffset ) transfer_rate ) ;\n }\n else {\n details = f ( _ ( \"%'d / %'d\" ) , transfer_info -> num_files , source_info -> num_files ) ;\n }\n }\n }\n nautilus_progress_info_take_details ( job -> progress , details ) ;\n if ( elapsed > SECONDS_NEEDED_FOR_APROXIMATE_TRANSFER_RATE ) {\n nautilus_progress_info_set_remaining_time ( job -> progress , remaining_time ) ;\n nautilus_progress_info_set_elapsed_time ( job -> progress , elapsed ) ;\n }\n nautilus_progress_info_set_progress ( job -> progress , transfer_info -> num_bytes , total_size ) ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 137, "target": 0, "idx": 13685}
{"code": "void nautilus_file_operations_trash_or_delete ( GList * files , GtkWindow * parent_window , NautilusDeleteCallback done_callback , gpointer done_callback_data ) {\n trash_or_delete_internal ( files , parent_window , TRUE , done_callback , done_callback_data ) ;\n }", "hash": 1245821301839614810, "project": "debian", "size": 3, "target": 0, "idx": 13692}
{"code": "static void scan_dir ( GFile * dir , SourceInfo * source_info , CommonJob * job , GQueue * dirs , GHashTable * scanned ) {\n GFileInfo * info ;\n GError * error ;\n GFile * subdir ;\n GFileEnumerator * enumerator ;\n char * primary , * secondary , * details ;\n int response ;\n SourceInfo saved_info ;\n saved_info = * source_info ;\n retry : error = NULL ;\n enumerator = g_file_enumerate_children ( dir , G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_SIZE , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , job -> cancellable , & error ) ;\n if ( enumerator ) {\n error = NULL ;\n while ( ( info = g_file_enumerator_next_file ( enumerator , job -> cancellable , & error ) ) != NULL ) {\n g_autoptr ( GFile ) file = NULL ;\n g_autofree char * file_uri = NULL ;\n file = g_file_enumerator_get_child ( enumerator , info ) ;\n file_uri = g_file_get_uri ( file ) ;\n if ( ! g_hash_table_contains ( scanned , file_uri ) ) {\n g_hash_table_add ( scanned , g_strdup ( file_uri ) ) ;\n count_file ( info , job , source_info ) ;\n if ( g_file_info_get_file_type ( info ) == G_FILE_TYPE_DIRECTORY ) {\n subdir = g_file_get_child ( dir , g_file_info_get_name ( info ) ) ;\n g_queue_push_head ( dirs , subdir ) ;\n }\n }\n g_object_unref ( info ) ;\n }\n g_file_enumerator_close ( enumerator , job -> cancellable , NULL ) ;\n g_object_unref ( enumerator ) ;\n if ( error && IS_IO_ERROR ( error , CANCELLED ) ) {\n g_error_free ( error ) ;\n }\n else if ( error ) {\n primary = get_scan_primary ( source_info -> op ) ;\n details = NULL ;\n if ( IS_IO_ERROR ( error , PERMISSION_DENIED ) ) {\n secondary = f ( _ ( \"Files in the folder \u201c%B\u201d cannot be handled because you do \" \"not have permissions to see them.\" ) , dir ) ;\n }\n else {\n secondary = f ( _ ( \"There was an error getting information about the files in the folder \u201c%B\u201d.\" ) , dir ) ;\n details = error -> message ;\n }\n response = run_warning ( job , primary , secondary , details , FALSE , CANCEL , RETRY , SKIP , NULL ) ;\n g_error_free ( error ) ;\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( job ) ;\n }\n else if ( response == 1 ) {\n * source_info = saved_info ;\n goto retry ;\n }\n else if ( response == 2 ) {\n skip_readdir_error ( job , dir ) ;\n }\n else {\n g_assert_not_reached ( ) ;\n }\n }\n }\n else if ( job -> skip_all_error ) {\n g_error_free ( error ) ;\n skip_file ( job , dir ) ;\n }\n else if ( IS_IO_ERROR ( error , CANCELLED ) ) {\n g_error_free ( error ) ;\n }\n else {\n primary = get_scan_primary ( source_info -> op ) ;\n details = NULL ;\n if ( IS_IO_ERROR ( error , PERMISSION_DENIED ) ) {\n secondary = f ( _ ( \"The folder \u201c%B\u201d cannot be handled because you do not have \" \"permissions to read it.\" ) , dir ) ;\n }\n else {\n secondary = f ( _ ( \"There was an error reading the folder \u201c%B\u201d.\" ) , dir ) ;\n details = error -> message ;\n }\n response = run_warning ( job , primary , secondary , details , TRUE , CANCEL , SKIP_ALL , SKIP , RETRY , NULL ) ;\n g_error_free ( error ) ;\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( job ) ;\n }\n else if ( response == 1 || response == 2 ) {\n if ( response == 1 ) {\n job -> skip_all_error = TRUE ;\n }\n skip_file ( job , dir ) ;\n }\n else if ( response == 3 ) {\n goto retry ;\n }\n else {\n g_assert_not_reached ( ) ;\n }\n }\n }", "hash": 1245821301839614810, "project": "debian", "size": 96, "target": 0, "idx": 13697}
{"code": "void addToHeaderList ( const char * strings [ ] , HttpHeaderList & headers ) {\n for ( int i = 0 ;\n strings [ i ] ;\n i += 2 ) {\n if ( i % 4 == 0 ) {\n headers . push_back ( HttpHeader ( strings [ i ] , - 1 , strings [ i + 1 ] , - 1 ) ) ;\n headers . push_back ( HttpHeader ( ) ) ;\n }\n else {\n headers . push_back ( HttpHeader ( strings [ i ] , strlen ( strings [ i ] ) , strings [ i + 1 ] , strlen ( strings [ i + 1 ] ) ) ) ;\n }\n }\n }", "hash": 2972516716299328416, "project": "debian", "size": 13, "target": 0, "idx": 13700}
{"code": "int fz_colorspace_is_icc ( fz_context * ctx , const fz_colorspace * cs ) {\n return cs && ( cs -> flags & FZ_COLORSPACE_IS_ICC ) ;\n }", "hash": 6323824267898511453, "project": "debian", "size": 3, "target": 0, "idx": 13705}
{"code": "int fz_colorspace_is_indexed ( fz_context * ctx , const fz_colorspace * cs ) {\n return cs && ( cs -> type == FZ_COLORSPACE_INDEXED ) ;\n }", "hash": 6323824267898511453, "project": "debian", "size": 3, "target": 0, "idx": 13710}
{"code": "fz_default_colorspaces * fz_new_default_colorspaces ( fz_context * ctx ) {\n fz_default_colorspaces * default_cs = fz_malloc_struct ( ctx , fz_default_colorspaces ) ;\n default_cs -> refs = 1 ;\n default_cs -> gray = fz_keep_colorspace ( ctx , fz_device_gray ( ctx ) ) ;\n default_cs -> rgb = fz_keep_colorspace ( ctx , fz_device_rgb ( ctx ) ) ;\n default_cs -> cmyk = fz_keep_colorspace ( ctx , fz_device_cmyk ( ctx ) ) ;\n default_cs -> oi = NULL ;\n return default_cs ;\n }", "hash": 6323824267898511453, "project": "debian", "size": 9, "target": 0, "idx": 13712}
{"code": "void fz_set_default_cmyk ( fz_context * ctx , fz_default_colorspaces * default_cs , fz_colorspace * cs ) {\n if ( cs -> n == 4 ) {\n fz_drop_colorspace ( ctx , default_cs -> cmyk ) ;\n default_cs -> cmyk = fz_keep_colorspace ( ctx , cs ) ;\n }\n }", "hash": 6323824267898511453, "project": "debian", "size": 6, "target": 0, "idx": 13724}
{"code": "fz_cmm_instance * fz_cmm_new_instance ( fz_context * ctx ) {\n if ( ctx && ctx -> colorspace && ctx -> colorspace -> cmm ) return ctx -> colorspace -> cmm -> new_instance ( ctx ) ;\n return NULL ;\n }", "hash": 6323824267898511453, "project": "debian", "size": 4, "target": 0, "idx": 13725}
{"code": "static void clamp_default ( const fz_colorspace * cs , const float * src , float * dst ) {\n int i ;\n for ( i = 0 ;\n i < cs -> n ;\n i ++ ) dst [ i ] = fz_clamp ( src [ i ] , 0 , 1 ) ;\n }", "hash": 6323824267898511453, "project": "debian", "size": 6, "target": 0, "idx": 13728}
{"code": "int fz_colorspace_is_cmyk ( fz_context * ctx , const fz_colorspace * cs ) {\n return cs && cs -> type == FZ_COLORSPACE_CMYK ;\n }", "hash": 6323824267898511453, "project": "debian", "size": 3, "target": 0, "idx": 13734}
{"code": "static void rgb_to_gray ( fz_context * ctx , const fz_colorspace * cs , const float * rgb , float * gray ) {\n float r = rgb [ 0 ] ;\n float g = rgb [ 1 ] ;\n float b = rgb [ 2 ] ;\n gray [ 0 ] = r * 0.3f + g * 0.59f + b * 0.11f ;\n }", "hash": 6323824267898511453, "project": "debian", "size": 6, "target": 0, "idx": 13764}
{"code": "void fz_cmm_transform_pixmap ( fz_context * ctx , fz_icclink * link , fz_pixmap * dst , fz_pixmap * src ) {\n if ( ctx && ctx -> colorspace && ctx -> colorspace -> cmm && ctx -> cmm_instance ) ctx -> colorspace -> cmm -> transform_pixmap ( ctx -> cmm_instance , link , dst , src ) ;\n }", "hash": 6323824267898511453, "project": "debian", "size": 3, "target": 0, "idx": 13766}
{"code": "void fz_new_cmm_context ( fz_context * ctx ) {\n ctx -> cmm_instance = fz_cmm_new_instance ( ctx ) ;\n }", "hash": 6323824267898511453, "project": "debian", "size": 3, "target": 0, "idx": 13799}
{"code": "static void lab_to_rgb ( fz_context * ctx , const fz_colorspace * cs , const float * lab , float * rgb ) {\n float lstar , astar , bstar , l , m , n , x , y , z , r , g , b ;\n lstar = lab [ 0 ] ;\n astar = lab [ 1 ] ;\n bstar = lab [ 2 ] ;\n m = ( lstar + 16 ) / 116 ;\n l = m + astar / 500 ;\n n = m - bstar / 200 ;\n x = fung ( l ) ;\n y = fung ( m ) ;\n z = fung ( n ) ;\n r = ( 3.240449f * x + - 1.537136f * y + - 0.498531f * z ) * 0.830026f ;\n g = ( - 0.969265f * x + 1.876011f * y + 0.041556f * z ) * 1.05452f ;\n b = ( 0.055643f * x + - 0.204026f * y + 1.057229f * z ) * 1.1003f ;\n rgb [ 0 ] = sqrtf ( fz_clamp ( r , 0 , 1 ) ) ;\n rgb [ 1 ] = sqrtf ( fz_clamp ( g , 0 , 1 ) ) ;\n rgb [ 2 ] = sqrtf ( fz_clamp ( b , 0 , 1 ) ) ;\n }", "hash": 6323824267898511453, "project": "debian", "size": 18, "target": 0, "idx": 13820}
{"code": "const char * fz_colorspace_colorant ( fz_context * ctx , const fz_colorspace * cs , int i ) {\n if ( ! cs || i < 0 || i >= cs -> n ) fz_throw ( ctx , FZ_ERROR_GENERIC , \"Colorant out of range\" ) ;\n return cs -> colorant [ i ] ;\n }", "hash": 6323824267898511453, "project": "debian", "size": 4, "target": 0, "idx": 13822}
{"code": "const unsigned char * fz_lookup_icc ( fz_context * ctx , const char * name , size_t * size ) {\n # ifndef NO_ICC if ( fz_get_cmm_engine ( ctx ) == NULL ) return * size = 0 , NULL ;\n if ( ! strcmp ( name , FZ_ICC_PROFILE_GRAY ) ) {\n extern const int fz_resources_icc_gray_icc_size ;\n extern const unsigned char fz_resources_icc_gray_icc [ ] ;\n * size = fz_resources_icc_gray_icc_size ;\n return fz_resources_icc_gray_icc ;\n }\n if ( ! strcmp ( name , FZ_ICC_PROFILE_RGB ) || ! strcmp ( name , FZ_ICC_PROFILE_BGR ) ) {\n extern const int fz_resources_icc_rgb_icc_size ;\n extern const unsigned char fz_resources_icc_rgb_icc [ ] ;\n * size = fz_resources_icc_rgb_icc_size ;\n return fz_resources_icc_rgb_icc ;\n }\n if ( ! strcmp ( name , FZ_ICC_PROFILE_CMYK ) ) {\n extern const int fz_resources_icc_cmyk_icc_size ;\n extern const unsigned char fz_resources_icc_cmyk_icc [ ] ;\n * size = fz_resources_icc_cmyk_icc_size ;\n return fz_resources_icc_cmyk_icc ;\n }\n if ( ! strcmp ( name , FZ_ICC_PROFILE_LAB ) ) {\n extern const int fz_resources_icc_lab_icc_size ;\n extern const unsigned char fz_resources_icc_lab_icc [ ] ;\n * size = fz_resources_icc_lab_icc_size ;\n return fz_resources_icc_lab_icc ;\n }\n # endif return * size = 0 , NULL ;\n }", "hash": 6323824267898511453, "project": "debian", "size": 28, "target": 0, "idx": 13830}
{"code": "static void clamp_lab ( const fz_colorspace * cs , const float * src , float * dst ) {\n int i ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) dst [ i ] = fz_clamp ( src [ i ] , i ? - 128 : 0 , i ? 127 : 100 ) ;\n }", "hash": 6323824267898511453, "project": "debian", "size": 6, "target": 0, "idx": 13840}
{"code": "void fz_cmm_init_link ( fz_context * ctx , fz_icclink * link , const fz_iccprofile * dst , int dst_extras , const fz_iccprofile * src , int src_extras , const fz_iccprofile * prf , const fz_color_params * rend , int cmm_flags , int num_bytes , int copy_spots ) {\n if ( ctx && ctx -> colorspace && ctx -> colorspace -> cmm && ctx -> cmm_instance ) ctx -> colorspace -> cmm -> init_link ( ctx -> cmm_instance , link , dst , dst_extras , src , src_extras , prf , rend , cmm_flags , num_bytes , copy_spots ) ;\n }", "hash": 6323824267898511453, "project": "debian", "size": 3, "target": 0, "idx": 13847}
{"code": "void virLogUnlock ( void ) {\n virMutexUnlock ( & virLogMutex ) ;\n }", "hash": -7555034601056330007, "project": "debian", "size": 3, "target": 0, "idx": 13881}
{"code": "int virLogParseFilters ( const char * src , virLogFilterPtr * * filters ) {\n int ret = - 1 ;\n size_t nfilters = 0 ;\n size_t i , count ;\n char * * strings = NULL ;\n virLogFilterPtr filter = NULL ;\n virLogFilterPtr * list = NULL ;\n VIR_DEBUG ( \"filters=%s\" , src ) ;\n if ( ! ( strings = virStringSplitCount ( src , \" \" , 0 , & count ) ) ) goto cleanup ;\n for ( i = 0 ;\n i < count ;\n i ++ ) {\n if ( STREQ ( strings [ i ] , \"\" ) ) continue ;\n if ( ! ( filter = virLogParseFilter ( strings [ i ] ) ) ) goto cleanup ;\n if ( VIR_APPEND_ELEMENT ( list , nfilters , filter ) ) {\n virLogFilterFree ( filter ) ;\n goto cleanup ;\n }\n }\n ret = nfilters ;\n * filters = list ;\n list = NULL ;\n cleanup : virStringListFree ( strings ) ;\n return ret ;\n }", "hash": -7555034601056330007, "project": "debian", "size": 25, "target": 0, "idx": 13907}
{"code": "static bool read_init_file ( char * file_name ) {\n MYSQL_FILE * file ;\n DBUG_ENTER ( \"read_init_file\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"name: %s\" , file_name ) ) ;\n if ( ! ( file = mysql_file_fopen ( key_file_init , file_name , O_RDONLY , MYF ( MY_WME ) ) ) ) DBUG_RETURN ( TRUE ) ;\n bootstrap ( file ) ;\n mysql_file_fclose ( file , MYF ( MY_WME ) ) ;\n DBUG_RETURN ( FALSE ) ;\n }", "hash": -5615323818347734353, "project": "debian", "size": 9, "target": 0, "idx": 13937}
{"code": "static struct passwd * check_user ( const char * user ) {\n # if ! defined ( __WIN__ ) struct passwd * tmp_user_info ;\n uid_t user_id = geteuid ( ) ;\n if ( user_id ) {\n if ( user ) {\n tmp_user_info = getpwnam ( user ) ;\n if ( ( ! tmp_user_info || user_id != tmp_user_info -> pw_uid ) && global_system_variables . log_warnings ) sql_print_warning ( \"One can only use the --user switch if running as root\\n\" ) ;\n }\n return NULL ;\n }\n if ( ! user ) {\n if ( ! opt_bootstrap && ! opt_help ) {\n sql_print_error ( \"Fatal error: Please consult the Knowledge Base \" \"to find out how to run mysqld as root!\\n\" ) ;\n unireg_abort ( 1 ) ;\n }\n return NULL ;\n }\n if ( ! strcmp ( user , \"root\" ) ) return NULL ;\n if ( ! ( tmp_user_info = getpwnam ( user ) ) ) {\n const char * pos ;\n for ( pos = user ;\n my_isdigit ( mysqld_charset , * pos ) ;\n pos ++ ) ;\n if ( * pos ) goto err ;\n if ( ! ( tmp_user_info = getpwuid ( atoi ( user ) ) ) ) goto err ;\n }\n return tmp_user_info ;\n err : sql_print_error ( \"Fatal error: Can't change to run as user '%s' ;\n Please check that the user exists!\\n\" , user ) ;\n unireg_abort ( 1 ) ;\n # endif return NULL ;\n }", "hash": -5615323818347734353, "project": "debian", "size": 32, "target": 0, "idx": 13944}
{"code": "static int fix_paths ( void ) {\n char buff [ FN_REFLEN ] , * pos ;\n DBUG_ENTER ( \"fix_paths\" ) ;\n convert_dirname ( mysql_home , mysql_home , NullS ) ;\n my_realpath ( mysql_home , mysql_home , MYF ( 0 ) ) ;\n pos = strend ( mysql_home ) ;\n if ( pos [ - 1 ] != FN_LIBCHAR ) {\n pos [ 0 ] = FN_LIBCHAR ;\n pos [ 1 ] = 0 ;\n }\n convert_dirname ( lc_messages_dir , lc_messages_dir , NullS ) ;\n convert_dirname ( mysql_real_data_home , mysql_real_data_home , NullS ) ;\n ( void ) my_load_path ( mysql_home , mysql_home , \"\" ) ;\n ( void ) my_load_path ( mysql_real_data_home , mysql_real_data_home , mysql_home ) ;\n ( void ) my_load_path ( pidfile_name , pidfile_name_ptr , mysql_real_data_home ) ;\n convert_dirname ( opt_plugin_dir , opt_plugin_dir_ptr ? opt_plugin_dir_ptr : get_relative_path ( PLUGINDIR ) , NullS ) ;\n ( void ) my_load_path ( opt_plugin_dir , opt_plugin_dir , mysql_home ) ;\n opt_plugin_dir_ptr = opt_plugin_dir ;\n pidfile_name_ptr = pidfile_name ;\n my_realpath ( mysql_unpacked_real_data_home , mysql_real_data_home , MYF ( 0 ) ) ;\n mysql_unpacked_real_data_home_len = ( int ) strlen ( mysql_unpacked_real_data_home ) ;\n if ( mysql_unpacked_real_data_home [ mysql_unpacked_real_data_home_len - 1 ] == FN_LIBCHAR ) -- mysql_unpacked_real_data_home_len ;\n char * sharedir = get_relative_path ( SHAREDIR ) ;\n if ( test_if_hard_path ( sharedir ) ) strmake_buf ( buff , sharedir ) ;\n else strxnmov ( buff , sizeof ( buff ) - 1 , mysql_home , sharedir , NullS ) ;\n convert_dirname ( buff , buff , NullS ) ;\n ( void ) my_load_path ( lc_messages_dir , lc_messages_dir , buff ) ;\n if ( charsets_dir ) strmake_buf ( mysql_charsets_dir , charsets_dir ) ;\n else strxnmov ( mysql_charsets_dir , sizeof ( mysql_charsets_dir ) - 1 , buff , CHARSET_DIR , NullS ) ;\n ( void ) my_load_path ( mysql_charsets_dir , mysql_charsets_dir , buff ) ;\n convert_dirname ( mysql_charsets_dir , mysql_charsets_dir , NullS ) ;\n charsets_dir = mysql_charsets_dir ;\n if ( init_tmpdir ( & mysql_tmpdir_list , opt_mysql_tmpdir ) ) DBUG_RETURN ( 1 ) ;\n if ( ! opt_mysql_tmpdir ) opt_mysql_tmpdir = mysql_tmpdir ;\n # ifdef HAVE_REPLICATION if ( ! slave_load_tmpdir ) slave_load_tmpdir = mysql_tmpdir ;\n # endif if ( opt_secure_file_priv ) {\n if ( * opt_secure_file_priv == 0 ) {\n my_free ( opt_secure_file_priv ) ;\n opt_secure_file_priv = 0 ;\n }\n else {\n if ( strlen ( opt_secure_file_priv ) >= FN_REFLEN ) opt_secure_file_priv [ FN_REFLEN - 1 ] = '\\0' ;\n if ( my_realpath ( buff , opt_secure_file_priv , 0 ) ) {\n sql_print_warning ( \"Failed to normalize the argument for --secure-file-priv.\" ) ;\n DBUG_RETURN ( 1 ) ;\n }\n char * secure_file_real_path = ( char * ) my_malloc ( FN_REFLEN , MYF ( MY_FAE ) ) ;\n convert_dirname ( secure_file_real_path , buff , NullS ) ;\n my_free ( opt_secure_file_priv ) ;\n opt_secure_file_priv = secure_file_real_path ;\n }\n }\n DBUG_RETURN ( 0 ) ;\n }", "hash": -5615323818347734353, "project": "debian", "size": 54, "target": 0, "idx": 13966}
{"code": "static void wait_for_signal_thread_to_end ( ) {\n uint i ;\n for ( i = 0 ;\n i < 100 && signal_thread_in_use ;\n i ++ ) {\n if ( pthread_kill ( signal_thread , MYSQL_KILL_SIGNAL ) == ESRCH ) break ;\n my_sleep ( 100 ) ;\n }\n }", "hash": -5615323818347734353, "project": "debian", "size": 9, "target": 0, "idx": 13967}
{"code": "static void clean_up_error_log_mutex ( ) {\n mysql_mutex_destroy ( & LOCK_error_log ) ;\n }", "hash": -5615323818347734353, "project": "debian", "size": 3, "target": 0, "idx": 13972}
{"code": "void set_server_version ( void ) {\n char * version_end = server_version + sizeof ( server_version ) - 1 ;\n char * end = strxnmov ( server_version , sizeof ( server_version ) - 1 , MYSQL_SERVER_VERSION , MYSQL_SERVER_SUFFIX_STR , NullS ) ;\n # ifdef EMBEDDED_LIBRARY end = strnmov ( end , \"-embedded\" , ( version_end - end ) ) ;\n # endif # ifndef DBUG_OFF if ( ! strstr ( MYSQL_SERVER_SUFFIX_STR , \"-debug\" ) ) end = strnmov ( end , \"-debug\" , ( version_end - end ) ) ;\n # endif if ( opt_log || opt_slow_log || opt_bin_log ) strnmov ( end , \"-log\" , ( version_end - end ) ) ;\n * end = 0 ;\n }", "hash": -5615323818347734353, "project": "debian", "size": 8, "target": 0, "idx": 13977}
{"code": "int jas_image_sampcmpt ( jas_image_t * image , int cmptno , int newcmptno , jas_image_coord_t ho , jas_image_coord_t vo , jas_image_coord_t hs , jas_image_coord_t vs , int sgnd , int prec ) {\n jas_image_cmpt_t * oldcmpt ;\n jas_image_cmpt_t * newcmpt ;\n int width ;\n int height ;\n jas_image_coord_t tlx ;\n jas_image_coord_t tly ;\n jas_image_coord_t brx ;\n jas_image_coord_t bry ;\n int i ;\n int j ;\n jas_image_cmptparm_t cmptparm ;\n jas_image_coord_t ax ;\n jas_image_coord_t ay ;\n jas_image_coord_t bx ;\n jas_image_coord_t by ;\n jas_image_coord_t d0 ;\n jas_image_coord_t d1 ;\n jas_image_coord_t d2 ;\n jas_image_coord_t d3 ;\n jas_image_coord_t oldx ;\n jas_image_coord_t oldy ;\n jas_image_coord_t x ;\n jas_image_coord_t y ;\n long v ;\n jas_image_coord_t cmptbrx ;\n jas_image_coord_t cmptbry ;\n assert ( cmptno >= 0 && cmptno < image -> numcmpts_ ) ;\n oldcmpt = image -> cmpts_ [ cmptno ] ;\n assert ( oldcmpt -> tlx_ == 0 && oldcmpt -> tly_ == 0 ) ;\n jas_image_calcbbox2 ( image , & tlx , & tly , & brx , & bry ) ;\n width = FLOORDIV ( brx - ho + hs , hs ) ;\n height = FLOORDIV ( bry - vo + vs , vs ) ;\n cmptparm . tlx = ho ;\n cmptparm . tly = vo ;\n cmptparm . hstep = hs ;\n cmptparm . vstep = vs ;\n cmptparm . width = width ;\n cmptparm . height = height ;\n cmptparm . prec = prec ;\n cmptparm . sgnd = sgnd ;\n if ( jas_image_addcmpt ( image , newcmptno , & cmptparm ) ) goto error ;\n cmptbrx = oldcmpt -> tlx_ + ( oldcmpt -> width_ - 1 ) * oldcmpt -> hstep_ ;\n cmptbry = oldcmpt -> tly_ + ( oldcmpt -> height_ - 1 ) * oldcmpt -> vstep_ ;\n newcmpt = image -> cmpts_ [ newcmptno ] ;\n jas_stream_rewind ( newcmpt -> stream_ ) ;\n for ( i = 0 ;\n i < height ;\n ++ i ) {\n y = newcmpt -> tly_ + newcmpt -> vstep_ * i ;\n for ( j = 0 ;\n j < width ;\n ++ j ) {\n x = newcmpt -> tlx_ + newcmpt -> hstep_ * j ;\n ax = downtomult ( x - oldcmpt -> tlx_ , oldcmpt -> hstep_ ) + oldcmpt -> tlx_ ;\n ay = downtomult ( y - oldcmpt -> tly_ , oldcmpt -> vstep_ ) + oldcmpt -> tly_ ;\n bx = uptomult ( x - oldcmpt -> tlx_ , oldcmpt -> hstep_ ) + oldcmpt -> tlx_ ;\n if ( bx > cmptbrx ) bx = cmptbrx ;\n by = uptomult ( y - oldcmpt -> tly_ , oldcmpt -> vstep_ ) + oldcmpt -> tly_ ;\n if ( by > cmptbry ) by = cmptbry ;\n d0 = ( ax - x ) * ( ax - x ) + ( ay - y ) * ( ay - y ) ;\n d1 = ( bx - x ) * ( bx - x ) + ( ay - y ) * ( ay - y ) ;\n d2 = ( bx - x ) * ( bx - x ) + ( by - y ) * ( by - y ) ;\n d3 = ( ax - x ) * ( ax - x ) + ( by - y ) * ( by - y ) ;\n if ( d0 <= d1 && d0 <= d2 && d0 <= d3 ) {\n oldx = ( ax - oldcmpt -> tlx_ ) / oldcmpt -> hstep_ ;\n oldy = ( ay - oldcmpt -> tly_ ) / oldcmpt -> vstep_ ;\n }\n else if ( d1 <= d0 && d1 <= d2 && d1 <= d3 ) {\n oldx = ( bx - oldcmpt -> tlx_ ) / oldcmpt -> hstep_ ;\n oldy = ( ay - oldcmpt -> tly_ ) / oldcmpt -> vstep_ ;\n }\n else if ( d2 <= d0 && d2 <= d1 && d1 <= d3 ) {\n oldx = ( bx - oldcmpt -> tlx_ ) / oldcmpt -> hstep_ ;\n oldy = ( by - oldcmpt -> tly_ ) / oldcmpt -> vstep_ ;\n }\n else {\n oldx = ( ax - oldcmpt -> tlx_ ) / oldcmpt -> hstep_ ;\n oldy = ( by - oldcmpt -> tly_ ) / oldcmpt -> vstep_ ;\n }\n assert ( oldx >= 0 && oldx < oldcmpt -> width_ && oldy >= 0 && oldy < oldcmpt -> height_ ) ;\n if ( jas_stream_seek ( oldcmpt -> stream_ , oldcmpt -> cps_ * ( oldy * oldcmpt -> width_ + oldx ) , SEEK_SET ) < 0 ) goto error ;\n if ( getint ( oldcmpt -> stream_ , oldcmpt -> sgnd_ , oldcmpt -> prec_ , & v ) ) goto error ;\n if ( newcmpt -> prec_ != oldcmpt -> prec_ || newcmpt -> sgnd_ != oldcmpt -> sgnd_ ) {\n v = convert ( v , oldcmpt -> sgnd_ , oldcmpt -> prec_ , newcmpt -> sgnd_ , newcmpt -> prec_ ) ;\n }\n if ( putint ( newcmpt -> stream_ , newcmpt -> sgnd_ , newcmpt -> prec_ , v ) ) goto error ;\n }\n }\n return 0 ;\n error : return - 1 ;\n }", "hash": 2820551931453396101, "project": "debian", "size": 92, "target": 0, "idx": 13997}
{"code": "static jas_seqent_t bitstoint ( uint_fast32_t v , int prec , bool sgnd ) {\n jas_seqent_t ret ;\n v &= JAS_ONES ( prec ) ;\n ret = ( sgnd && ( v & ( 1 << ( prec - 1 ) ) ) ) ? ( v - ( 1 << prec ) ) : v ;\n return ret ;\n }", "hash": 2820551931453396101, "project": "debian", "size": 6, "target": 0, "idx": 14013}
{"code": "static void jas_image_cmpt_destroy ( jas_image_cmpt_t * cmpt ) {\n if ( cmpt -> stream_ ) {\n jas_stream_close ( cmpt -> stream_ ) ;\n }\n jas_free ( cmpt ) ;\n }", "hash": 2820551931453396101, "project": "debian", "size": 6, "target": 0, "idx": 14015}
{"code": "int jas_image_fmtfromname ( char * name ) {\n int i ;\n char * ext ;\n jas_image_fmtinfo_t * fmtinfo ;\n if ( ! ( ext = strrchr ( name , '.' ) ) ) {\n return - 1 ;\n }\n ++ ext ;\n for ( i = 0 , fmtinfo = jas_image_fmtinfos ;\n i < jas_image_numfmts ;\n ++ i , ++ fmtinfo ) {\n if ( ! strcmp ( ext , fmtinfo -> ext ) ) {\n return fmtinfo -> id ;\n }\n }\n return - 1 ;\n }", "hash": 2820551931453396101, "project": "debian", "size": 17, "target": 0, "idx": 14025}
{"code": "static uint_fast32_t inttobits ( jas_seqent_t v , int prec , bool sgnd ) {\n uint_fast32_t ret ;\n ret = ( ( sgnd && v < 0 ) ? ( ( 1 << prec ) + v ) : v ) & JAS_ONES ( prec ) ;\n return ret ;\n }", "hash": 2820551931453396101, "project": "debian", "size": 5, "target": 0, "idx": 14033}
{"code": "BerElement * ber_dup ( BerElement * ber ) {\n BerElement * new ;\n assert ( ber != NULL ) ;\n assert ( LBER_VALID ( ber ) ) ;\n if ( ( new = ber_alloc_t ( ber -> ber_options ) ) == NULL ) {\n return NULL ;\n }\n * new = * ber ;\n assert ( LBER_VALID ( new ) ) ;\n return ( new ) ;\n }", "hash": -8704283573519790151, "project": "debian", "size": 11, "target": 0, "idx": 14045}
{"code": "int ber_flatten2 ( BerElement * ber , struct berval * bv , int alloc ) {\n assert ( bv != NULL ) ;\n if ( bv == NULL ) {\n return - 1 ;\n }\n if ( ber == NULL ) {\n bv -> bv_val = NULL ;\n bv -> bv_len = 0 ;\n }\n else if ( ber -> ber_sos_ptr != NULL ) {\n return - 1 ;\n }\n else {\n ber_len_t len = ber_pvt_ber_write ( ber ) ;\n if ( alloc ) {\n bv -> bv_val = ( char * ) ber_memalloc_x ( len + 1 , ber -> ber_memctx ) ;\n if ( bv -> bv_val == NULL ) {\n return - 1 ;\n }\n AC_MEMCPY ( bv -> bv_val , ber -> ber_buf , len ) ;\n bv -> bv_val [ len ] = '\\0' ;\n }\n else if ( ber -> ber_buf != NULL ) {\n bv -> bv_val = ber -> ber_buf ;\n bv -> bv_val [ len ] = '\\0' ;\n }\n else {\n bv -> bv_val = \"\" ;\n }\n bv -> bv_len = len ;\n }\n return 0 ;\n }", "hash": -8704283573519790151, "project": "debian", "size": 33, "target": 0, "idx": 14052}
{"code": "static void ehci_class_init ( ObjectClass * klass , void * data ) {\n DeviceClass * dc = DEVICE_CLASS ( klass ) ;\n PCIDeviceClass * k = PCI_DEVICE_CLASS ( klass ) ;\n k -> realize = usb_ehci_pci_realize ;\n k -> exit = usb_ehci_pci_exit ;\n k -> class_id = PCI_CLASS_SERIAL_USB ;\n k -> config_write = usb_ehci_pci_write_config ;\n dc -> vmsd = & vmstate_ehci_pci ;\n dc -> props = ehci_pci_properties ;\n dc -> reset = usb_ehci_pci_reset ;\n }", "hash": 2777995095263460833, "project": "debian", "size": 11, "target": 0, "idx": 14063}
{"code": "int ehci_create_ich9_with_companions ( PCIBus * bus , int slot ) {\n const struct ehci_companions * comp ;\n PCIDevice * ehci , * uhci ;\n BusState * usbbus ;\n const char * name ;\n int i ;\n switch ( slot ) {\n case 0x1d : name = \"ich9-usb-ehci1\" ;\n comp = ich9_1d ;\n break ;\n case 0x1a : name = \"ich9-usb-ehci2\" ;\n comp = ich9_1a ;\n break ;\n default : return - 1 ;\n }\n ehci = pci_create_multifunction ( bus , PCI_DEVFN ( slot , 7 ) , true , name ) ;\n qdev_init_nofail ( & ehci -> qdev ) ;\n usbbus = QLIST_FIRST ( & ehci -> qdev . child_bus ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n uhci = pci_create_multifunction ( bus , PCI_DEVFN ( slot , comp [ i ] . func ) , true , comp [ i ] . name ) ;\n qdev_prop_set_string ( & uhci -> qdev , \"masterbus\" , usbbus -> name ) ;\n qdev_prop_set_uint32 ( & uhci -> qdev , \"firstport\" , comp [ i ] . port ) ;\n qdev_init_nofail ( & uhci -> qdev ) ;\n }\n return 0 ;\n }", "hash": 2777995095263460833, "project": "debian", "size": 28, "target": 0, "idx": 14064}
{"code": "static void gs_heap_unregister_root ( gs_memory_t * mem , gs_gc_root_t * rp , client_name_t cname ) {\n }", "hash": -6252714751027237823, "project": "debian", "size": 2, "target": 0, "idx": 14076}
{"code": "int auth_server_connection_connect ( struct auth_server_connection * conn ) {\n const char * handshake ;\n int fd ;\n i_assert ( ! conn -> connected ) ;\n i_assert ( conn -> fd == - 1 ) ;\n conn -> last_connect = ioloop_time ;\n timeout_remove ( & conn -> to ) ;\n fd = net_connect_unix_with_retries ( conn -> client -> auth_socket_path , 1000 ) ;\n if ( fd == - 1 ) {\n if ( errno == EACCES ) {\n i_error ( \"auth: %s\" , eacces_error_get ( \"connect\" , conn -> client -> auth_socket_path ) ) ;\n }\n else {\n i_error ( \"auth: connect(%s) failed: %m\" , conn -> client -> auth_socket_path ) ;\n }\n return - 1 ;\n }\n conn -> fd = fd ;\n conn -> io = io_add ( fd , IO_READ , auth_server_connection_input , conn ) ;\n conn -> input = i_stream_create_fd ( fd , AUTH_SERVER_CONN_MAX_LINE_LENGTH ) ;\n conn -> output = o_stream_create_fd ( fd , ( size_t ) - 1 ) ;\n conn -> connected = TRUE ;\n handshake = t_strdup_printf ( \"VERSION\\t%u\\t%u\\nCPID\\t%u\\n\" , AUTH_CLIENT_PROTOCOL_MAJOR_VERSION , AUTH_CLIENT_PROTOCOL_MINOR_VERSION , conn -> client -> client_pid ) ;\n if ( o_stream_send_str ( conn -> output , handshake ) < 0 ) {\n i_warning ( \"Error sending handshake to auth server: %s\" , o_stream_get_error ( conn -> output ) ) ;\n auth_server_connection_disconnect ( conn , o_stream_get_error ( conn -> output ) ) ;\n return - 1 ;\n }\n conn -> to = timeout_add ( AUTH_HANDSHAKE_TIMEOUT , auth_client_handshake_timeout , conn ) ;\n return 0 ;\n }", "hash": 8170016074494868282, "project": "debian", "size": 31, "target": 0, "idx": 14099}
{"code": "static char * php_zip_make_relative_path ( char * path , int path_len ) {\n char * path_begin = path ;\n size_t i ;\n if ( path_len < 1 || path == NULL ) {\n return NULL ;\n }\n if ( IS_SLASH ( path [ 0 ] ) ) {\n return path + 1 ;\n }\n i = path_len ;\n while ( 1 ) {\n while ( i > 0 && ! IS_SLASH ( path [ i ] ) ) {\n i -- ;\n }\n if ( ! i ) {\n return path ;\n }\n if ( i >= 2 && ( path [ i - 1 ] == '.' || path [ i - 1 ] == ':' ) ) {\n path_begin = path + i + 1 ;\n break ;\n }\n i -- ;\n }\n return path_begin ;\n }", "hash": 7037573792123850742, "project": "debian", "size": 25, "target": 0, "idx": 14132}
{"code": "static PHP_NAMED_FUNCTION ( zif_zip_entry_filesize ) {\n php_zip_entry_get_info ( INTERNAL_FUNCTION_PARAM_PASSTHRU , 2 ) ;\n }", "hash": 7037573792123850742, "project": "debian", "size": 3, "target": 0, "idx": 14133}
{"code": "static int dtls1_retrieve_buffered_fragment ( SSL * s , long max , int * ok ) {\n pitem * item ;\n hm_fragment * frag ;\n int al ;\n * ok = 0 ;\n item = pqueue_peek ( s -> d1 -> buffered_messages ) ;\n if ( item == NULL ) return 0 ;\n frag = ( hm_fragment * ) item -> data ;\n if ( frag -> reassembly != NULL ) return 0 ;\n if ( s -> d1 -> handshake_read_seq == frag -> msg_header . seq ) {\n unsigned long frag_len = frag -> msg_header . frag_len ;\n pqueue_pop ( s -> d1 -> buffered_messages ) ;\n al = dtls1_preprocess_fragment ( s , & frag -> msg_header , max ) ;\n if ( al == 0 ) {\n unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ;\n memcpy ( & p [ frag -> msg_header . frag_off ] , frag -> fragment , frag -> msg_header . frag_len ) ;\n }\n dtls1_hm_fragment_free ( frag ) ;\n pitem_free ( item ) ;\n if ( al == 0 ) {\n * ok = 1 ;\n return frag_len ;\n }\n ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ;\n s -> init_num = 0 ;\n * ok = 0 ;\n return - 1 ;\n }\n else return 0 ;\n }", "hash": 3035587999006680483, "project": "debian", "size": 30, "target": 0, "idx": 14164}
{"code": "void proto_register_usb_vid ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_usb_vid_request , {\n \"bRequest\" , \"usbvideo.setup.bRequest\" , FT_UINT8 , BASE_HEX , VALS ( setup_request_names_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_length , {\n \"wLength\" , \"usbvideo.setup.wLength\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_request_error , {\n \"bRequestErrorCode\" , \"usbvideo.reqerror.code\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & request_error_codes_ext , 0 , \"Request Error Code\" , HFILL }\n }\n , {\n & hf_usb_vid_control_selector , {\n \"Control Selector\" , \"usbvideo.control.selector\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , \"ID of the control within its entity\" , HFILL }\n }\n , {\n & hf_usb_vid_control_entity , {\n \"Entity\" , \"usbvideo.control.entity\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , \"Unit or terminal to which the control belongs\" , HFILL }\n }\n , {\n & hf_usb_vid_control_interface , {\n \"Interface\" , \"usbvideo.control.interface\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , \"Interface to which the control belongs\" , HFILL }\n }\n , {\n & hf_usb_vid_control_info , {\n \"Info (Capabilities/State)\" , \"usbvideo.control.info\" , FT_UINT8 , BASE_HEX , NULL , 0 , \"Control capabilities and current state\" , HFILL }\n }\n , {\n & hf_usb_vid_control_info_D [ 0 ] , {\n \"Supports GET\" , \"usbvideo.control.info.D0\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 0 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_info_D [ 1 ] , {\n \"Supports SET\" , \"usbvideo.control.info.D1\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 1 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_info_D [ 2 ] , {\n \"Disabled due to automatic mode\" , \"usbvideo.control.info.D2\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 2 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_info_D [ 3 ] , {\n \"Autoupdate\" , \"usbvideo.control.info.D3\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 3 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_info_D [ 4 ] , {\n \"Asynchronous\" , \"usbvideo.control.info.D4\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 4 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_info_D [ 5 ] , {\n \"Disabled due to incompatibility with Commit state\" , \"usbvideo.control.info.D5\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 5 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_info_D [ 6 ] , {\n \"Reserved\" , \"usbvideo.control.info.D6\" , FT_UINT8 , BASE_HEX , NULL , ( 3 << 6 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_length , {\n \"Control Length\" , \"usbvideo.control.len\" , FT_UINT16 , BASE_DEC , NULL , 0 , \"Control size in bytes\" , HFILL }\n }\n , {\n & hf_usb_vid_control_default , {\n \"Default value\" , \"usbvideo.control.value.default\" , FT_UINT32 , BASE_DEC_HEX , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_min , {\n \"Minimum value\" , \"usbvideo.control.value.min\" , FT_UINT32 , BASE_DEC_HEX , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_max , {\n \"Maximum value\" , \"usbvideo.control.value.max\" , FT_UINT32 , BASE_DEC_HEX , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_res , {\n \"Resolution\" , \"usbvideo.control.value.res\" , FT_UINT32 , BASE_DEC_HEX , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_cur , {\n \"Current value\" , \"usbvideo.control.value.cur\" , FT_UINT32 , BASE_DEC_HEX , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_ifdesc_iTerminal , {\n \"iTerminal\" , \"usbvideo.terminal.name\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"String Descriptor describing this terminal\" , HFILL }\n }\n , {\n & hf_usb_vid_control_ifdesc_terminal_id , {\n \"bTerminalID\" , \"usbvideo.terminal.id\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_ifdesc_terminal_type , {\n \"wTerminalType\" , \"usbvideo.terminal.type\" , FT_UINT16 , BASE_HEX | BASE_EXT_STRING , & vc_terminal_types_ext , 0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_ifdesc_assoc_terminal , {\n \"bAssocTerminal\" , \"usbvideo.terminal.assocTerminal\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"Associated Terminal\" , HFILL }\n }\n , {\n & hf_usb_vid_cam_objective_focal_len_min , {\n \"wObjectiveFocalLengthMin\" , \"usbvideo.camera.objectiveFocalLengthMin\" , FT_UINT16 , BASE_DEC , NULL , 0 , \"Minimum Focal Length for Optical Zoom\" , HFILL }\n }\n , {\n & hf_usb_vid_cam_objective_focal_len_max , {\n \"wObjectiveFocalLengthMax\" , \"usbvideo.camera.objectiveFocalLengthMax\" , FT_UINT16 , BASE_DEC , NULL , 0 , \"Minimum Focal Length for Optical Zoom\" , HFILL }\n }\n , {\n & hf_usb_vid_cam_ocular_focal_len , {\n \"wOcularFocalLength\" , \"usbvideo.camera.ocularFocalLength\" , FT_UINT16 , BASE_DEC , NULL , 0 , \"Ocular Focal Length for Optical Zoom\" , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 0 ] , {\n \"Scanning Mode\" , \"usbvideo.camera.control.D0\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 0 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 1 ] , {\n \"Auto Exposure Mode\" , \"usbvideo.camera.control.D1\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 1 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 2 ] , {\n \"Auto Exposure Priority\" , \"usbvideo.camera.control.D2\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 2 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 3 ] , {\n \"Exposure Time (Absolute)\" , \"usbvideo.camera.control.D3\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 3 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 4 ] , {\n \"Exposure Time (Relative)\" , \"usbvideo.camera.control.D4\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 4 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 5 ] , {\n \"Focus (Absolute)\" , \"usbvideo.camera.control.D5\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 5 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 6 ] , {\n \"Focus (Relative)\" , \"usbvideo.camera.control.D6\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 6 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 7 ] , {\n \"Iris (Absolute)\" , \"usbvideo.camera.control.D7\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 7 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 8 ] , {\n \"Iris (Relative)\" , \"usbvideo.camera.control.D8\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 8 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 9 ] , {\n \"Zoom (Absolute)\" , \"usbvideo.camera.control.D9\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 9 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 10 ] , {\n \"Zoom (Relative)\" , \"usbvideo.camera.control.D10\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 10 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 11 ] , {\n \"PanTilt (Absolute)\" , \"usbvideo.camera.control.D11\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 11 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 12 ] , {\n \"PanTilt (Relative)\" , \"usbvideo.camera.control.D12\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 12 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 13 ] , {\n \"Roll (Absolute)\" , \"usbvideo.camera.control.D13\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 13 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 14 ] , {\n \"Roll (Relative)\" , \"usbvideo.camera.control.D14\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 14 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 15 ] , {\n \"D15\" , \"usbvideo.camera.control.D15\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 15 ) , \"Reserved\" , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 16 ] , {\n \"D16\" , \"usbvideo.camera.control.D16\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 16 ) , \"Reserved\" , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 17 ] , {\n \"Auto Focus\" , \"usbvideo.camera.control.D17\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 17 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 18 ] , {\n \"Privacy\" , \"usbvideo.camera.control.D18\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 18 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 19 ] , {\n \"Focus (Simple)\" , \"usbvideo.camera.control.D19\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 19 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 20 ] , {\n \"Window\" , \"usbvideo.camera.control.D20\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 20 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_cam_control_D [ 21 ] , {\n \"Region of Interest\" , \"usbvideo.camera.control.D21\" , FT_BOOLEAN , array_length ( hf_usb_vid_cam_control_D ) , TFS ( & tfs_yes_no ) , ( 1 << 21 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_ifdesc_unit_id , {\n \"bUnitID\" , \"usbvideo.unit.id\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_num_inputs , {\n \"bNrInPins\" , \"usbvideo.unit.numInputs\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Number of input pins\" , HFILL }\n }\n , {\n & hf_usb_vid_sources , {\n \"baSourceID\" , \"usbvideo.unit.sources\" , FT_BYTES , BASE_NONE , NULL , 0 , \"Input entity IDs\" , HFILL }\n }\n , {\n & hf_usb_vid_iProcessing , {\n \"iProcessing\" , \"usbvideo.processor.name\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"String Descriptor describing this terminal\" , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 0 ] , {\n \"Brightness\" , \"usbvideo.processor.control.D0\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 0 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 1 ] , {\n \"Contrast\" , \"usbvideo.processor.control.D1\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 1 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 2 ] , {\n \"Hue\" , \"usbvideo.processor.control.D2\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 2 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 3 ] , {\n \"Saturation\" , \"usbvideo.processor.control.D3\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 3 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 4 ] , {\n \"Sharpness\" , \"usbvideo.processor.control.D4\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 4 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 5 ] , {\n \"Gamma\" , \"usbvideo.processor.control.D5\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 5 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 6 ] , {\n \"White Balance Temperature\" , \"usbvideo.processor.control.D6\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 6 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 7 ] , {\n \"White Balance Component\" , \"usbvideo.processor.control.D7\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 7 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 8 ] , {\n \"Backlight Compensation\" , \"usbvideo.processor.control.D8\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 8 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 9 ] , {\n \"Gain\" , \"usbvideo.processor.control.D9\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 9 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 10 ] , {\n \"Power Line Frequency\" , \"usbvideo.processor.control.D10\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 10 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 11 ] , {\n \"Hue, Auto\" , \"usbvideo.processor.control.D11\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 11 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 12 ] , {\n \"White Balance Temperature, Auto\" , \"usbvideo.processor.control.D12\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 12 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 13 ] , {\n \"White Balance Component, Auto\" , \"usbvideo.processor.control.D13\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 13 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 14 ] , {\n \"Digital Multiplier\" , \"usbvideo.processor.control.D14\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 14 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 15 ] , {\n \"Digital Multiplier Limit\" , \"usbvideo.processor.control.D15\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 15 ) , \"Reserved\" , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 16 ] , {\n \"Analog Video Standard\" , \"usbvideo.processor.control.D16\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 16 ) , \"Reserved\" , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 17 ] , {\n \"Analog Video Lock Status\" , \"usbvideo.processor.control.D17\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 17 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_control_D [ 18 ] , {\n \"Contrast, Auto\" , \"usbvideo.processor.control.D18\" , FT_BOOLEAN , 24 , TFS ( & tfs_yes_no ) , ( 1 << 18 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_standards , {\n \"bmVideoStandards\" , \"usbvideo.processor.standards\" , FT_UINT8 , BASE_HEX , NULL , 0 , \"Supported analog video standards\" , HFILL }\n }\n , {\n & hf_usb_vid_proc_standards_D [ 0 ] , {\n \"None\" , \"usbvideo.processor.standards.D0\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 0 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_standards_D [ 1 ] , {\n \"NTSC - 525/60\" , \"usbvideo.processor.standards.D1\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 1 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_standards_D [ 2 ] , {\n \"PAL - 625/50\" , \"usbvideo.processor.standards.D2\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 2 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_standards_D [ 3 ] , {\n \"SECAM - 625/50\" , \"usbvideo.processor.standards.D3\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 3 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_standards_D [ 4 ] , {\n \"NTSC - 625/50\" , \"usbvideo.processor.standards.D4\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 4 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_proc_standards_D [ 5 ] , {\n \"PAL - 525/60\" , \"usbvideo.processor.standards.D5\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 5 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_max_multiplier , {\n \"wMaxMultiplier\" , \"usbvideo.processor.maxMultiplier\" , FT_UINT16 , BASE_DEC , NULL , 0 , \"100 x max digital multiplication\" , HFILL }\n }\n , {\n & hf_usb_vid_iSelector , {\n \"iSelector\" , \"usbvideo.selector.name\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"String Descriptor describing this terminal\" , HFILL }\n }\n , {\n & hf_usb_vid_iExtension , {\n \"iExtension\" , \"usbvideo.extension.name\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"String Descriptor describing this terminal\" , HFILL }\n }\n , {\n & hf_usb_vid_exten_guid , {\n \"guid\" , \"usbvideo.extension.guid\" , FT_GUID , BASE_NONE , NULL , 0 , \"Identifier\" , HFILL }\n }\n , {\n & hf_usb_vid_exten_num_controls , {\n \"bNumControls\" , \"usbvideo.extension.numControls\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Number of controls\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_hint , {\n \"bmHint\" , \"usbvideo.probe.hint\" , FT_UINT16 , BASE_HEX , NULL , 0 , \"Fields to hold constant during negotiation\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_hint_D [ 0 ] , {\n \"dwFrameInterval\" , \"usbvideo.probe.hint.D0\" , FT_BOOLEAN , 5 , TFS ( & probe_hint_meaning ) , ( 1 << 0 ) , \"Frame Rate\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_hint_D [ 1 ] , {\n \"wKeyFrameRate\" , \"usbvideo.probe.hint.D1\" , FT_BOOLEAN , 5 , TFS ( & probe_hint_meaning ) , ( 1 << 1 ) , \"Key Frame Rate\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_hint_D [ 2 ] , {\n \"wPFrameRate\" , \"usbvideo.probe.hint.D2\" , FT_BOOLEAN , 5 , TFS ( & probe_hint_meaning ) , ( 1 << 2 ) , \"P-Frame Rate\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_hint_D [ 3 ] , {\n \"wCompQuality\" , \"usbvideo.probe.hint.D3\" , FT_BOOLEAN , 5 , TFS ( & probe_hint_meaning ) , ( 1 << 3 ) , \"Compression Quality\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_hint_D [ 4 ] , {\n \"wCompWindowSize\" , \"usbvideo.probe.hint.D4\" , FT_BOOLEAN , 5 , TFS ( & probe_hint_meaning ) , ( 1 << 4 ) , \"Compression Window Size\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_key_frame_rate , {\n \"wKeyFrameRate\" , \"usbvideo.probe.keyFrameRate\" , FT_UINT16 , BASE_DEC , NULL , 0 , \"Key frame rate\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_p_frame_rate , {\n \"wPFrameRate\" , \"usbvideo.probe.pFrameRate\" , FT_UINT16 , BASE_DEC , NULL , 0 , \"P frame rate\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_comp_quality , {\n \"wCompQuality\" , \"usbvideo.probe.compQuality\" , FT_UINT16 , BASE_DEC , NULL , 0 , \"Compression quality [0-10000]\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_comp_window , {\n \"wCompWindow\" , \"usbvideo.probe.compWindow\" , FT_UINT16 , BASE_DEC , NULL , 0 , \"Window size for average bit rate control\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_delay , {\n \"wDelay\" , \"usbvideo.probe.delay\" , FT_UINT16 , BASE_DEC , NULL , 0 , \"Latency in ms from capture to USB\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_max_frame_sz , {\n \"dwMaxVideoFrameSize\" , \"usbvideo.probe.maxVideoFrameSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_probe_max_payload_sz , {\n \"dwMaxPayloadTransferSize\" , \"usbvideo.probe.maxPayloadTransferSize\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_probe_clock_freq , {\n \"dwClockFrequency\" , \"usbvideo.probe.clockFrequency\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"Device clock frequency in Hz\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_framing , {\n \"bmFramingInfo\" , \"usbvideo.probe.framing\" , FT_UINT16 , BASE_HEX , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_probe_framing_D [ 0 ] , {\n \"Frame ID required\" , \"usbvideo.probe.framing.D0\" , FT_BOOLEAN , 2 , TFS ( & tfs_yes_no ) , ( 1 << 0 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_probe_framing_D [ 1 ] , {\n \"EOF utilized\" , \"usbvideo.probe.framing.D1\" , FT_BOOLEAN , 2 , TFS ( & tfs_yes_no ) , ( 1 << 1 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_probe_preferred_ver , {\n \"bPreferredVersion\" , \"usbvideo.probe.preferredVersion\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Preferred payload format version\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_min_ver , {\n \"bMinVersion\" , \"usbvideo.probe.minVersion\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Min supported payload format version\" , HFILL }\n }\n , {\n & hf_usb_vid_probe_max_ver , {\n \"bPreferredVersion\" , \"usbvideo.probe.maxVer\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Max supported payload format version\" , HFILL }\n }\n , {\n & hf_usb_vid_control_ifdesc_dwClockFrequency , {\n \"dwClockFrequency\" , \"usbvideo.probe.clockFrequency\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"Device clock frequency (Hz) for selected format\" , HFILL }\n }\n , {\n & hf_usb_vid_format_index , {\n \"bFormatIndex\" , \"usbvideo.format.index\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Index of this format descriptor\" , HFILL }\n }\n , {\n & hf_usb_vid_format_num_frame_descriptors , {\n \"bNumFrameDescriptors\" , \"usbvideo.format.numFrameDescriptors\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Number of frame descriptors for this format\" , HFILL }\n }\n , {\n & hf_usb_vid_format_guid , {\n \"guidFormat\" , \"usbvideo.format.guid\" , FT_GUID , BASE_NONE , NULL , 0 , \"Stream encoding format\" , HFILL }\n }\n , {\n & hf_usb_vid_format_bits_per_pixel , {\n \"bBitsPerPixel\" , \"usbvideo.format.bitsPerPixel\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Bits per pixel\" , HFILL }\n }\n , {\n & hf_usb_vid_default_frame_index , {\n \"bDefaultFrameIndex\" , \"usbvideo.format.defaultFrameIndex\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Optimum frame index for this stream\" , HFILL }\n }\n , {\n & hf_usb_vid_aspect_ratio_x , {\n \"bAspectRatioX\" , \"usbvideo.format.aspectRatioX\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"X dimension of picture aspect ratio\" , HFILL }\n }\n , {\n & hf_usb_vid_aspect_ratio_y , {\n \"bAspectRatioY\" , \"usbvideo.format.aspectRatioY\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Y dimension of picture aspect ratio\" , HFILL }\n }\n , {\n & hf_usb_vid_interlace_flags , {\n \"bmInterlaceFlags\" , \"usbvideo.format.interlace\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_is_interlaced , {\n \"Interlaced stream\" , \"usbvideo.format.interlace.D0\" , FT_BOOLEAN , 8 , TFS ( & is_interlaced_meaning ) , ( 1 << 0 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_interlaced_fields , {\n \"Fields per frame\" , \"usbvideo.format.interlace.D1\" , FT_BOOLEAN , 8 , TFS ( & interlaced_fields_meaning ) , ( 1 << 1 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_field_1_first , {\n \"Field 1 first\" , \"usbvideo.format.interlace.D2\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 2 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_field_pattern , {\n \"Field pattern\" , \"usbvideo.format.interlace.pattern\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & field_pattern_meaning_ext , ( 3 << 4 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_copy_protect , {\n \"bCopyProtect\" , \"usbvideo.format.copyProtect\" , FT_UINT8 , BASE_DEC , VALS ( copy_protect_meaning ) , 0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_variable_size , {\n \"Variable size\" , \"usbvideo.format.variableSize\" , FT_BOOLEAN , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_mjpeg_flags , {\n \"bmFlags\" , \"usbvideo.mjpeg.flags\" , FT_UINT8 , BASE_HEX , NULL , 0 , \"Characteristics\" , HFILL }\n }\n , {\n & hf_usb_vid_mjpeg_fixed_samples , {\n \"Fixed size samples\" , \"usbvideo.mjpeg.fixed_size\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 0 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_frame_index , {\n \"bFrameIndex\" , \"usbvideo.frame.index\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Index of this frame descriptor\" , HFILL }\n }\n , {\n & hf_usb_vid_frame_capabilities , {\n \"bmCapabilities\" , \"usbvideo.frame.capabilities\" , FT_UINT8 , BASE_HEX , NULL , 0 , \"Capabilities\" , HFILL }\n }\n , {\n & hf_usb_vid_frame_stills_supported , {\n \"Still image\" , \"usbvideo.frame.stills\" , FT_BOOLEAN , 8 , TFS ( & tfs_supported_not_supported ) , ( 1 << 0 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_frame_interval , {\n \"dwFrameInterval\" , \"usbvideo.frame.interval\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"Frame interval multiple of 100 ns\" , HFILL }\n }\n , {\n & hf_usb_vid_frame_fixed_frame_rate , {\n \"Fixed frame rate\" , \"usbvideo.frame.fixedRate\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 1 ) , NULL , HFILL }\n }\n , {\n & hf_usb_vid_frame_width , {\n \"wWidth\" , \"usbvideo.frame.width\" , FT_UINT16 , BASE_DEC , NULL , 0 , \"Width of frame in pixels\" , HFILL }\n }\n , {\n & hf_usb_vid_frame_height , {\n \"wHeight\" , \"usbvideo.frame.height\" , FT_UINT16 , BASE_DEC , NULL , 0 , \"Height of frame in pixels\" , HFILL }\n }\n , {\n & hf_usb_vid_frame_min_bit_rate , {\n \"dwMinBitRate\" , \"usbvideo.frame.minBitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"Minimum bit rate in bps\" , HFILL }\n }\n , {\n & hf_usb_vid_frame_max_bit_rate , {\n \"dwMaxBitRate\" , \"usbvideo.frame.maxBitRate\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"Maximum bit rate in bps\" , HFILL }\n }\n , {\n & hf_usb_vid_frame_max_frame_sz , {\n \"dwMaxVideoFrameBufferSize\" , \"usbvideo.frame.maxBuffer\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"Maximum bytes per frame\" , HFILL }\n }\n , {\n & hf_usb_vid_frame_default_interval , {\n \"dwDefaultFrameInterval\" , \"usbvideo.frame.interval.default\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"Suggested default\" , HFILL }\n }\n , {\n & hf_usb_vid_frame_interval_type , {\n \"bFrameIntervalType\" , \"usbvideo.frame.interval.type\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Frame rate control (continuous/discrete)\" , HFILL }\n }\n , {\n & hf_usb_vid_frame_min_interval , {\n \"dwMinFrameInterval\" , \"usbvideo.frame.interval.min\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"Shortest frame interval (* 100 ns)\" , HFILL }\n }\n , {\n & hf_usb_vid_frame_max_interval , {\n \"dwMaxFrameInterval\" , \"usbvideo.frame.interval.max\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"Longest frame interval (* 100 ns)\" , HFILL }\n }\n , {\n & hf_usb_vid_frame_step_interval , {\n \"dwMinFrameInterval\" , \"usbvideo.frame.interval.step\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"Granularity of frame interval (* 100 ns)\" , HFILL }\n }\n , {\n & hf_usb_vid_frame_bytes_per_line , {\n \"dwBytesPerLine\" , \"usbvideo.frame.bytesPerLine\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"Fixed number of bytes per video line\" , HFILL }\n }\n , {\n & hf_usb_vid_color_primaries , {\n \"bColorPrimaries\" , \"usbvideo.color.primaries\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & color_primaries_meaning_ext , 0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_transfer_characteristics , {\n \"bTransferCharacteristics\" , \"usbvideo.color.transferCharacteristics\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & color_transfer_characteristics_ext , 0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_matrix_coefficients , {\n \"bMatrixCoefficients\" , \"usbvideo.color.matrixCoefficients\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & matrix_coefficients_meaning_ext , 0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_ifdesc_bcdUVC , {\n \"bcdUVC\" , \"usbvideo.bcdUVC\" , FT_UINT16 , BASE_HEX , NULL , 0 , \"Video Device Class Specification release number\" , HFILL }\n }\n , {\n & hf_usb_vid_control_ifdesc_bInCollection , {\n \"bInCollection\" , \"usbvideo.numStreamingInterfaces\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Number of VideoStreaming interfaces\" , HFILL }\n }\n , {\n & hf_usb_vid_control_ifdesc_baInterfaceNr , {\n \"baInterfaceNr\" , \"usbvideo.streamingInterfaceNumbers\" , FT_BYTES , BASE_NONE , NULL , 0 , \"Interface numbers of VideoStreaming interfaces\" , HFILL }\n }\n , {\n & hf_usb_vid_streaming_ifdesc_bNumFormats , {\n \"bNumFormats\" , \"usbvideo.streaming.numFormats\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Number of video payload format descriptors\" , HFILL }\n }\n , {\n & hf_usb_vid_streaming_bmInfo , {\n \"bmInfo\" , \"usbvideo.streaming.info\" , FT_UINT8 , BASE_HEX , NULL , 0 , \"Capabilities\" , HFILL }\n }\n , {\n & hf_usb_vid_streaming_info_D [ 0 ] , {\n \"Dynamic Format Change\" , \"usbvideo.streaming.info.D0\" , FT_BOOLEAN , 8 , TFS ( & tfs_yes_no ) , ( 1 << 0 ) , \"Dynamic Format Change\" , HFILL }\n }\n , {\n & hf_usb_vid_streaming_control_D [ 0 ] , {\n \"wKeyFrameRate\" , \"usbvideo.streaming.control.D0\" , FT_BOOLEAN , 6 , TFS ( & tfs_yes_no ) , ( 1 << 0 ) , \"Probe and Commit support\" , HFILL }\n }\n , {\n & hf_usb_vid_streaming_control_D [ 1 ] , {\n \"wPFrameRate\" , \"usbvideo.streaming.control.D1\" , FT_BOOLEAN , 6 , TFS ( & tfs_yes_no ) , ( 1 << 1 ) , \"Probe and Commit support\" , HFILL }\n }\n , {\n & hf_usb_vid_streaming_control_D [ 2 ] , {\n \"wCompQuality\" , \"usbvideo.streaming.control.D2\" , FT_BOOLEAN , 6 , TFS ( & tfs_yes_no ) , ( 1 << 2 ) , \"Probe and Commit support\" , HFILL }\n }\n , {\n & hf_usb_vid_streaming_control_D [ 3 ] , {\n \"wCompWindowSize\" , \"usbvideo.streaming.control.D3\" , FT_BOOLEAN , 6 , TFS ( & tfs_yes_no ) , ( 1 << 3 ) , \"Probe and Commit support\" , HFILL }\n }\n , {\n & hf_usb_vid_streaming_control_D [ 4 ] , {\n \"Generate Key Frame\" , \"usbvideo.streaming.control.D4\" , FT_BOOLEAN , 6 , TFS ( & tfs_yes_no ) , ( 1 << 4 ) , \"Probe and Commit support\" , HFILL }\n }\n , {\n & hf_usb_vid_streaming_control_D [ 5 ] , {\n \"Update Frame Segment\" , \"usbvideo.streaming.control.D5\" , FT_BOOLEAN , 6 , TFS ( & tfs_yes_no ) , ( 1 << 5 ) , \"Probe and Commit support\" , HFILL }\n }\n , {\n & hf_usb_vid_streaming_terminal_link , {\n \"bTerminalLink\" , \"usbvideo.streaming.terminalLink\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"Output terminal ID\" , HFILL }\n }\n , {\n & hf_usb_vid_streaming_still_capture_method , {\n \"bStillCaptureMethod\" , \"usbvideo.streaming.stillCaptureMethod\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & vs_still_capture_methods_ext , 0 , \"Method of Still Image Capture\" , HFILL }\n }\n , {\n & hf_usb_vid_streaming_trigger_support , {\n \"HW Triggering\" , \"usbvideo.streaming.triggerSupport\" , FT_BOOLEAN , BASE_DEC , TFS ( & tfs_supported_not_supported ) , 0 , \"Is HW triggering supported\" , HFILL }\n }\n , {\n & hf_usb_vid_streaming_trigger_usage , {\n \"bTriggerUsage\" , \"usbvideo.streaming.triggerUsage\" , FT_UINT8 , BASE_DEC , VALS ( vs_trigger_usage ) , 0 , \"How host SW should respond to trigger\" , HFILL }\n }\n , {\n & hf_usb_vid_interrupt_bStatusType , {\n \"Status Type\" , \"usbvideo.interrupt.statusType\" , FT_UINT8 , BASE_HEX , VALS ( interrupt_status_types ) , 0xF , NULL , HFILL }\n }\n , {\n & hf_usb_vid_interrupt_bAttribute , {\n \"Change Type\" , \"usbvideo.interrupt.attribute\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & control_change_types_ext , 0 , \"Type of control change\" , HFILL }\n }\n , {\n & hf_usb_vid_interrupt_bOriginator , {\n \"Originator\" , \"usbvideo.interrupt.originator\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"ID of the entity that reports this interrupt\" , HFILL }\n }\n , {\n & hf_usb_vid_control_interrupt_bEvent , {\n \"Event\" , \"usbvideo.interrupt.controlEvent\" , FT_UINT8 , BASE_HEX , VALS ( control_interrupt_events ) , 0 , \"Type of event\" , HFILL }\n }\n , {\n & hf_usb_vid_epdesc_subtype , {\n \"Subtype\" , \"usbvideo.ep.descriptorSubType\" , FT_UINT8 , BASE_DEC , VALS ( vc_ep_descriptor_subtypes ) , 0 , \"Descriptor Subtype\" , HFILL }\n }\n , {\n & hf_usb_vid_epdesc_max_transfer_sz , {\n \"wMaxTransferSize\" , \"usbvideo.ep.maxInterruptSize\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Max interrupt structure size\" , HFILL }\n }\n , {\n & hf_usb_vid_ifdesc_wTotalLength , {\n \"wTotalLength\" , \"usbvideo.totalLength\" , FT_UINT16 , BASE_DEC , NULL , 0 , \"Video interface descriptor size\" , HFILL }\n }\n , {\n & hf_usb_vid_bControlSize , {\n \"bControlSize\" , \"usbvideo.bmcontrolSize\" , FT_UINT8 , BASE_DEC , NULL , 0 , \"Size of bmControls field\" , HFILL }\n }\n , {\n & hf_usb_vid_bmControl , {\n \"bmControl\" , \"usbvideo.availableControls\" , FT_UINT32 , BASE_HEX , NULL , 0 , \"Available controls\" , HFILL }\n }\n , {\n & hf_usb_vid_bmControl_bytes , {\n \"bmControl\" , \"usbvideo.availableControls.bytes\" , FT_BYTES , BASE_NONE , NULL , 0 , \"Available controls\" , HFILL }\n }\n , {\n & hf_usb_vid_control_ifdesc_src_id , {\n \"bSourceID\" , \"usbvideo.sourceID\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"Entity to which this terminal/unit is connected\" , HFILL }\n }\n , {\n & hf_usb_vid_control_ifdesc_subtype , {\n \"Subtype\" , \"usbvideo.control.descriptorSubType\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & vc_if_descriptor_subtypes_ext , 0 , \"Descriptor Subtype\" , HFILL }\n }\n , {\n & hf_usb_vid_streaming_ifdesc_subtype , {\n \"Subtype\" , \"usbvideo.streaming.descriptorSubType\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & vs_if_descriptor_subtypes_ext , 0 , \"Descriptor Subtype\" , HFILL }\n }\n , {\n & hf_usb_vid_descriptor_data , {\n \"Descriptor data\" , \"usbvideo.descriptor_data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_data , {\n \"Control data\" , \"usbvideo.control_data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_control_value , {\n \"Control value\" , \"usbvideo.control_value\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_usb_vid_value_data , {\n \"Value data\" , \"usbvideo.value_data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , }\n ;\n static gint * usb_vid_subtrees [ ] = {\n & ett_usb_vid , & ett_descriptor_video_endpoint , & ett_descriptor_video_control , & ett_descriptor_video_streaming , & ett_camera_controls , & ett_processing_controls , & ett_streaming_controls , & ett_streaming_info , & ett_interlace_flags , & ett_frame_capability_flags , & ett_mjpeg_flags , & ett_video_probe , & ett_probe_hint , & ett_probe_framing , & ett_video_standards , & ett_control_capabilities }\n ;\n static ei_register_info ei [ ] = {\n {\n & ei_usb_vid_subtype_unknown , {\n \"usbvideo.subtype.unknown\" , PI_UNDECODED , PI_WARN , \"Unknown VC subtype\" , EXPFILL }\n }\n , {\n & ei_usb_vid_bitmask_len , {\n \"usbvideo.bitmask_len_error\" , PI_UNDECODED , PI_WARN , \"Only least-significant bytes decoded\" , EXPFILL }\n }\n , }\n ;\n expert_module_t * expert_usb_vid ;\n proto_usb_vid = proto_register_protocol ( \"USB Video\" , \"USBVIDEO\" , \"usbvideo\" ) ;\n proto_register_field_array ( proto_usb_vid , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( usb_vid_subtrees , array_length ( usb_vid_subtrees ) ) ;\n expert_usb_vid = expert_register_protocol ( proto_usb_vid ) ;\n expert_register_field_array ( expert_usb_vid , ei , array_length ( ei ) ) ;\n }", "hash": -187662502455871220, "project": "debian", "size": 717, "target": 0, "idx": 14173}
{"code": "static int dissect_usb_vid_interrupt ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n usb_conv_info_t * usb_conv_info ;\n gint bytes_available ;\n int offset = 0 ;\n usb_conv_info = ( usb_conv_info_t * ) data ;\n bytes_available = tvb_reported_length_remaining ( tvb , offset ) ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"USBVIDEO\" ) ;\n if ( bytes_available > 0 ) {\n guint8 originating_interface ;\n guint8 originating_entity ;\n originating_interface = tvb_get_guint8 ( tvb , offset ) & INT_ORIGINATOR_MASK ;\n proto_tree_add_item ( tree , hf_usb_vid_interrupt_bStatusType , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset ++ ;\n originating_entity = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_usb_vid_interrupt_bOriginator , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset ++ ;\n if ( originating_interface == INT_VIDEOCONTROL ) {\n guint8 control_sel ;\n guint8 attribute ;\n const gchar * control_name ;\n proto_tree_add_item ( tree , hf_usb_vid_control_interrupt_bEvent , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset ++ ;\n control_sel = tvb_get_guint8 ( tvb , offset ) ;\n control_name = get_control_selector_name ( originating_entity , control_sel , usb_conv_info ) ;\n if ( ! control_name ) control_name = \"Unknown\" ;\n proto_tree_add_uint_format_value ( tree , hf_usb_vid_control_selector , tvb , offset , 1 , control_sel , \"%s (0x%02x)\" , control_name , control_sel ) ;\n offset ++ ;\n attribute = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_usb_vid_interrupt_bAttribute , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset ++ ;\n switch ( attribute ) {\n case CONTROL_CHANGE_FAILURE : proto_tree_add_item ( tree , hf_usb_vid_request_error , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset ++ ;\n break ;\n case CONTROL_CHANGE_INFO : offset = dissect_usb_vid_control_info ( tree , tvb , offset ) ;\n break ;\n case CONTROL_CHANGE_VALUE : case CONTROL_CHANGE_MIN : case CONTROL_CHANGE_MAX : dissect_usb_vid_control_value ( tree , tvb , offset , attribute ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n break ;\n default : proto_tree_add_item ( tree , hf_usb_vid_value_data , tvb , offset , - 1 , ENC_NA ) ;\n offset += tvb_reported_length_remaining ( tvb , offset ) ;\n break ;\n }\n }\n else if ( originating_interface == INT_VIDEOSTREAMING ) {\n }\n }\n else offset = - 2 ;\n return offset ;\n }", "hash": -187662502455871220, "project": "debian", "size": 50, "target": 0, "idx": 14186}
{"code": "static gboolean dissect_u3v_heur ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n guint32 prefix ;\n usb_conv_info_t * usb_conv_info ;\n if ( tvb_reported_length ( tvb ) < 4 ) return FALSE ;\n prefix = tvb_get_letohl ( tvb , 0 ) ;\n usb_conv_info = ( usb_conv_info_t * ) data ;\n if ( ! usb_conv_info ) return FALSE ;\n if ( ( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix ) || ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) || ( ( usb_conv_info -> interfaceClass == IF_CLASS_MISCELLANEOUS && usb_conv_info -> interfaceSubclass == IF_SUBCLASS_MISC_U3V ) ) ) {\n dissect_u3v ( tvb , pinfo , tree , data ) ;\n return TRUE ;\n }\n return FALSE ;\n }", "hash": 8415334249344417068, "project": "debian", "size": 13, "target": 0, "idx": 14206}
{"code": "static gint dissect_ac_if_feature_unit ( tvbuff_t * tvb , gint offset , packet_info * pinfo _U_ , proto_tree * tree , usb_conv_info_t * usb_conv_info _U_ ) {\n gint offset_start ;\n guint8 controlsize ;\n proto_tree * bitmap_tree ;\n proto_item * ti ;\n static const int * fu_controls0 [ ] = {\n & hf_ac_if_fu_controls_d0 , & hf_ac_if_fu_controls_d1 , & hf_ac_if_fu_controls_d2 , & hf_ac_if_fu_controls_d3 , & hf_ac_if_fu_controls_d4 , & hf_ac_if_fu_controls_d5 , & hf_ac_if_fu_controls_d6 , & hf_ac_if_fu_controls_d7 , NULL }\n ;\n static const int * fu_controls1 [ ] = {\n & hf_ac_if_fu_controls_d8 , & hf_ac_if_fu_controls_d9 , & hf_ac_if_fu_controls_rsv , NULL }\n ;\n offset_start = offset ;\n proto_tree_add_item ( tree , hf_ac_if_fu_unitid , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_ac_if_fu_sourceid , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset += 1 ;\n proto_tree_add_item ( tree , hf_ac_if_fu_controlsize , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n controlsize = tvb_get_guint8 ( tvb , offset ) + 1 ;\n offset += 1 ;\n ti = proto_tree_add_item ( tree , hf_ac_if_fu_controls , tvb , offset , controlsize , ENC_NA ) ;\n bitmap_tree = proto_item_add_subtree ( ti , ett_ac_if_fu_controls ) ;\n proto_tree_add_bitmask ( bitmap_tree , tvb , offset , hf_ac_if_fu_control , ett_ac_if_fu_controls0 , fu_controls0 , ENC_LITTLE_ENDIAN ) ;\n if ( controlsize >= 1 ) {\n proto_tree_add_bitmask ( bitmap_tree , tvb , offset + 1 , hf_ac_if_fu_control , ett_ac_if_fu_controls1 , fu_controls1 , ENC_LITTLE_ENDIAN ) ;\n }\n offset += controlsize ;\n proto_tree_add_item ( tree , hf_ac_if_fu_ifeature , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset += 1 ;\n return offset - offset_start ;\n }", "hash": -8962831256613787672, "project": "debian", "size": 30, "target": 0, "idx": 14226}
{"code": "static gint dissect_usb_audio_descriptor ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n gint offset = 0 ;\n usb_conv_info_t * usb_conv_info ;\n proto_tree * desc_tree = NULL ;\n proto_item * desc_tree_item ;\n guint8 desc_len ;\n guint8 desc_type ;\n guint8 desc_subtype ;\n const gchar * subtype_str ;\n usb_conv_info = ( usb_conv_info_t * ) data ;\n if ( ! usb_conv_info || usb_conv_info -> interfaceClass != IF_CLASS_AUDIO ) return 0 ;\n desc_len = tvb_get_guint8 ( tvb , offset ) ;\n desc_type = tvb_get_guint8 ( tvb , offset + 1 ) ;\n if ( desc_type == CS_INTERFACE && usb_conv_info -> interfaceSubclass == AUDIO_IF_SUBCLASS_AUDIOCONTROL ) {\n desc_tree = proto_tree_add_subtree ( tree , tvb , offset , desc_len , ett_usb_audio_desc , & desc_tree_item , \"Class-specific Audio Control Interface Descriptor\" ) ;\n dissect_usb_descriptor_header ( desc_tree , tvb , offset , & aud_descriptor_type_vals_ext ) ;\n offset += 2 ;\n desc_subtype = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( desc_tree , hf_ac_if_desc_subtype , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n subtype_str = try_val_to_str_ext ( desc_subtype , & ac_subtype_vals_ext ) ;\n if ( subtype_str ) proto_item_append_text ( desc_tree_item , \": %s\" , subtype_str ) ;\n offset ++ ;\n switch ( desc_subtype ) {\n case AC_SUBTYPE_HEADER : dissect_ac_if_hdr_body ( tvb , offset , pinfo , desc_tree , usb_conv_info ) ;\n break ;\n case AC_SUBTYPE_INPUT_TERMINAL : dissect_ac_if_input_terminal ( tvb , offset , pinfo , desc_tree , usb_conv_info ) ;\n break ;\n case AC_SUBTYPE_OUTPUT_TERMINAL : dissect_ac_if_output_terminal ( tvb , offset , pinfo , desc_tree , usb_conv_info ) ;\n break ;\n case AC_SUBTYPE_FEATURE_UNIT : dissect_ac_if_feature_unit ( tvb , offset , pinfo , desc_tree , usb_conv_info ) ;\n break ;\n default : proto_tree_add_expert ( desc_tree , pinfo , & ei_usb_audio_undecoded , tvb , offset - 3 , desc_len ) ;\n break ;\n }\n }\n else if ( desc_type == CS_INTERFACE && usb_conv_info -> interfaceSubclass == AUDIO_IF_SUBCLASS_AUDIOSTREAMING ) {\n desc_tree = proto_tree_add_subtree ( tree , tvb , offset , desc_len , ett_usb_audio_desc , & desc_tree_item , \"Class-specific Audio Streaming Interface Descriptor\" ) ;\n dissect_usb_descriptor_header ( desc_tree , tvb , offset , & aud_descriptor_type_vals_ext ) ;\n offset += 2 ;\n desc_subtype = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( desc_tree , hf_as_if_desc_subtype , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n subtype_str = try_val_to_str_ext ( desc_subtype , & as_subtype_vals_ext ) ;\n if ( subtype_str ) proto_item_append_text ( desc_tree_item , \": %s\" , subtype_str ) ;\n offset ++ ;\n switch ( desc_subtype ) {\n case AS_SUBTYPE_GENERAL : dissect_as_if_general_body ( tvb , offset , pinfo , desc_tree , usb_conv_info ) ;\n break ;\n case AS_SUBTYPE_FORMAT_TYPE : dissect_as_if_format_type_body ( tvb , offset , pinfo , desc_tree , usb_conv_info ) ;\n break ;\n default : proto_tree_add_expert ( desc_tree , pinfo , & ei_usb_audio_undecoded , tvb , offset - 3 , desc_len ) ;\n break ;\n }\n }\n else if ( desc_type == CS_ENDPOINT && usb_conv_info -> interfaceSubclass == AUDIO_IF_SUBCLASS_AUDIOSTREAMING ) {\n desc_tree = proto_tree_add_subtree ( tree , tvb , offset , desc_len , ett_usb_audio_desc , & desc_tree_item , \"Class-specific Audio Streaming Endpoint Descriptor\" ) ;\n dissect_usb_descriptor_header ( desc_tree , tvb , offset , & aud_descriptor_type_vals_ext ) ;\n offset += 2 ;\n proto_tree_add_item ( desc_tree , hf_as_ep_desc_subtype , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n }\n else return 0 ;\n return desc_len ;\n }", "hash": -8962831256613787672, "project": "debian", "size": 62, "target": 0, "idx": 14231}
{"code": "const char * SSL_alert_desc_string ( int value ) {\n const char * str ;\n switch ( value & 0xff ) {\n case SSL3_AD_CLOSE_NOTIFY : str = \"CN\" ;\n break ;\n case SSL3_AD_UNEXPECTED_MESSAGE : str = \"UM\" ;\n break ;\n case SSL3_AD_BAD_RECORD_MAC : str = \"BM\" ;\n break ;\n case SSL3_AD_DECOMPRESSION_FAILURE : str = \"DF\" ;\n break ;\n case SSL3_AD_HANDSHAKE_FAILURE : str = \"HF\" ;\n break ;\n case SSL3_AD_NO_CERTIFICATE : str = \"NC\" ;\n break ;\n case SSL3_AD_BAD_CERTIFICATE : str = \"BC\" ;\n break ;\n case SSL3_AD_UNSUPPORTED_CERTIFICATE : str = \"UC\" ;\n break ;\n case SSL3_AD_CERTIFICATE_REVOKED : str = \"CR\" ;\n break ;\n case SSL3_AD_CERTIFICATE_EXPIRED : str = \"CE\" ;\n break ;\n case SSL3_AD_CERTIFICATE_UNKNOWN : str = \"CU\" ;\n break ;\n case SSL3_AD_ILLEGAL_PARAMETER : str = \"IP\" ;\n break ;\n case TLS1_AD_DECRYPTION_FAILED : str = \"DC\" ;\n break ;\n case TLS1_AD_RECORD_OVERFLOW : str = \"RO\" ;\n break ;\n case TLS1_AD_UNKNOWN_CA : str = \"CA\" ;\n break ;\n case TLS1_AD_ACCESS_DENIED : str = \"AD\" ;\n break ;\n case TLS1_AD_DECODE_ERROR : str = \"DE\" ;\n break ;\n case TLS1_AD_DECRYPT_ERROR : str = \"CY\" ;\n break ;\n case TLS1_AD_EXPORT_RESTRICTION : str = \"ER\" ;\n break ;\n case TLS1_AD_PROTOCOL_VERSION : str = \"PV\" ;\n break ;\n case TLS1_AD_INSUFFICIENT_SECURITY : str = \"IS\" ;\n break ;\n case TLS1_AD_INTERNAL_ERROR : str = \"IE\" ;\n break ;\n case TLS1_AD_USER_CANCELLED : str = \"US\" ;\n break ;\n case TLS1_AD_NO_RENEGOTIATION : str = \"NR\" ;\n break ;\n case TLS1_AD_UNSUPPORTED_EXTENSION : str = \"UE\" ;\n break ;\n case TLS1_AD_CERTIFICATE_UNOBTAINABLE : str = \"CO\" ;\n break ;\n case TLS1_AD_UNRECOGNIZED_NAME : str = \"UN\" ;\n break ;\n case TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE : str = \"BR\" ;\n break ;\n case TLS1_AD_BAD_CERTIFICATE_HASH_VALUE : str = \"BH\" ;\n break ;\n case TLS1_AD_UNKNOWN_PSK_IDENTITY : str = \"UP\" ;\n break ;\n default : str = \"UK\" ;\n break ;\n }\n return ( str ) ;\n }", "hash": 6380456053173444622, "project": "debian", "size": 68, "target": 0, "idx": 14264}
{"code": "static int dissect_pvfs_distribution ( tvbuff_t * tvb , proto_tree * tree , int offset ) {\n proto_item * dist_item ;\n proto_tree * dist_tree ;\n guint32 distlen ;\n char * tmpstr ;\n guint8 issimplestripe = 0 ;\n guint32 total_len ;\n distlen = tvb_get_letohl ( tvb , offset ) ;\n tmpstr = ( char * ) tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , offset + 4 , distlen , ENC_ASCII ) ;\n total_len = roundup8 ( 4 + distlen + 1 ) ;\n if ( ( ( distlen + 1 ) == PVFS_DIST_SIMPLE_STRIPE_NAME_SIZE ) && ( g_ascii_strncasecmp ( tmpstr , PVFS_DIST_SIMPLE_STRIPE_NAME , distlen ) == 0 ) ) {\n total_len += 8 ;\n issimplestripe = 1 ;\n }\n dist_item = proto_tree_add_string ( tree , hf_pvfs_distribution , tvb , offset , total_len + 8 , tmpstr ) ;\n dist_tree = proto_item_add_subtree ( dist_item , ett_pvfs_distribution ) ;\n offset = dissect_pvfs_string ( tvb , dist_tree , hf_pvfs_io_dist , offset , NULL ) ;\n if ( issimplestripe ) offset = dissect_pvfs_uint64 ( tvb , dist_tree , offset , hf_pvfs_strip_size , NULL ) ;\n offset += 8 ;\n return offset ;\n }", "hash": 4876100961671882393, "project": "debian", "size": 21, "target": 0, "idx": 14279}
{"code": "static int dissect_pvfs2_common_header ( tvbuff_t * tvb , proto_tree * tree , int offset ) {\n proto_tree_add_item ( tree , hf_pvfs_release_number , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_pvfs_encoding , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_pvfs_server_op , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n return offset ;\n }", "hash": 4876100961671882393, "project": "debian", "size": 9, "target": 0, "idx": 14282}
{"code": "static int dissect_pvfs2_readdir_request ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n offset = dissect_pvfs_fh ( tvb , offset , pinfo , tree , \"handle\" , NULL ) ;\n offset = dissect_pvfs_fs_id ( tvb , tree , offset ) ;\n proto_tree_add_item ( tree , hf_pvfs_ds_position , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_pvfs_dirent_limit , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n return offset ;\n }", "hash": 4876100961671882393, "project": "debian", "size": 9, "target": 0, "idx": 14296}
{"code": "static void dissect_fhandle_data ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , guint32 * hash ) {\n guint32 fhhash ;\n guint32 i ;\n if ( ! tvb_bytes_exist ( tvb , offset , PVFS2_FH_LENGTH ) ) goto type_ready ;\n for ( fhhash = 0 , i = 0 ;\n i < ( PVFS2_FH_LENGTH - 3 ) ;\n i += 4 ) {\n guint32 val ;\n val = tvb_get_ntohl ( tvb , offset + i ) ;\n fhhash ^= val ;\n fhhash += val ;\n }\n proto_tree_add_uint ( tree , hf_pvfs_fh_hash , tvb , offset , PVFS2_FH_LENGTH , fhhash ) ;\n if ( hash ) * hash = fhhash ;\n type_ready : dissect_fhandle_data_unknown ( tvb , offset , tree ) ;\n }", "hash": 4876100961671882393, "project": "debian", "size": 16, "target": 0, "idx": 14315}
{"code": "static int dissect_pvfs2_flush_request ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n offset = dissect_pvfs_fh ( tvb , offset , pinfo , tree , \"handle\" , NULL ) ;\n offset = dissect_pvfs_fs_id ( tvb , tree , offset ) ;\n proto_tree_add_item ( tree , hf_pvfs_flush_request_flags , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n return offset ;\n }", "hash": 4876100961671882393, "project": "debian", "size": 7, "target": 0, "idx": 14317}
{"code": "static int dissect_pvfs2_geteattr_response ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo _U_ ) {\n offset += 4 ;\n offset = dissect_ds_keyval_array ( tvb , tree , offset ) ;\n return offset ;\n }", "hash": 4876100961671882393, "project": "debian", "size": 5, "target": 0, "idx": 14335}
{"code": "static int dissect_pvfs_handle_extent_array ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n guint32 extent_count ;\n guint32 nCount ;\n proto_tree * extent_array_tree ;\n extent_count = tvb_get_letohl ( tvb , offset ) ;\n extent_array_tree = proto_tree_add_subtree_format ( tree , tvb , offset , 4 , ett_pvfs_extent_array_tree , NULL , \"Handle Extent Array (count = %d)\" , extent_count ) ;\n offset += 4 ;\n if ( extent_count > 0 ) {\n for ( nCount = 0 ;\n nCount < extent_count ;\n nCount ++ ) offset = dissect_pvfs_handle_extent ( tvb , extent_array_tree , offset , pinfo , nCount ) ;\n }\n return offset ;\n }", "hash": 4876100961671882393, "project": "debian", "size": 14, "target": 0, "idx": 14336}
{"code": "static int dissect_pvfs2_mgmt_remove_object_response ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n offset = dissect_pvfs_fh ( tvb , offset , pinfo , tree , \"handle\" , NULL ) ;\n offset = dissect_pvfs_fs_id ( tvb , tree , offset ) ;\n return offset ;\n }", "hash": 4876100961671882393, "project": "debian", "size": 5, "target": 0, "idx": 14349}
{"code": "bool send_add_edge ( connection_t * c , const edge_t * e ) {\n bool x ;\n char * address , * port ;\n sockaddr2str ( & e -> address , & address , & port ) ;\n x = send_request ( c , \"%d %x %s %s %s %s %x %d\" , ADD_EDGE , rand ( ) , e -> from -> name , e -> to -> name , address , port , e -> options , e -> weight ) ;\n free ( address ) ;\n free ( port ) ;\n return x ;\n }", "hash": 5691941650720729539, "project": "debian", "size": 9, "target": 0, "idx": 14354}
{"code": "bool ack_h ( connection_t * c ) {\n char hisport [ MAX_STRING_SIZE ] ;\n int weight , mtu ;\n uint32_t options ;\n node_t * n ;\n bool choice ;\n if ( sscanf ( c -> buffer , \"%*d \" MAX_STRING \" %d %x\" , hisport , & weight , & options ) != 3 ) {\n logger ( LOG_ERR , \"Got bad %s from %s (%s)\" , \"ACK\" , c -> name , c -> hostname ) ;\n return false ;\n }\n n = lookup_node ( c -> name ) ;\n if ( ! n ) {\n n = new_node ( ) ;\n n -> name = xstrdup ( c -> name ) ;\n node_add ( n ) ;\n }\n else {\n if ( n -> connection ) {\n ifdebug ( CONNECTIONS ) logger ( LOG_DEBUG , \"Established a second connection with %s (%s), closing old connection\" , n -> name , n -> hostname ) ;\n terminate_connection ( n -> connection , false ) ;\n graph ( ) ;\n }\n }\n n -> connection = c ;\n c -> node = n ;\n if ( ! ( c -> options & options & OPTION_PMTU_DISCOVERY ) ) {\n c -> options &= ~ OPTION_PMTU_DISCOVERY ;\n options &= ~ OPTION_PMTU_DISCOVERY ;\n }\n c -> options |= options ;\n if ( get_config_int ( lookup_config ( c -> config_tree , \"PMTU\" ) , & mtu ) && mtu < n -> mtu ) {\n n -> mtu = mtu ;\n }\n if ( get_config_int ( lookup_config ( config_tree , \"PMTU\" ) , & mtu ) && mtu < n -> mtu ) {\n n -> mtu = mtu ;\n }\n if ( get_config_bool ( lookup_config ( c -> config_tree , \"ClampMSS\" ) , & choice ) ) {\n if ( choice ) {\n c -> options |= OPTION_CLAMP_MSS ;\n }\n else {\n c -> options &= ~ OPTION_CLAMP_MSS ;\n }\n }\n c -> allow_request = ALL ;\n c -> status . active = true ;\n ifdebug ( CONNECTIONS ) logger ( LOG_NOTICE , \"Connection with %s (%s) activated\" , c -> name , c -> hostname ) ;\n send_everything ( c ) ;\n c -> edge = new_edge ( ) ;\n c -> edge -> from = myself ;\n c -> edge -> to = n ;\n sockaddrcpy ( & c -> edge -> address , & c -> address ) ;\n sockaddr_setport ( & c -> edge -> address , hisport ) ;\n c -> edge -> weight = ( weight + c -> estimated_weight ) / 2 ;\n c -> edge -> connection = c ;\n c -> edge -> options = c -> options ;\n edge_add ( c -> edge ) ;\n if ( tunnelserver ) {\n send_add_edge ( c , c -> edge ) ;\n }\n else {\n send_add_edge ( everyone , c -> edge ) ;\n }\n graph ( ) ;\n return true ;\n }", "hash": 4372812923566076695, "project": "debian", "size": 66, "target": 0, "idx": 14367}
{"code": "static bool is_valid_host_port ( const char * host , const char * port ) {\n for ( const char * p = host ;\n * p ;\n p ++ ) if ( ! isalnum ( * p ) && * p != '-' && * p != '.' ) {\n return false ;\n }\n for ( const char * p = port ;\n * p ;\n p ++ ) if ( ! isalnum ( * p ) ) {\n return false ;\n }\n return true ;\n }", "hash": 1614547608286395137, "project": "debian", "size": 13, "target": 0, "idx": 14379}
{"code": "enum ImapAuthRes imap_auth_login ( struct ImapData * idata , const char * method ) {\n char q_user [ SHORT_STRING ] , q_pass [ SHORT_STRING ] ;\n char buf [ STRING ] ;\n int rc ;\n if ( mutt_bit_isset ( idata -> capabilities , LOGINDISABLED ) ) {\n mutt_message ( _ ( \"LOGIN disabled on this server.\" ) ) ;\n return IMAP_AUTH_UNAVAIL ;\n }\n if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n mutt_message ( _ ( \"Logging in...\" ) ) ;\n imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user , false ) ;\n imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass , false ) ;\n if ( DebugLevel < IMAP_LOG_PASS ) mutt_debug ( 2 , \"Sending LOGIN command for %s...\\n\" , idata -> conn -> account . user ) ;\n snprintf ( buf , sizeof ( buf ) , \"LOGIN %s %s\" , q_user , q_pass ) ;\n rc = imap_exec ( idata , buf , IMAP_CMD_FAIL_OK | IMAP_CMD_PASS ) ;\n if ( ! rc ) {\n mutt_clear_error ( ) ;\n return IMAP_AUTH_SUCCESS ;\n }\n mutt_error ( _ ( \"Login failed.\" ) ) ;\n return IMAP_AUTH_FAILURE ;\n }", "hash": -5742868996277297983, "project": "debian", "size": 23, "target": 0, "idx": 14382}
{"code": "static void WarnPatented ( gs_font_type42 * pfont , ttfFont * ttf , const char * txt ) {\n if ( ! ttf -> design_grid ) {\n char buf [ gs_font_name_max + 1 ] ;\n int l ;\n gs_font_type42 * base_font = pfont ;\n while ( ( gs_font_type42 * ) base_font -> base != base_font ) base_font = ( gs_font_type42 * ) base_font -> base ;\n if ( ! base_font -> data . warning_patented ) {\n l = min ( sizeof ( buf ) - 1 , base_font -> font_name . size ) ;\n memcpy ( buf , base_font -> font_name . chars , l ) ;\n buf [ l ] = 0 ;\n emprintf2 ( pfont -> memory , \"%s %s requires a patented True Type interpreter.\\n\" , txt , buf ) ;\n base_font -> data . warning_patented = true ;\n }\n }\n }", "hash": -1950979830238945732, "project": "debian", "size": 15, "target": 0, "idx": 14389}
{"code": "void gx_ttfReader__set_font ( gx_ttfReader * self , gs_font_type42 * pfont ) {\n self -> pfont = pfont ;\n self -> super . get_metrics = gx_ttfReader__default_get_metrics ;\n }", "hash": -1950979830238945732, "project": "debian", "size": 4, "target": 0, "idx": 14393}
{"code": "static void * gx_ttfMemory__alloc_struct ( ttfMemory * self , const ttfMemoryDescriptor * d , const char * cname ) {\n gs_memory_t * mem = ( ( gx_ttfMemory * ) self ) -> memory ;\n return mem -> procs . alloc_struct ( mem , ( const gs_memory_struct_type_t * ) d , cname ) ;\n }", "hash": -1950979830238945732, "project": "debian", "size": 4, "target": 0, "idx": 14400}
{"code": "int gx_ttf_outline ( ttfFont * ttf , gx_ttfReader * r , gs_font_type42 * pfont , int glyph_index , const gs_matrix * m , const gs_log2_scale_point * pscale , gx_path * path , bool design_grid ) {\n gx_ttfExport e ;\n ttfOutliner o ;\n gs_point char_size , subpix_origin ;\n gs_matrix post_transform ;\n FloatMatrix m1 ;\n bool dg ;\n uint gftt = gs_currentgridfittt ( pfont -> dir ) ;\n bool ttin = ( gftt & 1 ) ;\n bool auth = ( gftt & 2 ) ;\n decompose_matrix ( pfont , m , pscale , design_grid , & char_size , & subpix_origin , & post_transform , & dg ) ;\n m1 . a = post_transform . xx ;\n m1 . b = post_transform . xy ;\n m1 . c = post_transform . yx ;\n m1 . d = post_transform . yy ;\n m1 . tx = post_transform . tx ;\n m1 . ty = post_transform . ty ;\n e . super . bPoints = false ;\n e . super . bOutline = true ;\n e . super . MoveTo = gx_ttfExport__MoveTo ;\n e . super . LineTo = gx_ttfExport__LineTo ;\n e . super . CurveTo = gx_ttfExport__CurveTo ;\n e . super . Close = gx_ttfExport__Close ;\n e . super . Point = gx_ttfExport__Point ;\n e . super . SetWidth = gx_ttfExport__SetWidth ;\n e . super . DebugPaint = gx_ttfExport__DebugPaint ;\n e . error = 0 ;\n e . path = path ;\n e . w . x = 0 ;\n e . w . y = 0 ;\n e . monotonize = auth ;\n gx_ttfReader__Reset ( r ) ;\n ttfOutliner__init ( & o , ttf , & r -> super , & e . super , true , false , pfont -> WMode != 0 ) ;\n switch ( ttfOutliner__Outline ( & o , glyph_index , subpix_origin . x , subpix_origin . y , & m1 ) ) {\n case fBadInstruction : WarnBadInstruction ( pfont , glyph_index ) ;\n goto recover ;\n case fPatented : if ( ! auth ) WarnPatented ( pfont , ttf , \"Some glyphs of the font\" ) ;\n recover : if ( ! design_grid && auth ) return grid_fit ( pfont -> dir -> san , path , pfont , pscale , & e , & o ) ;\n case fNoError : if ( ! design_grid && ! ttin && auth ) return grid_fit ( pfont -> dir -> san , path , pfont , pscale , & e , & o ) ;\n ttfOutliner__DrawGlyphOutline ( & o ) ;\n if ( e . error ) return e . error ;\n return 0 ;\n case fMemoryError : return_error ( gs_error_VMerror ) ;\n case fUnimplemented : return_error ( gs_error_unregistered ) ;\n default : {\n int code = r -> super . Error ( & r -> super ) ;\n if ( code < 0 ) return code ;\n return_error ( gs_error_invalidfont ) ;\n }\n }\n }", "hash": -1950979830238945732, "project": "debian", "size": 51, "target": 0, "idx": 14402}
{"code": "static int gx_ttfReader__LoadGlyph ( ttfReader * self , int glyph_index , const byte * * p , int * size ) {\n gx_ttfReader * r = ( gx_ttfReader * ) self ;\n gs_font_type42 * pfont = r -> pfont ;\n int code ;\n if ( r -> extra_glyph_index != - 1 ) return 0 ;\n r -> glyph_data . memory = pfont -> memory ;\n code = pfont -> data . get_outline ( pfont , ( uint ) glyph_index , & r -> glyph_data ) ;\n r -> extra_glyph_index = glyph_index ;\n r -> pos = 0 ;\n if ( code < 0 ) r -> error = code ;\n else if ( code > 0 ) {\n r -> error = gs_note_error ( gs_error_unregistered ) ;\n }\n else {\n * p = r -> glyph_data . bits . data ;\n * size = r -> glyph_data . bits . size ;\n }\n return 2 ;\n }", "hash": -1950979830238945732, "project": "debian", "size": 19, "target": 0, "idx": 14403}
{"code": "int ttfFont__Open_aux ( ttfFont * self , ttfInterpreter * tti , gx_ttfReader * r , gs_font_type42 * pfont , const gs_matrix * char_tm , const gs_log2_scale_point * log2_scale , bool design_grid ) {\n gs_point char_size , subpix_origin ;\n gs_matrix post_transform ;\n unsigned int nTTC = 0 ;\n bool dg ;\n decompose_matrix ( pfont , char_tm , log2_scale , design_grid , & char_size , & subpix_origin , & post_transform , & dg ) ;\n switch ( ttfFont__Open ( tti , self , & r -> super , nTTC , char_size . x , char_size . y , dg ) ) {\n case fNoError : return 0 ;\n case fMemoryError : return_error ( gs_error_VMerror ) ;\n case fUnimplemented : return_error ( gs_error_unregistered ) ;\n case fBadInstruction : WarnBadInstruction ( pfont , - 1 ) ;\n goto recover ;\n case fPatented : WarnPatented ( pfont , self , \"The font\" ) ;\n recover : self -> patented = true ;\n return 0 ;\n default : {\n int code = r -> super . Error ( & r -> super ) ;\n if ( code < 0 ) return code ;\n return_error ( gs_error_invalidfont ) ;\n }\n }\n }", "hash": -1950979830238945732, "project": "debian", "size": 22, "target": 0, "idx": 14409}
{"code": "static void gx_ttfExport__DebugPaint ( ttfExport * self ) {\n }", "hash": -1950979830238945732, "project": "debian", "size": 2, "target": 0, "idx": 14415}
{"code": "static guint get_dns_pdu_len ( packet_info * pinfo _U_ , tvbuff_t * tvb , int offset , void * data _U_ ) {\n guint16 plen ;\n plen = tvb_get_ntohs ( tvb , offset ) ;\n return plen + 2 ;\n }", "hash": 5506079590431503777, "project": "debian", "size": 5, "target": 0, "idx": 14431}
{"code": "static int dissect_answer_records ( tvbuff_t * tvb , int cur_off , int dns_data_offset , int count , column_info * cinfo , proto_tree * dns_tree , const char * name , packet_info * pinfo , gboolean is_mdns ) {\n int start_off , add_off ;\n proto_tree * qatree = NULL ;\n proto_item * ti = NULL ;\n start_off = cur_off ;\n if ( dns_tree ) {\n qatree = proto_tree_add_subtree ( dns_tree , tvb , start_off , - 1 , ett_dns_ans , & ti , name ) ;\n }\n while ( count -- > 0 ) {\n add_off = dissect_dns_answer ( tvb , cur_off , dns_data_offset , cinfo , qatree , pinfo , is_mdns ) ;\n cur_off += add_off ;\n }\n if ( ti ) {\n proto_item_set_len ( ti , cur_off - start_off ) ;\n }\n return cur_off - start_off ;\n }", "hash": 5506079590431503777, "project": "debian", "size": 17, "target": 0, "idx": 14439}
{"code": "static void dissect_dns_udp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) {\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"DNS\" ) ;\n dissect_dns_common ( tvb , pinfo , tree , FALSE , FALSE , FALSE ) ;\n }", "hash": 5506079590431503777, "project": "debian", "size": 4, "target": 0, "idx": 14447}
{"code": "static char * get_arg ( char * line , get_arg_mode mode ) {\n char * ptr , * start ;\n bool short_cmd = false ;\n char qtype = 0 ;\n ptr = line ;\n if ( mode == GET_NEXT ) {\n for ( ;\n * ptr ;\n ptr ++ ) ;\n if ( * ( ptr + 1 ) ) ptr ++ ;\n }\n else {\n while ( my_isspace ( charset_info , * ptr ) ) ptr ++ ;\n if ( ( short_cmd = * ptr == '\\\\' ) ) ptr += 2 ;\n else while ( * ptr && ! my_isspace ( charset_info , * ptr ) ) ptr ++ ;\n }\n if ( ! * ptr ) return NullS ;\n while ( my_isspace ( charset_info , * ptr ) ) ptr ++ ;\n if ( * ptr == '\\'' || * ptr == '\\\"' || * ptr == '`' ) {\n qtype = * ptr ;\n ptr ++ ;\n }\n for ( start = ptr ;\n * ptr ;\n ptr ++ ) {\n if ( ( * ptr == '\\\\' && ptr [ 1 ] ) || ( ! short_cmd && qtype && * ptr == qtype && ptr [ 1 ] == qtype ) ) {\n if ( mode != CHECK ) strmov_overlapp ( ptr , ptr + 1 ) ;\n else ptr ++ ;\n }\n else if ( * ptr == ( qtype ? qtype : ' ' ) ) {\n qtype = 0 ;\n if ( mode != CHECK ) * ptr = 0 ;\n break ;\n }\n }\n return ptr != start && ! qtype ? start : NullS ;\n }", "hash": 7191899184788440065, "project": "debian", "size": 37, "target": 0, "idx": 14458}
{"code": "static void init_username ( ) {\n my_free ( full_username ) ;\n my_free ( part_username ) ;\n MYSQL_RES * result ;\n LINT_INIT ( result ) ;\n if ( ! mysql_query ( & mysql , \"select USER()\" ) && ( result = mysql_use_result ( & mysql ) ) ) {\n MYSQL_ROW cur = mysql_fetch_row ( result ) ;\n full_username = my_strdup ( cur [ 0 ] , MYF ( MY_WME ) ) ;\n part_username = my_strdup ( strtok ( cur [ 0 ] , \"@\" ) , MYF ( MY_WME ) ) ;\n ( void ) mysql_fetch_row ( result ) ;\n }\n }", "hash": 7191899184788440065, "project": "debian", "size": 12, "target": 0, "idx": 14482}
{"code": "static int com_delimiter ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {\n char buff [ 256 ] , * tmp ;\n strmake_buf ( buff , line ) ;\n tmp = get_arg ( buff , GET ) ;\n if ( ! tmp || ! * tmp ) {\n put_info ( \"DELIMITER must be followed by a 'delimiter' character or string\" , INFO_ERROR ) ;\n return 0 ;\n }\n else {\n if ( strstr ( tmp , \"\\\\\" ) ) {\n put_info ( \"DELIMITER cannot contain a backslash character\" , INFO_ERROR ) ;\n return 0 ;\n }\n }\n strmake_buf ( delimiter , tmp ) ;\n delimiter_length = ( int ) strlen ( delimiter ) ;\n delimiter_str = delimiter ;\n return 0 ;\n }", "hash": 7191899184788440065, "project": "debian", "size": 19, "target": 0, "idx": 14486}
{"code": "void tee_fputs ( const char * s , FILE * file ) {\n fputs ( s , file ) ;\n if ( opt_outfile ) fputs ( s , OUTFILE ) ;\n }", "hash": 7191899184788440065, "project": "debian", "size": 4, "target": 0, "idx": 14487}
{"code": "static int com_clear ( String * buffer , char * line __attribute__ ( ( unused ) ) ) {\n # ifdef HAVE_READLINE if ( status . add_to_history ) fix_history ( buffer ) ;\n # endif buffer -> length ( 0 ) ;\n return 0 ;\n }", "hash": 7191899184788440065, "project": "debian", "size": 5, "target": 0, "idx": 14494}
{"code": "static bool add_line ( String & buffer , char * line , ulong line_length , char * in_string , bool * ml_comment , bool truncated ) {\n uchar inchar ;\n char buff [ 80 ] , * pos , * out ;\n COMMANDS * com ;\n bool need_space = 0 ;\n bool ss_comment = 0 ;\n DBUG_ENTER ( \"add_line\" ) ;\n if ( ! line [ 0 ] && buffer . is_empty ( ) ) DBUG_RETURN ( 0 ) ;\n # ifdef HAVE_READLINE if ( status . add_to_history && line [ 0 ] && not_in_history ( line ) ) add_history ( line ) ;\n # endif char * end_of_line = line + line_length ;\n for ( pos = out = line ;\n pos < end_of_line ;\n pos ++ ) {\n inchar = ( uchar ) * pos ;\n if ( ! preserve_comments ) {\n if ( my_isspace ( charset_info , inchar ) && ( out == line ) && buffer . is_empty ( ) ) continue ;\n }\n # ifdef USE_MB int length ;\n if ( use_mb ( charset_info ) && ( length = my_ismbchar ( charset_info , pos , end_of_line ) ) ) {\n if ( ! * ml_comment || preserve_comments ) {\n while ( length -- ) * out ++ = * pos ++ ;\n pos -- ;\n }\n else pos += length - 1 ;\n continue ;\n }\n # endif if ( ! * ml_comment && inchar == '\\\\' && ! ( * in_string && ( mysql . server_status & SERVER_STATUS_NO_BACKSLASH_ESCAPES ) ) ) {\n if ( ! ( inchar = ( uchar ) * ++ pos ) ) break ;\n if ( * in_string || inchar == 'N' ) {\n * out ++ = '\\\\' ;\n * out ++ = ( char ) inchar ;\n continue ;\n }\n if ( ( com = find_command ( ( char ) inchar ) ) ) {\n if ( out != line ) {\n buffer . append ( line , ( uint ) ( out - line ) ) ;\n out = line ;\n }\n if ( ( * com -> func ) ( & buffer , pos - 1 ) > 0 ) DBUG_RETURN ( 1 ) ;\n if ( com -> takes_params ) {\n if ( ss_comment ) {\n for ( pos ++ ;\n * pos && ( * pos != '*' || * ( pos + 1 ) != '/' ) ;\n pos ++ ) ;\n pos -- ;\n }\n else {\n for ( pos ++ ;\n * pos && ( * pos != * delimiter || ! is_prefix ( pos + 1 , delimiter + 1 ) ) ;\n pos ++ ) ;\n if ( ! * pos ) pos -- ;\n else pos += delimiter_length - 1 ;\n }\n }\n }\n else {\n sprintf ( buff , \"Unknown command '\\\\%c'.\" , inchar ) ;\n if ( put_info ( buff , INFO_ERROR ) > 0 ) DBUG_RETURN ( 1 ) ;\n * out ++ = '\\\\' ;\n * out ++ = ( char ) inchar ;\n continue ;\n }\n }\n else if ( ! * ml_comment && ! * in_string && is_prefix ( pos , delimiter ) ) {\n pos += delimiter_length ;\n if ( preserve_comments ) {\n while ( my_isspace ( charset_info , * pos ) ) * out ++ = * pos ++ ;\n }\n if ( out != line ) {\n buffer . append ( line , ( uint32 ) ( out - line ) ) ;\n out = line ;\n }\n if ( preserve_comments && ( ( * pos == '#' ) || ( ( * pos == '-' ) && ( pos [ 1 ] == '-' ) && my_isspace ( charset_info , pos [ 2 ] ) ) ) ) {\n buffer . append ( pos ) ;\n pos += strlen ( pos ) ;\n }\n pos -- ;\n if ( ( com = find_command ( buffer . c_ptr ( ) ) ) ) {\n if ( ( * com -> func ) ( & buffer , buffer . c_ptr ( ) ) > 0 ) DBUG_RETURN ( 1 ) ;\n }\n else {\n if ( com_go ( & buffer , 0 ) > 0 ) DBUG_RETURN ( 1 ) ;\n }\n buffer . length ( 0 ) ;\n }\n else if ( ! * ml_comment && ( ! * in_string && ( inchar == '#' || ( inchar == '-' && pos [ 1 ] == '-' && ( ( my_isspace ( charset_info , pos [ 2 ] ) || ! pos [ 2 ] ) || ( buffer . is_empty ( ) && out == line ) ) ) ) ) ) {\n if ( out != line ) {\n buffer . append ( line , ( uint32 ) ( out - line ) ) ;\n out = line ;\n }\n if ( preserve_comments ) {\n bool started_with_nothing = ! buffer . length ( ) ;\n buffer . append ( pos ) ;\n if ( started_with_nothing ) {\n if ( com_go ( & buffer , 0 ) > 0 ) DBUG_RETURN ( 1 ) ;\n buffer . length ( 0 ) ;\n }\n }\n break ;\n }\n else if ( ! * in_string && inchar == '/' && * ( pos + 1 ) == '*' && ! ( * ( pos + 2 ) == '!' || ( * ( pos + 2 ) == 'M' && * ( pos + 3 ) == '!' ) ) ) {\n if ( preserve_comments ) {\n * out ++ = * pos ++ ;\n * out ++ = * pos ;\n }\n else pos ++ ;\n * ml_comment = 1 ;\n if ( out != line ) {\n buffer . append ( line , ( uint ) ( out - line ) ) ;\n out = line ;\n }\n }\n else if ( * ml_comment && ! ss_comment && inchar == '*' && * ( pos + 1 ) == '/' ) {\n if ( preserve_comments ) {\n * out ++ = * pos ++ ;\n * out ++ = * pos ;\n }\n else pos ++ ;\n * ml_comment = 0 ;\n if ( out != line ) {\n buffer . append ( line , ( uint32 ) ( out - line ) ) ;\n out = line ;\n }\n need_space = 1 ;\n }\n else {\n if ( ! * in_string && inchar == '/' && * ( pos + 1 ) == '*' && * ( pos + 2 ) == '!' ) ss_comment = 1 ;\n else if ( ! * in_string && ss_comment && inchar == '*' && * ( pos + 1 ) == '/' ) ss_comment = 0 ;\n if ( inchar == * in_string ) * in_string = 0 ;\n else if ( ! * ml_comment && ! * in_string && ( inchar == '\\'' || inchar == '\"' || inchar == '`' ) ) * in_string = ( char ) inchar ;\n if ( ! * ml_comment || preserve_comments ) {\n if ( need_space && ! my_isspace ( charset_info , ( char ) inchar ) ) * out ++ = ' ' ;\n need_space = 0 ;\n * out ++ = ( char ) inchar ;\n }\n }\n }\n if ( out != line || ! buffer . is_empty ( ) ) {\n uint length = ( uint ) ( out - line ) ;\n if ( ! truncated && ( ! is_delimiter_command ( line , length ) || ( * in_string || * ml_comment ) ) ) {\n * out ++ = '\\n' ;\n length ++ ;\n }\n if ( buffer . length ( ) + length >= buffer . alloced_length ( ) ) buffer . realloc ( buffer . length ( ) + length + IO_SIZE ) ;\n if ( ( ! * ml_comment || preserve_comments ) && buffer . append ( line , length ) ) DBUG_RETURN ( 1 ) ;\n }\n DBUG_RETURN ( 0 ) ;\n }", "hash": 7191899184788440065, "project": "debian", "size": 148, "target": 0, "idx": 14512}
{"code": "static int com_quit ( String * buffer __attribute__ ( ( unused ) ) , char * line __attribute__ ( ( unused ) ) ) {\n status . exit_status = 0 ;\n return 1 ;\n }", "hash": 7191899184788440065, "project": "debian", "size": 4, "target": 0, "idx": 14519}
{"code": "static int com_pager ( String * buffer __attribute__ ( ( unused ) ) , char * line __attribute__ ( ( unused ) ) ) {\n char pager_name [ FN_REFLEN ] , * end , * param ;\n if ( status . batch ) return 0 ;\n while ( my_isspace ( charset_info , * line ) ) line ++ ;\n param = strchr ( line , ' ' ) ;\n while ( param && my_isspace ( charset_info , * param ) ) param ++ ;\n if ( ! param || ! strlen ( param ) ) {\n if ( ! default_pager_set ) {\n tee_fprintf ( stdout , \"Default pager wasn't set, using stdout.\\n\" ) ;\n opt_nopager = 1 ;\n strmov ( pager , \"stdout\" ) ;\n PAGER = stdout ;\n return 0 ;\n }\n strmov ( pager , default_pager ) ;\n }\n else {\n end = strmake_buf ( pager_name , param ) ;\n while ( end > pager_name && ( my_isspace ( charset_info , end [ - 1 ] ) || my_iscntrl ( charset_info , end [ - 1 ] ) ) ) end -- ;\n end [ 0 ] = 0 ;\n strmov ( pager , pager_name ) ;\n strmov ( default_pager , pager_name ) ;\n }\n opt_nopager = 0 ;\n tee_fprintf ( stdout , \"PAGER set to '%s'\\n\" , pager ) ;\n return 0 ;\n }", "hash": 7191899184788440065, "project": "debian", "size": 27, "target": 0, "idx": 14529}
{"code": "static int get_result_width ( MYSQL_RES * result ) {\n unsigned int len = 0 ;\n MYSQL_FIELD * field ;\n MYSQL_FIELD_OFFSET offset ;\n # ifndef DBUG_OFF offset = mysql_field_tell ( result ) ;\n DBUG_ASSERT ( offset == 0 ) ;\n # else offset = 0 ;\n # endif while ( ( field = mysql_fetch_field ( result ) ) != NULL ) len += get_field_disp_length ( field ) + 3 ;\n ( void ) mysql_field_seek ( result , offset ) ;\n return len + 1 ;\n }", "hash": 7191899184788440065, "project": "debian", "size": 11, "target": 0, "idx": 14538}
{"code": "void msyslog ( int level , const char * fmt , ... ) {\n char buf [ 1024 ] ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n mvsnprintf ( buf , sizeof ( buf ) , fmt , ap ) ;\n va_end ( ap ) ;\n addto_syslog ( level , buf ) ;\n }", "hash": -2443338381883395438, "project": "debian", "size": 8, "target": 0, "idx": 14566}
{"code": "static int lzh_read_input ( struct kwajd_stream * lzh ) {\n int read ;\n if ( lzh -> input_end ) {\n lzh -> input_end += 8 ;\n lzh -> inbuf [ 0 ] = 0 ;\n read = 1 ;\n }\n else {\n read = lzh -> sys -> read ( lzh -> input , & lzh -> inbuf [ 0 ] , KWAJ_INPUT_SIZE ) ;\n if ( read < 0 ) return MSPACK_ERR_READ ;\n if ( read == 0 ) {\n lzh -> input_end = 8 ;\n lzh -> inbuf [ 0 ] = 0 ;\n read = 1 ;\n }\n }\n lzh -> i_ptr = & lzh -> inbuf [ 0 ] ;\n lzh -> i_end = & lzh -> inbuf [ read ] ;\n return MSPACK_ERR_OK ;\n }", "hash": -8589152252830017940, "project": "debian", "size": 20, "target": 0, "idx": 14577}
{"code": "static int lzh_read_lens ( struct kwajd_stream * lzh , unsigned int type , unsigned int numsyms , unsigned char * lens ) {\n register unsigned int bit_buffer ;\n register int bits_left ;\n unsigned char * i_ptr , * i_end ;\n unsigned int i , c , sel ;\n int err ;\n RESTORE_BITS ;\n switch ( type ) {\n case 0 : i = numsyms ;\n c = ( i == 16 ) ? 4 : ( i == 32 ) ? 5 : ( i == 64 ) ? 6 : ( i == 256 ) ? 8 : 0 ;\n for ( i = 0 ;\n i < numsyms ;\n i ++ ) lens [ i ] = c ;\n break ;\n case 1 : READ_BITS_SAFE ( c , 4 ) ;\n lens [ 0 ] = c ;\n for ( i = 1 ;\n i < numsyms ;\n i ++ ) {\n READ_BITS_SAFE ( sel , 1 ) ;\n if ( sel == 0 ) lens [ i ] = c ;\n else {\n READ_BITS_SAFE ( sel , 1 ) ;\n if ( sel == 0 ) lens [ i ] = ++ c ;\n else {\n READ_BITS_SAFE ( c , 4 ) ;\n lens [ i ] = c ;\n }\n }\n }\n break ;\n case 2 : READ_BITS_SAFE ( c , 4 ) ;\n lens [ 0 ] = c ;\n for ( i = 1 ;\n i < numsyms ;\n i ++ ) {\n READ_BITS_SAFE ( sel , 2 ) ;\n if ( sel == 3 ) READ_BITS_SAFE ( c , 4 ) ;\n else c += ( char ) sel - 1 ;\n lens [ i ] = c ;\n }\n break ;\n case 3 : for ( i = 0 ;\n i < numsyms ;\n i ++ ) {\n READ_BITS_SAFE ( c , 4 ) ;\n lens [ i ] = c ;\n }\n break ;\n }\n STORE_BITS ;\n return MSPACK_ERR_OK ;\n }", "hash": -8589152252830017940, "project": "debian", "size": 53, "target": 0, "idx": 14584}
{"code": "static int compress_bidder_bid ( struct archive_read_filter_bidder * self , struct archive_read_filter * filter ) {\n const unsigned char * buffer ;\n ssize_t avail ;\n int bits_checked ;\n ( void ) self ;\n buffer = __archive_read_filter_ahead ( filter , 3 , & avail ) ;\n if ( buffer == NULL ) return ( 0 ) ;\n bits_checked = 0 ;\n if ( buffer [ 0 ] != 0x1F || buffer [ 1 ] != 0x9D ) return ( 0 ) ;\n if ( buffer [ 2 ] & 0x20 ) return ( 0 ) ;\n if ( buffer [ 2 ] & 0x40 ) return ( 0 ) ;\n bits_checked += 18 ;\n return ( bits_checked ) ;\n }", "hash": 5498422609764865307, "project": "debian", "size": 14, "target": 0, "idx": 14585}
{"code": "static int compress_filter_close ( struct archive_read_filter * self ) {\n struct private_data * state = ( struct private_data * ) self -> data ;\n free ( state -> out_block ) ;\n free ( state ) ;\n return ( ARCHIVE_OK ) ;\n }", "hash": 5498422609764865307, "project": "debian", "size": 6, "target": 0, "idx": 14593}
{"code": "int dtls1_send_newsession_ticket ( SSL * s ) {\n if ( s -> state == SSL3_ST_SW_SESSION_TICKET_A ) {\n unsigned char * p , * senc , * macstart ;\n int len , slen ;\n unsigned int hlen , msg_len ;\n EVP_CIPHER_CTX ctx ;\n HMAC_CTX hctx ;\n SSL_CTX * tctx = s -> initial_ctx ;\n unsigned char iv [ EVP_MAX_IV_LENGTH ] ;\n unsigned char key_name [ 16 ] ;\n slen = i2d_SSL_SESSION ( s -> session , NULL ) ;\n if ( slen > 0xFF00 ) return - 1 ;\n if ( ! BUF_MEM_grow ( s -> init_buf , DTLS1_HM_HEADER_LENGTH + 22 + EVP_MAX_IV_LENGTH + EVP_MAX_BLOCK_LENGTH + EVP_MAX_MD_SIZE + slen ) ) return - 1 ;\n senc = OPENSSL_malloc ( slen ) ;\n if ( ! senc ) return - 1 ;\n p = senc ;\n i2d_SSL_SESSION ( s -> session , & p ) ;\n p = ( unsigned char * ) & ( s -> init_buf -> data [ DTLS1_HM_HEADER_LENGTH ] ) ;\n EVP_CIPHER_CTX_init ( & ctx ) ;\n HMAC_CTX_init ( & hctx ) ;\n if ( tctx -> tlsext_ticket_key_cb ) {\n if ( tctx -> tlsext_ticket_key_cb ( s , key_name , iv , & ctx , & hctx , 1 ) < 0 ) {\n OPENSSL_free ( senc ) ;\n return - 1 ;\n }\n }\n else {\n RAND_pseudo_bytes ( iv , 16 ) ;\n EVP_EncryptInit_ex ( & ctx , EVP_aes_128_cbc ( ) , NULL , tctx -> tlsext_tick_aes_key , iv ) ;\n HMAC_Init_ex ( & hctx , tctx -> tlsext_tick_hmac_key , 16 , tlsext_tick_md ( ) , NULL ) ;\n memcpy ( key_name , tctx -> tlsext_tick_key_name , 16 ) ;\n }\n l2n ( s -> session -> tlsext_tick_lifetime_hint , p ) ;\n p += 2 ;\n macstart = p ;\n memcpy ( p , key_name , 16 ) ;\n p += 16 ;\n memcpy ( p , iv , EVP_CIPHER_CTX_iv_length ( & ctx ) ) ;\n p += EVP_CIPHER_CTX_iv_length ( & ctx ) ;\n EVP_EncryptUpdate ( & ctx , p , & len , senc , slen ) ;\n p += len ;\n EVP_EncryptFinal ( & ctx , p , & len ) ;\n p += len ;\n EVP_CIPHER_CTX_cleanup ( & ctx ) ;\n HMAC_Update ( & hctx , macstart , p - macstart ) ;\n HMAC_Final ( & hctx , p , & hlen ) ;\n HMAC_CTX_cleanup ( & hctx ) ;\n p += hlen ;\n len = p - ( unsigned char * ) ( s -> init_buf -> data ) ;\n p = ( unsigned char * ) & ( s -> init_buf -> data [ DTLS1_HM_HEADER_LENGTH ] ) + 4 ;\n s2n ( len - DTLS1_HM_HEADER_LENGTH - 6 , p ) ;\n s -> init_num = len ;\n s -> state = SSL3_ST_SW_SESSION_TICKET_B ;\n s -> init_off = 0 ;\n OPENSSL_free ( senc ) ;\n msg_len = s -> init_num - DTLS1_HM_HEADER_LENGTH ;\n dtls1_set_message_header ( s , ( void * ) s -> init_buf -> data , SSL3_MT_NEWSESSION_TICKET , msg_len , 0 , msg_len ) ;\n dtls1_buffer_message ( s , 0 ) ;\n }\n return ( dtls1_do_write ( s , SSL3_RT_HANDSHAKE ) ) ;\n }", "hash": 2521579609370336371, "project": "debian", "size": 61, "target": 0, "idx": 14597}
{"code": "IMPLEMENT_dtls1_meth_func ( DTLSv1_server_method , dtls1_accept , ssl_undefined_function , dtls1_get_server_method ) int dtls1_accept ( SSL * s ) {\n BUF_MEM * buf ;\n unsigned long Time = ( unsigned long ) time ( NULL ) ;\n void ( * cb ) ( const SSL * ssl , int type , int val ) = NULL ;\n unsigned long alg_k ;\n int ret = - 1 ;\n int new_state , state , skip = 0 ;\n int listen ;\n # ifndef OPENSSL_NO_SCTP unsigned char sctpauthkey [ 64 ] ;\n char labelbuffer [ sizeof ( DTLS1_SCTP_AUTH_LABEL ) ] ;\n # endif RAND_add ( & Time , sizeof ( Time ) , 0 ) ;\n ERR_clear_error ( ) ;\n clear_sys_error ( ) ;\n if ( s -> info_callback != NULL ) cb = s -> info_callback ;\n else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ;\n listen = s -> d1 -> listen ;\n s -> in_handshake ++ ;\n if ( ! SSL_in_init ( s ) || SSL_in_before ( s ) ) SSL_clear ( s ) ;\n s -> d1 -> listen = listen ;\n # ifndef OPENSSL_NO_SCTP BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE , s -> in_handshake , NULL ) ;\n # endif if ( s -> cert == NULL ) {\n SSLerr ( SSL_F_DTLS1_ACCEPT , SSL_R_NO_CERTIFICATE_SET ) ;\n return ( - 1 ) ;\n }\n # ifndef OPENSSL_NO_HEARTBEATS if ( s -> tlsext_hb_pending ) {\n dtls1_stop_timer ( s ) ;\n s -> tlsext_hb_pending = 0 ;\n s -> tlsext_hb_seq ++ ;\n }\n # endif for ( ;\n ;\n ) {\n state = s -> state ;\n switch ( s -> state ) {\n case SSL_ST_RENEGOTIATE : s -> renegotiate = 1 ;\n case SSL_ST_BEFORE : case SSL_ST_ACCEPT : case SSL_ST_BEFORE | SSL_ST_ACCEPT : case SSL_ST_OK | SSL_ST_ACCEPT : s -> server = 1 ;\n if ( cb != NULL ) cb ( s , SSL_CB_HANDSHAKE_START , 1 ) ;\n if ( ( s -> version & 0xff00 ) != ( DTLS1_VERSION & 0xff00 ) ) {\n SSLerr ( SSL_F_DTLS1_ACCEPT , ERR_R_INTERNAL_ERROR ) ;\n return - 1 ;\n }\n s -> type = SSL_ST_ACCEPT ;\n if ( s -> init_buf == NULL ) {\n if ( ( buf = BUF_MEM_new ( ) ) == NULL ) {\n ret = - 1 ;\n goto end ;\n }\n if ( ! BUF_MEM_grow ( buf , SSL3_RT_MAX_PLAIN_LENGTH ) ) {\n BUF_MEM_free ( buf ) ;\n ret = - 1 ;\n goto end ;\n }\n s -> init_buf = buf ;\n }\n if ( ! ssl3_setup_buffers ( s ) ) {\n ret = - 1 ;\n goto end ;\n }\n s -> init_num = 0 ;\n s -> d1 -> change_cipher_spec_ok = 0 ;\n s -> s3 -> change_cipher_spec = 0 ;\n if ( s -> state != SSL_ST_RENEGOTIATE ) {\n # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_wbio ( s ) ) ) # endif if ( ! ssl_init_wbio_buffer ( s , 1 ) ) {\n ret = - 1 ;\n goto end ;\n }\n ssl3_init_finished_mac ( s ) ;\n s -> state = SSL3_ST_SR_CLNT_HELLO_A ;\n s -> ctx -> stats . sess_accept ++ ;\n }\n else {\n s -> ctx -> stats . sess_accept_renegotiate ++ ;\n s -> state = SSL3_ST_SW_HELLO_REQ_A ;\n }\n break ;\n case SSL3_ST_SW_HELLO_REQ_A : case SSL3_ST_SW_HELLO_REQ_B : s -> shutdown = 0 ;\n dtls1_clear_record_buffer ( s ) ;\n dtls1_start_timer ( s ) ;\n ret = dtls1_send_hello_request ( s ) ;\n if ( ret <= 0 ) goto end ;\n s -> s3 -> tmp . next_state = SSL3_ST_SR_CLNT_HELLO_A ;\n s -> state = SSL3_ST_SW_FLUSH ;\n s -> init_num = 0 ;\n ssl3_init_finished_mac ( s ) ;\n break ;\n case SSL3_ST_SW_HELLO_REQ_C : s -> state = SSL_ST_OK ;\n break ;\n case SSL3_ST_SR_CLNT_HELLO_A : case SSL3_ST_SR_CLNT_HELLO_B : case SSL3_ST_SR_CLNT_HELLO_C : s -> shutdown = 0 ;\n ret = ssl3_get_client_hello ( s ) ;\n if ( ret <= 0 ) goto end ;\n dtls1_stop_timer ( s ) ;\n if ( ret == 1 && ( SSL_get_options ( s ) & SSL_OP_COOKIE_EXCHANGE ) ) s -> state = DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A ;\n else s -> state = SSL3_ST_SW_SRVR_HELLO_A ;\n s -> init_num = 0 ;\n if ( listen ) {\n memcpy ( s -> s3 -> write_sequence , s -> s3 -> read_sequence , sizeof ( s -> s3 -> write_sequence ) ) ;\n }\n if ( listen && s -> state == SSL3_ST_SW_SRVR_HELLO_A ) {\n ret = 2 ;\n s -> d1 -> listen = 0 ;\n s -> d1 -> handshake_read_seq = 2 ;\n s -> d1 -> handshake_write_seq = 1 ;\n s -> d1 -> next_handshake_write_seq = 1 ;\n goto end ;\n }\n break ;\n case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A : case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B : ret = dtls1_send_hello_verify_request ( s ) ;\n if ( ret <= 0 ) goto end ;\n s -> state = SSL3_ST_SW_FLUSH ;\n s -> s3 -> tmp . next_state = SSL3_ST_SR_CLNT_HELLO_A ;\n if ( s -> version != DTLS1_BAD_VER ) ssl3_init_finished_mac ( s ) ;\n break ;\n # ifndef OPENSSL_NO_SCTP case DTLS1_SCTP_ST_SR_READ_SOCK : if ( BIO_dgram_sctp_msg_waiting ( SSL_get_rbio ( s ) ) ) {\n s -> s3 -> in_read_app_data = 2 ;\n s -> rwstate = SSL_READING ;\n BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ;\n BIO_set_retry_read ( SSL_get_rbio ( s ) ) ;\n ret = - 1 ;\n goto end ;\n }\n s -> state = SSL3_ST_SR_FINISHED_A ;\n break ;\n case DTLS1_SCTP_ST_SW_WRITE_SOCK : ret = BIO_dgram_sctp_wait_for_dry ( SSL_get_wbio ( s ) ) ;\n if ( ret < 0 ) goto end ;\n if ( ret == 0 ) {\n if ( s -> d1 -> next_state != SSL_ST_OK ) {\n s -> s3 -> in_read_app_data = 2 ;\n s -> rwstate = SSL_READING ;\n BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ;\n BIO_set_retry_read ( SSL_get_rbio ( s ) ) ;\n ret = - 1 ;\n goto end ;\n }\n }\n s -> state = s -> d1 -> next_state ;\n break ;\n # endif case SSL3_ST_SW_SRVR_HELLO_A : case SSL3_ST_SW_SRVR_HELLO_B : s -> renegotiate = 2 ;\n dtls1_start_timer ( s ) ;\n ret = dtls1_send_server_hello ( s ) ;\n if ( ret <= 0 ) goto end ;\n if ( s -> hit ) {\n # ifndef OPENSSL_NO_SCTP snprintf ( ( char * ) labelbuffer , sizeof ( DTLS1_SCTP_AUTH_LABEL ) , DTLS1_SCTP_AUTH_LABEL ) ;\n SSL_export_keying_material ( s , sctpauthkey , sizeof ( sctpauthkey ) , labelbuffer , sizeof ( labelbuffer ) , NULL , 0 , 0 ) ;\n BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY , sizeof ( sctpauthkey ) , sctpauthkey ) ;\n # endif # ifndef OPENSSL_NO_TLSEXT if ( s -> tlsext_ticket_expected ) s -> state = SSL3_ST_SW_SESSION_TICKET_A ;\n else s -> state = SSL3_ST_SW_CHANGE_A ;\n # else s -> state = SSL3_ST_SW_CHANGE_A ;\n # endif }\n else s -> state = SSL3_ST_SW_CERT_A ;\n s -> init_num = 0 ;\n break ;\n case SSL3_ST_SW_CERT_A : case SSL3_ST_SW_CERT_B : if ( ! ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aNULL ) && ! ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) ) {\n dtls1_start_timer ( s ) ;\n ret = dtls1_send_server_certificate ( s ) ;\n if ( ret <= 0 ) goto end ;\n # ifndef OPENSSL_NO_TLSEXT if ( s -> tlsext_status_expected ) s -> state = SSL3_ST_SW_CERT_STATUS_A ;\n else s -> state = SSL3_ST_SW_KEY_EXCH_A ;\n }\n else {\n skip = 1 ;\n s -> state = SSL3_ST_SW_KEY_EXCH_A ;\n }\n # else }\n else skip = 1 ;\n s -> state = SSL3_ST_SW_KEY_EXCH_A ;\n # endif s -> init_num = 0 ;\n break ;\n case SSL3_ST_SW_KEY_EXCH_A : case SSL3_ST_SW_KEY_EXCH_B : alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey ;\n s -> s3 -> tmp . use_rsa_tmp = 0 ;\n if ( 0 # ifndef OPENSSL_NO_PSK || ( ( alg_k & SSL_kPSK ) && s -> ctx -> psk_identity_hint ) # endif || ( alg_k & ( SSL_kEDH | SSL_kDHr | SSL_kDHd ) ) || ( alg_k & SSL_kEECDH ) || ( ( alg_k & SSL_kRSA ) && ( s -> cert -> pkeys [ SSL_PKEY_RSA_ENC ] . privatekey == NULL || ( SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) && EVP_PKEY_size ( s -> cert -> pkeys [ SSL_PKEY_RSA_ENC ] . privatekey ) * 8 > SSL_C_EXPORT_PKEYLENGTH ( s -> s3 -> tmp . new_cipher ) ) ) ) ) {\n dtls1_start_timer ( s ) ;\n ret = dtls1_send_server_key_exchange ( s ) ;\n if ( ret <= 0 ) goto end ;\n }\n else skip = 1 ;\n s -> state = SSL3_ST_SW_CERT_REQ_A ;\n s -> init_num = 0 ;\n break ;\n case SSL3_ST_SW_CERT_REQ_A : case SSL3_ST_SW_CERT_REQ_B : if ( ! ( s -> verify_mode & SSL_VERIFY_PEER ) || ( ( s -> session -> peer != NULL ) && ( s -> verify_mode & SSL_VERIFY_CLIENT_ONCE ) ) || ( ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aNULL ) && ! ( s -> verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) || ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aKRB5 ) || ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) ) {\n skip = 1 ;\n s -> s3 -> tmp . cert_request = 0 ;\n s -> state = SSL3_ST_SW_SRVR_DONE_A ;\n # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_wbio ( s ) ) ) {\n s -> d1 -> next_state = SSL3_ST_SW_SRVR_DONE_A ;\n s -> state = DTLS1_SCTP_ST_SW_WRITE_SOCK ;\n }\n # endif }\n else {\n s -> s3 -> tmp . cert_request = 1 ;\n dtls1_start_timer ( s ) ;\n ret = dtls1_send_certificate_request ( s ) ;\n if ( ret <= 0 ) goto end ;\n # ifndef NETSCAPE_HANG_BUG s -> state = SSL3_ST_SW_SRVR_DONE_A ;\n # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_wbio ( s ) ) ) {\n s -> d1 -> next_state = SSL3_ST_SW_SRVR_DONE_A ;\n s -> state = DTLS1_SCTP_ST_SW_WRITE_SOCK ;\n }\n # endif # else s -> state = SSL3_ST_SW_FLUSH ;\n s -> s3 -> tmp . next_state = SSL3_ST_SR_CERT_A ;\n # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_wbio ( s ) ) ) {\n s -> d1 -> next_state = s -> s3 -> tmp . next_state ;\n s -> s3 -> tmp . next_state = DTLS1_SCTP_ST_SW_WRITE_SOCK ;\n }\n # endif # endif s -> init_num = 0 ;\n }\n break ;\n case SSL3_ST_SW_SRVR_DONE_A : case SSL3_ST_SW_SRVR_DONE_B : dtls1_start_timer ( s ) ;\n ret = dtls1_send_server_done ( s ) ;\n if ( ret <= 0 ) goto end ;\n s -> s3 -> tmp . next_state = SSL3_ST_SR_CERT_A ;\n s -> state = SSL3_ST_SW_FLUSH ;\n s -> init_num = 0 ;\n break ;\n case SSL3_ST_SW_FLUSH : s -> rwstate = SSL_WRITING ;\n if ( BIO_flush ( s -> wbio ) <= 0 ) {\n if ( ! BIO_should_retry ( s -> wbio ) ) {\n s -> rwstate = SSL_NOTHING ;\n s -> state = s -> s3 -> tmp . next_state ;\n }\n ret = - 1 ;\n goto end ;\n }\n s -> rwstate = SSL_NOTHING ;\n s -> state = s -> s3 -> tmp . next_state ;\n break ;\n case SSL3_ST_SR_CERT_A : case SSL3_ST_SR_CERT_B : ret = ssl3_check_client_hello ( s ) ;\n if ( ret <= 0 ) goto end ;\n if ( ret == 2 ) {\n dtls1_stop_timer ( s ) ;\n s -> state = SSL3_ST_SR_CLNT_HELLO_C ;\n }\n else {\n if ( s -> s3 -> tmp . cert_request ) {\n ret = ssl3_get_client_certificate ( s ) ;\n if ( ret <= 0 ) goto end ;\n }\n s -> init_num = 0 ;\n s -> state = SSL3_ST_SR_KEY_EXCH_A ;\n }\n break ;\n case SSL3_ST_SR_KEY_EXCH_A : case SSL3_ST_SR_KEY_EXCH_B : ret = ssl3_get_client_key_exchange ( s ) ;\n if ( ret <= 0 ) goto end ;\n # ifndef OPENSSL_NO_SCTP snprintf ( ( char * ) labelbuffer , sizeof ( DTLS1_SCTP_AUTH_LABEL ) , DTLS1_SCTP_AUTH_LABEL ) ;\n SSL_export_keying_material ( s , sctpauthkey , sizeof ( sctpauthkey ) , labelbuffer , sizeof ( labelbuffer ) , NULL , 0 , 0 ) ;\n BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY , sizeof ( sctpauthkey ) , sctpauthkey ) ;\n # endif s -> state = SSL3_ST_SR_CERT_VRFY_A ;\n s -> init_num = 0 ;\n if ( ret == 2 ) {\n s -> state = SSL3_ST_SR_FINISHED_A ;\n s -> init_num = 0 ;\n }\n else {\n s -> state = SSL3_ST_SR_CERT_VRFY_A ;\n s -> init_num = 0 ;\n s -> method -> ssl3_enc -> cert_verify_mac ( s , NID_md5 , & ( s -> s3 -> tmp . cert_verify_md [ 0 ] ) ) ;\n s -> method -> ssl3_enc -> cert_verify_mac ( s , NID_sha1 , & ( s -> s3 -> tmp . cert_verify_md [ MD5_DIGEST_LENGTH ] ) ) ;\n }\n break ;\n case SSL3_ST_SR_CERT_VRFY_A : case SSL3_ST_SR_CERT_VRFY_B : if ( ! s -> s3 -> change_cipher_spec ) s -> d1 -> change_cipher_spec_ok = 1 ;\n ret = ssl3_get_cert_verify ( s ) ;\n if ( ret <= 0 ) goto end ;\n # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_wbio ( s ) ) && state == SSL_ST_RENEGOTIATE ) s -> state = DTLS1_SCTP_ST_SR_READ_SOCK ;\n else # endif s -> state = SSL3_ST_SR_FINISHED_A ;\n s -> init_num = 0 ;\n break ;\n case SSL3_ST_SR_FINISHED_A : case SSL3_ST_SR_FINISHED_B : if ( ! s -> s3 -> change_cipher_spec ) s -> d1 -> change_cipher_spec_ok = 1 ;\n ret = ssl3_get_finished ( s , SSL3_ST_SR_FINISHED_A , SSL3_ST_SR_FINISHED_B ) ;\n if ( ret <= 0 ) goto end ;\n dtls1_stop_timer ( s ) ;\n if ( s -> hit ) s -> state = SSL_ST_OK ;\n # ifndef OPENSSL_NO_TLSEXT else if ( s -> tlsext_ticket_expected ) s -> state = SSL3_ST_SW_SESSION_TICKET_A ;\n # endif else s -> state = SSL3_ST_SW_CHANGE_A ;\n s -> init_num = 0 ;\n break ;\n # ifndef OPENSSL_NO_TLSEXT case SSL3_ST_SW_SESSION_TICKET_A : case SSL3_ST_SW_SESSION_TICKET_B : ret = dtls1_send_newsession_ticket ( s ) ;\n if ( ret <= 0 ) goto end ;\n s -> state = SSL3_ST_SW_CHANGE_A ;\n s -> init_num = 0 ;\n break ;\n case SSL3_ST_SW_CERT_STATUS_A : case SSL3_ST_SW_CERT_STATUS_B : ret = ssl3_send_cert_status ( s ) ;\n if ( ret <= 0 ) goto end ;\n s -> state = SSL3_ST_SW_KEY_EXCH_A ;\n s -> init_num = 0 ;\n break ;\n # endif case SSL3_ST_SW_CHANGE_A : case SSL3_ST_SW_CHANGE_B : s -> session -> cipher = s -> s3 -> tmp . new_cipher ;\n if ( ! s -> method -> ssl3_enc -> setup_key_block ( s ) ) {\n ret = - 1 ;\n goto end ;\n }\n ret = dtls1_send_change_cipher_spec ( s , SSL3_ST_SW_CHANGE_A , SSL3_ST_SW_CHANGE_B ) ;\n if ( ret <= 0 ) goto end ;\n # ifndef OPENSSL_NO_SCTP if ( ! s -> hit ) {\n BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY , 0 , NULL ) ;\n }\n # endif s -> state = SSL3_ST_SW_FINISHED_A ;\n s -> init_num = 0 ;\n if ( ! s -> method -> ssl3_enc -> change_cipher_state ( s , SSL3_CHANGE_CIPHER_SERVER_WRITE ) ) {\n ret = - 1 ;\n goto end ;\n }\n dtls1_reset_seq_numbers ( s , SSL3_CC_WRITE ) ;\n break ;\n case SSL3_ST_SW_FINISHED_A : case SSL3_ST_SW_FINISHED_B : ret = dtls1_send_finished ( s , SSL3_ST_SW_FINISHED_A , SSL3_ST_SW_FINISHED_B , s -> method -> ssl3_enc -> server_finished_label , s -> method -> ssl3_enc -> server_finished_label_len ) ;\n if ( ret <= 0 ) goto end ;\n s -> state = SSL3_ST_SW_FLUSH ;\n if ( s -> hit ) {\n s -> s3 -> tmp . next_state = SSL3_ST_SR_FINISHED_A ;\n # ifndef OPENSSL_NO_SCTP BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY , 0 , NULL ) ;\n # endif }\n else {\n s -> s3 -> tmp . next_state = SSL_ST_OK ;\n # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_wbio ( s ) ) ) {\n s -> d1 -> next_state = s -> s3 -> tmp . next_state ;\n s -> s3 -> tmp . next_state = DTLS1_SCTP_ST_SW_WRITE_SOCK ;\n }\n # endif }\n s -> init_num = 0 ;\n break ;\n case SSL_ST_OK : ssl3_cleanup_key_block ( s ) ;\n # if 0 BUF_MEM_free ( s -> init_buf ) ;\n s -> init_buf = NULL ;\n # endif ssl_free_wbio_buffer ( s ) ;\n s -> init_num = 0 ;\n if ( s -> renegotiate == 2 ) {\n s -> renegotiate = 0 ;\n s -> new_session = 0 ;\n ssl_update_cache ( s , SSL_SESS_CACHE_SERVER ) ;\n s -> ctx -> stats . sess_accept_good ++ ;\n s -> handshake_func = dtls1_accept ;\n if ( cb != NULL ) cb ( s , SSL_CB_HANDSHAKE_DONE , 1 ) ;\n }\n ret = 1 ;\n s -> d1 -> handshake_read_seq = 0 ;\n s -> d1 -> handshake_write_seq = 0 ;\n s -> d1 -> next_handshake_write_seq = 0 ;\n goto end ;\n default : SSLerr ( SSL_F_DTLS1_ACCEPT , SSL_R_UNKNOWN_STATE ) ;\n ret = - 1 ;\n goto end ;\n }\n if ( ! s -> s3 -> tmp . reuse_message && ! skip ) {\n if ( s -> debug ) {\n if ( ( ret = BIO_flush ( s -> wbio ) ) <= 0 ) goto end ;\n }\n if ( ( cb != NULL ) && ( s -> state != state ) ) {\n new_state = s -> state ;\n s -> state = state ;\n cb ( s , SSL_CB_ACCEPT_LOOP , 1 ) ;\n s -> state = new_state ;\n }\n }\n skip = 0 ;\n }\n end : s -> in_handshake -- ;\n # ifndef OPENSSL_NO_SCTP BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE , s -> in_handshake , NULL ) ;\n # endif if ( cb != NULL ) cb ( s , SSL_CB_ACCEPT_EXIT , ret ) ;\n return ( ret ) ;\n }", "hash": 2521579609370336371, "project": "debian", "size": 358, "target": 0, "idx": 14601}
{"code": "static int match_section ( const char * section_name , int show_all_entries , AVDictionary * entries ) {\n int i , ret = 0 ;\n for ( i = 0 ;\n i < FF_ARRAY_ELEMS ( sections ) ;\n i ++ ) {\n const struct section * section = & sections [ i ] ;\n if ( ! strcmp ( section_name , section -> name ) || ( section -> unique_name && ! strcmp ( section_name , section -> unique_name ) ) ) {\n av_log ( NULL , AV_LOG_DEBUG , \"'%s' matches section with unique name '%s'\\n\" , section_name , ( char * ) av_x_if_null ( section -> unique_name , section -> name ) ) ;\n ret ++ ;\n mark_section_show_entries ( section -> id , show_all_entries , entries ) ;\n }\n }\n return ret ;\n }", "hash": 6632536031698733342, "project": "debian", "size": 14, "target": 0, "idx": 14616}
{"code": "static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) {\n CompactContext * compact = wctx -> priv ;\n if ( wctx -> nb_item [ wctx -> level ] ) printf ( \"%c\" , compact -> item_sep ) ;\n if ( ! compact -> nokey ) printf ( \"%s%s=\" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ;\n printf ( \"%lld\" , value ) ;\n }", "hash": 6632536031698733342, "project": "debian", "size": 6, "target": 0, "idx": 14621}
{"code": "static void show_error ( WriterContext * w , int err ) {\n char errbuf [ 128 ] ;\n const char * errbuf_ptr = errbuf ;\n if ( av_strerror ( err , errbuf , sizeof ( errbuf ) ) < 0 ) errbuf_ptr = strerror ( AVUNERROR ( err ) ) ;\n writer_print_section_header ( w , SECTION_ID_ERROR ) ;\n print_int ( \"code\" , err ) ;\n print_str ( \"string\" , errbuf_ptr ) ;\n writer_print_section_footer ( w ) ;\n }", "hash": 6632536031698733342, "project": "debian", "size": 9, "target": 0, "idx": 14624}
{"code": "static int opt_format ( void * optctx , const char * opt , const char * arg ) {\n iformat = av_find_input_format ( arg ) ;\n if ( ! iformat ) {\n av_log ( NULL , AV_LOG_ERROR , \"Unknown input format: %s\\n\" , arg ) ;\n return AVERROR ( EINVAL ) ;\n }\n return 0 ;\n }", "hash": 6632536031698733342, "project": "debian", "size": 8, "target": 0, "idx": 14626}
{"code": "static int writer_register ( const Writer * writer ) {\n static int next_registered_writer_idx = 0 ;\n if ( next_registered_writer_idx == MAX_REGISTERED_WRITERS_NB ) return AVERROR ( ENOMEM ) ;\n registered_writers [ next_registered_writer_idx ++ ] = writer ;\n return 0 ;\n }", "hash": 6632536031698733342, "project": "debian", "size": 6, "target": 0, "idx": 14627}
{"code": "static int parse_read_interval ( const char * interval_spec , ReadInterval * interval ) {\n int ret = 0 ;\n char * next , * p , * spec = av_strdup ( interval_spec ) ;\n if ( ! spec ) return AVERROR ( ENOMEM ) ;\n if ( ! * spec ) {\n av_log ( NULL , AV_LOG_ERROR , \"Invalid empty interval specification\\n\" ) ;\n ret = AVERROR ( EINVAL ) ;\n goto end ;\n }\n p = spec ;\n next = strchr ( spec , '%' ) ;\n if ( next ) * next ++ = 0 ;\n if ( * p ) {\n interval -> has_start = 1 ;\n if ( * p == '+' ) {\n interval -> start_is_offset = 1 ;\n p ++ ;\n }\n else {\n interval -> start_is_offset = 0 ;\n }\n ret = av_parse_time ( & interval -> start , p , 1 ) ;\n if ( ret < 0 ) {\n av_log ( NULL , AV_LOG_ERROR , \"Invalid interval start specification '%s'\\n\" , p ) ;\n goto end ;\n }\n }\n else {\n interval -> has_start = 0 ;\n }\n p = next ;\n if ( p && * p ) {\n int64_t us ;\n interval -> has_end = 1 ;\n if ( * p == '+' ) {\n interval -> end_is_offset = 1 ;\n p ++ ;\n }\n else {\n interval -> end_is_offset = 0 ;\n }\n if ( interval -> end_is_offset && * p == '#' ) {\n long long int lli ;\n char * tail ;\n interval -> duration_frames = 1 ;\n p ++ ;\n lli = strtoll ( p , & tail , 10 ) ;\n if ( * tail || lli < 0 ) {\n av_log ( NULL , AV_LOG_ERROR , \"Invalid or negative value '%s' for duration number of frames\\n\" , p ) ;\n goto end ;\n }\n interval -> end = lli ;\n }\n else {\n interval -> duration_frames = 0 ;\n ret = av_parse_time ( & us , p , 1 ) ;\n if ( ret < 0 ) {\n av_log ( NULL , AV_LOG_ERROR , \"Invalid interval end/duration specification '%s'\\n\" , p ) ;\n goto end ;\n }\n interval -> end = us ;\n }\n }\n else {\n interval -> has_end = 0 ;\n }\n end : av_free ( spec ) ;\n return ret ;\n }", "hash": 6632536031698733342, "project": "debian", "size": 69, "target": 0, "idx": 14637}
{"code": "static int opt_show_ ## section ( const char * opt , const char * arg ) {\n mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ;\n return 0 ;\n }\n DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS ) DEFINE_OPT_SHOW_SECTION ( pixel_formats , PIXEL_FORMATS ) DEFINE_OPT_SHOW_SECTION ( program_version , PROGRAM_VERSION ) DEFINE_OPT_SHOW_SECTION ( streams , STREAMS ) DEFINE_OPT_SHOW_SECTION ( programs , PROGRAMS )", "hash": 6632536031698733342, "project": "debian", "size": 5, "target": 0, "idx": 14638}
{"code": "static inline int writer_print_string ( WriterContext * wctx , const char * key , const char * val , int flags ) {\n const struct section * section = wctx -> section [ wctx -> level ] ;\n int ret = 0 ;\n if ( ( flags & PRINT_STRING_OPT ) && ! ( wctx -> writer -> flags & WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS ) ) return 0 ;\n if ( section -> show_all_entries || av_dict_get ( section -> entries_to_show , key , NULL , 0 ) ) {\n if ( flags & PRINT_STRING_VALIDATE ) {\n char * key1 = NULL , * val1 = NULL ;\n ret = validate_string ( wctx , & key1 , key ) ;\n if ( ret < 0 ) goto end ;\n ret = validate_string ( wctx , & val1 , val ) ;\n if ( ret < 0 ) goto end ;\n wctx -> writer -> print_string ( wctx , key1 , val1 ) ;\n end : if ( ret < 0 ) {\n av_log ( wctx , AV_LOG_ERROR , \"Invalid key=value string combination %s=%s in section %s\\n\" , key , val , section -> unique_name ) ;\n }\n av_free ( key1 ) ;\n av_free ( val1 ) ;\n }\n else {\n wctx -> writer -> print_string ( wctx , key , val ) ;\n }\n wctx -> nb_item [ wctx -> level ] ++ ;\n }\n return ret ;\n }", "hash": 6632536031698733342, "project": "debian", "size": 25, "target": 0, "idx": 14639}
{"code": "static int opt_show_ ## section ( const char * opt , const char * arg ) {\n mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ;\n return 0 ;\n }\n DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT )", "hash": 6632536031698733342, "project": "debian", "size": 5, "target": 0, "idx": 14643}
{"code": "static void compact_print_section_header ( WriterContext * wctx ) {\n CompactContext * compact = wctx -> priv ;\n const struct section * section = wctx -> section [ wctx -> level ] ;\n const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ;\n compact -> terminate_line [ wctx -> level ] = 1 ;\n compact -> has_nested_elems [ wctx -> level ] = 0 ;\n av_bprint_clear ( & wctx -> section_pbuf [ wctx -> level ] ) ;\n if ( ! ( section -> flags & SECTION_FLAG_IS_ARRAY ) && parent_section && ! ( parent_section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) {\n compact -> nested_section [ wctx -> level ] = 1 ;\n compact -> has_nested_elems [ wctx -> level - 1 ] = 1 ;\n av_bprintf ( & wctx -> section_pbuf [ wctx -> level ] , \"%s%s:\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str , ( char * ) av_x_if_null ( section -> element_name , section -> name ) ) ;\n wctx -> nb_item [ wctx -> level ] = wctx -> nb_item [ wctx -> level - 1 ] ;\n }\n else {\n if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) {\n compact -> terminate_line [ wctx -> level - 1 ] = 0 ;\n printf ( \"\\n\" ) ;\n }\n if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) printf ( \"%s%c\" , section -> name , compact -> item_sep ) ;\n }\n }", "hash": 6632536031698733342, "project": "debian", "size": 21, "target": 0, "idx": 14657}
{"code": "static inline char * upcase_string ( char * dst , size_t dst_size , const char * src ) {\n int i ;\n for ( i = 0 ;\n src [ i ] && i < dst_size - 1 ;\n i ++ ) dst [ i ] = av_toupper ( src [ i ] ) ;\n dst [ i ] = 0 ;\n return dst ;\n }", "hash": 6632536031698733342, "project": "debian", "size": 8, "target": 0, "idx": 14666}
{"code": "static void ini_print_section_header ( WriterContext * wctx ) {\n INIContext * ini = wctx -> priv ;\n AVBPrint * buf = & wctx -> section_pbuf [ wctx -> level ] ;\n const struct section * section = wctx -> section [ wctx -> level ] ;\n const struct section * parent_section = wctx -> level ? wctx -> section [ wctx -> level - 1 ] : NULL ;\n av_bprint_clear ( buf ) ;\n if ( ! parent_section ) {\n printf ( \"# ffprobe output\\n\\n\" ) ;\n return ;\n }\n if ( wctx -> nb_item [ wctx -> level - 1 ] ) printf ( \"\\n\" ) ;\n av_bprintf ( buf , \"%s\" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ;\n if ( ini -> hierarchical || ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) {\n av_bprintf ( buf , \"%s%s\" , buf -> str [ 0 ] ? \".\" : \"\" , wctx -> section [ wctx -> level ] -> name ) ;\n if ( parent_section -> flags & SECTION_FLAG_IS_ARRAY ) {\n int n = parent_section -> id == SECTION_ID_PACKETS_AND_FRAMES ? wctx -> nb_section_packet_frame : wctx -> nb_item [ wctx -> level - 1 ] ;\n av_bprintf ( buf , \".%d\" , n ) ;\n }\n }\n if ( ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) printf ( \"[%s]\\n\" , buf -> str ) ;\n }", "hash": 6632536031698733342, "project": "debian", "size": 21, "target": 0, "idx": 14684}
{"code": "static int parse_read_intervals ( const char * intervals_spec ) {\n int ret , n , i ;\n char * p , * spec = av_strdup ( intervals_spec ) ;\n if ( ! spec ) return AVERROR ( ENOMEM ) ;\n for ( n = 0 , p = spec ;\n * p ;\n p ++ ) if ( * p == ',' ) n ++ ;\n n ++ ;\n read_intervals = av_malloc_array ( n , sizeof ( * read_intervals ) ) ;\n if ( ! read_intervals ) {\n ret = AVERROR ( ENOMEM ) ;\n goto end ;\n }\n read_intervals_nb = n ;\n p = spec ;\n for ( i = 0 ;\n p ;\n i ++ ) {\n char * next ;\n av_assert0 ( i < read_intervals_nb ) ;\n next = strchr ( p , ',' ) ;\n if ( next ) * next ++ = 0 ;\n read_intervals [ i ] . id = i ;\n ret = parse_read_interval ( p , & read_intervals [ i ] ) ;\n if ( ret < 0 ) {\n av_log ( NULL , AV_LOG_ERROR , \"Error parsing read interval #%d '%s'\\n\" , i , p ) ;\n goto end ;\n }\n av_log ( NULL , AV_LOG_VERBOSE , \"Parsed log interval \" ) ;\n log_read_interval ( & read_intervals [ i ] , NULL , AV_LOG_VERBOSE ) ;\n p = next ;\n }\n av_assert0 ( i == read_intervals_nb ) ;\n end : av_free ( spec ) ;\n return ret ;\n }", "hash": 6632536031698733342, "project": "debian", "size": 36, "target": 0, "idx": 14687}
{"code": "static void ffprobe_show_pixel_formats ( WriterContext * w ) {\n const AVPixFmtDescriptor * pixdesc = NULL ;\n int i , n ;\n writer_print_section_header ( w , SECTION_ID_PIXEL_FORMATS ) ;\n while ( pixdesc = av_pix_fmt_desc_next ( pixdesc ) ) {\n writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT ) ;\n print_str ( \"name\" , pixdesc -> name ) ;\n print_int ( \"nb_components\" , pixdesc -> nb_components ) ;\n if ( ( pixdesc -> nb_components >= 3 ) && ! ( pixdesc -> flags & AV_PIX_FMT_FLAG_RGB ) ) {\n print_int ( \"log2_chroma_w\" , pixdesc -> log2_chroma_w ) ;\n print_int ( \"log2_chroma_h\" , pixdesc -> log2_chroma_h ) ;\n }\n else {\n print_str_opt ( \"log2_chroma_w\" , \"N/A\" ) ;\n print_str_opt ( \"log2_chroma_h\" , \"N/A\" ) ;\n }\n n = av_get_bits_per_pixel ( pixdesc ) ;\n if ( n ) print_int ( \"bits_per_pixel\" , n ) ;\n else print_str_opt ( \"bits_per_pixel\" , \"N/A\" ) ;\n if ( do_show_pixel_format_flags ) {\n writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_FLAGS ) ;\n PRINT_PIX_FMT_FLAG ( BE , \"big_endian\" ) ;\n PRINT_PIX_FMT_FLAG ( PAL , \"palette\" ) ;\n PRINT_PIX_FMT_FLAG ( BITSTREAM , \"bitstream\" ) ;\n PRINT_PIX_FMT_FLAG ( HWACCEL , \"hwaccel\" ) ;\n PRINT_PIX_FMT_FLAG ( PLANAR , \"planar\" ) ;\n PRINT_PIX_FMT_FLAG ( RGB , \"rgb\" ) ;\n PRINT_PIX_FMT_FLAG ( PSEUDOPAL , \"pseudopal\" ) ;\n PRINT_PIX_FMT_FLAG ( ALPHA , \"alpha\" ) ;\n writer_print_section_footer ( w ) ;\n }\n if ( do_show_pixel_format_components && ( pixdesc -> nb_components > 0 ) ) {\n writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_COMPONENTS ) ;\n for ( i = 0 ;\n i < pixdesc -> nb_components ;\n i ++ ) {\n writer_print_section_header ( w , SECTION_ID_PIXEL_FORMAT_COMPONENT ) ;\n print_int ( \"index\" , i + 1 ) ;\n print_int ( \"bit_depth\" , pixdesc -> comp [ i ] . depth ) ;\n writer_print_section_footer ( w ) ;\n }\n writer_print_section_footer ( w ) ;\n }\n writer_print_section_footer ( w ) ;\n }\n writer_print_section_footer ( w ) ;\n }", "hash": 6632536031698733342, "project": "debian", "size": 47, "target": 0, "idx": 14689}
{"code": "static inline void writer_print_rational ( WriterContext * wctx , const char * key , AVRational q , char sep ) {\n AVBPrint buf ;\n av_bprint_init ( & buf , 0 , AV_BPRINT_SIZE_AUTOMATIC ) ;\n av_bprintf ( & buf , \"%d%c%d\" , q . num , sep , q . den ) ;\n writer_print_string ( wctx , key , buf . str , 0 ) ;\n }", "hash": 6632536031698733342, "project": "debian", "size": 6, "target": 0, "idx": 14690}
{"code": "int psf_file_valid ( SF_PRIVATE * psf ) {\n return ( psf -> file . filedes >= 0 ) ? SF_TRUE : SF_FALSE ;\n }", "hash": 4313735399044135249, "project": "debian", "size": 3, "target": 0, "idx": 14731}
{"code": "int psf_fopen ( SF_PRIVATE * psf ) {\n psf -> error = 0 ;\n psf -> file . filedes = psf_open_fd ( & psf -> file ) ;\n if ( psf -> file . filedes == - SFE_BAD_OPEN_MODE ) {\n psf -> error = SFE_BAD_OPEN_MODE ;\n psf -> file . filedes = - 1 ;\n return psf -> error ;\n }\n ;\n if ( psf -> file . filedes == - 1 ) psf_log_syserr ( psf , errno ) ;\n return psf -> error ;\n }", "hash": 4313735399044135249, "project": "debian", "size": 12, "target": 0, "idx": 14732}
{"code": "static sf_count_t psf_get_filelen_fd ( int fd ) {\n # if ( SIZEOF_OFF_T == 4 && SIZEOF_SF_COUNT_T == 8 && HAVE_FSTAT64 ) struct stat64 statbuf ;\n if ( fstat64 ( fd , & statbuf ) == - 1 ) return ( sf_count_t ) - 1 ;\n return statbuf . st_size ;\n # else struct stat statbuf ;\n if ( fstat ( fd , & statbuf ) == - 1 ) return ( sf_count_t ) - 1 ;\n return statbuf . st_size ;\n # endif }", "hash": 4313735399044135249, "project": "debian", "size": 8, "target": 0, "idx": 14735}
{"code": "static int kex_agree_hostkey ( LIBSSH2_SESSION * session , unsigned long kex_flags , unsigned char * hostkey , unsigned long hostkey_len ) {\n const LIBSSH2_HOSTKEY_METHOD * * hostkeyp = libssh2_hostkey_methods ( ) ;\n unsigned char * s ;\n if ( session -> hostkey_prefs ) {\n s = ( unsigned char * ) session -> hostkey_prefs ;\n while ( s && * s ) {\n unsigned char * p = ( unsigned char * ) strchr ( ( char * ) s , ',' ) ;\n size_t method_len = ( p ? ( size_t ) ( p - s ) : strlen ( ( char * ) s ) ) ;\n if ( kex_agree_instr ( hostkey , hostkey_len , s , method_len ) ) {\n const LIBSSH2_HOSTKEY_METHOD * method = ( const LIBSSH2_HOSTKEY_METHOD * ) kex_get_method_by_name ( ( char * ) s , method_len , ( const LIBSSH2_COMMON_METHOD * * ) hostkeyp ) ;\n if ( ! method ) {\n return - 1 ;\n }\n if ( ( ( kex_flags & LIBSSH2_KEX_METHOD_FLAG_REQ_ENC_HOSTKEY ) == 0 ) || ( method -> encrypt ) ) {\n if ( ( ( kex_flags & LIBSSH2_KEX_METHOD_FLAG_REQ_SIGN_HOSTKEY ) == 0 ) || ( method -> sig_verify ) ) {\n session -> hostkey = method ;\n return 0 ;\n }\n }\n }\n s = p ? p + 1 : NULL ;\n }\n return - 1 ;\n }\n while ( hostkeyp && ( * hostkeyp ) && ( * hostkeyp ) -> name ) {\n s = kex_agree_instr ( hostkey , hostkey_len , ( unsigned char * ) ( * hostkeyp ) -> name , strlen ( ( * hostkeyp ) -> name ) ) ;\n if ( s ) {\n if ( ( ( kex_flags & LIBSSH2_KEX_METHOD_FLAG_REQ_ENC_HOSTKEY ) == 0 ) || ( ( * hostkeyp ) -> encrypt ) ) {\n if ( ( ( kex_flags & LIBSSH2_KEX_METHOD_FLAG_REQ_SIGN_HOSTKEY ) == 0 ) || ( ( * hostkeyp ) -> sig_verify ) ) {\n session -> hostkey = * hostkeyp ;\n return 0 ;\n }\n }\n }\n hostkeyp ++ ;\n }\n return - 1 ;\n }", "hash": 1202634027547122397, "project": "debian", "size": 38, "target": 0, "idx": 14743}
{"code": "static int kex_agree_crypt ( LIBSSH2_SESSION * session , libssh2_endpoint_data * endpoint , unsigned char * crypt , unsigned long crypt_len ) {\n const LIBSSH2_CRYPT_METHOD * * cryptp = libssh2_crypt_methods ( ) ;\n unsigned char * s ;\n ( void ) session ;\n if ( endpoint -> crypt_prefs ) {\n s = ( unsigned char * ) endpoint -> crypt_prefs ;\n while ( s && * s ) {\n unsigned char * p = ( unsigned char * ) strchr ( ( char * ) s , ',' ) ;\n size_t method_len = ( p ? ( size_t ) ( p - s ) : strlen ( ( char * ) s ) ) ;\n if ( kex_agree_instr ( crypt , crypt_len , s , method_len ) ) {\n const LIBSSH2_CRYPT_METHOD * method = ( const LIBSSH2_CRYPT_METHOD * ) kex_get_method_by_name ( ( char * ) s , method_len , ( const LIBSSH2_COMMON_METHOD * * ) cryptp ) ;\n if ( ! method ) {\n return - 1 ;\n }\n endpoint -> crypt = method ;\n return 0 ;\n }\n s = p ? p + 1 : NULL ;\n }\n return - 1 ;\n }\n while ( * cryptp && ( * cryptp ) -> name ) {\n s = kex_agree_instr ( crypt , crypt_len , ( unsigned char * ) ( * cryptp ) -> name , strlen ( ( * cryptp ) -> name ) ) ;\n if ( s ) {\n endpoint -> crypt = * cryptp ;\n return 0 ;\n }\n cryptp ++ ;\n }\n return - 1 ;\n }", "hash": 1202634027547122397, "project": "debian", "size": 31, "target": 0, "idx": 14753}
{"code": "static int kex_agree_mac ( LIBSSH2_SESSION * session , libssh2_endpoint_data * endpoint , unsigned char * mac , unsigned long mac_len ) {\n const LIBSSH2_MAC_METHOD * * macp = _libssh2_mac_methods ( ) ;\n unsigned char * s ;\n ( void ) session ;\n if ( endpoint -> mac_prefs ) {\n s = ( unsigned char * ) endpoint -> mac_prefs ;\n while ( s && * s ) {\n unsigned char * p = ( unsigned char * ) strchr ( ( char * ) s , ',' ) ;\n size_t method_len = ( p ? ( size_t ) ( p - s ) : strlen ( ( char * ) s ) ) ;\n if ( kex_agree_instr ( mac , mac_len , s , method_len ) ) {\n const LIBSSH2_MAC_METHOD * method = ( const LIBSSH2_MAC_METHOD * ) kex_get_method_by_name ( ( char * ) s , method_len , ( const LIBSSH2_COMMON_METHOD * * ) macp ) ;\n if ( ! method ) {\n return - 1 ;\n }\n endpoint -> mac = method ;\n return 0 ;\n }\n s = p ? p + 1 : NULL ;\n }\n return - 1 ;\n }\n while ( * macp && ( * macp ) -> name ) {\n s = kex_agree_instr ( mac , mac_len , ( unsigned char * ) ( * macp ) -> name , strlen ( ( * macp ) -> name ) ) ;\n if ( s ) {\n endpoint -> mac = * macp ;\n return 0 ;\n }\n macp ++ ;\n }\n return - 1 ;\n }", "hash": 1202634027547122397, "project": "debian", "size": 31, "target": 0, "idx": 14754}
{"code": "static GstFlowReturn gst_asf_demux_process_file ( GstASFDemux * demux , guint8 * data , guint64 size ) {\n guint64 creation_time G_GNUC_UNUSED ;\n guint64 file_size G_GNUC_UNUSED ;\n guint64 send_time G_GNUC_UNUSED ;\n guint64 packets_count , play_time , preroll ;\n guint32 flags , min_pktsize , max_pktsize , min_bitrate G_GNUC_UNUSED ;\n if ( size < ( 16 + 8 + 8 + 8 + 8 + 8 + 8 + 4 + 4 + 4 + 4 ) ) goto not_enough_data ;\n gst_asf_demux_skip_bytes ( 16 , & data , & size ) ;\n file_size = gst_asf_demux_get_uint64 ( & data , & size ) ;\n creation_time = gst_asf_demux_get_uint64 ( & data , & size ) ;\n packets_count = gst_asf_demux_get_uint64 ( & data , & size ) ;\n play_time = gst_asf_demux_get_uint64 ( & data , & size ) ;\n send_time = gst_asf_demux_get_uint64 ( & data , & size ) ;\n preroll = gst_asf_demux_get_uint64 ( & data , & size ) ;\n flags = gst_asf_demux_get_uint32 ( & data , & size ) ;\n min_pktsize = gst_asf_demux_get_uint32 ( & data , & size ) ;\n max_pktsize = gst_asf_demux_get_uint32 ( & data , & size ) ;\n min_bitrate = gst_asf_demux_get_uint32 ( & data , & size ) ;\n demux -> broadcast = ! ! ( flags & 0x01 ) ;\n demux -> seekable = ! ! ( flags & 0x02 ) ;\n GST_DEBUG_OBJECT ( demux , \"min_pktsize = %u\" , min_pktsize ) ;\n GST_DEBUG_OBJECT ( demux , \"flags::broadcast = %d\" , demux -> broadcast ) ;\n GST_DEBUG_OBJECT ( demux , \"flags::seekable = %d\" , demux -> seekable ) ;\n if ( demux -> broadcast ) {\n play_time = 0 ;\n file_size = 0 ;\n }\n if ( min_pktsize != max_pktsize ) goto non_fixed_packet_size ;\n demux -> packet_size = max_pktsize ;\n if ( ( play_time * 100 ) >= ( preroll * GST_MSECOND ) ) demux -> play_time = ( play_time * 100 ) - ( preroll * GST_MSECOND ) ;\n else demux -> play_time = 0 ;\n demux -> preroll = preroll * GST_MSECOND ;\n demux -> latency = demux -> preroll ;\n if ( demux -> play_time == 0 ) demux -> seekable = FALSE ;\n GST_DEBUG_OBJECT ( demux , \"play_time %\" GST_TIME_FORMAT , GST_TIME_ARGS ( demux -> play_time ) ) ;\n GST_DEBUG_OBJECT ( demux , \"preroll %\" GST_TIME_FORMAT , GST_TIME_ARGS ( demux -> preroll ) ) ;\n if ( demux -> play_time > 0 ) {\n demux -> segment . duration = demux -> play_time ;\n }\n GST_INFO ( \"object is a file with %\" G_GUINT64_FORMAT \" data packets\" , packets_count ) ;\n GST_INFO ( \"preroll = %\" G_GUINT64_FORMAT , demux -> preroll ) ;\n demux -> saw_file_header = TRUE ;\n return GST_FLOW_OK ;\n non_fixed_packet_size : {\n GST_ELEMENT_ERROR ( demux , STREAM , DEMUX , ( NULL ) , ( \"packet size must be fixed\" ) ) ;\n return GST_FLOW_ERROR ;\n }\n not_enough_data : {\n GST_ELEMENT_ERROR ( demux , STREAM , DEMUX , ( NULL ) , ( \"short read parsing FILE object\" ) ) ;\n return GST_FLOW_ERROR ;\n }\n }", "hash": -5280794106681745199, "project": "debian", "size": 52, "target": 0, "idx": 14783}
{"code": "static void gst_asf_demux_init ( GstASFDemux * demux ) {\n demux -> sinkpad = gst_pad_new_from_static_template ( & gst_asf_demux_sink_template , \"sink\" ) ;\n gst_pad_set_chain_function ( demux -> sinkpad , GST_DEBUG_FUNCPTR ( gst_asf_demux_chain ) ) ;\n gst_pad_set_event_function ( demux -> sinkpad , GST_DEBUG_FUNCPTR ( gst_asf_demux_sink_event ) ) ;\n gst_pad_set_activate_function ( demux -> sinkpad , GST_DEBUG_FUNCPTR ( gst_asf_demux_activate ) ) ;\n gst_pad_set_activatemode_function ( demux -> sinkpad , GST_DEBUG_FUNCPTR ( gst_asf_demux_activate_mode ) ) ;\n gst_element_add_pad ( GST_ELEMENT ( demux ) , demux -> sinkpad ) ;\n gst_asf_demux_reset ( demux , FALSE ) ;\n }", "hash": -5280794106681745199, "project": "debian", "size": 9, "target": 0, "idx": 14784}
{"code": "static gboolean gst_asf_demux_send_event_unlocked ( GstASFDemux * demux , GstEvent * event ) {\n gboolean ret = TRUE ;\n gint i ;\n GST_DEBUG_OBJECT ( demux , \"sending %s event to all source pads\" , GST_EVENT_TYPE_NAME ( event ) ) ;\n for ( i = 0 ;\n i < demux -> num_streams ;\n ++ i ) {\n gst_event_ref ( event ) ;\n ret &= gst_pad_push_event ( demux -> stream [ i ] . pad , event ) ;\n }\n gst_event_unref ( event ) ;\n return ret ;\n }", "hash": -5280794106681745199, "project": "debian", "size": 13, "target": 0, "idx": 14792}
{"code": "static gboolean gst_asf_demux_activate ( GstPad * sinkpad , GstObject * parent ) {\n GstQuery * query ;\n gboolean pull_mode ;\n query = gst_query_new_scheduling ( ) ;\n if ( ! gst_pad_peer_query ( sinkpad , query ) ) {\n gst_query_unref ( query ) ;\n goto activate_push ;\n }\n pull_mode = gst_query_has_scheduling_mode_with_flags ( query , GST_PAD_MODE_PULL , GST_SCHEDULING_FLAG_SEEKABLE ) ;\n gst_query_unref ( query ) ;\n if ( ! pull_mode ) goto activate_push ;\n GST_DEBUG_OBJECT ( sinkpad , \"activating pull\" ) ;\n return gst_pad_activate_mode ( sinkpad , GST_PAD_MODE_PULL , TRUE ) ;\n activate_push : {\n GST_DEBUG_OBJECT ( sinkpad , \"activating push\" ) ;\n return gst_pad_activate_mode ( sinkpad , GST_PAD_MODE_PUSH , TRUE ) ;\n }\n }", "hash": -5280794106681745199, "project": "debian", "size": 18, "target": 0, "idx": 14797}
{"code": "static void gst_asf_demux_class_init ( GstASFDemuxClass * klass ) {\n GstElementClass * gstelement_class ;\n gstelement_class = ( GstElementClass * ) klass ;\n gst_element_class_set_static_metadata ( gstelement_class , \"ASF Demuxer\" , \"Codec/Demuxer\" , \"Demultiplexes ASF Streams\" , \"Owen Fraser-Green <owen@discobabe.net>\" ) ;\n gst_element_class_add_static_pad_template ( gstelement_class , & audio_src_template ) ;\n gst_element_class_add_static_pad_template ( gstelement_class , & video_src_template ) ;\n gst_element_class_add_static_pad_template ( gstelement_class , & gst_asf_demux_sink_template ) ;\n gstelement_class -> change_state = GST_DEBUG_FUNCPTR ( gst_asf_demux_change_state ) ;\n gstelement_class -> send_event = GST_DEBUG_FUNCPTR ( gst_asf_demux_element_send_event ) ;\n }", "hash": -5280794106681745199, "project": "debian", "size": 10, "target": 0, "idx": 14806}
{"code": "static gboolean gst_asf_demux_update_caps_from_payload ( GstASFDemux * demux , AsfStream * stream ) {\n GstTypeFindProbability prob = GST_TYPE_FIND_NONE ;\n GstCaps * caps = NULL ;\n int i ;\n GstAdapter * adapter = gst_adapter_new ( ) ;\n for ( i = 0 ;\n i < stream -> payloads -> len && prob < GST_TYPE_FIND_LIKELY ;\n ++ i ) {\n const guint8 * data ;\n AsfPayload * payload ;\n int len ;\n payload = & g_array_index ( stream -> payloads , AsfPayload , i ) ;\n gst_adapter_push ( adapter , gst_buffer_ref ( payload -> buf ) ) ;\n len = gst_adapter_available ( adapter ) ;\n data = gst_adapter_map ( adapter , len ) ;\n again : # define MIN_LENGTH 128 while ( TRUE ) {\n if ( len < MIN_LENGTH || ( data [ 0 ] == 0x0b && data [ 1 ] == 0x77 ) || ( data [ 0 ] == 0xFF && ( ( data [ 1 ] & 0xF0 ) >> 4 ) == 0xF ) ) break ;\n ++ data ;\n -- len ;\n }\n gst_caps_take ( & caps , gst_type_find_helper_for_data ( GST_OBJECT ( demux ) , data , len , & prob ) ) ;\n if ( prob < GST_TYPE_FIND_LIKELY ) {\n ++ data ;\n -- len ;\n if ( len > MIN_LENGTH ) goto again ;\n }\n gst_adapter_unmap ( adapter ) ;\n }\n gst_object_unref ( adapter ) ;\n if ( caps ) {\n gst_caps_take ( & stream -> caps , caps ) ;\n return TRUE ;\n }\n else {\n return FALSE ;\n }\n }", "hash": -5280794106681745199, "project": "debian", "size": 37, "target": 0, "idx": 14842}
{"code": "static void gst_asf_demux_pop_obj ( GstASFDemux * demux ) {\n gchar * s ;\n if ( ( s = g_strrstr ( demux -> objpath , \"/\" ) ) ) {\n * s = '\\0' ;\n }\n else {\n g_free ( demux -> objpath ) ;\n demux -> objpath = NULL ;\n }\n }", "hash": -5280794106681745199, "project": "debian", "size": 10, "target": 0, "idx": 14847}
{"code": "static gboolean gst_asf_demux_check_activate_streams ( GstASFDemux * demux , gboolean force ) {\n guint i , actual_streams = 0 ;\n if ( demux -> activated_streams ) return TRUE ;\n if ( G_UNLIKELY ( ! gst_asf_demux_check_first_ts ( demux , force ) ) ) return FALSE ;\n if ( ! all_streams_prerolled ( demux ) && ! force ) {\n GST_DEBUG_OBJECT ( demux , \"not all streams with data beyond preroll yet\" ) ;\n return FALSE ;\n }\n for ( i = 0 ;\n i < demux -> num_streams ;\n ++ i ) {\n AsfStream * stream = & demux -> stream [ i ] ;\n if ( stream -> payloads -> len > 0 ) {\n if ( stream -> inspect_payload && ! stream -> active && ! gst_asf_demux_update_caps_from_payload ( demux , stream ) && stream -> payloads -> len < 20 ) {\n return FALSE ;\n }\n GST_LOG_OBJECT ( stream -> pad , \"is prerolled - activate!\" ) ;\n gst_asf_demux_activate_stream ( demux , stream ) ;\n actual_streams += 1 ;\n }\n else {\n GST_LOG_OBJECT ( stream -> pad , \"no data, ignoring stream\" ) ;\n }\n }\n if ( actual_streams == 0 ) {\n GST_ERROR_OBJECT ( demux , \"No streams activated!\" ) ;\n return FALSE ;\n }\n gst_asf_demux_release_old_pads ( demux ) ;\n demux -> activated_streams = TRUE ;\n GST_LOG_OBJECT ( demux , \"signalling no more pads\" ) ;\n gst_element_no_more_pads ( GST_ELEMENT ( demux ) ) ;\n return TRUE ;\n }", "hash": -5280794106681745199, "project": "debian", "size": 34, "target": 0, "idx": 14848}
{"code": "static void test_tran_bdb ( ) {\n MYSQL_RES * result ;\n MYSQL_ROW row ;\n int rc ;\n myheader ( \"test_tran_bdb\" ) ;\n rc = mysql_autocommit ( mysql , FALSE ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS my_demo_transaction\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE my_demo_transaction( \" \"col1 int , col2 varchar(30)) ENGINE= BDB\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO my_demo_transaction VALUES(10, 'venu')\" ) ;\n myquery ( rc ) ;\n rc = mysql_commit ( mysql ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO my_demo_transaction VALUES(20, 'mysql')\" ) ;\n myquery ( rc ) ;\n rc = mysql_rollback ( mysql ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DELETE FROM my_demo_transaction WHERE col1= 10\" ) ;\n myquery ( rc ) ;\n rc = mysql_rollback ( mysql ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"SELECT * FROM my_demo_transaction\" ) ;\n myquery ( rc ) ;\n result = mysql_store_result ( mysql ) ;\n mytest ( result ) ;\n ( void ) my_process_result_set ( result ) ;\n mysql_free_result ( result ) ;\n rc = mysql_query ( mysql , \"SELECT * FROM my_demo_transaction\" ) ;\n myquery ( rc ) ;\n result = mysql_use_result ( mysql ) ;\n mytest ( result ) ;\n row = mysql_fetch_row ( result ) ;\n mytest ( row ) ;\n row = mysql_fetch_row ( result ) ;\n mytest_r ( row ) ;\n mysql_free_result ( result ) ;\n mysql_autocommit ( mysql , TRUE ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 40, "target": 0, "idx": 14854}
{"code": "static void test_bug27876 ( ) {\n int rc ;\n MYSQL_RES * result ;\n uchar utf8_func [ ] = {\n 0xd1 , 0x84 , 0xd1 , 0x83 , 0xd0 , 0xbd , 0xd0 , 0xba , 0xd1 , 0x86 , 0xd0 , 0xb8 , 0xd0 , 0xb9 , 0xd0 , 0xba , 0xd0 , 0xb0 , 0x00 }\n ;\n uchar utf8_param [ ] = {\n 0xd0 , 0xbf , 0xd0 , 0xb0 , 0xd1 , 0x80 , 0xd0 , 0xb0 , 0xd0 , 0xbc , 0xd0 , 0xb5 , 0xd1 , 0x82 , 0xd1 , 0x8a , 0xd1 , 0x80 , 0x5f , 0xd0 , 0xb2 , 0xd0 , 0xb5 , 0xd1 , 0x80 , 0xd1 , 0x81 , 0xd0 , 0xb8 , 0xd1 , 0x8f , 0x00 }\n ;\n char query [ 500 ] ;\n DBUG_ENTER ( \"test_bug27876\" ) ;\n myheader ( \"test_bug27876\" ) ;\n rc = mysql_query ( mysql , \"set names utf8\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"select version()\" ) ;\n myquery ( rc ) ;\n result = mysql_store_result ( mysql ) ;\n mytest ( result ) ;\n mysql_free_result ( result ) ;\n sprintf ( query , \"DROP FUNCTION IF EXISTS %s\" , ( char * ) utf8_func ) ;\n rc = mysql_query ( mysql , query ) ;\n myquery ( rc ) ;\n sprintf ( query , \"CREATE FUNCTION %s( %s VARCHAR(25))\" \" RETURNS VARCHAR(25) DETERMINISTIC RETURN %s\" , ( char * ) utf8_func , ( char * ) utf8_param , ( char * ) utf8_param ) ;\n rc = mysql_query ( mysql , query ) ;\n myquery ( rc ) ;\n sprintf ( query , \"SELECT %s(VERSION())\" , ( char * ) utf8_func ) ;\n rc = mysql_query ( mysql , query ) ;\n myquery ( rc ) ;\n result = mysql_store_result ( mysql ) ;\n mytest ( result ) ;\n mysql_free_result ( result ) ;\n sprintf ( query , \"DROP FUNCTION %s\" , ( char * ) utf8_func ) ;\n rc = mysql_query ( mysql , query ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"set names default\" ) ;\n myquery ( rc ) ;\n DBUG_VOID_RETURN ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 38, "target": 0, "idx": 14866}
{"code": "static void test_bug7990 ( ) {\n MYSQL_STMT * stmt ;\n int rc ;\n myheader ( \"test_bug7990\" ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( stmt , \"foo\" , 3 ) ;\n DIE_UNLESS ( rc && mysql_stmt_errno ( stmt ) && mysql_errno ( mysql ) ) ;\n mysql_stmt_close ( stmt ) ;\n DIE_UNLESS ( ! mysql_errno ( mysql ) ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 10, "target": 0, "idx": 14875}
{"code": "static void test_bug6081 ( ) {\n int rc ;\n myheader ( \"test_bug6081\" ) ;\n rc = simple_command ( mysql , COM_DROP_DB , ( uchar * ) current_db , ( ulong ) strlen ( current_db ) , 0 ) ;\n if ( rc == 0 && mysql_errno ( mysql ) != ER_UNKNOWN_COM_ERROR ) {\n myerror ( NULL ) ;\n die ( __FILE__ , __LINE__ , \"COM_DROP_DB failed\" ) ;\n }\n rc = simple_command ( mysql , COM_DROP_DB , ( uchar * ) current_db , ( ulong ) strlen ( current_db ) , 0 ) ;\n myquery_r ( rc ) ;\n rc = simple_command ( mysql , COM_CREATE_DB , ( uchar * ) current_db , ( ulong ) strlen ( current_db ) , 0 ) ;\n if ( rc == 0 && mysql_errno ( mysql ) != ER_UNKNOWN_COM_ERROR ) {\n myerror ( NULL ) ;\n die ( __FILE__ , __LINE__ , \"COM_CREATE_DB failed\" ) ;\n }\n rc = simple_command ( mysql , COM_CREATE_DB , ( uchar * ) current_db , ( ulong ) strlen ( current_db ) , 0 ) ;\n myquery_r ( rc ) ;\n rc = mysql_select_db ( mysql , current_db ) ;\n myquery ( rc ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 20, "target": 0, "idx": 14882}
{"code": "static void test_bug1115 ( ) {\n MYSQL_STMT * stmt ;\n int rc ;\n MYSQL_BIND my_bind [ 1 ] ;\n ulong length [ 1 ] ;\n char szData [ 11 ] ;\n char query [ MAX_TEST_QUERY_LENGTH ] ;\n myheader ( \"test_bug1115\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_select\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_select(\\ session_id char(9) NOT NULL, \\ a int(8) unsigned NOT NULL, \\ b int(5) NOT NULL, \\ c int(5) NOT NULL, \\ d datetime NOT NULL)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO test_select VALUES \" \"(\\\"abc\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abd\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abf\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abg\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abh\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abj\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abk\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abl\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abq\\\", 1, 2, 3, 2003-08-30) \" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO test_select VALUES \" \"(\\\"abw\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abe\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abr\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abt\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"aby\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abu\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abi\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abo\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abp\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abz\\\", 1, 2, 3, 2003-08-30), \" \"(\\\"abx\\\", 1, 2, 3, 2003-08-30)\" ) ;\n myquery ( rc ) ;\n strmov ( query , \"SELECT * FROM test_select WHERE \" \"CONVERT(session_id USING utf8)= ?\" ) ;\n stmt = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt ) ;\n verify_param_count ( stmt , 1 ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n strmov ( szData , ( char * ) \"abc\" ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 0 ] . buffer = ( void * ) szData ;\n my_bind [ 0 ] . buffer_length = 10 ;\n my_bind [ 0 ] . length = & length [ 0 ] ;\n length [ 0 ] = 3 ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 1 ) ;\n strmov ( szData , ( char * ) \"venu\" ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 0 ] . buffer = ( void * ) szData ;\n my_bind [ 0 ] . buffer_length = 10 ;\n my_bind [ 0 ] . length = & length [ 0 ] ;\n length [ 0 ] = 4 ;\n my_bind [ 0 ] . is_null = 0 ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 0 ) ;\n strmov ( szData , ( char * ) \"abc\" ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 0 ] . buffer = ( void * ) szData ;\n my_bind [ 0 ] . buffer_length = 10 ;\n my_bind [ 0 ] . length = & length [ 0 ] ;\n length [ 0 ] = 3 ;\n my_bind [ 0 ] . is_null = 0 ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 1 ) ;\n mysql_stmt_close ( stmt ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 61, "target": 0, "idx": 14886}
{"code": "static uint query_cache_hits ( MYSQL * conn ) {\n MYSQL_RES * res ;\n MYSQL_ROW row ;\n int rc ;\n uint result ;\n rc = mysql_query ( conn , \"show status like 'qcache_hits'\" ) ;\n myquery ( rc ) ;\n res = mysql_use_result ( conn ) ;\n DIE_UNLESS ( res ) ;\n row = mysql_fetch_row ( res ) ;\n DIE_UNLESS ( row ) ;\n result = atoi ( row [ 1 ] ) ;\n mysql_free_result ( res ) ;\n return result ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 15, "target": 0, "idx": 14894}
{"code": "static void test_bug28505 ( ) {\n my_ulonglong res ;\n myquery ( mysql_query ( mysql , \"drop table if exists t1\" ) ) ;\n myquery ( mysql_query ( mysql , \"create table t1(f1 int primary key)\" ) ) ;\n myquery ( mysql_query ( mysql , \"insert into t1 values(1)\" ) ) ;\n myquery ( mysql_query ( mysql , \"insert into t1 values(1) on duplicate key update f1=1\" ) ) ;\n res = mysql_affected_rows ( mysql ) ;\n DIE_UNLESS ( ! res ) ;\n myquery ( mysql_query ( mysql , \"drop table t1\" ) ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 10, "target": 0, "idx": 14895}
{"code": "static void test_bug6058 ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND my_bind [ 1 ] ;\n MYSQL_RES * res ;\n MYSQL_ROW row ;\n const char * stmt_text ;\n char buffer [ 30 ] ;\n ulong length ;\n int rc ;\n myheader ( \"test_bug6058\" ) ;\n rc = mysql_query ( mysql , \"SET SQL_MODE=''\" ) ;\n myquery ( rc ) ;\n stmt_text = \"SELECT CAST('0000-00-00' AS DATE)\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n res = mysql_store_result ( mysql ) ;\n row = mysql_fetch_row ( res ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n my_bind [ 0 ] . buffer = & buffer ;\n my_bind [ 0 ] . buffer_length = sizeof ( buffer ) ;\n my_bind [ 0 ] . length = & length ;\n mysql_stmt_bind_result ( stmt , my_bind ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == 0 ) ;\n if ( ! opt_silent ) {\n printf ( \"Result from query: %s\\n\" , row [ 0 ] ) ;\n printf ( \"Result from prepared statement: %s\\n\" , buffer ) ;\n }\n DIE_UNLESS ( strcmp ( row [ 0 ] , buffer ) == 0 ) ;\n mysql_free_result ( res ) ;\n mysql_stmt_close ( stmt ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 38, "target": 0, "idx": 14902}
{"code": "static void test_bug2248 ( ) {\n MYSQL_STMT * stmt ;\n int rc ;\n const char * query1 = \"SELECT DATABASE()\" ;\n const char * query2 = \"INSERT INTO test_bug2248 VALUES (10)\" ;\n myheader ( \"test_bug2248\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_bug2248\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_bug2248 (id int)\" ) ;\n myquery ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , query1 ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute_r ( stmt , rc ) ;\n rc = mysql_stmt_store_result ( stmt ) ;\n check_execute_r ( stmt , rc ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = mysql_simple_prepare ( mysql , query2 ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == 1 ) ;\n rc = mysql_stmt_store_result ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute_r ( stmt , rc ) ;\n DIE_UNLESS ( rc == 1 ) ;\n mysql_stmt_close ( stmt ) ;\n rc = mysql_query ( mysql , \"DROP TABLE test_bug2248\" ) ;\n myquery ( rc ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 32, "target": 0, "idx": 14917}
{"code": "static void test_bug16144 ( ) {\n const my_bool flag_orig = ( my_bool ) 0xde ;\n my_bool flag = flag_orig ;\n MYSQL_STMT * stmt ;\n myheader ( \"test_bug16144\" ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n mysql_stmt_attr_set ( stmt , STMT_ATTR_UPDATE_MAX_LENGTH , ( const void * ) & flag ) ;\n mysql_stmt_attr_get ( stmt , STMT_ATTR_UPDATE_MAX_LENGTH , ( void * ) & flag ) ;\n DIE_UNLESS ( flag == flag_orig ) ;\n mysql_stmt_close ( stmt ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 11, "target": 0, "idx": 14932}
{"code": "static void test_insert_select ( ) {\n MYSQL_STMT * stmt_insert , * stmt_select ;\n char * query ;\n int rc ;\n uint i ;\n myheader ( \"test_insert_select\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS t1, t2\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t1 (a int)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t2 (a int)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (1)\" ) ;\n myquery ( rc ) ;\n query = ( char * ) \"insert into t1 select a from t2\" ;\n stmt_insert = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt_insert ) ;\n query = ( char * ) \"select * from t1\" ;\n stmt_select = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt_select ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n rc = mysql_stmt_execute ( stmt_insert ) ;\n check_execute ( stmt_insert , rc ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"insert %u\\n\" , i ) ;\n rc = mysql_stmt_execute ( stmt_select ) ;\n check_execute ( stmt_select , rc ) ;\n rc = my_process_stmt_result ( stmt_select ) ;\n DIE_UNLESS ( rc == ( int ) ( i + 1 ) ) ;\n }\n mysql_stmt_close ( stmt_insert ) ;\n mysql_stmt_close ( stmt_select ) ;\n rc = mysql_query ( mysql , \"drop table t1, t2\" ) ;\n myquery ( rc ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 36, "target": 0, "idx": 14935}
{"code": "static void test_bug49972 ( ) {\n int rc ;\n MYSQL_STMT * stmt ;\n MYSQL_BIND in_param_bind ;\n MYSQL_BIND out_param_bind ;\n int int_data ;\n my_bool is_null ;\n DBUG_ENTER ( \"test_bug49972\" ) ;\n myheader ( \"test_bug49972\" ) ;\n rc = mysql_query ( mysql , \"DROP FUNCTION IF EXISTS f1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP PROCEDURE IF EXISTS p1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE FUNCTION f1() RETURNS INT RETURN 1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE PROCEDURE p1(IN a INT, OUT b INT) SET b = a\" ) ;\n myquery ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , \"CALL p1((SELECT f1()), ?)\" ) ;\n check_stmt ( stmt ) ;\n memset ( & in_param_bind , 0 , sizeof ( in_param_bind ) ) ;\n in_param_bind . buffer_type = MYSQL_TYPE_LONG ;\n in_param_bind . buffer = ( char * ) & int_data ;\n in_param_bind . length = 0 ;\n in_param_bind . is_null = 0 ;\n rc = mysql_stmt_bind_param ( stmt , & in_param_bind ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n {\n memset ( & out_param_bind , 0 , sizeof ( out_param_bind ) ) ;\n out_param_bind . buffer_type = MYSQL_TYPE_LONG ;\n out_param_bind . is_null = & is_null ;\n out_param_bind . buffer = & int_data ;\n out_param_bind . buffer_length = sizeof ( int_data ) ;\n rc = mysql_stmt_bind_result ( stmt , & out_param_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DBUG_ASSERT ( rc == MYSQL_NO_DATA ) ;\n mysql_stmt_next_result ( stmt ) ;\n mysql_stmt_fetch ( stmt ) ;\n }\n rc = mysql_query ( mysql , \"DROP FUNCTION f1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE FUNCTION f1() RETURNS INT RETURN 1\" ) ;\n myquery ( rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n {\n memset ( & out_param_bind , 0 , sizeof ( out_param_bind ) ) ;\n out_param_bind . buffer_type = MYSQL_TYPE_LONG ;\n out_param_bind . is_null = & is_null ;\n out_param_bind . buffer = & int_data ;\n out_param_bind . buffer_length = sizeof ( int_data ) ;\n rc = mysql_stmt_bind_result ( stmt , & out_param_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DBUG_ASSERT ( rc == MYSQL_NO_DATA ) ;\n mysql_stmt_next_result ( stmt ) ;\n mysql_stmt_fetch ( stmt ) ;\n }\n mysql_stmt_close ( stmt ) ;\n rc = mysql_query ( mysql , \"DROP PROCEDURE p1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP FUNCTION f1\" ) ;\n myquery ( rc ) ;\n DBUG_VOID_RETURN ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 68, "target": 0, "idx": 14937}
{"code": "static void test_bug54041 ( ) {\n enable_query_logs ( 0 ) ;\n test_bug54041_impl ( ) ;\n disable_query_logs ( ) ;\n test_bug54041_impl ( ) ;\n restore_query_logs ( ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 7, "target": 0, "idx": 14949}
{"code": "static void test_bug9643 ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND my_bind [ 1 ] ;\n int32 a ;\n int rc ;\n const char * stmt_text ;\n int num_rows = 0 ;\n ulong type ;\n ulong prefetch_rows = 5 ;\n myheader ( \"test_bug9643\" ) ;\n mysql_query ( mysql , \"drop table if exists t1\" ) ;\n mysql_query ( mysql , \"create table t1 (id integer not null primary key)\" ) ;\n rc = mysql_query ( mysql , \"insert into t1 (id) values \" \" (1), (2), (3), (4), (5), (6), (7), (8), (9)\" ) ;\n myquery ( rc ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n type = ( ulong ) CURSOR_TYPE_SCROLLABLE ;\n rc = mysql_stmt_attr_set ( stmt , STMT_ATTR_CURSOR_TYPE , ( void * ) & type ) ;\n DIE_UNLESS ( rc ) ;\n if ( ! opt_silent ) printf ( \"Got error (as expected): %s\\n\" , mysql_stmt_error ( stmt ) ) ;\n type = ( ulong ) CURSOR_TYPE_READ_ONLY ;\n rc = mysql_stmt_attr_set ( stmt , STMT_ATTR_CURSOR_TYPE , ( void * ) & type ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_attr_set ( stmt , STMT_ATTR_PREFETCH_ROWS , ( void * ) & prefetch_rows ) ;\n check_execute ( stmt , rc ) ;\n stmt_text = \"select * from t1\" ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n check_execute ( stmt , rc ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_LONG ;\n my_bind [ 0 ] . buffer = ( void * ) & a ;\n my_bind [ 0 ] . buffer_length = sizeof ( a ) ;\n mysql_stmt_bind_result ( stmt , my_bind ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n while ( ( rc = mysql_stmt_fetch ( stmt ) ) == 0 ) ++ num_rows ;\n DIE_UNLESS ( num_rows == 9 ) ;\n rc = mysql_stmt_close ( stmt ) ;\n DIE_UNLESS ( rc == 0 ) ;\n rc = mysql_query ( mysql , \"drop table t1\" ) ;\n myquery ( rc ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 41, "target": 0, "idx": 14950}
{"code": "static void test_truncation ( ) {\n MYSQL_STMT * stmt ;\n const char * stmt_text ;\n int rc ;\n uint bind_count ;\n MYSQL_BIND * bind_array , * my_bind ;\n myheader ( \"test_truncation\" ) ;\n rc = mysql_query ( mysql , \"drop table if exists t1\" ) ;\n myquery ( rc ) ;\n stmt_text = \"create table t1 (\" \"i8 tinyint, ui8 tinyint unsigned, \" \"i16 smallint, i16_1 smallint, \" \"ui16 smallint unsigned, i32 int, i32_1 int, \" \"d double, d_1 double, ch char(30), ch_1 char(30), \" \"tx text, tx_1 text, ch_2 char(30) \" \")\" ;\n rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n myquery ( rc ) ;\n {\n const char insert_text [ ] = \"insert into t1 VALUES (\" \"-10, \" \"200, \" \"32000, \" \"-32767, \" \"64000, \" \"1073741824, \" \"1073741825, \" \"123.456, \" \"-12345678910, \" \"'111111111111111111111111111111',\" \"'abcdef', \" \"'12345 ', \" \"'12345.67 ', \" \"'12345.67abc'\" \")\" ;\n rc = mysql_real_query ( mysql , insert_text , strlen ( insert_text ) ) ;\n myquery ( rc ) ;\n }\n stmt_text = \"select i8 c1, i8 c2, ui8 c3, i16_1 c4, ui16 c5, \" \" i16 c6, ui16 c7, i32 c8, i32_1 c9, i32_1 c10, \" \" d c11, d_1 c12, d_1 c13, ch c14, ch_1 c15, tx c16, \" \" tx_1 c17, ch_2 c18 \" \"from t1\" ;\n stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n bind_count = ( uint ) mysql_stmt_field_count ( stmt ) ;\n bind_array = malloc ( sizeof ( MYSQL_BIND ) * bind_count ) ;\n memset ( bind_array , 0 , sizeof ( MYSQL_BIND ) * bind_count ) ;\n for ( my_bind = bind_array ;\n my_bind < bind_array + bind_count ;\n my_bind ++ ) my_bind -> error = & my_bind -> error_value ;\n my_bind = bind_array ;\n my_bind -> buffer = malloc ( sizeof ( uint8 ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_TINY ;\n my_bind -> is_unsigned = TRUE ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( uint32 ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_LONG ;\n my_bind -> is_unsigned = TRUE ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( int8 ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_TINY ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( uint16 ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_SHORT ;\n my_bind -> is_unsigned = TRUE ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( int16 ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_SHORT ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( uint16 ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_SHORT ;\n my_bind -> is_unsigned = TRUE ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( int8 ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_TINY ;\n my_bind -> is_unsigned = TRUE ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( float ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_FLOAT ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( float ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_FLOAT ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( double ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_DOUBLE ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( longlong ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_LONGLONG ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( ulonglong ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_LONGLONG ;\n my_bind -> is_unsigned = TRUE ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( longlong ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_LONGLONG ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( longlong ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_LONGLONG ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( longlong ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_LONGLONG ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( longlong ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_LONGLONG ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( double ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_DOUBLE ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n my_bind -> buffer = malloc ( sizeof ( double ) ) ;\n my_bind -> buffer_type = MYSQL_TYPE_DOUBLE ;\n rc = mysql_stmt_bind_result ( stmt , bind_array ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == MYSQL_DATA_TRUNCATED ) ;\n my_bind = bind_array ;\n DIE_UNLESS ( * my_bind -> error && * ( int8 * ) my_bind -> buffer == - 10 ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( * my_bind -> error && * ( int32 * ) my_bind -> buffer == - 10 ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( * my_bind -> error && * ( uint8 * ) my_bind -> buffer == 200 ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( * my_bind -> error && * ( int16 * ) my_bind -> buffer == - 32767 ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( * my_bind -> error && * ( uint16 * ) my_bind -> buffer == 64000 ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( ! * my_bind -> error && * ( uint16 * ) my_bind -> buffer == 32000 ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( * my_bind -> error && * ( int8 * ) my_bind -> buffer == 0 ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( ! * my_bind -> error && * ( float * ) my_bind -> buffer == 1073741824 ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( * my_bind -> error ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( ! * my_bind -> error && * ( double * ) my_bind -> buffer == 1073741825 ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( * my_bind -> error ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( ! * my_bind -> error && * ( longlong * ) my_bind -> buffer == LL ( - 12345678910 ) ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( * my_bind -> error ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( * my_bind -> error && * ( longlong * ) my_bind -> buffer == 0 ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( ! * my_bind -> error && * ( longlong * ) my_bind -> buffer == 12345 ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( ! * my_bind -> error && * ( double * ) my_bind -> buffer == 12345.67 ) ;\n DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n DIE_UNLESS ( * ( double * ) my_bind -> buffer == 12345.67 ) ;\n mysql_stmt_close ( stmt ) ;\n for ( my_bind = bind_array ;\n my_bind < bind_array + bind_count ;\n my_bind ++ ) free ( my_bind -> buffer ) ;\n free ( bind_array ) ;\n rc = mysql_query ( mysql , \"drop table t1\" ) ;\n myquery ( rc ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 136, "target": 0, "idx": 14955}
{"code": "static void test_bug5315 ( ) {\n MYSQL_STMT * stmt ;\n const char * stmt_text ;\n int rc ;\n myheader ( \"test_bug5315\" ) ;\n stmt_text = \"SELECT 1\" ;\n stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n DIE_UNLESS ( rc == 0 ) ;\n if ( ! opt_silent ) printf ( \"Excuting mysql_change_user\\n\" ) ;\n mysql_change_user ( mysql , opt_user , opt_password , current_db ) ;\n if ( ! opt_silent ) printf ( \"Excuting mysql_stmt_execute\\n\" ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n DIE_UNLESS ( rc != 0 ) ;\n if ( rc ) {\n if ( ! opt_silent ) printf ( \"Got error (as expected): '%s'\\n\" , mysql_stmt_error ( stmt ) ) ;\n }\n if ( ! opt_silent ) printf ( \"Excuting mysql_stmt_close\\n\" ) ;\n mysql_stmt_close ( stmt ) ;\n if ( ! opt_silent ) printf ( \"Excuting mysql_stmt_init\\n\" ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n DIE_UNLESS ( rc == 0 ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n DIE_UNLESS ( rc == 0 ) ;\n mysql_stmt_close ( stmt ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 27, "target": 0, "idx": 14972}
{"code": "static void test_order_param ( ) {\n MYSQL_STMT * stmt ;\n int rc ;\n myheader ( \"test_order_param\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE t1(a INT, b char(10))\" ) ;\n myquery ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , \"select sum(a) + 200, 1 from t1 \" \" union distinct \" \"select sum(a) + 200, 1 from t1 group by b \" ) ;\n check_stmt ( stmt ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = mysql_simple_prepare ( mysql , \"select sum(a) + 200, ? from t1 group by b \" \" union distinct \" \"select sum(a) + 200, 1 from t1 group by b \" ) ;\n check_stmt ( stmt ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = mysql_simple_prepare ( mysql , \"select sum(a) + 200, ? from t1 \" \" union distinct \" \"select sum(a) + 200, 1 from t1 group by b \" ) ;\n check_stmt ( stmt ) ;\n mysql_stmt_close ( stmt ) ;\n rc = mysql_query ( mysql , \"DROP TABLE t1\" ) ;\n myquery ( rc ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 20, "target": 0, "idx": 14990}
{"code": "static void test_ps_null_param ( ) {\n MYSQL_STMT * stmt ;\n int rc ;\n MYSQL_BIND in_bind ;\n my_bool in_is_null ;\n long int in_long ;\n MYSQL_BIND out_bind ;\n ulong out_length ;\n my_bool out_is_null ;\n char out_str_data [ 20 ] ;\n const char * queries [ ] = {\n \"select ?\" , \"select ?+1\" , \"select col1 from test_ps_nulls where col1 <=> ?\" , NULL }\n ;\n const char * * cur_query = queries ;\n myheader ( \"test_null_ps_param_in_result\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_ps_nulls\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_ps_nulls(col1 int)\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO test_ps_nulls values (1), (null)\" ) ;\n myquery ( rc ) ;\n memset ( & in_bind , 0 , sizeof ( in_bind ) ) ;\n memset ( & out_bind , 0 , sizeof ( out_bind ) ) ;\n in_bind . buffer_type = MYSQL_TYPE_LONG ;\n in_bind . is_null = & in_is_null ;\n in_bind . length = 0 ;\n in_bind . buffer = ( void * ) & in_long ;\n in_is_null = 1 ;\n in_long = 1 ;\n out_bind . buffer_type = MYSQL_TYPE_STRING ;\n out_bind . is_null = & out_is_null ;\n out_bind . length = & out_length ;\n out_bind . buffer = out_str_data ;\n out_bind . buffer_length = array_elements ( out_str_data ) ;\n for ( cur_query = queries ;\n * cur_query ;\n cur_query ++ ) {\n char query [ MAX_TEST_QUERY_LENGTH ] ;\n strmov ( query , * cur_query ) ;\n stmt = mysql_simple_prepare ( mysql , query ) ;\n check_stmt ( stmt ) ;\n verify_param_count ( stmt , 1 ) ;\n rc = mysql_stmt_bind_param ( stmt , & in_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_bind_result ( stmt , & out_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc != MYSQL_NO_DATA ) ;\n DIE_UNLESS ( out_is_null ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n DIE_UNLESS ( rc == MYSQL_NO_DATA ) ;\n mysql_stmt_close ( stmt ) ;\n }\n }", "hash": 2895622461494525400, "project": "debian", "size": 56, "target": 0, "idx": 14991}
{"code": "static void test_tran_innodb ( ) {\n MYSQL_RES * result ;\n MYSQL_ROW row ;\n int rc ;\n myheader ( \"test_tran_innodb\" ) ;\n rc = mysql_autocommit ( mysql , FALSE ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS my_demo_transaction\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE my_demo_transaction(col1 int, \" \"col2 varchar(30)) ENGINE= InnoDB\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO my_demo_transaction VALUES(10, 'venu')\" ) ;\n myquery ( rc ) ;\n rc = mysql_commit ( mysql ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"INSERT INTO my_demo_transaction VALUES(20, 'mysql')\" ) ;\n myquery ( rc ) ;\n rc = mysql_rollback ( mysql ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DELETE FROM my_demo_transaction WHERE col1= 10\" ) ;\n myquery ( rc ) ;\n rc = mysql_rollback ( mysql ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"SELECT * FROM my_demo_transaction\" ) ;\n myquery ( rc ) ;\n result = mysql_store_result ( mysql ) ;\n mytest ( result ) ;\n ( void ) my_process_result_set ( result ) ;\n mysql_free_result ( result ) ;\n rc = mysql_query ( mysql , \"SELECT * FROM my_demo_transaction\" ) ;\n myquery ( rc ) ;\n result = mysql_use_result ( mysql ) ;\n mytest ( result ) ;\n row = mysql_fetch_row ( result ) ;\n mytest ( row ) ;\n row = mysql_fetch_row ( result ) ;\n mytest_r ( row ) ;\n mysql_free_result ( result ) ;\n mysql_autocommit ( mysql , TRUE ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 40, "target": 0, "idx": 15013}
{"code": "static void test_mysql_insert_id ( ) {\n my_ulonglong res ;\n int rc ;\n myheader ( \"test_mysql_insert_id\" ) ;\n rc = mysql_query ( mysql , \"drop table if exists t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t1 (f1 int, f2 varchar(255), key(f1))\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t1 values (1,'a')\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 0 ) ;\n rc = mysql_query ( mysql , \"insert into t1 values (null,'b')\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 0 ) ;\n rc = mysql_query ( mysql , \"insert into t1 select 5,'c'\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 0 ) ;\n rc = mysql_query ( mysql , \"create table t2 (f1 int not null primary key auto_increment, f2 varchar(255))\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (null,'b')\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t1 select 5,'c'\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 0 ) ;\n rc = mysql_query ( mysql , \"drop table t2\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t1 select null,'d'\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 0 ) ;\n rc = mysql_query ( mysql , \"insert into t1 values (null,last_insert_id(300))\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 300 ) ;\n rc = mysql_query ( mysql , \"insert into t1 select null,last_insert_id(400)\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 400 ) ;\n rc = mysql_query ( mysql , \"create table t2 (f1 int not null primary key auto_increment, f2 varchar(255))\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (1,'a')\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 1 ) ;\n rc = mysql_query ( mysql , \"insert into t1 values (10,'e')\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 0 ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (null,'b')\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 2 ) ;\n rc = mysql_query ( mysql , \"insert into t2 select 5,'c'\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 5 ) ;\n rc = mysql_query ( mysql , \"insert into t2 select null,'d'\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 6 ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (10,'a'),(11,'b')\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 11 ) ;\n rc = mysql_query ( mysql , \"insert into t2 select 12,'a' union select 13,'b'\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 13 ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (null,'a'),(null,'b')\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 14 ) ;\n rc = mysql_query ( mysql , \"insert into t2 select null,'a' union select null,'b'\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 16 ) ;\n rc = mysql_query ( mysql , \"insert into t2 select 12,'a' union select 13,'b'\" ) ;\n myquery_r ( rc ) ;\n rc = mysql_query ( mysql , \"insert ignore into t2 select 12,'a' union select 13,'b'\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 0 ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (12,'a'),(13,'b')\" ) ;\n myquery_r ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 0 ) ;\n rc = mysql_query ( mysql , \"insert ignore into t2 values (12,'a'),(13,'b')\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 0 ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (null,'e'),(12,'a'),(13,'b')\" ) ;\n myquery_r ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (null,'e'),(12,'a'),(13,'b'),(25,'g')\" ) ;\n myquery_r ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (null,last_insert_id(300))\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 20 ) ;\n rc = mysql_query ( mysql , \"drop table t2\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t2 (f1 int not null primary key \" \"auto_increment, f2 varchar(255), unique (f2))\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (null,'e')\" ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 1 ) ;\n rc = mysql_query ( mysql , \"insert ignore into t2 values (null,'e'),(null,'a'),(null,'e')\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 2 ) ;\n rc = mysql_query ( mysql , \"insert ignore into t2 values (null,'e'),(12,'c'),(null,'d')\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 13 ) ;\n rc = mysql_query ( mysql , \"update t2 set f1=14 where f1=12\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 0 ) ;\n rc = mysql_query ( mysql , \"update t2 set f1=0 where f1=14\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 0 ) ;\n rc = mysql_query ( mysql , \"update t2 set f2=last_insert_id(372) where f1=0\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 372 ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (null,'g')\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 15 ) ;\n rc = mysql_query ( mysql , \"update t2 set f2=(@li:=last_insert_id()) where f1=15\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 0 ) ;\n rc = mysql_query ( mysql , \"insert into t2 values (null,@li) on duplicate key \" \"update f2=concat('we updated ',f2)\" ) ;\n myquery ( rc ) ;\n res = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( res == 15 ) ;\n rc = mysql_query ( mysql , \"drop table t1,t2\" ) ;\n myquery ( rc ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 144, "target": 0, "idx": 15022}
{"code": "static void test_bad_union ( ) {\n MYSQL_STMT * stmt ;\n const char * query = \"SELECT 1, 2 union SELECT 1\" ;\n myheader ( \"test_bad_union\" ) ;\n stmt = mysql_simple_prepare ( mysql , query ) ;\n DIE_UNLESS ( stmt == 0 ) ;\n myerror ( NULL ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 8, "target": 0, "idx": 15026}
{"code": "static void test_bug21635 ( ) {\n const char * expr [ ] = {\n \"MIN(i)\" , \"MIN(i)\" , \"MIN(i) AS A1\" , \"A1\" , \"MAX(i)\" , \"MAX(i)\" , \"MAX(i) AS A2\" , \"A2\" , \"COUNT(i)\" , \"COUNT(i)\" , \"COUNT(i) AS A3\" , \"A3\" , }\n ;\n char query [ MAX_TEST_QUERY_LENGTH ] ;\n char * query_end ;\n MYSQL_RES * result ;\n MYSQL_FIELD * field ;\n unsigned int field_count , i , j ;\n int rc ;\n DBUG_ENTER ( \"test_bug21635\" ) ;\n myheader ( \"test_bug21635\" ) ;\n query_end = strxmov ( query , \"SELECT \" , NullS ) ;\n for ( i = 0 ;\n i < sizeof ( expr ) / sizeof ( * expr ) / 2 ;\n ++ i ) query_end = strxmov ( query_end , expr [ i * 2 ] , \", \" , NullS ) ;\n query_end = strxmov ( query_end - 2 , \" FROM t1 GROUP BY i\" , NullS ) ;\n DIE_UNLESS ( query_end - query < MAX_TEST_QUERY_LENGTH ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE t1 (i INT)\" ) ;\n myquery ( rc ) ;\n for ( j = 0 ;\n j < 2 ;\n j ++ ) {\n rc = mysql_query ( mysql , \"INSERT INTO t1 VALUES (1)\" ) ;\n myquery ( rc ) ;\n rc = mysql_real_query ( mysql , query , query_end - query ) ;\n myquery ( rc ) ;\n result = mysql_use_result ( mysql ) ;\n DIE_UNLESS ( result ) ;\n field_count = mysql_field_count ( mysql ) ;\n for ( i = 0 ;\n i < field_count ;\n ++ i ) {\n field = mysql_fetch_field_direct ( result , i ) ;\n if ( ! opt_silent ) if ( ! opt_silent ) printf ( \"%s -> %s ... \" , expr [ i * 2 ] , field -> name ) ;\n fflush ( stdout ) ;\n DIE_UNLESS ( field -> db [ 0 ] == 0 && field -> org_table [ 0 ] == 0 && field -> table [ 0 ] == 0 && field -> org_name [ 0 ] == 0 ) ;\n DIE_UNLESS ( strcmp ( field -> name , expr [ i * 2 + 1 ] ) == 0 ) ;\n if ( ! opt_silent ) if ( ! opt_silent ) puts ( \"OK\" ) ;\n }\n mysql_free_result ( result ) ;\n }\n rc = mysql_query ( mysql , \"DROP TABLE t1\" ) ;\n myquery ( rc ) ;\n DBUG_VOID_RETURN ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 48, "target": 0, "idx": 15030}
{"code": "static void test_field_misc ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_RES * result ;\n int rc ;\n myheader ( \"test_field_misc\" ) ;\n rc = mysql_query ( mysql , \"SELECT @@autocommit\" ) ;\n myquery ( rc ) ;\n result = mysql_store_result ( mysql ) ;\n mytest ( result ) ;\n rc = my_process_result_set ( result ) ;\n DIE_UNLESS ( rc == 1 ) ;\n verify_prepare_field ( result , 0 , \"@@autocommit\" , \"\" , MYSQL_TYPE_LONGLONG , \"\" , \"\" , \"\" , 1 , 0 ) ;\n mysql_free_result ( result ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT @@autocommit\" ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n result = mysql_stmt_result_metadata ( stmt ) ;\n mytest ( result ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 1 ) ;\n verify_prepare_field ( result , 0 , \"@@autocommit\" , \"\" , MYSQL_TYPE_LONGLONG , \"\" , \"\" , \"\" , 1 , 0 ) ;\n mysql_free_result ( result ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT @@max_error_count\" ) ;\n check_stmt ( stmt ) ;\n result = mysql_stmt_result_metadata ( stmt ) ;\n mytest ( result ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 1 ) ;\n verify_prepare_field ( result , 0 , \"@@max_error_count\" , \"\" , MYSQL_TYPE_LONGLONG , \"\" , \"\" , \"\" , MY_INT64_NUM_DECIMAL_DIGITS , 0 ) ;\n mysql_free_result ( result ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT @@max_allowed_packet\" ) ;\n check_stmt ( stmt ) ;\n result = mysql_stmt_result_metadata ( stmt ) ;\n mytest ( result ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n DIE_UNLESS ( 1 == my_process_stmt_result ( stmt ) ) ;\n verify_prepare_field ( result , 0 , \"@@max_allowed_packet\" , \"\" , MYSQL_TYPE_LONGLONG , \"\" , \"\" , \"\" , MY_INT64_NUM_DECIMAL_DIGITS , 0 ) ;\n mysql_free_result ( result ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT @@sql_warnings\" ) ;\n check_stmt ( stmt ) ;\n result = mysql_stmt_result_metadata ( stmt ) ;\n mytest ( result ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = my_process_stmt_result ( stmt ) ;\n DIE_UNLESS ( rc == 1 ) ;\n verify_prepare_field ( result , 0 , \"@@sql_warnings\" , \"\" , MYSQL_TYPE_LONGLONG , \"\" , \"\" , \"\" , 1 , 0 ) ;\n mysql_free_result ( result ) ;\n mysql_stmt_close ( stmt ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 57, "target": 0, "idx": 15053}
{"code": "static void test_bug3117 ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND buffer ;\n longlong lii ;\n ulong length ;\n my_bool is_null ;\n int rc ;\n myheader ( \"test_bug3117\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE t1 (id int auto_increment primary key)\" ) ;\n myquery ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT LAST_INSERT_ID()\" ) ;\n check_stmt ( stmt ) ;\n rc = mysql_query ( mysql , \"INSERT INTO t1 VALUES (NULL)\" ) ;\n myquery ( rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n memset ( & buffer , 0 , sizeof ( buffer ) ) ;\n buffer . buffer_type = MYSQL_TYPE_LONGLONG ;\n buffer . buffer_length = sizeof ( lii ) ;\n buffer . buffer = ( void * ) & lii ;\n buffer . length = & length ;\n buffer . is_null = & is_null ;\n rc = mysql_stmt_bind_result ( stmt , & buffer ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_store_result ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n DIE_UNLESS ( is_null == 0 && lii == 1 ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\n\\tLAST_INSERT_ID()= 1 ok\\n\" ) ;\n rc = mysql_query ( mysql , \"INSERT INTO t1 VALUES (NULL)\" ) ;\n myquery ( rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_fetch ( stmt ) ;\n check_execute ( stmt , rc ) ;\n DIE_UNLESS ( is_null == 0 && lii == 2 ) ;\n if ( ! opt_silent ) fprintf ( stdout , \"\\tLAST_INSERT_ID()= 2 ok\\n\" ) ;\n mysql_stmt_close ( stmt ) ;\n rc = mysql_query ( mysql , \"DROP TABLE t1\" ) ;\n myquery ( rc ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 44, "target": 0, "idx": 15054}
{"code": "static void test_bug56976 ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND bind [ 1 ] ;\n int rc ;\n const char * query = \"SELECT LENGTH(?)\" ;\n char * long_buffer ;\n unsigned long i , packet_len = 256 * 1024L ;\n unsigned long dos_len = 8 * 1024 * 1024L ;\n DBUG_ENTER ( \"test_bug56976\" ) ;\n myheader ( \"test_bug56976\" ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n check_execute ( stmt , rc ) ;\n memset ( bind , 0 , sizeof ( bind ) ) ;\n bind [ 0 ] . buffer_type = MYSQL_TYPE_TINY_BLOB ;\n rc = mysql_stmt_bind_param ( stmt , bind ) ;\n check_execute ( stmt , rc ) ;\n long_buffer = ( char * ) my_malloc ( packet_len , MYF ( 0 ) ) ;\n DIE_UNLESS ( long_buffer ) ;\n memset ( long_buffer , 'a' , packet_len ) ;\n for ( i = 0 ;\n i < dos_len / packet_len ;\n i ++ ) {\n rc = mysql_stmt_send_long_data ( stmt , 0 , long_buffer , packet_len ) ;\n check_execute ( stmt , rc ) ;\n }\n my_free ( long_buffer ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n DIE_UNLESS ( rc && mysql_stmt_errno ( stmt ) == ER_UNKNOWN_ERROR ) ;\n mysql_stmt_close ( stmt ) ;\n DBUG_VOID_RETURN ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 33, "target": 0, "idx": 15058}
{"code": "static void test_bug9735 ( ) {\n MYSQL_RES * res ;\n int rc ;\n myheader ( \"test_bug9735\" ) ;\n rc = mysql_query ( mysql , \"drop table if exists t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t1 (a mediumtext, b longtext) \" \"character set latin1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"select * from t1\" ) ;\n myquery ( rc ) ;\n res = mysql_store_result ( mysql ) ;\n verify_prepare_field ( res , 0 , \"a\" , \"a\" , MYSQL_TYPE_BLOB , \"t1\" , \"t1\" , current_db , ( 1U << 24 ) - 1 , 0 ) ;\n verify_prepare_field ( res , 1 , \"b\" , \"b\" , MYSQL_TYPE_BLOB , \"t1\" , \"t1\" , current_db , ~ 0U , 0 ) ;\n mysql_free_result ( res ) ;\n rc = mysql_query ( mysql , \"drop table t1\" ) ;\n myquery ( rc ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 17, "target": 0, "idx": 15066}
{"code": "static void test_pure_coverage ( ) {\n MYSQL_STMT * stmt ;\n MYSQL_BIND my_bind [ 2 ] ;\n int rc ;\n ulong length ;\n myheader ( \"test_pure_coverage\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_pure\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_pure(c1 int, c2 varchar(20))\" ) ;\n myquery ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , \"insert into test_pure(c67788) values(10)\" ) ;\n check_stmt_r ( stmt ) ;\n stmt = mysql_simple_prepare ( mysql , \"insert into test_pure(c2) values(10)\" ) ;\n check_stmt ( stmt ) ;\n rc = mysql_stmt_bind_param ( stmt , ( MYSQL_BIND * ) 0 ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_bind_result ( stmt , ( MYSQL_BIND * ) 0 ) ;\n DIE_UNLESS ( rc == 1 ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = mysql_simple_prepare ( mysql , \"insert into test_pure(c2) values(?)\" ) ;\n check_stmt ( stmt ) ;\n memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n my_bind [ 0 ] . length = & length ;\n my_bind [ 0 ] . is_null = 0 ;\n my_bind [ 0 ] . buffer_length = 0 ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_GEOMETRY ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute_r ( stmt , rc ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_store_result ( stmt ) ;\n check_execute ( stmt , rc ) ;\n mysql_stmt_close ( stmt ) ;\n stmt = mysql_simple_prepare ( mysql , \"select * from test_pure\" ) ;\n check_execute ( stmt , rc ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n check_execute ( stmt , rc ) ;\n my_bind [ 0 ] . buffer_type = MYSQL_TYPE_GEOMETRY ;\n rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n check_execute_r ( stmt , rc ) ;\n rc = mysql_stmt_store_result ( stmt ) ;\n DIE_UNLESS ( rc ) ;\n rc = mysql_stmt_store_result ( stmt ) ;\n DIE_UNLESS ( rc ) ;\n mysql_stmt_close ( stmt ) ;\n mysql_query ( mysql , \"DROP TABLE test_pure\" ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 50, "target": 0, "idx": 15077}
{"code": "static void test_fetch_double ( ) {\n int rc ;\n myheader ( \"test_fetch_double\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_bind_fetch\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_bind_fetch(c1 double(5, 2), \" \"c2 double unsigned, c3 double unsigned, \" \"c4 double unsigned, c5 double unsigned, \" \"c6 double unsigned, c7 double unsigned)\" ) ;\n myquery ( rc ) ;\n bind_fetch ( 3 ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 9, "target": 0, "idx": 15093}
{"code": "static void test_bug21726 ( ) {\n const char * create_table [ ] = {\n \"DROP TABLE IF EXISTS t1\" , \"CREATE TABLE t1 (i INT)\" , \"INSERT INTO t1 VALUES (1)\" , }\n ;\n const char * update_query = \"UPDATE t1 SET i= LAST_INSERT_ID(i + 1)\" ;\n int rc ;\n my_ulonglong insert_id ;\n const char * select_query = \"SELECT * FROM t1\" ;\n MYSQL_RES * result ;\n DBUG_ENTER ( \"test_bug21726\" ) ;\n myheader ( \"test_bug21726\" ) ;\n fill_tables ( create_table , sizeof ( create_table ) / sizeof ( * create_table ) ) ;\n rc = mysql_query ( mysql , update_query ) ;\n myquery ( rc ) ;\n insert_id = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( insert_id == 2 ) ;\n rc = mysql_query ( mysql , update_query ) ;\n myquery ( rc ) ;\n insert_id = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( insert_id == 3 ) ;\n rc = mysql_query ( mysql , select_query ) ;\n myquery ( rc ) ;\n insert_id = mysql_insert_id ( mysql ) ;\n DIE_UNLESS ( insert_id == 3 ) ;\n result = mysql_store_result ( mysql ) ;\n mysql_free_result ( result ) ;\n DBUG_VOID_RETURN ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 28, "target": 0, "idx": 15095}
{"code": "static void test_prepare_resultset ( ) {\n MYSQL_STMT * stmt ;\n int rc ;\n MYSQL_RES * result ;\n myheader ( \"test_prepare_resultset\" ) ;\n rc = mysql_autocommit ( mysql , TRUE ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_prepare_resultset\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_prepare_resultset(id int, \\ name varchar(50), extra double)\" ) ;\n myquery ( rc ) ;\n stmt = mysql_simple_prepare ( mysql , \"SELECT * FROM test_prepare_resultset\" ) ;\n check_stmt ( stmt ) ;\n verify_param_count ( stmt , 0 ) ;\n result = mysql_stmt_result_metadata ( stmt ) ;\n mytest ( result ) ;\n my_print_result_metadata ( result ) ;\n mysql_free_result ( result ) ;\n mysql_stmt_close ( stmt ) ;\n }", "hash": 2895622461494525400, "project": "debian", "size": 20, "target": 0, "idx": 15103}
{"code": "static void var_read_metadata ( AVFormatContext * avctx , const char * tag , int size ) {\n char * value = var_read_string ( avctx -> pb , size ) ;\n if ( value ) av_dict_set ( & avctx -> metadata , tag , value , AV_DICT_DONT_STRDUP_VAL ) ;\n }", "hash": 3896936900447628930, "project": "debian", "size": 4, "target": 0, "idx": 15127}
{"code": "static void read_index ( AVIOContext * pb , AVStream * st ) {\n uint64_t timestamp = 0 ;\n int i ;\n for ( i = 0 ;\n i < st -> nb_frames ;\n i ++ ) {\n uint32_t pos = avio_rb32 ( pb ) ;\n uint32_t size = avio_rb32 ( pb ) ;\n avio_skip ( pb , 8 ) ;\n av_add_index_entry ( st , pos , timestamp , size , 0 , AVINDEX_KEYFRAME ) ;\n if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) {\n timestamp += size / ( st -> codecpar -> channels * 2 ) ;\n }\n else {\n timestamp ++ ;\n }\n }\n }", "hash": 3896936900447628930, "project": "debian", "size": 18, "target": 0, "idx": 15128}
{"code": "static int dsa_sig_print ( BIO * bp , const X509_ALGOR * sigalg , const ASN1_STRING * sig , int indent , ASN1_PCTX * pctx ) {\n DSA_SIG * dsa_sig ;\n const unsigned char * p ;\n if ( ! sig ) {\n if ( BIO_puts ( bp , \"\\n\" ) <= 0 ) return 0 ;\n else return 1 ;\n }\n p = sig -> data ;\n dsa_sig = d2i_DSA_SIG ( NULL , & p , sig -> length ) ;\n if ( dsa_sig ) {\n int rv = 0 ;\n size_t buf_len = 0 ;\n unsigned char * m = NULL ;\n update_buflen ( dsa_sig -> r , & buf_len ) ;\n update_buflen ( dsa_sig -> s , & buf_len ) ;\n m = OPENSSL_malloc ( buf_len + 10 ) ;\n if ( m == NULL ) {\n DSAerr ( DSA_F_DSA_SIG_PRINT , ERR_R_MALLOC_FAILURE ) ;\n goto err ;\n }\n if ( BIO_write ( bp , \"\\n\" , 1 ) != 1 ) goto err ;\n if ( ! ASN1_bn_print ( bp , \"r: \" , dsa_sig -> r , m , indent ) ) goto err ;\n if ( ! ASN1_bn_print ( bp , \"s: \" , dsa_sig -> s , m , indent ) ) goto err ;\n rv = 1 ;\n err : OPENSSL_free ( m ) ;\n DSA_SIG_free ( dsa_sig ) ;\n return rv ;\n }\n return X509_signature_dump ( bp , sig , indent ) ;\n }", "hash": -3146697469509848825, "project": "debian", "size": 30, "target": 0, "idx": 15141}
{"code": "static int dsa_priv_decode ( EVP_PKEY * pkey , PKCS8_PRIV_KEY_INFO * p8 ) {\n const unsigned char * p , * q , * pm ;\n int pklen , pmlen ;\n int ptype ;\n void * pval ;\n ASN1_STRING * pstr ;\n X509_ALGOR * palg ;\n ASN1_INTEGER * privkey = NULL ;\n BN_CTX * ctx = NULL ;\n DSA * dsa = NULL ;\n int ret = 0 ;\n if ( ! PKCS8_pkey_get0 ( NULL , & p , & pklen , & palg , p8 ) ) return 0 ;\n X509_ALGOR_get0 ( NULL , & ptype , & pval , palg ) ;\n q = p ;\n if ( ( privkey = d2i_ASN1_INTEGER ( NULL , & p , pklen ) ) == NULL ) goto decerr ;\n if ( privkey -> type == V_ASN1_NEG_INTEGER ) {\n p8 -> broken = PKCS8_NEG_PRIVKEY ;\n ASN1_STRING_clear_free ( privkey ) ;\n if ( ( privkey = d2i_ASN1_UINTEGER ( NULL , & q , pklen ) ) == NULL ) goto decerr ;\n }\n if ( ptype != V_ASN1_SEQUENCE ) goto decerr ;\n pstr = pval ;\n pm = pstr -> data ;\n pmlen = pstr -> length ;\n if ( ( dsa = d2i_DSAparams ( NULL , & pm , pmlen ) ) == NULL ) goto decerr ;\n if ( ( dsa -> priv_key = BN_secure_new ( ) ) == NULL || ! ASN1_INTEGER_to_BN ( privkey , dsa -> priv_key ) ) {\n DSAerr ( DSA_F_DSA_PRIV_DECODE , DSA_R_BN_ERROR ) ;\n goto dsaerr ;\n }\n if ( ( dsa -> pub_key = BN_new ( ) ) == NULL ) {\n DSAerr ( DSA_F_DSA_PRIV_DECODE , ERR_R_MALLOC_FAILURE ) ;\n goto dsaerr ;\n }\n if ( ( ctx = BN_CTX_new ( ) ) == NULL ) {\n DSAerr ( DSA_F_DSA_PRIV_DECODE , ERR_R_MALLOC_FAILURE ) ;\n goto dsaerr ;\n }\n if ( ! BN_mod_exp ( dsa -> pub_key , dsa -> g , dsa -> priv_key , dsa -> p , ctx ) ) {\n DSAerr ( DSA_F_DSA_PRIV_DECODE , DSA_R_BN_ERROR ) ;\n goto dsaerr ;\n }\n EVP_PKEY_assign_DSA ( pkey , dsa ) ;\n ret = 1 ;\n goto done ;\n decerr : DSAerr ( DSA_F_DSA_PRIV_DECODE , DSA_R_DECODE_ERROR ) ;\n dsaerr : DSA_free ( dsa ) ;\n done : BN_CTX_free ( ctx ) ;\n ASN1_STRING_clear_free ( privkey ) ;\n return ret ;\n }", "hash": -3146697469509848825, "project": "debian", "size": 50, "target": 0, "idx": 15143}
{"code": "static int dsa_param_encode ( const EVP_PKEY * pkey , unsigned char * * pder ) {\n return i2d_DSAparams ( pkey -> pkey . dsa , pder ) ;\n }", "hash": -3146697469509848825, "project": "debian", "size": 3, "target": 0, "idx": 15149}
{"code": "static int dsa_copy_parameters ( EVP_PKEY * to , const EVP_PKEY * from ) {\n BIGNUM * a ;\n if ( to -> pkey . dsa == NULL ) {\n to -> pkey . dsa = DSA_new ( ) ;\n if ( to -> pkey . dsa == NULL ) return 0 ;\n }\n if ( ( a = BN_dup ( from -> pkey . dsa -> p ) ) == NULL ) return 0 ;\n BN_free ( to -> pkey . dsa -> p ) ;\n to -> pkey . dsa -> p = a ;\n if ( ( a = BN_dup ( from -> pkey . dsa -> q ) ) == NULL ) return 0 ;\n BN_free ( to -> pkey . dsa -> q ) ;\n to -> pkey . dsa -> q = a ;\n if ( ( a = BN_dup ( from -> pkey . dsa -> g ) ) == NULL ) return 0 ;\n BN_free ( to -> pkey . dsa -> g ) ;\n to -> pkey . dsa -> g = a ;\n return 1 ;\n }", "hash": -3146697469509848825, "project": "debian", "size": 17, "target": 0, "idx": 15151}
{"code": "CURLcode Curl_http ( struct connectdata * conn , bool * done ) {\n struct Curl_easy * data = conn -> data ;\n CURLcode result = CURLE_OK ;\n struct HTTP * http ;\n const char * ppath = data -> state . path ;\n bool paste_ftp_userpwd = FALSE ;\n char ftp_typecode [ sizeof ( \"/;\ntype=?\" ) ] = \"\" ;\n const char * host = conn -> host . name ;\n const char * te = \"\" ;\n const char * ptr ;\n const char * request ;\n Curl_HttpReq httpreq = data -> set . httpreq ;\n # if ! defined ( CURL_DISABLE_COOKIES ) char * addcookies = NULL ;\n # endif curl_off_t included_body = 0 ;\n const char * httpstring ;\n Curl_send_buffer * req_buffer ;\n curl_off_t postsize = 0 ;\n int seekerr = CURL_SEEKFUNC_OK ;\n * done = TRUE ;\n if ( conn -> httpversion < 20 ) {\n switch ( conn -> negnpn ) {\n case CURL_HTTP_VERSION_2 : conn -> httpversion = 20 ;\n result = Curl_http2_switched ( conn , NULL , 0 ) ;\n if ( result ) return result ;\n break ;\n case CURL_HTTP_VERSION_1_1 : break ;\n default : # ifdef USE_NGHTTP2 if ( conn -> data -> set . httpversion == CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE ) {\n DEBUGF ( infof ( data , \"HTTP/2 over clean TCP\\n\" ) ) ;\n conn -> httpversion = 20 ;\n result = Curl_http2_switched ( conn , NULL , 0 ) ;\n if ( result ) return result ;\n }\n # endif break ;\n }\n }\n else {\n result = Curl_http2_setup ( conn ) ;\n if ( result ) return result ;\n }\n http = data -> req . protop ;\n if ( ! data -> state . this_is_a_follow ) {\n free ( data -> state . first_host ) ;\n data -> state . first_host = strdup ( conn -> host . name ) ;\n if ( ! data -> state . first_host ) return CURLE_OUT_OF_MEMORY ;\n data -> state . first_remote_port = conn -> remote_port ;\n }\n http -> writebytecount = http -> readbytecount = 0 ;\n if ( ( conn -> handler -> protocol & ( PROTO_FAMILY_HTTP | CURLPROTO_FTP ) ) && data -> set . upload ) {\n httpreq = HTTPREQ_PUT ;\n }\n if ( data -> set . str [ STRING_CUSTOMREQUEST ] ) request = data -> set . str [ STRING_CUSTOMREQUEST ] ;\n else {\n if ( data -> set . opt_no_body ) request = \"HEAD\" ;\n else {\n DEBUGASSERT ( ( httpreq > HTTPREQ_NONE ) && ( httpreq < HTTPREQ_LAST ) ) ;\n switch ( httpreq ) {\n case HTTPREQ_POST : case HTTPREQ_POST_FORM : request = \"POST\" ;\n break ;\n case HTTPREQ_PUT : request = \"PUT\" ;\n break ;\n default : case HTTPREQ_GET : request = \"GET\" ;\n break ;\n case HTTPREQ_HEAD : request = \"HEAD\" ;\n break ;\n }\n }\n }\n if ( Curl_checkheaders ( conn , \"User-Agent:\" ) ) {\n free ( conn -> allocptr . uagent ) ;\n conn -> allocptr . uagent = NULL ;\n }\n result = Curl_http_output_auth ( conn , request , ppath , FALSE ) ;\n if ( result ) return result ;\n if ( ( data -> state . authhost . multi || data -> state . authproxy . multi ) && ( httpreq != HTTPREQ_GET ) && ( httpreq != HTTPREQ_HEAD ) ) {\n conn -> bits . authneg = TRUE ;\n }\n else conn -> bits . authneg = FALSE ;\n Curl_safefree ( conn -> allocptr . ref ) ;\n if ( data -> change . referer && ! Curl_checkheaders ( conn , \"Referer:\" ) ) {\n conn -> allocptr . ref = aprintf ( \"Referer: %s\\r\\n\" , data -> change . referer ) ;\n if ( ! conn -> allocptr . ref ) return CURLE_OUT_OF_MEMORY ;\n }\n else conn -> allocptr . ref = NULL ;\n # if ! defined ( CURL_DISABLE_COOKIES ) if ( data -> set . str [ STRING_COOKIE ] && ! Curl_checkheaders ( conn , \"Cookie:\" ) ) addcookies = data -> set . str [ STRING_COOKIE ] ;\n # endif if ( ! Curl_checkheaders ( conn , \"Accept-Encoding:\" ) && data -> set . str [ STRING_ENCODING ] ) {\n Curl_safefree ( conn -> allocptr . accept_encoding ) ;\n conn -> allocptr . accept_encoding = aprintf ( \"Accept-Encoding: %s\\r\\n\" , data -> set . str [ STRING_ENCODING ] ) ;\n if ( ! conn -> allocptr . accept_encoding ) return CURLE_OUT_OF_MEMORY ;\n }\n else {\n Curl_safefree ( conn -> allocptr . accept_encoding ) ;\n conn -> allocptr . accept_encoding = NULL ;\n }\n # ifdef HAVE_LIBZ if ( ! Curl_checkheaders ( conn , \"TE:\" ) && data -> set . http_transfer_encoding ) {\n char * cptr = Curl_checkheaders ( conn , \"Connection:\" ) ;\n # define TE_HEADER \"TE: gzip\\r\\n\" Curl_safefree ( conn -> allocptr . te ) ;\n conn -> allocptr . te = cptr ? aprintf ( \"%s, TE\\r\\n\" TE_HEADER , cptr ) : strdup ( \"Connection: TE\\r\\n\" TE_HEADER ) ;\n if ( ! conn -> allocptr . te ) return CURLE_OUT_OF_MEMORY ;\n }\n # endif ptr = Curl_checkheaders ( conn , \"Transfer-Encoding:\" ) ;\n if ( ptr ) {\n data -> req . upload_chunky = Curl_compareheader ( ptr , \"Transfer-Encoding:\" , \"chunked\" ) ;\n }\n else {\n if ( ( conn -> handler -> protocol & PROTO_FAMILY_HTTP ) && data -> set . upload && ( data -> state . infilesize == - 1 ) ) {\n if ( conn -> bits . authneg ) ;\n else if ( use_http_1_1plus ( data , conn ) ) {\n data -> req . upload_chunky = TRUE ;\n }\n else {\n failf ( data , \"Chunky upload is not supported by HTTP 1.0\" ) ;\n return CURLE_UPLOAD_FAILED ;\n }\n }\n else {\n data -> req . upload_chunky = FALSE ;\n }\n if ( data -> req . upload_chunky ) te = \"Transfer-Encoding: chunked\\r\\n\" ;\n }\n Curl_safefree ( conn -> allocptr . host ) ;\n ptr = Curl_checkheaders ( conn , \"Host:\" ) ;\n if ( ptr && ( ! data -> state . this_is_a_follow || Curl_raw_equal ( data -> state . first_host , conn -> host . name ) ) ) {\n # if ! defined ( CURL_DISABLE_COOKIES ) char * cookiehost = Curl_copy_header_value ( ptr ) ;\n if ( ! cookiehost ) return CURLE_OUT_OF_MEMORY ;\n if ( ! * cookiehost ) free ( cookiehost ) ;\n else {\n int startsearch = 0 ;\n if ( * cookiehost == '[' ) {\n char * closingbracket ;\n memmove ( cookiehost , cookiehost + 1 , strlen ( cookiehost ) - 1 ) ;\n closingbracket = strchr ( cookiehost , ']' ) ;\n if ( closingbracket ) * closingbracket = 0 ;\n }\n else {\n char * colon = strchr ( cookiehost + startsearch , ':' ) ;\n if ( colon ) * colon = 0 ;\n }\n Curl_safefree ( conn -> allocptr . cookiehost ) ;\n conn -> allocptr . cookiehost = cookiehost ;\n }\n # endif if ( strcmp ( \"Host:\" , ptr ) ) {\n conn -> allocptr . host = aprintf ( \"%s\\r\\n\" , ptr ) ;\n if ( ! conn -> allocptr . host ) return CURLE_OUT_OF_MEMORY ;\n }\n else conn -> allocptr . host = NULL ;\n }\n else {\n if ( ( ( conn -> given -> protocol & CURLPROTO_HTTPS ) && ( conn -> remote_port == PORT_HTTPS ) ) || ( ( conn -> given -> protocol & CURLPROTO_HTTP ) && ( conn -> remote_port == PORT_HTTP ) ) ) conn -> allocptr . host = aprintf ( \"Host: %s%s%s\\r\\n\" , conn -> bits . ipv6_ip ? \"[\" : \"\" , host , conn -> bits . ipv6_ip ? \"]\" : \"\" ) ;\n else conn -> allocptr . host = aprintf ( \"Host: %s%s%s:%hu\\r\\n\" , conn -> bits . ipv6_ip ? \"[\" : \"\" , host , conn -> bits . ipv6_ip ? \"]\" : \"\" , conn -> remote_port ) ;\n if ( ! conn -> allocptr . host ) return CURLE_OUT_OF_MEMORY ;\n }\n # ifndef CURL_DISABLE_PROXY if ( conn -> bits . httpproxy && ! conn -> bits . tunnel_proxy ) {\n if ( conn -> host . dispname != conn -> host . name ) {\n char * url = data -> change . url ;\n ptr = strstr ( url , conn -> host . dispname ) ;\n if ( ptr ) {\n size_t currlen = strlen ( conn -> host . dispname ) ;\n size_t newlen = strlen ( conn -> host . name ) ;\n size_t urllen = strlen ( url ) ;\n char * newurl ;\n newurl = malloc ( urllen + newlen - currlen + 1 ) ;\n if ( newurl ) {\n memcpy ( newurl , url , ptr - url ) ;\n memcpy ( newurl + ( ptr - url ) , conn -> host . name , newlen ) ;\n memcpy ( newurl + newlen + ( ptr - url ) , ptr + currlen , urllen - ( ptr - url ) - currlen + 1 ) ;\n if ( data -> change . url_alloc ) {\n Curl_safefree ( data -> change . url ) ;\n data -> change . url_alloc = FALSE ;\n }\n data -> change . url = newurl ;\n data -> change . url_alloc = TRUE ;\n }\n else return CURLE_OUT_OF_MEMORY ;\n }\n }\n ppath = data -> change . url ;\n if ( checkprefix ( \"ftp://\" , ppath ) ) {\n if ( data -> set . proxy_transfer_mode ) {\n char * type = strstr ( ppath , \";\ntype=\" ) ;\n if ( type && type [ 6 ] && type [ 7 ] == 0 ) {\n switch ( Curl_raw_toupper ( type [ 6 ] ) ) {\n case 'A' : case 'D' : case 'I' : break ;\n default : type = NULL ;\n }\n }\n if ( ! type ) {\n char * p = ftp_typecode ;\n if ( ! * data -> state . path && ppath [ strlen ( ppath ) - 1 ] != '/' ) {\n * p ++ = '/' ;\n }\n snprintf ( p , sizeof ( ftp_typecode ) - 1 , \";\ntype=%c\" , data -> set . prefer_ascii ? 'a' : 'i' ) ;\n }\n }\n if ( conn -> bits . user_passwd && ! conn -> bits . userpwd_in_url ) paste_ftp_userpwd = TRUE ;\n }\n }\n # endif if ( HTTPREQ_POST_FORM == httpreq ) {\n result = Curl_getformdata ( data , & http -> sendit , data -> set . httppost , Curl_checkheaders ( conn , \"Content-Type:\" ) , & http -> postsize ) ;\n if ( result ) return result ;\n }\n http -> p_accept = Curl_checkheaders ( conn , \"Accept:\" ) ? NULL : \"Accept: */*\\r\\n\" ;\n if ( ( ( HTTPREQ_POST == httpreq ) || ( HTTPREQ_POST_FORM == httpreq ) || ( HTTPREQ_PUT == httpreq ) ) && data -> state . resume_from ) {\n if ( data -> state . resume_from < 0 ) {\n data -> state . resume_from = 0 ;\n }\n if ( data -> state . resume_from && ! data -> state . this_is_a_follow ) {\n if ( conn -> seek_func ) {\n seekerr = conn -> seek_func ( conn -> seek_client , data -> state . resume_from , SEEK_SET ) ;\n }\n if ( seekerr != CURL_SEEKFUNC_OK ) {\n if ( seekerr != CURL_SEEKFUNC_CANTSEEK ) {\n failf ( data , \"Could not seek stream\" ) ;\n return CURLE_READ_ERROR ;\n }\n else {\n curl_off_t passed = 0 ;\n do {\n size_t readthisamountnow = ( data -> state . resume_from - passed > CURL_OFF_T_C ( BUFSIZE ) ) ? BUFSIZE : curlx_sotouz ( data -> state . resume_from - passed ) ;\n size_t actuallyread = data -> state . fread_func ( data -> state . buffer , 1 , readthisamountnow , data -> state . in ) ;\n passed += actuallyread ;\n if ( ( actuallyread == 0 ) || ( actuallyread > readthisamountnow ) ) {\n failf ( data , \"Could only read %\" CURL_FORMAT_CURL_OFF_T \" bytes from the input\" , passed ) ;\n return CURLE_READ_ERROR ;\n }\n }\n while ( passed < data -> state . resume_from ) ;\n }\n }\n if ( data -> state . infilesize > 0 ) {\n data -> state . infilesize -= data -> state . resume_from ;\n if ( data -> state . infilesize <= 0 ) {\n failf ( data , \"File already completely uploaded\" ) ;\n return CURLE_PARTIAL_FILE ;\n }\n }\n }\n }\n if ( data -> state . use_range ) {\n if ( ( ( httpreq == HTTPREQ_GET ) || ( httpreq == HTTPREQ_HEAD ) ) && ! Curl_checkheaders ( conn , \"Range:\" ) ) {\n free ( conn -> allocptr . rangeline ) ;\n conn -> allocptr . rangeline = aprintf ( \"Range: bytes=%s\\r\\n\" , data -> state . range ) ;\n }\n else if ( ( httpreq != HTTPREQ_GET ) && ! Curl_checkheaders ( conn , \"Content-Range:\" ) ) {\n free ( conn -> allocptr . rangeline ) ;\n if ( data -> set . set_resume_from < 0 ) {\n conn -> allocptr . rangeline = aprintf ( \"Content-Range: bytes 0-%\" CURL_FORMAT_CURL_OFF_T \"/%\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\" , data -> state . infilesize - 1 , data -> state . infilesize ) ;\n }\n else if ( data -> state . resume_from ) {\n curl_off_t total_expected_size = data -> state . resume_from + data -> state . infilesize ;\n conn -> allocptr . rangeline = aprintf ( \"Content-Range: bytes %s%\" CURL_FORMAT_CURL_OFF_T \"/%\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\" , data -> state . range , total_expected_size - 1 , total_expected_size ) ;\n }\n else {\n conn -> allocptr . rangeline = aprintf ( \"Content-Range: bytes %s/%\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\" , data -> state . range , data -> state . infilesize ) ;\n }\n if ( ! conn -> allocptr . rangeline ) return CURLE_OUT_OF_MEMORY ;\n }\n }\n httpstring = use_http_1_1plus ( data , conn ) ? \"1.1\" : \"1.0\" ;\n req_buffer = Curl_add_buffer_init ( ) ;\n if ( ! req_buffer ) return CURLE_OUT_OF_MEMORY ;\n result = Curl_add_bufferf ( req_buffer , \"%s \" , request ) ;\n if ( result ) return result ;\n if ( paste_ftp_userpwd ) result = Curl_add_bufferf ( req_buffer , \"ftp://%s:%s@%s\" , conn -> user , conn -> passwd , ppath + sizeof ( \"ftp://\" ) - 1 ) ;\n else result = Curl_add_buffer ( req_buffer , ppath , strlen ( ppath ) ) ;\n if ( result ) return result ;\n result = Curl_add_bufferf ( req_buffer , \"%s\" \" HTTP/%s\\r\\n\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" , ftp_typecode , httpstring , ( conn -> allocptr . host ? conn -> allocptr . host : \"\" ) , conn -> allocptr . proxyuserpwd ? conn -> allocptr . proxyuserpwd : \"\" , conn -> allocptr . userpwd ? conn -> allocptr . userpwd : \"\" , ( data -> state . use_range && conn -> allocptr . rangeline ) ? conn -> allocptr . rangeline : \"\" , ( data -> set . str [ STRING_USERAGENT ] && * data -> set . str [ STRING_USERAGENT ] && conn -> allocptr . uagent ) ? conn -> allocptr . uagent : \"\" , http -> p_accept ? http -> p_accept : \"\" , conn -> allocptr . te ? conn -> allocptr . te : \"\" , ( data -> set . str [ STRING_ENCODING ] && * data -> set . str [ STRING_ENCODING ] && conn -> allocptr . accept_encoding ) ? conn -> allocptr . accept_encoding : \"\" , ( data -> change . referer && conn -> allocptr . ref ) ? conn -> allocptr . ref : \"\" , ( conn -> bits . httpproxy && ! conn -> bits . tunnel_proxy && ! Curl_checkProxyheaders ( conn , \"Proxy-Connection:\" ) ) ? \"Proxy-Connection: Keep-Alive\\r\\n\" : \"\" , te ) ;\n Curl_safefree ( conn -> allocptr . userpwd ) ;\n switch ( data -> state . authproxy . picked ) {\n case CURLAUTH_NEGOTIATE : case CURLAUTH_NTLM : case CURLAUTH_NTLM_WB : Curl_safefree ( conn -> allocptr . proxyuserpwd ) ;\n break ;\n }\n if ( result ) return result ;\n if ( ! ( conn -> handler -> flags & PROTOPT_SSL ) && conn -> httpversion != 20 && ( data -> set . httpversion == CURL_HTTP_VERSION_2 ) ) {\n result = Curl_http2_request_upgrade ( req_buffer , conn ) ;\n if ( result ) return result ;\n }\n # if ! defined ( CURL_DISABLE_COOKIES ) if ( data -> cookies || addcookies ) {\n struct Cookie * co = NULL ;\n int count = 0 ;\n if ( data -> cookies ) {\n Curl_share_lock ( data , CURL_LOCK_DATA_COOKIE , CURL_LOCK_ACCESS_SINGLE ) ;\n co = Curl_cookie_getlist ( data -> cookies , conn -> allocptr . cookiehost ? conn -> allocptr . cookiehost : host , data -> state . path , ( conn -> handler -> protocol & CURLPROTO_HTTPS ) ? TRUE : FALSE ) ;\n Curl_share_unlock ( data , CURL_LOCK_DATA_COOKIE ) ;\n }\n if ( co ) {\n struct Cookie * store = co ;\n while ( co ) {\n if ( co -> value ) {\n if ( 0 == count ) {\n result = Curl_add_bufferf ( req_buffer , \"Cookie: \" ) ;\n if ( result ) break ;\n }\n result = Curl_add_bufferf ( req_buffer , \"%s%s=%s\" , count ? \";\n \" : \"\" , co -> name , co -> value ) ;\n if ( result ) break ;\n count ++ ;\n }\n co = co -> next ;\n }\n Curl_cookie_freelist ( store ) ;\n }\n if ( addcookies && ! result ) {\n if ( ! count ) result = Curl_add_bufferf ( req_buffer , \"Cookie: \" ) ;\n if ( ! result ) {\n result = Curl_add_bufferf ( req_buffer , \"%s%s\" , count ? \";\n \" : \"\" , addcookies ) ;\n count ++ ;\n }\n }\n if ( count && ! result ) result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n if ( result ) return result ;\n }\n # endif result = Curl_add_timecondition ( data , req_buffer ) ;\n if ( result ) return result ;\n result = Curl_add_custom_headers ( conn , FALSE , req_buffer ) ;\n if ( result ) return result ;\n http -> postdata = NULL ;\n Curl_pgrsSetUploadSize ( data , - 1 ) ;\n switch ( httpreq ) {\n case HTTPREQ_POST_FORM : if ( ! http -> sendit || conn -> bits . authneg ) {\n result = Curl_add_bufferf ( req_buffer , \"Content-Length: 0\\r\\n\\r\\n\" ) ;\n if ( result ) return result ;\n result = Curl_add_buffer_send ( req_buffer , conn , & data -> info . request_size , 0 , FIRSTSOCKET ) ;\n if ( result ) failf ( data , \"Failed sending POST request\" ) ;\n else Curl_setup_transfer ( conn , FIRSTSOCKET , - 1 , TRUE , & http -> readbytecount , - 1 , NULL ) ;\n break ;\n }\n if ( Curl_FormInit ( & http -> form , http -> sendit ) ) {\n failf ( data , \"Internal HTTP POST error!\" ) ;\n return CURLE_HTTP_POST_ERROR ;\n }\n http -> form . fread_func = data -> state . fread_func ;\n data -> state . fread_func = ( curl_read_callback ) Curl_FormReader ;\n data -> state . in = & http -> form ;\n http -> sending = HTTPSEND_BODY ;\n if ( ! data -> req . upload_chunky && ! Curl_checkheaders ( conn , \"Content-Length:\" ) ) {\n result = Curl_add_bufferf ( req_buffer , \"Content-Length: %\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\" , http -> postsize ) ;\n if ( result ) return result ;\n }\n result = expect100 ( data , conn , req_buffer ) ;\n if ( result ) return result ;\n {\n char * contentType ;\n size_t linelength = 0 ;\n contentType = Curl_formpostheader ( ( void * ) & http -> form , & linelength ) ;\n if ( ! contentType ) {\n failf ( data , \"Could not get Content-Type header line!\" ) ;\n return CURLE_HTTP_POST_ERROR ;\n }\n result = Curl_add_buffer ( req_buffer , contentType , linelength ) ;\n if ( result ) return result ;\n }\n result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n if ( result ) return result ;\n Curl_pgrsSetUploadSize ( data , http -> postsize ) ;\n result = Curl_add_buffer_send ( req_buffer , conn , & data -> info . request_size , 0 , FIRSTSOCKET ) ;\n if ( result ) failf ( data , \"Failed sending POST request\" ) ;\n else Curl_setup_transfer ( conn , FIRSTSOCKET , - 1 , TRUE , & http -> readbytecount , FIRSTSOCKET , & http -> writebytecount ) ;\n if ( result ) {\n Curl_formclean ( & http -> sendit ) ;\n return result ;\n }\n result = Curl_convert_form ( data , http -> sendit ) ;\n if ( result ) {\n Curl_formclean ( & http -> sendit ) ;\n return result ;\n }\n break ;\n case HTTPREQ_PUT : if ( conn -> bits . authneg ) postsize = 0 ;\n else postsize = data -> state . infilesize ;\n if ( ( postsize != - 1 ) && ! data -> req . upload_chunky && ! Curl_checkheaders ( conn , \"Content-Length:\" ) ) {\n result = Curl_add_bufferf ( req_buffer , \"Content-Length: %\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\" , postsize ) ;\n if ( result ) return result ;\n }\n if ( postsize != 0 ) {\n result = expect100 ( data , conn , req_buffer ) ;\n if ( result ) return result ;\n }\n result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n if ( result ) return result ;\n Curl_pgrsSetUploadSize ( data , postsize ) ;\n result = Curl_add_buffer_send ( req_buffer , conn , & data -> info . request_size , 0 , FIRSTSOCKET ) ;\n if ( result ) failf ( data , \"Failed sending PUT request\" ) ;\n else Curl_setup_transfer ( conn , FIRSTSOCKET , - 1 , TRUE , & http -> readbytecount , postsize ? FIRSTSOCKET : - 1 , postsize ? & http -> writebytecount : NULL ) ;\n if ( result ) return result ;\n break ;\n case HTTPREQ_POST : if ( conn -> bits . authneg ) postsize = 0 ;\n else {\n postsize = ( data -> state . infilesize != - 1 ) ? data -> state . infilesize : ( data -> set . postfields ? ( curl_off_t ) strlen ( data -> set . postfields ) : - 1 ) ;\n }\n if ( ( postsize != - 1 ) && ! data -> req . upload_chunky && ! Curl_checkheaders ( conn , \"Content-Length:\" ) ) {\n result = Curl_add_bufferf ( req_buffer , \"Content-Length: %\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\" , postsize ) ;\n if ( result ) return result ;\n }\n if ( ! Curl_checkheaders ( conn , \"Content-Type:\" ) ) {\n result = Curl_add_bufferf ( req_buffer , \"Content-Type: application/\" \"x-www-form-urlencoded\\r\\n\" ) ;\n if ( result ) return result ;\n }\n ptr = Curl_checkheaders ( conn , \"Expect:\" ) ;\n if ( ptr ) {\n data -> state . expect100header = Curl_compareheader ( ptr , \"Expect:\" , \"100-continue\" ) ;\n }\n else if ( postsize > TINY_INITIAL_POST_SIZE || postsize < 0 ) {\n result = expect100 ( data , conn , req_buffer ) ;\n if ( result ) return result ;\n }\n else data -> state . expect100header = FALSE ;\n if ( data -> set . postfields ) {\n if ( conn -> httpversion != 20 && ! data -> state . expect100header && ( postsize < MAX_INITIAL_POST_SIZE ) ) {\n result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n if ( result ) return result ;\n if ( ! data -> req . upload_chunky ) {\n result = Curl_add_buffer ( req_buffer , data -> set . postfields , ( size_t ) postsize ) ;\n included_body = postsize ;\n }\n else {\n if ( postsize ) {\n result = Curl_add_bufferf ( req_buffer , \"%x\\r\\n\" , ( int ) postsize ) ;\n if ( ! result ) {\n result = Curl_add_buffer ( req_buffer , data -> set . postfields , ( size_t ) postsize ) ;\n if ( ! result ) result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n included_body = postsize + 2 ;\n }\n }\n if ( ! result ) result = Curl_add_buffer ( req_buffer , \"\\x30\\x0d\\x0a\\x0d\\x0a\" , 5 ) ;\n included_body += 5 ;\n }\n if ( result ) return result ;\n Curl_pgrsSetUploadSize ( data , postsize ) ;\n }\n else {\n http -> postsize = postsize ;\n http -> postdata = data -> set . postfields ;\n http -> sending = HTTPSEND_BODY ;\n data -> state . fread_func = ( curl_read_callback ) readmoredata ;\n data -> state . in = ( void * ) conn ;\n Curl_pgrsSetUploadSize ( data , http -> postsize ) ;\n result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n if ( result ) return result ;\n }\n }\n else {\n result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n if ( result ) return result ;\n if ( data -> req . upload_chunky && conn -> bits . authneg ) {\n result = Curl_add_buffer ( req_buffer , \"\\x30\\x0d\\x0a\\x0d\\x0a\" , 5 ) ;\n if ( result ) return result ;\n }\n else if ( data -> state . infilesize ) {\n Curl_pgrsSetUploadSize ( data , postsize ? postsize : - 1 ) ;\n if ( ! conn -> bits . authneg ) {\n http -> postdata = ( char * ) & http -> postdata ;\n http -> postsize = postsize ;\n }\n }\n }\n result = Curl_add_buffer_send ( req_buffer , conn , & data -> info . request_size , ( size_t ) included_body , FIRSTSOCKET ) ;\n if ( result ) failf ( data , \"Failed sending HTTP POST request\" ) ;\n else Curl_setup_transfer ( conn , FIRSTSOCKET , - 1 , TRUE , & http -> readbytecount , http -> postdata ? FIRSTSOCKET : - 1 , http -> postdata ? & http -> writebytecount : NULL ) ;\n break ;\n default : result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n if ( result ) return result ;\n result = Curl_add_buffer_send ( req_buffer , conn , & data -> info . request_size , 0 , FIRSTSOCKET ) ;\n if ( result ) failf ( data , \"Failed sending HTTP request\" ) ;\n else Curl_setup_transfer ( conn , FIRSTSOCKET , - 1 , TRUE , & http -> readbytecount , http -> postdata ? FIRSTSOCKET : - 1 , http -> postdata ? & http -> writebytecount : NULL ) ;\n }\n if ( result ) return result ;\n if ( http -> writebytecount ) {\n Curl_pgrsSetUploadCounter ( data , http -> writebytecount ) ;\n if ( Curl_pgrsUpdate ( conn ) ) result = CURLE_ABORTED_BY_CALLBACK ;\n if ( http -> writebytecount >= postsize ) {\n infof ( data , \"upload completely sent off: %\" CURL_FORMAT_CURL_OFF_T \" out of %\" CURL_FORMAT_CURL_OFF_T \" bytes\\n\" , http -> writebytecount , postsize ) ;\n data -> req . upload_done = TRUE ;\n data -> req . keepon &= ~ KEEP_SEND ;\n data -> req . exp100 = EXP100_SEND_DATA ;\n }\n }\n if ( ( conn -> httpversion == 20 ) && data -> req . upload_chunky ) data -> req . upload_chunky = FALSE ;\n return result ;\n }", "hash": -7136186224744987223, "project": "debian", "size": 483, "target": 0, "idx": 15164}
{"code": "static int nb_add_value_list ( lcc_network_buffer_t * nb , const lcc_value_list_t * vl ) {\n char * buffer = nb -> ptr ;\n size_t buffer_size = nb -> free ;\n const lcc_identifier_t * ident_src ;\n lcc_identifier_t * ident_dst ;\n ident_src = & vl -> identifier ;\n ident_dst = & nb -> state . identifier ;\n if ( strcmp ( ident_dst -> host , ident_src -> host ) != 0 ) {\n if ( nb_add_string ( & buffer , & buffer_size , TYPE_HOST , ident_src -> host , strlen ( ident_src -> host ) ) != 0 ) return ( - 1 ) ;\n SSTRNCPY ( ident_dst -> host , ident_src -> host , sizeof ( ident_dst -> host ) ) ;\n }\n if ( strcmp ( ident_dst -> plugin , ident_src -> plugin ) != 0 ) {\n if ( nb_add_string ( & buffer , & buffer_size , TYPE_PLUGIN , ident_src -> plugin , strlen ( ident_src -> plugin ) ) != 0 ) return ( - 1 ) ;\n SSTRNCPY ( ident_dst -> plugin , ident_src -> plugin , sizeof ( ident_dst -> plugin ) ) ;\n }\n if ( strcmp ( ident_dst -> plugin_instance , ident_src -> plugin_instance ) != 0 ) {\n if ( nb_add_string ( & buffer , & buffer_size , TYPE_PLUGIN_INSTANCE , ident_src -> plugin_instance , strlen ( ident_src -> plugin_instance ) ) != 0 ) return ( - 1 ) ;\n SSTRNCPY ( ident_dst -> plugin_instance , ident_src -> plugin_instance , sizeof ( ident_dst -> plugin_instance ) ) ;\n }\n if ( strcmp ( ident_dst -> type , ident_src -> type ) != 0 ) {\n if ( nb_add_string ( & buffer , & buffer_size , TYPE_TYPE , ident_src -> type , strlen ( ident_src -> type ) ) != 0 ) return ( - 1 ) ;\n SSTRNCPY ( ident_dst -> type , ident_src -> type , sizeof ( ident_dst -> type ) ) ;\n }\n if ( strcmp ( ident_dst -> type_instance , ident_src -> type_instance ) != 0 ) {\n if ( nb_add_string ( & buffer , & buffer_size , TYPE_TYPE_INSTANCE , ident_src -> type_instance , strlen ( ident_src -> type_instance ) ) != 0 ) return ( - 1 ) ;\n SSTRNCPY ( ident_dst -> type_instance , ident_src -> type_instance , sizeof ( ident_dst -> type_instance ) ) ;\n }\n if ( nb -> state . time != vl -> time ) {\n if ( nb_add_time ( & buffer , & buffer_size , TYPE_TIME_HR , vl -> time ) ) return ( - 1 ) ;\n nb -> state . time = vl -> time ;\n }\n if ( nb -> state . interval != vl -> interval ) {\n if ( nb_add_time ( & buffer , & buffer_size , TYPE_INTERVAL_HR , vl -> interval ) ) return ( - 1 ) ;\n nb -> state . interval = vl -> interval ;\n }\n if ( nb_add_values ( & buffer , & buffer_size , vl ) != 0 ) return ( - 1 ) ;\n nb -> ptr = buffer ;\n nb -> free = buffer_size ;\n return ( 0 ) ;\n }", "hash": 8281630545066492937, "project": "debian", "size": 40, "target": 0, "idx": 15197}
{"code": "static void clean_index ( AVFormatContext * s ) {\n int i ;\n int64_t j ;\n for ( i = 0 ;\n i < s -> nb_streams ;\n i ++ ) {\n AVStream * st = s -> streams [ i ] ;\n AVIStream * ast = st -> priv_data ;\n int n = st -> nb_index_entries ;\n int max = ast -> sample_size ;\n int64_t pos , size , ts ;\n if ( n != 1 || ast -> sample_size == 0 ) continue ;\n while ( max < 1024 ) max += max ;\n pos = st -> index_entries [ 0 ] . pos ;\n size = st -> index_entries [ 0 ] . size ;\n ts = st -> index_entries [ 0 ] . timestamp ;\n for ( j = 0 ;\n j < size ;\n j += max ) av_add_index_entry ( st , pos + j , ts + j , FFMIN ( max , size - j ) , 0 , AVINDEX_KEYFRAME ) ;\n }\n }", "hash": -4534372572324105488, "project": "debian", "size": 21, "target": 0, "idx": 15212}
{"code": "static void avi_metadata_creation_time ( AVDictionary * * metadata , char * date ) {\n char month [ 4 ] , time [ 9 ] , buffer [ 64 ] ;\n int i , day , year ;\n if ( sscanf ( date , \"%*3s%*[ ]%3s%*[ ]%2d%*[ ]%8s%*[ ]%4d\" , month , & day , time , & year ) == 4 ) {\n for ( i = 0 ;\n i < 12 ;\n i ++ ) if ( ! av_strcasecmp ( month , months [ i ] ) ) {\n snprintf ( buffer , sizeof ( buffer ) , \"%.4d-%.2d-%.2d %s\" , year , i + 1 , day , time ) ;\n av_dict_set ( metadata , \"creation_time\" , buffer , 0 ) ;\n }\n }\n else if ( date [ 4 ] == '/' && date [ 7 ] == '/' ) {\n date [ 4 ] = date [ 7 ] = '-' ;\n av_dict_set ( metadata , \"creation_time\" , date , 0 ) ;\n }\n }", "hash": -4534372572324105488, "project": "debian", "size": 16, "target": 0, "idx": 15214}
{"code": "static int avi_probe ( AVProbeData * p ) {\n int i ;\n for ( i = 0 ;\n avi_headers [ i ] [ 0 ] ;\n i ++ ) if ( AV_RL32 ( p -> buf ) == AV_RL32 ( avi_headers [ i ] ) && AV_RL32 ( p -> buf + 8 ) == AV_RL32 ( avi_headers [ i ] + 4 ) ) return AVPROBE_SCORE_MAX ;\n return 0 ;\n }", "hash": -4534372572324105488, "project": "debian", "size": 7, "target": 0, "idx": 15221}
{"code": "static AVStream * get_subtitle_pkt ( AVFormatContext * s , AVStream * next_st , AVPacket * pkt ) {\n AVIStream * ast , * next_ast = next_st -> priv_data ;\n int64_t ts , next_ts , ts_min = INT64_MAX ;\n AVStream * st , * sub_st = NULL ;\n int i ;\n next_ts = av_rescale_q ( next_ast -> frame_offset , next_st -> time_base , AV_TIME_BASE_Q ) ;\n for ( i = 0 ;\n i < s -> nb_streams ;\n i ++ ) {\n st = s -> streams [ i ] ;\n ast = st -> priv_data ;\n if ( st -> discard < AVDISCARD_ALL && ast && ast -> sub_pkt . data ) {\n ts = av_rescale_q ( ast -> sub_pkt . dts , st -> time_base , AV_TIME_BASE_Q ) ;\n if ( ts <= next_ts && ts < ts_min ) {\n ts_min = ts ;\n sub_st = st ;\n }\n }\n }\n if ( sub_st ) {\n ast = sub_st -> priv_data ;\n * pkt = ast -> sub_pkt ;\n pkt -> stream_index = sub_st -> index ;\n if ( ff_read_packet ( ast -> sub_ctx , & ast -> sub_pkt ) < 0 ) ast -> sub_pkt . data = NULL ;\n }\n return sub_st ;\n }", "hash": -4534372572324105488, "project": "debian", "size": 27, "target": 0, "idx": 15225}
{"code": "static void trim_trailing_spaces ( char * s ) {\n char * p ;\n p = s ;\n while ( * p != '\\0' ) p ++ ;\n if ( p == s ) return ;\n p -- ;\n while ( p >= s && * p == ' ' ) * p -- = '\\0' ;\n }", "hash": -4525874104093394205, "project": "debian", "size": 8, "target": 0, "idx": 15235}
{"code": "static OFCondition makeLengthError ( const char * pdu , unsigned long bufSize , unsigned long minSize , unsigned long length ) {\n OFStringStream stream ;\n stream << \"DUL Illegal \" << pdu << \". Got \" << bufSize << \" bytes of data\" ;\n if ( length != 0 ) stream << \" with a length field of \" << length << \" (data before length field is not included in length field)\" ;\n if ( minSize != 0 ) stream << \". The minimum allowed size is \" << minSize ;\n stream << \".\" << OFStringStream_ends ;\n OFCondition ret ;\n OFSTRINGSTREAM_GETSTR ( stream , tmpString ) ret = makeDcmnetCondition ( DULC_ILLEGALPDULENGTH , OF_error , tmpString ) ;\n OFSTRINGSTREAM_FREESTR ( tmpString ) return ret ;\n }", "hash": -4525874104093394205, "project": "debian", "size": 10, "target": 0, "idx": 15242}
{"code": "ECPKPARAMETERS * ec_asn1_group2pkparameters ( const EC_GROUP * group , ECPKPARAMETERS * params ) {\n int ok = 1 , tmp ;\n ECPKPARAMETERS * ret = params ;\n if ( ret == NULL ) {\n if ( ( ret = ECPKPARAMETERS_new ( ) ) == NULL ) {\n ECerr ( EC_F_EC_ASN1_GROUP2PKPARAMETERS , ERR_R_MALLOC_FAILURE ) ;\n return NULL ;\n }\n }\n else {\n if ( ret -> type == 0 && ret -> value . named_curve ) ASN1_OBJECT_free ( ret -> value . named_curve ) ;\n else if ( ret -> type == 1 && ret -> value . parameters ) ECPARAMETERS_free ( ret -> value . parameters ) ;\n }\n if ( EC_GROUP_get_asn1_flag ( group ) ) {\n tmp = EC_GROUP_get_curve_name ( group ) ;\n if ( tmp ) {\n ret -> type = 0 ;\n if ( ( ret -> value . named_curve = OBJ_nid2obj ( tmp ) ) == NULL ) ok = 0 ;\n }\n else ok = 0 ;\n }\n else {\n ret -> type = 1 ;\n if ( ( ret -> value . parameters = ec_asn1_group2parameters ( group , NULL ) ) == NULL ) ok = 0 ;\n }\n if ( ! ok ) {\n ECPKPARAMETERS_free ( ret ) ;\n return NULL ;\n }\n return ret ;\n }", "hash": -6359684484462176044, "project": "debian", "size": 31, "target": 0, "idx": 15296}
{"code": "EC_GROUP * d2i_ECPKParameters ( EC_GROUP * * a , const unsigned char * * in , long len ) {\n EC_GROUP * group = NULL ;\n ECPKPARAMETERS * params = NULL ;\n if ( ( params = d2i_ECPKPARAMETERS ( NULL , in , len ) ) == NULL ) {\n ECerr ( EC_F_D2I_ECPKPARAMETERS , EC_R_D2I_ECPKPARAMETERS_FAILURE ) ;\n ECPKPARAMETERS_free ( params ) ;\n return NULL ;\n }\n if ( ( group = ec_asn1_pkparameters2group ( params ) ) == NULL ) {\n ECerr ( EC_F_D2I_ECPKPARAMETERS , EC_R_PKPARAMETERS2GROUP_FAILURE ) ;\n return NULL ;\n }\n if ( a && * a ) EC_GROUP_clear_free ( * a ) ;\n if ( a ) * a = group ;\n ECPKPARAMETERS_free ( params ) ;\n return ( group ) ;\n }", "hash": -6359684484462176044, "project": "debian", "size": 17, "target": 0, "idx": 15299}
{"code": "static int dissect_rsl_ie_rel_mode ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_tree * ie_tree ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_REL_MODE ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 4 , ett_ie_rel_mode , NULL , \"Release Mode IE \" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( ie_tree , hf_rsl_rel_mode , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n return offset ;\n }", "hash": -5082285935423529157, "project": "debian", "size": 14, "target": 0, "idx": 15318}
{"code": "static int dissect_rsl_ie_full_bcch_inf ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_item * ti ;\n proto_tree * ie_tree ;\n tvbuff_t * next_tvb ;\n guint16 length ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_FULL_BCCH_INF ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_ie_full_bcch_inf , & ti , \"Full BCCH Information IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n length = tvb_get_guint8 ( tvb , offset ) ;\n proto_item_set_len ( ti , length + 2 ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( ie_tree , hf_rsl_layer_3_message , tvb , offset , length , ENC_NA ) ;\n next_tvb = tvb_new_subset_length ( tvb , offset , length ) ;\n call_dissector ( gsm_a_ccch_handle , next_tvb , pinfo , top_tree ) ;\n offset = offset + length ;\n return offset ;\n }", "hash": -5082285935423529157, "project": "debian", "size": 23, "target": 0, "idx": 15319}
{"code": "void proto_register_rsl ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_rsl_msg_dsc , {\n \"Message discriminator\" , \"gsm_abis_rsl.msg_dsc\" , FT_UINT8 , BASE_DEC , VALS ( rsl_msg_disc_vals ) , 0xfe , NULL , HFILL }\n }\n , {\n & hf_rsl_T_bit , {\n \"T bit\" , \"gsm_abis_rsl.T_bit\" , FT_BOOLEAN , 8 , TFS ( & rsl_t_bit_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_msg_type , {\n \"Message type\" , \"gsm_abis_rsl.msg_type\" , FT_UINT8 , BASE_HEX_DEC | BASE_EXT_STRING , & rsl_msg_type_vals_ext , 0x7f , NULL , HFILL }\n }\n , {\n & hf_rsl_ie_id , {\n \"Element identifier\" , \"gsm_abis_rsl.ie_id\" , FT_UINT8 , BASE_HEX_DEC | BASE_EXT_STRING , & rsl_ie_type_vals_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_ie_length , {\n \"Length\" , \"gsm_abis_rsl.ie_length\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_ch_no_Cbits , {\n \"C-bits\" , \"gsm_abis_rsl.ch_no_Cbits\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & rsl_ch_no_Cbits_vals_ext , 0xf8 , NULL , HFILL }\n }\n , {\n & hf_rsl_ch_no_TN , {\n \"Time slot number (TN)\" , \"gsm_abis_rsl.ch_no_TN\" , FT_UINT8 , BASE_DEC , NULL , 0x07 , NULL , HFILL }\n }\n , {\n & hf_rsl_rtd , {\n \"Round Trip Delay (RTD)\" , \"gsm_abis_rsl.rtd\" , FT_UINT8 , BASE_DEC , NULL , 0xfe , NULL , HFILL }\n }\n , {\n & hf_rsl_delay_ind , {\n \"Delay IND\" , \"gsm_abis_rsl.delay_ind\" , FT_UINT8 , BASE_DEC , VALS ( rsl_delay_ind_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_tfo , {\n \"TFO\" , \"gsm_abis_rsl.tfo\" , FT_BOOLEAN , 8 , TFS ( & rsl_tfo_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_req_ref_ra , {\n \"Random Access Information (RA)\" , \"gsm_abis_rsl.req_ref_ra\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_req_ref_T1prim , {\n \"T1'\" , \"gsm_abis_rsl.req_ref_T1prim\" , FT_UINT8 , BASE_DEC , NULL , 0xf8 , NULL , HFILL }\n }\n , {\n & hf_rsl_req_ref_T3 , {\n \"T3\" , \"gsm_abis_rsl.req_ref_T3\" , FT_UINT16 , BASE_DEC , NULL , 0x07e0 , NULL , HFILL }\n }\n , {\n & hf_rsl_req_ref_T2 , {\n \"T2\" , \"gsm_abis_rsl.req_ref_T2\" , FT_UINT8 , BASE_DEC , NULL , 0x1f , NULL , HFILL }\n }\n , {\n & hf_rsl_timing_adv , {\n \"Timing Advance\" , \"gsm_abis_rsl.timing_adv\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_ho_ref , {\n \"Hand-over reference\" , \"gsm_abis_rsl.ho_ref\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_l1inf_power_lev , {\n \"MS power level\" , \"gsm_abis_rsl.ms_power_lev\" , FT_UINT8 , BASE_DEC , NULL , 0xf8 , NULL , HFILL }\n }\n , {\n & hf_rsl_l1inf_fpc , {\n \"FPC/EPC\" , \"gsm_abis_rsl.ms_fpc\" , FT_BOOLEAN , 8 , TFS ( & rsl_ms_fpc_epc_mode_vals ) , 0x04 , NULL , HFILL }\n }\n , {\n & hf_rsl_ms_power_lev , {\n \"MS power level\" , \"gsm_abis_rsl.ms_power_lev\" , FT_UINT8 , BASE_DEC , NULL , 0x1f , NULL , HFILL }\n }\n , {\n & hf_rsl_ms_fpc , {\n \"FPC/EPC\" , \"gsm_abis_rsl.ms_fpc\" , FT_BOOLEAN , 8 , TFS ( & rsl_ms_fpc_epc_mode_vals ) , 0x20 , NULL , HFILL }\n }\n , {\n & hf_rsl_act_timing_adv , {\n \"Actual Timing Advance\" , \"gsm_abis_rsl.act_timing_adv\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_dtxd , {\n \"DTXd\" , \"gsm_abis_rsl.dtxd\" , FT_BOOLEAN , 8 , TFS ( & rsl_dtxd_vals ) , 0x40 , NULL , HFILL }\n }\n , {\n & hf_rsl_rxlev_full_up , {\n \"RXLEV.FULL.up\" , \"gsm_abis_rsl.rxlev_full_up\" , FT_UINT8 , BASE_DEC , NULL , 0x3f , NULL , HFILL }\n }\n , {\n & hf_rsl_rxlev_sub_up , {\n \"RXLEV.SUB.up\" , \"gsm_abis_rsl.rxlev_sub_up\" , FT_UINT8 , BASE_DEC , NULL , 0x3f , NULL , HFILL }\n }\n , {\n & hf_rsl_rxqual_full_up , {\n \"RXQUAL.FULL.up\" , \"gsm_abis_rsl.rxqual_full_up\" , FT_UINT8 , BASE_DEC , NULL , 0x38 , NULL , HFILL }\n }\n , {\n & hf_rsl_rxqual_sub_up , {\n \"RXQUAL.SUB.up\" , \"gsm_abis_rsl.rxqual_sub_up\" , FT_UINT8 , BASE_DEC , NULL , 0x07 , NULL , HFILL }\n }\n , {\n & hf_rsl_acc_delay , {\n \"Access Delay\" , \"gsm_abis_rsl.acc_del\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_rach_slot_cnt , {\n \"RACH Slot Count\" , \"gsm_abis_rsl.rach_slot_cnt\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_rach_busy_cnt , {\n \"RACH Busy Count\" , \"gsm_abis_rsl.rach_busy_cnt\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_rach_acc_cnt , {\n \"RACH Access Count\" , \"gsm_abis_rsl.rach_acc_cnt\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_phy_ctx , {\n \"Physical Context\" , \"gsm_abis_rsl.phy_ctx\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_na , {\n \"Not applicable (NA)\" , \"gsm_abis_rsl.na\" , FT_BOOLEAN , 8 , TFS ( & rsl_na_vals ) , 0x20 , NULL , HFILL }\n }\n , {\n & hf_rsl_ch_type , {\n \"channel type\" , \"gsm_abis_rsl.ch_type\" , FT_UINT8 , BASE_DEC , VALS ( rsl_ch_type_vals ) , 0xc0 , NULL , HFILL }\n }\n , {\n & hf_rsl_prio , {\n \"Priority\" , \"gsm_abis_rsl.prio\" , FT_UINT8 , BASE_DEC , VALS ( rsl_prio_vals ) , 0x18 , NULL , HFILL }\n }\n , {\n & hf_rsl_sapi , {\n \"SAPI\" , \"gsm_abis_rsl.sapi\" , FT_UINT8 , BASE_DEC , NULL , 0x07 , NULL , HFILL }\n }\n , {\n & hf_rsl_rbit , {\n \"R\" , \"gsm_abis_rsl.rbit\" , FT_BOOLEAN , 8 , TFS ( & rsl_rbit_vals ) , 0x80 , NULL , HFILL }\n }\n , {\n & hf_rsl_a3a2 , {\n \"A3A2\" , \"gsm_abis_rsl.a3a2\" , FT_UINT8 , BASE_DEC , VALS ( rsl_a3a2_vals ) , 0x06 , NULL , HFILL }\n }\n , {\n & hf_rsl_a1_0 , {\n \"A1\" , \"gsm_abis_rsl.a1_0\" , FT_BOOLEAN , 8 , TFS ( & rsl_a1_0_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_a1_1 , {\n \"A1\" , \"gsm_abis_rsl.a1_1\" , FT_BOOLEAN , 8 , TFS ( & rsl_a1_1_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_a1_2 , {\n \"A1\" , \"gsm_abis_rsl.a2_0\" , FT_BOOLEAN , 8 , TFS ( & rsl_a1_2_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_epc_mode , {\n \"EPC mode\" , \"gsm_abis_rsl.epc_mode\" , FT_BOOLEAN , 8 , TFS ( & rsl_epc_mode_vals ) , 0x20 , NULL , HFILL }\n }\n , {\n & hf_rsl_bs_fpc_epc_mode , {\n \"FPC-EPC mode\" , \"gsm_abis_rsl.fpc_epc_mode\" , FT_BOOLEAN , 8 , TFS ( & rsl_fpc_epc_mode_vals ) , 0x10 , NULL , HFILL }\n }\n , {\n & hf_rsl_bs_power , {\n \"Power Level\" , \"gsm_abis_rsl.bs_power\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & rsl_rlm_bs_power_vals_ext , 0x0f , NULL , HFILL }\n }\n , {\n & hf_rsl_cm_dtxd , {\n \"DTXd\" , \"gsm_abis_rsl.cm_dtxd\" , FT_BOOLEAN , 8 , TFS ( & rsl_dtx_vals ) , 0x02 , NULL , HFILL }\n }\n , {\n & hf_rsl_cm_dtxu , {\n \"DTXu\" , \"gsm_abis_rsl.cm_dtxu\" , FT_BOOLEAN , 8 , TFS ( & rsl_dtx_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_speech_or_data , {\n \"Speech or data indicator\" , \"gsm_abis_rsl.speech_or_data\" , FT_UINT8 , BASE_DEC , VALS ( rsl_speech_or_data_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_ch_rate_and_type , {\n \"Channel rate and type\" , \"gsm_abis_rsl.ch_rate_and_type\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & rsl_ch_rate_and_type_vals_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_speech_coding_alg , {\n \"Speech coding algorithm\" , \"gsm_abis_rsl.speech_coding_alg\" , FT_UINT8 , BASE_DEC , VALS ( rsl_speech_coding_alg_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_t_nt_bit , {\n \"Transparent indication\" , \"gsm_abis_rsl.t_nt_bit\" , FT_BOOLEAN , 8 , TFS ( & t_nt_bit_vals ) , 0x40 , NULL , HFILL }\n }\n , {\n & hf_rsl_ra_if_data_rte , {\n \"Radio interface data rate\" , \"gsm_abis_rsl.ra_if_data_rte\" , FT_UINT8 , BASE_DEC , VALS ( rsl_ra_if_data_rte_vals ) , 0x3f , NULL , HFILL }\n }\n , {\n & hf_rsl_data_rte , {\n \"Data rate\" , \"gsm_abis_rsl.data_rte\" , FT_UINT8 , BASE_DEC , VALS ( rsl_ra_if_data_rte_vals ) , 0x3f , NULL , HFILL }\n }\n , {\n & hf_rsl_alg_id , {\n \"Algorithm Identifier\" , \"gsm_abis_rsl.alg_id\" , FT_UINT8 , BASE_DEC , VALS ( rsl_algorithm_id_vals ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_key , {\n \"KEY\" , \"gsm_abis_rsl.key\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_cause , {\n \"Cause\" , \"gsm_abis_rsl.cause\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & rsl_rlm_cause_vals_ext , 0x7f , NULL , HFILL }\n }\n , {\n & hf_rsl_rel_mode , {\n \"Release Mode\" , \"gsm_abis_rsl.rel_mode\" , FT_UINT8 , BASE_DEC , VALS ( rel_mode_vals ) , 0x01 , NULL , HFILL }\n }\n , {\n & hf_rsl_interf_band , {\n \"Interf Band\" , \"gsm_abis_rsl.interf_band\" , FT_UINT8 , BASE_DEC , NULL , 0xe0 , NULL , HFILL }\n }\n , {\n & hf_rsl_interf_band_reserved , {\n \"Interf Band reserved bits\" , \"gsm_abis_rsl.interf_band_reserved\" , FT_UINT8 , BASE_DEC , NULL , 0x1f , NULL , HFILL }\n }\n , {\n & hf_rsl_meas_res_no , {\n \"Measurement result number\" , \"gsm_abis_rsl.meas_res_no\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_extension_bit , {\n \"Extension\" , \"gsm_abis_rsl.extension_bit\" , FT_BOOLEAN , 8 , TFS ( & rsl_extension_bit_value ) , 0x80 , NULL , HFILL }\n }\n , {\n & hf_rsl_class , {\n \"Class\" , \"gsm_abis_rsl.class\" , FT_UINT8 , BASE_DEC , VALS ( rsl_class_vals ) , 0x70 , NULL , HFILL }\n }\n , {\n & hf_rsl_paging_grp , {\n \"Paging Group\" , \"gsm_abis_rsl.paging_grp\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_paging_load , {\n \"Paging Buffer Space\" , \"gsm_abis_rsl.paging_load\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_sys_info_type , {\n \"System Info Type\" , \"gsm_abis_rsl.sys_info_type\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & rsl_sys_info_type_vals_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_timing_offset , {\n \"Timing Offset\" , \"gsm_abis_rsl.timing_offset\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_ch_needed , {\n \"Channel Needed\" , \"gsm_abis_rsl.ch_needed\" , FT_UINT8 , BASE_DEC , VALS ( rsl_ch_needed_vals ) , 0x03 , NULL , HFILL }\n }\n , {\n & hf_rsl_cbch_load_type , {\n \"CBCH Load Type\" , \"gsm_abis_rsl.cbch_load_type\" , FT_BOOLEAN , 8 , TFS ( & rsl_cbch_load_type_vals ) , 0x80 , NULL , HFILL }\n }\n , {\n & hf_rsl_msg_slt_cnt , {\n \"Message Slot Count\" , \"gsm_abis_rsl.sg_slt_cnt\" , FT_UINT8 , BASE_DEC , NULL , 0x0f , NULL , HFILL }\n }\n , {\n & hf_rsl_ch_ind , {\n \"Channel Ind\" , \"gsm_abis_rsl.ch_ind\" , FT_UINT8 , BASE_DEC , VALS ( rsl_ch_ind_vals ) , 0x0f , NULL , HFILL }\n }\n , {\n & hf_rsl_command , {\n \"Command\" , \"gsm_abis_rsl.cmd\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_emlpp_prio , {\n \"eMLPP Priority\" , \"gsm_abis_rsl.emlpp_prio\" , FT_UINT8 , BASE_DEC , VALS ( rsl_emlpp_prio_vals ) , 0x03 , NULL , HFILL }\n }\n , {\n & hf_rsl_speech_mode_s , {\n \"ip.access Speech Mode S\" , \"gsm_abis_rsl.ipacc.speech_mode_s\" , FT_UINT8 , BASE_HEX , VALS ( rsl_ipacc_spm_s_vals ) , 0xf , NULL , HFILL }\n }\n , {\n & hf_rsl_speech_mode_m , {\n \"ip.access Speech Mode M\" , \"gsm_abis_rsl.ipacc.speech_mode_m\" , FT_UINT8 , BASE_HEX , VALS ( rsl_ipacc_spm_m_vals ) , 0xf0 , NULL , HFILL }\n }\n , {\n & hf_rsl_conn_id , {\n \"ip.access Connection ID\" , \"gsm_abis_rsl.ipacc.conn_id\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_rtp_payload , {\n \"ip.access RTP Payload Type\" , \"gsm_abis_rsl.ipacc.rtp_payload\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_rtp_csd_fmt_d , {\n \"ip.access RTP CSD Format D\" , \"gsm_abis_rsl.ipacc.rtp_csd_fmt_d\" , FT_UINT8 , BASE_HEX , VALS ( rsl_ipacc_rtp_csd_fmt_d_vals ) , 0x0f , NULL , HFILL }\n , }\n , {\n & hf_rsl_rtp_csd_fmt_ir , {\n \"ip.access RTP CSD Format IR\" , \"gsm_abis_rsl.ipacc.rtp_csd_fmt_ir\" , FT_UINT8 , BASE_HEX , VALS ( rsl_ipacc_rtp_csd_fmt_ir_vals ) , 0xf0 , NULL , HFILL }\n , }\n , {\n & hf_rsl_local_port , {\n \"ip.access Local RTP Port\" , \"gsm_abis_rsl.ipacc.local_port\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n , }\n , {\n & hf_rsl_remote_port , {\n \"ip.access Remote RTP Port\" , \"gsm_abis_rsl.ipacc.remote_port\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n , }\n , {\n & hf_rsl_local_ip , {\n \"ip.access Local IP Address\" , \"gsm_abis_rsl.ipacc.local_ip\" , FT_IPv4 , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n , }\n , {\n & hf_rsl_remote_ip , {\n \"ip.access Remote IP Address\" , \"gsm_abis_rsl.ipacc.remote_ip\" , FT_IPv4 , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n , }\n , {\n & hf_rsl_cstat_tx_pkts , {\n \"Packets Sent\" , \"gsm_abis_rsl.ipacc.cstat.tx_pkts\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_rsl_cstat_tx_octs , {\n \"Octets Sent\" , \"gsm_abis_rsl.ipacc.cstat.tx_octets\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_rsl_cstat_rx_pkts , {\n \"Packets Received\" , \"gsm_abis_rsl.ipacc.cstat.rx_pkts\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_rsl_cstat_rx_octs , {\n \"Octets Received\" , \"gsm_abis_rsl.ipacc.cstat.rx_octets\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_rsl_cstat_lost_pkts , {\n \"Packets Lost\" , \"gsm_abis_rsl.ipacc.cstat.lost_pkts\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_rsl_cstat_ia_jitter , {\n \"Inter-arrival Jitter\" , \"gsm_abis_rsl.ipacc.cstat.ia_jitter\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_rsl_cstat_avg_tx_dly , {\n \"Average Tx Delay\" , \"gsm_abis_rsl.ipacc.cstat.avg_tx_delay\" , FT_UINT32 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_rsl_channel_description_tag , {\n \"Channel Description Tag\" , \"gsm_abis_rsl.channel_description_tag\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_mobile_allocation_tag , {\n \"Mobile Allocation Tag+Length(0)\" , \"gsm_abis_rsl.mobile_allocation_tag\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_no_resources_required , {\n \"0 No resources required(All other values are reserved)\" , \"gsm_abis_rsl.no_resources_required\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_llsdu_ccch , {\n \"Link Layer Service Data Unit (L3 Message)(CCCH)\" , \"gsm_abis_rsl.llsdu.ccch\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_llsdu_sacch , {\n \"Link Layer Service Data Unit (L3 Message)(SACCH)\" , \"gsm_abis_rsl.llsdu.sacch\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_llsdu , {\n \"Link Layer Service Data Unit (L3 Message)\" , \"gsm_abis_rsl.llsdu\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_rach_supplementary_information , {\n \"Supplementary Information\" , \"gsm_abis_rsl.supplementary_information\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_full_immediate_assign_info_field , {\n \"Full Immediate Assign Info field\" , \"gsm_abis_rsl.full_immediate_assign_info_field\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_layer_3_message , {\n \"Layer 3 message\" , \"gsm_abis_rsl.layer_3_message\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_descriptive_group_or_broadcast_call_reference , {\n \"Descriptive group or broadcast call reference\" , \"gsm_abis_rsl.descriptive_group_or_broadcast_call_reference\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_group_channel_description , {\n \"Group Channel Description\" , \"gsm_abis_rsl.group_channel_description\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_uic , {\n \"UIC\" , \"gsm_abis_rsl.uic\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_rsl_codec_list , {\n \"Codec List\" , \"gsm_abis_rsl.codec_list\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , }\n ;\n static gint * ett [ ] = {\n & ett_rsl , & ett_ie_link_id , & ett_ie_act_type , & ett_ie_bs_power , & ett_ie_ch_id , & ett_ie_ch_mode , & ett_ie_enc_inf , & ett_ie_ch_no , & ett_ie_frame_no , & ett_ie_ho_ref , & ett_ie_l1_inf , & ett_ie_L3_inf , & ett_ie_ms_id , & ett_ie_ms_pow , & ett_ie_phy_ctx , & ett_ie_paging_grp , & ett_ie_paging_load , & ett_ie_access_delay , & ett_ie_rach_load , & ett_ie_req_ref , & ett_ie_rel_mode , & ett_ie_resource_inf , & ett_ie_rlm_cause , & ett_ie_staring_time , & ett_ie_timing_adv , & ett_ie_uplink_meas , & ett_ie_full_imm_ass_inf , & ett_ie_smscb_inf , & ett_ie_ms_timing_offset , & ett_ie_err_msg , & ett_ie_full_bcch_inf , & ett_ie_ch_needed , & ett_ie_cb_cmd_type , & ett_ie_smscb_mess , & ett_ie_cbch_load_inf , & ett_ie_smscb_ch_ind , & ett_ie_grp_call_ref , & ett_ie_ch_desc , & ett_ie_nch_drx , & ett_ie_cmd_ind , & ett_ie_emlpp_prio , & ett_ie_uic , & ett_ie_main_ch_ref , & ett_ie_multirate_conf , & ett_ie_multirate_cntrl , & ett_ie_sup_codec_types , & ett_ie_codec_conf , & ett_ie_rtd , & ett_ie_tfo_status , & ett_ie_llp_apdu , & ett_ie_tfo_transp_cont , & ett_ie_cause , & ett_ie_meas_res_no , & ett_ie_message_id , & ett_ie_sys_info_type , & ett_ie_speech_mode , & ett_ie_conn_id , & ett_ie_remote_ip , & ett_ie_remote_port , & ett_ie_local_port , & ett_ie_local_ip , & ett_ie_rtp_payload , }\n ;\n static ei_register_info ei [ ] = {\n {\n & ei_rsl_speech_or_data_indicator , {\n \"gsm_abis_rsl.speech_or_data_indicator.bad\" , PI_PROTOCOL , PI_WARN , \"Speech or data indicator != 1,2 or 3\" , EXPFILL }\n }\n , {\n & ei_rsl_facility_information_element_3gpp_ts_44071 , {\n \"gsm_abis_rsl.facility_information_element_3gpp_ts_44071\" , PI_PROTOCOL , PI_NOTE , \"Facility Information Element as defined in 3GPP TS 44.071\" , EXPFILL }\n }\n , {\n & ei_rsl_embedded_message_tfo_configuration , {\n \"gsm_abis_rsl.embedded_message_tfo_configuration\" , PI_PROTOCOL , PI_NOTE , \"Embedded message that contains the TFO configuration\" , EXPFILL }\n }\n , }\n ;\n module_t * rsl_module ;\n expert_module_t * expert_rsl ;\n # define RSL_ATT_TLVDEF ( _attr , _type , _fixed_len ) \\ rsl_att_tlvdef . def [ _attr ] . type = _type ;\n \\ rsl_att_tlvdef . def [ _attr ] . fixed_len = _fixed_len ;\n RSL_ATT_TLVDEF ( RSL_IE_CH_NO , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_LINK_ID , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_ACT_TYPE , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_BS_POW , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CH_ID , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CH_MODE , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_ENC_INF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_FRAME_NO , TLV_TYPE_FIXED , 2 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_HO_REF , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_L1_INF , TLV_TYPE_FIXED , 2 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_L3_INF , TLV_TYPE_TL16V , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MS_ID , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MS_POW , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_PAGING_GRP , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_PAGING_LOAD , TLV_TYPE_FIXED , 2 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_PHY_CTX , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_ACCESS_DELAY , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_RACH_LOAD , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_REQ_REF , TLV_TYPE_FIXED , 3 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_REL_MODE , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_RESOURCE_INF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_RLM_CAUSE , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_STARTING_TIME , TLV_TYPE_FIXED , 2 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_TIMING_ADV , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_UPLINK_MEAS , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CAUSE , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MEAS_RES_NO , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MESSAGE_ID , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_SYS_INFO_TYPE , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MS_POWER_PARAM , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_BS_POWER_PARAM , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_PREPROC_PARAM , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_PREPROC_MEAS , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_ERR_MSG , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_FULL_BCCH_INF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CH_NEEDED , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CB_CMD_TYPE , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_SMSCB_MESS , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_FULL_IMM_ASS_INF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CBCH_LOAD_INF , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_SMSCB_CH_IND , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_GRP_CALL_REF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CH_DESC , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_NCH_DRX_INF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CMD_IND , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_EMLPP_PRIO , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_UIC , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MAIN_CH_REF , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MULTIRATE_CONF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_MULTIRATE_CNTRL , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_SUP_CODEC_TYPES , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_CODEC_CONF , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_RTD , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_TFO_STATUS , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_LLP_APDU , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_REMOTE_IP , TLV_TYPE_FIXED , 4 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_REMOTE_PORT , TLV_TYPE_FIXED , 2 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_LOCAL_IP , TLV_TYPE_FIXED , 4 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_CONN_STAT , TLV_TYPE_TLV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_LOCAL_PORT , TLV_TYPE_FIXED , 2 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_SPEECH_MODE , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_CONN_ID , TLV_TYPE_FIXED , 2 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_RTP_PAYLOAD2 , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_RTP_PAYLOAD , TLV_TYPE_TV , 0 ) ;\n RSL_ATT_TLVDEF ( RSL_IE_IPAC_RTP_CSD_FMT , TLV_TYPE_TV , 0 ) ;\n proto_rsl = proto_register_protocol ( \"Radio Signalling Link (RSL)\" , \"RSL\" , \"gsm_abis_rsl\" ) ;\n proto_register_field_array ( proto_rsl , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n expert_rsl = expert_register_protocol ( proto_rsl ) ;\n expert_register_field_array ( expert_rsl , ei , array_length ( ei ) ) ;\n register_dissector ( \"gsm_abis_rsl\" , dissect_rsl , proto_rsl ) ;\n rsl_module = prefs_register_protocol ( proto_rsl , proto_reg_handoff_rsl ) ;\n prefs_register_bool_preference ( rsl_module , \"use_ipaccess_rsl\" , \"Use nanoBTS definitions\" , \"Use ipaccess nanoBTS specific definitions for RSL\" , & global_rsl_use_nano_bts ) ;\n }", "hash": -5082285935423529157, "project": "debian", "size": 500, "target": 0, "idx": 15321}
{"code": "static int dissect_rsl_ie_tfo_transp_cont ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_item * ti ;\n proto_tree * ie_tree ;\n guint8 length ;\n int ie_offset ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_TFO_TRANSP_CONT ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_ie_tfo_transp_cont , & ti , \"TFO transparent container IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n length = tvb_get_guint8 ( tvb , offset ) ;\n proto_item_set_len ( ti , length + 2 ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n ie_offset = offset ;\n proto_tree_add_expert ( tree , pinfo , & ei_rsl_embedded_message_tfo_configuration , tvb , offset , length ) ;\n return ie_offset + length ;\n }", "hash": -5082285935423529157, "project": "debian", "size": 21, "target": 0, "idx": 15323}
{"code": "static int dissect_rsl_ie_timing_adv ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_tree * ie_tree ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_TIMING_ADV ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 2 , ett_ie_timing_adv , NULL , \"Timing Advance IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( ie_tree , hf_rsl_timing_adv , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n return offset ;\n }", "hash": -5082285935423529157, "project": "debian", "size": 14, "target": 0, "idx": 15363}
{"code": "void proto_add_deregistered_data ( void * data ) {\n g_ptr_array_add ( deregistered_data , data ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 3, "target": 0, "idx": 15366}
{"code": "static void proto_tree_set_eui64 ( field_info * fi , const guint64 value ) {\n fvalue_set_uinteger64 ( & fi -> value , value ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 3, "target": 0, "idx": 15392}
{"code": "static void get_time_value ( tvbuff_t * tvb , const gint start , const gint length , const guint encoding , nstime_t * time_stamp , const gboolean is_relative ) {\n guint32 tmpsecs ;\n guint64 todsecs ;\n if ( is_relative && ( encoding != ( ENC_TIME_TIMESPEC | ENC_BIG_ENDIAN ) ) && ( encoding != ( ENC_TIME_TIMESPEC | ENC_LITTLE_ENDIAN ) ) ) {\n return ;\n }\n switch ( encoding ) {\n case ENC_TIME_TIMESPEC | ENC_BIG_ENDIAN : time_stamp -> secs = ( time_t ) tvb_get_ntohl ( tvb , start ) ;\n if ( length == 8 ) time_stamp -> nsecs = tvb_get_ntohl ( tvb , start + 4 ) ;\n else time_stamp -> nsecs = 0 ;\n break ;\n case ENC_TIME_TIMESPEC | ENC_LITTLE_ENDIAN : time_stamp -> secs = ( time_t ) tvb_get_letohl ( tvb , start ) ;\n if ( length == 8 ) time_stamp -> nsecs = tvb_get_letohl ( tvb , start + 4 ) ;\n else time_stamp -> nsecs = 0 ;\n break ;\n case ENC_TIME_TOD | ENC_BIG_ENDIAN : # define TOD_BASETIME G_GUINT64_CONSTANT ( 2208988800 ) todsecs = tvb_get_ntoh64 ( tvb , start ) >> 12 ;\n time_stamp -> secs = ( time_t ) ( ( todsecs / 1000000 ) - TOD_BASETIME ) ;\n time_stamp -> nsecs = ( int ) ( ( todsecs % 1000000 ) * 1000 ) ;\n break ;\n case ENC_TIME_TOD | ENC_LITTLE_ENDIAN : todsecs = tvb_get_letoh64 ( tvb , start ) >> 12 ;\n time_stamp -> secs = ( time_t ) ( ( todsecs / 1000000 ) - TOD_BASETIME ) ;\n time_stamp -> nsecs = ( int ) ( ( todsecs % 1000000 ) * 1000 ) ;\n break ;\n case ENC_TIME_NTP | ENC_BIG_ENDIAN : # define NTP_BASETIME G_GUINT64_CONSTANT ( 2208988800 ) tmpsecs = tvb_get_ntohl ( tvb , start ) ;\n if ( tmpsecs ) time_stamp -> secs = ( time_t ) ( tmpsecs - ( guint32 ) NTP_BASETIME ) ;\n else time_stamp -> secs = tmpsecs ;\n if ( length == 8 ) {\n time_stamp -> nsecs = ( int ) ( 1000000 * ( tvb_get_ntohl ( tvb , start + 4 ) / 4294967296.0 ) ) ;\n time_stamp -> nsecs *= 1000 ;\n }\n else {\n time_stamp -> nsecs = 0 ;\n }\n break ;\n case ENC_TIME_NTP | ENC_LITTLE_ENDIAN : tmpsecs = tvb_get_letohl ( tvb , start ) ;\n if ( tmpsecs ) time_stamp -> secs = ( time_t ) ( tmpsecs - ( guint32 ) NTP_BASETIME ) ;\n else time_stamp -> secs = tmpsecs ;\n if ( length == 8 ) {\n time_stamp -> nsecs = ( int ) ( 1000000 * ( tvb_get_letohl ( tvb , start + 4 ) / 4294967296.0 ) ) ;\n time_stamp -> nsecs *= 1000 ;\n }\n else {\n time_stamp -> nsecs = 0 ;\n }\n break ;\n case ENC_TIME_NTP_BASE_ZERO | ENC_BIG_ENDIAN : # define NTP_BASETIME_ZERO G_GUINT64_CONSTANT ( 0 ) tmpsecs = tvb_get_ntohl ( tvb , start ) ;\n if ( tmpsecs ) time_stamp -> secs = ( time_t ) ( tmpsecs - ( guint32 ) NTP_BASETIME_ZERO ) ;\n else time_stamp -> secs = tmpsecs ;\n if ( length == 8 ) {\n time_stamp -> nsecs = ( int ) ( 1000000 * ( tvb_get_ntohl ( tvb , start + 4 ) / 4294967296.0 ) ) ;\n time_stamp -> nsecs *= 1000 ;\n }\n else {\n time_stamp -> nsecs = 0 ;\n }\n break ;\n case ENC_TIME_NTP_BASE_ZERO | ENC_LITTLE_ENDIAN : tmpsecs = tvb_get_letohl ( tvb , start ) ;\n if ( tmpsecs ) time_stamp -> secs = ( time_t ) ( tmpsecs - ( guint32 ) NTP_BASETIME_ZERO ) ;\n else time_stamp -> secs = tmpsecs ;\n time_stamp -> secs = ( time_t ) tvb_get_letohl ( tvb , start ) ;\n if ( length == 8 ) {\n time_stamp -> nsecs = ( int ) ( 1000000 * ( tvb_get_letohl ( tvb , start + 4 ) / 4294967296.0 ) ) ;\n time_stamp -> nsecs *= 1000 ;\n }\n else {\n time_stamp -> nsecs = 0 ;\n }\n break ;\n default : DISSECTOR_ASSERT_NOT_REACHED ( ) ;\n break ;\n }\n }", "hash": -1315695702746584250, "project": "debian", "size": 72, "target": 0, "idx": 15405}
{"code": "proto_item * proto_tree_add_eui64_format ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , const guint64 value , const char * format , ... ) {\n proto_item * pi ;\n va_list ap ;\n pi = proto_tree_add_eui64 ( tree , hfindex , tvb , start , length , value ) ;\n if ( pi != tree ) {\n TRY_TO_FAKE_THIS_REPR ( pi ) ;\n va_start ( ap , format ) ;\n proto_tree_set_representation ( pi , format , ap ) ;\n va_end ( ap ) ;\n }\n return pi ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 12, "target": 0, "idx": 15427}
{"code": "proto_item * proto_tree_add_item ( proto_tree * tree , int hfindex , tvbuff_t * tvb , const gint start , gint length , const guint encoding ) {\n register header_field_info * hfinfo ;\n PROTO_REGISTRAR_GET_NTH ( hfindex , hfinfo ) ;\n return proto_tree_add_item_new ( tree , hfinfo , tvb , start , length , encoding ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 5, "target": 0, "idx": 15432}
{"code": "static void label_mark_truncated ( char * label_str , gsize name_pos ) {\n static const char trunc_str [ ] = \" [truncated]\" ;\n const size_t trunc_len = sizeof ( trunc_str ) - 1 ;\n gchar * last_char ;\n if ( name_pos < ITEM_LABEL_LENGTH - trunc_len ) {\n memmove ( label_str + name_pos + trunc_len , label_str + name_pos , ITEM_LABEL_LENGTH - name_pos - trunc_len ) ;\n memcpy ( label_str + name_pos , trunc_str , trunc_len ) ;\n last_char = g_utf8_prev_char ( & label_str [ ITEM_LABEL_LENGTH ] ) ;\n * last_char = '\\0' ;\n }\n else if ( name_pos < ITEM_LABEL_LENGTH ) g_strlcpy ( label_str + name_pos , trunc_str , ITEM_LABEL_LENGTH - name_pos ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 12, "target": 0, "idx": 15438}
{"code": "static void proto_tree_set_guid_tvb ( field_info * fi , tvbuff_t * tvb , gint start , const guint encoding ) {\n e_guid_t guid ;\n tvb_get_guid ( tvb , start , & guid , encoding ) ;\n proto_tree_set_guid ( fi , & guid ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 5, "target": 0, "idx": 15445}
{"code": "static void proto_tree_set_guid ( field_info * fi , const e_guid_t * value_ptr ) {\n DISSECTOR_ASSERT ( value_ptr != NULL ) ;\n fvalue_set_guid ( & fi -> value , value_ptr ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 4, "target": 0, "idx": 15450}
{"code": "static void proto_tree_set_float ( field_info * fi , float value ) {\n fvalue_set_floating ( & fi -> value , value ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 3, "target": 0, "idx": 15463}
{"code": "static void proto_tree_set_ipv4 ( field_info * fi , guint32 value ) {\n fvalue_set_uinteger ( & fi -> value , value ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 3, "target": 0, "idx": 15467}
{"code": "static inline const guint8 * get_string_value ( wmem_allocator_t * scope , tvbuff_t * tvb , gint start , gint length , gint * ret_length , const guint encoding ) {\n if ( length == - 1 ) {\n length = tvb_ensure_captured_length_remaining ( tvb , start ) ;\n }\n * ret_length = length ;\n return tvb_get_string_enc ( scope , tvb , start , length , encoding ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 7, "target": 0, "idx": 15468}
{"code": "void proto_item_set_len ( proto_item * pi , const gint length ) {\n field_info * fi ;\n TRY_TO_FAKE_THIS_REPR_VOID ( pi ) ;\n fi = PITEM_FINFO ( pi ) ;\n if ( fi == NULL ) return ;\n DISSECTOR_ASSERT ( length >= 0 ) ;\n fi -> length = length ;\n if ( fi -> value . ftype -> ftype == FT_BYTES && length <= ( gint ) fi -> value . value . bytes -> len ) fi -> value . value . bytes -> len = length ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 9, "target": 0, "idx": 15516}
{"code": "const char * proto_get_protocol_name ( const int proto_id ) {\n protocol_t * protocol ;\n protocol = find_protocol_by_id ( proto_id ) ;\n if ( protocol == NULL ) return NULL ;\n return protocol -> name ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 6, "target": 0, "idx": 15518}
{"code": "proto_item * proto_tree_add_checksum ( proto_tree * tree , tvbuff_t * tvb , const guint offset , const int hf_checksum , const int hf_checksum_status , struct expert_field * bad_checksum_expert , packet_info * pinfo , guint32 computed_checksum , const guint encoding , const guint flags ) {\n header_field_info * hfinfo = proto_registrar_get_nth ( hf_checksum ) ;\n guint32 checksum ;\n guint32 len ;\n proto_item * ti = NULL ;\n proto_item * ti2 ;\n gboolean incorrect_checksum = TRUE ;\n DISSECTOR_ASSERT_HINT ( hfinfo != NULL , \"Not passed hfi!\" ) ;\n if ( flags & PROTO_CHECKSUM_NOT_PRESENT ) {\n ti = proto_tree_add_uint_format_value ( tree , hf_checksum , tvb , offset , 0 , 0 , \"[missing]\" ) ;\n PROTO_ITEM_SET_GENERATED ( ti ) ;\n if ( hf_checksum_status != - 1 ) {\n ti2 = proto_tree_add_uint ( tree , hf_checksum_status , tvb , offset , 0 , PROTO_CHECKSUM_E_NOT_PRESENT ) ;\n PROTO_ITEM_SET_GENERATED ( ti2 ) ;\n }\n return ti ;\n }\n switch ( hfinfo -> type ) {\n case FT_UINT8 : len = 1 ;\n break ;\n case FT_UINT16 : len = 2 ;\n break ;\n case FT_UINT24 : len = 3 ;\n break ;\n case FT_UINT32 : len = 4 ;\n break ;\n default : DISSECTOR_ASSERT_NOT_REACHED ( ) ;\n }\n if ( flags & PROTO_CHECKSUM_GENERATED ) {\n ti = proto_tree_add_uint ( tree , hf_checksum , tvb , offset , 0 , computed_checksum ) ;\n PROTO_ITEM_SET_GENERATED ( ti ) ;\n }\n else {\n ti = proto_tree_add_item_ret_uint ( tree , hf_checksum , tvb , offset , len , encoding , & checksum ) ;\n if ( flags & PROTO_CHECKSUM_VERIFY ) {\n if ( flags & ( PROTO_CHECKSUM_IN_CKSUM | PROTO_CHECKSUM_ZERO ) ) {\n if ( computed_checksum == 0 ) {\n proto_item_append_text ( ti , \" [correct]\" ) ;\n if ( hf_checksum_status != - 1 ) {\n ti2 = proto_tree_add_uint ( tree , hf_checksum_status , tvb , offset , 0 , PROTO_CHECKSUM_E_GOOD ) ;\n PROTO_ITEM_SET_GENERATED ( ti2 ) ;\n }\n incorrect_checksum = FALSE ;\n }\n else if ( flags & PROTO_CHECKSUM_IN_CKSUM ) {\n computed_checksum = in_cksum_shouldbe ( checksum , computed_checksum ) ;\n }\n }\n else {\n if ( checksum == computed_checksum ) {\n proto_item_append_text ( ti , \" [correct]\" ) ;\n if ( hf_checksum_status != - 1 ) {\n ti2 = proto_tree_add_uint ( tree , hf_checksum_status , tvb , offset , 0 , PROTO_CHECKSUM_E_GOOD ) ;\n PROTO_ITEM_SET_GENERATED ( ti2 ) ;\n }\n incorrect_checksum = FALSE ;\n }\n }\n if ( incorrect_checksum ) {\n if ( hf_checksum_status != - 1 ) {\n ti2 = proto_tree_add_uint ( tree , hf_checksum_status , tvb , offset , 0 , PROTO_CHECKSUM_E_BAD ) ;\n PROTO_ITEM_SET_GENERATED ( ti2 ) ;\n }\n if ( flags & PROTO_CHECKSUM_ZERO ) {\n proto_item_append_text ( ti , \" [incorrect]\" ) ;\n if ( bad_checksum_expert != NULL ) expert_add_info_format ( pinfo , ti , bad_checksum_expert , \"Bad checksum\" ) ;\n }\n else {\n switch ( hfinfo -> type ) {\n case FT_UINT8 : proto_item_append_text ( ti , \" [incorrect, should be 0x%02x]\" , computed_checksum ) ;\n if ( bad_checksum_expert != NULL ) expert_add_info_format ( pinfo , ti , bad_checksum_expert , \"Bad checksum [should be 0x%02x]\" , computed_checksum ) ;\n break ;\n case FT_UINT16 : proto_item_append_text ( ti , \" [incorrect, should be 0x%04x]\" , computed_checksum ) ;\n if ( bad_checksum_expert != NULL ) expert_add_info_format ( pinfo , ti , bad_checksum_expert , \"Bad checksum [should be 0x%04x]\" , computed_checksum ) ;\n break ;\n case FT_UINT24 : proto_item_append_text ( ti , \" [incorrect, should be 0x%06x]\" , computed_checksum ) ;\n if ( bad_checksum_expert != NULL ) expert_add_info_format ( pinfo , ti , bad_checksum_expert , \"Bad checksum [should be 0x%06x]\" , computed_checksum ) ;\n break ;\n case FT_UINT32 : proto_item_append_text ( ti , \" [incorrect, should be 0x%08x]\" , computed_checksum ) ;\n if ( bad_checksum_expert != NULL ) expert_add_info_format ( pinfo , ti , bad_checksum_expert , \"Bad checksum [should be 0x%08x]\" , computed_checksum ) ;\n break ;\n default : DISSECTOR_ASSERT_NOT_REACHED ( ) ;\n }\n }\n }\n }\n else {\n if ( hf_checksum_status != - 1 ) {\n proto_item_append_text ( ti , \" [unverified]\" ) ;\n ti2 = proto_tree_add_uint ( tree , hf_checksum_status , tvb , offset , 0 , PROTO_CHECKSUM_E_UNVERIFIED ) ;\n PROTO_ITEM_SET_GENERATED ( ti2 ) ;\n }\n }\n }\n return ti ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 96, "target": 0, "idx": 15521}
{"code": "int proto_get_id_by_short_name ( const gchar * short_name ) {\n const protocol_t * protocol = NULL ;\n DISSECTOR_ASSERT_HINT ( short_name , \"No short name present\" ) ;\n protocol = ( const protocol_t * ) g_hash_table_lookup ( proto_short_names , short_name ) ;\n if ( protocol == NULL ) return - 1 ;\n return protocol -> proto_id ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 7, "target": 0, "idx": 15523}
{"code": "static void proto_tree_set_ipv6_tvb ( field_info * fi , tvbuff_t * tvb , gint start , gint length ) {\n proto_tree_set_ipv6 ( fi , tvb_get_ptr ( tvb , start , length ) ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 3, "target": 0, "idx": 15538}
{"code": "static void proto_tree_set_system_id ( field_info * fi , const guint8 * value_ptr , gint length ) {\n GByteArray * bytes ;\n DISSECTOR_ASSERT ( value_ptr != NULL || length == 0 ) ;\n bytes = g_byte_array_new ( ) ;\n if ( length > 0 ) {\n g_byte_array_append ( bytes , value_ptr , length ) ;\n }\n fvalue_set_byte_array ( & fi -> value , bytes ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 9, "target": 0, "idx": 15554}
{"code": "gboolean proto_tracking_interesting_fields ( const proto_tree * tree ) {\n GHashTable * interesting_hfids ;\n if ( ! tree ) return FALSE ;\n interesting_hfids = PTREE_DATA ( tree ) -> interesting_hfids ;\n return ( interesting_hfids != NULL ) && g_hash_table_size ( interesting_hfids ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 6, "target": 0, "idx": 15569}
{"code": "proto_tree * proto_item_get_subtree ( proto_item * pi ) {\n field_info * fi ;\n if ( ! pi ) return NULL ;\n fi = PITEM_FINFO ( pi ) ;\n if ( ( ! fi ) || ( fi -> tree_type == - 1 ) ) return NULL ;\n return ( proto_tree * ) pi ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 7, "target": 0, "idx": 15583}
{"code": "static gint proto_compare_name ( gconstpointer p1_arg , gconstpointer p2_arg ) {\n const protocol_t * p1 = ( const protocol_t * ) p1_arg ;\n const protocol_t * p2 = ( const protocol_t * ) p2_arg ;\n return g_ascii_strcasecmp ( p1 -> short_name , p2 -> short_name ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 5, "target": 0, "idx": 15589}
{"code": "proto_item * ptvcursor_add ( ptvcursor_t * ptvc , int hfindex , gint length , const guint encoding ) {\n field_info * new_fi ;\n header_field_info * hfinfo ;\n gint item_length ;\n int offset ;\n offset = ptvc -> offset ;\n PROTO_REGISTRAR_GET_NTH ( hfindex , hfinfo ) ;\n get_hfi_length ( hfinfo , ptvc -> tvb , offset , & length , & item_length ) ;\n test_length ( hfinfo , ptvc -> tvb , offset , item_length ) ;\n ptvc -> offset += get_full_length ( hfinfo , ptvc -> tvb , offset , length , item_length , encoding ) ;\n CHECK_FOR_NULL_TREE ( ptvc -> tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( ptvc -> tree , hfindex , hfinfo ) ;\n new_fi = new_field_info ( ptvc -> tree , hfinfo , ptvc -> tvb , offset , item_length ) ;\n return proto_tree_new_item ( new_fi , ptvc -> tree , ptvc -> tvb , offset , length , encoding ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 15, "target": 0, "idx": 15600}
{"code": "proto_item * proto_tree_add_string ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , const char * value ) {\n proto_item * pi ;\n header_field_info * hfinfo ;\n CHECK_FOR_NULL_TREE ( tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( tree , hfindex , hfinfo ) ;\n DISSECTOR_ASSERT_FIELD_TYPE_IS_STRING ( hfinfo ) ;\n if ( hfinfo -> display == STR_UNICODE ) {\n DISSECTOR_ASSERT ( g_utf8_validate ( value , - 1 , NULL ) ) ;\n }\n pi = proto_tree_add_pi ( tree , hfinfo , tvb , start , & length ) ;\n DISSECTOR_ASSERT ( length >= 0 ) ;\n proto_tree_set_string ( PNODE_FINFO ( pi ) , value ) ;\n return pi ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 14, "target": 0, "idx": 15614}
{"code": "proto_item * proto_tree_add_bytes_item ( proto_tree * tree , int hfindex , tvbuff_t * tvb , const gint start , gint length , const guint encoding , GByteArray * retval , gint * endoff , gint * err ) {\n field_info * new_fi ;\n GByteArray * bytes = retval ;\n GByteArray * created_bytes = NULL ;\n gint saved_err = 0 ;\n guint32 n = 0 ;\n header_field_info * hfinfo ;\n gboolean generate = ( bytes || tree ) ? TRUE : FALSE ;\n PROTO_REGISTRAR_GET_NTH ( hfindex , hfinfo ) ;\n DISSECTOR_ASSERT_HINT ( hfinfo != NULL , \"Not passed hfi!\" ) ;\n DISSECTOR_ASSERT_HINT ( validate_proto_tree_add_bytes_ftype ( hfinfo -> type ) , \"Called proto_tree_add_bytes_item but not a bytes-based FT_XXX type\" ) ;\n if ( length < - 1 || length == 0 ) {\n REPORT_DISSECTOR_BUG ( wmem_strdup_printf ( wmem_packet_scope ( ) , \"Invalid length %d passed to proto_tree_add_bytes_item for %s\" , length , ftype_name ( hfinfo -> type ) ) ) ;\n }\n if ( encoding & ENC_STR_NUM ) {\n REPORT_DISSECTOR_BUG ( \"Decoding number strings for byte arrays is not supported\" ) ;\n }\n if ( generate && ( encoding & ENC_STR_HEX ) ) {\n if ( hfinfo -> type == FT_UINT_BYTES ) {\n REPORT_DISSECTOR_BUG ( \"proto_tree_add_bytes_item called for \" \"FT_UINT_BYTES type, but as ENC_STR_HEX\" ) ;\n }\n if ( ! bytes ) {\n bytes = created_bytes = g_byte_array_new ( ) ;\n }\n bytes = tvb_get_string_bytes ( tvb , start , length , encoding , bytes , endoff ) ;\n saved_err = errno ;\n }\n else if ( generate ) {\n tvb_ensure_bytes_exist ( tvb , start , length ) ;\n if ( ! bytes ) {\n bytes = created_bytes = g_byte_array_new ( ) ;\n }\n if ( hfinfo -> type == FT_UINT_BYTES ) {\n n = length ;\n length = get_uint_value ( tree , tvb , start , n , encoding ) ;\n g_byte_array_append ( bytes , tvb_get_ptr ( tvb , start + n , length ) , length ) ;\n }\n else if ( length > 0 ) {\n g_byte_array_append ( bytes , tvb_get_ptr ( tvb , start , length ) , length ) ;\n }\n if ( endoff ) * endoff = start + n + length ;\n }\n if ( err ) * err = saved_err ;\n CHECK_FOR_NULL_TREE_AND_FREE ( tree , {\n if ( created_bytes ) g_byte_array_free ( created_bytes , TRUE ) ;\n created_bytes = NULL ;\n bytes = NULL ;\n }\n ) ;\n TRY_TO_FAKE_THIS_ITEM_OR_FREE ( tree , hfinfo -> id , hfinfo , {\n if ( created_bytes ) g_byte_array_free ( created_bytes , TRUE ) ;\n created_bytes = NULL ;\n bytes = NULL ;\n }\n ) ;\n new_fi = new_field_info ( tree , hfinfo , tvb , start , n + length ) ;\n if ( encoding & ENC_STRING ) {\n if ( saved_err == ERANGE ) expert_add_info ( NULL , tree , & ei_number_string_decoding_erange_error ) ;\n else if ( ! bytes || saved_err != 0 ) expert_add_info ( NULL , tree , & ei_number_string_decoding_failed_error ) ;\n if ( bytes ) proto_tree_set_bytes_gbytearray ( new_fi , bytes ) ;\n else proto_tree_set_bytes ( new_fi , NULL , 0 ) ;\n if ( created_bytes ) g_byte_array_free ( created_bytes , TRUE ) ;\n }\n else {\n proto_tree_set_bytes_tvb ( new_fi , tvb , start + n , length ) ;\n FI_SET_FLAG ( new_fi , ( encoding & ENC_LITTLE_ENDIAN ) ? FI_LITTLE_ENDIAN : FI_BIG_ENDIAN ) ;\n }\n return proto_tree_add_node ( tree , new_fi ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 69, "target": 0, "idx": 15616}
{"code": "proto_item * proto_tree_add_float_format_value ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , float value , const char * format , ... ) {\n proto_item * pi ;\n va_list ap ;\n pi = proto_tree_add_float ( tree , hfindex , tvb , start , length , value ) ;\n if ( pi != tree ) {\n va_start ( ap , format ) ;\n proto_tree_set_representation_value ( pi , format , ap ) ;\n va_end ( ap ) ;\n }\n return pi ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 11, "target": 0, "idx": 15621}
{"code": "proto_item * proto_tree_add_time_item ( proto_tree * tree , int hfindex , tvbuff_t * tvb , const gint start , gint length , const guint encoding , nstime_t * retval , gint * endoff , gint * err ) {\n field_info * new_fi ;\n nstime_t time_stamp ;\n gint saved_err = 0 ;\n header_field_info * hfinfo ;\n PROTO_REGISTRAR_GET_NTH ( hfindex , hfinfo ) ;\n DISSECTOR_ASSERT_HINT ( hfinfo != NULL , \"Not passed hfi!\" ) ;\n DISSECTOR_ASSERT_FIELD_TYPE_IS_TIME ( hfinfo ) ;\n if ( length < - 1 || length == 0 ) {\n REPORT_DISSECTOR_BUG ( wmem_strdup_printf ( wmem_packet_scope ( ) , \"Invalid length %d passed to proto_tree_add_time_item\" , length ) ) ;\n }\n time_stamp . secs = 0 ;\n time_stamp . nsecs = 0 ;\n if ( encoding & ENC_STR_TIME_MASK ) {\n tvb_get_string_time ( tvb , start , length , encoding , & time_stamp , endoff ) ;\n saved_err = errno ;\n }\n else {\n const gboolean is_relative = ( hfinfo -> type == FT_RELATIVE_TIME ) ? TRUE : FALSE ;\n if ( length != 8 && length != 4 ) {\n const gboolean length_error = length < 4 ? TRUE : FALSE ;\n if ( is_relative ) report_type_length_mismatch ( tree , \"a relative time value\" , length , length_error ) ;\n else report_type_length_mismatch ( tree , \"an absolute time value\" , length , length_error ) ;\n }\n tvb_ensure_bytes_exist ( tvb , start , length ) ;\n get_time_value ( tvb , start , length , encoding , & time_stamp , is_relative ) ;\n if ( endoff ) * endoff = length ;\n }\n if ( err ) * err = saved_err ;\n if ( retval ) {\n retval -> secs = time_stamp . secs ;\n retval -> nsecs = time_stamp . nsecs ;\n }\n CHECK_FOR_NULL_TREE ( tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( tree , hfinfo -> id , hfinfo ) ;\n new_fi = new_field_info ( tree , hfinfo , tvb , start , length ) ;\n proto_tree_set_time ( new_fi , & time_stamp ) ;\n if ( encoding & ENC_STRING ) {\n if ( saved_err == ERANGE ) expert_add_info ( NULL , tree , & ei_number_string_decoding_erange_error ) ;\n else if ( saved_err == EDOM ) expert_add_info ( NULL , tree , & ei_number_string_decoding_failed_error ) ;\n }\n else {\n FI_SET_FLAG ( new_fi , ( encoding & ENC_LITTLE_ENDIAN ) ? FI_LITTLE_ENDIAN : FI_BIG_ENDIAN ) ;\n }\n return proto_tree_add_node ( tree , new_fi ) ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 46, "target": 0, "idx": 15628}
{"code": "proto_item * proto_tree_add_format_text ( proto_tree * tree , tvbuff_t * tvb , gint start , gint length ) {\n proto_item * pi ;\n header_field_info * hfinfo ;\n CHECK_FOR_NULL_TREE ( tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( tree , hf_text_only , hfinfo ) ;\n pi = proto_tree_add_text_node ( tree , tvb , start , length ) ;\n TRY_TO_FAKE_THIS_REPR ( pi ) ;\n proto_item_set_text ( pi , \"%s\" , tvb_format_text ( tvb , start , length ) ) ;\n return pi ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 10, "target": 0, "idx": 15645}
{"code": "static Image * ReadTGAImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n Image * image ;\n IndexPacket index ;\n MagickBooleanType status ;\n PixelPacket pixel ;\n register IndexPacket * indexes ;\n register PixelPacket * q ;\n register ssize_t i , x ;\n size_t base , flag , offset , real , skip ;\n ssize_t count , y ;\n TGAInfo tga_info ;\n unsigned char j , k , pixels [ 4 ] , runlength ;\n unsigned int alpha_bits ;\n assert ( image_info != ( const ImageInfo * ) NULL ) ;\n assert ( image_info -> signature == MagickSignature ) ;\n if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ;\n assert ( exception != ( ExceptionInfo * ) NULL ) ;\n assert ( exception -> signature == MagickSignature ) ;\n image = AcquireImage ( image_info ) ;\n status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ;\n if ( status == MagickFalse ) {\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n count = ReadBlob ( image , 1 , & tga_info . id_length ) ;\n tga_info . colormap_type = ( unsigned char ) ReadBlobByte ( image ) ;\n tga_info . image_type = ( TGAImageType ) ReadBlobByte ( image ) ;\n if ( ( count != 1 ) || ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARGB ) && ( tga_info . image_type != TGAMonochrome ) && ( tga_info . image_type != TGARLEColormap ) && ( tga_info . image_type != TGARLERGB ) && ( tga_info . image_type != TGARLEMonochrome ) ) || ( ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGARLEColormap ) ) && ( tga_info . colormap_type == 0 ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ;\n tga_info . colormap_index = ReadBlobLSBShort ( image ) ;\n tga_info . colormap_length = ReadBlobLSBShort ( image ) ;\n tga_info . colormap_size = ( unsigned char ) ReadBlobByte ( image ) ;\n tga_info . x_origin = ReadBlobLSBShort ( image ) ;\n tga_info . y_origin = ReadBlobLSBShort ( image ) ;\n tga_info . width = ( unsigned short ) ReadBlobLSBShort ( image ) ;\n tga_info . height = ( unsigned short ) ReadBlobLSBShort ( image ) ;\n tga_info . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ;\n tga_info . attributes = ( unsigned char ) ReadBlobByte ( image ) ;\n if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ;\n if ( ( ( ( tga_info . bits_per_pixel <= 1 ) || ( tga_info . bits_per_pixel >= 17 ) ) && ( tga_info . bits_per_pixel != 24 ) && ( tga_info . bits_per_pixel != 32 ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ;\n image -> columns = tga_info . width ;\n image -> rows = tga_info . height ;\n alpha_bits = ( tga_info . attributes & 0x0FU ) ;\n image -> matte = ( alpha_bits > 0 ) || ( tga_info . bits_per_pixel == 32 ) || ( tga_info . colormap_size == 32 ) ? MagickTrue : MagickFalse ;\n if ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARLEColormap ) ) image -> depth = ( size_t ) ( ( tga_info . bits_per_pixel <= 8 ) ? 8 : ( tga_info . bits_per_pixel <= 16 ) ? 5 : 8 ) ;\n else image -> depth = ( size_t ) ( ( tga_info . colormap_size <= 8 ) ? 8 : ( tga_info . colormap_size <= 16 ) ? 5 : 8 ) ;\n if ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGAMonochrome ) || ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLEMonochrome ) ) image -> storage_class = PseudoClass ;\n image -> compression = NoCompression ;\n if ( ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLEMonochrome ) || ( tga_info . image_type == TGARLERGB ) ) image -> compression = RLECompression ;\n if ( image -> storage_class == PseudoClass ) {\n if ( tga_info . colormap_type != 0 ) image -> colors = tga_info . colormap_index + tga_info . colormap_length ;\n else {\n size_t one ;\n one = 1 ;\n image -> colors = one << tga_info . bits_per_pixel ;\n if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n }\n if ( tga_info . id_length != 0 ) {\n char * comment ;\n size_t length ;\n length = ( size_t ) tga_info . id_length ;\n comment = ( char * ) NULL ;\n if ( ~ length >= ( MaxTextExtent - 1 ) ) comment = ( char * ) AcquireQuantumMemory ( length + MaxTextExtent , sizeof ( * comment ) ) ;\n if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n ( void ) ReadBlob ( image , tga_info . id_length , ( unsigned char * ) comment ) ;\n comment [ tga_info . id_length ] = '\\0' ;\n ( void ) SetImageProperty ( image , \"comment\" , comment ) ;\n comment = DestroyString ( comment ) ;\n }\n if ( tga_info . attributes & ( 1UL << 4 ) ) {\n if ( tga_info . attributes & ( 1UL << 5 ) ) SetImageArtifact ( image , \"tga:image-origin\" , \"TopRight\" ) ;\n else SetImageArtifact ( image , \"tga:image-origin\" , \"BottomRight\" ) ;\n }\n else {\n if ( tga_info . attributes & ( 1UL << 5 ) ) SetImageArtifact ( image , \"tga:image-origin\" , \"TopLeft\" ) ;\n else SetImageArtifact ( image , \"tga:image-origin\" , \"BottomLeft\" ) ;\n }\n if ( image_info -> ping != MagickFalse ) {\n ( void ) CloseBlob ( image ) ;\n return ( image ) ;\n }\n status = SetImageExtent ( image , image -> columns , image -> rows ) ;\n if ( status == MagickFalse ) {\n InheritException ( exception , & image -> exception ) ;\n return ( DestroyImageList ( image ) ) ;\n }\n ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ;\n pixel . opacity = ( Quantum ) OpaqueOpacity ;\n if ( tga_info . colormap_type != 0 ) {\n if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;\n if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n for ( i = 0 ;\n i < ( ssize_t ) tga_info . colormap_index ;\n i ++ ) image -> colormap [ i ] = pixel ;\n for ( ;\n i < ( ssize_t ) image -> colors ;\n i ++ ) {\n switch ( tga_info . colormap_size ) {\n case 8 : default : {\n pixel . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;\n pixel . green = pixel . red ;\n pixel . blue = pixel . red ;\n break ;\n }\n case 15 : case 16 : {\n QuantumAny range ;\n j = ( unsigned char ) ReadBlobByte ( image ) ;\n k = ( unsigned char ) ReadBlobByte ( image ) ;\n range = GetQuantumRange ( 5UL ) ;\n pixel . red = ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , range ) ;\n pixel . green = ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ;\n pixel . blue = ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ;\n break ;\n }\n case 24 : {\n pixel . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;\n pixel . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;\n pixel . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;\n break ;\n }\n case 32 : {\n pixel . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;\n pixel . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;\n pixel . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ;\n pixel . opacity = ( Quantum ) ( QuantumRange - ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ) ;\n break ;\n }\n }\n image -> colormap [ i ] = pixel ;\n }\n }\n base = 0 ;\n flag = 0 ;\n skip = MagickFalse ;\n real = 0 ;\n index = ( IndexPacket ) 0 ;\n runlength = 0 ;\n offset = 0 ;\n for ( y = 0 ;\n y < ( ssize_t ) image -> rows ;\n y ++ ) {\n real = offset ;\n if ( ( ( unsigned char ) ( tga_info . attributes & 0x20 ) >> 5 ) == 0 ) real = image -> rows - real - 1 ;\n q = QueueAuthenticPixels ( image , 0 , ( ssize_t ) real , image -> columns , 1 , exception ) ;\n if ( q == ( PixelPacket * ) NULL ) break ;\n indexes = GetAuthenticIndexQueue ( image ) ;\n for ( x = 0 ;\n x < ( ssize_t ) image -> columns ;\n x ++ ) {\n if ( ( tga_info . image_type == TGARLEColormap ) || ( tga_info . image_type == TGARLERGB ) || ( tga_info . image_type == TGARLEMonochrome ) ) {\n if ( runlength != 0 ) {\n runlength -- ;\n skip = flag != 0 ;\n }\n else {\n count = ReadBlob ( image , 1 , & runlength ) ;\n if ( count != 1 ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ;\n flag = runlength & 0x80 ;\n if ( flag != 0 ) runlength -= 128 ;\n skip = MagickFalse ;\n }\n }\n if ( skip == MagickFalse ) switch ( tga_info . bits_per_pixel ) {\n case 8 : default : {\n index = ( IndexPacket ) ReadBlobByte ( image ) ;\n if ( tga_info . colormap_type != 0 ) pixel = image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , 1UL * index ) ] ;\n else {\n pixel . red = ScaleCharToQuantum ( ( unsigned char ) index ) ;\n pixel . green = ScaleCharToQuantum ( ( unsigned char ) index ) ;\n pixel . blue = ScaleCharToQuantum ( ( unsigned char ) index ) ;\n }\n break ;\n }\n case 15 : case 16 : {\n QuantumAny range ;\n if ( ReadBlob ( image , 2 , pixels ) != 2 ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ;\n j = pixels [ 0 ] ;\n k = pixels [ 1 ] ;\n range = GetQuantumRange ( 5UL ) ;\n pixel . red = ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , range ) ;\n pixel . green = ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ;\n pixel . blue = ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ;\n if ( image -> matte != MagickFalse ) pixel . opacity = ( k & 0x80 ) == 0 ? ( Quantum ) TransparentOpacity : ( Quantum ) OpaqueOpacity ;\n if ( image -> storage_class == PseudoClass ) index = ConstrainColormapIndex ( image , ( ( size_t ) k << 8 ) + j ) ;\n break ;\n }\n case 24 : {\n if ( ReadBlob ( image , 3 , pixels ) != 3 ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ;\n pixel . blue = ScaleCharToQuantum ( pixels [ 0 ] ) ;\n pixel . green = ScaleCharToQuantum ( pixels [ 1 ] ) ;\n pixel . red = ScaleCharToQuantum ( pixels [ 2 ] ) ;\n break ;\n }\n case 32 : {\n if ( ReadBlob ( image , 4 , pixels ) != 4 ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ;\n pixel . blue = ScaleCharToQuantum ( pixels [ 0 ] ) ;\n pixel . green = ScaleCharToQuantum ( pixels [ 1 ] ) ;\n pixel . red = ScaleCharToQuantum ( pixels [ 2 ] ) ;\n pixel . opacity = ( Quantum ) ( QuantumRange - ScaleCharToQuantum ( pixels [ 3 ] ) ) ;\n break ;\n }\n }\n if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ;\n if ( image -> storage_class == PseudoClass ) SetPixelIndex ( indexes + x , index ) ;\n SetPixelRed ( q , pixel . red ) ;\n SetPixelGreen ( q , pixel . green ) ;\n SetPixelBlue ( q , pixel . blue ) ;\n if ( image -> matte != MagickFalse ) SetPixelOpacity ( q , pixel . opacity ) ;\n q ++ ;\n }\n if ( ( ( unsigned char ) ( tga_info . attributes & 0xc0 ) >> 6 ) == 2 ) offset += 2 ;\n else offset ++ ;\n if ( offset >= image -> rows ) {\n base ++ ;\n offset = base ;\n }\n if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;\n if ( image -> previous == ( Image * ) NULL ) {\n status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;\n if ( status == MagickFalse ) break ;\n }\n }\n if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ;\n ( void ) CloseBlob ( image ) ;\n return ( GetFirstImageInList ( image ) ) ;\n }", "hash": 1369940078867816769, "project": "debian", "size": 226, "target": 0, "idx": 15661}
{"code": "static void resetstack ( lua_State * L , int status ) {\n L -> ci = L -> base_ci ;\n L -> base = L -> ci -> base ;\n luaF_close ( L , L -> base ) ;\n luaD_seterrorobj ( L , status , L -> base ) ;\n L -> nCcalls = L -> baseCcalls ;\n L -> allowhook = 1 ;\n restore_stack_limit ( L ) ;\n L -> errfunc = 0 ;\n L -> errorJmp = NULL ;\n }", "hash": -5357254031401749470, "project": "debian", "size": 11, "target": 0, "idx": 15665}
{"code": "static StkId callrethooks ( lua_State * L , StkId firstResult ) {\n ptrdiff_t fr = savestack ( L , firstResult ) ;\n luaD_callhook ( L , LUA_HOOKRET , - 1 ) ;\n if ( f_isLua ( L -> ci ) ) {\n while ( ( L -> hookmask & LUA_MASKRET ) && L -> ci -> tailcalls -- ) luaD_callhook ( L , LUA_HOOKTAILRET , - 1 ) ;\n }\n return restorestack ( L , fr ) ;\n }", "hash": -5357254031401749470, "project": "debian", "size": 8, "target": 0, "idx": 15671}
{"code": "void luaD_call ( lua_State * L , StkId func , int nResults ) {\n if ( ++ L -> nCcalls >= LUAI_MAXCCALLS ) {\n if ( L -> nCcalls == LUAI_MAXCCALLS ) luaG_runerror ( L , \"C stack overflow\" ) ;\n else if ( L -> nCcalls >= ( LUAI_MAXCCALLS + ( LUAI_MAXCCALLS >> 3 ) ) ) luaD_throw ( L , LUA_ERRERR ) ;\n }\n if ( luaD_precall ( L , func , nResults ) == PCRLUA ) luaV_execute ( L , 1 ) ;\n L -> nCcalls -- ;\n luaC_checkGC ( L ) ;\n }", "hash": -5357254031401749470, "project": "debian", "size": 9, "target": 0, "idx": 15675}
{"code": "static void write_variables ( struct recvbuf * rbufp , int restrict_mask ) {\n const struct ctl_var * v ;\n int ext_var ;\n char * valuep ;\n long val ;\n size_t octets ;\n char * vareqv ;\n const char * t ;\n char * tt ;\n val = 0 ;\n if ( res_associd != 0 ) {\n ctl_error ( CERR_PERMISSION ) ;\n return ;\n }\n rpkt . status = htons ( ctlsysstatus ( ) ) ;\n while ( ( v = ctl_getitem ( sys_var , & valuep ) ) != 0 ) {\n ext_var = 0 ;\n if ( v -> flags & EOV ) {\n if ( ( v = ctl_getitem ( ext_sys_var , & valuep ) ) != 0 ) {\n if ( v -> flags & EOV ) {\n ctl_error ( CERR_UNKNOWNVAR ) ;\n return ;\n }\n ext_var = 1 ;\n }\n else {\n break ;\n }\n }\n if ( ! ( v -> flags & CAN_WRITE ) ) {\n ctl_error ( CERR_PERMISSION ) ;\n return ;\n }\n if ( ! ext_var && ( * valuep == '\\0' || ! atoint ( valuep , & val ) ) ) {\n ctl_error ( CERR_BADFMT ) ;\n return ;\n }\n if ( ! ext_var && ( val & ~ LEAP_NOTINSYNC ) != 0 ) {\n ctl_error ( CERR_BADVALUE ) ;\n return ;\n }\n if ( ext_var ) {\n octets = strlen ( v -> text ) + strlen ( valuep ) + 2 ;\n vareqv = emalloc ( octets ) ;\n tt = vareqv ;\n t = v -> text ;\n while ( * t && * t != '=' ) * tt ++ = * t ++ ;\n * tt ++ = '=' ;\n memcpy ( tt , valuep , 1 + strlen ( valuep ) ) ;\n set_sys_var ( vareqv , 1 + strlen ( vareqv ) , v -> flags ) ;\n free ( vareqv ) ;\n }\n else {\n ctl_error ( CERR_UNSPEC ) ;\n return ;\n }\n }\n ctl_flushpkt ( 0 ) ;\n }", "hash": -6068976579504840746, "project": "debian", "size": 59, "target": 0, "idx": 15705}
{"code": "u_short ctlpeerstatus ( register struct peer * p ) {\n u_short status ;\n status = p -> status ;\n if ( FLAG_CONFIG & p -> flags ) status |= CTL_PST_CONFIG ;\n if ( p -> keyid ) status |= CTL_PST_AUTHENABLE ;\n if ( FLAG_AUTHENTIC & p -> flags ) status |= CTL_PST_AUTHENTIC ;\n if ( p -> reach ) status |= CTL_PST_REACH ;\n if ( MDF_TXONLY_MASK & p -> cast_flags ) status |= CTL_PST_BCAST ;\n return CTL_PEER_STATUS ( status , p -> num_events , p -> last_event ) ;\n }", "hash": -6068976579504840746, "project": "debian", "size": 10, "target": 0, "idx": 15706}
{"code": "static void send_restrict_list ( restrict_u * pres , int ipv6 , u_int * pidx ) {\n for ( ;\n pres != NULL ;\n pres = pres -> link ) {\n send_restrict_entry ( pres , ipv6 , * pidx ) ;\n ( * pidx ) ++ ;\n }\n }", "hash": -6068976579504840746, "project": "debian", "size": 8, "target": 0, "idx": 15722}
{"code": "static void read_mru_list ( struct recvbuf * rbufp , int restrict_mask ) {\n const char nonce_text [ ] = \"nonce\" ;\n const char frags_text [ ] = \"frags\" ;\n const char limit_text [ ] = \"limit\" ;\n const char mincount_text [ ] = \"mincount\" ;\n const char resall_text [ ] = \"resall\" ;\n const char resany_text [ ] = \"resany\" ;\n const char maxlstint_text [ ] = \"maxlstint\" ;\n const char laddr_text [ ] = \"laddr\" ;\n const char resaxx_fmt [ ] = \"0x%hx\" ;\n u_int limit ;\n u_short frags ;\n u_short resall ;\n u_short resany ;\n int mincount ;\n u_int maxlstint ;\n sockaddr_u laddr ;\n struct interface * lcladr ;\n u_int count ;\n u_int ui ;\n u_int uf ;\n l_fp last [ 16 ] ;\n sockaddr_u addr [ COUNTOF ( last ) ] ;\n char buf [ 128 ] ;\n struct ctl_var * in_parms ;\n const struct ctl_var * v ;\n char * val ;\n const char * pch ;\n char * pnonce ;\n int nonce_valid ;\n size_t i ;\n int priors ;\n u_short hash ;\n mon_entry * mon ;\n mon_entry * prior_mon ;\n l_fp now ;\n if ( RES_NOMRULIST & restrict_mask ) {\n ctl_error ( CERR_PERMISSION ) ;\n NLOG ( NLOG_SYSINFO ) msyslog ( LOG_NOTICE , \"mrulist from %s rejected due to nomrulist restriction\" , stoa ( & rbufp -> recv_srcadr ) ) ;\n sys_restricted ++ ;\n return ;\n }\n in_parms = NULL ;\n set_var ( & in_parms , nonce_text , sizeof ( nonce_text ) , 0 ) ;\n set_var ( & in_parms , frags_text , sizeof ( frags_text ) , 0 ) ;\n set_var ( & in_parms , limit_text , sizeof ( limit_text ) , 0 ) ;\n set_var ( & in_parms , mincount_text , sizeof ( mincount_text ) , 0 ) ;\n set_var ( & in_parms , resall_text , sizeof ( resall_text ) , 0 ) ;\n set_var ( & in_parms , resany_text , sizeof ( resany_text ) , 0 ) ;\n set_var ( & in_parms , maxlstint_text , sizeof ( maxlstint_text ) , 0 ) ;\n set_var ( & in_parms , laddr_text , sizeof ( laddr_text ) , 0 ) ;\n for ( i = 0 ;\n i < COUNTOF ( last ) ;\n i ++ ) {\n snprintf ( buf , sizeof ( buf ) , last_fmt , ( int ) i ) ;\n set_var ( & in_parms , buf , strlen ( buf ) + 1 , 0 ) ;\n snprintf ( buf , sizeof ( buf ) , addr_fmt , ( int ) i ) ;\n set_var ( & in_parms , buf , strlen ( buf ) + 1 , 0 ) ;\n }\n pnonce = NULL ;\n frags = 0 ;\n limit = 0 ;\n mincount = 0 ;\n resall = 0 ;\n resany = 0 ;\n maxlstint = 0 ;\n lcladr = NULL ;\n priors = 0 ;\n ZERO ( last ) ;\n ZERO ( addr ) ;\n while ( NULL != ( v = ctl_getitem ( in_parms , & val ) ) && ! ( EOV & v -> flags ) ) {\n int si ;\n if ( ! strcmp ( nonce_text , v -> text ) ) {\n if ( NULL != pnonce ) free ( pnonce ) ;\n pnonce = estrdup ( val ) ;\n }\n else if ( ! strcmp ( frags_text , v -> text ) ) {\n sscanf ( val , \"%hu\" , & frags ) ;\n }\n else if ( ! strcmp ( limit_text , v -> text ) ) {\n sscanf ( val , \"%u\" , & limit ) ;\n }\n else if ( ! strcmp ( mincount_text , v -> text ) ) {\n if ( 1 != sscanf ( val , \"%d\" , & mincount ) || mincount < 0 ) mincount = 0 ;\n }\n else if ( ! strcmp ( resall_text , v -> text ) ) {\n sscanf ( val , resaxx_fmt , & resall ) ;\n }\n else if ( ! strcmp ( resany_text , v -> text ) ) {\n sscanf ( val , resaxx_fmt , & resany ) ;\n }\n else if ( ! strcmp ( maxlstint_text , v -> text ) ) {\n sscanf ( val , \"%u\" , & maxlstint ) ;\n }\n else if ( ! strcmp ( laddr_text , v -> text ) ) {\n if ( decodenetnum ( val , & laddr ) ) lcladr = getinterface ( & laddr , 0 ) ;\n }\n else if ( 1 == sscanf ( v -> text , last_fmt , & si ) && ( size_t ) si < COUNTOF ( last ) ) {\n if ( 2 == sscanf ( val , \"0x%08x.%08x\" , & ui , & uf ) ) {\n last [ si ] . l_ui = ui ;\n last [ si ] . l_uf = uf ;\n if ( ! SOCK_UNSPEC ( & addr [ si ] ) && si == priors ) priors ++ ;\n }\n }\n else if ( 1 == sscanf ( v -> text , addr_fmt , & si ) && ( size_t ) si < COUNTOF ( addr ) ) {\n if ( decodenetnum ( val , & addr [ si ] ) && last [ si ] . l_ui && last [ si ] . l_uf && si == priors ) priors ++ ;\n }\n }\n free_varlist ( in_parms ) ;\n in_parms = NULL ;\n if ( NULL == pnonce ) return ;\n nonce_valid = validate_nonce ( pnonce , rbufp ) ;\n free ( pnonce ) ;\n if ( ! nonce_valid ) return ;\n if ( ( 0 == frags && ! ( 0 < limit && limit <= MRU_ROW_LIMIT ) ) || frags > MRU_FRAGS_LIMIT ) {\n ctl_error ( CERR_BADVALUE ) ;\n return ;\n }\n if ( 0 != frags && 0 == limit ) limit = UINT_MAX ;\n else if ( 0 != limit && 0 == frags ) frags = MRU_FRAGS_LIMIT ;\n mon = NULL ;\n for ( i = 0 ;\n i < ( size_t ) priors ;\n i ++ ) {\n hash = MON_HASH ( & addr [ i ] ) ;\n for ( mon = mon_hash [ hash ] ;\n mon != NULL ;\n mon = mon -> hash_next ) if ( ADDR_PORT_EQ ( & mon -> rmtadr , & addr [ i ] ) ) break ;\n if ( mon != NULL ) {\n if ( L_ISEQU ( & mon -> last , & last [ i ] ) ) break ;\n mon = NULL ;\n }\n }\n if ( priors ) {\n if ( NULL == mon ) {\n ctl_error ( CERR_UNKNOWNVAR ) ;\n return ;\n }\n ctl_putts ( \"last.older\" , & mon -> last ) ;\n pch = sptoa ( & mon -> rmtadr ) ;\n ctl_putunqstr ( \"addr.older\" , pch , strlen ( pch ) ) ;\n if ( limit > 1 ) mon = PREV_DLIST ( mon_mru_list , mon , mru ) ;\n }\n else {\n mon = TAIL_DLIST ( mon_mru_list , mru ) ;\n }\n get_systime ( & now ) ;\n generate_nonce ( rbufp , buf , sizeof ( buf ) ) ;\n ctl_putunqstr ( \"nonce\" , buf , strlen ( buf ) ) ;\n prior_mon = NULL ;\n for ( count = 0 ;\n mon != NULL && res_frags < frags && count < limit ;\n mon = PREV_DLIST ( mon_mru_list , mon , mru ) ) {\n if ( mon -> count < mincount ) continue ;\n if ( resall && resall != ( resall & mon -> flags ) ) continue ;\n if ( resany && ! ( resany & mon -> flags ) ) continue ;\n if ( maxlstint > 0 && now . l_ui - mon -> last . l_ui > maxlstint ) continue ;\n if ( lcladr != NULL && mon -> lcladr != lcladr ) continue ;\n send_mru_entry ( mon , count ) ;\n if ( ! count ) send_random_tag_value ( 0 ) ;\n count ++ ;\n prior_mon = mon ;\n }\n if ( NULL == mon ) {\n if ( count > 1 ) send_random_tag_value ( count - 1 ) ;\n ctl_putts ( \"now\" , & now ) ;\n if ( prior_mon != NULL ) ctl_putts ( \"last.newest\" , & prior_mon -> last ) ;\n }\n ctl_flushpkt ( 0 ) ;\n }", "hash": -6068976579504840746, "project": "debian", "size": 170, "target": 0, "idx": 15725}
{"code": "static void ctl_error ( u_char errcode ) {\n int maclen ;\n numctlerrors ++ ;\n DPRINTF ( 3 , ( \"sending control error %u\\n\" , errcode ) ) ;\n rpkt . r_m_e_op = ( u_char ) CTL_RESPONSE | CTL_ERROR | ( res_opcode & CTL_OP_MASK ) ;\n rpkt . status = htons ( ( u_short ) ( errcode << 8 ) & 0xff00 ) ;\n rpkt . count = 0 ;\n if ( res_authenticate && sys_authenticate ) {\n maclen = authencrypt ( res_keyid , ( u_int32 * ) & rpkt , CTL_HEADER_LEN ) ;\n sendpkt ( rmt_addr , lcl_inter , - 2 , ( void * ) & rpkt , CTL_HEADER_LEN + maclen ) ;\n }\n else sendpkt ( rmt_addr , lcl_inter , - 3 , ( void * ) & rpkt , CTL_HEADER_LEN ) ;\n }", "hash": -6068976579504840746, "project": "debian", "size": 13, "target": 0, "idx": 15727}
{"code": "u_short ctlsysstatus ( void ) {\n register u_char this_clock ;\n this_clock = CTL_SST_TS_UNSPEC ;\n # ifdef REFCLOCK if ( sys_peer != NULL ) {\n if ( CTL_SST_TS_UNSPEC != sys_peer -> sstclktype ) this_clock = sys_peer -> sstclktype ;\n else if ( sys_peer -> refclktype < COUNTOF ( clocktypes ) ) this_clock = clocktypes [ sys_peer -> refclktype ] ;\n }\n # else if ( sys_peer != 0 ) this_clock = CTL_SST_TS_NTP ;\n # endif return CTL_SYS_STATUS ( sys_leap , this_clock , ctl_sys_num_events , ctl_sys_last_event ) ;\n }", "hash": -6068976579504840746, "project": "debian", "size": 10, "target": 0, "idx": 15728}
{"code": "static void ctl_putpeer ( int id , struct peer * p ) {\n char buf [ CTL_MAX_DATA_LEN ] ;\n char * s ;\n char * t ;\n char * be ;\n int i ;\n const struct ctl_var * k ;\n # ifdef AUTOKEY struct autokey * ap ;\n const EVP_MD * dp ;\n const char * str ;\n # endif switch ( id ) {\n case CP_CONFIG : ctl_putuint ( peer_var [ id ] . text , ! ( FLAG_PREEMPT & p -> flags ) ) ;\n break ;\n case CP_AUTHENABLE : ctl_putuint ( peer_var [ id ] . text , ! ( p -> keyid ) ) ;\n break ;\n case CP_AUTHENTIC : ctl_putuint ( peer_var [ id ] . text , ! ! ( FLAG_AUTHENTIC & p -> flags ) ) ;\n break ;\n case CP_SRCADR : ctl_putadr ( peer_var [ id ] . text , 0 , & p -> srcadr ) ;\n break ;\n case CP_SRCPORT : ctl_putuint ( peer_var [ id ] . text , SRCPORT ( & p -> srcadr ) ) ;\n break ;\n case CP_SRCHOST : if ( p -> hostname != NULL ) ctl_putstr ( peer_var [ id ] . text , p -> hostname , strlen ( p -> hostname ) ) ;\n break ;\n case CP_DSTADR : ctl_putadr ( peer_var [ id ] . text , 0 , ( p -> dstadr != NULL ) ? & p -> dstadr -> sin : NULL ) ;\n break ;\n case CP_DSTPORT : ctl_putuint ( peer_var [ id ] . text , ( p -> dstadr != NULL ) ? SRCPORT ( & p -> dstadr -> sin ) : 0 ) ;\n break ;\n case CP_IN : if ( p -> r21 > 0. ) ctl_putdbl ( peer_var [ id ] . text , p -> r21 / 1e3 ) ;\n break ;\n case CP_OUT : if ( p -> r34 > 0. ) ctl_putdbl ( peer_var [ id ] . text , p -> r34 / 1e3 ) ;\n break ;\n case CP_RATE : ctl_putuint ( peer_var [ id ] . text , p -> throttle ) ;\n break ;\n case CP_LEAP : ctl_putuint ( peer_var [ id ] . text , p -> leap ) ;\n break ;\n case CP_HMODE : ctl_putuint ( peer_var [ id ] . text , p -> hmode ) ;\n break ;\n case CP_STRATUM : ctl_putuint ( peer_var [ id ] . text , p -> stratum ) ;\n break ;\n case CP_PPOLL : ctl_putuint ( peer_var [ id ] . text , p -> ppoll ) ;\n break ;\n case CP_HPOLL : ctl_putuint ( peer_var [ id ] . text , p -> hpoll ) ;\n break ;\n case CP_PRECISION : ctl_putint ( peer_var [ id ] . text , p -> precision ) ;\n break ;\n case CP_ROOTDELAY : ctl_putdbl ( peer_var [ id ] . text , p -> rootdelay * 1e3 ) ;\n break ;\n case CP_ROOTDISPERSION : ctl_putdbl ( peer_var [ id ] . text , p -> rootdisp * 1e3 ) ;\n break ;\n case CP_REFID : # ifdef REFCLOCK if ( p -> flags & FLAG_REFCLOCK ) {\n ctl_putrefid ( peer_var [ id ] . text , p -> refid ) ;\n break ;\n }\n # endif if ( p -> stratum > 1 && p -> stratum < STRATUM_UNSPEC ) ctl_putadr ( peer_var [ id ] . text , p -> refid , NULL ) ;\n else ctl_putrefid ( peer_var [ id ] . text , p -> refid ) ;\n break ;\n case CP_REFTIME : ctl_putts ( peer_var [ id ] . text , & p -> reftime ) ;\n break ;\n case CP_ORG : ctl_putts ( peer_var [ id ] . text , & p -> aorg ) ;\n break ;\n case CP_REC : ctl_putts ( peer_var [ id ] . text , & p -> dst ) ;\n break ;\n case CP_XMT : if ( p -> xleave ) ctl_putdbl ( peer_var [ id ] . text , p -> xleave * 1e3 ) ;\n break ;\n case CP_BIAS : if ( p -> bias != 0. ) ctl_putdbl ( peer_var [ id ] . text , p -> bias * 1e3 ) ;\n break ;\n case CP_REACH : ctl_puthex ( peer_var [ id ] . text , p -> reach ) ;\n break ;\n case CP_FLASH : ctl_puthex ( peer_var [ id ] . text , p -> flash ) ;\n break ;\n case CP_TTL : # ifdef REFCLOCK if ( p -> flags & FLAG_REFCLOCK ) {\n ctl_putuint ( peer_var [ id ] . text , p -> ttl ) ;\n break ;\n }\n # endif if ( p -> ttl > 0 && p -> ttl < COUNTOF ( sys_ttl ) ) ctl_putint ( peer_var [ id ] . text , sys_ttl [ p -> ttl ] ) ;\n break ;\n case CP_UNREACH : ctl_putuint ( peer_var [ id ] . text , p -> unreach ) ;\n break ;\n case CP_TIMER : ctl_putuint ( peer_var [ id ] . text , p -> nextdate - current_time ) ;\n break ;\n case CP_DELAY : ctl_putdbl ( peer_var [ id ] . text , p -> delay * 1e3 ) ;\n break ;\n case CP_OFFSET : ctl_putdbl ( peer_var [ id ] . text , p -> offset * 1e3 ) ;\n break ;\n case CP_JITTER : ctl_putdbl ( peer_var [ id ] . text , p -> jitter * 1e3 ) ;\n break ;\n case CP_DISPERSION : ctl_putdbl ( peer_var [ id ] . text , p -> disp * 1e3 ) ;\n break ;\n case CP_KEYID : if ( p -> keyid > NTP_MAXKEY ) ctl_puthex ( peer_var [ id ] . text , p -> keyid ) ;\n else ctl_putuint ( peer_var [ id ] . text , p -> keyid ) ;\n break ;\n case CP_FILTDELAY : ctl_putarray ( peer_var [ id ] . text , p -> filter_delay , p -> filter_nextpt ) ;\n break ;\n case CP_FILTOFFSET : ctl_putarray ( peer_var [ id ] . text , p -> filter_offset , p -> filter_nextpt ) ;\n break ;\n case CP_FILTERROR : ctl_putarray ( peer_var [ id ] . text , p -> filter_disp , p -> filter_nextpt ) ;\n break ;\n case CP_PMODE : ctl_putuint ( peer_var [ id ] . text , p -> pmode ) ;\n break ;\n case CP_RECEIVED : ctl_putuint ( peer_var [ id ] . text , p -> received ) ;\n break ;\n case CP_SENT : ctl_putuint ( peer_var [ id ] . text , p -> sent ) ;\n break ;\n case CP_VARLIST : s = buf ;\n be = buf + sizeof ( buf ) ;\n if ( strlen ( peer_var [ id ] . text ) + 4 > sizeof ( buf ) ) break ;\n snprintf ( s , sizeof ( buf ) , \"%s=\\\"\" , peer_var [ id ] . text ) ;\n s += strlen ( s ) ;\n t = s ;\n for ( k = peer_var ;\n ! ( EOV & k -> flags ) ;\n k ++ ) {\n if ( PADDING & k -> flags ) continue ;\n i = strlen ( k -> text ) ;\n if ( s + i + 1 >= be ) break ;\n if ( s != t ) * s ++ = ',' ;\n memcpy ( s , k -> text , i ) ;\n s += i ;\n }\n if ( s + 2 < be ) {\n * s ++ = '\"' ;\n * s = '\\0' ;\n ctl_putdata ( buf , ( u_int ) ( s - buf ) , 0 ) ;\n }\n break ;\n case CP_TIMEREC : ctl_putuint ( peer_var [ id ] . text , current_time - p -> timereceived ) ;\n break ;\n case CP_TIMEREACH : ctl_putuint ( peer_var [ id ] . text , current_time - p -> timereachable ) ;\n break ;\n case CP_BADAUTH : ctl_putuint ( peer_var [ id ] . text , p -> badauth ) ;\n break ;\n case CP_BOGUSORG : ctl_putuint ( peer_var [ id ] . text , p -> bogusorg ) ;\n break ;\n case CP_OLDPKT : ctl_putuint ( peer_var [ id ] . text , p -> oldpkt ) ;\n break ;\n case CP_SELDISP : ctl_putuint ( peer_var [ id ] . text , p -> seldisptoolarge ) ;\n break ;\n case CP_SELBROKEN : ctl_putuint ( peer_var [ id ] . text , p -> selbroken ) ;\n break ;\n case CP_CANDIDATE : ctl_putuint ( peer_var [ id ] . text , p -> status ) ;\n break ;\n # ifdef AUTOKEY case CP_FLAGS : if ( p -> crypto ) ctl_puthex ( peer_var [ id ] . text , p -> crypto ) ;\n break ;\n case CP_SIGNATURE : if ( p -> crypto ) {\n dp = EVP_get_digestbynid ( p -> crypto >> 16 ) ;\n str = OBJ_nid2ln ( EVP_MD_pkey_type ( dp ) ) ;\n ctl_putstr ( peer_var [ id ] . text , str , strlen ( str ) ) ;\n }\n break ;\n case CP_HOST : if ( p -> subject != NULL ) ctl_putstr ( peer_var [ id ] . text , p -> subject , strlen ( p -> subject ) ) ;\n break ;\n case CP_VALID : break ;\n case CP_INITSEQ : if ( NULL == ( ap = p -> recval . ptr ) ) break ;\n ctl_putint ( peer_var [ CP_INITSEQ ] . text , ap -> seq ) ;\n ctl_puthex ( peer_var [ CP_INITKEY ] . text , ap -> key ) ;\n ctl_putfs ( peer_var [ CP_INITTSP ] . text , ntohl ( p -> recval . tstamp ) ) ;\n break ;\n case CP_IDENT : if ( p -> ident != NULL ) ctl_putstr ( peer_var [ id ] . text , p -> ident , strlen ( p -> ident ) ) ;\n break ;\n # endif }\n }", "hash": -6068976579504840746, "project": "debian", "size": 161, "target": 0, "idx": 15739}
{"code": "bool tcg_enabled ( void ) {\n return tcg_ctx . code_gen_buffer != NULL ;\n }", "hash": 1458662858915721428, "project": "debian", "size": 3, "target": 0, "idx": 15778}
{"code": "void cpu_io_recompile ( CPUArchState * env , uintptr_t retaddr ) {\n TranslationBlock * tb ;\n uint32_t n , cflags ;\n target_ulong pc , cs_base ;\n uint64_t flags ;\n tb = tb_find_pc ( retaddr ) ;\n if ( ! tb ) {\n cpu_abort ( env , \"cpu_io_recompile: could not find TB for pc=%p\" , ( void * ) retaddr ) ;\n }\n n = env -> icount_decr . u16 . low + tb -> icount ;\n cpu_restore_state_from_tb ( tb , env , retaddr ) ;\n n = n - env -> icount_decr . u16 . low ;\n n ++ ;\n # if defined ( TARGET_MIPS ) if ( ( env -> hflags & MIPS_HFLAG_BMASK ) != 0 && n > 1 ) {\n env -> active_tc . PC -= 4 ;\n env -> icount_decr . u16 . low ++ ;\n env -> hflags &= ~ MIPS_HFLAG_BMASK ;\n }\n # elif defined ( TARGET_SH4 ) if ( ( env -> flags & ( ( DELAY_SLOT | DELAY_SLOT_CONDITIONAL ) ) ) != 0 && n > 1 ) {\n env -> pc -= 2 ;\n env -> icount_decr . u16 . low ++ ;\n env -> flags &= ~ ( DELAY_SLOT | DELAY_SLOT_CONDITIONAL ) ;\n }\n # endif if ( n > CF_COUNT_MASK ) {\n cpu_abort ( env , \"TB too big during recompile\" ) ;\n }\n cflags = n | CF_LAST_IO ;\n pc = tb -> pc ;\n cs_base = tb -> cs_base ;\n flags = tb -> flags ;\n tb_phys_invalidate ( tb , - 1 ) ;\n tb_gen_code ( env , pc , cs_base , flags , cflags ) ;\n cpu_resume_from_signal ( env , NULL ) ;\n }", "hash": 1458662858915721428, "project": "debian", "size": 34, "target": 0, "idx": 15789}
{"code": "static void typhoon_pcihost_class_init ( ObjectClass * klass , void * data ) {\n DeviceClass * dc = DEVICE_CLASS ( klass ) ;\n SysBusDeviceClass * k = SYS_BUS_DEVICE_CLASS ( klass ) ;\n k -> init = typhoon_pcihost_init ;\n dc -> no_user = 1 ;\n }", "hash": 9155638497612715289, "project": "debian", "size": 6, "target": 0, "idx": 15805}
{"code": "void vapic_report_tpr_access ( DeviceState * dev , CPUState * cs , target_ulong ip , TPRAccess access ) {\n VAPICROMState * s = DO_UPCAST ( VAPICROMState , busdev . qdev , dev ) ;\n X86CPU * cpu = X86_CPU ( cs ) ;\n CPUX86State * env = & cpu -> env ;\n cpu_synchronize_state ( cs ) ;\n if ( evaluate_tpr_instruction ( s , env , & ip , access ) < 0 ) {\n if ( s -> state == VAPIC_ACTIVE ) {\n vapic_enable ( s , env ) ;\n }\n return ;\n }\n if ( update_rom_mapping ( s , env , ip ) < 0 ) {\n return ;\n }\n if ( vapic_enable ( s , env ) < 0 ) {\n return ;\n }\n patch_instruction ( s , cpu , ip ) ;\n }", "hash": 8127806390163862344, "project": "debian", "size": 19, "target": 0, "idx": 15822}
{"code": "static int find_real_tpr_addr ( VAPICROMState * s , CPUX86State * env ) {\n hwaddr paddr ;\n target_ulong addr ;\n if ( s -> state == VAPIC_ACTIVE ) {\n return 0 ;\n }\n for ( addr = 0xfffff000 ;\n addr >= 0x80000000 ;\n addr -= TARGET_PAGE_SIZE ) {\n paddr = cpu_get_phys_page_debug ( env , addr ) ;\n if ( paddr != APIC_DEFAULT_ADDRESS ) {\n continue ;\n }\n s -> real_tpr_addr = addr + 0x80 ;\n update_guest_rom_state ( s ) ;\n return 0 ;\n }\n return - 1 ;\n }", "hash": 8127806390163862344, "project": "debian", "size": 19, "target": 0, "idx": 15843}
{"code": "static int patch_hypercalls ( VAPICROMState * s ) {\n hwaddr rom_paddr = s -> rom_state_paddr & ROM_BLOCK_MASK ;\n static const uint8_t vmcall_pattern [ ] = {\n 0xb8 , 0x1 , 0 , 0 , 0 , 0xf , 0x1 , 0xc1 }\n ;\n static const uint8_t outl_pattern [ ] = {\n 0xb8 , 0x1 , 0 , 0 , 0 , 0x90 , 0xe7 , 0x7e }\n ;\n uint8_t alternates [ 2 ] ;\n const uint8_t * pattern ;\n const uint8_t * patch ;\n int patches = 0 ;\n off_t pos ;\n uint8_t * rom ;\n rom = g_malloc ( s -> rom_size ) ;\n cpu_physical_memory_rw ( rom_paddr , rom , s -> rom_size , 0 ) ;\n for ( pos = 0 ;\n pos < s -> rom_size - sizeof ( vmcall_pattern ) ;\n pos ++ ) {\n if ( kvm_irqchip_in_kernel ( ) ) {\n pattern = outl_pattern ;\n alternates [ 0 ] = outl_pattern [ 7 ] ;\n alternates [ 1 ] = outl_pattern [ 7 ] ;\n patch = & vmcall_pattern [ 5 ] ;\n }\n else {\n pattern = vmcall_pattern ;\n alternates [ 0 ] = vmcall_pattern [ 7 ] ;\n alternates [ 1 ] = 0xd9 ;\n patch = & outl_pattern [ 5 ] ;\n }\n if ( memcmp ( rom + pos , pattern , 7 ) == 0 && ( rom [ pos + 7 ] == alternates [ 0 ] || rom [ pos + 7 ] == alternates [ 1 ] ) ) {\n cpu_physical_memory_rw ( rom_paddr + pos + 5 , ( uint8_t * ) patch , 3 , 1 ) ;\n }\n }\n g_free ( rom ) ;\n if ( patches != 0 && patches != 2 ) {\n return - 1 ;\n }\n return 0 ;\n }", "hash": 8127806390163862344, "project": "debian", "size": 41, "target": 0, "idx": 15846}
{"code": "static void mips_jazz_machine_init ( void ) {\n qemu_register_machine ( & mips_magnum_machine ) ;\n qemu_register_machine ( & mips_pica61_machine ) ;\n }", "hash": 5597027026426443709, "project": "debian", "size": 4, "target": 0, "idx": 15851}
{"code": "static void mpc8544_guts_initfn ( Object * obj ) {\n SysBusDevice * d = SYS_BUS_DEVICE ( obj ) ;\n GutsState * s = MPC8544_GUTS ( obj ) ;\n memory_region_init_io ( & s -> iomem , OBJECT ( s ) , & mpc8544_guts_ops , s , \"mpc8544.guts\" , MPC8544_GUTS_MMIO_SIZE ) ;\n sysbus_init_mmio ( d , & s -> iomem ) ;\n }", "hash": -4978182697885785366, "project": "debian", "size": 6, "target": 0, "idx": 15871}
{"code": "static void sun4m_register_types ( void ) {\n type_register_static ( & idreg_info ) ;\n type_register_static ( & afx_info ) ;\n type_register_static ( & prom_info ) ;\n type_register_static ( & ram_info ) ;\n }", "hash": -7187272991279783781, "project": "debian", "size": 6, "target": 0, "idx": 15885}
{"code": "static void nvram_init ( M48t59State * nvram , uint8_t * macaddr , const char * cmdline , const char * boot_devices , ram_addr_t RAM_size , uint32_t kernel_size , int width , int height , int depth , int nvram_machine_id , const char * arch ) {\n unsigned int i ;\n uint32_t start , end ;\n uint8_t image [ 0x1ff0 ] ;\n struct OpenBIOS_nvpart_v1 * part_header ;\n memset ( image , '\\0' , sizeof ( image ) ) ;\n start = 0 ;\n part_header = ( struct OpenBIOS_nvpart_v1 * ) & image [ start ] ;\n part_header -> signature = OPENBIOS_PART_SYSTEM ;\n pstrcpy ( part_header -> name , sizeof ( part_header -> name ) , \"system\" ) ;\n end = start + sizeof ( struct OpenBIOS_nvpart_v1 ) ;\n for ( i = 0 ;\n i < nb_prom_envs ;\n i ++ ) end = OpenBIOS_set_var ( image , end , prom_envs [ i ] ) ;\n image [ end ++ ] = '\\0' ;\n end = start + ( ( end - start + 15 ) & ~ 15 ) ;\n OpenBIOS_finish_partition ( part_header , end - start ) ;\n start = end ;\n part_header = ( struct OpenBIOS_nvpart_v1 * ) & image [ start ] ;\n part_header -> signature = OPENBIOS_PART_FREE ;\n pstrcpy ( part_header -> name , sizeof ( part_header -> name ) , \"free\" ) ;\n end = 0x1fd0 ;\n OpenBIOS_finish_partition ( part_header , end - start ) ;\n Sun_init_header ( ( struct Sun_nvram * ) & image [ 0x1fd8 ] , macaddr , nvram_machine_id ) ;\n for ( i = 0 ;\n i < sizeof ( image ) ;\n i ++ ) m48t59_write ( nvram , i , image [ i ] ) ;\n }", "hash": -7187272991279783781, "project": "debian", "size": 28, "target": 0, "idx": 15891}
{"code": "static int idreg_init1 ( SysBusDevice * dev ) {\n IDRegState * s = FROM_SYSBUS ( IDRegState , dev ) ;\n memory_region_init_ram ( & s -> mem , OBJECT ( s ) , \"sun4m.idreg\" , sizeof ( idreg_data ) ) ;\n vmstate_register_ram_global ( & s -> mem ) ;\n memory_region_set_readonly ( & s -> mem , true ) ;\n sysbus_init_mmio ( dev , & s -> mem ) ;\n return 0 ;\n }", "hash": -7187272991279783781, "project": "debian", "size": 8, "target": 0, "idx": 15898}
{"code": "static void ss20_init ( QEMUMachineInitArgs * args ) {\n ram_addr_t RAM_size = args -> ram_size ;\n const char * cpu_model = args -> cpu_model ;\n const char * kernel_filename = args -> kernel_filename ;\n const char * kernel_cmdline = args -> kernel_cmdline ;\n const char * initrd_filename = args -> initrd_filename ;\n const char * boot_device = args -> boot_device ;\n sun4m_hw_init ( & sun4m_hwdefs [ 3 ] , RAM_size , boot_device , kernel_filename , kernel_cmdline , initrd_filename , cpu_model ) ;\n }", "hash": -7187272991279783781, "project": "debian", "size": 9, "target": 0, "idx": 15899}
{"code": "void sun4m_pic_info ( Monitor * mon , const QDict * qdict ) {\n if ( slavio_intctl ) slavio_pic_info ( mon , slavio_intctl ) ;\n }", "hash": -7187272991279783781, "project": "debian", "size": 3, "target": 0, "idx": 15905}
{"code": "static void ecc_init ( hwaddr base , qemu_irq irq , uint32_t version ) {\n DeviceState * dev ;\n SysBusDevice * s ;\n dev = qdev_create ( NULL , \"eccmemctl\" ) ;\n qdev_prop_set_uint32 ( dev , \"version\" , version ) ;\n qdev_init_nofail ( dev ) ;\n s = SYS_BUS_DEVICE ( dev ) ;\n sysbus_connect_irq ( s , 0 , irq ) ;\n sysbus_mmio_map ( s , 0 , base ) ;\n if ( version == 0 ) {\n sysbus_mmio_map ( s , 1 , base + 0x1000 ) ;\n }\n }", "hash": -7187272991279783781, "project": "debian", "size": 13, "target": 0, "idx": 15912}
{"code": "static unsigned long sun4m_load_kernel ( const char * kernel_filename , const char * initrd_filename , ram_addr_t RAM_size ) {\n int linux_boot ;\n unsigned int i ;\n long initrd_size , kernel_size ;\n uint8_t * ptr ;\n linux_boot = ( kernel_filename != NULL ) ;\n kernel_size = 0 ;\n if ( linux_boot ) {\n int bswap_needed ;\n # ifdef BSWAP_NEEDED bswap_needed = 1 ;\n # else bswap_needed = 0 ;\n # endif kernel_size = load_elf ( kernel_filename , translate_kernel_address , NULL , NULL , NULL , NULL , 1 , ELF_MACHINE , 0 ) ;\n if ( kernel_size < 0 ) kernel_size = load_aout ( kernel_filename , KERNEL_LOAD_ADDR , RAM_size - KERNEL_LOAD_ADDR , bswap_needed , TARGET_PAGE_SIZE ) ;\n if ( kernel_size < 0 ) kernel_size = load_image_targphys ( kernel_filename , KERNEL_LOAD_ADDR , RAM_size - KERNEL_LOAD_ADDR ) ;\n if ( kernel_size < 0 ) {\n fprintf ( stderr , \"qemu: could not load kernel '%s'\\n\" , kernel_filename ) ;\n exit ( 1 ) ;\n }\n initrd_size = 0 ;\n if ( initrd_filename ) {\n initrd_size = load_image_targphys ( initrd_filename , INITRD_LOAD_ADDR , RAM_size - INITRD_LOAD_ADDR ) ;\n if ( initrd_size < 0 ) {\n fprintf ( stderr , \"qemu: could not load initial ram disk '%s'\\n\" , initrd_filename ) ;\n exit ( 1 ) ;\n }\n }\n if ( initrd_size > 0 ) {\n for ( i = 0 ;\n i < 64 * TARGET_PAGE_SIZE ;\n i += TARGET_PAGE_SIZE ) {\n ptr = rom_ptr ( KERNEL_LOAD_ADDR + i ) ;\n if ( ldl_p ( ptr ) == 0x48647253 ) {\n stl_p ( ptr + 16 , INITRD_LOAD_ADDR ) ;\n stl_p ( ptr + 20 , initrd_size ) ;\n break ;\n }\n }\n }\n }\n return kernel_size ;\n }", "hash": -7187272991279783781, "project": "debian", "size": 41, "target": 0, "idx": 15914}
{"code": "static void prom_class_init ( ObjectClass * klass , void * data ) {\n DeviceClass * dc = DEVICE_CLASS ( klass ) ;\n SysBusDeviceClass * k = SYS_BUS_DEVICE_CLASS ( klass ) ;\n k -> init = prom_init1 ;\n dc -> props = prom_properties ;\n }", "hash": -7187272991279783781, "project": "debian", "size": 6, "target": 0, "idx": 15921}
{"code": "static inline void pxa2xx_rtc_swal2_tick ( void * opaque ) {\n PXA2xxRTCState * s = ( PXA2xxRTCState * ) opaque ;\n s -> rtsr |= ( 1 << 10 ) ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n pxa2xx_rtc_int_update ( s ) ;\n }", "hash": 6302861533225984845, "project": "debian", "size": 6, "target": 0, "idx": 15945}
{"code": "static int pxa2xx_ssp_load ( QEMUFile * f , void * opaque , int version_id ) {\n PXA2xxSSPState * s = ( PXA2xxSSPState * ) opaque ;\n int i ;\n s -> enable = qemu_get_be32 ( f ) ;\n qemu_get_be32s ( f , & s -> sscr [ 0 ] ) ;\n qemu_get_be32s ( f , & s -> sscr [ 1 ] ) ;\n qemu_get_be32s ( f , & s -> sspsp ) ;\n qemu_get_be32s ( f , & s -> ssto ) ;\n qemu_get_be32s ( f , & s -> ssitr ) ;\n qemu_get_be32s ( f , & s -> sssr ) ;\n qemu_get_8s ( f , & s -> sstsa ) ;\n qemu_get_8s ( f , & s -> ssrsa ) ;\n qemu_get_8s ( f , & s -> ssacd ) ;\n s -> rx_level = qemu_get_byte ( f ) ;\n s -> rx_start = 0 ;\n for ( i = 0 ;\n i < s -> rx_level ;\n i ++ ) s -> rx_fifo [ i ] = qemu_get_byte ( f ) ;\n return 0 ;\n }", "hash": 6302861533225984845, "project": "debian", "size": 20, "target": 0, "idx": 15952}
{"code": "static void pxa2xx_rtc_sysbus_class_init ( ObjectClass * klass , void * data ) {\n DeviceClass * dc = DEVICE_CLASS ( klass ) ;\n SysBusDeviceClass * k = SYS_BUS_DEVICE_CLASS ( klass ) ;\n k -> init = pxa2xx_rtc_init ;\n dc -> desc = \"PXA2xx RTC Controller\" ;\n dc -> vmsd = & vmstate_pxa2xx_rtc_regs ;\n }", "hash": 6302861533225984845, "project": "debian", "size": 7, "target": 0, "idx": 15956}
{"code": "static void pxa2xx_ssp_save ( QEMUFile * f , void * opaque ) {\n PXA2xxSSPState * s = ( PXA2xxSSPState * ) opaque ;\n int i ;\n qemu_put_be32 ( f , s -> enable ) ;\n qemu_put_be32s ( f , & s -> sscr [ 0 ] ) ;\n qemu_put_be32s ( f , & s -> sscr [ 1 ] ) ;\n qemu_put_be32s ( f , & s -> sspsp ) ;\n qemu_put_be32s ( f , & s -> ssto ) ;\n qemu_put_be32s ( f , & s -> ssitr ) ;\n qemu_put_be32s ( f , & s -> sssr ) ;\n qemu_put_8s ( f , & s -> sstsa ) ;\n qemu_put_8s ( f , & s -> ssrsa ) ;\n qemu_put_8s ( f , & s -> ssacd ) ;\n qemu_put_byte ( f , s -> rx_level ) ;\n for ( i = 0 ;\n i < s -> rx_level ;\n i ++ ) qemu_put_byte ( f , s -> rx_fifo [ ( s -> rx_start + i ) & 0xf ] ) ;\n }", "hash": 6302861533225984845, "project": "debian", "size": 18, "target": 0, "idx": 15963}
{"code": "static int pxa2xx_fir_is_empty ( void * opaque ) {\n PXA2xxFIrState * s = ( PXA2xxFIrState * ) opaque ;\n return ( s -> rx_len < 64 ) ;\n }", "hash": 6302861533225984845, "project": "debian", "size": 4, "target": 0, "idx": 15964}
{"code": "static void pxa2xx_fir_rx ( void * opaque , const uint8_t * buf , int size ) {\n PXA2xxFIrState * s = ( PXA2xxFIrState * ) opaque ;\n if ( ! ( s -> control [ 0 ] & ( 1 << 4 ) ) ) return ;\n while ( size -- ) {\n s -> status [ 1 ] |= 1 << 4 ;\n if ( s -> rx_len >= 64 ) {\n s -> status [ 1 ] |= 1 << 6 ;\n break ;\n }\n if ( s -> control [ 2 ] & ( 1 << 3 ) ) s -> rx_fifo [ ( s -> rx_start + s -> rx_len ++ ) & 63 ] = * ( buf ++ ) ;\n else s -> rx_fifo [ ( s -> rx_start + s -> rx_len ++ ) & 63 ] = ~ * ( buf ++ ) ;\n }\n pxa2xx_fir_update ( s ) ;\n }", "hash": 6302861533225984845, "project": "debian", "size": 14, "target": 0, "idx": 15970}
{"code": "static void pxa2xx_rtc_swupdate ( PXA2xxRTCState * s ) {\n int64_t rt = qemu_get_clock_ms ( rtc_clock ) ;\n if ( s -> rtsr & ( 1 << 12 ) ) s -> last_swcr += ( rt - s -> last_sw ) / 10 ;\n s -> last_sw = rt ;\n }", "hash": 6302861533225984845, "project": "debian", "size": 5, "target": 0, "idx": 15994}
{"code": "static void pxa2xx_i2s_write ( void * opaque , hwaddr addr , uint64_t value , unsigned size ) {\n PXA2xxI2SState * s = ( PXA2xxI2SState * ) opaque ;\n uint32_t * sample ;\n switch ( addr ) {\n case SACR0 : if ( value & ( 1 << 3 ) ) pxa2xx_i2s_reset ( s ) ;\n s -> control [ 0 ] = value & 0xff3d ;\n if ( ! s -> enable && ( value & 1 ) && s -> tx_len ) {\n for ( sample = s -> fifo ;\n s -> fifo_len > 0 ;\n s -> fifo_len -- , sample ++ ) s -> codec_out ( s -> opaque , * sample ) ;\n s -> status &= ~ ( 1 << 7 ) ;\n }\n if ( value & ( 1 << 4 ) ) printf ( \"%s: Attempt to use special function\\n\" , __FUNCTION__ ) ;\n s -> enable = ( value & 9 ) == 1 ;\n pxa2xx_i2s_update ( s ) ;\n break ;\n case SACR1 : s -> control [ 1 ] = value & 0x0039 ;\n if ( value & ( 1 << 5 ) ) printf ( \"%s: Attempt to use loopback function\\n\" , __FUNCTION__ ) ;\n if ( value & ( 1 << 4 ) ) s -> fifo_len = 0 ;\n pxa2xx_i2s_update ( s ) ;\n break ;\n case SAIMR : s -> mask = value & 0x0078 ;\n pxa2xx_i2s_update ( s ) ;\n break ;\n case SAICR : s -> status &= ~ ( value & ( 3 << 5 ) ) ;\n pxa2xx_i2s_update ( s ) ;\n break ;\n case SADIV : s -> clk = value & 0x007f ;\n break ;\n case SADR : if ( s -> tx_len && s -> enable ) {\n s -> tx_len -- ;\n pxa2xx_i2s_update ( s ) ;\n s -> codec_out ( s -> opaque , value ) ;\n }\n else if ( s -> fifo_len < 16 ) {\n s -> fifo [ s -> fifo_len ++ ] = value ;\n pxa2xx_i2s_update ( s ) ;\n }\n break ;\n default : printf ( \"%s: Bad register \" REG_FMT \"\\n\" , __FUNCTION__ , addr ) ;\n }\n }", "hash": 6302861533225984845, "project": "debian", "size": 42, "target": 0, "idx": 15995}
{"code": "static uint64_t pxa2xx_fir_read ( void * opaque , hwaddr addr , unsigned size ) {\n PXA2xxFIrState * s = ( PXA2xxFIrState * ) opaque ;\n uint8_t ret ;\n switch ( addr ) {\n case ICCR0 : return s -> control [ 0 ] ;\n case ICCR1 : return s -> control [ 1 ] ;\n case ICCR2 : return s -> control [ 2 ] ;\n case ICDR : s -> status [ 0 ] &= ~ 0x01 ;\n s -> status [ 1 ] &= ~ 0x72 ;\n if ( s -> rx_len ) {\n s -> rx_len -- ;\n ret = s -> rx_fifo [ s -> rx_start ++ ] ;\n s -> rx_start &= 63 ;\n pxa2xx_fir_update ( s ) ;\n return ret ;\n }\n printf ( \"%s: Rx FIFO underrun.\\n\" , __FUNCTION__ ) ;\n break ;\n case ICSR0 : return s -> status [ 0 ] ;\n case ICSR1 : return s -> status [ 1 ] | ( 1 << 3 ) ;\n case ICFOR : return s -> rx_len ;\n default : printf ( \"%s: Bad register \" REG_FMT \"\\n\" , __FUNCTION__ , addr ) ;\n break ;\n }\n return 0 ;\n }", "hash": 6302861533225984845, "project": "debian", "size": 26, "target": 0, "idx": 16002}
{"code": "PXA2xxI2CState * pxa2xx_i2c_init ( hwaddr base , qemu_irq irq , uint32_t region_size ) {\n DeviceState * dev ;\n SysBusDevice * i2c_dev ;\n PXA2xxI2CState * s ;\n i2c_dev = SYS_BUS_DEVICE ( qdev_create ( NULL , \"pxa2xx_i2c\" ) ) ;\n qdev_prop_set_uint32 ( & i2c_dev -> qdev , \"size\" , region_size + 1 ) ;\n qdev_prop_set_uint32 ( & i2c_dev -> qdev , \"offset\" , base & region_size ) ;\n qdev_init_nofail ( & i2c_dev -> qdev ) ;\n sysbus_mmio_map ( i2c_dev , 0 , base & ~ region_size ) ;\n sysbus_connect_irq ( i2c_dev , 0 , irq ) ;\n s = FROM_SYSBUS ( PXA2xxI2CState , i2c_dev ) ;\n dev = i2c_create_slave ( i2c_init_bus ( NULL , \"dummy\" ) , \"pxa2xx-i2c-slave\" , 0 ) ;\n s -> slave = FROM_I2C_SLAVE ( PXA2xxI2CSlaveState , I2C_SLAVE ( dev ) ) ;\n s -> slave -> host = s ;\n return s ;\n }", "hash": 6302861533225984845, "project": "debian", "size": 16, "target": 0, "idx": 16003}
{"code": "static void openpic_cpu_write ( void * opaque , hwaddr addr , uint64_t val , unsigned len ) {\n openpic_cpu_write_internal ( opaque , addr , val , ( addr & 0x1f000 ) >> 12 ) ;\n }", "hash": -1919011628477388936, "project": "debian", "size": 3, "target": 0, "idx": 16031}
{"code": "static inline void IRQ_setbit ( IRQQueue * q , int n_IRQ ) {\n set_bit ( n_IRQ , q -> queue ) ;\n }", "hash": -1919011628477388936, "project": "debian", "size": 3, "target": 0, "idx": 16040}
{"code": "static void openpic_class_init ( ObjectClass * oc , void * data ) {\n DeviceClass * dc = DEVICE_CLASS ( oc ) ;\n dc -> realize = openpic_realize ;\n dc -> props = openpic_properties ;\n dc -> reset = openpic_reset ;\n }", "hash": -1919011628477388936, "project": "debian", "size": 6, "target": 0, "idx": 16041}
{"code": "static void IRQ_local_pipe ( OpenPICState * opp , int n_CPU , int n_IRQ , bool active , bool was_active ) {\n IRQDest * dst ;\n IRQSource * src ;\n int priority ;\n dst = & opp -> dst [ n_CPU ] ;\n src = & opp -> src [ n_IRQ ] ;\n DPRINTF ( \"%s: IRQ %d active %d was %d\\n\" , __func__ , n_IRQ , active , was_active ) ;\n if ( src -> output != OPENPIC_OUTPUT_INT ) {\n DPRINTF ( \"%s: output %d irq %d active %d was %d count %d\\n\" , __func__ , src -> output , n_IRQ , active , was_active , dst -> outputs_active [ src -> output ] ) ;\n if ( active ) {\n if ( ! was_active && dst -> outputs_active [ src -> output ] ++ == 0 ) {\n DPRINTF ( \"%s: Raise OpenPIC output %d cpu %d irq %d\\n\" , __func__ , src -> output , n_CPU , n_IRQ ) ;\n qemu_irq_raise ( dst -> irqs [ src -> output ] ) ;\n }\n }\n else {\n if ( was_active && -- dst -> outputs_active [ src -> output ] == 0 ) {\n DPRINTF ( \"%s: Lower OpenPIC output %d cpu %d irq %d\\n\" , __func__ , src -> output , n_CPU , n_IRQ ) ;\n qemu_irq_lower ( dst -> irqs [ src -> output ] ) ;\n }\n }\n return ;\n }\n priority = IVPR_PRIORITY ( src -> ivpr ) ;\n if ( active ) {\n IRQ_setbit ( & dst -> raised , n_IRQ ) ;\n }\n else {\n IRQ_resetbit ( & dst -> raised , n_IRQ ) ;\n }\n IRQ_check ( opp , & dst -> raised ) ;\n if ( active && priority <= dst -> ctpr ) {\n DPRINTF ( \"%s: IRQ %d priority %d too low for ctpr %d on CPU %d\\n\" , __func__ , n_IRQ , priority , dst -> ctpr , n_CPU ) ;\n active = 0 ;\n }\n if ( active ) {\n if ( IRQ_get_next ( opp , & dst -> servicing ) >= 0 && priority <= dst -> servicing . priority ) {\n DPRINTF ( \"%s: IRQ %d is hidden by servicing IRQ %d on CPU %d\\n\" , __func__ , n_IRQ , dst -> servicing . next , n_CPU ) ;\n }\n else {\n DPRINTF ( \"%s: Raise OpenPIC INT output cpu %d irq %d/%d\\n\" , __func__ , n_CPU , n_IRQ , dst -> raised . next ) ;\n qemu_irq_raise ( opp -> dst [ n_CPU ] . irqs [ OPENPIC_OUTPUT_INT ] ) ;\n }\n }\n else {\n IRQ_get_next ( opp , & dst -> servicing ) ;\n if ( dst -> raised . priority > dst -> ctpr && dst -> raised . priority > dst -> servicing . priority ) {\n DPRINTF ( \"%s: IRQ %d inactive, IRQ %d prio %d above %d/%d, CPU %d\\n\" , __func__ , n_IRQ , dst -> raised . next , dst -> raised . priority , dst -> ctpr , dst -> servicing . priority , n_CPU ) ;\n }\n else {\n DPRINTF ( \"%s: IRQ %d inactive, current prio %d/%d, CPU %d\\n\" , __func__ , n_IRQ , dst -> ctpr , dst -> servicing . priority , n_CPU ) ;\n qemu_irq_lower ( opp -> dst [ n_CPU ] . irqs [ OPENPIC_OUTPUT_INT ] ) ;\n }\n }\n }", "hash": -1919011628477388936, "project": "debian", "size": 55, "target": 0, "idx": 16046}
{"code": "static void openpic_realize ( DeviceState * dev , Error * * errp ) {\n SysBusDevice * d = SYS_BUS_DEVICE ( dev ) ;\n OpenPICState * opp = OPENPIC ( dev ) ;\n int i , j ;\n int list_count = 0 ;\n static const MemReg list_le [ ] = {\n {\n \"glb\" , & openpic_glb_ops_le , OPENPIC_GLB_REG_START , OPENPIC_GLB_REG_SIZE }\n , {\n \"tmr\" , & openpic_tmr_ops_le , OPENPIC_TMR_REG_START , OPENPIC_TMR_REG_SIZE }\n , {\n \"src\" , & openpic_src_ops_le , OPENPIC_SRC_REG_START , OPENPIC_SRC_REG_SIZE }\n , {\n \"cpu\" , & openpic_cpu_ops_le , OPENPIC_CPU_REG_START , OPENPIC_CPU_REG_SIZE }\n , {\n NULL }\n }\n ;\n static const MemReg list_be [ ] = {\n {\n \"glb\" , & openpic_glb_ops_be , OPENPIC_GLB_REG_START , OPENPIC_GLB_REG_SIZE }\n , {\n \"tmr\" , & openpic_tmr_ops_be , OPENPIC_TMR_REG_START , OPENPIC_TMR_REG_SIZE }\n , {\n \"src\" , & openpic_src_ops_be , OPENPIC_SRC_REG_START , OPENPIC_SRC_REG_SIZE }\n , {\n \"cpu\" , & openpic_cpu_ops_be , OPENPIC_CPU_REG_START , OPENPIC_CPU_REG_SIZE }\n , {\n NULL }\n }\n ;\n static const MemReg list_fsl [ ] = {\n {\n \"msi\" , & openpic_msi_ops_be , OPENPIC_MSI_REG_START , OPENPIC_MSI_REG_SIZE }\n , {\n \"summary\" , & openpic_summary_ops_be , OPENPIC_SUMMARY_REG_START , OPENPIC_SUMMARY_REG_SIZE }\n , {\n NULL }\n }\n ;\n switch ( opp -> model ) {\n case OPENPIC_MODEL_FSL_MPIC_20 : default : opp -> fsl = & fsl_mpic_20 ;\n opp -> brr1 = 0x00400200 ;\n opp -> flags |= OPENPIC_FLAG_IDR_CRIT ;\n opp -> nb_irqs = 80 ;\n opp -> mpic_mode_mask = GCR_MODE_MIXED ;\n fsl_common_init ( opp ) ;\n map_list ( opp , list_be , & list_count ) ;\n map_list ( opp , list_fsl , & list_count ) ;\n break ;\n case OPENPIC_MODEL_FSL_MPIC_42 : opp -> fsl = & fsl_mpic_42 ;\n opp -> brr1 = 0x00400402 ;\n opp -> flags |= OPENPIC_FLAG_ILR ;\n opp -> nb_irqs = 196 ;\n opp -> mpic_mode_mask = GCR_MODE_PROXY ;\n fsl_common_init ( opp ) ;\n map_list ( opp , list_be , & list_count ) ;\n map_list ( opp , list_fsl , & list_count ) ;\n break ;\n case OPENPIC_MODEL_RAVEN : opp -> nb_irqs = RAVEN_MAX_EXT ;\n opp -> vid = VID_REVISION_1_3 ;\n opp -> vir = VIR_GENERIC ;\n opp -> vector_mask = 0xFF ;\n opp -> tfrr_reset = 4160000 ;\n opp -> ivpr_reset = IVPR_MASK_MASK | IVPR_MODE_MASK ;\n opp -> idr_reset = 0 ;\n opp -> max_irq = RAVEN_MAX_IRQ ;\n opp -> irq_ipi0 = RAVEN_IPI_IRQ ;\n opp -> irq_tim0 = RAVEN_TMR_IRQ ;\n opp -> brr1 = - 1 ;\n opp -> mpic_mode_mask = GCR_MODE_MIXED ;\n if ( opp -> nb_cpus != 1 ) {\n error_setg ( errp , \"Only UP supported today\" ) ;\n return ;\n }\n map_list ( opp , list_le , & list_count ) ;\n break ;\n }\n for ( i = 0 ;\n i < opp -> nb_cpus ;\n i ++ ) {\n opp -> dst [ i ] . irqs = g_new ( qemu_irq , OPENPIC_OUTPUT_NB ) ;\n for ( j = 0 ;\n j < OPENPIC_OUTPUT_NB ;\n j ++ ) {\n sysbus_init_irq ( d , & opp -> dst [ i ] . irqs [ j ] ) ;\n }\n }\n register_savevm ( dev , \"openpic\" , 0 , 2 , openpic_save , openpic_load , opp ) ;\n sysbus_init_mmio ( d , & opp -> mem ) ;\n qdev_init_gpio_in ( dev , openpic_set_irq , opp -> max_irq ) ;\n }", "hash": -1919011628477388936, "project": "debian", "size": 92, "target": 0, "idx": 16059}
{"code": "static uint64_t openpic_msi_read ( void * opaque , hwaddr addr , unsigned size ) {\n OpenPICState * opp = opaque ;\n uint64_t r = 0 ;\n int i , srs ;\n DPRINTF ( \"%s: addr %#\" HWADDR_PRIx \"\\n\" , __func__ , addr ) ;\n if ( addr & 0xF ) {\n return - 1 ;\n }\n srs = addr >> 4 ;\n switch ( addr ) {\n case 0x00 : case 0x10 : case 0x20 : case 0x30 : case 0x40 : case 0x50 : case 0x60 : case 0x70 : r = opp -> msi [ srs ] . msir ;\n opp -> msi [ srs ] . msir = 0 ;\n openpic_set_irq ( opp , opp -> irq_msi + srs , 0 ) ;\n break ;\n case 0x120 : for ( i = 0 ;\n i < MAX_MSI ;\n i ++ ) {\n r |= ( opp -> msi [ i ] . msir ? 1 : 0 ) << i ;\n }\n break ;\n }\n return r ;\n }", "hash": -1919011628477388936, "project": "debian", "size": 23, "target": 0, "idx": 16067}
{"code": "static uint64_t openpic_tmr_read ( void * opaque , hwaddr addr , unsigned len ) {\n OpenPICState * opp = opaque ;\n uint32_t retval = - 1 ;\n int idx ;\n DPRINTF ( \"%s: addr %#\" HWADDR_PRIx \"\\n\" , __func__ , addr ) ;\n if ( addr & 0xF ) {\n goto out ;\n }\n idx = ( addr >> 6 ) & 0x3 ;\n if ( addr == 0x0 ) {\n retval = opp -> tfrr ;\n goto out ;\n }\n switch ( addr & 0x30 ) {\n case 0x00 : retval = opp -> timers [ idx ] . tccr ;\n break ;\n case 0x10 : retval = opp -> timers [ idx ] . tbcr ;\n break ;\n case 0x20 : retval = read_IRQreg_ivpr ( opp , opp -> irq_tim0 + idx ) ;\n break ;\n case 0x30 : retval = read_IRQreg_idr ( opp , opp -> irq_tim0 + idx ) ;\n break ;\n }\n out : DPRINTF ( \"%s: => 0x%08x\\n\" , __func__ , retval ) ;\n return retval ;\n }", "hash": -1919011628477388936, "project": "debian", "size": 26, "target": 0, "idx": 16070}
{"code": "int64_t cpu_get_clock ( void ) {\n int64_t ti ;\n if ( ! timers_state . cpu_ticks_enabled ) {\n return timers_state . cpu_clock_offset ;\n }\n else {\n ti = get_clock ( ) ;\n return ti + timers_state . cpu_clock_offset ;\n }\n }", "hash": -5420171864670538459, "project": "debian", "size": 10, "target": 0, "idx": 16076}
{"code": "static void flush_queued_work ( CPUState * cpu ) {\n struct qemu_work_item * wi ;\n if ( cpu -> queued_work_first == NULL ) {\n return ;\n }\n while ( ( wi = cpu -> queued_work_first ) ) {\n cpu -> queued_work_first = wi -> next ;\n wi -> func ( wi -> data ) ;\n wi -> done = true ;\n }\n cpu -> queued_work_last = NULL ;\n qemu_cond_broadcast ( & qemu_work_cond ) ;\n }", "hash": -5420171864670538459, "project": "debian", "size": 13, "target": 0, "idx": 16079}
{"code": "void qemu_cpu_kick ( CPUState * cpu ) {\n qemu_cond_broadcast ( cpu -> halt_cond ) ;\n if ( ! tcg_enabled ( ) && ! cpu -> thread_kicked ) {\n qemu_cpu_kick_thread ( cpu ) ;\n cpu -> thread_kicked = true ;\n }\n }", "hash": -5420171864670538459, "project": "debian", "size": 7, "target": 0, "idx": 16086}
{"code": "static void dummy_signal ( int sig ) {\n }", "hash": -5420171864670538459, "project": "debian", "size": 2, "target": 0, "idx": 16089}
{"code": "void qmp_pmemsave ( int64_t addr , int64_t size , const char * filename , Error * * errp ) {\n FILE * f ;\n uint32_t l ;\n uint8_t buf [ 1024 ] ;\n f = fopen ( filename , \"wb\" ) ;\n if ( ! f ) {\n error_setg_file_open ( errp , errno , filename ) ;\n return ;\n }\n while ( size != 0 ) {\n l = sizeof ( buf ) ;\n if ( l > size ) l = size ;\n cpu_physical_memory_rw ( addr , buf , l , 0 ) ;\n if ( fwrite ( buf , 1 , l , f ) != l ) {\n error_set ( errp , QERR_IO_ERROR ) ;\n goto exit ;\n }\n addr += l ;\n size -= l ;\n }\n exit : fclose ( f ) ;\n }", "hash": -5420171864670538459, "project": "debian", "size": 22, "target": 0, "idx": 16090}
{"code": "static void qemu_tcg_init_cpu_signals ( void ) {\n sigset_t set ;\n struct sigaction sigact ;\n memset ( & sigact , 0 , sizeof ( sigact ) ) ;\n sigact . sa_handler = cpu_signal ;\n sigaction ( SIG_IPI , & sigact , NULL ) ;\n sigemptyset ( & set ) ;\n sigaddset ( & set , SIG_IPI ) ;\n pthread_sigmask ( SIG_UNBLOCK , & set , NULL ) ;\n }", "hash": -5420171864670538459, "project": "debian", "size": 10, "target": 0, "idx": 16104}
{"code": "void resume_all_vcpus ( void ) {\n CPUArchState * penv = first_cpu ;\n qemu_clock_enable ( vm_clock , true ) ;\n while ( penv ) {\n CPUState * pcpu = ENV_GET_CPU ( penv ) ;\n cpu_resume ( pcpu ) ;\n penv = penv -> next_cpu ;\n }\n }", "hash": -5420171864670538459, "project": "debian", "size": 9, "target": 0, "idx": 16124}
{"code": "static void qemu_dummy_start_vcpu ( CPUState * cpu ) {\n cpu -> thread = g_malloc0 ( sizeof ( QemuThread ) ) ;\n cpu -> halt_cond = g_malloc0 ( sizeof ( QemuCond ) ) ;\n qemu_cond_init ( cpu -> halt_cond ) ;\n qemu_thread_create ( cpu -> thread , qemu_dummy_cpu_thread_fn , cpu , QEMU_THREAD_JOINABLE ) ;\n while ( ! cpu -> created ) {\n qemu_cond_wait ( & qemu_cpu_cond , & qemu_global_mutex ) ;\n }\n }", "hash": -5420171864670538459, "project": "debian", "size": 9, "target": 0, "idx": 16138}
{"code": "static uint64_t timerblock_read ( void * opaque , hwaddr addr , unsigned size ) {\n TimerBlock * tb = ( TimerBlock * ) opaque ;\n int64_t val ;\n switch ( addr ) {\n case 0 : return tb -> load ;\n case 4 : if ( ( ( tb -> control & 1 ) == 0 ) || ( tb -> count == 0 ) ) {\n return 0 ;\n }\n val = tb -> tick - qemu_get_clock_ns ( vm_clock ) ;\n val /= timerblock_scale ( tb ) ;\n if ( val < 0 ) {\n val = 0 ;\n }\n return val ;\n case 8 : return tb -> control ;\n case 12 : return tb -> status ;\n default : return 0 ;\n }\n }", "hash": -5262394088289559608, "project": "debian", "size": 19, "target": 0, "idx": 16140}
{"code": "static inline uint32_t timerblock_scale ( TimerBlock * tb ) {\n return ( ( ( tb -> control >> 8 ) & 0xff ) + 1 ) * 10 ;\n }", "hash": -5262394088289559608, "project": "debian", "size": 3, "target": 0, "idx": 16145}
{"code": "static inline int get_current_cpu ( ARMMPTimerState * s ) {\n if ( current_cpu -> cpu_index >= s -> num_cpu ) {\n hw_error ( \"arm_mptimer: num-cpu %d but this cpu is %d!\\n\" , s -> num_cpu , current_cpu -> cpu_index ) ;\n }\n return current_cpu -> cpu_index ;\n }", "hash": -5262394088289559608, "project": "debian", "size": 6, "target": 0, "idx": 16146}
{"code": "static void gic_set_irq ( void * opaque , int irq , int level ) {\n GICState * s = ( GICState * ) opaque ;\n int cm , target ;\n if ( irq < ( s -> num_irq - GIC_INTERNAL ) ) {\n cm = ALL_CPU_MASK ;\n irq += GIC_INTERNAL ;\n target = GIC_TARGET ( irq ) ;\n }\n else {\n int cpu ;\n irq -= ( s -> num_irq - GIC_INTERNAL ) ;\n cpu = irq / GIC_INTERNAL ;\n irq %= GIC_INTERNAL ;\n cm = 1 << cpu ;\n target = cm ;\n }\n if ( level == GIC_TEST_LEVEL ( irq , cm ) ) {\n return ;\n }\n if ( level ) {\n GIC_SET_LEVEL ( irq , cm ) ;\n if ( GIC_TEST_TRIGGER ( irq ) || GIC_TEST_ENABLED ( irq , cm ) ) {\n DPRINTF ( \"Set %d pending mask %x\\n\" , irq , target ) ;\n GIC_SET_PENDING ( irq , target ) ;\n }\n }\n else {\n GIC_CLEAR_LEVEL ( irq , cm ) ;\n }\n gic_update ( s ) ;\n }", "hash": 7493853980473701704, "project": "debian", "size": 31, "target": 0, "idx": 16167}
{"code": "void gic_set_pending_private ( GICState * s , int cpu , int irq ) {\n int cm = 1 << cpu ;\n if ( GIC_TEST_PENDING ( irq , cm ) ) return ;\n DPRINTF ( \"Set %d pending cpu %d\\n\" , irq , cpu ) ;\n GIC_SET_PENDING ( irq , cm ) ;\n gic_update ( s ) ;\n }", "hash": 7493853980473701704, "project": "debian", "size": 7, "target": 0, "idx": 16186}
{"code": "static uint32_t vmport_cmd_get_version ( void * opaque , uint32_t addr ) {\n X86CPU * cpu = X86_CPU ( current_cpu ) ;\n cpu -> env . regs [ R_EBX ] = VMPORT_MAGIC ;\n return 6 ;\n }", "hash": 3528176083733952042, "project": "debian", "size": 5, "target": 0, "idx": 16193}
{"code": "static int s_aes_init ( stream_state * ss ) {\n stream_aes_state * const state = ( stream_aes_state * ) ss ;\n state -> initialized = 0 ;\n state -> ctx = NULL ;\n return 0 ;\n }", "hash": 2782335626401253771, "project": "debian", "size": 6, "target": 0, "idx": 16205}
{"code": "static void s_aes_release ( stream_state * ss ) {\n stream_aes_state * const state = ( stream_aes_state * ) ss ;\n if ( state -> ctx != NULL ) gs_free_object ( state -> memory , state -> ctx , \"aes context structure\" ) ;\n }", "hash": 2782335626401253771, "project": "debian", "size": 4, "target": 0, "idx": 16209}
{"code": "VALUE ossl_cipher_new ( const EVP_CIPHER * cipher ) {\n VALUE ret ;\n EVP_CIPHER_CTX * ctx ;\n ret = ossl_cipher_alloc ( cCipher ) ;\n AllocCipher ( ret , ctx ) ;\n if ( EVP_CipherInit_ex ( ctx , cipher , NULL , NULL , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ;\n return ret ;\n }", "hash": 1896723564367514490, "project": "debian", "size": 8, "target": 0, "idx": 16229}
{"code": "static VALUE ossl_cipher_set_iv ( VALUE self , VALUE iv ) {\n EVP_CIPHER_CTX * ctx ;\n int iv_len = 0 ;\n StringValue ( iv ) ;\n GetCipher ( self , ctx ) ;\n # if defined ( HAVE_AUTHENTICATED_ENCRYPTION ) if ( EVP_CIPHER_CTX_flags ( ctx ) & EVP_CIPH_FLAG_AEAD_CIPHER ) iv_len = ( int ) ( VALUE ) EVP_CIPHER_CTX_get_app_data ( ctx ) ;\n # endif if ( ! iv_len ) iv_len = EVP_CIPHER_CTX_iv_length ( ctx ) ;\n if ( RSTRING_LEN ( iv ) != iv_len ) ossl_raise ( rb_eArgError , \"iv must be %d bytes\" , iv_len ) ;\n if ( EVP_CipherInit_ex ( ctx , NULL , NULL , NULL , ( unsigned char * ) RSTRING_PTR ( iv ) , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ;\n return iv ;\n }", "hash": 1896723564367514490, "project": "debian", "size": 11, "target": 0, "idx": 16230}
{"code": "void Init_ossl_cipher ( void ) {\n # if 0 mOSSL = rb_define_module ( \"OpenSSL\" ) ;\n eOSSLError = rb_define_class_under ( mOSSL , \"OpenSSLError\" , rb_eStandardError ) ;\n # endif cCipher = rb_define_class_under ( mOSSL , \"Cipher\" , rb_cObject ) ;\n eCipherError = rb_define_class_under ( cCipher , \"CipherError\" , eOSSLError ) ;\n rb_define_alloc_func ( cCipher , ossl_cipher_alloc ) ;\n rb_define_copy_func ( cCipher , ossl_cipher_copy ) ;\n rb_define_module_function ( cCipher , \"ciphers\" , ossl_s_ciphers , 0 ) ;\n rb_define_method ( cCipher , \"initialize\" , ossl_cipher_initialize , 1 ) ;\n rb_define_method ( cCipher , \"reset\" , ossl_cipher_reset , 0 ) ;\n rb_define_method ( cCipher , \"encrypt\" , ossl_cipher_encrypt , - 1 ) ;\n rb_define_method ( cCipher , \"decrypt\" , ossl_cipher_decrypt , - 1 ) ;\n rb_define_method ( cCipher , \"pkcs5_keyivgen\" , ossl_cipher_pkcs5_keyivgen , - 1 ) ;\n rb_define_method ( cCipher , \"update\" , ossl_cipher_update , - 1 ) ;\n rb_define_method ( cCipher , \"final\" , ossl_cipher_final , 0 ) ;\n rb_define_method ( cCipher , \"name\" , ossl_cipher_name , 0 ) ;\n rb_define_method ( cCipher , \"key=\" , ossl_cipher_set_key , 1 ) ;\n rb_define_method ( cCipher , \"auth_data=\" , ossl_cipher_set_auth_data , 1 ) ;\n rb_define_method ( cCipher , \"auth_tag=\" , ossl_cipher_set_auth_tag , 1 ) ;\n rb_define_method ( cCipher , \"auth_tag\" , ossl_cipher_get_auth_tag , - 1 ) ;\n rb_define_method ( cCipher , \"auth_tag_len=\" , ossl_cipher_set_auth_tag_len , 1 ) ;\n rb_define_method ( cCipher , \"authenticated?\" , ossl_cipher_is_authenticated , 0 ) ;\n rb_define_method ( cCipher , \"key_len=\" , ossl_cipher_set_key_length , 1 ) ;\n rb_define_method ( cCipher , \"key_len\" , ossl_cipher_key_length , 0 ) ;\n rb_define_method ( cCipher , \"iv=\" , ossl_cipher_set_iv , 1 ) ;\n rb_define_method ( cCipher , \"iv_len=\" , ossl_cipher_set_iv_length , 1 ) ;\n rb_define_method ( cCipher , \"iv_len\" , ossl_cipher_iv_length , 0 ) ;\n rb_define_method ( cCipher , \"block_size\" , ossl_cipher_block_size , 0 ) ;\n rb_define_method ( cCipher , \"padding=\" , ossl_cipher_set_padding , 1 ) ;\n id_auth_tag_len = rb_intern_const ( \"auth_tag_len\" ) ;\n id_key_set = rb_intern_const ( \"key_set\" ) ;\n }", "hash": 1896723564367514490, "project": "debian", "size": 32, "target": 0, "idx": 16232}
{"code": "static VALUE ossl_cipher_set_key_length ( VALUE self , VALUE key_length ) {\n int len = NUM2INT ( key_length ) ;\n EVP_CIPHER_CTX * ctx ;\n GetCipher ( self , ctx ) ;\n if ( EVP_CIPHER_CTX_set_key_length ( ctx , len ) != 1 ) ossl_raise ( eCipherError , NULL ) ;\n return key_length ;\n }", "hash": 1896723564367514490, "project": "debian", "size": 7, "target": 0, "idx": 16237}
{"code": "static VALUE ossl_cipher_set_key ( VALUE self , VALUE key ) {\n EVP_CIPHER_CTX * ctx ;\n int key_len ;\n StringValue ( key ) ;\n GetCipher ( self , ctx ) ;\n key_len = EVP_CIPHER_CTX_key_length ( ctx ) ;\n if ( RSTRING_LEN ( key ) != key_len ) ossl_raise ( rb_eArgError , \"key must be %d bytes\" , key_len ) ;\n if ( EVP_CipherInit_ex ( ctx , NULL , NULL , ( unsigned char * ) RSTRING_PTR ( key ) , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ;\n rb_ivar_set ( self , id_key_set , Qtrue ) ;\n return key ;\n }", "hash": 1896723564367514490, "project": "debian", "size": 11, "target": 0, "idx": 16239}
{"code": "static VALUE ossl_cipher_iv_length ( VALUE self ) {\n EVP_CIPHER_CTX * ctx ;\n int len = 0 ;\n GetCipher ( self , ctx ) ;\n # if defined ( HAVE_AUTHENTICATED_ENCRYPTION ) if ( EVP_CIPHER_CTX_flags ( ctx ) & EVP_CIPH_FLAG_AEAD_CIPHER ) len = ( int ) ( VALUE ) EVP_CIPHER_CTX_get_app_data ( ctx ) ;\n # endif if ( ! len ) len = EVP_CIPHER_CTX_iv_length ( ctx ) ;\n return INT2NUM ( len ) ;\n }", "hash": 1896723564367514490, "project": "debian", "size": 8, "target": 0, "idx": 16241}
{"code": "static void sig_complete_connect ( GList * * list , WINDOW_REC * window , const char * word , const char * line , int * want_space ) {\n g_return_if_fail ( list != NULL ) ;\n g_return_if_fail ( word != NULL ) ;\n * list = completion_get_chatnets ( word ) ;\n * list = g_list_concat ( * list , completion_get_servers ( word ) ) ;\n if ( * list != NULL ) signal_stop ( ) ;\n }", "hash": -1055531103257174901, "project": "debian", "size": 7, "target": 0, "idx": 16249}
{"code": "GList * completion_get_targets ( const char * word ) {\n CONFIG_NODE * node ;\n GList * list ;\n GSList * tmp ;\n int len ;\n g_return_val_if_fail ( word != NULL , NULL ) ;\n len = strlen ( word ) ;\n list = NULL ;\n node = iconfig_node_traverse ( \"conversions\" , FALSE ) ;\n tmp = node == NULL ? NULL : config_node_first ( node -> value ) ;\n for ( ;\n tmp != NULL ;\n tmp = config_node_next ( tmp ) ) {\n node = tmp -> data ;\n if ( node -> type != NODE_TYPE_KEY ) continue ;\n if ( len != 0 && g_ascii_strncasecmp ( node -> key , word , len ) != 0 ) continue ;\n list = g_list_append ( list , g_strdup ( node -> key ) ) ;\n }\n return list ;\n }", "hash": -1055531103257174901, "project": "debian", "size": 20, "target": 0, "idx": 16250}
{"code": "static void completion_msg_server ( GSList * * list , SERVER_REC * server , const char * nick , const char * prefix ) {\n LAST_MSG_REC * msg ;\n GSList * tmp ;\n int len ;\n g_return_if_fail ( nick != NULL ) ;\n len = strlen ( nick ) ;\n tmp = server == NULL ? global_lastmsgs : ( ( MODULE_SERVER_REC * ) MODULE_DATA ( server ) ) -> lastmsgs ;\n for ( ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n LAST_MSG_REC * rec = tmp -> data ;\n if ( len != 0 && g_ascii_strncasecmp ( rec -> nick , nick , len ) != 0 ) continue ;\n msg = g_new ( LAST_MSG_REC , 1 ) ;\n msg -> time = rec -> time ;\n msg -> nick = prefix == NULL || * prefix == '\\0' ? g_strdup ( rec -> nick ) : g_strconcat ( prefix , \" \" , rec -> nick , NULL ) ;\n * list = g_slist_insert_sorted ( * list , msg , ( GCompareFunc ) last_msg_cmp ) ;\n }\n }", "hash": -1055531103257174901, "project": "debian", "size": 18, "target": 0, "idx": 16260}
{"code": "static void last_msg_destroy ( GSList * * list , LAST_MSG_REC * rec ) {\n * list = g_slist_remove ( * list , rec ) ;\n g_free ( rec -> nick ) ;\n g_free ( rec ) ;\n }", "hash": -1055531103257174901, "project": "debian", "size": 5, "target": 0, "idx": 16269}
{"code": "static void sig_complete_unalias ( GList * * list , WINDOW_REC * window , const char * word , const char * line , int * want_space ) {\n g_return_if_fail ( list != NULL ) ;\n g_return_if_fail ( word != NULL ) ;\n * list = completion_get_aliases ( word ) ;\n if ( * list != NULL ) signal_stop ( ) ;\n }", "hash": -1055531103257174901, "project": "debian", "size": 6, "target": 0, "idx": 16270}
{"code": "static int last_msg_cmp ( LAST_MSG_REC * m1 , LAST_MSG_REC * m2 ) {\n return m1 -> time < m2 -> time ? 1 : - 1 ;\n }", "hash": -1055531103257174901, "project": "debian", "size": 3, "target": 0, "idx": 16272}
{"code": "static LAST_MSG_REC * last_msg_find ( GSList * list , const char * nick ) {\n while ( list != NULL ) {\n LAST_MSG_REC * rec = list -> data ;\n if ( g_ascii_strcasecmp ( rec -> nick , nick ) == 0 ) return rec ;\n list = list -> next ;\n }\n return NULL ;\n }", "hash": -1055531103257174901, "project": "debian", "size": 8, "target": 0, "idx": 16274}
{"code": "static GList * convert_msglist ( GSList * msglist ) {\n GList * list ;\n list = NULL ;\n while ( msglist != NULL ) {\n LAST_MSG_REC * rec = msglist -> data ;\n list = g_list_append ( list , rec -> nick ) ;\n msglist = g_slist_remove ( msglist , rec ) ;\n g_free ( rec ) ;\n }\n return list ;\n }", "hash": -1055531103257174901, "project": "debian", "size": 11, "target": 0, "idx": 16276}
{"code": "static void complete_from_nicklist ( GList * * outlist , CHANNEL_REC * channel , const char * nick , const char * suffix , const int match_case ) {\n MODULE_CHANNEL_REC * mchannel ;\n GSList * tmp ;\n GList * ownlist ;\n char * str ;\n int len ;\n ownlist = NULL ;\n len = strlen ( nick ) ;\n mchannel = MODULE_DATA ( channel ) ;\n for ( tmp = mchannel -> lastmsgs ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n LAST_MSG_REC * rec = tmp -> data ;\n if ( ( match_case ? strncmp ( rec -> nick , nick , len ) : g_ascii_strncasecmp ( rec -> nick , nick , len ) ) == 0 && ( match_case ? glist_find_string ( * outlist , rec -> nick ) : glist_find_icase_string ( * outlist , rec -> nick ) ) == NULL ) {\n str = g_strconcat ( rec -> nick , suffix , NULL ) ;\n if ( completion_lowercase ) ascii_strdown ( str ) ;\n if ( rec -> own ) ownlist = g_list_append ( ownlist , str ) ;\n else * outlist = g_list_append ( * outlist , str ) ;\n }\n }\n * outlist = g_list_concat ( ownlist , * outlist ) ;\n }", "hash": -1055531103257174901, "project": "debian", "size": 22, "target": 0, "idx": 16287}
{"code": "int input_DecoderSetCcState ( decoder_t * p_dec , bool b_decode , int i_channel ) {\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n if ( i_channel < 0 || i_channel >= 4 || ! p_owner -> cc . pb_present [ i_channel ] ) return VLC_EGENERIC ;\n if ( b_decode ) {\n static const vlc_fourcc_t fcc [ 4 ] = {\n VLC_FOURCC ( 'c' , 'c' , '1' , ' ' ) , VLC_FOURCC ( 'c' , 'c' , '2' , ' ' ) , VLC_FOURCC ( 'c' , 'c' , '3' , ' ' ) , VLC_FOURCC ( 'c' , 'c' , '4' , ' ' ) , }\n ;\n decoder_t * p_cc ;\n es_format_t fmt ;\n es_format_Init ( & fmt , SPU_ES , fcc [ i_channel ] ) ;\n p_cc = input_DecoderNew ( p_owner -> p_input , & fmt , p_dec -> p_owner -> p_clock , p_owner -> p_sout ) ;\n if ( ! p_cc ) {\n msg_Err ( p_dec , \"could not create decoder\" ) ;\n dialog_Fatal ( p_dec , _ ( \"Streaming / Transcoding failed\" ) , \"%s\" , _ ( \"VLC could not open the decoder module.\" ) ) ;\n return VLC_EGENERIC ;\n }\n else if ( ! p_cc -> p_module ) {\n DecoderUnsupportedCodec ( p_dec , fcc [ i_channel ] ) ;\n input_DecoderDelete ( p_cc ) ;\n return VLC_EGENERIC ;\n }\n p_cc -> p_owner -> p_clock = p_owner -> p_clock ;\n vlc_mutex_lock ( & p_owner -> lock ) ;\n p_owner -> cc . pp_decoder [ i_channel ] = p_cc ;\n vlc_mutex_unlock ( & p_owner -> lock ) ;\n }\n else {\n decoder_t * p_cc ;\n vlc_mutex_lock ( & p_owner -> lock ) ;\n p_cc = p_owner -> cc . pp_decoder [ i_channel ] ;\n p_owner -> cc . pp_decoder [ i_channel ] = NULL ;\n vlc_mutex_unlock ( & p_owner -> lock ) ;\n if ( p_cc ) input_DecoderDelete ( p_cc ) ;\n }\n return VLC_SUCCESS ;\n }", "hash": -8884965407551053630, "project": "debian", "size": 36, "target": 0, "idx": 16327}
{"code": "static void * DecoderThread ( void * p_data ) {\n decoder_t * p_dec = ( decoder_t * ) p_data ;\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n for ( ;\n ;\n ) {\n block_t * p_block = block_FifoGet ( p_owner -> p_fifo ) ;\n bool end_wait = ! p_block || p_block -> i_flags & BLOCK_FLAG_CORE_EOS ;\n DecoderSignalWait ( p_dec , end_wait ) ;\n if ( end_wait ) input_DecoderStopWait ( p_dec ) ;\n if ( p_block ) {\n int canc = vlc_savecancel ( ) ;\n if ( p_block -> i_flags & BLOCK_FLAG_CORE_EOS ) {\n block_Release ( p_block ) ;\n p_block = NULL ;\n }\n DecoderProcess ( p_dec , p_block ) ;\n vlc_restorecancel ( canc ) ;\n }\n }\n return NULL ;\n }", "hash": -8884965407551053630, "project": "debian", "size": 22, "target": 0, "idx": 16358}
{"code": "int ieee80211_radiotap_iterator_next ( struct ieee80211_radiotap_iterator * iterator ) {\n while ( 1 ) {\n int hit = 0 ;\n int pad , align , size , subns ;\n guint32 oui ;\n if ( ( iterator -> _arg_index % 32 ) == IEEE80211_RADIOTAP_EXT && ! ( iterator -> _bitmap_shifter & 1 ) ) return - ENOENT ;\n if ( ! ( iterator -> _bitmap_shifter & 1 ) ) goto next_entry ;\n switch ( iterator -> _arg_index % 32 ) {\n case IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE : case IEEE80211_RADIOTAP_EXT : align = 1 ;\n size = 0 ;\n break ;\n case IEEE80211_RADIOTAP_VENDOR_NAMESPACE : align = 2 ;\n size = 6 ;\n break ;\n default : # ifdef RADIOTAP_SUPPORT_OVERRIDES if ( find_override ( iterator , & align , & size ) ) {\n }\n else # endif if ( ! iterator -> current_namespace || iterator -> _arg_index >= iterator -> current_namespace -> n_bits ) {\n if ( iterator -> current_namespace == & radiotap_ns ) return - ENOENT ;\n align = 0 ;\n }\n else {\n align = iterator -> current_namespace -> align_size [ iterator -> _arg_index ] . align ;\n size = iterator -> current_namespace -> align_size [ iterator -> _arg_index ] . size ;\n }\n if ( ! align ) {\n if ( ! iterator -> _next_ns_data ) return - EINVAL ;\n iterator -> _arg = iterator -> _next_ns_data ;\n iterator -> current_namespace = NULL ;\n iterator -> _next_ns_data = NULL ;\n if ( ! ITERATOR_VALID ( iterator , 0 ) ) return - EINVAL ;\n goto next_entry ;\n }\n break ;\n }\n pad = ( int ) ( ( iterator -> _arg - ( unsigned char * ) iterator -> _rtheader ) & ( align - 1 ) ) ;\n if ( pad ) iterator -> _arg += align - pad ;\n if ( iterator -> _arg_index % 32 == IEEE80211_RADIOTAP_VENDOR_NAMESPACE ) {\n int vnslen ;\n if ( ! ITERATOR_VALID ( iterator , size ) ) return - EINVAL ;\n oui = ( * iterator -> _arg << 16 ) | ( * ( iterator -> _arg + 1 ) << 8 ) | * ( iterator -> _arg + 2 ) ;\n subns = * ( iterator -> _arg + 3 ) ;\n find_ns ( iterator , oui , subns ) ;\n vnslen = get_unaligned_le16 ( iterator -> _arg + 4 ) ;\n iterator -> _next_ns_data = iterator -> _arg + size + vnslen ;\n if ( ! iterator -> current_namespace ) size += vnslen ;\n }\n iterator -> this_arg_index = iterator -> _arg_index ;\n iterator -> this_arg = iterator -> _arg ;\n iterator -> this_arg_size = size ;\n iterator -> _arg += size ;\n if ( ! ITERATOR_VALID ( iterator , 0 ) ) return - EINVAL ;\n switch ( iterator -> _arg_index % 32 ) {\n case IEEE80211_RADIOTAP_VENDOR_NAMESPACE : iterator -> _reset_on_ext = 1 ;\n iterator -> is_radiotap_ns = 0 ;\n iterator -> this_arg_index = IEEE80211_RADIOTAP_VENDOR_NAMESPACE ;\n if ( ! iterator -> current_namespace ) hit = 1 ;\n goto next_entry ;\n case IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE : iterator -> _reset_on_ext = 1 ;\n iterator -> current_namespace = & radiotap_ns ;\n iterator -> is_radiotap_ns = 1 ;\n goto next_entry ;\n case IEEE80211_RADIOTAP_EXT : iterator -> _bitmap_shifter = get_unaligned_le32 ( iterator -> _next_bitmap ) ;\n iterator -> _next_bitmap ++ ;\n if ( iterator -> _reset_on_ext ) iterator -> _arg_index = 0 ;\n else iterator -> _arg_index ++ ;\n iterator -> _reset_on_ext = 0 ;\n break ;\n default : hit = 1 ;\n next_entry : iterator -> _bitmap_shifter >>= 1 ;\n iterator -> _arg_index ++ ;\n }\n if ( hit ) return 0 ;\n }\n }", "hash": 72378500491506723, "project": "debian", "size": 74, "target": 0, "idx": 16377}
{"code": "void proto_register_zbee_zcl_appl_idt ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_zbee_zcl_appl_idt_attr_id , {\n \"Attribute\" , \"zbee_zcl_ha.applident.attr_id\" , FT_UINT16 , BASE_HEX , VALS ( zbee_zcl_appl_idt_attr_names ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_idt_company_id , {\n \"Company ID\" , \"zbee_zcl_ha.applident.attr.company.id\" , FT_UINT16 , BASE_HEX , VALS ( zbee_zcl_appl_idt_company_names ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_idt_brand_id , {\n \"Brand ID\" , \"zbee_zcl_ha.applident.attr.brand.id\" , FT_UINT16 , BASE_HEX , VALS ( zbee_zcl_appl_idt_brand_names ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_idt_string_len , {\n \"Length\" , \"zbee_zcl_ha.applident.string.len\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_idt_prod_type_name , {\n \"Product Type Name\" , \"zbee_zcl_ha.applident.attr.prod_type.name\" , FT_UINT16 , BASE_HEX , VALS ( zbee_zcl_appl_idt_prod_type_name_names ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_idt_prod_type_id , {\n \"Product Type ID\" , \"zbee_zcl_ha.applident.attr.prod_type.id\" , FT_UINT16 , BASE_HEX , VALS ( zbee_zcl_appl_idt_prod_type_names ) , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_idt_ceced_spec_ver , {\n \"CECED Spec. Version\" , \"zbee_zcl_ha.applident.attr.ceced_spec_ver\" , FT_UINT8 , BASE_HEX , VALS ( zbee_zcl_appl_idt_ceced_spec_ver_names ) , 0x00 , NULL , HFILL }\n }\n }\n ;\n gint * ett [ ZBEE_ZCL_APPL_IDT_NUM_ETT ] ;\n ett [ 0 ] = & ett_zbee_zcl_appl_idt ;\n ett [ 1 ] = & ett_zbee_zcl_appl_idt_basic ;\n proto_zbee_zcl_appl_idt = proto_register_protocol ( \"ZigBee ZCL Appliance Identification\" , \"ZCL Appliance Identification\" , ZBEE_PROTOABBREV_ZCL_APPLIDT ) ;\n proto_register_field_array ( proto_zbee_zcl_appl_idt , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n register_dissector ( ZBEE_PROTOABBREV_ZCL_APPLIDT , dissect_zbee_zcl_appl_idt , proto_zbee_zcl_appl_idt ) ;\n }", "hash": 5917118798851365454, "project": "debian", "size": 40, "target": 0, "idx": 16379}
{"code": "static void dissect_zcl_appl_stats_log_rsp ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n guint32 log_len ;\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_stats_utc_time , tvb , * offset , 4 , ENC_LITTLE_ENDIAN ) ;\n * offset += 4 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_stats_log_id , tvb , * offset , 4 , ENC_LITTLE_ENDIAN ) ;\n * offset += 4 ;\n log_len = tvb_get_letohl ( tvb , * offset ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_stats_log_length , tvb , * offset , 4 , ENC_LITTLE_ENDIAN ) ;\n * offset += 4 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_stats_log_payload , tvb , * offset , log_len , ENC_NA ) ;\n * offset += log_len ;\n }", "hash": 5917118798851365454, "project": "debian", "size": 12, "target": 0, "idx": 16382}
{"code": "static void dissect_zcl_appl_stats_log_req ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_stats_log_id , tvb , * offset , 4 , ENC_LITTLE_ENDIAN ) ;\n * offset += 4 ;\n }", "hash": 5917118798851365454, "project": "debian", "size": 4, "target": 0, "idx": 16387}
{"code": "void proto_register_zbee_zcl_appl_evtalt ( void ) {\n guint i , j ;\n static hf_register_info hf [ ] = {\n {\n & hf_zbee_zcl_appl_evtalt_srv_tx_cmd_id , {\n \"Command\" , \"zbee_zcl_ha.applevtalt.cmd.srv_tx.id\" , FT_UINT8 , BASE_HEX , VALS ( zbee_zcl_appl_evtalt_srv_tx_cmd_names ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_evtalt_srv_rx_cmd_id , {\n \"Command\" , \"zbee_zcl_ha.applevtalt.cmd.srv_rx.id\" , FT_UINT8 , BASE_HEX , VALS ( zbee_zcl_appl_evtalt_srv_rx_cmd_names ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_evtalt_count_num , {\n \"Number of Alerts\" , \"zbee_zcl_ha.applevtalt.count.num\" , FT_UINT8 , BASE_DEC , NULL , ZBEE_ZCL_APPL_EVTALT_COUNT_NUM_MASK , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_evtalt_count_type , {\n \"Type of Alerts\" , \"zbee_zcl_ha.applevtalt.count.type\" , FT_UINT8 , BASE_DEC , NULL , ZBEE_ZCL_APPL_EVTALT_COUNT_TYPE_MASK , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_evtalt_alert_id , {\n \"Alert Id\" , \"zbee_zcl_ha.applevtalt.alert_id\" , FT_UINT24 , BASE_HEX , NULL , ZBEE_ZCL_APPL_EVTALT_ALERT_ID_MASK , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_evtalt_category , {\n \"Category\" , \"zbee_zcl_ha.applevtalt.category\" , FT_UINT24 , BASE_HEX , VALS ( zbee_zcl_appl_evtalt_category_names ) , ZBEE_ZCL_APPL_EVTALT_CATEGORY_MASK , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_evtalt_status , {\n \"Status\" , \"zbee_zcl_ha.applevtalt.status\" , FT_UINT24 , BASE_HEX , VALS ( zbee_zcl_appl_evtalt_status_names ) , ZBEE_ZCL_APPL_EVTALT_STATUS_MASK , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_evtalt_reserved , {\n \"Reserved\" , \"zbee_zcl_ha.applevtalt.reserved\" , FT_UINT24 , BASE_HEX , NULL , ZBEE_ZCL_APPL_EVTALT_RESERVED_MASK , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_evtalt_proprietary , {\n \"Proprietary\" , \"zbee_zcl_ha.applevtalt.proprietary\" , FT_UINT24 , BASE_HEX , NULL , ZBEE_ZCL_APPL_EVTALT_PROPRIETARY_MASK , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_evtalt_event_hdr , {\n \"Event Header\" , \"zbee_zcl_ha.applevtalt.event.header\" , FT_UINT8 , BASE_HEX , NULL , 0x00 , NULL , HFILL }\n }\n , {\n & hf_zbee_zcl_appl_evtalt_event_id , {\n \"Event Id\" , \"zbee_zcl_ha.applevtalt.event.id\" , FT_UINT8 , BASE_HEX , VALS ( zbee_zcl_appl_evtalt_event_id_names ) , 0x00 , NULL , HFILL }\n }\n }\n ;\n gint * ett [ ZBEE_ZCL_APPL_EVTALT_NUM_ETT ] ;\n ett [ 0 ] = & ett_zbee_zcl_appl_evtalt ;\n for ( i = 0 , j = ZBEE_ZCL_APPL_EVTALT_NUM_GENERIC_ETT ;\n i < ZBEE_ZCL_APPL_EVTALT_NUM_STRUCT_ETT ;\n i ++ , j ++ ) {\n ett_zbee_zcl_appl_evtalt_alerts_struct [ i ] = - 1 ;\n ett [ j ] = & ett_zbee_zcl_appl_evtalt_alerts_struct [ i ] ;\n }\n proto_zbee_zcl_appl_evtalt = proto_register_protocol ( \"ZigBee ZCL Appliance Events & Alert\" , \"ZCL Appliance Events & Alert\" , ZBEE_PROTOABBREV_ZCL_APPLEVTALT ) ;\n proto_register_field_array ( proto_zbee_zcl_appl_evtalt , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n register_dissector ( ZBEE_PROTOABBREV_ZCL_APPLEVTALT , dissect_zbee_zcl_appl_evtalt , proto_zbee_zcl_appl_evtalt ) ;\n }", "hash": 5917118798851365454, "project": "debian", "size": 62, "target": 0, "idx": 16391}
{"code": "int x_catch_free_colors ( Display * dpy , XErrorEvent * err ) {\n if ( err -> request_code == X_FreeColors || x_error_handler . orighandler == x_catch_free_colors ) return 0 ;\n return x_error_handler . orighandler ( dpy , err ) ;\n }", "hash": -6529313662352494663, "project": "debian", "size": 4, "target": 0, "idx": 16402}
{"code": "void gdev_x_clear_window ( gx_device_X * xdev ) {\n if ( ! xdev -> ghostview ) {\n if ( xdev -> useBackingPixmap ) {\n if ( xdev -> bpixmap == 0 ) {\n x_error_handler . oldhandler = XSetErrorHandler ( x_catch_alloc ) ;\n x_error_handler . alloc_error = False ;\n xdev -> bpixmap = XCreatePixmap ( xdev -> dpy , xdev -> win , xdev -> width , xdev -> height , xdev -> vinfo -> depth ) ;\n XSync ( xdev -> dpy , False ) ;\n if ( x_error_handler . alloc_error ) {\n xdev -> useBackingPixmap = False ;\n # ifdef DEBUG emprintf ( xdev -> memory , \"Warning: Failed to allocated backing pixmap.\\n\" ) ;\n # endif if ( xdev -> bpixmap ) {\n XFreePixmap ( xdev -> dpy , xdev -> bpixmap ) ;\n xdev -> bpixmap = None ;\n XSync ( xdev -> dpy , False ) ;\n }\n }\n x_error_handler . oldhandler = XSetErrorHandler ( x_error_handler . oldhandler ) ;\n }\n }\n else {\n if ( xdev -> bpixmap != 0 ) {\n XFreePixmap ( xdev -> dpy , xdev -> bpixmap ) ;\n xdev -> bpixmap = ( Pixmap ) 0 ;\n }\n }\n }\n x_set_buffer ( xdev ) ;\n if ( xdev -> dest == ( Pixmap ) 0 ) {\n xdev -> dest = ( xdev -> bpixmap != ( Pixmap ) 0 ? xdev -> bpixmap : ( Pixmap ) xdev -> win ) ;\n }\n if ( xdev -> dest != ( Pixmap ) 0 ) {\n XSetForeground ( xdev -> dpy , xdev -> gc , xdev -> background ) ;\n XFillRectangle ( xdev -> dpy , xdev -> dest , xdev -> gc , 0 , 0 , xdev -> width , xdev -> height ) ;\n }\n if ( xdev -> bpixmap != ( Pixmap ) 0 ) {\n if ( ! xdev -> ghostview ) XSetWindowBackgroundPixmap ( xdev -> dpy , xdev -> win , xdev -> bpixmap ) ;\n XSetForeground ( xdev -> dpy , xdev -> gc , xdev -> background ) ;\n XFillRectangle ( xdev -> dpy , xdev -> bpixmap , xdev -> gc , 0 , 0 , xdev -> width , xdev -> height ) ;\n }\n xdev -> back_color = xdev -> background ;\n XSetBackground ( xdev -> dpy , xdev -> gc , xdev -> background ) ;\n xdev -> fore_color = xdev -> background ;\n XSetForeground ( xdev -> dpy , xdev -> gc , xdev -> background ) ;\n xdev -> colors_or = xdev -> colors_and = xdev -> background ;\n }", "hash": -6529313662352494663, "project": "debian", "size": 46, "target": 0, "idx": 16409}
{"code": "ATF_TC_BODY ( option_refcnt , tc ) {\n struct option_state * options ;\n struct option * option ;\n unsigned code ;\n int refcnt ;\n unsigned char buffer [ 3 ] = {\n 15 , 255 , 0 }\n ;\n initialize_common_option_spaces ( ) ;\n options = NULL ;\n if ( ! option_state_allocate ( & options , MDL ) ) {\n atf_tc_fail ( \"can't allocate option state\" ) ;\n }\n option = NULL ;\n code = 15 ;\n if ( ! option_code_hash_lookup ( & option , dhcp_universe . code_hash , & code , 0 , MDL ) ) {\n atf_tc_fail ( \"can't find option 15\" ) ;\n }\n if ( option == NULL ) {\n atf_tc_fail ( \"option is NULL\" ) ;\n }\n refcnt = option -> refcnt ;\n buffer [ 0 ] = 15 ;\n buffer [ 1 ] = 255 ;\n buffer [ 2 ] = 0 ;\n if ( parse_option_buffer ( options , buffer , 3 , & dhcp_universe ) ) {\n atf_tc_fail ( \"parse_option_buffer is expected to fail\" ) ;\n }\n if ( refcnt != option -> refcnt ) {\n atf_tc_fail ( \"refcnt changed from %d to %d\" , refcnt , option -> refcnt ) ;\n }\n }", "hash": -6379515734957310198, "project": "debian", "size": 32, "target": 0, "idx": 16421}
{"code": "static Image * ReadGIFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n # define BitSet ( byte , bit ) ( ( ( byte ) & ( bit ) ) == ( bit ) ) # define LSBFirstOrder ( x , y ) ( ( ( y ) << 8 ) | ( x ) ) Image * image , * meta_image ;\n int number_extensionss = 0 ;\n MagickBooleanType status ;\n RectangleInfo page ;\n register ssize_t i ;\n register unsigned char * p ;\n size_t delay , dispose , duration , global_colors , image_count , iterations , one ;\n ssize_t count , opacity ;\n unsigned char background , c , flag , * global_colormap , header [ MaxTextExtent ] , magick [ 12 ] ;\n assert ( image_info != ( const ImageInfo * ) NULL ) ;\n assert ( image_info -> signature == MagickSignature ) ;\n if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ;\n assert ( exception != ( ExceptionInfo * ) NULL ) ;\n assert ( exception -> signature == MagickSignature ) ;\n image = AcquireImage ( image_info ) ;\n status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ;\n if ( status == MagickFalse ) {\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n count = ReadBlob ( image , 6 , magick ) ;\n if ( ( count != 6 ) || ( ( LocaleNCompare ( ( char * ) magick , \"GIF87\" , 5 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , \"GIF89\" , 5 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ;\n page . width = ReadBlobLSBShort ( image ) ;\n page . height = ReadBlobLSBShort ( image ) ;\n flag = ( unsigned char ) ReadBlobByte ( image ) ;\n background = ( unsigned char ) ReadBlobByte ( image ) ;\n c = ( unsigned char ) ReadBlobByte ( image ) ;\n one = 1 ;\n global_colors = one << ( ( ( size_t ) flag & 0x07 ) + 1 ) ;\n global_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( global_colors , 256 ) , 3UL * sizeof ( * global_colormap ) ) ;\n if ( global_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap ) ) ;\n if ( BitSet ( ( int ) flag , 0x80 ) != 0 ) {\n count = ReadBlob ( image , ( size_t ) ( 3 * global_colors ) , global_colormap ) ;\n if ( count != ( ssize_t ) ( 3 * global_colors ) ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ;\n }\n }\n delay = 0 ;\n dispose = 0 ;\n duration = 0 ;\n iterations = 1 ;\n opacity = ( - 1 ) ;\n image_count = 0 ;\n meta_image = AcquireImage ( image_info ) ;\n for ( ;\n ;\n ) {\n count = ReadBlob ( image , 1 , & c ) ;\n if ( count != 1 ) break ;\n if ( c == ( unsigned char ) ';\n' ) break ;\n if ( c == ( unsigned char ) '!' ) {\n count = ReadBlob ( image , 1 , & c ) ;\n if ( count != 1 ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( CorruptImageError , \"UnableToReadExtensionBlock\" ) ;\n }\n switch ( c ) {\n case 0xf9 : {\n while ( ReadBlobBlock ( image , header ) != 0 ) ;\n dispose = ( size_t ) ( header [ 0 ] >> 2 ) ;\n delay = ( size_t ) ( ( header [ 2 ] << 8 ) | header [ 1 ] ) ;\n if ( ( ssize_t ) ( header [ 0 ] & 0x01 ) == 0x01 ) opacity = ( ssize_t ) header [ 3 ] ;\n break ;\n }\n case 0xfe : {\n char * comments ;\n size_t length ;\n comments = AcquireString ( ( char * ) NULL ) ;\n for ( length = 0 ;\n ;\n length += count ) {\n count = ReadBlobBlock ( image , header ) ;\n if ( count == 0 ) break ;\n header [ count ] = '\\0' ;\n ( void ) ConcatenateString ( & comments , ( const char * ) header ) ;\n }\n ( void ) SetImageProperty ( meta_image , \"comment\" , comments ) ;\n comments = DestroyString ( comments ) ;\n break ;\n }\n case 0xff : {\n MagickBooleanType loop ;\n loop = MagickFalse ;\n if ( ReadBlobBlock ( image , header ) != 0 ) loop = LocaleNCompare ( ( char * ) header , \"NETSCAPE2.0\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n if ( loop != MagickFalse ) {\n while ( ReadBlobBlock ( image , header ) != 0 ) iterations = ( size_t ) ( ( header [ 2 ] << 8 ) | header [ 1 ] ) ;\n break ;\n }\n else {\n char name [ MaxTextExtent ] ;\n int block_length , info_length , reserved_length ;\n MagickBooleanType i8bim , icc , iptc , magick ;\n StringInfo * profile ;\n unsigned char * info ;\n icc = LocaleNCompare ( ( char * ) header , \"ICCRGBG1012\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n magick = LocaleNCompare ( ( char * ) header , \"ImageMagick\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n i8bim = LocaleNCompare ( ( char * ) header , \"MGK8BIM0000\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n iptc = LocaleNCompare ( ( char * ) header , \"MGKIPTC0000\" , 11 ) == 0 ? MagickTrue : MagickFalse ;\n number_extensionss ++ ;\n ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \" Reading GIF application extension\" ) ;\n info = ( unsigned char * ) AcquireQuantumMemory ( 255UL , sizeof ( * info ) ) ;\n if ( info == ( unsigned char * ) NULL ) {\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n reserved_length = 255 ;\n for ( info_length = 0 ;\n ;\n ) {\n block_length = ( int ) ReadBlobBlock ( image , & info [ info_length ] ) ;\n if ( block_length == 0 ) break ;\n info_length += block_length ;\n if ( info_length > ( reserved_length - 255 ) ) {\n reserved_length += 4096 ;\n info = ( unsigned char * ) ResizeQuantumMemory ( info , ( size_t ) reserved_length , sizeof ( * info ) ) ;\n if ( info == ( unsigned char * ) NULL ) {\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n }\n }\n profile = BlobToStringInfo ( info , ( size_t ) info_length ) ;\n if ( profile == ( StringInfo * ) NULL ) {\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n if ( i8bim != MagickFalse ) ( void ) CopyMagickString ( name , \"8bim\" , sizeof ( name ) ) ;\n else if ( icc != MagickFalse ) ( void ) CopyMagickString ( name , \"icc\" , sizeof ( name ) ) ;\n else if ( iptc != MagickFalse ) ( void ) CopyMagickString ( name , \"iptc\" , sizeof ( name ) ) ;\n else if ( magick != MagickFalse ) {\n ( void ) CopyMagickString ( name , \"magick\" , sizeof ( name ) ) ;\n meta_image -> gamma = StringToDouble ( ( char * ) info + 6 , ( char * * ) NULL ) ;\n }\n else ( void ) FormatLocaleString ( name , sizeof ( name ) , \"gif:%.11s\" , header ) ;\n info = ( unsigned char * ) RelinquishMagickMemory ( info ) ;\n if ( magick == MagickFalse ) ( void ) SetImageProfile ( meta_image , name , profile ) ;\n profile = DestroyStringInfo ( profile ) ;\n ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \" profile name=%s\" , name ) ;\n }\n break ;\n }\n default : {\n while ( ReadBlobBlock ( image , header ) != 0 ) ;\n break ;\n }\n }\n }\n if ( c != ( unsigned char ) ',' ) continue ;\n if ( image_count != 0 ) {\n AcquireNextImage ( image_info , image ) ;\n if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {\n image = DestroyImageList ( image ) ;\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n return ( ( Image * ) NULL ) ;\n }\n image = SyncNextImageInList ( image ) ;\n }\n image_count ++ ;\n meta_image -> scene = image -> scene ;\n ( void ) CloneImageProperties ( image , meta_image ) ;\n DestroyImageProperties ( meta_image ) ;\n ( void ) CloneImageProfiles ( image , meta_image ) ;\n DestroyImageProfiles ( meta_image ) ;\n image -> storage_class = PseudoClass ;\n image -> compression = LZWCompression ;\n page . x = ( ssize_t ) ReadBlobLSBShort ( image ) ;\n page . y = ( ssize_t ) ReadBlobLSBShort ( image ) ;\n image -> columns = ReadBlobLSBShort ( image ) ;\n image -> rows = ReadBlobLSBShort ( image ) ;\n image -> depth = 8 ;\n flag = ( unsigned char ) ReadBlobByte ( image ) ;\n image -> interlace = BitSet ( ( int ) flag , 0x40 ) != 0 ? GIFInterlace : NoInterlace ;\n image -> colors = BitSet ( ( int ) flag , 0x80 ) == 0 ? global_colors : one << ( ( size_t ) ( flag & 0x07 ) + 1 ) ;\n if ( opacity >= ( ssize_t ) image -> colors ) opacity = ( - 1 ) ;\n image -> page . width = page . width ;\n image -> page . height = page . height ;\n image -> page . y = page . y ;\n image -> page . x = page . x ;\n image -> delay = delay ;\n image -> iterations = iterations ;\n image -> ticks_per_second = 100 ;\n image -> dispose = ( DisposeType ) dispose ;\n image -> matte = opacity >= 0 ? MagickTrue : MagickFalse ;\n delay = 0 ;\n dispose = 0 ;\n if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ;\n }\n if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n if ( BitSet ( ( int ) flag , 0x80 ) == 0 ) {\n p = global_colormap ;\n for ( i = 0 ;\n i < ( ssize_t ) image -> colors ;\n i ++ ) {\n image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ;\n image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ;\n image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ;\n if ( i == opacity ) {\n image -> colormap [ i ] . opacity = ( Quantum ) TransparentOpacity ;\n image -> transparent_color = image -> colormap [ opacity ] ;\n }\n }\n image -> background_color = image -> colormap [ MagickMin ( ( ssize_t ) background , ( ssize_t ) image -> colors - 1 ) ] ;\n }\n else {\n unsigned char * colormap ;\n colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , 3 * sizeof ( * colormap ) ) ;\n if ( colormap == ( unsigned char * ) NULL ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n count = ReadBlob ( image , ( 3 * image -> colors ) * sizeof ( * colormap ) , colormap ) ;\n if ( count != ( ssize_t ) ( 3 * image -> colors ) ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ;\n }\n p = colormap ;\n for ( i = 0 ;\n i < ( ssize_t ) image -> colors ;\n i ++ ) {\n image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ;\n image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ;\n image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ;\n if ( i == opacity ) image -> colormap [ i ] . opacity = ( Quantum ) TransparentOpacity ;\n }\n colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ;\n }\n if ( image -> gamma == 1.0 ) {\n for ( i = 0 ;\n i < ( ssize_t ) image -> colors ;\n i ++ ) if ( IsGrayPixel ( image -> colormap + i ) == MagickFalse ) break ;\n ( void ) SetImageColorspace ( image , i == ( ssize_t ) image -> colors ? GRAYColorspace : RGBColorspace ) ;\n }\n if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;\n status = SetImageExtent ( image , image -> columns , image -> rows ) ;\n if ( status == MagickFalse ) {\n InheritException ( exception , & image -> exception ) ;\n return ( DestroyImageList ( image ) ) ;\n }\n if ( image_info -> ping != MagickFalse ) status = PingGIFImage ( image ) ;\n else status = DecodeImage ( image , opacity ) ;\n if ( ( image_info -> ping == MagickFalse ) && ( status == MagickFalse ) ) {\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n meta_image = DestroyImage ( meta_image ) ;\n ThrowReaderException ( CorruptImageError , \"CorruptImage\" ) ;\n }\n duration += image -> delay * image -> iterations ;\n if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;\n opacity = ( - 1 ) ;\n status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) image -> scene - 1 , image -> scene ) ;\n if ( status == MagickFalse ) break ;\n }\n image -> duration = duration ;\n meta_image = DestroyImage ( meta_image ) ;\n global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ;\n if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , \"NegativeOrZeroImageSize\" ) ;\n ( void ) CloseBlob ( image ) ;\n return ( GetFirstImageInList ( image ) ) ;\n }", "hash": 6968788423709606113, "project": "debian", "size": 273, "target": 0, "idx": 16434}
{"code": "static inline void ResetLZWInfo ( LZWInfo * lzw_info ) {\n size_t one ;\n lzw_info -> bits = lzw_info -> data_size + 1 ;\n one = 1 ;\n lzw_info -> maximum_code = one << lzw_info -> bits ;\n lzw_info -> slot = lzw_info -> maximum_data_value + 3 ;\n lzw_info -> genesis = MagickTrue ;\n }", "hash": 6968788423709606113, "project": "debian", "size": 8, "target": 0, "idx": 16435}
{"code": "static int asf_write_trailer ( AVFormatContext * s ) {\n ASFContext * asf = s -> priv_data ;\n int64_t file_size , data_size ;\n int ret ;\n if ( asf -> pb . buf_ptr > asf -> pb . buffer ) flush_packet ( s ) ;\n data_size = avio_tell ( s -> pb ) ;\n if ( ! asf -> is_streamed && asf -> next_start_sec ) {\n if ( ( ret = update_index ( s , asf -> end_sec + 1 , 0 , 0 , 0 ) ) < 0 ) return ret ;\n asf_write_index ( s , asf -> index_ptr , asf -> maximum_packet , asf -> next_start_sec ) ;\n }\n avio_flush ( s -> pb ) ;\n if ( asf -> is_streamed || ! s -> pb -> seekable ) {\n put_chunk ( s , 0x4524 , 0 , 0 ) ;\n }\n else {\n file_size = avio_tell ( s -> pb ) ;\n avio_seek ( s -> pb , 0 , SEEK_SET ) ;\n asf_write_header1 ( s , file_size , data_size - asf -> data_offset ) ;\n }\n av_freep ( & asf -> index_ptr ) ;\n return 0 ;\n }", "hash": -5385892304146930196, "project": "debian", "size": 22, "target": 0, "idx": 16448}
{"code": "int remoteSendStreamData ( struct qemud_client * client , struct qemud_client_stream * stream , const char * data , unsigned int len ) {\n struct qemud_client_message * msg ;\n XDR xdr ;\n VIR_DEBUG ( \"client=%p stream=%p data=%p len=%d\" , client , stream , data , len ) ;\n if ( VIR_ALLOC ( msg ) < 0 ) {\n return - 1 ;\n }\n msg -> hdr . prog = REMOTE_PROGRAM ;\n msg -> hdr . vers = REMOTE_PROTOCOL_VERSION ;\n msg -> hdr . proc = stream -> procedure ;\n msg -> hdr . type = REMOTE_STREAM ;\n msg -> hdr . serial = stream -> serial ;\n msg -> hdr . status = data ? REMOTE_CONTINUE : REMOTE_OK ;\n if ( remoteEncodeClientMessageHeader ( msg ) < 0 ) goto fatal_error ;\n if ( data && len ) {\n if ( ( msg -> bufferLength - msg -> bufferOffset ) < len ) goto fatal_error ;\n xdrmem_create ( & xdr , msg -> buffer , msg -> bufferLength , XDR_ENCODE ) ;\n if ( xdr_setpos ( & xdr , msg -> bufferOffset ) == 0 ) goto xdr_error ;\n memcpy ( msg -> buffer + msg -> bufferOffset , data , len ) ;\n msg -> bufferOffset += len ;\n len = msg -> bufferOffset ;\n if ( xdr_setpos ( & xdr , 0 ) == 0 ) goto xdr_error ;\n if ( ! xdr_u_int ( & xdr , & len ) ) goto xdr_error ;\n xdr_destroy ( & xdr ) ;\n VIR_DEBUG ( \"Total %d\" , msg -> bufferOffset ) ;\n }\n if ( data ) msg -> streamTX = 1 ;\n msg -> bufferLength = msg -> bufferOffset ;\n msg -> bufferOffset = 0 ;\n qemudClientMessageQueuePush ( & client -> tx , msg ) ;\n qemudUpdateClientEvent ( client ) ;\n return 0 ;\n xdr_error : xdr_destroy ( & xdr ) ;\n fatal_error : VIR_FREE ( msg ) ;\n VIR_WARN ( \"Failed to serialize stream data for proc %d as XDR\" , stream -> procedure ) ;\n return - 1 ;\n }", "hash": 1535921111212871029, "project": "debian", "size": 37, "target": 0, "idx": 16469}
{"code": "static void remoteStreamUpdateEvents ( struct qemud_client_stream * stream ) {\n int newEvents = 0 ;\n if ( stream -> rx ) newEvents |= VIR_STREAM_EVENT_WRITABLE ;\n if ( stream -> tx && ! stream -> recvEOF ) newEvents |= VIR_STREAM_EVENT_READABLE ;\n virStreamEventUpdateCallback ( stream -> st , newEvents ) ;\n }", "hash": 7320640583188908680, "project": "debian", "size": 6, "target": 0, "idx": 16478}
{"code": "void do_device_add ( Monitor * mon , const QDict * qdict ) {\n QemuOpts * opts ;\n opts = qemu_opts_parse ( & qemu_device_opts , qdict_get_str ( qdict , \"config\" ) , \"driver\" ) ;\n if ( opts ) qdev_device_add ( opts ) ;\n }", "hash": 8484475213808847345, "project": "debian", "size": 5, "target": 0, "idx": 16534}
{"code": "int qdev_unplug ( DeviceState * dev ) {\n if ( ! dev -> parent_bus -> allow_hotplug ) {\n qemu_error ( \"Bus %s does not support hotplugging\\n\" , dev -> parent_bus -> name ) ;\n return - 1 ;\n }\n assert ( dev -> info -> unplug != NULL ) ;\n return dev -> info -> unplug ( dev ) ;\n }", "hash": 8484475213808847345, "project": "debian", "size": 8, "target": 0, "idx": 16540}
{"code": "static void qbus_list_dev ( BusState * bus , char * dest , int len ) {\n DeviceState * dev ;\n const char * sep = \" \" ;\n int pos = 0 ;\n pos += snprintf ( dest + pos , len - pos , \"devices at \\\"%s\\\":\" , bus -> name ) ;\n QLIST_FOREACH ( dev , & bus -> children , sibling ) {\n pos += snprintf ( dest + pos , len - pos , \"%s\\\"%s\\\"\" , sep , dev -> info -> name ) ;\n if ( dev -> id ) pos += snprintf ( dest + pos , len - pos , \"/\\\"%s\\\"\" , dev -> id ) ;\n sep = \", \" ;\n }\n }", "hash": 8484475213808847345, "project": "debian", "size": 11, "target": 0, "idx": 16549}
{"code": "static void s390_machine_init ( void ) {\n qemu_register_machine ( & s390_machine ) ;\n }", "hash": -5018047422955641881, "project": "debian", "size": 3, "target": 0, "idx": 16560}
{"code": "static int s390_virtio_serial_init ( VirtIOS390Device * dev ) {\n VirtIOS390Bus * bus ;\n VirtIODevice * vdev ;\n int r ;\n bus = DO_UPCAST ( VirtIOS390Bus , bus , dev -> qdev . parent_bus ) ;\n vdev = virtio_serial_init ( ( DeviceState * ) dev , dev -> max_virtserial_ports ) ;\n if ( ! vdev ) {\n return - 1 ;\n }\n r = s390_virtio_device_init ( dev , vdev ) ;\n if ( ! r ) {\n bus -> console = dev ;\n }\n return r ;\n }", "hash": 2419147764757351618, "project": "debian", "size": 15, "target": 0, "idx": 16563}
{"code": "static unsigned virtio_s390_get_features ( void * opaque ) {\n VirtIOS390Device * dev = ( VirtIOS390Device * ) opaque ;\n return dev -> host_features ;\n }", "hash": 2419147764757351618, "project": "debian", "size": 4, "target": 0, "idx": 16568}
{"code": "static int s390_virtio_busdev_init ( DeviceState * dev , DeviceInfo * info ) {\n VirtIOS390DeviceInfo * _info = ( VirtIOS390DeviceInfo * ) info ;\n VirtIOS390Device * _dev = ( VirtIOS390Device * ) dev ;\n return _info -> init ( _dev ) ;\n }", "hash": 2419147764757351618, "project": "debian", "size": 5, "target": 0, "idx": 16570}
{"code": "static int s390_virtio_net_init ( VirtIOS390Device * dev ) {\n VirtIODevice * vdev ;\n vdev = virtio_net_init ( ( DeviceState * ) dev , & dev -> nic ) ;\n if ( ! vdev ) {\n return - 1 ;\n }\n return s390_virtio_device_init ( dev , vdev ) ;\n }", "hash": 2419147764757351618, "project": "debian", "size": 8, "target": 0, "idx": 16571}
{"code": "static void virtio_s390_notify ( void * opaque , uint16_t vector ) {\n VirtIOS390Device * dev = ( VirtIOS390Device * ) opaque ;\n uint64_t token = s390_virtio_device_vq_token ( dev , vector ) ;\n kvm_s390_virtio_irq ( s390_cpu_addr2state ( 0 ) , 0 , token ) ;\n }", "hash": 2419147764757351618, "project": "debian", "size": 5, "target": 0, "idx": 16575}
{"code": "static uint32_t pmac_ide_readw ( void * opaque , hwaddr addr ) {\n uint16_t retval ;\n MACIOIDEState * d = opaque ;\n addr = ( addr & 0xFFF ) >> 4 ;\n if ( addr == 0 ) {\n retval = ide_data_readw ( & d -> bus , 0 ) ;\n }\n else {\n retval = 0xFFFF ;\n }\n retval = bswap16 ( retval ) ;\n return retval ;\n }", "hash": -2127895299879503273, "project": "debian", "size": 13, "target": 0, "idx": 16592}
{"code": "static uint32_t pmac_ide_readb ( void * opaque , hwaddr addr ) {\n uint8_t retval ;\n MACIOIDEState * d = opaque ;\n addr = ( addr & 0xFFF ) >> 4 ;\n switch ( addr ) {\n case 1 ... 7 : retval = ide_ioport_read ( & d -> bus , addr ) ;\n break ;\n case 8 : case 22 : retval = ide_status_read ( & d -> bus , 0 ) ;\n break ;\n default : retval = 0xFF ;\n break ;\n }\n return retval ;\n }", "hash": -2127895299879503273, "project": "debian", "size": 14, "target": 0, "idx": 16600}
{"code": "static void vga_draw_line8 ( VGACommonState * vga , uint8_t * d , uint32_t addr , int width ) {\n uint32_t * palette ;\n int x ;\n palette = vga -> last_palette ;\n width >>= 3 ;\n for ( x = 0 ;\n x < width ;\n x ++ ) {\n ( ( uint32_t * ) d ) [ 0 ] = palette [ vga_read_byte ( vga , addr + 0 ) ] ;\n ( ( uint32_t * ) d ) [ 1 ] = palette [ vga_read_byte ( vga , addr + 1 ) ] ;\n ( ( uint32_t * ) d ) [ 2 ] = palette [ vga_read_byte ( vga , addr + 2 ) ] ;\n ( ( uint32_t * ) d ) [ 3 ] = palette [ vga_read_byte ( vga , addr + 3 ) ] ;\n ( ( uint32_t * ) d ) [ 4 ] = palette [ vga_read_byte ( vga , addr + 4 ) ] ;\n ( ( uint32_t * ) d ) [ 5 ] = palette [ vga_read_byte ( vga , addr + 5 ) ] ;\n ( ( uint32_t * ) d ) [ 6 ] = palette [ vga_read_byte ( vga , addr + 6 ) ] ;\n ( ( uint32_t * ) d ) [ 7 ] = palette [ vga_read_byte ( vga , addr + 7 ) ] ;\n d += 32 ;\n addr += 8 ;\n }\n }", "hash": 369115599810341094, "project": "debian", "size": 20, "target": 0, "idx": 16626}
{"code": "static void vga_draw_line32_le ( VGACommonState * vga , uint8_t * d , uint32_t addr , int width ) {\n int w ;\n uint32_t r , g , b ;\n w = width ;\n do {\n b = vga_read_byte ( vga , addr + 0 ) ;\n g = vga_read_byte ( vga , addr + 1 ) ;\n r = vga_read_byte ( vga , addr + 2 ) ;\n ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;\n addr += 4 ;\n d += 4 ;\n }\n while ( -- w != 0 ) ;\n }", "hash": 369115599810341094, "project": "debian", "size": 14, "target": 0, "idx": 16628}
{"code": "static inline void vga_draw_glyph_line ( uint8_t * d , uint32_t font_data , uint32_t xorcol , uint32_t bgcol ) {\n ( ( uint32_t * ) d ) [ 0 ] = ( - ( ( font_data >> 7 ) ) & xorcol ) ^ bgcol ;\n ( ( uint32_t * ) d ) [ 1 ] = ( - ( ( font_data >> 6 ) & 1 ) & xorcol ) ^ bgcol ;\n ( ( uint32_t * ) d ) [ 2 ] = ( - ( ( font_data >> 5 ) & 1 ) & xorcol ) ^ bgcol ;\n ( ( uint32_t * ) d ) [ 3 ] = ( - ( ( font_data >> 4 ) & 1 ) & xorcol ) ^ bgcol ;\n ( ( uint32_t * ) d ) [ 4 ] = ( - ( ( font_data >> 3 ) & 1 ) & xorcol ) ^ bgcol ;\n ( ( uint32_t * ) d ) [ 5 ] = ( - ( ( font_data >> 2 ) & 1 ) & xorcol ) ^ bgcol ;\n ( ( uint32_t * ) d ) [ 6 ] = ( - ( ( font_data >> 1 ) & 1 ) & xorcol ) ^ bgcol ;\n ( ( uint32_t * ) d ) [ 7 ] = ( - ( ( font_data >> 0 ) & 1 ) & xorcol ) ^ bgcol ;\n }", "hash": 369115599810341094, "project": "debian", "size": 10, "target": 0, "idx": 16642}
{"code": "static void vga_draw_glyph16 ( uint8_t * d , int linesize , const uint8_t * font_ptr , int h , uint32_t fgcol , uint32_t bgcol ) {\n uint32_t font_data , xorcol ;\n xorcol = bgcol ^ fgcol ;\n do {\n font_data = font_ptr [ 0 ] ;\n vga_draw_glyph_line ( d , expand4to8 [ font_data >> 4 ] , xorcol , bgcol ) ;\n vga_draw_glyph_line ( d + 32 , expand4to8 [ font_data & 0x0f ] , xorcol , bgcol ) ;\n font_ptr += 4 ;\n d += linesize ;\n }\n while ( -- h ) ;\n }", "hash": 369115599810341094, "project": "debian", "size": 12, "target": 0, "idx": 16643}
{"code": "static int cine_read_probe ( AVProbeData * p ) {\n int HeaderSize ;\n if ( p -> buf [ 0 ] == 'C' && p -> buf [ 1 ] == 'I' && ( HeaderSize = AV_RL16 ( p -> buf + 2 ) ) >= 0x2C && AV_RL16 ( p -> buf + 4 ) <= CC_UNINT && AV_RL16 ( p -> buf + 6 ) <= 1 && AV_RL32 ( p -> buf + 20 ) && AV_RL32 ( p -> buf + 24 ) >= HeaderSize && AV_RL32 ( p -> buf + 28 ) >= HeaderSize && AV_RL32 ( p -> buf + 32 ) >= HeaderSize ) return AVPROBE_SCORE_MAX ;\n return 0 ;\n }", "hash": 136942900289772931, "project": "debian", "size": 5, "target": 0, "idx": 16649}
{"code": "static void uiserver_set_io_cbs ( void * engine , gpgme_io_cbs_t io_cbs ) {\n engine_uiserver_t uiserver = engine ;\n uiserver -> io_cbs = * io_cbs ;\n }", "hash": -769658847024738738, "project": "debian", "size": 4, "target": 0, "idx": 16659}
{"code": "static void uiserver_set_status_handler ( void * engine , engine_status_handler_t fnc , void * fnc_value ) {\n engine_uiserver_t uiserver = engine ;\n uiserver -> status . fnc = fnc ;\n uiserver -> status . fnc_value = fnc_value ;\n }", "hash": -769658847024738738, "project": "debian", "size": 5, "target": 0, "idx": 16666}
{"code": "static void uiserver_io_event ( void * engine , gpgme_event_io_t type , void * type_data ) {\n engine_uiserver_t uiserver = engine ;\n TRACE3 ( DEBUG_ENGINE , \"gpgme:uiserver_io_event\" , uiserver , \"event %p, type %d, type_data %p\" , uiserver -> io_cbs . event , type , type_data ) ;\n if ( uiserver -> io_cbs . event ) ( * uiserver -> io_cbs . event ) ( uiserver -> io_cbs . event_priv , type , type_data ) ;\n }", "hash": -769658847024738738, "project": "debian", "size": 5, "target": 0, "idx": 16674}
{"code": "static gpgme_error_t gpgsm_new ( void * * engine , const char * file_name , const char * home_dir ) {\n gpgme_error_t err = 0 ;\n engine_gpgsm_t gpgsm ;\n const char * pgmname ;\n const char * argv [ 5 ] ;\n int argc ;\n # if ! USE_DESCRIPTOR_PASSING int fds [ 2 ] ;\n int child_fds [ 4 ] ;\n # endif char * dft_display = NULL ;\n char dft_ttyname [ 64 ] ;\n char * dft_ttytype = NULL ;\n char * optstr ;\n gpgsm = calloc ( 1 , sizeof * gpgsm ) ;\n if ( ! gpgsm ) return gpg_error_from_syserror ( ) ;\n gpgsm -> status_cb . fd = - 1 ;\n gpgsm -> status_cb . dir = 1 ;\n gpgsm -> status_cb . tag = 0 ;\n gpgsm -> status_cb . data = gpgsm ;\n gpgsm -> input_cb . fd = - 1 ;\n gpgsm -> input_cb . dir = 0 ;\n gpgsm -> input_cb . tag = 0 ;\n gpgsm -> input_cb . server_fd = - 1 ;\n * gpgsm -> input_cb . server_fd_str = 0 ;\n gpgsm -> output_cb . fd = - 1 ;\n gpgsm -> output_cb . dir = 1 ;\n gpgsm -> output_cb . tag = 0 ;\n gpgsm -> output_cb . server_fd = - 1 ;\n * gpgsm -> output_cb . server_fd_str = 0 ;\n gpgsm -> message_cb . fd = - 1 ;\n gpgsm -> message_cb . dir = 0 ;\n gpgsm -> message_cb . tag = 0 ;\n gpgsm -> message_cb . server_fd = - 1 ;\n * gpgsm -> message_cb . server_fd_str = 0 ;\n gpgsm -> status . fnc = 0 ;\n gpgsm -> colon . fnc = 0 ;\n gpgsm -> colon . attic . line = 0 ;\n gpgsm -> colon . attic . linesize = 0 ;\n gpgsm -> colon . attic . linelen = 0 ;\n gpgsm -> colon . any = 0 ;\n gpgsm -> inline_data = NULL ;\n gpgsm -> io_cbs . add = NULL ;\n gpgsm -> io_cbs . add_priv = NULL ;\n gpgsm -> io_cbs . remove = NULL ;\n gpgsm -> io_cbs . event = NULL ;\n gpgsm -> io_cbs . event_priv = NULL ;\n # if ! USE_DESCRIPTOR_PASSING if ( _gpgme_io_pipe ( fds , 0 ) < 0 ) {\n err = gpg_error_from_syserror ( ) ;\n goto leave ;\n }\n gpgsm -> input_cb . fd = fds [ 1 ] ;\n gpgsm -> input_cb . server_fd = fds [ 0 ] ;\n if ( _gpgme_io_pipe ( fds , 1 ) < 0 ) {\n err = gpg_error_from_syserror ( ) ;\n goto leave ;\n }\n gpgsm -> output_cb . fd = fds [ 0 ] ;\n gpgsm -> output_cb . server_fd = fds [ 1 ] ;\n if ( _gpgme_io_pipe ( fds , 0 ) < 0 ) {\n err = gpg_error_from_syserror ( ) ;\n goto leave ;\n }\n gpgsm -> message_cb . fd = fds [ 1 ] ;\n gpgsm -> message_cb . server_fd = fds [ 0 ] ;\n child_fds [ 0 ] = gpgsm -> input_cb . server_fd ;\n child_fds [ 1 ] = gpgsm -> output_cb . server_fd ;\n child_fds [ 2 ] = gpgsm -> message_cb . server_fd ;\n child_fds [ 3 ] = - 1 ;\n # endif pgmname = file_name ? file_name : _gpgme_get_default_gpgsm_name ( ) ;\n argc = 0 ;\n argv [ argc ++ ] = _gpgme_get_basename ( pgmname ) ;\n if ( home_dir ) {\n argv [ argc ++ ] = \"--homedir\" ;\n argv [ argc ++ ] = home_dir ;\n }\n argv [ argc ++ ] = \"--server\" ;\n argv [ argc ++ ] = NULL ;\n err = assuan_new_ext ( & gpgsm -> assuan_ctx , GPG_ERR_SOURCE_GPGME , & _gpgme_assuan_malloc_hooks , _gpgme_assuan_log_cb , NULL ) ;\n if ( err ) goto leave ;\n assuan_ctx_set_system_hooks ( gpgsm -> assuan_ctx , & _gpgme_assuan_system_hooks ) ;\n # if USE_DESCRIPTOR_PASSING err = assuan_pipe_connect ( gpgsm -> assuan_ctx , pgmname , argv , NULL , NULL , NULL , ASSUAN_PIPE_CONNECT_FDPASSING ) ;\n # else {\n assuan_fd_t achild_fds [ 4 ] ;\n int i ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) achild_fds [ i ] = ( assuan_fd_t ) child_fds [ i ] ;\n err = assuan_pipe_connect ( gpgsm -> assuan_ctx , pgmname , argv , achild_fds , NULL , NULL , 0 ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) child_fds [ i ] = ( int ) achild_fds [ i ] ;\n }\n if ( ! err ) {\n snprintf ( gpgsm -> input_cb . server_fd_str , sizeof gpgsm -> input_cb . server_fd_str , \"%d\" , child_fds [ 0 ] ) ;\n snprintf ( gpgsm -> output_cb . server_fd_str , sizeof gpgsm -> output_cb . server_fd_str , \"%d\" , child_fds [ 1 ] ) ;\n snprintf ( gpgsm -> message_cb . server_fd_str , sizeof gpgsm -> message_cb . server_fd_str , \"%d\" , child_fds [ 2 ] ) ;\n }\n # endif if ( err ) goto leave ;\n err = _gpgme_getenv ( \"DISPLAY\" , & dft_display ) ;\n if ( err ) goto leave ;\n if ( dft_display ) {\n if ( asprintf ( & optstr , \"OPTION display=%s\" , dft_display ) < 0 ) {\n free ( dft_display ) ;\n err = gpg_error_from_syserror ( ) ;\n goto leave ;\n }\n free ( dft_display ) ;\n err = assuan_transact ( gpgsm -> assuan_ctx , optstr , NULL , NULL , NULL , NULL , NULL , NULL ) ;\n free ( optstr ) ;\n if ( err ) goto leave ;\n }\n if ( isatty ( 1 ) ) {\n int rc ;\n rc = ttyname_r ( 1 , dft_ttyname , sizeof ( dft_ttyname ) ) ;\n if ( rc ) {\n err = gpg_error_from_errno ( rc ) ;\n goto leave ;\n }\n else {\n if ( asprintf ( & optstr , \"OPTION ttyname=%s\" , dft_ttyname ) < 0 ) {\n err = gpg_error_from_syserror ( ) ;\n goto leave ;\n }\n err = assuan_transact ( gpgsm -> assuan_ctx , optstr , NULL , NULL , NULL , NULL , NULL , NULL ) ;\n free ( optstr ) ;\n if ( err ) goto leave ;\n err = _gpgme_getenv ( \"TERM\" , & dft_ttytype ) ;\n if ( err ) goto leave ;\n if ( dft_ttytype ) {\n if ( asprintf ( & optstr , \"OPTION ttytype=%s\" , dft_ttytype ) < 0 ) {\n free ( dft_ttytype ) ;\n err = gpg_error_from_syserror ( ) ;\n goto leave ;\n }\n free ( dft_ttytype ) ;\n err = assuan_transact ( gpgsm -> assuan_ctx , optstr , NULL , NULL , NULL , NULL , NULL , NULL ) ;\n free ( optstr ) ;\n if ( err ) goto leave ;\n }\n }\n }\n if ( ! err ) {\n err = assuan_transact ( gpgsm -> assuan_ctx , \"OPTION enable-audit-log=1\" , NULL , NULL , NULL , NULL , NULL , NULL ) ;\n if ( gpg_err_code ( err ) == GPG_ERR_UNKNOWN_OPTION ) err = 0 ;\n }\n # ifdef HAVE_W32_SYSTEM if ( ! err ) {\n err = assuan_transact ( gpgsm -> assuan_ctx , \"OPTION allow-pinentry-notify\" , NULL , NULL , NULL , NULL , NULL , NULL ) ;\n if ( gpg_err_code ( err ) == GPG_ERR_UNKNOWN_OPTION ) err = 0 ;\n }\n # endif # if ! USE_DESCRIPTOR_PASSING if ( ! err && ( _gpgme_io_set_close_notify ( gpgsm -> input_cb . fd , close_notify_handler , gpgsm ) || _gpgme_io_set_close_notify ( gpgsm -> output_cb . fd , close_notify_handler , gpgsm ) || _gpgme_io_set_close_notify ( gpgsm -> message_cb . fd , close_notify_handler , gpgsm ) ) ) {\n err = gpg_error ( GPG_ERR_GENERAL ) ;\n goto leave ;\n }\n # endif leave : # if ! USE_DESCRIPTOR_PASSING if ( gpgsm -> input_cb . server_fd != - 1 ) _gpgme_io_close ( gpgsm -> input_cb . server_fd ) ;\n if ( gpgsm -> output_cb . server_fd != - 1 ) _gpgme_io_close ( gpgsm -> output_cb . server_fd ) ;\n if ( gpgsm -> message_cb . server_fd != - 1 ) _gpgme_io_close ( gpgsm -> message_cb . server_fd ) ;\n # endif if ( err ) gpgsm_release ( gpgsm ) ;\n else * engine = gpgsm ;\n return err ;\n }", "hash": -2386031673786599357, "project": "debian", "size": 159, "target": 0, "idx": 16680}
{"code": "static gpgme_error_t gpgsm_assuan_simple_command ( assuan_context_t ctx , char * cmd , engine_status_handler_t status_fnc , void * status_fnc_value ) {\n gpg_error_t err ;\n char * line ;\n size_t linelen ;\n err = assuan_write_line ( ctx , cmd ) ;\n if ( err ) return err ;\n do {\n err = assuan_read_line ( ctx , & line , & linelen ) ;\n if ( err ) return err ;\n if ( * line == '#' || ! linelen ) continue ;\n if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\\0' || line [ 2 ] == ' ' ) ) return 0 ;\n else if ( linelen >= 4 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n else if ( linelen >= 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n char * rest ;\n gpgme_status_code_t r ;\n rest = strchr ( line + 2 , ' ' ) ;\n if ( ! rest ) rest = line + linelen ;\n else * ( rest ++ ) = 0 ;\n r = _gpgme_parse_status ( line + 2 ) ;\n if ( r >= 0 && status_fnc ) err = status_fnc ( status_fnc_value , r , rest ) ;\n else err = gpg_error ( GPG_ERR_GENERAL ) ;\n }\n else err = gpg_error ( GPG_ERR_GENERAL ) ;\n }\n while ( ! err ) ;\n return err ;\n }", "hash": -2386031673786599357, "project": "debian", "size": 27, "target": 0, "idx": 16707}
{"code": "struct crypto_instance * crypto_init ( const unsigned char * private_key , unsigned int private_key_len , const char * crypto_cipher_type , const char * crypto_hash_type , void ( * log_printf_func ) ( int level , int subsys , const char * function , const char * file , int line , const char * format , ... ) __attribute__ ( ( format ( printf , 6 , 7 ) ) ) , int log_level_security , int log_level_notice , int log_level_error , int log_subsys_id ) {\n struct crypto_instance * instance ;\n instance = malloc ( sizeof ( * instance ) ) ;\n if ( instance == NULL ) {\n return ( NULL ) ;\n }\n memset ( instance , 0 , sizeof ( struct crypto_instance ) ) ;\n memcpy ( instance -> private_key , private_key , private_key_len ) ;\n instance -> private_key_len = private_key_len ;\n instance -> crypto_cipher_type = string_to_crypto_cipher_type ( crypto_cipher_type ) ;\n instance -> crypto_hash_type = string_to_crypto_hash_type ( crypto_hash_type ) ;\n instance -> crypto_header_size = crypto_sec_header_size ( crypto_cipher_type , crypto_hash_type ) ;\n instance -> log_printf_func = log_printf_func ;\n instance -> log_level_security = log_level_security ;\n instance -> log_level_notice = log_level_notice ;\n instance -> log_level_error = log_level_error ;\n instance -> log_subsys_id = log_subsys_id ;\n if ( init_nss ( instance , crypto_cipher_type , crypto_hash_type ) < 0 ) {\n free ( instance ) ;\n return ( NULL ) ;\n }\n return ( instance ) ;\n }", "hash": 3755875528583281641, "project": "debian", "size": 23, "target": 0, "idx": 16709}
{"code": "static int authenticate_nss_2_3 ( struct crypto_instance * instance , unsigned char * buf , int * buf_len ) {\n if ( hash_to_nss [ instance -> crypto_hash_type ] ) {\n unsigned char tmp_hash [ hash_len [ instance -> crypto_hash_type ] ] ;\n int datalen = * buf_len - hash_len [ instance -> crypto_hash_type ] ;\n if ( * buf_len <= hash_len [ instance -> crypto_hash_type ] ) {\n log_printf ( instance -> log_level_security , \"Received message is too short... ignoring\" ) ;\n return - 1 ;\n }\n if ( calculate_nss_hash ( instance , buf , datalen , tmp_hash ) < 0 ) {\n return - 1 ;\n }\n if ( memcmp ( tmp_hash , buf + datalen , hash_len [ instance -> crypto_hash_type ] ) != 0 ) {\n log_printf ( instance -> log_level_error , \"Digest does not match\" ) ;\n return - 1 ;\n }\n * buf_len = datalen ;\n }\n return 0 ;\n }", "hash": 3755875528583281641, "project": "debian", "size": 19, "target": 0, "idx": 16721}
{"code": "int crypto_encrypt_and_sign ( struct crypto_instance * instance , const unsigned char * buf_in , const size_t buf_in_len , unsigned char * buf_out , size_t * buf_out_len ) {\n struct crypto_config_header * cch = ( struct crypto_config_header * ) buf_out ;\n int err ;\n cch -> crypto_cipher_type = CRYPTO_CIPHER_TYPE_2_3 ;\n cch -> crypto_hash_type = CRYPTO_HASH_TYPE_2_3 ;\n cch -> __pad0 = 0 ;\n cch -> __pad1 = 0 ;\n err = encrypt_and_sign_nss_2_3 ( instance , buf_in , buf_in_len , buf_out , buf_out_len ) ;\n return err ;\n }", "hash": 3755875528583281641, "project": "debian", "size": 10, "target": 0, "idx": 16724}
{"code": "static VALUE decode_int ( unsigned char * der , long length ) {\n ASN1_INTEGER * ai ;\n const unsigned char * p ;\n VALUE ret ;\n int status = 0 ;\n p = der ;\n if ( ! ( ai = d2i_ASN1_INTEGER ( NULL , & p , length ) ) ) ossl_raise ( eASN1Error , NULL ) ;\n ret = rb_protect ( ( VALUE ( * ) ( VALUE ) ) asn1integer_to_num , ( VALUE ) ai , & status ) ;\n ASN1_INTEGER_free ( ai ) ;\n if ( status ) rb_jump_tag ( status ) ;\n return ret ;\n }", "hash": 7549435794356072684, "project": "debian", "size": 12, "target": 0, "idx": 16741}
{"code": "static ASN1_INTEGER * obj_to_asn1int ( VALUE obj ) {\n return num_to_asn1integer ( obj , NULL ) ;\n }", "hash": 7549435794356072684, "project": "debian", "size": 3, "target": 0, "idx": 16748}
{"code": "static VALUE decode_bstr ( unsigned char * der , long length , long * unused_bits ) {\n ASN1_BIT_STRING * bstr ;\n const unsigned char * p ;\n long len ;\n VALUE ret ;\n p = der ;\n if ( ! ( bstr = d2i_ASN1_BIT_STRING ( NULL , & p , length ) ) ) ossl_raise ( eASN1Error , NULL ) ;\n len = bstr -> length ;\n * unused_bits = 0 ;\n if ( bstr -> flags & ASN1_STRING_FLAG_BITS_LEFT ) * unused_bits = bstr -> flags & 0x07 ;\n ret = rb_str_new ( ( const char * ) bstr -> data , len ) ;\n ASN1_BIT_STRING_free ( bstr ) ;\n return ret ;\n }", "hash": 7549435794356072684, "project": "debian", "size": 14, "target": 0, "idx": 16778}
{"code": "static VALUE decode_obj ( unsigned char * der , long length ) {\n ASN1_OBJECT * obj ;\n const unsigned char * p ;\n VALUE ret ;\n int nid ;\n BIO * bio ;\n p = der ;\n if ( ! ( obj = d2i_ASN1_OBJECT ( NULL , & p , length ) ) ) ossl_raise ( eASN1Error , NULL ) ;\n if ( ( nid = OBJ_obj2nid ( obj ) ) != NID_undef ) {\n ASN1_OBJECT_free ( obj ) ;\n ret = rb_str_new2 ( OBJ_nid2sn ( nid ) ) ;\n }\n else {\n if ( ! ( bio = BIO_new ( BIO_s_mem ( ) ) ) ) {\n ASN1_OBJECT_free ( obj ) ;\n ossl_raise ( eASN1Error , NULL ) ;\n }\n i2a_ASN1_OBJECT ( bio , obj ) ;\n ASN1_OBJECT_free ( obj ) ;\n ret = ossl_membio2str ( bio ) ;\n }\n return ret ;\n }", "hash": 7549435794356072684, "project": "debian", "size": 23, "target": 0, "idx": 16779}
{"code": "void Init_ossl_asn1 ( void ) {\n VALUE ary ;\n int i ;\n # if 0 mOSSL = rb_define_module ( \"OpenSSL\" ) ;\n eOSSLError = rb_define_class_under ( mOSSL , \"OpenSSLError\" , rb_eStandardError ) ;\n # endif sym_UNIVERSAL = ID2SYM ( rb_intern_const ( \"UNIVERSAL\" ) ) ;\n sym_CONTEXT_SPECIFIC = ID2SYM ( rb_intern_const ( \"CONTEXT_SPECIFIC\" ) ) ;\n sym_APPLICATION = ID2SYM ( rb_intern_const ( \"APPLICATION\" ) ) ;\n sym_PRIVATE = ID2SYM ( rb_intern_const ( \"PRIVATE\" ) ) ;\n sym_EXPLICIT = ID2SYM ( rb_intern_const ( \"EXPLICIT\" ) ) ;\n sym_IMPLICIT = ID2SYM ( rb_intern_const ( \"IMPLICIT\" ) ) ;\n sivVALUE = rb_intern ( \"@value\" ) ;\n sivTAG = rb_intern ( \"@tag\" ) ;\n sivTAGGING = rb_intern ( \"@tagging\" ) ;\n sivTAG_CLASS = rb_intern ( \"@tag_class\" ) ;\n sivINFINITE_LENGTH = rb_intern ( \"@infinite_length\" ) ;\n sivUNUSED_BITS = rb_intern ( \"@unused_bits\" ) ;\n mASN1 = rb_define_module_under ( mOSSL , \"ASN1\" ) ;\n eASN1Error = rb_define_class_under ( mASN1 , \"ASN1Error\" , eOSSLError ) ;\n rb_define_module_function ( mASN1 , \"traverse\" , ossl_asn1_traverse , 1 ) ;\n rb_define_module_function ( mASN1 , \"decode\" , ossl_asn1_decode , 1 ) ;\n rb_define_module_function ( mASN1 , \"decode_all\" , ossl_asn1_decode_all , 1 ) ;\n ary = rb_ary_new ( ) ;\n rb_define_const ( mASN1 , \"UNIVERSAL_TAG_NAME\" , ary ) ;\n for ( i = 0 ;\n i < ossl_asn1_info_size ;\n i ++ ) {\n if ( ossl_asn1_info [ i ] . name [ 0 ] == '[' ) continue ;\n rb_define_const ( mASN1 , ossl_asn1_info [ i ] . name , INT2NUM ( i ) ) ;\n rb_ary_store ( ary , i , rb_str_new2 ( ossl_asn1_info [ i ] . name ) ) ;\n }\n cASN1Data = rb_define_class_under ( mASN1 , \"ASN1Data\" , rb_cObject ) ;\n rb_attr ( cASN1Data , rb_intern ( \"value\" ) , 1 , 1 , 0 ) ;\n rb_attr ( cASN1Data , rb_intern ( \"tag\" ) , 1 , 1 , 0 ) ;\n rb_attr ( cASN1Data , rb_intern ( \"tag_class\" ) , 1 , 1 , 0 ) ;\n rb_attr ( cASN1Data , rb_intern ( \"infinite_length\" ) , 1 , 1 , 0 ) ;\n rb_define_method ( cASN1Data , \"initialize\" , ossl_asn1data_initialize , 3 ) ;\n rb_define_method ( cASN1Data , \"to_der\" , ossl_asn1data_to_der , 0 ) ;\n cASN1Primitive = rb_define_class_under ( mASN1 , \"Primitive\" , cASN1Data ) ;\n rb_attr ( cASN1Primitive , rb_intern ( \"tagging\" ) , 1 , 1 , Qtrue ) ;\n rb_undef_method ( cASN1Primitive , \"infinite_length=\" ) ;\n rb_define_method ( cASN1Primitive , \"initialize\" , ossl_asn1_initialize , - 1 ) ;\n rb_define_method ( cASN1Primitive , \"to_der\" , ossl_asn1prim_to_der , 0 ) ;\n cASN1Constructive = rb_define_class_under ( mASN1 , \"Constructive\" , cASN1Data ) ;\n rb_include_module ( cASN1Constructive , rb_mEnumerable ) ;\n rb_attr ( cASN1Constructive , rb_intern ( \"tagging\" ) , 1 , 1 , Qtrue ) ;\n rb_define_method ( cASN1Constructive , \"initialize\" , ossl_asn1_initialize , - 1 ) ;\n rb_define_method ( cASN1Constructive , \"to_der\" , ossl_asn1cons_to_der , 0 ) ;\n rb_define_method ( cASN1Constructive , \"each\" , ossl_asn1cons_each , 0 ) ;\n # define OSSL_ASN1_DEFINE_CLASS ( name , super ) do {\n cASN1 ## name = rb_define_class_under ( mASN1 , # name , cASN1 ## super ) ;\n rb_define_module_function ( mASN1 , # name , ossl_asn1_ ## name , - 1 ) ;\n \\ }\n while ( 0 ) OSSL_ASN1_DEFINE_CLASS ( Boolean , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( Integer , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( Enumerated , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( BitString , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( OctetString , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( UTF8String , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( NumericString , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( PrintableString , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( T61String , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( VideotexString , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( IA5String , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( GraphicString , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( ISO64String , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( GeneralString , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( UniversalString , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( BMPString , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( Null , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( ObjectId , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( UTCTime , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( GeneralizedTime , Primitive ) ;\n OSSL_ASN1_DEFINE_CLASS ( Sequence , Constructive ) ;\n OSSL_ASN1_DEFINE_CLASS ( Set , Constructive ) ;\n OSSL_ASN1_DEFINE_CLASS ( EndOfContent , Data ) ;\n # if 0 cASN1ObjectId = rb_define_class_under ( mASN1 , \"ObjectId\" , cASN1Primitive ) ;\n # endif rb_define_singleton_method ( cASN1ObjectId , \"register\" , ossl_asn1obj_s_register , 3 ) ;\n rb_define_method ( cASN1ObjectId , \"sn\" , ossl_asn1obj_get_sn , 0 ) ;\n rb_define_method ( cASN1ObjectId , \"ln\" , ossl_asn1obj_get_ln , 0 ) ;\n rb_define_method ( cASN1ObjectId , \"oid\" , ossl_asn1obj_get_oid , 0 ) ;\n rb_define_alias ( cASN1ObjectId , \"short_name\" , \"sn\" ) ;\n rb_define_alias ( cASN1ObjectId , \"long_name\" , \"ln\" ) ;\n rb_attr ( cASN1BitString , rb_intern ( \"unused_bits\" ) , 1 , 1 , 0 ) ;\n rb_define_method ( cASN1EndOfContent , \"initialize\" , ossl_asn1eoc_initialize , 0 ) ;\n class_tag_map = rb_hash_new ( ) ;\n rb_hash_aset ( class_tag_map , cASN1EndOfContent , INT2NUM ( V_ASN1_EOC ) ) ;\n rb_hash_aset ( class_tag_map , cASN1Boolean , INT2NUM ( V_ASN1_BOOLEAN ) ) ;\n rb_hash_aset ( class_tag_map , cASN1Integer , INT2NUM ( V_ASN1_INTEGER ) ) ;\n rb_hash_aset ( class_tag_map , cASN1BitString , INT2NUM ( V_ASN1_BIT_STRING ) ) ;\n rb_hash_aset ( class_tag_map , cASN1OctetString , INT2NUM ( V_ASN1_OCTET_STRING ) ) ;\n rb_hash_aset ( class_tag_map , cASN1Null , INT2NUM ( V_ASN1_NULL ) ) ;\n rb_hash_aset ( class_tag_map , cASN1ObjectId , INT2NUM ( V_ASN1_OBJECT ) ) ;\n rb_hash_aset ( class_tag_map , cASN1Enumerated , INT2NUM ( V_ASN1_ENUMERATED ) ) ;\n rb_hash_aset ( class_tag_map , cASN1UTF8String , INT2NUM ( V_ASN1_UTF8STRING ) ) ;\n rb_hash_aset ( class_tag_map , cASN1Sequence , INT2NUM ( V_ASN1_SEQUENCE ) ) ;\n rb_hash_aset ( class_tag_map , cASN1Set , INT2NUM ( V_ASN1_SET ) ) ;\n rb_hash_aset ( class_tag_map , cASN1NumericString , INT2NUM ( V_ASN1_NUMERICSTRING ) ) ;\n rb_hash_aset ( class_tag_map , cASN1PrintableString , INT2NUM ( V_ASN1_PRINTABLESTRING ) ) ;\n rb_hash_aset ( class_tag_map , cASN1T61String , INT2NUM ( V_ASN1_T61STRING ) ) ;\n rb_hash_aset ( class_tag_map , cASN1VideotexString , INT2NUM ( V_ASN1_VIDEOTEXSTRING ) ) ;\n rb_hash_aset ( class_tag_map , cASN1IA5String , INT2NUM ( V_ASN1_IA5STRING ) ) ;\n rb_hash_aset ( class_tag_map , cASN1UTCTime , INT2NUM ( V_ASN1_UTCTIME ) ) ;\n rb_hash_aset ( class_tag_map , cASN1GeneralizedTime , INT2NUM ( V_ASN1_GENERALIZEDTIME ) ) ;\n rb_hash_aset ( class_tag_map , cASN1GraphicString , INT2NUM ( V_ASN1_GRAPHICSTRING ) ) ;\n rb_hash_aset ( class_tag_map , cASN1ISO64String , INT2NUM ( V_ASN1_ISO64STRING ) ) ;\n rb_hash_aset ( class_tag_map , cASN1GeneralString , INT2NUM ( V_ASN1_GENERALSTRING ) ) ;\n rb_hash_aset ( class_tag_map , cASN1UniversalString , INT2NUM ( V_ASN1_UNIVERSALSTRING ) ) ;\n rb_hash_aset ( class_tag_map , cASN1BMPString , INT2NUM ( V_ASN1_BMPSTRING ) ) ;\n rb_global_variable ( & class_tag_map ) ;\n }", "hash": 7549435794356072684, "project": "debian", "size": 111, "target": 0, "idx": 16784}
{"code": "static ASN1_BOOLEAN obj_to_asn1bool ( VALUE obj ) {\n if ( NIL_P ( obj ) ) ossl_raise ( rb_eTypeError , \"Can't convert nil into Boolean\" ) ;\n return RTEST ( obj ) ? 0xff : 0x0 ;\n }", "hash": 7549435794356072684, "project": "debian", "size": 4, "target": 0, "idx": 16786}
{"code": "static VALUE ossl_asn1_ ## klass ( int argc , VALUE * argv , VALUE self ) \\ {\n return rb_funcall3 ( cASN1 ## klass , rb_intern ( \"new\" ) , argc , argv ) ;\n }\n OSSL_ASN1_IMPL_FACTORY_METHOD ( Boolean ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Integer ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Enumerated ) OSSL_ASN1_IMPL_FACTORY_METHOD ( BitString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( OctetString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( UTF8String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( NumericString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( PrintableString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( T61String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( VideotexString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( IA5String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( GraphicString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( ISO64String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( GeneralString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( UniversalString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( BMPString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Null )", "hash": 7549435794356072684, "project": "debian", "size": 4, "target": 0, "idx": 16790}
{"code": "static VALUE decode_time ( unsigned char * der , long length ) {\n ASN1_TIME * time ;\n const unsigned char * p ;\n VALUE ret ;\n int status = 0 ;\n p = der ;\n if ( ! ( time = d2i_ASN1_TIME ( NULL , & p , length ) ) ) ossl_raise ( eASN1Error , NULL ) ;\n ret = rb_protect ( ( VALUE ( * ) ( VALUE ) ) asn1time_to_time , ( VALUE ) time , & status ) ;\n ASN1_TIME_free ( time ) ;\n if ( status ) rb_jump_tag ( status ) ;\n return ret ;\n }", "hash": 7549435794356072684, "project": "debian", "size": 12, "target": 0, "idx": 16796}
{"code": "static char * adb_send_and_receive ( socket_handle_t sock , const char * adb_service , char * buffer , int buffer_length , gssize * data_length ) {\n gssize used_buffer_length ;\n gssize length ;\n gssize result ;\n char status [ 4 ] ;\n char tmp_buffer ;\n size_t adb_service_length ;\n adb_service_length = strlen ( adb_service ) ;\n result = send ( sock , adb_service , ( int ) adb_service_length , 0 ) ;\n if ( result != ( gssize ) adb_service_length ) {\n errmsg_print ( \"ERROR: Error while sending <%s> to ADB daemon\" , adb_service ) ;\n if ( data_length ) * data_length = 0 ;\n return NULL ;\n }\n used_buffer_length = 0 ;\n while ( used_buffer_length < 8 ) {\n result = recv ( sock , buffer + used_buffer_length , ( int ) ( buffer_length - used_buffer_length ) , 0 ) ;\n if ( result <= 0 ) {\n errmsg_print ( \"ERROR: Broken socket connection while fetching reply status for <%s>\" , adb_service ) ;\n return NULL ;\n }\n used_buffer_length += result ;\n }\n memcpy ( status , buffer , 4 ) ;\n tmp_buffer = buffer [ 8 ] ;\n buffer [ 8 ] = '\\0' ;\n length = ( gssize ) g_ascii_strtoll ( buffer + 4 , NULL , 16 ) ;\n buffer [ 8 ] = tmp_buffer ;\n while ( used_buffer_length < length + 8 ) {\n result = recv ( sock , buffer + used_buffer_length , ( int ) ( buffer_length - used_buffer_length ) , 0 ) ;\n if ( result <= 0 ) {\n errmsg_print ( \"ERROR: Broken socket connection while reading reply for <%s>\" , adb_service ) ;\n return NULL ;\n }\n used_buffer_length += result ;\n }\n if ( data_length ) * data_length = used_buffer_length - 8 ;\n if ( memcmp ( status , \"OKAY\" , 4 ) ) {\n errmsg_print ( \"ERROR: Error while receiving by ADB for <%s>\" , adb_service ) ;\n if ( data_length ) * data_length = 0 ;\n return NULL ;\n }\n return buffer + 8 ;\n }", "hash": -5912543978015782596, "project": "debian", "size": 44, "target": 0, "idx": 16813}
{"code": "static void display_refresh ( DisplayChangeListener * dcl ) {\n SimpleSpiceDisplay * ssd = container_of ( dcl , SimpleSpiceDisplay , dcl ) ;\n qemu_spice_display_refresh ( ssd ) ;\n }", "hash": -2478888184195421052, "project": "debian", "size": 4, "target": 0, "idx": 16828}
{"code": "void rfbDecrClientRef ( rfbClientPtr cl ) {\n }", "hash": 6250095321513210169, "project": "debian", "size": 2, "target": 0, "idx": 16843}
{"code": "static void rfbProcessClientProtocolVersion ( rfbClientPtr cl ) {\n rfbProtocolVersionMsg pv ;\n int n , major_ , minor_ ;\n if ( ( n = rfbReadExact ( cl , pv , sz_rfbProtocolVersionMsg ) ) <= 0 ) {\n if ( n == 0 ) rfbLog ( \"rfbProcessClientProtocolVersion: client gone\\n\" ) ;\n else rfbLogPerror ( \"rfbProcessClientProtocolVersion: read\" ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n pv [ sz_rfbProtocolVersionMsg ] = 0 ;\n if ( sscanf ( pv , rfbProtocolVersionFormat , & major_ , & minor_ ) != 2 ) {\n rfbErr ( \"rfbProcessClientProtocolVersion: not a valid RFB client: %s\\n\" , pv ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n rfbLog ( \"Client Protocol Version %d.%d\\n\" , major_ , minor_ ) ;\n if ( major_ != rfbProtocolMajorVersion ) {\n rfbErr ( \"RFB protocol version mismatch - server %d.%d, client %d.%d\" , cl -> screen -> protocolMajorVersion , cl -> screen -> protocolMinorVersion , major_ , minor_ ) ;\n rfbCloseClient ( cl ) ;\n return ;\n }\n cl -> protocolMajorVersion = major_ ;\n cl -> protocolMinorVersion = minor_ ;\n rfbLog ( \"Protocol version sent %d.%d, using %d.%d\\n\" , major_ , minor_ , rfbProtocolMajorVersion , cl -> protocolMinorVersion ) ;\n rfbAuthNewClient ( cl ) ;\n }", "hash": 6250095321513210169, "project": "debian", "size": 26, "target": 0, "idx": 16848}
{"code": "rfbBool rfbSendNewFBSize ( rfbClientPtr cl , int w , int h ) {\n rfbFramebufferUpdateRectHeader rect ;\n if ( cl -> ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE ) {\n if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;\n }\n if ( cl -> PalmVNC == TRUE ) rfbLog ( \"Sending rfbEncodingNewFBSize in response to a PalmVNC style framebuffer resize (%dx%d)\\n\" , w , h ) ;\n else rfbLog ( \"Sending rfbEncodingNewFBSize for resize to (%dx%d)\\n\" , w , h ) ;\n rect . encoding = Swap32IfLE ( rfbEncodingNewFBSize ) ;\n rect . r . x = 0 ;\n rect . r . y = 0 ;\n rect . r . w = Swap16IfLE ( w ) ;\n rect . r . h = Swap16IfLE ( h ) ;\n memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ;\n cl -> ublen += sz_rfbFramebufferUpdateRectHeader ;\n rfbStatRecordEncodingSent ( cl , rfbEncodingNewFBSize , sz_rfbFramebufferUpdateRectHeader , sz_rfbFramebufferUpdateRectHeader ) ;\n return TRUE ;\n }", "hash": 6250095321513210169, "project": "debian", "size": 17, "target": 0, "idx": 16855}
{"code": "rfbClientPtr rfbClientIteratorNext ( rfbClientIteratorPtr i ) {\n if ( i -> next == 0 ) {\n LOCK ( rfbClientListMutex ) ;\n i -> next = i -> screen -> clientHead ;\n UNLOCK ( rfbClientListMutex ) ;\n }\n else {\n IF_PTHREADS ( rfbClientPtr cl = i -> next ) ;\n i -> next = i -> next -> next ;\n IF_PTHREADS ( rfbDecrClientRef ( cl ) ) ;\n }\n # ifdef LIBVNCSERVER_HAVE_LIBPTHREAD if ( ! i -> closedToo ) while ( i -> next && i -> next -> sock < 0 ) i -> next = i -> next -> next ;\n if ( i -> next ) rfbIncrClientRef ( i -> next ) ;\n # endif return i -> next ;\n }", "hash": 6250095321513210169, "project": "debian", "size": 15, "target": 0, "idx": 16856}
{"code": "static rfbClientPtr rfbNewTCPOrUDPClient ( rfbScreenInfoPtr rfbScreen , int sock , rfbBool isUDP ) {\n rfbProtocolVersionMsg pv ;\n rfbClientIteratorPtr iterator ;\n rfbClientPtr cl , cl_ ;\n # ifdef LIBVNCSERVER_IPv6 struct sockaddr_storage addr ;\n # else struct sockaddr_in addr ;\n # endif socklen_t addrlen = sizeof ( addr ) ;\n rfbProtocolExtension * extension ;\n cl = ( rfbClientPtr ) calloc ( sizeof ( rfbClientRec ) , 1 ) ;\n cl -> screen = rfbScreen ;\n cl -> sock = sock ;\n cl -> viewOnly = FALSE ;\n cl -> scaledScreen = rfbScreen ;\n cl -> scaledScreen -> scaledScreenRefCount ++ ;\n rfbResetStats ( cl ) ;\n cl -> clientData = NULL ;\n cl -> clientGoneHook = rfbDoNothingWithClient ;\n if ( isUDP ) {\n rfbLog ( \" accepted UDP client\\n\" ) ;\n }\n else {\n # ifdef LIBVNCSERVER_IPv6 char host [ 1024 ] ;\n # endif int one = 1 ;\n getpeername ( sock , ( struct sockaddr * ) & addr , & addrlen ) ;\n # ifdef LIBVNCSERVER_IPv6 if ( getnameinfo ( ( struct sockaddr * ) & addr , addrlen , host , sizeof ( host ) , NULL , 0 , NI_NUMERICHOST ) != 0 ) {\n rfbLogPerror ( \"rfbNewClient: error in getnameinfo\" ) ;\n cl -> host = strdup ( \"\" ) ;\n }\n else cl -> host = strdup ( host ) ;\n # else cl -> host = strdup ( inet_ntoa ( addr . sin_addr ) ) ;\n # endif rfbLog ( \" other clients:\\n\" ) ;\n iterator = rfbGetClientIterator ( rfbScreen ) ;\n while ( ( cl_ = rfbClientIteratorNext ( iterator ) ) != NULL ) {\n rfbLog ( \" %s\\n\" , cl_ -> host ) ;\n }\n rfbReleaseClientIterator ( iterator ) ;\n if ( ! rfbSetNonBlocking ( sock ) ) {\n close ( sock ) ;\n return NULL ;\n }\n if ( setsockopt ( sock , IPPROTO_TCP , TCP_NODELAY , ( char * ) & one , sizeof ( one ) ) < 0 ) {\n rfbLogPerror ( \"setsockopt failed: can't set TCP_NODELAY flag, non TCP socket?\" ) ;\n }\n FD_SET ( sock , & ( rfbScreen -> allFds ) ) ;\n rfbScreen -> maxFd = rfbMax ( sock , rfbScreen -> maxFd ) ;\n INIT_MUTEX ( cl -> outputMutex ) ;\n INIT_MUTEX ( cl -> refCountMutex ) ;\n INIT_MUTEX ( cl -> sendMutex ) ;\n INIT_COND ( cl -> deleteCond ) ;\n cl -> state = RFB_PROTOCOL_VERSION ;\n cl -> reverseConnection = FALSE ;\n cl -> readyForSetColourMapEntries = FALSE ;\n cl -> useCopyRect = FALSE ;\n cl -> preferredEncoding = - 1 ;\n cl -> correMaxWidth = 48 ;\n cl -> correMaxHeight = 48 ;\n # ifdef LIBVNCSERVER_HAVE_LIBZ cl -> zrleData = NULL ;\n # endif cl -> copyRegion = sraRgnCreate ( ) ;\n cl -> copyDX = 0 ;\n cl -> copyDY = 0 ;\n cl -> modifiedRegion = sraRgnCreateRect ( 0 , 0 , rfbScreen -> width , rfbScreen -> height ) ;\n INIT_MUTEX ( cl -> updateMutex ) ;\n INIT_COND ( cl -> updateCond ) ;\n cl -> requestedRegion = sraRgnCreate ( ) ;\n cl -> format = cl -> screen -> serverFormat ;\n cl -> translateFn = rfbTranslateNone ;\n cl -> translateLookupTable = NULL ;\n LOCK ( rfbClientListMutex ) ;\n IF_PTHREADS ( cl -> refCount = 0 ) ;\n cl -> next = rfbScreen -> clientHead ;\n cl -> prev = NULL ;\n if ( rfbScreen -> clientHead ) rfbScreen -> clientHead -> prev = cl ;\n rfbScreen -> clientHead = cl ;\n UNLOCK ( rfbClientListMutex ) ;\n # if defined ( LIBVNCSERVER_HAVE_LIBZ ) || defined ( LIBVNCSERVER_HAVE_LIBPNG ) cl -> tightQualityLevel = - 1 ;\n # ifdef LIBVNCSERVER_HAVE_LIBJPEG cl -> tightCompressLevel = TIGHT_DEFAULT_COMPRESSION ;\n cl -> turboSubsampLevel = TURBO_DEFAULT_SUBSAMP ;\n {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) cl -> zsActive [ i ] = FALSE ;\n }\n # endif # endif cl -> fileTransfer . fd = - 1 ;\n cl -> enableCursorShapeUpdates = FALSE ;\n cl -> enableCursorPosUpdates = FALSE ;\n cl -> useRichCursorEncoding = FALSE ;\n cl -> enableLastRectEncoding = FALSE ;\n cl -> enableKeyboardLedState = FALSE ;\n cl -> enableSupportedMessages = FALSE ;\n cl -> enableSupportedEncodings = FALSE ;\n cl -> enableServerIdentity = FALSE ;\n cl -> lastKeyboardLedState = - 1 ;\n cl -> cursorX = rfbScreen -> cursorX ;\n cl -> cursorY = rfbScreen -> cursorY ;\n cl -> useNewFBSize = FALSE ;\n # ifdef LIBVNCSERVER_HAVE_LIBZ cl -> compStreamInited = FALSE ;\n cl -> compStream . total_in = 0 ;\n cl -> compStream . total_out = 0 ;\n cl -> compStream . zalloc = Z_NULL ;\n cl -> compStream . zfree = Z_NULL ;\n cl -> compStream . opaque = Z_NULL ;\n cl -> zlibCompressLevel = 5 ;\n # endif cl -> progressiveSliceY = 0 ;\n cl -> extensions = NULL ;\n cl -> lastPtrX = - 1 ;\n # ifdef LIBVNCSERVER_WITH_WEBSOCKETS if ( ! webSocketsCheck ( cl ) ) {\n rfbCloseClient ( cl ) ;\n rfbClientConnectionGone ( cl ) ;\n return NULL ;\n }\n # endif sprintf ( pv , rfbProtocolVersionFormat , rfbScreen -> protocolMajorVersion , rfbScreen -> protocolMinorVersion ) ;\n if ( rfbWriteExact ( cl , pv , sz_rfbProtocolVersionMsg ) < 0 ) {\n rfbLogPerror ( \"rfbNewClient: write\" ) ;\n rfbCloseClient ( cl ) ;\n rfbClientConnectionGone ( cl ) ;\n return NULL ;\n }\n }\n for ( extension = rfbGetExtensionIterator ( ) ;\n extension ;\n extension = extension -> next ) {\n void * data = NULL ;\n if ( extension -> newClient && extension -> newClient ( cl , & data ) ) rfbEnableExtension ( cl , extension , data ) ;\n }\n rfbReleaseExtensionIterator ( ) ;\n switch ( cl -> screen -> newClientHook ( cl ) ) {\n case RFB_CLIENT_ON_HOLD : cl -> onHold = TRUE ;\n break ;\n case RFB_CLIENT_ACCEPT : cl -> onHold = FALSE ;\n break ;\n case RFB_CLIENT_REFUSE : rfbCloseClient ( cl ) ;\n rfbClientConnectionGone ( cl ) ;\n cl = NULL ;\n break ;\n }\n return cl ;\n }", "hash": 6250095321513210169, "project": "debian", "size": 138, "target": 0, "idx": 16870}
{"code": "void rfbClientConnectionGone ( rfbClientPtr cl ) {\n # if defined ( LIBVNCSERVER_HAVE_LIBZ ) && defined ( LIBVNCSERVER_HAVE_LIBJPEG ) int i ;\n # endif LOCK ( rfbClientListMutex ) ;\n if ( cl -> prev ) cl -> prev -> next = cl -> next ;\n else cl -> screen -> clientHead = cl -> next ;\n if ( cl -> next ) cl -> next -> prev = cl -> prev ;\n UNLOCK ( rfbClientListMutex ) ;\n # ifdef LIBVNCSERVER_HAVE_LIBPTHREAD if ( cl -> screen -> backgroundLoop != FALSE ) {\n int i ;\n do {\n LOCK ( cl -> refCountMutex ) ;\n i = cl -> refCount ;\n if ( i > 0 ) WAIT ( cl -> deleteCond , cl -> refCountMutex ) ;\n UNLOCK ( cl -> refCountMutex ) ;\n }\n while ( i > 0 ) ;\n }\n # endif if ( cl -> sock >= 0 ) close ( cl -> sock ) ;\n if ( cl -> scaledScreen != NULL ) cl -> scaledScreen -> scaledScreenRefCount -- ;\n # ifdef LIBVNCSERVER_HAVE_LIBZ rfbFreeZrleData ( cl ) ;\n # endif rfbFreeUltraData ( cl ) ;\n free ( cl -> beforeEncBuf ) ;\n free ( cl -> afterEncBuf ) ;\n if ( cl -> sock >= 0 ) FD_CLR ( cl -> sock , & ( cl -> screen -> allFds ) ) ;\n cl -> clientGoneHook ( cl ) ;\n rfbLog ( \"Client %s gone\\n\" , cl -> host ) ;\n free ( cl -> host ) ;\n # ifdef LIBVNCSERVER_HAVE_LIBZ if ( cl -> compStreamInited ) {\n deflateEnd ( & ( cl -> compStream ) ) ;\n }\n # ifdef LIBVNCSERVER_HAVE_LIBJPEG for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n if ( cl -> zsActive [ i ] ) deflateEnd ( & cl -> zsStruct [ i ] ) ;\n }\n # endif # endif if ( cl -> screen -> pointerClient == cl ) cl -> screen -> pointerClient = NULL ;\n sraRgnDestroy ( cl -> modifiedRegion ) ;\n sraRgnDestroy ( cl -> requestedRegion ) ;\n sraRgnDestroy ( cl -> copyRegion ) ;\n if ( cl -> translateLookupTable ) free ( cl -> translateLookupTable ) ;\n TINI_COND ( cl -> updateCond ) ;\n TINI_MUTEX ( cl -> updateMutex ) ;\n LOCK ( cl -> outputMutex ) ;\n UNLOCK ( cl -> outputMutex ) ;\n TINI_MUTEX ( cl -> outputMutex ) ;\n LOCK ( cl -> sendMutex ) ;\n UNLOCK ( cl -> sendMutex ) ;\n TINI_MUTEX ( cl -> sendMutex ) ;\n rfbPrintStats ( cl ) ;\n rfbResetStats ( cl ) ;\n free ( cl ) ;\n }", "hash": 6250095321513210169, "project": "debian", "size": 52, "target": 0, "idx": 16872}
{"code": "rfbBool rfbFilenameTranslate2UNIX ( rfbClientPtr cl , char * path , char * unixPath , size_t unixPathMaxLen ) {\n int x ;\n char * home = NULL ;\n FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN ( \"\" , cl , FALSE ) ;\n if ( strlen ( path ) >= unixPathMaxLen ) return FALSE ;\n if ( path [ 0 ] == 'C' && path [ 1 ] == ':' ) strcpy ( unixPath , & path [ 2 ] ) ;\n else {\n home = getenv ( \"HOME\" ) ;\n if ( home != NULL ) {\n if ( ( strlen ( path ) + strlen ( home ) + 1 ) >= unixPathMaxLen ) return FALSE ;\n strcpy ( unixPath , home ) ;\n strcat ( unixPath , \"/\" ) ;\n strcat ( unixPath , path ) ;\n }\n else strcpy ( unixPath , path ) ;\n }\n for ( x = 0 ;\n x < strlen ( unixPath ) ;\n x ++ ) if ( unixPath [ x ] == '\\\\' ) unixPath [ x ] = '/' ;\n return TRUE ;\n }", "hash": 6250095321513210169, "project": "debian", "size": 21, "target": 0, "idx": 16879}
{"code": "void vp9_iwht4x4_1_add_c ( const tran_low_t * in , uint8_t * dest , int dest_stride ) {\n int i ;\n tran_high_t a1 , e1 ;\n tran_low_t tmp [ 4 ] ;\n const tran_low_t * ip = in ;\n tran_low_t * op = tmp ;\n a1 = ip [ 0 ] >> UNIT_QUANT_SHIFT ;\n e1 = a1 >> 1 ;\n a1 -= e1 ;\n op [ 0 ] = a1 ;\n op [ 1 ] = op [ 2 ] = op [ 3 ] = e1 ;\n ip = tmp ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n e1 = ip [ 0 ] >> 1 ;\n a1 = ip [ 0 ] - e1 ;\n dest [ dest_stride * 0 ] = clip_pixel ( dest [ dest_stride * 0 ] + a1 ) ;\n dest [ dest_stride * 1 ] = clip_pixel ( dest [ dest_stride * 1 ] + e1 ) ;\n dest [ dest_stride * 2 ] = clip_pixel ( dest [ dest_stride * 2 ] + e1 ) ;\n dest [ dest_stride * 3 ] = clip_pixel ( dest [ dest_stride * 3 ] + e1 ) ;\n ip ++ ;\n dest ++ ;\n }\n }", "hash": 8320716512483418415, "project": "chrome", "size": 25, "target": 0, "idx": 16940}
{"code": "static void set_roi_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) {\n unsigned int i ;\n vpx_roi_map_t roi ;\n memset ( & roi , 0 , sizeof ( roi ) ) ;\n roi . rows = ( cfg -> g_h + 15 ) / 16 ;\n roi . cols = ( cfg -> g_w + 15 ) / 16 ;\n roi . delta_q [ 0 ] = 0 ;\n roi . delta_q [ 1 ] = - 2 ;\n roi . delta_q [ 2 ] = - 4 ;\n roi . delta_q [ 3 ] = - 6 ;\n roi . delta_lf [ 0 ] = 0 ;\n roi . delta_lf [ 1 ] = 1 ;\n roi . delta_lf [ 2 ] = 2 ;\n roi . delta_lf [ 3 ] = 3 ;\n roi . static_threshold [ 0 ] = 1500 ;\n roi . static_threshold [ 1 ] = 1000 ;\n roi . static_threshold [ 2 ] = 500 ;\n roi . static_threshold [ 3 ] = 0 ;\n roi . roi_map = ( uint8_t * ) malloc ( roi . rows * roi . cols ) ;\n for ( i = 0 ;\n i < roi . rows * roi . cols ;\n ++ i ) roi . roi_map [ i ] = i % 4 ;\n if ( vpx_codec_control ( codec , VP8E_SET_ROI_MAP , & roi ) ) die_codec ( codec , \"Failed to set ROI map\" ) ;\n free ( roi . roi_map ) ;\n }", "hash": 6017095990848568360, "project": "chrome", "size": 25, "target": 0, "idx": 16949}
{"code": "static void encode_quantization ( const VP9_COMMON * const cm , struct vp9_write_bit_buffer * wb ) {\n vp9_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ;\n write_delta_q ( wb , cm -> y_dc_delta_q ) ;\n write_delta_q ( wb , cm -> uv_dc_delta_q ) ;\n write_delta_q ( wb , cm -> uv_ac_delta_q ) ;\n }", "hash": 5611940141018433728, "project": "chrome", "size": 6, "target": 0, "idx": 16955}
{"code": "static void write_profile ( BITSTREAM_PROFILE profile , struct vp9_write_bit_buffer * wb ) {\n switch ( profile ) {\n case PROFILE_0 : vp9_wb_write_literal ( wb , 0 , 2 ) ;\n break ;\n case PROFILE_1 : vp9_wb_write_literal ( wb , 2 , 2 ) ;\n break ;\n case PROFILE_2 : vp9_wb_write_literal ( wb , 1 , 2 ) ;\n break ;\n case PROFILE_3 : vp9_wb_write_literal ( wb , 6 , 3 ) ;\n break ;\n default : assert ( 0 ) ;\n }\n }", "hash": 5611940141018433728, "project": "chrome", "size": 13, "target": 0, "idx": 16956}
{"code": "static void encode_unsigned_max ( struct vp9_write_bit_buffer * wb , int data , int max ) {\n vp9_wb_write_literal ( wb , data , get_unsigned_bits ( max ) ) ;\n }", "hash": 5611940141018433728, "project": "chrome", "size": 3, "target": 0, "idx": 16957}
{"code": "static size_t write_compressed_header ( VP9_COMP * cpi , uint8_t * data ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;\n FRAME_CONTEXT * const fc = & cm -> fc ;\n vp9_writer header_bc ;\n vp9_start_encode ( & header_bc , data ) ;\n if ( xd -> lossless ) cm -> tx_mode = ONLY_4X4 ;\n else encode_txfm_probs ( cm , & header_bc ) ;\n update_coef_probs ( cpi , & header_bc ) ;\n update_skip_probs ( cm , & header_bc ) ;\n if ( ! frame_is_intra_only ( cm ) ) {\n int i ;\n for ( i = 0 ;\n i < INTER_MODE_CONTEXTS ;\n ++ i ) prob_diff_update ( vp9_inter_mode_tree , cm -> fc . inter_mode_probs [ i ] , cm -> counts . inter_mode [ i ] , INTER_MODES , & header_bc ) ;\n vp9_zero ( cm -> counts . inter_mode ) ;\n if ( cm -> interp_filter == SWITCHABLE ) update_switchable_interp_probs ( cm , & header_bc ) ;\n for ( i = 0 ;\n i < INTRA_INTER_CONTEXTS ;\n i ++ ) vp9_cond_prob_diff_update ( & header_bc , & fc -> intra_inter_prob [ i ] , cm -> counts . intra_inter [ i ] ) ;\n if ( cm -> allow_comp_inter_inter ) {\n const int use_compound_pred = cm -> reference_mode != SINGLE_REFERENCE ;\n const int use_hybrid_pred = cm -> reference_mode == REFERENCE_MODE_SELECT ;\n vp9_write_bit ( & header_bc , use_compound_pred ) ;\n if ( use_compound_pred ) {\n vp9_write_bit ( & header_bc , use_hybrid_pred ) ;\n if ( use_hybrid_pred ) for ( i = 0 ;\n i < COMP_INTER_CONTEXTS ;\n i ++ ) vp9_cond_prob_diff_update ( & header_bc , & fc -> comp_inter_prob [ i ] , cm -> counts . comp_inter [ i ] ) ;\n }\n }\n if ( cm -> reference_mode != COMPOUND_REFERENCE ) {\n for ( i = 0 ;\n i < REF_CONTEXTS ;\n i ++ ) {\n vp9_cond_prob_diff_update ( & header_bc , & fc -> single_ref_prob [ i ] [ 0 ] , cm -> counts . single_ref [ i ] [ 0 ] ) ;\n vp9_cond_prob_diff_update ( & header_bc , & fc -> single_ref_prob [ i ] [ 1 ] , cm -> counts . single_ref [ i ] [ 1 ] ) ;\n }\n }\n if ( cm -> reference_mode != SINGLE_REFERENCE ) for ( i = 0 ;\n i < REF_CONTEXTS ;\n i ++ ) vp9_cond_prob_diff_update ( & header_bc , & fc -> comp_ref_prob [ i ] , cm -> counts . comp_ref [ i ] ) ;\n for ( i = 0 ;\n i < BLOCK_SIZE_GROUPS ;\n ++ i ) prob_diff_update ( vp9_intra_mode_tree , cm -> fc . y_mode_prob [ i ] , cm -> counts . y_mode [ i ] , INTRA_MODES , & header_bc ) ;\n for ( i = 0 ;\n i < PARTITION_CONTEXTS ;\n ++ i ) prob_diff_update ( vp9_partition_tree , fc -> partition_prob [ i ] , cm -> counts . partition [ i ] , PARTITION_TYPES , & header_bc ) ;\n vp9_write_nmv_probs ( cm , cm -> allow_high_precision_mv , & header_bc ) ;\n }\n vp9_stop_encode ( & header_bc ) ;\n assert ( header_bc . pos <= 0xffff ) ;\n return header_bc . pos ;\n }", "hash": 5611940141018433728, "project": "chrome", "size": 54, "target": 0, "idx": 16966}
{"code": "static void write_display_size ( const VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) {\n const int scaling_active = cm -> width != cm -> display_width || cm -> height != cm -> display_height ;\n vp9_wb_write_bit ( wb , scaling_active ) ;\n if ( scaling_active ) {\n vp9_wb_write_literal ( wb , cm -> display_width - 1 , 16 ) ;\n vp9_wb_write_literal ( wb , cm -> display_height - 1 , 16 ) ;\n }\n }", "hash": 5611940141018433728, "project": "chrome", "size": 8, "target": 0, "idx": 16973}
{"code": "PREDICTION_MODE vp9_above_block_mode ( const MODE_INFO * cur_mi , const MODE_INFO * above_mi , int b ) {\n if ( b == 0 || b == 1 ) {\n if ( ! above_mi || is_inter_block ( & above_mi -> mbmi ) ) return DC_PRED ;\n return get_y_mode ( above_mi , b + 2 ) ;\n }\n else {\n assert ( b == 2 || b == 3 ) ;\n return cur_mi -> bmi [ b - 2 ] . as_mode ;\n }\n }", "hash": 6442032569499442758, "project": "chrome", "size": 10, "target": 0, "idx": 16993}
{"code": "void vp9_ ## type ## _predictor_ ## size ## x ## size ## _c ( uint8_t * dst , ptrdiff_t stride , const uint8_t * above , const uint8_t * left ) {\n type ## _predictor ( dst , stride , size , above , left ) ;\n }\n # if CONFIG_VP9_HIGHBITDEPTH # define intra_pred_high_sized ( type , size ) void vp9_high_ ## type ## _predictor_ ## size ## x ## size ## _c ( uint16_t * dst , ptrdiff_t stride , const uint16_t * above , const uint16_t * left , int bd ) {\n high_ ## type ## _predictor ( dst , stride , size , above , left , bd ) ;\n }\n # define intra_pred_allsizes ( type ) intra_pred_sized ( type , 4 ) intra_pred_sized ( type , 8 ) intra_pred_sized ( type , 16 ) intra_pred_sized ( type , 32 ) intra_pred_high_sized ( type , 4 ) intra_pred_high_sized ( type , 8 ) intra_pred_high_sized ( type , 16 ) intra_pred_high_sized ( type , 32 ) # else # define intra_pred_allsizes ( type ) intra_pred_sized ( type , 4 ) intra_pred_sized ( type , 8 ) intra_pred_sized ( type , 16 ) intra_pred_sized ( type , 32 ) # endif # if CONFIG_VP9_HIGHBITDEPTH static INLINE void high_d207_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r , c ;\n ( void ) above ;\n ( void ) bd ;\n for ( r = 0 ;\n r < bs - 1 ;\n ++ r ) {\n dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] , 1 ) ;\n }\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( r = 0 ;\n r < bs - 2 ;\n ++ r ) {\n dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] * 2 + left [ r + 2 ] , 2 ) ;\n }\n dst [ ( bs - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ bs - 2 ] + left [ bs - 1 ] * 3 , 2 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ ( bs - 1 ) * stride + c ] = left [ bs - 1 ] ;\n for ( r = bs - 2 ;\n r >= 0 ;\n -- r ) {\n for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ r * stride + c ] = dst [ ( r + 1 ) * stride + c - 2 ] ;\n }\n }\n static INLINE void high_d63_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r , c ;\n ( void ) left ;\n ( void ) bd ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) {\n dst [ c ] = r & 1 ? ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] * 2 + above [ r / 2 + c + 2 ] , 2 ) : ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] , 1 ) ;\n }\n dst += stride ;\n }\n }\n static INLINE void high_d45_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r , c ;\n ( void ) left ;\n ( void ) bd ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) {\n dst [ c ] = r + c + 2 < bs * 2 ? ROUND_POWER_OF_TWO ( above [ r + c ] + above [ r + c + 1 ] * 2 + above [ r + c + 2 ] , 2 ) : above [ bs * 2 - 1 ] ;\n }\n dst += stride ;\n }\n }\n static INLINE void high_d117_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r , c ;\n ( void ) bd ;\n for ( c = 0 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] , 1 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 3 ;\n r < bs ;\n ++ r ) dst [ ( r - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ r - 3 ] + left [ r - 2 ] * 2 + left [ r - 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - 2 * stride + c - 1 ] ;\n dst += stride ;\n }\n }\n static INLINE void high_d135_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r , c ;\n ( void ) bd ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - stride + c - 1 ] ;\n dst += stride ;\n }\n }\n static INLINE void high_d153_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r , c ;\n ( void ) bd ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] , 1 ) ;\n for ( r = 1 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 1 ] + left [ r ] , 1 ) ;\n dst ++ ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] * 2 + above [ c + 1 ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = dst [ - stride + c - 2 ] ;\n dst += stride ;\n }\n }\n static INLINE void high_v_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r ;\n ( void ) left ;\n ( void ) bd ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memcpy ( dst , above , bs * sizeof ( uint16_t ) ) ;\n dst += stride ;\n }\n }\n static INLINE void high_h_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r ;\n ( void ) above ;\n ( void ) bd ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset16 ( dst , left [ r ] , bs ) ;\n dst += stride ;\n }\n }\n static INLINE void high_tm_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r , c ;\n int ytop_left = above [ - 1 ] ;\n ( void ) bd ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n for ( c = 0 ;\n c < bs ;\n c ++ ) dst [ c ] = clip_pixel_high ( left [ r ] + above [ c ] - ytop_left , bd ) ;\n dst += stride ;\n }\n }\n static INLINE void high_dc_128_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int r ;\n ( void ) above ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset16 ( dst , 128 << ( bd - 8 ) , bs ) ;\n dst += stride ;\n }\n }\n static INLINE void high_dc_left_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int i , r , expected_dc , sum = 0 ;\n ( void ) above ;\n ( void ) bd ;\n for ( i = 0 ;\n i < bs ;\n i ++ ) sum += left [ i ] ;\n expected_dc = ( sum + ( bs >> 1 ) ) / bs ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset16 ( dst , expected_dc , bs ) ;\n dst += stride ;\n }\n }\n static INLINE void high_dc_top_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int i , r , expected_dc , sum = 0 ;\n ( void ) left ;\n ( void ) bd ;\n for ( i = 0 ;\n i < bs ;\n i ++ ) sum += above [ i ] ;\n expected_dc = ( sum + ( bs >> 1 ) ) / bs ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset16 ( dst , expected_dc , bs ) ;\n dst += stride ;\n }\n }\n static INLINE void high_dc_predictor ( uint16_t * dst , ptrdiff_t stride , int bs , const uint16_t * above , const uint16_t * left , int bd ) {\n int i , r , expected_dc , sum = 0 ;\n const int count = 2 * bs ;\n ( void ) bd ;\n for ( i = 0 ;\n i < bs ;\n i ++ ) {\n sum += above [ i ] ;\n sum += left [ i ] ;\n }\n expected_dc = ( sum + ( count >> 1 ) ) / count ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset16 ( dst , expected_dc , bs ) ;\n dst += stride ;\n }\n }\n # endif static INLINE void d207_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) above ;\n for ( r = 0 ;\n r < bs - 1 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] , 1 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( r = 0 ;\n r < bs - 2 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] * 2 + left [ r + 2 ] , 2 ) ;\n dst [ ( bs - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ bs - 2 ] + left [ bs - 1 ] * 3 , 2 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ ( bs - 1 ) * stride + c ] = left [ bs - 1 ] ;\n for ( r = bs - 2 ;\n r >= 0 ;\n -- r ) for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ r * stride + c ] = dst [ ( r + 1 ) * stride + c - 2 ] ;\n }\n intra_pred_allsizes ( d207 )", "hash": -755883256379441954, "project": "chrome", "size": 257, "target": 0, "idx": 17005}
{"code": "static int parse_stream_params ( struct VpxEncoderConfig * global , struct stream_state * stream , char * * argv ) {\n char * * argi , * * argj ;\n struct arg arg ;\n static const arg_def_t * * ctrl_args = no_args ;\n static const int * ctrl_args_map = NULL ;\n struct stream_config * config = & stream -> config ;\n int eos_mark_found = 0 ;\n # if CONFIG_VP9 && CONFIG_VP9_HIGHBITDEPTH int test_16bit_internal = 0 ;\n # endif if ( 0 ) {\n # if CONFIG_VP8_ENCODER }\n else if ( strcmp ( global -> codec -> name , \"vp8\" ) == 0 ) {\n ctrl_args = vp8_args ;\n ctrl_args_map = vp8_arg_ctrl_map ;\n # endif # if CONFIG_VP9_ENCODER }\n else if ( strcmp ( global -> codec -> name , \"vp9\" ) == 0 ) {\n ctrl_args = vp9_args ;\n ctrl_args_map = vp9_arg_ctrl_map ;\n # endif }\n for ( argi = argj = argv ;\n ( * argj = * argi ) ;\n argi += arg . argv_step ) {\n arg . argv_step = 1 ;\n if ( eos_mark_found ) {\n argj ++ ;\n continue ;\n }\n else if ( ! strcmp ( * argj , \"--\" ) ) {\n eos_mark_found = 1 ;\n continue ;\n }\n if ( 0 ) {\n }\n else if ( arg_match ( & arg , & outputfile , argi ) ) {\n config -> out_fn = arg . val ;\n }\n else if ( arg_match ( & arg , & fpf_name , argi ) ) {\n config -> stats_fn = arg . val ;\n # if CONFIG_FP_MB_STATS }\n else if ( arg_match ( & arg , & fpmbf_name , argi ) ) {\n config -> fpmb_stats_fn = arg . val ;\n # endif }\n else if ( arg_match ( & arg , & use_ivf , argi ) ) {\n config -> write_webm = 0 ;\n }\n else if ( arg_match ( & arg , & threads , argi ) ) {\n config -> cfg . g_threads = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & profile , argi ) ) {\n config -> cfg . g_profile = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & width , argi ) ) {\n config -> cfg . g_w = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & height , argi ) ) {\n config -> cfg . g_h = arg_parse_uint ( & arg ) ;\n # if CONFIG_VP9 && CONFIG_VP9_HIGHBITDEPTH }\n else if ( arg_match ( & arg , & bitdeptharg , argi ) ) {\n config -> cfg . g_bit_depth = arg_parse_enum_or_int ( & arg ) ;\n }\n else if ( arg_match ( & arg , & inbitdeptharg , argi ) ) {\n config -> cfg . g_input_bit_depth = arg_parse_uint ( & arg ) ;\n # endif # if CONFIG_WEBM_IO }\n else if ( arg_match ( & arg , & stereo_mode , argi ) ) {\n config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ;\n # endif }\n else if ( arg_match ( & arg , & timebase , argi ) ) {\n config -> cfg . g_timebase = arg_parse_rational ( & arg ) ;\n validate_positive_rational ( arg . name , & config -> cfg . g_timebase ) ;\n }\n else if ( arg_match ( & arg , & error_resilient , argi ) ) {\n config -> cfg . g_error_resilient = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & lag_in_frames , argi ) ) {\n config -> cfg . g_lag_in_frames = arg_parse_uint ( & arg ) ;\n if ( global -> deadline == VPX_DL_REALTIME && config -> cfg . g_lag_in_frames != 0 ) {\n warn ( \"non-zero %s option ignored in realtime mode.\\n\" , arg . name ) ;\n config -> cfg . g_lag_in_frames = 0 ;\n }\n }\n else if ( arg_match ( & arg , & dropframe_thresh , argi ) ) {\n config -> cfg . rc_dropframe_thresh = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & resize_allowed , argi ) ) {\n config -> cfg . rc_resize_allowed = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & resize_width , argi ) ) {\n config -> cfg . rc_scaled_width = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & resize_height , argi ) ) {\n config -> cfg . rc_scaled_height = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & resize_up_thresh , argi ) ) {\n config -> cfg . rc_resize_up_thresh = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & resize_down_thresh , argi ) ) {\n config -> cfg . rc_resize_down_thresh = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & end_usage , argi ) ) {\n config -> cfg . rc_end_usage = arg_parse_enum_or_int ( & arg ) ;\n }\n else if ( arg_match ( & arg , & target_bitrate , argi ) ) {\n config -> cfg . rc_target_bitrate = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & min_quantizer , argi ) ) {\n config -> cfg . rc_min_quantizer = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & max_quantizer , argi ) ) {\n config -> cfg . rc_max_quantizer = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & undershoot_pct , argi ) ) {\n config -> cfg . rc_undershoot_pct = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & overshoot_pct , argi ) ) {\n config -> cfg . rc_overshoot_pct = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & buf_sz , argi ) ) {\n config -> cfg . rc_buf_sz = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & buf_initial_sz , argi ) ) {\n config -> cfg . rc_buf_initial_sz = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & buf_optimal_sz , argi ) ) {\n config -> cfg . rc_buf_optimal_sz = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & bias_pct , argi ) ) {\n config -> cfg . rc_2pass_vbr_bias_pct = arg_parse_uint ( & arg ) ;\n if ( global -> passes < 2 ) warn ( \"option %s ignored in one-pass mode.\\n\" , arg . name ) ;\n }\n else if ( arg_match ( & arg , & minsection_pct , argi ) ) {\n config -> cfg . rc_2pass_vbr_minsection_pct = arg_parse_uint ( & arg ) ;\n if ( global -> passes < 2 ) warn ( \"option %s ignored in one-pass mode.\\n\" , arg . name ) ;\n }\n else if ( arg_match ( & arg , & maxsection_pct , argi ) ) {\n config -> cfg . rc_2pass_vbr_maxsection_pct = arg_parse_uint ( & arg ) ;\n if ( global -> passes < 2 ) warn ( \"option %s ignored in one-pass mode.\\n\" , arg . name ) ;\n }\n else if ( arg_match ( & arg , & kf_min_dist , argi ) ) {\n config -> cfg . kf_min_dist = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & kf_max_dist , argi ) ) {\n config -> cfg . kf_max_dist = arg_parse_uint ( & arg ) ;\n config -> have_kf_max_dist = 1 ;\n }\n else if ( arg_match ( & arg , & kf_disabled , argi ) ) {\n config -> cfg . kf_mode = VPX_KF_DISABLED ;\n # if CONFIG_VP9 && CONFIG_VP9_HIGHBITDEPTH }\n else if ( arg_match ( & arg , & test16bitinternalarg , argi ) ) {\n if ( strcmp ( global -> codec -> name , \"vp9\" ) == 0 ) {\n test_16bit_internal = 1 ;\n }\n # endif }\n else {\n int i , match = 0 ;\n for ( i = 0 ;\n ctrl_args [ i ] ;\n i ++ ) {\n if ( arg_match ( & arg , ctrl_args [ i ] , argi ) ) {\n int j ;\n match = 1 ;\n for ( j = 0 ;\n j < config -> arg_ctrl_cnt ;\n j ++ ) if ( ctrl_args_map != NULL && config -> arg_ctrls [ j ] [ 0 ] == ctrl_args_map [ i ] ) break ;\n assert ( j < ( int ) ARG_CTRL_CNT_MAX ) ;\n if ( ctrl_args_map != NULL && j < ( int ) ARG_CTRL_CNT_MAX ) {\n config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ;\n config -> arg_ctrls [ j ] [ 1 ] = arg_parse_enum_or_int ( & arg ) ;\n if ( j == config -> arg_ctrl_cnt ) config -> arg_ctrl_cnt ++ ;\n }\n }\n }\n if ( ! match ) argj ++ ;\n }\n }\n # if CONFIG_VP9 && CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global -> codec -> name , \"vp9\" ) == 0 ) {\n config -> use_16bit_internal = test_16bit_internal | ( config -> cfg . g_profile > 1 ) ;\n }\n # endif return eos_mark_found ;\n }", "hash": -1483849844579170895, "project": "chrome", "size": 178, "target": 0, "idx": 17026}
{"code": "static void close_input_file ( struct VpxInputContext * input ) {\n fclose ( input -> file ) ;\n if ( input -> file_type == FILE_TYPE_Y4M ) y4m_input_close ( & input -> y4m ) ;\n }", "hash": -1483849844579170895, "project": "chrome", "size": 4, "target": 0, "idx": 17043}
{"code": "static const char * file_type_to_string ( enum VideoFileType t ) {\n switch ( t ) {\n case FILE_TYPE_RAW : return \"RAW\" ;\n case FILE_TYPE_Y4M : return \"Y4M\" ;\n default : return \"Other\" ;\n }\n }", "hash": -1483849844579170895, "project": "chrome", "size": 7, "target": 0, "idx": 17051}
{"code": "static void parse_global_config ( struct VpxEncoderConfig * global , char * * argv ) {\n char * * argi , * * argj ;\n struct arg arg ;\n memset ( global , 0 , sizeof ( * global ) ) ;\n global -> codec = get_vpx_encoder_by_index ( 0 ) ;\n global -> passes = 0 ;\n global -> color_type = I420 ;\n global -> deadline = VPX_DL_GOOD_QUALITY ;\n for ( argi = argj = argv ;\n ( * argj = * argi ) ;\n argi += arg . argv_step ) {\n arg . argv_step = 1 ;\n if ( arg_match ( & arg , & codecarg , argi ) ) {\n global -> codec = get_vpx_encoder_by_name ( arg . val ) ;\n if ( ! global -> codec ) die ( \"Error: Unrecognized argument (%s) to --codec\\n\" , arg . val ) ;\n }\n else if ( arg_match ( & arg , & passes , argi ) ) {\n global -> passes = arg_parse_uint ( & arg ) ;\n if ( global -> passes < 1 || global -> passes > 2 ) die ( \"Error: Invalid number of passes (%d)\\n\" , global -> passes ) ;\n }\n else if ( arg_match ( & arg , & pass_arg , argi ) ) {\n global -> pass = arg_parse_uint ( & arg ) ;\n if ( global -> pass < 1 || global -> pass > 2 ) die ( \"Error: Invalid pass selected (%d)\\n\" , global -> pass ) ;\n }\n else if ( arg_match ( & arg , & usage , argi ) ) global -> usage = arg_parse_uint ( & arg ) ;\n else if ( arg_match ( & arg , & deadline , argi ) ) global -> deadline = arg_parse_uint ( & arg ) ;\n else if ( arg_match ( & arg , & best_dl , argi ) ) global -> deadline = VPX_DL_BEST_QUALITY ;\n else if ( arg_match ( & arg , & good_dl , argi ) ) global -> deadline = VPX_DL_GOOD_QUALITY ;\n else if ( arg_match ( & arg , & rt_dl , argi ) ) global -> deadline = VPX_DL_REALTIME ;\n else if ( arg_match ( & arg , & use_yv12 , argi ) ) global -> color_type = YV12 ;\n else if ( arg_match ( & arg , & use_i420 , argi ) ) global -> color_type = I420 ;\n else if ( arg_match ( & arg , & use_i422 , argi ) ) global -> color_type = I422 ;\n else if ( arg_match ( & arg , & use_i444 , argi ) ) global -> color_type = I444 ;\n else if ( arg_match ( & arg , & quietarg , argi ) ) global -> quiet = 1 ;\n else if ( arg_match ( & arg , & verbosearg , argi ) ) global -> verbose = 1 ;\n else if ( arg_match ( & arg , & limit , argi ) ) global -> limit = arg_parse_uint ( & arg ) ;\n else if ( arg_match ( & arg , & skip , argi ) ) global -> skip_frames = arg_parse_uint ( & arg ) ;\n else if ( arg_match ( & arg , & psnrarg , argi ) ) global -> show_psnr = 1 ;\n else if ( arg_match ( & arg , & recontest , argi ) ) global -> test_decode = arg_parse_enum_or_int ( & arg ) ;\n else if ( arg_match ( & arg , & framerate , argi ) ) {\n global -> framerate = arg_parse_rational ( & arg ) ;\n validate_positive_rational ( arg . name , & global -> framerate ) ;\n global -> have_framerate = 1 ;\n }\n else if ( arg_match ( & arg , & out_part , argi ) ) global -> out_part = 1 ;\n else if ( arg_match ( & arg , & debugmode , argi ) ) global -> debug = 1 ;\n else if ( arg_match ( & arg , & q_hist_n , argi ) ) global -> show_q_hist_buckets = arg_parse_uint ( & arg ) ;\n else if ( arg_match ( & arg , & rate_hist_n , argi ) ) global -> show_rate_hist_buckets = arg_parse_uint ( & arg ) ;\n else if ( arg_match ( & arg , & disable_warnings , argi ) ) global -> disable_warnings = 1 ;\n else if ( arg_match ( & arg , & disable_warning_prompt , argi ) ) global -> disable_warning_prompt = 1 ;\n else if ( arg_match ( & arg , & experimental_bitstream , argi ) ) global -> experimental_bitstream = 1 ;\n else argj ++ ;\n }\n if ( global -> pass ) {\n if ( global -> pass > global -> passes ) {\n warn ( \"Assuming --pass=%d implies --passes=%d\\n\" , global -> pass , global -> pass ) ;\n global -> passes = global -> pass ;\n }\n }\n if ( global -> passes == 0 ) {\n # if CONFIG_VP9_ENCODER if ( global -> codec != NULL && global -> codec -> name != NULL ) global -> passes = ( strcmp ( global -> codec -> name , \"vp9\" ) == 0 && global -> deadline != VPX_DL_REALTIME ) ? 2 : 1 ;\n # else global -> passes = 1 ;\n # endif }\n if ( global -> deadline == VPX_DL_REALTIME && global -> passes > 1 ) {\n warn ( \"Enforcing one-pass encoding in realtime mode\\n\" ) ;\n global -> passes = 1 ;\n }\n }", "hash": -1483849844579170895, "project": "chrome", "size": 68, "target": 0, "idx": 17056}
{"code": "static void dealloc_raw_frame_buffers ( VP8_COMP * cpi ) {\n # if VP8_TEMPORAL_ALT_REF vp8_yv12_de_alloc_frame_buffer ( & cpi -> alt_ref_buffer ) ;\n # endif vp8_lookahead_destroy ( cpi -> lookahead ) ;\n }", "hash": -3384986069176965684, "project": "chrome", "size": 4, "target": 0, "idx": 17061}
{"code": "static void Pass2Encode ( VP8_COMP * cpi , unsigned long * size , unsigned char * dest , unsigned char * dest_end , unsigned int * frame_flags ) {\n if ( ! cpi -> common . refresh_alt_ref_frame ) vp8_second_pass ( cpi ) ;\n encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ;\n cpi -> twopass . bits_left -= 8 * * size ;\n if ( ! cpi -> common . refresh_alt_ref_frame ) {\n double two_pass_min_rate = ( double ) ( cpi -> oxcf . target_bandwidth * cpi -> oxcf . two_pass_vbrmin_section / 100 ) ;\n cpi -> twopass . bits_left += ( int64_t ) ( two_pass_min_rate / cpi -> framerate ) ;\n }\n }", "hash": -3384986069176965684, "project": "chrome", "size": 9, "target": 0, "idx": 17071}
{"code": "static void update_golden_frame_stats ( VP8_COMP * cpi ) {\n VP8_COMMON * cm = & cpi -> common ;\n if ( cm -> refresh_golden_frame ) {\n if ( ! cpi -> auto_gold ) cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ;\n if ( ( cpi -> pass != 2 ) && ( cpi -> frames_till_gf_update_due > 0 ) ) {\n cpi -> current_gf_interval = cpi -> frames_till_gf_update_due ;\n if ( ( cm -> frame_type != KEY_FRAME ) && ! cpi -> source_alt_ref_active ) {\n cpi -> gf_overspend_bits += ( cpi -> projected_frame_size - cpi -> inter_frame_target ) ;\n }\n cpi -> non_gf_bitrate_adjustment = cpi -> gf_overspend_bits / cpi -> frames_till_gf_update_due ;\n }\n vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;\n cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;\n cm -> refresh_golden_frame = 0 ;\n cpi -> frames_since_golden = 0 ;\n cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ;\n cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ;\n cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ;\n cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ;\n if ( cpi -> oxcf . fixed_q >= 0 && cpi -> oxcf . play_alternate && ! cpi -> common . refresh_alt_ref_frame ) {\n cpi -> source_alt_ref_pending = 1 ;\n cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ;\n }\n if ( ! cpi -> source_alt_ref_pending ) cpi -> source_alt_ref_active = 0 ;\n if ( cpi -> frames_till_gf_update_due > 0 ) cpi -> frames_till_gf_update_due -- ;\n }\n else if ( ! cpi -> common . refresh_alt_ref_frame ) {\n if ( cpi -> frames_till_gf_update_due > 0 ) cpi -> frames_till_gf_update_due -- ;\n if ( cpi -> frames_till_alt_ref_frame ) cpi -> frames_till_alt_ref_frame -- ;\n cpi -> frames_since_golden ++ ;\n if ( cpi -> frames_since_golden > 1 ) {\n cpi -> recent_ref_frame_usage [ INTRA_FRAME ] += cpi -> mb . count_mb_ref_frame_usage [ INTRA_FRAME ] ;\n cpi -> recent_ref_frame_usage [ LAST_FRAME ] += cpi -> mb . count_mb_ref_frame_usage [ LAST_FRAME ] ;\n cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] += cpi -> mb . count_mb_ref_frame_usage [ GOLDEN_FRAME ] ;\n cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] += cpi -> mb . count_mb_ref_frame_usage [ ALTREF_FRAME ] ;\n }\n }\n }", "hash": -3384986069176965684, "project": "chrome", "size": 38, "target": 0, "idx": 17081}
{"code": "int vp8_get_compressed_data ( VP8_COMP * cpi , unsigned int * frame_flags , unsigned long * size , unsigned char * dest , unsigned char * dest_end , int64_t * time_stamp , int64_t * time_end , int flush ) {\n VP8_COMMON * cm ;\n struct vpx_usec_timer tsctimer ;\n struct vpx_usec_timer ticktimer ;\n struct vpx_usec_timer cmptimer ;\n YV12_BUFFER_CONFIG * force_src_buffer = NULL ;\n if ( ! cpi ) return - 1 ;\n cm = & cpi -> common ;\n if ( setjmp ( cpi -> common . error . jmp ) ) {\n cpi -> common . error . setjmp = 0 ;\n vp8_clear_system_state ( ) ;\n return VPX_CODEC_CORRUPT_FRAME ;\n }\n cpi -> common . error . setjmp = 1 ;\n vpx_usec_timer_start ( & cmptimer ) ;\n cpi -> source = NULL ;\n # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . play_alternate && cpi -> source_alt_ref_pending ) {\n if ( ( cpi -> source = vp8_lookahead_peek ( cpi -> lookahead , cpi -> frames_till_gf_update_due , PEEK_FORWARD ) ) ) {\n cpi -> alt_ref_source = cpi -> source ;\n if ( cpi -> oxcf . arnr_max_frames > 0 ) {\n vp8_temporal_filter_prepare_c ( cpi , cpi -> frames_till_gf_update_due ) ;\n force_src_buffer = & cpi -> alt_ref_buffer ;\n }\n cpi -> frames_till_alt_ref_frame = cpi -> frames_till_gf_update_due ;\n cm -> refresh_alt_ref_frame = 1 ;\n cm -> refresh_golden_frame = 0 ;\n cm -> refresh_last_frame = 0 ;\n cm -> show_frame = 0 ;\n cpi -> source_alt_ref_pending = 0 ;\n cpi -> is_src_frame_alt_ref = 0 ;\n }\n }\n # endif if ( ! cpi -> source ) {\n if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) {\n if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , PEEK_BACKWARD ) ) == NULL ) return - 1 ;\n }\n if ( ( cpi -> source = vp8_lookahead_pop ( cpi -> lookahead , flush ) ) ) {\n cm -> show_frame = 1 ;\n cpi -> is_src_frame_alt_ref = cpi -> alt_ref_source && ( cpi -> source == cpi -> alt_ref_source ) ;\n if ( cpi -> is_src_frame_alt_ref ) cpi -> alt_ref_source = NULL ;\n }\n }\n if ( cpi -> source ) {\n cpi -> Source = force_src_buffer ? force_src_buffer : & cpi -> source -> img ;\n cpi -> un_scaled_source = cpi -> Source ;\n * time_stamp = cpi -> source -> ts_start ;\n * time_end = cpi -> source -> ts_end ;\n * frame_flags = cpi -> source -> flags ;\n if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) {\n cpi -> last_frame_unscaled_source = & cpi -> last_source -> img ;\n }\n }\n else {\n * size = 0 ;\n # if ! ( CONFIG_REALTIME_ONLY ) if ( flush && cpi -> pass == 1 && ! cpi -> twopass . first_pass_done ) {\n vp8_end_first_pass ( cpi ) ;\n cpi -> twopass . first_pass_done = 1 ;\n }\n # endif return - 1 ;\n }\n if ( cpi -> source -> ts_start < cpi -> first_time_stamp_ever ) {\n cpi -> first_time_stamp_ever = cpi -> source -> ts_start ;\n cpi -> last_end_time_stamp_seen = cpi -> source -> ts_start ;\n }\n if ( cm -> show_frame ) {\n int64_t this_duration ;\n int step = 0 ;\n if ( cpi -> source -> ts_start == cpi -> first_time_stamp_ever ) {\n this_duration = cpi -> source -> ts_end - cpi -> source -> ts_start ;\n step = 1 ;\n }\n else {\n int64_t last_duration ;\n this_duration = cpi -> source -> ts_end - cpi -> last_end_time_stamp_seen ;\n last_duration = cpi -> last_end_time_stamp_seen - cpi -> last_time_stamp_seen ;\n if ( last_duration ) step = ( int ) ( ( ( this_duration - last_duration ) * / last_duration ) ) ;\n }\n if ( this_duration ) {\n if ( step ) cpi -> ref_framerate = 10000000.0 / this_duration ;\n else {\n double avg_duration , interval ;\n interval = ( double ) ( cpi -> source -> ts_end - cpi -> first_time_stamp_ever ) ;\n if ( interval > 10000000.0 ) interval = 10000000 ;\n avg_duration = 10000000.0 / cpi -> ref_framerate ;\n avg_duration *= ( interval - avg_duration + this_duration ) ;\n avg_duration /= interval ;\n cpi -> ref_framerate = 10000000.0 / avg_duration ;\n }\n if ( cpi -> oxcf . number_of_layers > 1 ) {\n unsigned int i ;\n assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ;\n for ( i = 0 ;\n i < cpi -> oxcf . number_of_layers && i < VPX_TS_MAX_LAYERS ;\n ++ i ) {\n LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ;\n lc -> framerate = cpi -> ref_framerate / cpi -> oxcf . rate_decimator [ i ] ;\n }\n }\n else vp8_new_framerate ( cpi , cpi -> ref_framerate ) ;\n }\n cpi -> last_time_stamp_seen = cpi -> source -> ts_start ;\n cpi -> last_end_time_stamp_seen = cpi -> source -> ts_end ;\n }\n if ( cpi -> oxcf . number_of_layers > 1 ) {\n int layer ;\n update_layer_contexts ( cpi ) ;\n layer = cpi -> oxcf . layer_id [ cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ;\n restore_layer_context ( cpi , layer ) ;\n vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ;\n }\n if ( cpi -> compressor_speed == 2 ) {\n vpx_usec_timer_start ( & tsctimer ) ;\n vpx_usec_timer_start ( & ticktimer ) ;\n }\n cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ;\n # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING {\n int i ;\n const int num_part = ( 1 << cm -> multi_token_partition ) ;\n const unsigned long dest_size = dest_end - dest ;\n const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ;\n unsigned char * dp = dest ;\n cpi -> partition_d [ 0 ] = dp ;\n dp += dest_size / 10 ;\n cpi -> partition_d_end [ 0 ] = dp ;\n for ( i = 0 ;\n i < num_part ;\n i ++ ) {\n cpi -> partition_d [ i + 1 ] = dp ;\n dp += tok_part_buff_size ;\n cpi -> partition_d_end [ i + 1 ] = dp ;\n }\n }\n # endif * size = 0 ;\n vp8_clear_system_state ( ) ;\n cm -> frame_type = INTER_FRAME ;\n cm -> frame_flags = * frame_flags ;\n # if 0 if ( cm -> refresh_alt_ref_frame ) {\n cm -> refresh_golden_frame = 0 ;\n cm -> refresh_last_frame = 0 ;\n }\n else {\n cm -> refresh_golden_frame = 0 ;\n cm -> refresh_last_frame = 1 ;\n }\n # endif {\n int i = 0 ;\n for ( ;\n i < NUM_YV12_BUFFERS ;\n i ++ ) {\n if ( ! cm -> yv12_fb [ i ] . flags ) {\n cm -> new_fb_idx = i ;\n break ;\n }\n }\n assert ( i < NUM_YV12_BUFFERS ) ;\n }\n # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 1 ) {\n Pass1Encode ( cpi , size , dest , frame_flags ) ;\n }\n else if ( cpi -> pass == 2 ) {\n Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ;\n }\n else # endif encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ;\n if ( cpi -> compressor_speed == 2 ) {\n unsigned int duration , duration2 ;\n vpx_usec_timer_mark ( & tsctimer ) ;\n vpx_usec_timer_mark ( & ticktimer ) ;\n duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ;\n duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ;\n if ( cm -> frame_type != KEY_FRAME ) {\n if ( cpi -> avg_encode_time == 0 ) cpi -> avg_encode_time = duration ;\n else cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ;\n }\n if ( duration2 ) {\n {\n if ( cpi -> avg_pick_mode_time == 0 ) cpi -> avg_pick_mode_time = duration2 ;\n else cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ;\n }\n }\n }\n if ( cm -> refresh_entropy_probs == 0 ) {\n vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ;\n }\n if ( cm -> refresh_alt_ref_frame ) vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ;\n if ( cm -> refresh_golden_frame ) vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ;\n if ( cm -> refresh_last_frame ) vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ;\n if ( * size > 0 ) {\n cpi -> droppable = ! frame_is_reference ( cpi ) ;\n cm -> refresh_entropy_probs = 1 ;\n cm -> refresh_alt_ref_frame = 0 ;\n cm -> refresh_golden_frame = 0 ;\n cm -> refresh_last_frame = 1 ;\n cm -> frame_type = INTER_FRAME ;\n }\n if ( cpi -> oxcf . number_of_layers > 1 ) save_layer_context ( cpi ) ;\n vpx_usec_timer_mark ( & cmptimer ) ;\n cpi -> time_compress_data += vpx_usec_timer_elapsed ( & cmptimer ) ;\n if ( cpi -> b_calculate_psnr && cpi -> pass != 1 && cm -> show_frame ) {\n generate_psnr_packet ( cpi ) ;\n }\n # if CONFIG_INTERNAL_STATS if ( cpi -> pass != 1 ) {\n cpi -> bytes += * size ;\n if ( cm -> show_frame ) {\n cpi -> common . show_frame_mi = cpi -> common . mi ;\n cpi -> count ++ ;\n if ( cpi -> b_calculate_psnr ) {\n uint64_t ye , ue , ve ;\n double frame_psnr ;\n YV12_BUFFER_CONFIG * orig = cpi -> Source ;\n YV12_BUFFER_CONFIG * recon = cpi -> common . frame_to_show ;\n int y_samples = orig -> y_height * orig -> y_width ;\n int uv_samples = orig -> uv_height * orig -> uv_width ;\n int t_samples = y_samples + 2 * uv_samples ;\n double sq_error ;\n ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride , recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ;\n ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;\n ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ;\n sq_error = ( double ) ( ye + ue + ve ) ;\n frame_psnr = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error ) ;\n cpi -> total_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ;\n cpi -> total_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ;\n cpi -> total_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ;\n cpi -> total_sq_error += sq_error ;\n cpi -> total += frame_psnr ;\n # if CONFIG_POSTPROC {\n YV12_BUFFER_CONFIG * pp = & cm -> post_proc_buffer ;\n double sq_error2 ;\n double frame_psnr2 , frame_ssim2 = 0 ;\n double weight = 0 ;\n vp8_deblock ( cm , cm -> frame_to_show , & cm -> post_proc_buffer , cm -> filter_level * 10 / 6 , 1 , 0 ) ;\n vp8_clear_system_state ( ) ;\n ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride , pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ;\n ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;\n ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ;\n sq_error2 = ( double ) ( ye + ue + ve ) ;\n frame_psnr2 = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error2 ) ;\n cpi -> totalp_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ;\n cpi -> totalp_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ;\n cpi -> totalp_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ;\n cpi -> total_sq_error2 += sq_error2 ;\n cpi -> totalp += frame_psnr2 ;\n frame_ssim2 = vp8_calc_ssim ( cpi -> Source , & cm -> post_proc_buffer , 1 , & weight ) ;\n cpi -> summed_quality += frame_ssim2 * weight ;\n cpi -> summed_weights += weight ;\n if ( cpi -> oxcf . number_of_layers > 1 ) {\n unsigned int i ;\n for ( i = cpi -> current_layer ;\n i < cpi -> oxcf . number_of_layers ;\n i ++ ) {\n cpi -> frames_in_layer [ i ] ++ ;\n cpi -> bytes_in_layer [ i ] += * size ;\n cpi -> sum_psnr [ i ] += frame_psnr ;\n cpi -> sum_psnr_p [ i ] += frame_psnr2 ;\n cpi -> total_error2 [ i ] += sq_error ;\n cpi -> total_error2_p [ i ] += sq_error2 ;\n cpi -> sum_ssim [ i ] += frame_ssim2 * weight ;\n cpi -> sum_weights [ i ] += weight ;\n }\n }\n }\n # endif }\n if ( cpi -> b_calculate_ssimg ) {\n double y , u , v , frame_all ;\n frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show , & y , & u , & v ) ;\n if ( cpi -> oxcf . number_of_layers > 1 ) {\n unsigned int i ;\n for ( i = cpi -> current_layer ;\n i < cpi -> oxcf . number_of_layers ;\n i ++ ) {\n if ( ! cpi -> b_calculate_psnr ) cpi -> frames_in_layer [ i ] ++ ;\n cpi -> total_ssimg_y_in_layer [ i ] += y ;\n cpi -> total_ssimg_u_in_layer [ i ] += u ;\n cpi -> total_ssimg_v_in_layer [ i ] += v ;\n cpi -> total_ssimg_all_in_layer [ i ] += frame_all ;\n }\n }\n else {\n cpi -> total_ssimg_y += y ;\n cpi -> total_ssimg_u += u ;\n cpi -> total_ssimg_v += v ;\n cpi -> total_ssimg_all += frame_all ;\n }\n }\n }\n }\n # if 0 if ( cpi -> common . frame_type != 0 && cpi -> common . base_qindex == cpi -> oxcf . worst_allowed_q ) {\n skiptruecount += cpi -> skip_true_count ;\n skipfalsecount += cpi -> skip_false_count ;\n }\n # endif # if 0 if ( cpi -> pass != 1 ) {\n FILE * f = fopen ( \"skip.stt\" , \"a\" ) ;\n fprintf ( f , \"frame:%4d flags:%4x Q:%4d P:%4d Size:%5d\\n\" , cpi -> common . current_video_frame , * frame_flags , cpi -> common . base_qindex , cpi -> prob_skip_false , * size ) ;\n if ( cpi -> is_src_frame_alt_ref == 1 ) fprintf ( f , \"skipcount: %4d framesize: %d\\n\" , cpi -> skip_true_count , * size ) ;\n fclose ( f ) ;\n }\n # endif # endif cpi -> common . error . setjmp = 0 ;\n return 0 ;\n }", "hash": -3384986069176965684, "project": "chrome", "size": 298, "target": 0, "idx": 17093}
{"code": "void vp8_alloc_compressor_data ( VP8_COMP * cpi ) {\n VP8_COMMON * cm = & cpi -> common ;\n int width = cm -> Width ;\n int height = cm -> Height ;\n if ( vp8_alloc_frame_buffers ( cm , width , height ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , \"Failed to allocate frame buffers\" ) ;\n if ( vp8_alloc_partition_data ( cpi ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , \"Failed to allocate partition data\" ) ;\n if ( ( width & 0xf ) != 0 ) width += 16 - ( width & 0xf ) ;\n if ( ( height & 0xf ) != 0 ) height += 16 - ( height & 0xf ) ;\n if ( vp8_yv12_alloc_frame_buffer ( & cpi -> pick_lf_lvl_frame , width , height , VP8BORDERINPIXELS ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , \"Failed to allocate last frame buffer\" ) ;\n if ( vp8_yv12_alloc_frame_buffer ( & cpi -> scaled_source , width , height , VP8BORDERINPIXELS ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , \"Failed to allocate scaled source buffer\" ) ;\n vpx_free ( cpi -> tok ) ;\n {\n # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING unsigned int tokens = 8 * 24 * 16 ;\n # else unsigned int tokens = cm -> mb_rows * cm -> mb_cols * 24 * 16 ;\n # endif CHECK_MEM_ERROR ( cpi -> tok , vpx_calloc ( tokens , sizeof ( * cpi -> tok ) ) ) ;\n }\n cpi -> zeromv_count = 0 ;\n vpx_free ( cpi -> gf_active_flags ) ;\n CHECK_MEM_ERROR ( cpi -> gf_active_flags , vpx_calloc ( sizeof ( * cpi -> gf_active_flags ) , cm -> mb_rows * cm -> mb_cols ) ) ;\n cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ;\n vpx_free ( cpi -> mb_activity_map ) ;\n CHECK_MEM_ERROR ( cpi -> mb_activity_map , vpx_calloc ( sizeof ( * cpi -> mb_activity_map ) , cm -> mb_rows * cm -> mb_cols ) ) ;\n vpx_free ( cpi -> lfmv ) ;\n CHECK_MEM_ERROR ( cpi -> lfmv , vpx_calloc ( ( cm -> mb_rows + 2 ) * ( cm -> mb_cols + 2 ) , sizeof ( * cpi -> lfmv ) ) ) ;\n vpx_free ( cpi -> lf_ref_frame_sign_bias ) ;\n CHECK_MEM_ERROR ( cpi -> lf_ref_frame_sign_bias , vpx_calloc ( ( cm -> mb_rows + 2 ) * ( cm -> mb_cols + 2 ) , sizeof ( * cpi -> lf_ref_frame_sign_bias ) ) ) ;\n vpx_free ( cpi -> lf_ref_frame ) ;\n CHECK_MEM_ERROR ( cpi -> lf_ref_frame , vpx_calloc ( ( cm -> mb_rows + 2 ) * ( cm -> mb_cols + 2 ) , sizeof ( * cpi -> lf_ref_frame ) ) ) ;\n vpx_free ( cpi -> segmentation_map ) ;\n CHECK_MEM_ERROR ( cpi -> segmentation_map , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , sizeof ( * cpi -> segmentation_map ) ) ) ;\n cpi -> cyclic_refresh_mode_index = 0 ;\n vpx_free ( cpi -> active_map ) ;\n CHECK_MEM_ERROR ( cpi -> active_map , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , sizeof ( * cpi -> active_map ) ) ) ;\n vpx_memset ( cpi -> active_map , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;\n # if CONFIG_MULTITHREAD if ( width < 640 ) cpi -> mt_sync_range = 1 ;\n else if ( width <= 1280 ) cpi -> mt_sync_range = 4 ;\n else if ( width <= 2560 ) cpi -> mt_sync_range = 8 ;\n else cpi -> mt_sync_range = 16 ;\n if ( cpi -> oxcf . multi_threaded > 1 ) {\n vpx_free ( cpi -> mt_current_mb_col ) ;\n CHECK_MEM_ERROR ( cpi -> mt_current_mb_col , vpx_malloc ( sizeof ( * cpi -> mt_current_mb_col ) * cm -> mb_rows ) ) ;\n }\n # endif vpx_free ( cpi -> tplist ) ;\n CHECK_MEM_ERROR ( cpi -> tplist , vpx_malloc ( sizeof ( TOKENLIST ) * cm -> mb_rows ) ) ;\n # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) {\n vp8_denoiser_free ( & cpi -> denoiser ) ;\n vp8_denoiser_allocate ( & cpi -> denoiser , width , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity ) ;\n }\n # endif }", "hash": -3384986069176965684, "project": "chrome", "size": 49, "target": 0, "idx": 17109}
{"code": "static int search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , int partial_frame ) {\n const VP9_COMMON * const cm = & cpi -> common ;\n const struct loopfilter * const lf = & cm -> lf ;\n const int min_filter_level = 0 ;\n const int max_filter_level = get_max_filter_level ( cpi ) ;\n int filt_direction = 0 ;\n int best_err , filt_best ;\n int filt_mid = clamp ( lf -> filter_level , min_filter_level , max_filter_level ) ;\n int filter_step = filt_mid < 16 ? 4 : filt_mid / 4 ;\n int ss_err [ MAX_LOOP_FILTER + 1 ] ;\n vpx_memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ;\n vpx_yv12_copy_y ( cm -> frame_to_show , & cpi -> last_frame_uf ) ;\n best_err = try_filter_frame ( sd , cpi , filt_mid , partial_frame ) ;\n filt_best = filt_mid ;\n ss_err [ filt_mid ] = best_err ;\n while ( filter_step > 0 ) {\n const int filt_high = MIN ( filt_mid + filter_step , max_filter_level ) ;\n const int filt_low = MAX ( filt_mid - filter_step , min_filter_level ) ;\n int bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ;\n if ( ( cpi -> oxcf . pass == 2 ) && ( cpi -> twopass . section_intra_rating < 20 ) ) bias = ( bias * cpi -> twopass . section_intra_rating ) / 20 ;\n if ( cm -> tx_mode != ONLY_4X4 ) bias >>= 1 ;\n if ( filt_direction <= 0 && filt_low != filt_mid ) {\n if ( ss_err [ filt_low ] < 0 ) {\n ss_err [ filt_low ] = try_filter_frame ( sd , cpi , filt_low , partial_frame ) ;\n }\n if ( ( ss_err [ filt_low ] - bias ) < best_err ) {\n if ( ss_err [ filt_low ] < best_err ) best_err = ss_err [ filt_low ] ;\n filt_best = filt_low ;\n }\n }\n if ( filt_direction >= 0 && filt_high != filt_mid ) {\n if ( ss_err [ filt_high ] < 0 ) {\n ss_err [ filt_high ] = try_filter_frame ( sd , cpi , filt_high , partial_frame ) ;\n }\n if ( ss_err [ filt_high ] < ( best_err - bias ) ) {\n best_err = ss_err [ filt_high ] ;\n filt_best = filt_high ;\n }\n }\n if ( filt_best == filt_mid ) {\n filter_step /= 2 ;\n filt_direction = 0 ;\n }\n else {\n filt_direction = ( filt_best < filt_mid ) ? - 1 : 1 ;\n filt_mid = filt_best ;\n }\n }\n return filt_best ;\n }", "hash": -1579723330456999443, "project": "chrome", "size": 50, "target": 0, "idx": 17120}
{"code": "unsigned int vp8_sub_pixel_variance16x16_neon_func ( const unsigned char * src_ptr , int src_pixels_per_line , int xoffset , int yoffset , const unsigned char * dst_ptr , int dst_pixels_per_line , unsigned int * sse ) {\n int i ;\n DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , tmp , 528 ) ;\n unsigned char * tmpp ;\n unsigned char * tmpp2 ;\n uint8x8_t d0u8 , d1u8 , d2u8 , d3u8 , d4u8 , d5u8 , d6u8 , d7u8 , d8u8 , d9u8 ;\n uint8x8_t d10u8 , d11u8 , d12u8 , d13u8 , d14u8 , d15u8 , d16u8 , d17u8 , d18u8 ;\n uint8x8_t d19u8 , d20u8 , d21u8 ;\n int16x4_t d22s16 , d23s16 , d24s16 , d25s16 , d26s16 , d27s16 , d28s16 , d29s16 ;\n uint32x2_t d0u32 , d10u32 ;\n int64x1_t d0s64 , d1s64 , d2s64 , d3s64 ;\n uint8x16_t q0u8 , q1u8 , q2u8 , q3u8 , q4u8 , q5u8 , q6u8 , q7u8 , q8u8 , q9u8 ;\n uint8x16_t q10u8 , q11u8 , q12u8 , q13u8 , q14u8 , q15u8 ;\n uint16x8_t q1u16 , q2u16 , q3u16 , q4u16 , q5u16 , q6u16 , q7u16 , q8u16 ;\n uint16x8_t q9u16 , q10u16 , q11u16 , q12u16 , q13u16 , q14u16 ;\n int32x4_t q8s32 , q9s32 , q10s32 ;\n int64x2_t q0s64 , q1s64 , q5s64 ;\n tmpp2 = tmp + 272 ;\n tmpp = tmp ;\n if ( xoffset == 0 ) {\n d0u8 = vdup_n_u8 ( bilinear_taps_coeff [ yoffset ] [ 0 ] ) ;\n d1u8 = vdup_n_u8 ( bilinear_taps_coeff [ yoffset ] [ 1 ] ) ;\n q11u8 = vld1q_u8 ( src_ptr ) ;\n src_ptr += src_pixels_per_line ;\n for ( i = 4 ;\n i > 0 ;\n i -- ) {\n q12u8 = vld1q_u8 ( src_ptr ) ;\n src_ptr += src_pixels_per_line ;\n q13u8 = vld1q_u8 ( src_ptr ) ;\n src_ptr += src_pixels_per_line ;\n q14u8 = vld1q_u8 ( src_ptr ) ;\n src_ptr += src_pixels_per_line ;\n q15u8 = vld1q_u8 ( src_ptr ) ;\n src_ptr += src_pixels_per_line ;\n __builtin_prefetch ( src_ptr ) ;\n __builtin_prefetch ( src_ptr + src_pixels_per_line ) ;\n __builtin_prefetch ( src_ptr + src_pixels_per_line * 2 ) ;\n q1u16 = vmull_u8 ( vget_low_u8 ( q11u8 ) , d0u8 ) ;\n q2u16 = vmull_u8 ( vget_high_u8 ( q11u8 ) , d0u8 ) ;\n q3u16 = vmull_u8 ( vget_low_u8 ( q12u8 ) , d0u8 ) ;\n q4u16 = vmull_u8 ( vget_high_u8 ( q12u8 ) , d0u8 ) ;\n q5u16 = vmull_u8 ( vget_low_u8 ( q13u8 ) , d0u8 ) ;\n q6u16 = vmull_u8 ( vget_high_u8 ( q13u8 ) , d0u8 ) ;\n q7u16 = vmull_u8 ( vget_low_u8 ( q14u8 ) , d0u8 ) ;\n q8u16 = vmull_u8 ( vget_high_u8 ( q14u8 ) , d0u8 ) ;\n q1u16 = vmlal_u8 ( q1u16 , vget_low_u8 ( q12u8 ) , d1u8 ) ;\n q2u16 = vmlal_u8 ( q2u16 , vget_high_u8 ( q12u8 ) , d1u8 ) ;\n q3u16 = vmlal_u8 ( q3u16 , vget_low_u8 ( q13u8 ) , d1u8 ) ;\n q4u16 = vmlal_u8 ( q4u16 , vget_high_u8 ( q13u8 ) , d1u8 ) ;\n q5u16 = vmlal_u8 ( q5u16 , vget_low_u8 ( q14u8 ) , d1u8 ) ;\n q6u16 = vmlal_u8 ( q6u16 , vget_high_u8 ( q14u8 ) , d1u8 ) ;\n q7u16 = vmlal_u8 ( q7u16 , vget_low_u8 ( q15u8 ) , d1u8 ) ;\n q8u16 = vmlal_u8 ( q8u16 , vget_high_u8 ( q15u8 ) , d1u8 ) ;\n d2u8 = vqrshrn_n_u16 ( q1u16 , 7 ) ;\n d3u8 = vqrshrn_n_u16 ( q2u16 , 7 ) ;\n d4u8 = vqrshrn_n_u16 ( q3u16 , 7 ) ;\n d5u8 = vqrshrn_n_u16 ( q4u16 , 7 ) ;\n d6u8 = vqrshrn_n_u16 ( q5u16 , 7 ) ;\n d7u8 = vqrshrn_n_u16 ( q6u16 , 7 ) ;\n d8u8 = vqrshrn_n_u16 ( q7u16 , 7 ) ;\n d9u8 = vqrshrn_n_u16 ( q8u16 , 7 ) ;\n q1u8 = vcombine_u8 ( d2u8 , d3u8 ) ;\n q2u8 = vcombine_u8 ( d4u8 , d5u8 ) ;\n q3u8 = vcombine_u8 ( d6u8 , d7u8 ) ;\n q4u8 = vcombine_u8 ( d8u8 , d9u8 ) ;\n q11u8 = q15u8 ;\n vst1q_u8 ( ( uint8_t * ) tmpp2 , q1u8 ) ;\n tmpp2 += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp2 , q2u8 ) ;\n tmpp2 += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp2 , q3u8 ) ;\n tmpp2 += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp2 , q4u8 ) ;\n tmpp2 += 16 ;\n }\n }\n else if ( yoffset == 0 ) {\n d0u8 = vdup_n_u8 ( bilinear_taps_coeff [ xoffset ] [ 0 ] ) ;\n d1u8 = vdup_n_u8 ( bilinear_taps_coeff [ xoffset ] [ 1 ] ) ;\n for ( i = 4 ;\n i > 0 ;\n i -- ) {\n d2u8 = vld1_u8 ( src_ptr ) ;\n d3u8 = vld1_u8 ( src_ptr + 8 ) ;\n d4u8 = vld1_u8 ( src_ptr + 16 ) ;\n src_ptr += src_pixels_per_line ;\n d5u8 = vld1_u8 ( src_ptr ) ;\n d6u8 = vld1_u8 ( src_ptr + 8 ) ;\n d7u8 = vld1_u8 ( src_ptr + 16 ) ;\n src_ptr += src_pixels_per_line ;\n d8u8 = vld1_u8 ( src_ptr ) ;\n d9u8 = vld1_u8 ( src_ptr + 8 ) ;\n d10u8 = vld1_u8 ( src_ptr + 16 ) ;\n src_ptr += src_pixels_per_line ;\n d11u8 = vld1_u8 ( src_ptr ) ;\n d12u8 = vld1_u8 ( src_ptr + 8 ) ;\n d13u8 = vld1_u8 ( src_ptr + 16 ) ;\n src_ptr += src_pixels_per_line ;\n __builtin_prefetch ( src_ptr ) ;\n __builtin_prefetch ( src_ptr + src_pixels_per_line ) ;\n __builtin_prefetch ( src_ptr + src_pixels_per_line * 2 ) ;\n q7u16 = vmull_u8 ( d2u8 , d0u8 ) ;\n q8u16 = vmull_u8 ( d3u8 , d0u8 ) ;\n q9u16 = vmull_u8 ( d5u8 , d0u8 ) ;\n q10u16 = vmull_u8 ( d6u8 , d0u8 ) ;\n q11u16 = vmull_u8 ( d8u8 , d0u8 ) ;\n q12u16 = vmull_u8 ( d9u8 , d0u8 ) ;\n q13u16 = vmull_u8 ( d11u8 , d0u8 ) ;\n q14u16 = vmull_u8 ( d12u8 , d0u8 ) ;\n d2u8 = vext_u8 ( d2u8 , d3u8 , 1 ) ;\n d5u8 = vext_u8 ( d5u8 , d6u8 , 1 ) ;\n d8u8 = vext_u8 ( d8u8 , d9u8 , 1 ) ;\n d11u8 = vext_u8 ( d11u8 , d12u8 , 1 ) ;\n q7u16 = vmlal_u8 ( q7u16 , d2u8 , d1u8 ) ;\n q9u16 = vmlal_u8 ( q9u16 , d5u8 , d1u8 ) ;\n q11u16 = vmlal_u8 ( q11u16 , d8u8 , d1u8 ) ;\n q13u16 = vmlal_u8 ( q13u16 , d11u8 , d1u8 ) ;\n d3u8 = vext_u8 ( d3u8 , d4u8 , 1 ) ;\n d6u8 = vext_u8 ( d6u8 , d7u8 , 1 ) ;\n d9u8 = vext_u8 ( d9u8 , d10u8 , 1 ) ;\n d12u8 = vext_u8 ( d12u8 , d13u8 , 1 ) ;\n q8u16 = vmlal_u8 ( q8u16 , d3u8 , d1u8 ) ;\n q10u16 = vmlal_u8 ( q10u16 , d6u8 , d1u8 ) ;\n q12u16 = vmlal_u8 ( q12u16 , d9u8 , d1u8 ) ;\n q14u16 = vmlal_u8 ( q14u16 , d12u8 , d1u8 ) ;\n d14u8 = vqrshrn_n_u16 ( q7u16 , 7 ) ;\n d15u8 = vqrshrn_n_u16 ( q8u16 , 7 ) ;\n d16u8 = vqrshrn_n_u16 ( q9u16 , 7 ) ;\n d17u8 = vqrshrn_n_u16 ( q10u16 , 7 ) ;\n d18u8 = vqrshrn_n_u16 ( q11u16 , 7 ) ;\n d19u8 = vqrshrn_n_u16 ( q12u16 , 7 ) ;\n d20u8 = vqrshrn_n_u16 ( q13u16 , 7 ) ;\n d21u8 = vqrshrn_n_u16 ( q14u16 , 7 ) ;\n q7u8 = vcombine_u8 ( d14u8 , d15u8 ) ;\n q8u8 = vcombine_u8 ( d16u8 , d17u8 ) ;\n q9u8 = vcombine_u8 ( d18u8 , d19u8 ) ;\n q10u8 = vcombine_u8 ( d20u8 , d21u8 ) ;\n vst1q_u8 ( ( uint8_t * ) tmpp2 , q7u8 ) ;\n tmpp2 += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp2 , q8u8 ) ;\n tmpp2 += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp2 , q9u8 ) ;\n tmpp2 += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp2 , q10u8 ) ;\n tmpp2 += 16 ;\n }\n }\n else {\n d0u8 = vdup_n_u8 ( bilinear_taps_coeff [ xoffset ] [ 0 ] ) ;\n d1u8 = vdup_n_u8 ( bilinear_taps_coeff [ xoffset ] [ 1 ] ) ;\n d2u8 = vld1_u8 ( src_ptr ) ;\n d3u8 = vld1_u8 ( src_ptr + 8 ) ;\n d4u8 = vld1_u8 ( src_ptr + 16 ) ;\n src_ptr += src_pixels_per_line ;\n d5u8 = vld1_u8 ( src_ptr ) ;\n d6u8 = vld1_u8 ( src_ptr + 8 ) ;\n d7u8 = vld1_u8 ( src_ptr + 16 ) ;\n src_ptr += src_pixels_per_line ;\n d8u8 = vld1_u8 ( src_ptr ) ;\n d9u8 = vld1_u8 ( src_ptr + 8 ) ;\n d10u8 = vld1_u8 ( src_ptr + 16 ) ;\n src_ptr += src_pixels_per_line ;\n d11u8 = vld1_u8 ( src_ptr ) ;\n d12u8 = vld1_u8 ( src_ptr + 8 ) ;\n d13u8 = vld1_u8 ( src_ptr + 16 ) ;\n src_ptr += src_pixels_per_line ;\n for ( i = 3 ;\n i > 0 ;\n i -- ) {\n q7u16 = vmull_u8 ( d2u8 , d0u8 ) ;\n q8u16 = vmull_u8 ( d3u8 , d0u8 ) ;\n q9u16 = vmull_u8 ( d5u8 , d0u8 ) ;\n q10u16 = vmull_u8 ( d6u8 , d0u8 ) ;\n q11u16 = vmull_u8 ( d8u8 , d0u8 ) ;\n q12u16 = vmull_u8 ( d9u8 , d0u8 ) ;\n q13u16 = vmull_u8 ( d11u8 , d0u8 ) ;\n q14u16 = vmull_u8 ( d12u8 , d0u8 ) ;\n d2u8 = vext_u8 ( d2u8 , d3u8 , 1 ) ;\n d5u8 = vext_u8 ( d5u8 , d6u8 , 1 ) ;\n d8u8 = vext_u8 ( d8u8 , d9u8 , 1 ) ;\n d11u8 = vext_u8 ( d11u8 , d12u8 , 1 ) ;\n q7u16 = vmlal_u8 ( q7u16 , d2u8 , d1u8 ) ;\n q9u16 = vmlal_u8 ( q9u16 , d5u8 , d1u8 ) ;\n q11u16 = vmlal_u8 ( q11u16 , d8u8 , d1u8 ) ;\n q13u16 = vmlal_u8 ( q13u16 , d11u8 , d1u8 ) ;\n d3u8 = vext_u8 ( d3u8 , d4u8 , 1 ) ;\n d6u8 = vext_u8 ( d6u8 , d7u8 , 1 ) ;\n d9u8 = vext_u8 ( d9u8 , d10u8 , 1 ) ;\n d12u8 = vext_u8 ( d12u8 , d13u8 , 1 ) ;\n q8u16 = vmlal_u8 ( q8u16 , d3u8 , d1u8 ) ;\n q10u16 = vmlal_u8 ( q10u16 , d6u8 , d1u8 ) ;\n q12u16 = vmlal_u8 ( q12u16 , d9u8 , d1u8 ) ;\n q14u16 = vmlal_u8 ( q14u16 , d12u8 , d1u8 ) ;\n d14u8 = vqrshrn_n_u16 ( q7u16 , 7 ) ;\n d15u8 = vqrshrn_n_u16 ( q8u16 , 7 ) ;\n d16u8 = vqrshrn_n_u16 ( q9u16 , 7 ) ;\n d17u8 = vqrshrn_n_u16 ( q10u16 , 7 ) ;\n d18u8 = vqrshrn_n_u16 ( q11u16 , 7 ) ;\n d19u8 = vqrshrn_n_u16 ( q12u16 , 7 ) ;\n d20u8 = vqrshrn_n_u16 ( q13u16 , 7 ) ;\n d21u8 = vqrshrn_n_u16 ( q14u16 , 7 ) ;\n d2u8 = vld1_u8 ( src_ptr ) ;\n d3u8 = vld1_u8 ( src_ptr + 8 ) ;\n d4u8 = vld1_u8 ( src_ptr + 16 ) ;\n src_ptr += src_pixels_per_line ;\n d5u8 = vld1_u8 ( src_ptr ) ;\n d6u8 = vld1_u8 ( src_ptr + 8 ) ;\n d7u8 = vld1_u8 ( src_ptr + 16 ) ;\n src_ptr += src_pixels_per_line ;\n d8u8 = vld1_u8 ( src_ptr ) ;\n d9u8 = vld1_u8 ( src_ptr + 8 ) ;\n d10u8 = vld1_u8 ( src_ptr + 16 ) ;\n src_ptr += src_pixels_per_line ;\n d11u8 = vld1_u8 ( src_ptr ) ;\n d12u8 = vld1_u8 ( src_ptr + 8 ) ;\n d13u8 = vld1_u8 ( src_ptr + 16 ) ;\n src_ptr += src_pixels_per_line ;\n q7u8 = vcombine_u8 ( d14u8 , d15u8 ) ;\n q8u8 = vcombine_u8 ( d16u8 , d17u8 ) ;\n q9u8 = vcombine_u8 ( d18u8 , d19u8 ) ;\n q10u8 = vcombine_u8 ( d20u8 , d21u8 ) ;\n vst1q_u8 ( ( uint8_t * ) tmpp , q7u8 ) ;\n tmpp += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp , q8u8 ) ;\n tmpp += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp , q9u8 ) ;\n tmpp += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp , q10u8 ) ;\n tmpp += 16 ;\n }\n d14u8 = vld1_u8 ( src_ptr ) ;\n d15u8 = vld1_u8 ( src_ptr + 8 ) ;\n d16u8 = vld1_u8 ( src_ptr + 16 ) ;\n src_ptr += src_pixels_per_line ;\n q9u16 = vmull_u8 ( d2u8 , d0u8 ) ;\n q10u16 = vmull_u8 ( d3u8 , d0u8 ) ;\n q11u16 = vmull_u8 ( d5u8 , d0u8 ) ;\n q12u16 = vmull_u8 ( d6u8 , d0u8 ) ;\n q13u16 = vmull_u8 ( d8u8 , d0u8 ) ;\n q14u16 = vmull_u8 ( d9u8 , d0u8 ) ;\n d2u8 = vext_u8 ( d2u8 , d3u8 , 1 ) ;\n d5u8 = vext_u8 ( d5u8 , d6u8 , 1 ) ;\n d8u8 = vext_u8 ( d8u8 , d9u8 , 1 ) ;\n q9u16 = vmlal_u8 ( q9u16 , d2u8 , d1u8 ) ;\n q11u16 = vmlal_u8 ( q11u16 , d5u8 , d1u8 ) ;\n q13u16 = vmlal_u8 ( q13u16 , d8u8 , d1u8 ) ;\n d3u8 = vext_u8 ( d3u8 , d4u8 , 1 ) ;\n d6u8 = vext_u8 ( d6u8 , d7u8 , 1 ) ;\n d9u8 = vext_u8 ( d9u8 , d10u8 , 1 ) ;\n q10u16 = vmlal_u8 ( q10u16 , d3u8 , d1u8 ) ;\n q12u16 = vmlal_u8 ( q12u16 , d6u8 , d1u8 ) ;\n q14u16 = vmlal_u8 ( q14u16 , d9u8 , d1u8 ) ;\n q1u16 = vmull_u8 ( d11u8 , d0u8 ) ;\n q2u16 = vmull_u8 ( d12u8 , d0u8 ) ;\n q3u16 = vmull_u8 ( d14u8 , d0u8 ) ;\n q4u16 = vmull_u8 ( d15u8 , d0u8 ) ;\n d11u8 = vext_u8 ( d11u8 , d12u8 , 1 ) ;\n d14u8 = vext_u8 ( d14u8 , d15u8 , 1 ) ;\n q1u16 = vmlal_u8 ( q1u16 , d11u8 , d1u8 ) ;\n q3u16 = vmlal_u8 ( q3u16 , d14u8 , d1u8 ) ;\n d12u8 = vext_u8 ( d12u8 , d13u8 , 1 ) ;\n d15u8 = vext_u8 ( d15u8 , d16u8 , 1 ) ;\n q2u16 = vmlal_u8 ( q2u16 , d12u8 , d1u8 ) ;\n q4u16 = vmlal_u8 ( q4u16 , d15u8 , d1u8 ) ;\n d10u8 = vqrshrn_n_u16 ( q9u16 , 7 ) ;\n d11u8 = vqrshrn_n_u16 ( q10u16 , 7 ) ;\n d12u8 = vqrshrn_n_u16 ( q11u16 , 7 ) ;\n d13u8 = vqrshrn_n_u16 ( q12u16 , 7 ) ;\n d14u8 = vqrshrn_n_u16 ( q13u16 , 7 ) ;\n d15u8 = vqrshrn_n_u16 ( q14u16 , 7 ) ;\n d16u8 = vqrshrn_n_u16 ( q1u16 , 7 ) ;\n d17u8 = vqrshrn_n_u16 ( q2u16 , 7 ) ;\n d18u8 = vqrshrn_n_u16 ( q3u16 , 7 ) ;\n d19u8 = vqrshrn_n_u16 ( q4u16 , 7 ) ;\n q5u8 = vcombine_u8 ( d10u8 , d11u8 ) ;\n q6u8 = vcombine_u8 ( d12u8 , d13u8 ) ;\n q7u8 = vcombine_u8 ( d14u8 , d15u8 ) ;\n q8u8 = vcombine_u8 ( d16u8 , d17u8 ) ;\n q9u8 = vcombine_u8 ( d18u8 , d19u8 ) ;\n vst1q_u8 ( ( uint8_t * ) tmpp , q5u8 ) ;\n tmpp += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp , q6u8 ) ;\n tmpp += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp , q7u8 ) ;\n tmpp += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp , q8u8 ) ;\n tmpp += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp , q9u8 ) ;\n d0u8 = vdup_n_u8 ( bilinear_taps_coeff [ yoffset ] [ 0 ] ) ;\n d1u8 = vdup_n_u8 ( bilinear_taps_coeff [ yoffset ] [ 1 ] ) ;\n tmpp = tmp ;\n tmpp2 = tmpp + 272 ;\n q11u8 = vld1q_u8 ( tmpp ) ;\n tmpp += 16 ;\n for ( i = 4 ;\n i > 0 ;\n i -- ) {\n q12u8 = vld1q_u8 ( tmpp ) ;\n tmpp += 16 ;\n q13u8 = vld1q_u8 ( tmpp ) ;\n tmpp += 16 ;\n q14u8 = vld1q_u8 ( tmpp ) ;\n tmpp += 16 ;\n q15u8 = vld1q_u8 ( tmpp ) ;\n tmpp += 16 ;\n q1u16 = vmull_u8 ( vget_low_u8 ( q11u8 ) , d0u8 ) ;\n q2u16 = vmull_u8 ( vget_high_u8 ( q11u8 ) , d0u8 ) ;\n q3u16 = vmull_u8 ( vget_low_u8 ( q12u8 ) , d0u8 ) ;\n q4u16 = vmull_u8 ( vget_high_u8 ( q12u8 ) , d0u8 ) ;\n q5u16 = vmull_u8 ( vget_low_u8 ( q13u8 ) , d0u8 ) ;\n q6u16 = vmull_u8 ( vget_high_u8 ( q13u8 ) , d0u8 ) ;\n q7u16 = vmull_u8 ( vget_low_u8 ( q14u8 ) , d0u8 ) ;\n q8u16 = vmull_u8 ( vget_high_u8 ( q14u8 ) , d0u8 ) ;\n q1u16 = vmlal_u8 ( q1u16 , vget_low_u8 ( q12u8 ) , d1u8 ) ;\n q2u16 = vmlal_u8 ( q2u16 , vget_high_u8 ( q12u8 ) , d1u8 ) ;\n q3u16 = vmlal_u8 ( q3u16 , vget_low_u8 ( q13u8 ) , d1u8 ) ;\n q4u16 = vmlal_u8 ( q4u16 , vget_high_u8 ( q13u8 ) , d1u8 ) ;\n q5u16 = vmlal_u8 ( q5u16 , vget_low_u8 ( q14u8 ) , d1u8 ) ;\n q6u16 = vmlal_u8 ( q6u16 , vget_high_u8 ( q14u8 ) , d1u8 ) ;\n q7u16 = vmlal_u8 ( q7u16 , vget_low_u8 ( q15u8 ) , d1u8 ) ;\n q8u16 = vmlal_u8 ( q8u16 , vget_high_u8 ( q15u8 ) , d1u8 ) ;\n d2u8 = vqrshrn_n_u16 ( q1u16 , 7 ) ;\n d3u8 = vqrshrn_n_u16 ( q2u16 , 7 ) ;\n d4u8 = vqrshrn_n_u16 ( q3u16 , 7 ) ;\n d5u8 = vqrshrn_n_u16 ( q4u16 , 7 ) ;\n d6u8 = vqrshrn_n_u16 ( q5u16 , 7 ) ;\n d7u8 = vqrshrn_n_u16 ( q6u16 , 7 ) ;\n d8u8 = vqrshrn_n_u16 ( q7u16 , 7 ) ;\n d9u8 = vqrshrn_n_u16 ( q8u16 , 7 ) ;\n q1u8 = vcombine_u8 ( d2u8 , d3u8 ) ;\n q2u8 = vcombine_u8 ( d4u8 , d5u8 ) ;\n q3u8 = vcombine_u8 ( d6u8 , d7u8 ) ;\n q4u8 = vcombine_u8 ( d8u8 , d9u8 ) ;\n q11u8 = q15u8 ;\n vst1q_u8 ( ( uint8_t * ) tmpp2 , q1u8 ) ;\n tmpp2 += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp2 , q2u8 ) ;\n tmpp2 += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp2 , q3u8 ) ;\n tmpp2 += 16 ;\n vst1q_u8 ( ( uint8_t * ) tmpp2 , q4u8 ) ;\n tmpp2 += 16 ;\n }\n }\n q8s32 = vdupq_n_s32 ( 0 ) ;\n q9s32 = vdupq_n_s32 ( 0 ) ;\n q10s32 = vdupq_n_s32 ( 0 ) ;\n tmpp = tmp + 272 ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n q0u8 = vld1q_u8 ( tmpp ) ;\n tmpp += 16 ;\n q1u8 = vld1q_u8 ( tmpp ) ;\n tmpp += 16 ;\n q2u8 = vld1q_u8 ( dst_ptr ) ;\n dst_ptr += dst_pixels_per_line ;\n q3u8 = vld1q_u8 ( dst_ptr ) ;\n dst_ptr += dst_pixels_per_line ;\n d0u8 = vget_low_u8 ( q0u8 ) ;\n d1u8 = vget_high_u8 ( q0u8 ) ;\n d2u8 = vget_low_u8 ( q1u8 ) ;\n d3u8 = vget_high_u8 ( q1u8 ) ;\n q11u16 = vsubl_u8 ( d0u8 , vget_low_u8 ( q2u8 ) ) ;\n q12u16 = vsubl_u8 ( d1u8 , vget_high_u8 ( q2u8 ) ) ;\n q13u16 = vsubl_u8 ( d2u8 , vget_low_u8 ( q3u8 ) ) ;\n q14u16 = vsubl_u8 ( d3u8 , vget_high_u8 ( q3u8 ) ) ;\n d22s16 = vreinterpret_s16_u16 ( vget_low_u16 ( q11u16 ) ) ;\n d23s16 = vreinterpret_s16_u16 ( vget_high_u16 ( q11u16 ) ) ;\n q8s32 = vpadalq_s16 ( q8s32 , vreinterpretq_s16_u16 ( q11u16 ) ) ;\n q9s32 = vmlal_s16 ( q9s32 , d22s16 , d22s16 ) ;\n q10s32 = vmlal_s16 ( q10s32 , d23s16 , d23s16 ) ;\n d24s16 = vreinterpret_s16_u16 ( vget_low_u16 ( q12u16 ) ) ;\n d25s16 = vreinterpret_s16_u16 ( vget_high_u16 ( q12u16 ) ) ;\n q8s32 = vpadalq_s16 ( q8s32 , vreinterpretq_s16_u16 ( q12u16 ) ) ;\n q9s32 = vmlal_s16 ( q9s32 , d24s16 , d24s16 ) ;\n q10s32 = vmlal_s16 ( q10s32 , d25s16 , d25s16 ) ;\n d26s16 = vreinterpret_s16_u16 ( vget_low_u16 ( q13u16 ) ) ;\n d27s16 = vreinterpret_s16_u16 ( vget_high_u16 ( q13u16 ) ) ;\n q8s32 = vpadalq_s16 ( q8s32 , vreinterpretq_s16_u16 ( q13u16 ) ) ;\n q9s32 = vmlal_s16 ( q9s32 , d26s16 , d26s16 ) ;\n q10s32 = vmlal_s16 ( q10s32 , d27s16 , d27s16 ) ;\n d28s16 = vreinterpret_s16_u16 ( vget_low_u16 ( q14u16 ) ) ;\n d29s16 = vreinterpret_s16_u16 ( vget_high_u16 ( q14u16 ) ) ;\n q8s32 = vpadalq_s16 ( q8s32 , vreinterpretq_s16_u16 ( q14u16 ) ) ;\n q9s32 = vmlal_s16 ( q9s32 , d28s16 , d28s16 ) ;\n q10s32 = vmlal_s16 ( q10s32 , d29s16 , d29s16 ) ;\n }\n q10s32 = vaddq_s32 ( q10s32 , q9s32 ) ;\n q0s64 = vpaddlq_s32 ( q8s32 ) ;\n q1s64 = vpaddlq_s32 ( q10s32 ) ;\n d0s64 = vget_low_s64 ( q0s64 ) ;\n d1s64 = vget_high_s64 ( q0s64 ) ;\n d2s64 = vget_low_s64 ( q1s64 ) ;\n d3s64 = vget_high_s64 ( q1s64 ) ;\n d0s64 = vadd_s64 ( d0s64 , d1s64 ) ;\n d1s64 = vadd_s64 ( d2s64 , d3s64 ) ;\n q5s64 = vmull_s32 ( vreinterpret_s32_s64 ( d0s64 ) , vreinterpret_s32_s64 ( d0s64 ) ) ;\n vst1_lane_u32 ( ( uint32_t * ) sse , vreinterpret_u32_s64 ( d1s64 ) , 0 ) ;\n d10u32 = vshr_n_u32 ( vreinterpret_u32_s64 ( vget_low_s64 ( q5s64 ) ) , 8 ) ;\n d0u32 = vsub_u32 ( vreinterpret_u32_s64 ( d1s64 ) , d10u32 ) ;\n return vget_lane_u32 ( d0u32 , 0 ) ;\n }", "hash": -8225252931914868675, "project": "chrome", "size": 404, "target": 0, "idx": 17130}
{"code": "static int decode_coefs ( VP9_COMMON * cm , const MACROBLOCKD * xd , PLANE_TYPE type , tran_low_t * dqcoeff , TX_SIZE tx_size , const int16_t * dq , int ctx , const int16_t * scan , const int16_t * nb , vp9_reader * r ) {\n const int max_eob = 16 << ( tx_size << 1 ) ;\n const FRAME_CONTEXT * const fc = & cm -> fc ;\n FRAME_COUNTS * const counts = & cm -> counts ;\n const int ref = is_inter_block ( & xd -> mi [ 0 ] . src_mi -> mbmi ) ;\n int band , c = 0 ;\n const vp9_prob ( * coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = fc -> coef_probs [ tx_size ] [ type ] [ ref ] ;\n const vp9_prob * prob ;\n unsigned int ( * coef_counts ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES + 1 ] = counts -> coef [ tx_size ] [ type ] [ ref ] ;\n unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS ] = counts -> eob_branch [ tx_size ] [ type ] [ ref ] ;\n uint8_t token_cache [ 32 * 32 ] ;\n const uint8_t * band_translate = get_band_translate ( tx_size ) ;\n const int dq_shift = ( tx_size == TX_32X32 ) ;\n int v , token ;\n int16_t dqv = dq [ 0 ] ;\n const uint8_t * cat1_prob ;\n const uint8_t * cat2_prob ;\n const uint8_t * cat3_prob ;\n const uint8_t * cat4_prob ;\n const uint8_t * cat5_prob ;\n const uint8_t * cat6_prob ;\n # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) {\n if ( cm -> bit_depth == VPX_BITS_10 ) {\n cat1_prob = vp9_cat1_prob_high10 ;\n cat2_prob = vp9_cat2_prob_high10 ;\n cat3_prob = vp9_cat3_prob_high10 ;\n cat4_prob = vp9_cat4_prob_high10 ;\n cat5_prob = vp9_cat5_prob_high10 ;\n cat6_prob = vp9_cat6_prob_high10 ;\n }\n else {\n cat1_prob = vp9_cat1_prob_high12 ;\n cat2_prob = vp9_cat2_prob_high12 ;\n cat3_prob = vp9_cat3_prob_high12 ;\n cat4_prob = vp9_cat4_prob_high12 ;\n cat5_prob = vp9_cat5_prob_high12 ;\n cat6_prob = vp9_cat6_prob_high12 ;\n }\n }\n else {\n cat1_prob = vp9_cat1_prob ;\n cat2_prob = vp9_cat2_prob ;\n cat3_prob = vp9_cat3_prob ;\n cat4_prob = vp9_cat4_prob ;\n cat5_prob = vp9_cat5_prob ;\n cat6_prob = vp9_cat6_prob ;\n }\n # else cat1_prob = vp9_cat1_prob ;\n cat2_prob = vp9_cat2_prob ;\n cat3_prob = vp9_cat3_prob ;\n cat4_prob = vp9_cat4_prob ;\n cat5_prob = vp9_cat5_prob ;\n cat6_prob = vp9_cat6_prob ;\n # endif while ( c < max_eob ) {\n int val = - 1 ;\n band = * band_translate ++ ;\n prob = coef_probs [ band ] [ ctx ] ;\n if ( ! cm -> frame_parallel_decoding_mode ) ++ eob_branch_count [ band ] [ ctx ] ;\n if ( ! vp9_read ( r , prob [ EOB_CONTEXT_NODE ] ) ) {\n INCREMENT_COUNT ( EOB_MODEL_TOKEN ) ;\n break ;\n }\n while ( ! vp9_read ( r , prob [ ZERO_CONTEXT_NODE ] ) ) {\n INCREMENT_COUNT ( ZERO_TOKEN ) ;\n dqv = dq [ 1 ] ;\n token_cache [ scan [ c ] ] = 0 ;\n ++ c ;\n if ( c >= max_eob ) return c ;\n ctx = get_coef_context ( nb , token_cache , c ) ;\n band = * band_translate ++ ;\n prob = coef_probs [ band ] [ ctx ] ;\n }\n if ( ! vp9_read ( r , prob [ ONE_CONTEXT_NODE ] ) ) {\n INCREMENT_COUNT ( ONE_TOKEN ) ;\n token = ONE_TOKEN ;\n val = 1 ;\n }\n else {\n INCREMENT_COUNT ( TWO_TOKEN ) ;\n token = vp9_read_tree ( r , coeff_subtree_high , vp9_pareto8_full [ prob [ PIVOT_NODE ] - 1 ] ) ;\n switch ( token ) {\n case TWO_TOKEN : case THREE_TOKEN : case FOUR_TOKEN : val = token ;\n break ;\n case CATEGORY1_TOKEN : val = CAT1_MIN_VAL + read_coeff ( cat1_prob , 1 , r ) ;\n break ;\n case CATEGORY2_TOKEN : val = CAT2_MIN_VAL + read_coeff ( cat2_prob , 2 , r ) ;\n break ;\n case CATEGORY3_TOKEN : val = CAT3_MIN_VAL + read_coeff ( cat3_prob , 3 , r ) ;\n break ;\n case CATEGORY4_TOKEN : val = CAT4_MIN_VAL + read_coeff ( cat4_prob , 4 , r ) ;\n break ;\n case CATEGORY5_TOKEN : val = CAT5_MIN_VAL + read_coeff ( cat5_prob , 5 , r ) ;\n break ;\n case CATEGORY6_TOKEN : # if CONFIG_VP9_HIGHBITDEPTH switch ( cm -> bit_depth ) {\n case VPX_BITS_8 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ;\n break ;\n case VPX_BITS_10 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 16 , r ) ;\n break ;\n case VPX_BITS_12 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 18 , r ) ;\n break ;\n default : assert ( 0 ) ;\n return - 1 ;\n }\n # else val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ;\n # endif break ;\n }\n }\n v = ( val * dqv ) >> dq_shift ;\n dqcoeff [ scan [ c ] ] = vp9_read_bit ( r ) ? - v : v ;\n token_cache [ scan [ c ] ] = vp9_pt_energy_class [ token ] ;\n ++ c ;\n ctx = get_coef_context ( nb , token_cache , c ) ;\n dqv = dq [ 1 ] ;\n }\n return c ;\n }", "hash": 4561548163749120103, "project": "chrome", "size": 116, "target": 0, "idx": 17132}
{"code": "void vp9_coef_tree_initialize ( ) {\n init_bit_trees ( ) ;\n vp9_tokens_from_tree ( vp9_coef_encodings , vp9_coef_tree ) ;\n }", "hash": -8925552398357902286, "project": "chrome", "size": 4, "target": 0, "idx": 17136}
{"code": "static void is_skippable ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * argv ) {\n struct is_skippable_args * args = argv ;\n ( void ) plane_bsize ;\n ( void ) tx_size ;\n args -> skippable [ 0 ] &= ( ! args -> x -> plane [ plane ] . eobs [ block ] ) ;\n }", "hash": -8925552398357902286, "project": "chrome", "size": 6, "target": 0, "idx": 17141}
{"code": "void vp9_temporal_filter ( VP9_COMP * cpi , int distance ) {\n VP9_COMMON * const cm = & cpi -> common ;\n RATE_CONTROL * const rc = & cpi -> rc ;\n int frame ;\n int frames_to_blur ;\n int start_frame ;\n int strength ;\n int frames_to_blur_backward ;\n int frames_to_blur_forward ;\n struct scale_factors sf ;\n YV12_BUFFER_CONFIG * frames [ MAX_LAG_BUFFERS ] = {\n NULL }\n ;\n adjust_arnr_filter ( cpi , distance , rc -> gfu_boost , & frames_to_blur , & strength ) ;\n frames_to_blur_backward = ( frames_to_blur / 2 ) ;\n frames_to_blur_forward = ( ( frames_to_blur - 1 ) / 2 ) ;\n start_frame = distance + frames_to_blur_forward ;\n for ( frame = 0 ;\n frame < frames_to_blur ;\n ++ frame ) {\n const int which_buffer = start_frame - frame ;\n struct lookahead_entry * buf = vp9_lookahead_peek ( cpi -> lookahead , which_buffer ) ;\n frames [ frames_to_blur - 1 - frame ] = & buf -> img ;\n }\n if ( is_two_pass_svc ( cpi ) ) {\n int frame_used = 0 ;\n # if CONFIG_VP9_HIGHBITDEPTH vp9_setup_scale_factors_for_frame ( & sf , get_frame_new_buffer ( cm ) -> y_crop_width , get_frame_new_buffer ( cm ) -> y_crop_height , get_frame_new_buffer ( cm ) -> y_crop_width , get_frame_new_buffer ( cm ) -> y_crop_height , cm -> use_highbitdepth ) ;\n # else vp9_setup_scale_factors_for_frame ( & sf , get_frame_new_buffer ( cm ) -> y_crop_width , get_frame_new_buffer ( cm ) -> y_crop_height , get_frame_new_buffer ( cm ) -> y_crop_width , get_frame_new_buffer ( cm ) -> y_crop_height ) ;\n # endif for ( frame = 0 ;\n frame < frames_to_blur ;\n ++ frame ) {\n if ( cm -> mi_cols * MI_SIZE != frames [ frame ] -> y_width || cm -> mi_rows * MI_SIZE != frames [ frame ] -> y_height ) {\n if ( vp9_realloc_frame_buffer ( & cpi -> svc . scaled_frames [ frame_used ] , cm -> width , cm -> height , cm -> subsampling_x , cm -> subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , NULL , NULL , NULL ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , \"Failed to reallocate alt_ref_buffer\" ) ;\n frames [ frame ] = vp9_scale_if_required ( cm , frames [ frame ] , & cpi -> svc . scaled_frames [ frame_used ] ) ;\n ++ frame_used ;\n }\n }\n }\n else {\n # if CONFIG_VP9_HIGHBITDEPTH vp9_setup_scale_factors_for_frame ( & sf , frames [ 0 ] -> y_crop_width , frames [ 0 ] -> y_crop_height , frames [ 0 ] -> y_crop_width , frames [ 0 ] -> y_crop_height , cm -> use_highbitdepth ) ;\n # else vp9_setup_scale_factors_for_frame ( & sf , frames [ 0 ] -> y_crop_width , frames [ 0 ] -> y_crop_height , frames [ 0 ] -> y_crop_width , frames [ 0 ] -> y_crop_height ) ;\n # endif }\n temporal_filter_iterate_c ( cpi , frames , frames_to_blur , frames_to_blur_backward , strength , & sf ) ;\n }", "hash": 5829728328403223446, "project": "chrome", "size": 44, "target": 0, "idx": 17147}
{"code": "static void convolve_horiz ( const uint8_t * src , ptrdiff_t src_stride , uint8_t * dst , ptrdiff_t dst_stride , const InterpKernel * x_filters , int x0_q4 , int x_step_q4 , int w , int h ) {\n int x , y ;\n src -= SUBPEL_TAPS / 2 - 1 ;\n for ( y = 0 ;\n y < h ;\n ++ y ) {\n int x_q4 = x0_q4 ;\n for ( x = 0 ;\n x < w ;\n ++ x ) {\n const uint8_t * const src_x = & src [ x_q4 >> SUBPEL_BITS ] ;\n const int16_t * const x_filter = x_filters [ x_q4 & SUBPEL_MASK ] ;\n int k , sum = 0 ;\n for ( k = 0 ;\n k < SUBPEL_TAPS ;\n ++ k ) sum += src_x [ k ] * x_filter [ k ] ;\n dst [ x ] = clip_pixel ( ROUND_POWER_OF_TWO ( sum , FILTER_BITS ) ) ;\n x_q4 += x_step_q4 ;\n }\n src += src_stride ;\n dst += dst_stride ;\n }\n }", "hash": 2315393806700093389, "project": "chrome", "size": 23, "target": 0, "idx": 17159}
{"code": "void vp9_adapt_coef_probs ( VP9_COMMON * cm ) {\n TX_SIZE t ;\n unsigned int count_sat , update_factor ;\n if ( frame_is_intra_only ( cm ) ) {\n update_factor = COEF_MAX_UPDATE_FACTOR_KEY ;\n count_sat = COEF_COUNT_SAT_KEY ;\n }\n else if ( cm -> last_frame_type == KEY_FRAME ) {\n update_factor = COEF_MAX_UPDATE_FACTOR_AFTER_KEY ;\n count_sat = COEF_COUNT_SAT_AFTER_KEY ;\n }\n else {\n update_factor = COEF_MAX_UPDATE_FACTOR ;\n count_sat = COEF_COUNT_SAT ;\n }\n for ( t = TX_4X4 ;\n t <= TX_32X32 ;\n t ++ ) adapt_coef_probs ( cm , t , count_sat , update_factor ) ;\n }", "hash": 6570435103925347380, "project": "chrome", "size": 19, "target": 0, "idx": 17166}
{"code": "void vp9_model_to_full_probs ( const vp9_prob * model , vp9_prob * full ) {\n if ( full != model ) vpx_memcpy ( full , model , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ;\n extend_to_full_distribution ( & full [ UNCONSTRAINED_NODES ] , model [ PIVOT_NODE ] ) ;\n }", "hash": 6570435103925347380, "project": "chrome", "size": 4, "target": 0, "idx": 17167}
{"code": "void vp9_default_coef_probs ( VP9_COMMON * cm ) {\n vp9_copy ( cm -> fc . coef_probs [ TX_4X4 ] , default_coef_probs_4x4 ) ;\n vp9_copy ( cm -> fc . coef_probs [ TX_8X8 ] , default_coef_probs_8x8 ) ;\n vp9_copy ( cm -> fc . coef_probs [ TX_16X16 ] , default_coef_probs_16x16 ) ;\n vp9_copy ( cm -> fc . coef_probs [ TX_32X32 ] , default_coef_probs_32x32 ) ;\n }", "hash": 6570435103925347380, "project": "chrome", "size": 6, "target": 0, "idx": 17168}
{"code": "void vp8_denoiser_set_parameters ( VP8_DENOISER * denoiser , int mode ) {\n assert ( mode > 0 ) ;\n if ( mode == 1 ) {\n denoiser -> denoiser_mode = kDenoiserOnYOnly ;\n }\n else if ( mode == 2 ) {\n denoiser -> denoiser_mode = kDenoiserOnYUV ;\n }\n else if ( mode == 3 ) {\n denoiser -> denoiser_mode = kDenoiserOnYUVAggressive ;\n }\n else {\n denoiser -> denoiser_mode = kDenoiserOnAdaptive ;\n }\n if ( denoiser -> denoiser_mode != kDenoiserOnYUVAggressive ) {\n denoiser -> denoise_pars . scale_sse_thresh = 1 ;\n denoiser -> denoise_pars . scale_motion_thresh = 8 ;\n denoiser -> denoise_pars . scale_increase_filter = 0 ;\n denoiser -> denoise_pars . denoise_mv_bias = 95 ;\n denoiser -> denoise_pars . pickmode_mv_bias = 100 ;\n denoiser -> denoise_pars . qp_thresh = 0 ;\n denoiser -> denoise_pars . consec_zerolast = UINT_MAX ;\n denoiser -> denoise_pars . spatial_blur = 0 ;\n }\n else {\n denoiser -> denoise_pars . scale_sse_thresh = 2 ;\n denoiser -> denoise_pars . scale_motion_thresh = 16 ;\n denoiser -> denoise_pars . scale_increase_filter = 1 ;\n denoiser -> denoise_pars . denoise_mv_bias = 60 ;\n denoiser -> denoise_pars . pickmode_mv_bias = 60 ;\n denoiser -> denoise_pars . qp_thresh = 100 ;\n denoiser -> denoise_pars . consec_zerolast = 10 ;\n denoiser -> denoise_pars . spatial_blur = 20 ;\n }\n }", "hash": 8323148621905688627, "project": "chrome", "size": 35, "target": 0, "idx": 17187}
{"code": "void vp8_quantize_mb_c ( MACROBLOCK * x ) {\n int i ;\n int has_2nd_order = ( x -> e_mbd . mode_info_context -> mbmi . mode != B_PRED && x -> e_mbd . mode_info_context -> mbmi . mode != SPLITMV ) ;\n for ( i = 0 ;\n i < 24 + has_2nd_order ;\n i ++ ) x -> quantize_b ( & x -> block [ i ] , & x -> e_mbd . block [ i ] ) ;\n }", "hash": -5952453487978309155, "project": "chrome", "size": 7, "target": 0, "idx": 17193}
{"code": "static void invert_quant ( int improved_quant , short * quant , short * shift , short d ) {\n if ( improved_quant ) {\n unsigned t ;\n int l ;\n t = d ;\n for ( l = 0 ;\n t > 1 ;\n l ++ ) t >>= 1 ;\n t = 1 + ( 1 << ( 16 + l ) ) / d ;\n * quant = ( short ) ( t - ( 1 << 16 ) ) ;\n * shift = l ;\n * shift = 1 << ( 16 - * shift ) ;\n }\n else {\n * quant = ( 1 << 16 ) / d ;\n * shift = 0 ;\n * shift = 1 << ( 16 - * shift ) ;\n }\n }", "hash": -5952453487978309155, "project": "chrome", "size": 19, "target": 0, "idx": 17200}
{"code": "static int compute_rd_thresh_factor ( int qindex , vpx_bit_depth_t bit_depth ) {\n double q ;\n # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) {\n case VPX_BITS_8 : q = vp9_dc_quant ( qindex , 0 , VPX_BITS_8 ) / 4.0 ;\n break ;\n case VPX_BITS_10 : q = vp9_dc_quant ( qindex , 0 , VPX_BITS_10 ) / 16.0 ;\n break ;\n case VPX_BITS_12 : q = vp9_dc_quant ( qindex , 0 , VPX_BITS_12 ) / 64.0 ;\n break ;\n default : assert ( 0 && \"bit_depth should be VPX_BITS_8, VPX_BITS_10 or VPX_BITS_12\" ) ;\n return - 1 ;\n }\n # else ( void ) bit_depth ;\n q = vp9_dc_quant ( qindex , 0 , VPX_BITS_8 ) / 4.0 ;\n # endif return MAX ( ( int ) ( pow ( q , RD_THRESH_POW ) * 5.12 ) , 8 ) ;\n }", "hash": 1911881859629730975, "project": "chrome", "size": 16, "target": 0, "idx": 17204}
{"code": "static void init_me_luts_bd ( int * bit16lut , int * bit4lut , int range , vpx_bit_depth_t bit_depth ) {\n int i ;\n for ( i = 0 ;\n i < range ;\n i ++ ) {\n const double q = vp9_convert_qindex_to_q ( i , bit_depth ) ;\n bit16lut [ i ] = ( int ) ( 0.0418 * q + 2.4107 ) ;\n bit4lut [ i ] = ( int ) ( 0.063 * q + 2.742 ) ;\n }\n }", "hash": 1911881859629730975, "project": "chrome", "size": 10, "target": 0, "idx": 17205}
{"code": "void vp9_initialize_rd_consts ( VP9_COMP * cpi ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * const x = & cpi -> mb ;\n RD_OPT * const rd = & cpi -> rd ;\n int i ;\n vp9_clear_system_state ( ) ;\n rd -> RDDIV = RDDIV_BITS ;\n rd -> RDMULT = vp9_compute_rd_mult ( cpi , cm -> base_qindex + cm -> y_dc_delta_q ) ;\n x -> errorperbit = rd -> RDMULT / RD_MULT_EPB_RATIO ;\n x -> errorperbit += ( x -> errorperbit == 0 ) ;\n x -> select_tx_size = ( cpi -> sf . tx_size_search_method == USE_LARGESTALL && cm -> frame_type != KEY_FRAME ) ? 0 : 1 ;\n set_block_thresholds ( cm , rd ) ;\n if ( ! cpi -> sf . use_nonrd_pick_mode || cm -> frame_type == KEY_FRAME ) {\n fill_token_costs ( x -> token_costs , cm -> fc . coef_probs ) ;\n for ( i = 0 ;\n i < PARTITION_CONTEXTS ;\n ++ i ) vp9_cost_tokens ( cpi -> partition_cost [ i ] , get_partition_probs ( cm , i ) , vp9_partition_tree ) ;\n }\n if ( ! cpi -> sf . use_nonrd_pick_mode || ( cm -> current_video_frame & 0x07 ) == 1 || cm -> frame_type == KEY_FRAME ) {\n fill_mode_costs ( cpi ) ;\n if ( ! frame_is_intra_only ( cm ) ) {\n vp9_build_nmv_cost_table ( x -> nmvjointcost , cm -> allow_high_precision_mv ? x -> nmvcost_hp : x -> nmvcost , & cm -> fc . nmvc , cm -> allow_high_precision_mv ) ;\n for ( i = 0 ;\n i < INTER_MODE_CONTEXTS ;\n ++ i ) vp9_cost_tokens ( ( int * ) cpi -> inter_mode_cost [ i ] , cm -> fc . inter_mode_probs [ i ] , vp9_inter_mode_tree ) ;\n }\n }\n }", "hash": 1911881859629730975, "project": "chrome", "size": 28, "target": 0, "idx": 17207}
{"code": "void vp9_select_in_frame_q_segment ( VP9_COMP * cpi , int mi_row , int mi_col , int output_enabled , int projected_rate ) {\n VP9_COMMON * const cm = & cpi -> common ;\n const int mi_offset = mi_row * cm -> mi_cols + mi_col ;\n const int bw = num_8x8_blocks_wide_lookup [ BLOCK_64X64 ] ;\n const int bh = num_8x8_blocks_high_lookup [ BLOCK_64X64 ] ;\n const int xmis = MIN ( cm -> mi_cols - mi_col , bw ) ;\n const int ymis = MIN ( cm -> mi_rows - mi_row , bh ) ;\n int complexity_metric = 64 ;\n int x , y ;\n unsigned char segment ;\n if ( ! output_enabled ) {\n segment = 0 ;\n }\n else {\n const int target_rate = ( cpi -> rc . sb64_target_rate * xmis * ymis * 256 ) / ( bw * bh ) ;\n const int aq_strength = get_aq_c_strength ( cm -> base_qindex , cm -> bit_depth ) ;\n const int active_segments = aq_c_active_segments [ aq_strength ] ;\n segment = active_segments - 1 ;\n while ( segment > 0 ) {\n if ( projected_rate < ( target_rate * aq_c_transitions [ aq_strength ] [ segment ] ) ) {\n break ;\n }\n -- segment ;\n }\n if ( target_rate > 0 ) {\n complexity_metric = clamp ( ( int ) ( ( projected_rate * 64 ) / target_rate ) , 16 , 255 ) ;\n }\n }\n for ( y = 0 ;\n y < ymis ;\n y ++ ) {\n for ( x = 0 ;\n x < xmis ;\n x ++ ) {\n cpi -> segmentation_map [ mi_offset + y * cm -> mi_cols + x ] = segment ;\n cpi -> complexity_map [ mi_offset + y * cm -> mi_cols + x ] = ( unsigned char ) complexity_metric ;\n }\n }\n }", "hash": -7853481279968318488, "project": "chrome", "size": 39, "target": 0, "idx": 17223}
{"code": "void vp9_pick_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x , const TileInfo * const tile , int mi_row , int mi_col , int * returnrate , int64_t * returndistortion , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] . src_mi -> mbmi ;\n struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ;\n PREDICTION_MODE best_mode = ZEROMV ;\n MV_REFERENCE_FRAME ref_frame , best_ref_frame = LAST_FRAME ;\n TX_SIZE best_tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cm -> tx_mode ] ) ;\n INTERP_FILTER best_pred_filter = EIGHTTAP ;\n int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ;\n struct buf_2d yv12_mb [ 4 ] [ MAX_MB_PLANE ] ;\n static const int flag_list [ 4 ] = {\n 0 , VP9_LAST_FLAG , VP9_GOLD_FLAG , VP9_ALT_FLAG }\n ;\n int64_t best_rd = INT64_MAX ;\n int64_t this_rd = INT64_MAX ;\n uint8_t skip_txfm = 0 ;\n int rate = INT_MAX ;\n int64_t dist = INT64_MAX ;\n unsigned int var_y = UINT_MAX ;\n unsigned int sse_y = UINT_MAX ;\n const int intra_cost_penalty = * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q , cm -> bit_depth ) ;\n const int64_t inter_mode_thresh = RDCOST ( x -> rdmult , x -> rddiv , intra_cost_penalty , 0 ) ;\n const int intra_mode_cost = 50 ;\n const int8_t segment_id = mbmi -> segment_id ;\n const int * const rd_threshes = cpi -> rd . threshes [ segment_id ] [ bsize ] ;\n const int * const rd_thresh_freq_fact = cpi -> rd . thresh_freq_fact [ bsize ] ;\n INTERP_FILTER filter_ref = cm -> interp_filter ;\n const int bsl = mi_width_log2 ( bsize ) ;\n const int pred_filter_search = cm -> interp_filter == SWITCHABLE ? ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 : 0 ;\n int const_motion [ MAX_REF_FRAMES ] = {\n 0 }\n ;\n const int bh = num_4x4_blocks_high_lookup [ bsize ] << 2 ;\n const int bw = num_4x4_blocks_wide_lookup [ bsize ] << 2 ;\n PRED_BUFFER tmp [ 4 ] ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , pred_buf , 3 * 64 * 64 ) ;\n struct buf_2d orig_dst = pd -> dst ;\n PRED_BUFFER * best_pred = NULL ;\n PRED_BUFFER * this_mode_pred = NULL ;\n if ( cpi -> sf . reuse_inter_pred_sby ) {\n int i ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n tmp [ i ] . data = & pred_buf [ bw * bh * i ] ;\n tmp [ i ] . stride = bw ;\n tmp [ i ] . in_use = 0 ;\n }\n tmp [ 3 ] . data = pd -> dst . buf ;\n tmp [ 3 ] . stride = pd -> dst . stride ;\n tmp [ 3 ] . in_use = 0 ;\n }\n x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ;\n x -> skip = 0 ;\n * returnrate = INT_MAX ;\n * returndistortion = INT64_MAX ;\n vpx_memset ( mbmi , 0 , sizeof ( MB_MODE_INFO ) ) ;\n mbmi -> sb_type = bsize ;\n mbmi -> ref_frame [ 0 ] = NONE ;\n mbmi -> ref_frame [ 1 ] = NONE ;\n mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cm -> tx_mode ] ) ;\n mbmi -> interp_filter = cm -> interp_filter == SWITCHABLE ? EIGHTTAP : cm -> interp_filter ;\n mbmi -> segment_id = segment_id ;\n for ( ref_frame = LAST_FRAME ;\n ref_frame <= ALTREF_FRAME ;\n ++ ref_frame ) {\n PREDICTION_MODE this_mode ;\n x -> pred_mv_sad [ ref_frame ] = INT_MAX ;\n frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ;\n frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ;\n if ( xd -> up_available ) filter_ref = xd -> mi [ - xd -> mi_stride ] . src_mi -> mbmi . interp_filter ;\n else if ( xd -> left_available ) filter_ref = xd -> mi [ - 1 ] . src_mi -> mbmi . interp_filter ;\n if ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) {\n const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , ref_frame ) ;\n int_mv * const candidates = mbmi -> ref_mvs [ ref_frame ] ;\n const struct scale_factors * const sf = & cm -> frame_refs [ ref_frame - 1 ] . sf ;\n vp9_setup_pred_block ( xd , yv12_mb [ ref_frame ] , yv12 , mi_row , mi_col , sf , sf ) ;\n if ( ! cm -> error_resilient_mode ) vp9_find_mv_refs ( cm , xd , tile , xd -> mi [ 0 ] . src_mi , ref_frame , candidates , mi_row , mi_col ) ;\n else const_motion [ ref_frame ] = mv_refs_rt ( cm , xd , tile , xd -> mi [ 0 ] . src_mi , ref_frame , candidates , mi_row , mi_col ) ;\n vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , candidates , & frame_mv [ NEARESTMV ] [ ref_frame ] , & frame_mv [ NEARMV ] [ ref_frame ] ) ;\n if ( ! vp9_is_scaled ( sf ) && bsize >= BLOCK_8X8 ) vp9_mv_pred ( cpi , x , yv12_mb [ ref_frame ] [ 0 ] . buf , yv12 -> y_stride , ref_frame , bsize ) ;\n }\n else {\n continue ;\n }\n xd -> plane [ 0 ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ 0 ] ;\n clamp_mv2 ( & frame_mv [ NEARESTMV ] [ ref_frame ] . as_mv , xd ) ;\n clamp_mv2 ( & frame_mv [ NEARMV ] [ ref_frame ] . as_mv , xd ) ;\n mbmi -> ref_frame [ 0 ] = ref_frame ;\n for ( this_mode = NEARESTMV ;\n this_mode <= NEWMV ;\n ++ this_mode ) {\n int rate_mv = 0 ;\n int mode_rd_thresh ;\n if ( const_motion [ ref_frame ] && ( this_mode == NEARMV || this_mode == ZEROMV ) ) continue ;\n if ( ! ( cpi -> sf . inter_mode_mask [ bsize ] & ( 1 << this_mode ) ) ) continue ;\n mode_rd_thresh = rd_threshes [ mode_idx [ ref_frame - LAST_FRAME ] [ INTER_OFFSET ( this_mode ) ] ] ;\n if ( rd_less_than_thresh ( best_rd , mode_rd_thresh , rd_thresh_freq_fact [ this_mode ] ) ) continue ;\n if ( this_mode == NEWMV ) {\n if ( this_rd < ( int64_t ) ( 1 << num_pels_log2_lookup [ bsize ] ) ) continue ;\n if ( ! combined_motion_search ( cpi , x , bsize , mi_row , mi_col , & frame_mv [ NEWMV ] [ ref_frame ] , & rate_mv , best_rd ) ) continue ;\n }\n if ( this_mode != NEARESTMV && frame_mv [ this_mode ] [ ref_frame ] . as_int == frame_mv [ NEARESTMV ] [ ref_frame ] . as_int ) continue ;\n mbmi -> mode = this_mode ;\n mbmi -> mv [ 0 ] . as_int = frame_mv [ this_mode ] [ ref_frame ] . as_int ;\n if ( cpi -> sf . reuse_inter_pred_sby ) {\n if ( this_mode == NEARESTMV ) {\n this_mode_pred = & tmp [ 3 ] ;\n }\n else {\n this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ;\n pd -> dst . buf = this_mode_pred -> data ;\n pd -> dst . stride = bw ;\n }\n }\n if ( ( this_mode == NEWMV || filter_ref == SWITCHABLE ) && pred_filter_search && ( ( mbmi -> mv [ 0 ] . as_mv . row & 0x07 ) != 0 || ( mbmi -> mv [ 0 ] . as_mv . col & 0x07 ) != 0 ) ) {\n int pf_rate [ 3 ] ;\n int64_t pf_dist [ 3 ] ;\n unsigned int pf_var [ 3 ] ;\n unsigned int pf_sse [ 3 ] ;\n TX_SIZE pf_tx_size [ 3 ] ;\n int64_t best_cost = INT64_MAX ;\n INTERP_FILTER best_filter = SWITCHABLE , filter ;\n PRED_BUFFER * current_pred = this_mode_pred ;\n for ( filter = EIGHTTAP ;\n filter <= EIGHTTAP_SHARP ;\n ++ filter ) {\n int64_t cost ;\n mbmi -> interp_filter = filter ;\n vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , bsize ) ;\n model_rd_for_sb_y ( cpi , bsize , x , xd , & pf_rate [ filter ] , & pf_dist [ filter ] , & pf_var [ filter ] , & pf_sse [ filter ] ) ;\n cost = RDCOST ( x -> rdmult , x -> rddiv , vp9_get_switchable_rate ( cpi ) + pf_rate [ filter ] , pf_dist [ filter ] ) ;\n pf_tx_size [ filter ] = mbmi -> tx_size ;\n if ( cost < best_cost ) {\n best_filter = filter ;\n best_cost = cost ;\n skip_txfm = x -> skip_txfm [ 0 ] ;\n if ( cpi -> sf . reuse_inter_pred_sby ) {\n if ( this_mode_pred != current_pred ) {\n free_pred_buffer ( this_mode_pred ) ;\n this_mode_pred = current_pred ;\n }\n if ( filter < EIGHTTAP_SHARP ) {\n current_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ;\n pd -> dst . buf = current_pred -> data ;\n pd -> dst . stride = bw ;\n }\n }\n }\n }\n if ( cpi -> sf . reuse_inter_pred_sby && this_mode_pred != current_pred ) free_pred_buffer ( current_pred ) ;\n mbmi -> interp_filter = best_filter ;\n mbmi -> tx_size = pf_tx_size [ mbmi -> interp_filter ] ;\n rate = pf_rate [ mbmi -> interp_filter ] ;\n dist = pf_dist [ mbmi -> interp_filter ] ;\n var_y = pf_var [ mbmi -> interp_filter ] ;\n sse_y = pf_sse [ mbmi -> interp_filter ] ;\n x -> skip_txfm [ 0 ] = skip_txfm ;\n }\n else {\n mbmi -> interp_filter = ( filter_ref == SWITCHABLE ) ? EIGHTTAP : filter_ref ;\n vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , bsize ) ;\n model_rd_for_sb_y ( cpi , bsize , x , xd , & rate , & dist , & var_y , & sse_y ) ;\n }\n rate += rate_mv ;\n rate += cpi -> inter_mode_cost [ mbmi -> mode_context [ ref_frame ] ] [ INTER_OFFSET ( this_mode ) ] ;\n this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , dist ) ;\n if ( cpi -> allow_encode_breakout ) {\n encode_breakout_test ( cpi , x , bsize , mi_row , mi_col , ref_frame , this_mode , var_y , sse_y , yv12_mb , & rate , & dist ) ;\n if ( x -> skip ) {\n rate += rate_mv ;\n this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , dist ) ;\n }\n }\n # if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) {\n vp9_denoiser_update_frame_stats ( mbmi , sse_y , this_mode , ctx ) ;\n }\n # else ( void ) ctx ;\n # endif if ( this_rd < best_rd || x -> skip ) {\n best_rd = this_rd ;\n * returnrate = rate ;\n * returndistortion = dist ;\n best_mode = this_mode ;\n best_pred_filter = mbmi -> interp_filter ;\n best_tx_size = mbmi -> tx_size ;\n best_ref_frame = ref_frame ;\n skip_txfm = x -> skip_txfm [ 0 ] ;\n if ( cpi -> sf . reuse_inter_pred_sby ) {\n free_pred_buffer ( best_pred ) ;\n best_pred = this_mode_pred ;\n }\n }\n else {\n if ( cpi -> sf . reuse_inter_pred_sby ) free_pred_buffer ( this_mode_pred ) ;\n }\n if ( x -> skip ) break ;\n }\n if ( best_rd < INT64_MAX ) break ;\n }\n if ( best_pred != NULL && cpi -> sf . reuse_inter_pred_sby && best_pred -> data != orig_dst . buf ) {\n pd -> dst = orig_dst ;\n vp9_convolve_copy ( best_pred -> data , bw , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh ) ;\n }\n mbmi -> mode = best_mode ;\n mbmi -> interp_filter = best_pred_filter ;\n mbmi -> tx_size = best_tx_size ;\n mbmi -> ref_frame [ 0 ] = best_ref_frame ;\n mbmi -> mv [ 0 ] . as_int = frame_mv [ best_mode ] [ best_ref_frame ] . as_int ;\n xd -> mi [ 0 ] . src_mi -> bmi [ 0 ] . as_mv [ 0 ] . as_int = mbmi -> mv [ 0 ] . as_int ;\n x -> skip_txfm [ 0 ] = skip_txfm ;\n if ( ! x -> skip && best_rd > inter_mode_thresh && bsize <= cpi -> sf . max_intra_bsize ) {\n PREDICTION_MODE this_mode ;\n struct estimate_block_intra_args args = {\n cpi , x , DC_PRED , 0 , 0 }\n ;\n const TX_SIZE intra_tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ;\n if ( cpi -> sf . reuse_inter_pred_sby ) {\n pd -> dst . buf = tmp [ 0 ] . data ;\n pd -> dst . stride = bw ;\n }\n for ( this_mode = DC_PRED ;\n this_mode <= DC_PRED ;\n ++ this_mode ) {\n const TX_SIZE saved_tx_size = mbmi -> tx_size ;\n args . mode = this_mode ;\n args . rate = 0 ;\n args . dist = 0 ;\n mbmi -> tx_size = intra_tx_size ;\n vp9_foreach_transformed_block_in_plane ( xd , bsize , 0 , estimate_block_intra , & args ) ;\n mbmi -> tx_size = saved_tx_size ;\n rate = args . rate ;\n dist = args . dist ;\n rate += cpi -> mbmode_cost [ this_mode ] ;\n rate += intra_cost_penalty ;\n this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , dist ) ;\n if ( this_rd + intra_mode_cost < best_rd ) {\n best_rd = this_rd ;\n * returnrate = rate ;\n * returndistortion = dist ;\n mbmi -> mode = this_mode ;\n mbmi -> tx_size = intra_tx_size ;\n mbmi -> ref_frame [ 0 ] = INTRA_FRAME ;\n mbmi -> uv_mode = this_mode ;\n mbmi -> mv [ 0 ] . as_int = INVALID_MV ;\n }\n else {\n x -> skip_txfm [ 0 ] = skip_txfm ;\n }\n }\n if ( cpi -> sf . reuse_inter_pred_sby ) pd -> dst = orig_dst ;\n }\n }", "hash": -4341894042551388054, "project": "chrome", "size": 253, "target": 0, "idx": 17239}
{"code": "unsigned int vp9_sub_pixel_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp2 , W , dst , dst_stride , sse ) ;\n \\ }\n # define SUBPIX_AVG_VAR ( W , H ) unsigned int vp9_sub_pixel_avg_variance ## W ## x ## H ## _c ( const uint8_t * src , int src_stride , int xoffset , int yoffset , const uint8_t * dst , int dst_stride , unsigned int * sse , const uint8_t * second_pred ) {\n uint16_t fdata3 [ ( H + 1 ) * W ] ;\n uint8_t temp2 [ H * W ] ;\n DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , temp3 , H * W ) ;\n var_filter_block2d_bil_first_pass ( src , fdata3 , src_stride , 1 , H + 1 , W , BILINEAR_FILTERS_2TAP ( xoffset ) ) ;\n var_filter_block2d_bil_second_pass ( fdata3 , temp2 , W , W , H , W , BILINEAR_FILTERS_2TAP ( yoffset ) ) ;\n vp9_comp_avg_pred ( temp3 , second_pred , W , H , temp2 , W ) ;\n return vp9_variance ## W ## x ## H ## _c ( temp3 , W , dst , dst_stride , sse ) ;\n \\ }\n void vp9_get16x16var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 16 , 16 , sse , sum ) ;\n }\n void vp9_get8x8var_c ( const uint8_t * src_ptr , int source_stride , const uint8_t * ref_ptr , int ref_stride , unsigned int * sse , int * sum ) {\n variance ( src_ptr , source_stride , ref_ptr , ref_stride , 8 , 8 , sse , sum ) ;\n }\n unsigned int vp9_mse16x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse16x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 8 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 16 , sse , & sum ) ;\n return * sse ;\n }\n unsigned int vp9_mse8x8_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 8 , 8 , sse , & sum ) ;\n return * sse ;\n }\n VAR ( 4 , 4 ) SUBPIX_VAR ( 4 , 4 ) SUBPIX_AVG_VAR ( 4 , 4 ) VAR ( 4 , 8 ) SUBPIX_VAR ( 4 , 8 ) SUBPIX_AVG_VAR ( 4 , 8 ) VAR ( 8 , 4 ) SUBPIX_VAR ( 8 , 4 ) SUBPIX_AVG_VAR ( 8 , 4 ) VAR ( 8 , 8 ) SUBPIX_VAR ( 8 , 8 ) SUBPIX_AVG_VAR ( 8 , 8 ) VAR ( 8 , 16 ) SUBPIX_VAR ( 8 , 16 ) SUBPIX_AVG_VAR ( 8 , 16 ) VAR ( 16 , 8 ) SUBPIX_VAR ( 16 , 8 ) SUBPIX_AVG_VAR ( 16 , 8 ) VAR ( 16 , 16 ) SUBPIX_VAR ( 16 , 16 )", "hash": -2943582541244387919, "project": "chrome", "size": 43, "target": 0, "idx": 17276}
{"code": "unsigned int vp9_mse16x16_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sse ) {\n int sum ;\n variance ( src , src_stride , ref , ref_stride , 16 , 16 , sse , & sum ) ;\n return * sse ;\n }", "hash": -2943582541244387919, "project": "chrome", "size": 5, "target": 0, "idx": 17307}
{"code": "void usage_exit ( ) {\n fprintf ( stderr , \"Usage: %s <options> input_filename output_filename\\n\" , exec_name ) ;\n fprintf ( stderr , \"Options:\\n\" ) ;\n arg_show_usage ( stderr , svc_args ) ;\n exit ( EXIT_FAILURE ) ;\n }", "hash": 6809509104003465181, "project": "chrome", "size": 6, "target": 0, "idx": 17315}
{"code": "static int sb_has_motion ( const VP9_COMMON * cm , MODE_INFO * prev_mi_8x8 , const int motion_thresh ) {\n const int mis = cm -> mi_stride ;\n int block_row , block_col ;\n if ( cm -> prev_mi ) {\n for ( block_row = 0 ;\n block_row < 8 ;\n ++ block_row ) {\n for ( block_col = 0 ;\n block_col < 8 ;\n ++ block_col ) {\n const MODE_INFO * prev_mi = prev_mi_8x8 [ block_row * mis + block_col ] . src_mi ;\n if ( prev_mi ) {\n if ( abs ( prev_mi -> mbmi . mv [ 0 ] . as_mv . row ) > motion_thresh || abs ( prev_mi -> mbmi . mv [ 0 ] . as_mv . col ) > motion_thresh ) return 1 ;\n }\n }\n }\n }\n return 0 ;\n }", "hash": -5706788925640467782, "project": "chrome", "size": 19, "target": 0, "idx": 17335}
{"code": "static void encode_sb ( VP9_COMP * cpi , const TileInfo * const tile , TOKENEXTRA * * tp , int mi_row , int mi_col , int output_enabled , BLOCK_SIZE bsize , PC_TREE * pc_tree ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ;\n int ctx ;\n PARTITION_TYPE partition ;\n BLOCK_SIZE subsize = bsize ;\n if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;\n if ( bsize >= BLOCK_8X8 ) {\n ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;\n subsize = get_subsize ( bsize , pc_tree -> partitioning ) ;\n }\n else {\n ctx = 0 ;\n subsize = BLOCK_4X4 ;\n }\n partition = partition_lookup [ bsl ] [ subsize ] ;\n if ( output_enabled && bsize != BLOCK_4X4 ) cm -> counts . partition [ ctx ] [ partition ] ++ ;\n switch ( partition ) {\n case PARTITION_NONE : encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) ;\n break ;\n case PARTITION_VERT : encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] ) ;\n if ( mi_col + hbs < cm -> mi_cols && bsize > BLOCK_8X8 ) {\n encode_b ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] ) ;\n }\n break ;\n case PARTITION_HORZ : encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] ) ;\n if ( mi_row + hbs < cm -> mi_rows && bsize > BLOCK_8X8 ) {\n encode_b ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] ) ;\n }\n break ;\n case PARTITION_SPLIT : if ( bsize == BLOCK_8X8 ) {\n encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ;\n }\n else {\n encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) ;\n encode_sb ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) ;\n encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) ;\n encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] ) ;\n }\n break ;\n default : assert ( \"Invalid partition type.\" ) ;\n break ;\n }\n if ( partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ;\n }", "hash": -5706788925640467782, "project": "chrome", "size": 47, "target": 0, "idx": 17344}
{"code": "static void encode_b_rt ( VP9_COMP * cpi , const TileInfo * const tile , TOKENEXTRA * * tp , int mi_row , int mi_col , int output_enabled , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {\n set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;\n update_state_rt ( cpi , ctx , mi_row , mi_col , bsize ) ;\n # if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 && output_enabled ) {\n vp9_denoiser_denoise ( & cpi -> denoiser , & cpi -> mb , mi_row , mi_col , MAX ( BLOCK_8X8 , bsize ) , ctx ) ;\n }\n # endif encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize , ctx ) ;\n update_stats ( & cpi -> common , & cpi -> mb ) ;\n ( * tp ) -> token = EOSB_TOKEN ;\n ( * tp ) ++ ;\n }", "hash": -5706788925640467782, "project": "chrome", "size": 11, "target": 0, "idx": 17358}
{"code": "static void nonrd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile , int mi_row , int mi_col , int * rate , int64_t * dist , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * mbmi ;\n set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;\n mbmi = & xd -> mi [ 0 ] . src_mi -> mbmi ;\n mbmi -> sb_type = bsize ;\n if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) if ( mbmi -> segment_id && x -> in_static_area ) x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ;\n if ( vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) set_mode_info_seg_skip ( x , cm -> tx_mode , rate , dist , bsize ) ;\n else vp9_pick_inter_mode ( cpi , x , tile , mi_row , mi_col , rate , dist , bsize , ctx ) ;\n duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;\n }", "hash": -5706788925640467782, "project": "chrome", "size": 13, "target": 0, "idx": 17368}
{"code": "static void set_mode_info_seg_skip ( MACROBLOCK * x , TX_MODE tx_mode , int * rate , int64_t * dist , BLOCK_SIZE bsize ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] . src_mi -> mbmi ;\n INTERP_FILTER filter_ref ;\n if ( xd -> up_available ) filter_ref = xd -> mi [ - xd -> mi_stride ] . src_mi -> mbmi . interp_filter ;\n else if ( xd -> left_available ) filter_ref = xd -> mi [ - 1 ] . src_mi -> mbmi . interp_filter ;\n else filter_ref = EIGHTTAP ;\n mbmi -> sb_type = bsize ;\n mbmi -> mode = ZEROMV ;\n mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ tx_mode ] ) ;\n mbmi -> skip = 1 ;\n mbmi -> uv_mode = DC_PRED ;\n mbmi -> ref_frame [ 0 ] = LAST_FRAME ;\n mbmi -> ref_frame [ 1 ] = NONE ;\n mbmi -> mv [ 0 ] . as_int = 0 ;\n mbmi -> interp_filter = filter_ref ;\n xd -> mi [ 0 ] . src_mi -> bmi [ 0 ] . as_mv [ 0 ] . as_int = 0 ;\n x -> skip = 1 ;\n * rate = 0 ;\n * dist = 0 ;\n }", "hash": -5706788925640467782, "project": "chrome", "size": 21, "target": 0, "idx": 17373}
{"code": "static void encode_sb_rt ( VP9_COMP * cpi , const TileInfo * const tile , TOKENEXTRA * * tp , int mi_row , int mi_col , int output_enabled , BLOCK_SIZE bsize , PC_TREE * pc_tree ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ;\n int ctx ;\n PARTITION_TYPE partition ;\n BLOCK_SIZE subsize ;\n if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;\n if ( bsize >= BLOCK_8X8 ) {\n const int idx_str = xd -> mi_stride * mi_row + mi_col ;\n MODE_INFO * mi_8x8 = cm -> mi [ idx_str ] . src_mi ;\n ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;\n subsize = mi_8x8 [ 0 ] . src_mi -> mbmi . sb_type ;\n }\n else {\n ctx = 0 ;\n subsize = BLOCK_4X4 ;\n }\n partition = partition_lookup [ bsl ] [ subsize ] ;\n if ( output_enabled && bsize != BLOCK_4X4 ) cm -> counts . partition [ ctx ] [ partition ] ++ ;\n switch ( partition ) {\n case PARTITION_NONE : encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) ;\n break ;\n case PARTITION_VERT : encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] ) ;\n if ( mi_col + hbs < cm -> mi_cols && bsize > BLOCK_8X8 ) {\n encode_b_rt ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] ) ;\n }\n break ;\n case PARTITION_HORZ : encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] ) ;\n if ( mi_row + hbs < cm -> mi_rows && bsize > BLOCK_8X8 ) {\n encode_b_rt ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] ) ;\n }\n break ;\n case PARTITION_SPLIT : subsize = get_subsize ( bsize , PARTITION_SPLIT ) ;\n encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) ;\n encode_sb_rt ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) ;\n encode_sb_rt ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) ;\n encode_sb_rt ( cpi , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] ) ;\n break ;\n default : assert ( \"Invalid partition type.\" ) ;\n break ;\n }\n if ( partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ;\n }", "hash": -5706788925640467782, "project": "chrome", "size": 45, "target": 0, "idx": 17382}
{"code": "static void choose_partitioning ( VP9_COMP * cpi , const TileInfo * const tile , int mi_row , int mi_col ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * x = & cpi -> mb ;\n MACROBLOCKD * xd = & cpi -> mb . e_mbd ;\n int i , j , k ;\n v64x64 vt ;\n uint8_t * s ;\n const uint8_t * d ;\n int sp ;\n int dp ;\n int pixels_wide = 64 , pixels_high = 64 ;\n int_mv nearest_mv , near_mv ;\n const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ;\n const struct scale_factors * const sf = & cm -> frame_refs [ LAST_FRAME - 1 ] . sf ;\n vp9_zero ( vt ) ;\n set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ;\n if ( xd -> mb_to_right_edge < 0 ) pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ;\n if ( xd -> mb_to_bottom_edge < 0 ) pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ;\n s = x -> plane [ 0 ] . src . buf ;\n sp = x -> plane [ 0 ] . src . stride ;\n if ( cm -> frame_type != KEY_FRAME ) {\n vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , sf ) ;\n xd -> mi [ 0 ] . src_mi -> mbmi . ref_frame [ 0 ] = LAST_FRAME ;\n xd -> mi [ 0 ] . src_mi -> mbmi . sb_type = BLOCK_64X64 ;\n vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , xd -> mi [ 0 ] . src_mi -> mbmi . ref_mvs [ LAST_FRAME ] , & nearest_mv , & near_mv ) ;\n xd -> mi [ 0 ] . src_mi -> mbmi . mv [ 0 ] = nearest_mv ;\n vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , BLOCK_64X64 ) ;\n d = xd -> plane [ 0 ] . dst . buf ;\n dp = xd -> plane [ 0 ] . dst . stride ;\n }\n else {\n d = VP9_VAR_OFFS ;\n dp = 0 ;\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n const int x32_idx = ( ( i & 1 ) << 5 ) ;\n const int y32_idx = ( ( i >> 1 ) << 5 ) ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n const int x16_idx = x32_idx + ( ( j & 1 ) << 4 ) ;\n const int y16_idx = y32_idx + ( ( j >> 1 ) << 4 ) ;\n v16x16 * vst = & vt . split [ i ] . split [ j ] ;\n for ( k = 0 ;\n k < 4 ;\n k ++ ) {\n int x_idx = x16_idx + ( ( k & 1 ) << 3 ) ;\n int y_idx = y16_idx + ( ( k >> 1 ) << 3 ) ;\n unsigned int sse = 0 ;\n int sum = 0 ;\n if ( x_idx < pixels_wide && y_idx < pixels_high ) vp9_get8x8var ( s + y_idx * sp + x_idx , sp , d + y_idx * dp + x_idx , dp , & sse , & sum ) ;\n fill_variance ( sse , sum , 64 , & vst -> split [ k ] . part_variances . none ) ;\n }\n }\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ;\n }\n fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ;\n }\n fill_variance_tree ( & vt , BLOCK_64X64 ) ;\n if ( ! set_vt_partitioning ( cpi , & vt , BLOCK_64X64 , mi_row , mi_col ) ) {\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n const int x32_idx = ( ( i & 1 ) << 2 ) ;\n const int y32_idx = ( ( i >> 1 ) << 2 ) ;\n if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] , BLOCK_32X32 , ( mi_row + y32_idx ) , ( mi_col + x32_idx ) ) ) {\n for ( j = 0 ;\n j < 4 ;\n ++ j ) {\n const int x16_idx = ( ( j & 1 ) << 1 ) ;\n const int y16_idx = ( ( j >> 1 ) << 1 ) ;\n # define DISABLE_8X8_VAR_BASED_PARTITION # ifdef DISABLE_8X8_VAR_BASED_PARTITION if ( mi_row + y32_idx + y16_idx + 1 < cm -> mi_rows && mi_row + x32_idx + x16_idx + 1 < cm -> mi_cols ) {\n set_block_size ( cpi , ( mi_row + y32_idx + y16_idx ) , ( mi_col + x32_idx + x16_idx ) , BLOCK_16X16 ) ;\n }\n else {\n for ( k = 0 ;\n k < 4 ;\n ++ k ) {\n const int x8_idx = ( k & 1 ) ;\n const int y8_idx = ( k >> 1 ) ;\n set_block_size ( cpi , ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ;\n }\n }\n # else if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] . split [ j ] , tile , BLOCK_16X16 , ( mi_row + y32_idx + y16_idx ) , ( mi_col + x32_idx + x16_idx ) , 2 ) ) {\n for ( k = 0 ;\n k < 4 ;\n ++ k ) {\n const int x8_idx = ( k & 1 ) ;\n const int y8_idx = ( k >> 1 ) ;\n set_block_size ( cpi , ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ;\n }\n }\n # endif }\n }\n }\n }\n }", "hash": -5706788925640467782, "project": "chrome", "size": 106, "target": 0, "idx": 17385}
{"code": "static void update_state ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , int mi_row , int mi_col , BLOCK_SIZE bsize , int output_enabled ) {\n int i , x_idx , y ;\n VP9_COMMON * const cm = & cpi -> common ;\n RD_OPT * const rd_opt = & cpi -> rd ;\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n struct macroblock_plane * const p = x -> plane ;\n struct macroblockd_plane * const pd = xd -> plane ;\n MODE_INFO * mi = & ctx -> mic ;\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] . src_mi -> mbmi ;\n MODE_INFO * mi_addr = & xd -> mi [ 0 ] ;\n const struct segmentation * const seg = & cm -> seg ;\n const int mis = cm -> mi_stride ;\n const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ;\n const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ;\n int max_plane ;\n assert ( mi -> mbmi . sb_type == bsize ) ;\n * mi_addr = * mi ;\n mi_addr -> src_mi = mi_addr ;\n if ( seg -> enabled && output_enabled ) {\n if ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) {\n const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ;\n mi_addr -> mbmi . segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ;\n }\n if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) {\n vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] . src_mi -> mbmi , mi_row , mi_col , bsize , 1 ) ;\n }\n }\n max_plane = is_inter_block ( mbmi ) ? MAX_MB_PLANE : 1 ;\n for ( i = 0 ;\n i < max_plane ;\n ++ i ) {\n p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 1 ] ;\n p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 1 ] ;\n pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 1 ] ;\n p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 1 ] ;\n }\n for ( i = max_plane ;\n i < MAX_MB_PLANE ;\n ++ i ) {\n p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 2 ] ;\n p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 2 ] ;\n pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 2 ] ;\n p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 2 ] ;\n }\n for ( y = 0 ;\n y < mi_height ;\n y ++ ) for ( x_idx = 0 ;\n x_idx < mi_width ;\n x_idx ++ ) if ( ( xd -> mb_to_right_edge >> ( 3 + MI_SIZE_LOG2 ) ) + mi_width > x_idx && ( xd -> mb_to_bottom_edge >> ( 3 + MI_SIZE_LOG2 ) ) + mi_height > y ) {\n xd -> mi [ x_idx + y * mis ] . src_mi = mi_addr ;\n }\n if ( cpi -> oxcf . aq_mode ) vp9_init_plane_quantizers ( cpi , x ) ;\n if ( bsize < BLOCK_32X32 ) {\n if ( bsize < BLOCK_16X16 ) ctx -> tx_rd_diff [ ALLOW_16X16 ] = ctx -> tx_rd_diff [ ALLOW_8X8 ] ;\n ctx -> tx_rd_diff [ ALLOW_32X32 ] = ctx -> tx_rd_diff [ ALLOW_16X16 ] ;\n }\n if ( is_inter_block ( mbmi ) && mbmi -> sb_type < BLOCK_8X8 ) {\n mbmi -> mv [ 0 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 0 ] . as_int ;\n mbmi -> mv [ 1 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 1 ] . as_int ;\n }\n x -> skip = ctx -> skip ;\n vpx_memcpy ( x -> zcoeff_blk [ mbmi -> tx_size ] , ctx -> zcoeff_blk , sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ;\n if ( ! output_enabled ) return ;\n if ( ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) {\n for ( i = 0 ;\n i < TX_MODES ;\n i ++ ) rd_opt -> tx_select_diff [ i ] += ctx -> tx_rd_diff [ i ] ;\n }\n # if CONFIG_INTERNAL_STATS if ( frame_is_intra_only ( cm ) ) {\n static const int kf_mode_index [ ] = {\n THR_DC , THR_V_PRED , THR_H_PRED , THR_D45_PRED , THR_D135_PRED , THR_D117_PRED , THR_D153_PRED , THR_D207_PRED , THR_D63_PRED , THR_TM , }\n ;\n ++ cpi -> mode_chosen_counts [ kf_mode_index [ mbmi -> mode ] ] ;\n }\n else {\n ++ cpi -> mode_chosen_counts [ ctx -> best_mode_index ] ;\n }\n # endif if ( ! frame_is_intra_only ( cm ) ) {\n if ( is_inter_block ( mbmi ) ) {\n vp9_update_mv_count ( cm , xd ) ;\n if ( cm -> interp_filter == SWITCHABLE ) {\n const int ctx = vp9_get_pred_context_switchable_interp ( xd ) ;\n ++ cm -> counts . switchable_interp [ ctx ] [ mbmi -> interp_filter ] ;\n }\n }\n rd_opt -> comp_pred_diff [ SINGLE_REFERENCE ] += ctx -> single_pred_diff ;\n rd_opt -> comp_pred_diff [ COMPOUND_REFERENCE ] += ctx -> comp_pred_diff ;\n rd_opt -> comp_pred_diff [ REFERENCE_MODE_SELECT ] += ctx -> hybrid_pred_diff ;\n for ( i = 0 ;\n i < SWITCHABLE_FILTER_CONTEXTS ;\n ++ i ) rd_opt -> filter_diff [ i ] += ctx -> best_filter_diff [ i ] ;\n }\n }", "hash": -5706788925640467782, "project": "chrome", "size": 94, "target": 0, "idx": 17387}
{"code": "int vp9_alloc_internal_frame_buffers ( InternalFrameBufferList * list ) {\n assert ( list != NULL ) ;\n vp9_free_internal_frame_buffers ( list ) ;\n list -> num_internal_frame_buffers = VP9_MAXIMUM_REF_BUFFERS + VPX_MAXIMUM_WORK_BUFFERS ;\n list -> int_fb = ( InternalFrameBuffer * ) vpx_calloc ( list -> num_internal_frame_buffers , sizeof ( * list -> int_fb ) ) ;\n return ( list -> int_fb == NULL ) ;\n }", "hash": 6829083446989851560, "project": "chrome", "size": 7, "target": 0, "idx": 17405}
{"code": "void vp9_idct32x32_1024_add_sse2 ( const int16_t * input , uint8_t * dest , int stride ) {\n const __m128i rounding = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ;\n const __m128i final_rounding = _mm_set1_epi16 ( 1 << 5 ) ;\n const __m128i zero = _mm_setzero_si128 ( ) ;\n const __m128i stg1_0 = pair_set_epi16 ( cospi_31_64 , - cospi_1_64 ) ;\n const __m128i stg1_1 = pair_set_epi16 ( cospi_1_64 , cospi_31_64 ) ;\n const __m128i stg1_2 = pair_set_epi16 ( cospi_15_64 , - cospi_17_64 ) ;\n const __m128i stg1_3 = pair_set_epi16 ( cospi_17_64 , cospi_15_64 ) ;\n const __m128i stg1_4 = pair_set_epi16 ( cospi_23_64 , - cospi_9_64 ) ;\n const __m128i stg1_5 = pair_set_epi16 ( cospi_9_64 , cospi_23_64 ) ;\n const __m128i stg1_6 = pair_set_epi16 ( cospi_7_64 , - cospi_25_64 ) ;\n const __m128i stg1_7 = pair_set_epi16 ( cospi_25_64 , cospi_7_64 ) ;\n const __m128i stg1_8 = pair_set_epi16 ( cospi_27_64 , - cospi_5_64 ) ;\n const __m128i stg1_9 = pair_set_epi16 ( cospi_5_64 , cospi_27_64 ) ;\n const __m128i stg1_10 = pair_set_epi16 ( cospi_11_64 , - cospi_21_64 ) ;\n const __m128i stg1_11 = pair_set_epi16 ( cospi_21_64 , cospi_11_64 ) ;\n const __m128i stg1_12 = pair_set_epi16 ( cospi_19_64 , - cospi_13_64 ) ;\n const __m128i stg1_13 = pair_set_epi16 ( cospi_13_64 , cospi_19_64 ) ;\n const __m128i stg1_14 = pair_set_epi16 ( cospi_3_64 , - cospi_29_64 ) ;\n const __m128i stg1_15 = pair_set_epi16 ( cospi_29_64 , cospi_3_64 ) ;\n const __m128i stg2_0 = pair_set_epi16 ( cospi_30_64 , - cospi_2_64 ) ;\n const __m128i stg2_1 = pair_set_epi16 ( cospi_2_64 , cospi_30_64 ) ;\n const __m128i stg2_2 = pair_set_epi16 ( cospi_14_64 , - cospi_18_64 ) ;\n const __m128i stg2_3 = pair_set_epi16 ( cospi_18_64 , cospi_14_64 ) ;\n const __m128i stg2_4 = pair_set_epi16 ( cospi_22_64 , - cospi_10_64 ) ;\n const __m128i stg2_5 = pair_set_epi16 ( cospi_10_64 , cospi_22_64 ) ;\n const __m128i stg2_6 = pair_set_epi16 ( cospi_6_64 , - cospi_26_64 ) ;\n const __m128i stg2_7 = pair_set_epi16 ( cospi_26_64 , cospi_6_64 ) ;\n const __m128i stg3_0 = pair_set_epi16 ( cospi_28_64 , - cospi_4_64 ) ;\n const __m128i stg3_1 = pair_set_epi16 ( cospi_4_64 , cospi_28_64 ) ;\n const __m128i stg3_2 = pair_set_epi16 ( cospi_12_64 , - cospi_20_64 ) ;\n const __m128i stg3_3 = pair_set_epi16 ( cospi_20_64 , cospi_12_64 ) ;\n const __m128i stg3_4 = pair_set_epi16 ( - cospi_4_64 , cospi_28_64 ) ;\n const __m128i stg3_5 = pair_set_epi16 ( cospi_28_64 , cospi_4_64 ) ;\n const __m128i stg3_6 = pair_set_epi16 ( - cospi_28_64 , - cospi_4_64 ) ;\n const __m128i stg3_8 = pair_set_epi16 ( - cospi_20_64 , cospi_12_64 ) ;\n const __m128i stg3_9 = pair_set_epi16 ( cospi_12_64 , cospi_20_64 ) ;\n const __m128i stg3_10 = pair_set_epi16 ( - cospi_12_64 , - cospi_20_64 ) ;\n const __m128i stg4_0 = pair_set_epi16 ( cospi_16_64 , cospi_16_64 ) ;\n const __m128i stg4_1 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ;\n const __m128i stg4_2 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ;\n const __m128i stg4_3 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ;\n const __m128i stg4_4 = pair_set_epi16 ( - cospi_8_64 , cospi_24_64 ) ;\n const __m128i stg4_5 = pair_set_epi16 ( cospi_24_64 , cospi_8_64 ) ;\n const __m128i stg4_6 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ;\n const __m128i stg6_0 = pair_set_epi16 ( - cospi_16_64 , cospi_16_64 ) ;\n __m128i in [ 32 ] , col [ 128 ] , zero_idx [ 16 ] ;\n __m128i stp1_0 , stp1_1 , stp1_2 , stp1_3 , stp1_4 , stp1_5 , stp1_6 , stp1_7 , stp1_8 , stp1_9 , stp1_10 , stp1_11 , stp1_12 , stp1_13 , stp1_14 , stp1_15 , stp1_16 , stp1_17 , stp1_18 , stp1_19 , stp1_20 , stp1_21 , stp1_22 , stp1_23 , stp1_24 , stp1_25 , stp1_26 , stp1_27 , stp1_28 , stp1_29 , stp1_30 , stp1_31 ;\n __m128i stp2_0 , stp2_1 , stp2_2 , stp2_3 , stp2_4 , stp2_5 , stp2_6 , stp2_7 , stp2_8 , stp2_9 , stp2_10 , stp2_11 , stp2_12 , stp2_13 , stp2_14 , stp2_15 , stp2_16 , stp2_17 , stp2_18 , stp2_19 , stp2_20 , stp2_21 , stp2_22 , stp2_23 , stp2_24 , stp2_25 , stp2_26 , stp2_27 , stp2_28 , stp2_29 , stp2_30 , stp2_31 ;\n __m128i tmp0 , tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 ;\n int i , j , i32 ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n i32 = ( i << 5 ) ;\n LOAD_DQCOEFF ( in [ 0 ] , input ) ;\n LOAD_DQCOEFF ( in [ 8 ] , input ) ;\n LOAD_DQCOEFF ( in [ 16 ] , input ) ;\n LOAD_DQCOEFF ( in [ 24 ] , input ) ;\n LOAD_DQCOEFF ( in [ 1 ] , input ) ;\n LOAD_DQCOEFF ( in [ 9 ] , input ) ;\n LOAD_DQCOEFF ( in [ 17 ] , input ) ;\n LOAD_DQCOEFF ( in [ 25 ] , input ) ;\n LOAD_DQCOEFF ( in [ 2 ] , input ) ;\n LOAD_DQCOEFF ( in [ 10 ] , input ) ;\n LOAD_DQCOEFF ( in [ 18 ] , input ) ;\n LOAD_DQCOEFF ( in [ 26 ] , input ) ;\n LOAD_DQCOEFF ( in [ 3 ] , input ) ;\n LOAD_DQCOEFF ( in [ 11 ] , input ) ;\n LOAD_DQCOEFF ( in [ 19 ] , input ) ;\n LOAD_DQCOEFF ( in [ 27 ] , input ) ;\n LOAD_DQCOEFF ( in [ 4 ] , input ) ;\n LOAD_DQCOEFF ( in [ 12 ] , input ) ;\n LOAD_DQCOEFF ( in [ 20 ] , input ) ;\n LOAD_DQCOEFF ( in [ 28 ] , input ) ;\n LOAD_DQCOEFF ( in [ 5 ] , input ) ;\n LOAD_DQCOEFF ( in [ 13 ] , input ) ;\n LOAD_DQCOEFF ( in [ 21 ] , input ) ;\n LOAD_DQCOEFF ( in [ 29 ] , input ) ;\n LOAD_DQCOEFF ( in [ 6 ] , input ) ;\n LOAD_DQCOEFF ( in [ 14 ] , input ) ;\n LOAD_DQCOEFF ( in [ 22 ] , input ) ;\n LOAD_DQCOEFF ( in [ 30 ] , input ) ;\n LOAD_DQCOEFF ( in [ 7 ] , input ) ;\n LOAD_DQCOEFF ( in [ 15 ] , input ) ;\n LOAD_DQCOEFF ( in [ 23 ] , input ) ;\n LOAD_DQCOEFF ( in [ 31 ] , input ) ;\n zero_idx [ 0 ] = _mm_or_si128 ( in [ 0 ] , in [ 1 ] ) ;\n zero_idx [ 1 ] = _mm_or_si128 ( in [ 2 ] , in [ 3 ] ) ;\n zero_idx [ 2 ] = _mm_or_si128 ( in [ 4 ] , in [ 5 ] ) ;\n zero_idx [ 3 ] = _mm_or_si128 ( in [ 6 ] , in [ 7 ] ) ;\n zero_idx [ 4 ] = _mm_or_si128 ( in [ 8 ] , in [ 9 ] ) ;\n zero_idx [ 5 ] = _mm_or_si128 ( in [ 10 ] , in [ 11 ] ) ;\n zero_idx [ 6 ] = _mm_or_si128 ( in [ 12 ] , in [ 13 ] ) ;\n zero_idx [ 7 ] = _mm_or_si128 ( in [ 14 ] , in [ 15 ] ) ;\n zero_idx [ 8 ] = _mm_or_si128 ( in [ 16 ] , in [ 17 ] ) ;\n zero_idx [ 9 ] = _mm_or_si128 ( in [ 18 ] , in [ 19 ] ) ;\n zero_idx [ 10 ] = _mm_or_si128 ( in [ 20 ] , in [ 21 ] ) ;\n zero_idx [ 11 ] = _mm_or_si128 ( in [ 22 ] , in [ 23 ] ) ;\n zero_idx [ 12 ] = _mm_or_si128 ( in [ 24 ] , in [ 25 ] ) ;\n zero_idx [ 13 ] = _mm_or_si128 ( in [ 26 ] , in [ 27 ] ) ;\n zero_idx [ 14 ] = _mm_or_si128 ( in [ 28 ] , in [ 29 ] ) ;\n zero_idx [ 15 ] = _mm_or_si128 ( in [ 30 ] , in [ 31 ] ) ;\n zero_idx [ 0 ] = _mm_or_si128 ( zero_idx [ 0 ] , zero_idx [ 1 ] ) ;\n zero_idx [ 1 ] = _mm_or_si128 ( zero_idx [ 2 ] , zero_idx [ 3 ] ) ;\n zero_idx [ 2 ] = _mm_or_si128 ( zero_idx [ 4 ] , zero_idx [ 5 ] ) ;\n zero_idx [ 3 ] = _mm_or_si128 ( zero_idx [ 6 ] , zero_idx [ 7 ] ) ;\n zero_idx [ 4 ] = _mm_or_si128 ( zero_idx [ 8 ] , zero_idx [ 9 ] ) ;\n zero_idx [ 5 ] = _mm_or_si128 ( zero_idx [ 10 ] , zero_idx [ 11 ] ) ;\n zero_idx [ 6 ] = _mm_or_si128 ( zero_idx [ 12 ] , zero_idx [ 13 ] ) ;\n zero_idx [ 7 ] = _mm_or_si128 ( zero_idx [ 14 ] , zero_idx [ 15 ] ) ;\n zero_idx [ 8 ] = _mm_or_si128 ( zero_idx [ 0 ] , zero_idx [ 1 ] ) ;\n zero_idx [ 9 ] = _mm_or_si128 ( zero_idx [ 2 ] , zero_idx [ 3 ] ) ;\n zero_idx [ 10 ] = _mm_or_si128 ( zero_idx [ 4 ] , zero_idx [ 5 ] ) ;\n zero_idx [ 11 ] = _mm_or_si128 ( zero_idx [ 6 ] , zero_idx [ 7 ] ) ;\n zero_idx [ 12 ] = _mm_or_si128 ( zero_idx [ 8 ] , zero_idx [ 9 ] ) ;\n zero_idx [ 13 ] = _mm_or_si128 ( zero_idx [ 10 ] , zero_idx [ 11 ] ) ;\n zero_idx [ 14 ] = _mm_or_si128 ( zero_idx [ 12 ] , zero_idx [ 13 ] ) ;\n if ( _mm_movemask_epi8 ( _mm_cmpeq_epi32 ( zero_idx [ 14 ] , zero ) ) == 0xFFFF ) {\n col [ i32 + 0 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 1 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 2 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 3 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 4 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 5 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 6 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 7 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 8 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 9 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 10 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 11 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 12 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 13 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 14 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 15 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 16 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 17 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 18 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 19 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 20 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 21 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 22 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 23 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 24 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 25 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 26 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 27 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 28 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 29 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 30 ] = _mm_setzero_si128 ( ) ;\n col [ i32 + 31 ] = _mm_setzero_si128 ( ) ;\n continue ;\n }\n array_transpose_8x8 ( in , in ) ;\n array_transpose_8x8 ( in + 8 , in + 8 ) ;\n array_transpose_8x8 ( in + 16 , in + 16 ) ;\n array_transpose_8x8 ( in + 24 , in + 24 ) ;\n IDCT32 col [ i32 + 0 ] = _mm_add_epi16 ( stp1_0 , stp1_31 ) ;\n col [ i32 + 1 ] = _mm_add_epi16 ( stp1_1 , stp1_30 ) ;\n col [ i32 + 2 ] = _mm_add_epi16 ( stp1_2 , stp1_29 ) ;\n col [ i32 + 3 ] = _mm_add_epi16 ( stp1_3 , stp1_28 ) ;\n col [ i32 + 4 ] = _mm_add_epi16 ( stp1_4 , stp1_27 ) ;\n col [ i32 + 5 ] = _mm_add_epi16 ( stp1_5 , stp1_26 ) ;\n col [ i32 + 6 ] = _mm_add_epi16 ( stp1_6 , stp1_25 ) ;\n col [ i32 + 7 ] = _mm_add_epi16 ( stp1_7 , stp1_24 ) ;\n col [ i32 + 8 ] = _mm_add_epi16 ( stp1_8 , stp1_23 ) ;\n col [ i32 + 9 ] = _mm_add_epi16 ( stp1_9 , stp1_22 ) ;\n col [ i32 + 10 ] = _mm_add_epi16 ( stp1_10 , stp1_21 ) ;\n col [ i32 + 11 ] = _mm_add_epi16 ( stp1_11 , stp1_20 ) ;\n col [ i32 + 12 ] = _mm_add_epi16 ( stp1_12 , stp1_19 ) ;\n col [ i32 + 13 ] = _mm_add_epi16 ( stp1_13 , stp1_18 ) ;\n col [ i32 + 14 ] = _mm_add_epi16 ( stp1_14 , stp1_17 ) ;\n col [ i32 + 15 ] = _mm_add_epi16 ( stp1_15 , stp1_16 ) ;\n col [ i32 + 16 ] = _mm_sub_epi16 ( stp1_15 , stp1_16 ) ;\n col [ i32 + 17 ] = _mm_sub_epi16 ( stp1_14 , stp1_17 ) ;\n col [ i32 + 18 ] = _mm_sub_epi16 ( stp1_13 , stp1_18 ) ;\n col [ i32 + 19 ] = _mm_sub_epi16 ( stp1_12 , stp1_19 ) ;\n col [ i32 + 20 ] = _mm_sub_epi16 ( stp1_11 , stp1_20 ) ;\n col [ i32 + 21 ] = _mm_sub_epi16 ( stp1_10 , stp1_21 ) ;\n col [ i32 + 22 ] = _mm_sub_epi16 ( stp1_9 , stp1_22 ) ;\n col [ i32 + 23 ] = _mm_sub_epi16 ( stp1_8 , stp1_23 ) ;\n col [ i32 + 24 ] = _mm_sub_epi16 ( stp1_7 , stp1_24 ) ;\n col [ i32 + 25 ] = _mm_sub_epi16 ( stp1_6 , stp1_25 ) ;\n col [ i32 + 26 ] = _mm_sub_epi16 ( stp1_5 , stp1_26 ) ;\n col [ i32 + 27 ] = _mm_sub_epi16 ( stp1_4 , stp1_27 ) ;\n col [ i32 + 28 ] = _mm_sub_epi16 ( stp1_3 , stp1_28 ) ;\n col [ i32 + 29 ] = _mm_sub_epi16 ( stp1_2 , stp1_29 ) ;\n col [ i32 + 30 ] = _mm_sub_epi16 ( stp1_1 , stp1_30 ) ;\n col [ i32 + 31 ] = _mm_sub_epi16 ( stp1_0 , stp1_31 ) ;\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n j = i << 3 ;\n array_transpose_8x8 ( col + j , in ) ;\n array_transpose_8x8 ( col + j + 32 , in + 8 ) ;\n array_transpose_8x8 ( col + j + 64 , in + 16 ) ;\n array_transpose_8x8 ( col + j + 96 , in + 24 ) ;\n IDCT32 in [ 0 ] = _mm_add_epi16 ( stp1_0 , stp1_31 ) ;\n in [ 1 ] = _mm_add_epi16 ( stp1_1 , stp1_30 ) ;\n in [ 2 ] = _mm_add_epi16 ( stp1_2 , stp1_29 ) ;\n in [ 3 ] = _mm_add_epi16 ( stp1_3 , stp1_28 ) ;\n in [ 4 ] = _mm_add_epi16 ( stp1_4 , stp1_27 ) ;\n in [ 5 ] = _mm_add_epi16 ( stp1_5 , stp1_26 ) ;\n in [ 6 ] = _mm_add_epi16 ( stp1_6 , stp1_25 ) ;\n in [ 7 ] = _mm_add_epi16 ( stp1_7 , stp1_24 ) ;\n in [ 8 ] = _mm_add_epi16 ( stp1_8 , stp1_23 ) ;\n in [ 9 ] = _mm_add_epi16 ( stp1_9 , stp1_22 ) ;\n in [ 10 ] = _mm_add_epi16 ( stp1_10 , stp1_21 ) ;\n in [ 11 ] = _mm_add_epi16 ( stp1_11 , stp1_20 ) ;\n in [ 12 ] = _mm_add_epi16 ( stp1_12 , stp1_19 ) ;\n in [ 13 ] = _mm_add_epi16 ( stp1_13 , stp1_18 ) ;\n in [ 14 ] = _mm_add_epi16 ( stp1_14 , stp1_17 ) ;\n in [ 15 ] = _mm_add_epi16 ( stp1_15 , stp1_16 ) ;\n in [ 16 ] = _mm_sub_epi16 ( stp1_15 , stp1_16 ) ;\n in [ 17 ] = _mm_sub_epi16 ( stp1_14 , stp1_17 ) ;\n in [ 18 ] = _mm_sub_epi16 ( stp1_13 , stp1_18 ) ;\n in [ 19 ] = _mm_sub_epi16 ( stp1_12 , stp1_19 ) ;\n in [ 20 ] = _mm_sub_epi16 ( stp1_11 , stp1_20 ) ;\n in [ 21 ] = _mm_sub_epi16 ( stp1_10 , stp1_21 ) ;\n in [ 22 ] = _mm_sub_epi16 ( stp1_9 , stp1_22 ) ;\n in [ 23 ] = _mm_sub_epi16 ( stp1_8 , stp1_23 ) ;\n in [ 24 ] = _mm_sub_epi16 ( stp1_7 , stp1_24 ) ;\n in [ 25 ] = _mm_sub_epi16 ( stp1_6 , stp1_25 ) ;\n in [ 26 ] = _mm_sub_epi16 ( stp1_5 , stp1_26 ) ;\n in [ 27 ] = _mm_sub_epi16 ( stp1_4 , stp1_27 ) ;\n in [ 28 ] = _mm_sub_epi16 ( stp1_3 , stp1_28 ) ;\n in [ 29 ] = _mm_sub_epi16 ( stp1_2 , stp1_29 ) ;\n in [ 30 ] = _mm_sub_epi16 ( stp1_1 , stp1_30 ) ;\n in [ 31 ] = _mm_sub_epi16 ( stp1_0 , stp1_31 ) ;\n in [ 0 ] = _mm_adds_epi16 ( in [ 0 ] , final_rounding ) ;\n in [ 1 ] = _mm_adds_epi16 ( in [ 1 ] , final_rounding ) ;\n in [ 2 ] = _mm_adds_epi16 ( in [ 2 ] , final_rounding ) ;\n in [ 3 ] = _mm_adds_epi16 ( in [ 3 ] , final_rounding ) ;\n in [ 4 ] = _mm_adds_epi16 ( in [ 4 ] , final_rounding ) ;\n in [ 5 ] = _mm_adds_epi16 ( in [ 5 ] , final_rounding ) ;\n in [ 6 ] = _mm_adds_epi16 ( in [ 6 ] , final_rounding ) ;\n in [ 7 ] = _mm_adds_epi16 ( in [ 7 ] , final_rounding ) ;\n in [ 8 ] = _mm_adds_epi16 ( in [ 8 ] , final_rounding ) ;\n in [ 9 ] = _mm_adds_epi16 ( in [ 9 ] , final_rounding ) ;\n in [ 10 ] = _mm_adds_epi16 ( in [ 10 ] , final_rounding ) ;\n in [ 11 ] = _mm_adds_epi16 ( in [ 11 ] , final_rounding ) ;\n in [ 12 ] = _mm_adds_epi16 ( in [ 12 ] , final_rounding ) ;\n in [ 13 ] = _mm_adds_epi16 ( in [ 13 ] , final_rounding ) ;\n in [ 14 ] = _mm_adds_epi16 ( in [ 14 ] , final_rounding ) ;\n in [ 15 ] = _mm_adds_epi16 ( in [ 15 ] , final_rounding ) ;\n in [ 16 ] = _mm_adds_epi16 ( in [ 16 ] , final_rounding ) ;\n in [ 17 ] = _mm_adds_epi16 ( in [ 17 ] , final_rounding ) ;\n in [ 18 ] = _mm_adds_epi16 ( in [ 18 ] , final_rounding ) ;\n in [ 19 ] = _mm_adds_epi16 ( in [ 19 ] , final_rounding ) ;\n in [ 20 ] = _mm_adds_epi16 ( in [ 20 ] , final_rounding ) ;\n in [ 21 ] = _mm_adds_epi16 ( in [ 21 ] , final_rounding ) ;\n in [ 22 ] = _mm_adds_epi16 ( in [ 22 ] , final_rounding ) ;\n in [ 23 ] = _mm_adds_epi16 ( in [ 23 ] , final_rounding ) ;\n in [ 24 ] = _mm_adds_epi16 ( in [ 24 ] , final_rounding ) ;\n in [ 25 ] = _mm_adds_epi16 ( in [ 25 ] , final_rounding ) ;\n in [ 26 ] = _mm_adds_epi16 ( in [ 26 ] , final_rounding ) ;\n in [ 27 ] = _mm_adds_epi16 ( in [ 27 ] , final_rounding ) ;\n in [ 28 ] = _mm_adds_epi16 ( in [ 28 ] , final_rounding ) ;\n in [ 29 ] = _mm_adds_epi16 ( in [ 29 ] , final_rounding ) ;\n in [ 30 ] = _mm_adds_epi16 ( in [ 30 ] , final_rounding ) ;\n in [ 31 ] = _mm_adds_epi16 ( in [ 31 ] , final_rounding ) ;\n in [ 0 ] = _mm_srai_epi16 ( in [ 0 ] , 6 ) ;\n in [ 1 ] = _mm_srai_epi16 ( in [ 1 ] , 6 ) ;\n in [ 2 ] = _mm_srai_epi16 ( in [ 2 ] , 6 ) ;\n in [ 3 ] = _mm_srai_epi16 ( in [ 3 ] , 6 ) ;\n in [ 4 ] = _mm_srai_epi16 ( in [ 4 ] , 6 ) ;\n in [ 5 ] = _mm_srai_epi16 ( in [ 5 ] , 6 ) ;\n in [ 6 ] = _mm_srai_epi16 ( in [ 6 ] , 6 ) ;\n in [ 7 ] = _mm_srai_epi16 ( in [ 7 ] , 6 ) ;\n in [ 8 ] = _mm_srai_epi16 ( in [ 8 ] , 6 ) ;\n in [ 9 ] = _mm_srai_epi16 ( in [ 9 ] , 6 ) ;\n in [ 10 ] = _mm_srai_epi16 ( in [ 10 ] , 6 ) ;\n in [ 11 ] = _mm_srai_epi16 ( in [ 11 ] , 6 ) ;\n in [ 12 ] = _mm_srai_epi16 ( in [ 12 ] , 6 ) ;\n in [ 13 ] = _mm_srai_epi16 ( in [ 13 ] , 6 ) ;\n in [ 14 ] = _mm_srai_epi16 ( in [ 14 ] , 6 ) ;\n in [ 15 ] = _mm_srai_epi16 ( in [ 15 ] , 6 ) ;\n in [ 16 ] = _mm_srai_epi16 ( in [ 16 ] , 6 ) ;\n in [ 17 ] = _mm_srai_epi16 ( in [ 17 ] , 6 ) ;\n in [ 18 ] = _mm_srai_epi16 ( in [ 18 ] , 6 ) ;\n in [ 19 ] = _mm_srai_epi16 ( in [ 19 ] , 6 ) ;\n in [ 20 ] = _mm_srai_epi16 ( in [ 20 ] , 6 ) ;\n in [ 21 ] = _mm_srai_epi16 ( in [ 21 ] , 6 ) ;\n in [ 22 ] = _mm_srai_epi16 ( in [ 22 ] , 6 ) ;\n in [ 23 ] = _mm_srai_epi16 ( in [ 23 ] , 6 ) ;\n in [ 24 ] = _mm_srai_epi16 ( in [ 24 ] , 6 ) ;\n in [ 25 ] = _mm_srai_epi16 ( in [ 25 ] , 6 ) ;\n in [ 26 ] = _mm_srai_epi16 ( in [ 26 ] , 6 ) ;\n in [ 27 ] = _mm_srai_epi16 ( in [ 27 ] , 6 ) ;\n in [ 28 ] = _mm_srai_epi16 ( in [ 28 ] , 6 ) ;\n in [ 29 ] = _mm_srai_epi16 ( in [ 29 ] , 6 ) ;\n in [ 30 ] = _mm_srai_epi16 ( in [ 30 ] , 6 ) ;\n in [ 31 ] = _mm_srai_epi16 ( in [ 31 ] , 6 ) ;\n RECON_AND_STORE ( dest , in [ 0 ] ) ;\n RECON_AND_STORE ( dest , in [ 1 ] ) ;\n RECON_AND_STORE ( dest , in [ 2 ] ) ;\n RECON_AND_STORE ( dest , in [ 3 ] ) ;\n RECON_AND_STORE ( dest , in [ 4 ] ) ;\n RECON_AND_STORE ( dest , in [ 5 ] ) ;\n RECON_AND_STORE ( dest , in [ 6 ] ) ;\n RECON_AND_STORE ( dest , in [ 7 ] ) ;\n RECON_AND_STORE ( dest , in [ 8 ] ) ;\n RECON_AND_STORE ( dest , in [ 9 ] ) ;\n RECON_AND_STORE ( dest , in [ 10 ] ) ;\n RECON_AND_STORE ( dest , in [ 11 ] ) ;\n RECON_AND_STORE ( dest , in [ 12 ] ) ;\n RECON_AND_STORE ( dest , in [ 13 ] ) ;\n RECON_AND_STORE ( dest , in [ 14 ] ) ;\n RECON_AND_STORE ( dest , in [ 15 ] ) ;\n RECON_AND_STORE ( dest , in [ 16 ] ) ;\n RECON_AND_STORE ( dest , in [ 17 ] ) ;\n RECON_AND_STORE ( dest , in [ 18 ] ) ;\n RECON_AND_STORE ( dest , in [ 19 ] ) ;\n RECON_AND_STORE ( dest , in [ 20 ] ) ;\n RECON_AND_STORE ( dest , in [ 21 ] ) ;\n RECON_AND_STORE ( dest , in [ 22 ] ) ;\n RECON_AND_STORE ( dest , in [ 23 ] ) ;\n RECON_AND_STORE ( dest , in [ 24 ] ) ;\n RECON_AND_STORE ( dest , in [ 25 ] ) ;\n RECON_AND_STORE ( dest , in [ 26 ] ) ;\n RECON_AND_STORE ( dest , in [ 27 ] ) ;\n RECON_AND_STORE ( dest , in [ 28 ] ) ;\n RECON_AND_STORE ( dest , in [ 29 ] ) ;\n RECON_AND_STORE ( dest , in [ 30 ] ) ;\n RECON_AND_STORE ( dest , in [ 31 ] ) ;\n dest += 8 - ( stride * 32 ) ;\n }\n }", "hash": -1710554222303887484, "project": "chrome", "size": 329, "target": 0, "idx": 17424}
{"code": "void vp9_remove_common ( VP9_COMMON * cm ) {\n vp9_free_ref_frame_buffers ( cm ) ;\n vp9_free_context_buffers ( cm ) ;\n vp9_free_internal_frame_buffers ( & cm -> int_frame_buffers ) ;\n }", "hash": -7415191846425595149, "project": "chrome", "size": 5, "target": 0, "idx": 17442}
{"code": "int vp9_alloc_ref_frame_buffers ( VP9_COMMON * cm , int width , int height ) {\n int i ;\n const int ss_x = cm -> subsampling_x ;\n const int ss_y = cm -> subsampling_y ;\n vp9_free_ref_frame_buffers ( cm ) ;\n for ( i = 0 ;\n i < FRAME_BUFFERS ;\n ++ i ) {\n cm -> frame_bufs [ i ] . ref_count = 0 ;\n if ( vp9_alloc_frame_buffer ( & cm -> frame_bufs [ i ] . buf , width , height , ss_x , ss_y , # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS ) < 0 ) goto fail ;\n }\n init_frame_bufs ( cm ) ;\n # if CONFIG_INTERNAL_STATS || CONFIG_VP9_POSTPROC if ( vp9_alloc_frame_buffer ( & cm -> post_proc_buffer , width , height , ss_x , ss_y , # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS ) < 0 ) goto fail ;\n # endif return 0 ;\n fail : vp9_free_ref_frame_buffers ( cm ) ;\n return 1 ;\n }", "hash": -7415191846425595149, "project": "chrome", "size": 17, "target": 0, "idx": 17449}
{"code": "int16_t vp9_ac_quant ( int qindex , int delta , vpx_bit_depth_t bit_depth ) {\n # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) {\n case VPX_BITS_8 : return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;\n case VPX_BITS_10 : return ac_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ;\n case VPX_BITS_12 : return ac_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ;\n default : assert ( 0 && \"bit_depth should be VPX_BITS_8, VPX_BITS_10 or VPX_BITS_12\" ) ;\n return - 1 ;\n }\n # else ( void ) bit_depth ;\n return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;\n # endif }", "hash": 6827449473891484617, "project": "chrome", "size": 11, "target": 0, "idx": 17452}
{"code": "static unsigned int sse_thresh ( BLOCK_SIZE bs , int increase_denoising ) {\n return widths [ bs ] * heights [ bs ] * ( increase_denoising ? 60 : 40 ) ;\n }", "hash": 8085056330506804135, "project": "chrome", "size": 3, "target": 0, "idx": 17468}
{"code": "int vp9_denoiser_alloc ( VP9_DENOISER * denoiser , int width , int height , int ssx , int ssy , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif int border ) {\n int i , fail ;\n assert ( denoiser != NULL ) ;\n for ( i = 0 ;\n i < MAX_REF_FRAMES ;\n ++ i ) {\n fail = vp9_alloc_frame_buffer ( & denoiser -> running_avg_y [ i ] , width , height , ssx , ssy , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif border ) ;\n if ( fail ) {\n vp9_denoiser_free ( denoiser ) ;\n return 1 ;\n }\n # ifdef OUTPUT_YUV_DENOISED make_grayscale ( & denoiser -> running_avg_y [ i ] ) ;\n # endif }\n fail = vp9_alloc_frame_buffer ( & denoiser -> mc_running_avg_y , width , height , ssx , ssy , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif border ) ;\n if ( fail ) {\n vp9_denoiser_free ( denoiser ) ;\n return 1 ;\n }\n # ifdef OUTPUT_YUV_DENOISED make_grayscale ( & denoiser -> running_avg_y [ i ] ) ;\n # endif denoiser -> increase_denoising = 0 ;\n return 0 ;\n }", "hash": 8085056330506804135, "project": "chrome", "size": 22, "target": 0, "idx": 17469}
{"code": "void vp9_sad ## m ## x ## n ## x ## k ## _c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < k ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , & ref [ i ] , ref_stride ) ;\n \\ }\n # define sadMxNx4D ( m , n ) void vp9_sad ## m ## x ## n ## x4d_c ( const uint8_t * src , int src_stride , const uint8_t * const refs [ ] , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , refs [ i ] , ref_stride ) ;\n \\ }\n sadMxN ( 64 , 64 ) sadMxNxK ( 64 , 64 , 3 ) sadMxNxK ( 64 , 64 , 8 )", "hash": 3557739556029059195, "project": "chrome", "size": 13, "target": 0, "idx": 17481}
{"code": "unsigned int vp9_sad ## m ## x ## n ## _avg_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , const uint8_t * second_pred ) {\n uint8_t comp_pred [ m * n ] ;\n vp9_comp_avg_pred ( comp_pred , second_pred , m , n , ref , ref_stride ) ;\n return sad ( src , src_stride , comp_pred , m , m , n ) ;\n \\ }\n # define sadMxNxK ( m , n , k ) void vp9_sad ## m ## x ## n ## x ## k ## _c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < k ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , & ref [ i ] , ref_stride ) ;\n \\ }\n # define sadMxNx4D ( m , n ) void vp9_sad ## m ## x ## n ## x4d_c ( const uint8_t * src , int src_stride , const uint8_t * const refs [ ] , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , refs [ i ] , ref_stride ) ;\n \\ }\n sadMxN ( 64 , 64 ) sadMxNxK ( 64 , 64 , 3 ) sadMxNxK ( 64 , 64 , 8 ) sadMxNx4D ( 64 , 64 ) sadMxN ( 64 , 32 )", "hash": 3557739556029059195, "project": "chrome", "size": 18, "target": 0, "idx": 17502}
{"code": "unsigned int vp9_sad ## m ## x ## n ## _c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride ) {\n return sad ( src , src_stride , ref , ref_stride , m , n ) ;\n \\ }\n unsigned int vp9_sad ## m ## x ## n ## _avg_c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , const uint8_t * second_pred ) {\n uint8_t comp_pred [ m * n ] ;\n vp9_comp_avg_pred ( comp_pred , second_pred , m , n , ref , ref_stride ) ;\n return sad ( src , src_stride , comp_pred , m , m , n ) ;\n \\ }\n # define sadMxNxK ( m , n , k ) void vp9_sad ## m ## x ## n ## x ## k ## _c ( const uint8_t * src , int src_stride , const uint8_t * ref , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < k ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , & ref [ i ] , ref_stride ) ;\n \\ }\n # define sadMxNx4D ( m , n ) void vp9_sad ## m ## x ## n ## x4d_c ( const uint8_t * src , int src_stride , const uint8_t * const refs [ ] , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , refs [ i ] , ref_stride ) ;\n \\ }\n sadMxN ( 64 , 64 ) sadMxNxK ( 64 , 64 , 3 ) sadMxNxK ( 64 , 64 , 8 ) sadMxNx4D ( 64 , 64 ) sadMxN ( 64 , 32 ) sadMxNx4D ( 64 , 32 ) sadMxN ( 32 , 64 ) sadMxNx4D ( 32 , 64 ) sadMxN ( 32 , 32 ) sadMxNxK ( 32 , 32 , 3 ) sadMxNxK ( 32 , 32 , 8 ) sadMxNx4D ( 32 , 32 ) sadMxN ( 32 , 16 ) sadMxNx4D ( 32 , 16 ) sadMxN ( 16 , 32 ) sadMxNx4D ( 16 , 32 ) sadMxN ( 16 , 16 ) sadMxNxK ( 16 , 16 , 3 ) sadMxNxK ( 16 , 16 , 8 ) sadMxNx4D ( 16 , 16 ) sadMxN ( 16 , 8 ) sadMxNxK ( 16 , 8 , 3 ) sadMxNxK ( 16 , 8 , 8 ) sadMxNx4D ( 16 , 8 ) sadMxN ( 8 , 16 ) sadMxNxK ( 8 , 16 , 3 ) sadMxNxK ( 8 , 16 , 8 ) sadMxNx4D ( 8 , 16 ) sadMxN ( 8 , 8 ) sadMxNxK ( 8 , 8 , 3 ) sadMxNxK ( 8 , 8 , 8 ) sadMxNx4D ( 8 , 8 ) sadMxN ( 8 , 4 ) sadMxNxK ( 8 , 4 , 8 ) sadMxNx4D ( 8 , 4 ) sadMxN ( 4 , 8 )", "hash": 3557739556029059195, "project": "chrome", "size": 21, "target": 0, "idx": 17531}
{"code": "void vp9_sad ## m ## x ## n ## x4d_c ( const uint8_t * src , int src_stride , const uint8_t * const refs [ ] , int ref_stride , unsigned int * sads ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) sads [ i ] = vp9_sad ## m ## x ## n ## _c ( src , src_stride , refs [ i ] , ref_stride ) ;\n \\ }\n sadMxN ( 64 , 64 ) sadMxNxK ( 64 , 64 , 3 ) sadMxNxK ( 64 , 64 , 8 ) sadMxNx4D ( 64 , 64 ) sadMxN ( 64 , 32 ) sadMxNx4D ( 64 , 32 )", "hash": 3557739556029059195, "project": "chrome", "size": 7, "target": 0, "idx": 17532}
{"code": "void y4m_input_close ( y4m_input * _y4m ) {\n free ( _y4m -> dst_buf ) ;\n free ( _y4m -> aux_buf ) ;\n }", "hash": -5018199117312371093, "project": "chrome", "size": 4, "target": 0, "idx": 17544}
{"code": "void vp8_transform_mbuv ( MACROBLOCK * x ) {\n int i ;\n for ( i = 16 ;\n i < 24 ;\n i += 2 ) {\n x -> short_fdct8x4 ( & x -> block [ i ] . src_diff [ 0 ] , & x -> block [ i ] . coeff [ 0 ] , 16 ) ;\n }\n }", "hash": -1321749842392027937, "project": "chrome", "size": 8, "target": 0, "idx": 17560}
{"code": "void vp8_subtract_mby_c ( short * diff , unsigned char * src , int src_stride , unsigned char * pred , int pred_stride ) {\n int r , c ;\n for ( r = 0 ;\n r < 16 ;\n r ++ ) {\n for ( c = 0 ;\n c < 16 ;\n c ++ ) {\n diff [ c ] = src [ c ] - pred [ c ] ;\n }\n diff += 16 ;\n pred += pred_stride ;\n src += src_stride ;\n }\n }", "hash": -1321749842392027937, "project": "chrome", "size": 15, "target": 0, "idx": 17562}
{"code": "void vp8_optimize_mby ( MACROBLOCK * x ) {\n int b ;\n int type ;\n int has_2nd_order ;\n ENTROPY_CONTEXT_PLANES t_above , t_left ;\n ENTROPY_CONTEXT * ta ;\n ENTROPY_CONTEXT * tl ;\n if ( ! x -> e_mbd . above_context ) return ;\n if ( ! x -> e_mbd . left_context ) return ;\n vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;\n vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ;\n ta = ( ENTROPY_CONTEXT * ) & t_above ;\n tl = ( ENTROPY_CONTEXT * ) & t_left ;\n has_2nd_order = ( x -> e_mbd . mode_info_context -> mbmi . mode != B_PRED && x -> e_mbd . mode_info_context -> mbmi . mode != SPLITMV ) ;\n type = has_2nd_order ? PLANE_TYPE_Y_NO_DC : PLANE_TYPE_Y_WITH_DC ;\n for ( b = 0 ;\n b < 16 ;\n b ++ ) {\n optimize_b ( x , b , type , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ;\n }\n if ( has_2nd_order ) {\n b = 24 ;\n optimize_b ( x , b , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ;\n check_reset_2nd_coeffs ( & x -> e_mbd , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ;\n }\n }", "hash": -1321749842392027937, "project": "chrome", "size": 26, "target": 0, "idx": 17563}
{"code": "static void setup_frame_size ( VP9_COMMON * cm , struct vp9_read_bit_buffer * rb ) {\n int width , height ;\n vp9_read_frame_size ( rb , & width , & height ) ;\n resize_context_buffers ( cm , width , height ) ;\n setup_display_size ( cm , rb ) ;\n if ( vp9_realloc_frame_buffer ( get_frame_new_buffer ( cm ) , cm -> width , cm -> height , cm -> subsampling_x , cm -> subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth , # endif VP9_DEC_BORDER_IN_PIXELS , & cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer , cm -> get_fb_cb , cm -> cb_priv ) ) {\n vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , \"Failed to allocate frame buffer\" ) ;\n }\n cm -> frame_bufs [ cm -> new_fb_idx ] . buf . bit_depth = ( unsigned int ) cm -> bit_depth ;\n }", "hash": 1353431100313404503, "project": "chrome", "size": 10, "target": 0, "idx": 17583}
{"code": "static void free_tree_contexts ( PC_TREE * tree ) {\n free_mode_context ( & tree -> none ) ;\n free_mode_context ( & tree -> horizontal [ 0 ] ) ;\n free_mode_context ( & tree -> horizontal [ 1 ] ) ;\n free_mode_context ( & tree -> vertical [ 0 ] ) ;\n free_mode_context ( & tree -> vertical [ 1 ] ) ;\n }", "hash": -2375740980880577395, "project": "chrome", "size": 7, "target": 0, "idx": 17585}
{"code": "static double get_sr_decay_rate ( const VP9_COMMON * cm , const FIRSTPASS_STATS * frame ) {\n double sr_diff = ( frame -> sr_coded_error - frame -> coded_error ) / cm -> MBs ;\n double sr_decay = 1.0 ;\n const double motion_amplitude_factor = frame -> pcnt_motion * ( ( frame -> mvc_abs + frame -> mvr_abs ) / 2 ) ;\n const double pcnt_intra = 100 * ( 1.0 - frame -> pcnt_inter ) ;\n if ( ( sr_diff > LOW_SR_DIFF_TRHESH ) ) {\n sr_diff = MIN ( sr_diff , SR_DIFF_MAX ) ;\n sr_decay = 1.0 - ( SR_DIFF_PART * sr_diff ) - ( MOTION_AMP_PART * motion_amplitude_factor ) - ( INTRA_PART * pcnt_intra ) ;\n }\n return MAX ( sr_decay , MIN ( DEFAULT_DECAY_LIMIT , frame -> pcnt_inter ) ) ;\n }", "hash": -4960438251319819237, "project": "chrome", "size": 11, "target": 0, "idx": 17593}
{"code": "static int calc_arf_boost ( VP9_COMP * cpi , int offset , int f_frames , int b_frames , int * f_boost , int * b_boost ) {\n TWO_PASS * const twopass = & cpi -> twopass ;\n int i ;\n double boost_score = 0.0 ;\n double mv_ratio_accumulator = 0.0 ;\n double decay_accumulator = 1.0 ;\n double this_frame_mv_in_out = 0.0 ;\n double mv_in_out_accumulator = 0.0 ;\n double abs_mv_in_out_accumulator = 0.0 ;\n int arf_boost ;\n int flash_detected = 0 ;\n for ( i = 0 ;\n i < f_frames ;\n ++ i ) {\n const FIRSTPASS_STATS * this_frame = read_frame_stats ( twopass , i + offset ) ;\n if ( this_frame == NULL ) break ;\n accumulate_frame_motion_stats ( this_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ;\n flash_detected = detect_flash ( twopass , i + offset ) || detect_flash ( twopass , i + offset + 1 ) ;\n if ( ! flash_detected ) {\n decay_accumulator *= get_prediction_decay_rate ( & cpi -> common , this_frame ) ;\n decay_accumulator = decay_accumulator < MIN_DECAY_FACTOR ? MIN_DECAY_FACTOR : decay_accumulator ;\n }\n boost_score += decay_accumulator * calc_frame_boost ( cpi , this_frame , this_frame_mv_in_out , GF_MAX_BOOST ) ;\n }\n * f_boost = ( int ) boost_score ;\n boost_score = 0.0 ;\n mv_ratio_accumulator = 0.0 ;\n decay_accumulator = 1.0 ;\n this_frame_mv_in_out = 0.0 ;\n mv_in_out_accumulator = 0.0 ;\n abs_mv_in_out_accumulator = 0.0 ;\n for ( i = - 1 ;\n i >= - b_frames ;\n -- i ) {\n const FIRSTPASS_STATS * this_frame = read_frame_stats ( twopass , i + offset ) ;\n if ( this_frame == NULL ) break ;\n accumulate_frame_motion_stats ( this_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ;\n flash_detected = detect_flash ( twopass , i + offset ) || detect_flash ( twopass , i + offset + 1 ) ;\n if ( ! flash_detected ) {\n decay_accumulator *= get_prediction_decay_rate ( & cpi -> common , this_frame ) ;\n decay_accumulator = decay_accumulator < MIN_DECAY_FACTOR ? MIN_DECAY_FACTOR : decay_accumulator ;\n }\n boost_score += decay_accumulator * calc_frame_boost ( cpi , this_frame , this_frame_mv_in_out , GF_MAX_BOOST ) ;\n }\n * b_boost = ( int ) boost_score ;\n arf_boost = ( * f_boost + * b_boost ) ;\n if ( arf_boost < ( ( b_frames + f_frames ) * 20 ) ) arf_boost = ( ( b_frames + f_frames ) * 20 ) ;\n return arf_boost ;\n }", "hash": -4960438251319819237, "project": "chrome", "size": 49, "target": 0, "idx": 17601}
{"code": "static void first_pass_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , const MV * ref_mv , MV * best_mv , int * best_motion_err ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MV tmp_mv = {\n 0 , 0 }\n ;\n MV ref_mv_full = {\n ref_mv -> row >> 3 , ref_mv -> col >> 3 }\n ;\n int num00 , tmp_err , n ;\n const BLOCK_SIZE bsize = xd -> mi [ 0 ] . src_mi -> mbmi . sb_type ;\n vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ bsize ] ;\n const int new_mv_mode_penalty = NEW_MV_MODE_PENALTY ;\n int step_param = 3 ;\n int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ;\n const int sr = get_search_range ( & cpi -> common ) ;\n step_param += sr ;\n further_steps -= sr ;\n v_fn_ptr . vf = get_block_variance_fn ( bsize ) ;\n tmp_err = cpi -> diamond_search_sad ( x , & cpi -> ss_cfg , & ref_mv_full , & tmp_mv , step_param , x -> sadperbit16 , & num00 , & v_fn_ptr , ref_mv ) ;\n if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ;\n if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ;\n if ( tmp_err < * best_motion_err ) {\n * best_motion_err = tmp_err ;\n * best_mv = tmp_mv ;\n }\n n = num00 ;\n num00 = 0 ;\n while ( n < further_steps ) {\n ++ n ;\n if ( num00 ) {\n -- num00 ;\n }\n else {\n tmp_err = cpi -> diamond_search_sad ( x , & cpi -> ss_cfg , & ref_mv_full , & tmp_mv , step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr , ref_mv ) ;\n if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ;\n if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ;\n if ( tmp_err < * best_motion_err ) {\n * best_motion_err = tmp_err ;\n * best_mv = tmp_mv ;\n }\n }\n }\n }", "hash": -4960438251319819237, "project": "chrome", "size": 43, "target": 0, "idx": 17603}
{"code": "static vp9_variance_fn_t get_block_variance_fn ( BLOCK_SIZE bsize ) {\n switch ( bsize ) {\n case BLOCK_8X8 : return vp9_mse8x8 ;\n case BLOCK_16X8 : return vp9_mse16x8 ;\n case BLOCK_8X16 : return vp9_mse8x16 ;\n default : return vp9_mse16x16 ;\n }\n }", "hash": -4960438251319819237, "project": "chrome", "size": 8, "target": 0, "idx": 17606}
{"code": "void vp9_init_first_pass ( VP9_COMP * cpi ) {\n zero_stats ( & cpi -> twopass . total_stats ) ;\n }", "hash": -4960438251319819237, "project": "chrome", "size": 3, "target": 0, "idx": 17614}
{"code": "static void reset_fpf_position ( TWO_PASS * p , const FIRSTPASS_STATS * position ) {\n p -> stats_in = position ;\n }", "hash": -4960438251319819237, "project": "chrome", "size": 3, "target": 0, "idx": 17619}
{"code": "void vp8_blend_mb_inner_c ( unsigned char * y , unsigned char * u , unsigned char * v , int y_1 , int u_1 , int v_1 , int alpha , int stride ) {\n int i , j ;\n int y1_const = y_1 * ( ( 1 << 16 ) - alpha ) ;\n int u1_const = u_1 * ( ( 1 << 16 ) - alpha ) ;\n int v1_const = v_1 * ( ( 1 << 16 ) - alpha ) ;\n y += 2 * stride + 2 ;\n for ( i = 0 ;\n i < 12 ;\n i ++ ) {\n for ( j = 0 ;\n j < 12 ;\n j ++ ) {\n y [ j ] = ( y [ j ] * alpha + y1_const ) >> 16 ;\n }\n y += stride ;\n }\n stride >>= 1 ;\n u += stride + 1 ;\n v += stride + 1 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n for ( j = 0 ;\n j < 6 ;\n j ++ ) {\n u [ j ] = ( u [ j ] * alpha + u1_const ) >> 16 ;\n v [ j ] = ( v [ j ] * alpha + v1_const ) >> 16 ;\n }\n u += stride ;\n v += stride ;\n }\n }", "hash": -320658364442495927, "project": "chrome", "size": 32, "target": 0, "idx": 17656}
{"code": "static int64_t rd_pick_intra_sby_mode ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize , int64_t tx_cache [ TX_MODES ] , int64_t best_rd ) {\n PREDICTION_MODE mode ;\n PREDICTION_MODE mode_selected = DC_PRED ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MODE_INFO * const mic = xd -> mi [ 0 ] . src_mi ;\n int this_rate , this_rate_tokenonly , s ;\n int64_t this_distortion , this_rd ;\n TX_SIZE best_tx = TX_4X4 ;\n int i ;\n int * bmode_costs = cpi -> mbmode_cost ;\n if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) for ( i = 0 ;\n i < TX_MODES ;\n i ++ ) tx_cache [ i ] = INT64_MAX ;\n for ( mode = DC_PRED ;\n mode <= TM_PRED ;\n mode ++ ) {\n int64_t local_tx_cache [ TX_MODES ] ;\n MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] . src_mi ;\n MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] . src_mi : NULL ;\n if ( cpi -> common . frame_type == KEY_FRAME ) {\n const PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ;\n const PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ;\n bmode_costs = cpi -> y_mode_costs [ A ] [ L ] ;\n }\n mic -> mbmi . mode = mode ;\n super_block_yrd ( cpi , x , & this_rate_tokenonly , & this_distortion , & s , NULL , bsize , local_tx_cache , best_rd ) ;\n if ( this_rate_tokenonly == INT_MAX ) continue ;\n this_rate = this_rate_tokenonly + bmode_costs [ mode ] ;\n this_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_distortion ) ;\n if ( this_rd < best_rd ) {\n mode_selected = mode ;\n best_rd = this_rd ;\n best_tx = mic -> mbmi . tx_size ;\n * rate = this_rate ;\n * rate_tokenonly = this_rate_tokenonly ;\n * distortion = this_distortion ;\n * skippable = s ;\n }\n if ( cpi -> sf . tx_size_search_method == USE_FULL_RD && this_rd < INT64_MAX ) {\n for ( i = 0 ;\n i < TX_MODES && local_tx_cache [ i ] < INT64_MAX ;\n i ++ ) {\n const int64_t adj_rd = this_rd + local_tx_cache [ i ] - local_tx_cache [ cpi -> common . tx_mode ] ;\n if ( adj_rd < tx_cache [ i ] ) {\n tx_cache [ i ] = adj_rd ;\n }\n }\n }\n }\n mic -> mbmi . mode = mode_selected ;\n mic -> mbmi . tx_size = best_tx ;\n return best_rd ;\n }", "hash": 3887066622454352196, "project": "chrome", "size": 53, "target": 0, "idx": 17695}
{"code": "static int64_t rd_pick_intra_sbuv_mode ( VP9_COMP * cpi , MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize , TX_SIZE max_tx_size ) {\n MACROBLOCKD * xd = & x -> e_mbd ;\n PREDICTION_MODE mode ;\n PREDICTION_MODE mode_selected = DC_PRED ;\n int64_t best_rd = INT64_MAX , this_rd ;\n int this_rate_tokenonly , this_rate , s ;\n int64_t this_distortion , this_sse ;\n for ( mode = DC_PRED ;\n mode <= TM_PRED ;\n ++ mode ) {\n if ( ! ( cpi -> sf . intra_uv_mode_mask [ max_tx_size ] & ( 1 << mode ) ) ) continue ;\n xd -> mi [ 0 ] . src_mi -> mbmi . uv_mode = mode ;\n super_block_uvrd ( cpi , x , & this_rate_tokenonly , & this_distortion , & s , & this_sse , bsize , best_rd ) ;\n if ( this_rate_tokenonly == INT_MAX ) continue ;\n this_rate = this_rate_tokenonly + cpi -> intra_uv_mode_cost [ cpi -> common . frame_type ] [ mode ] ;\n this_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_distortion ) ;\n if ( this_rd < best_rd ) {\n mode_selected = mode ;\n best_rd = this_rd ;\n * rate = this_rate ;\n * rate_tokenonly = this_rate_tokenonly ;\n * distortion = this_distortion ;\n * skippable = s ;\n if ( ! x -> select_tx_size ) swap_block_ptr ( x , ctx , 2 , 0 , 1 , MAX_MB_PLANE ) ;\n }\n }\n xd -> mi [ 0 ] . src_mi -> mbmi . uv_mode = mode_selected ;\n return best_rd ;\n }", "hash": 3887066622454352196, "project": "chrome", "size": 29, "target": 0, "idx": 17701}
{"code": "static void set_mv_search_params ( VP9_COMP * cpi ) {\n const VP9_COMMON * const cm = & cpi -> common ;\n const unsigned int max_mv_def = MIN ( cm -> width , cm -> height ) ;\n cpi -> mv_step_param = vp9_init_search_range ( max_mv_def ) ;\n if ( cpi -> sf . mv . auto_mv_step_size ) {\n if ( frame_is_intra_only ( cm ) ) {\n cpi -> max_mv_magnitude = max_mv_def ;\n }\n else {\n if ( cm -> show_frame ) cpi -> mv_step_param = vp9_init_search_range ( MIN ( max_mv_def , 2 * cpi -> max_mv_magnitude ) ) ;\n cpi -> max_mv_magnitude = 0 ;\n }\n }\n }", "hash": -2222463888415249941, "project": "chrome", "size": 14, "target": 0, "idx": 17720}
{"code": "static void alloc_raw_frame_buffers ( VP9_COMP * cpi ) {\n VP9_COMMON * cm = & cpi -> common ;\n const VP9EncoderConfig * oxcf = & cpi -> oxcf ;\n cpi -> lookahead = vp9_lookahead_init ( oxcf -> width , oxcf -> height , cm -> subsampling_x , cm -> subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth , # endif oxcf -> lag_in_frames ) ;\n if ( ! cpi -> lookahead ) vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , \"Failed to allocate lag buffers\" ) ;\n if ( vp9_realloc_frame_buffer ( & cpi -> alt_ref_buffer , oxcf -> width , oxcf -> height , cm -> subsampling_x , cm -> subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , NULL , NULL , NULL ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , \"Failed to allocate altref buffer\" ) ;\n }", "hash": -2222463888415249941, "project": "chrome", "size": 7, "target": 0, "idx": 17732}
{"code": "static void scale_and_extend_frame_nonnormative ( const YV12_BUFFER_CONFIG * src , YV12_BUFFER_CONFIG * dst ) {\n int i ;\n const uint8_t * const srcs [ 3 ] = {\n src -> y_buffer , src -> u_buffer , src -> v_buffer }\n ;\n const int src_strides [ 3 ] = {\n src -> y_stride , src -> uv_stride , src -> uv_stride }\n ;\n const int src_widths [ 3 ] = {\n src -> y_crop_width , src -> uv_crop_width , src -> uv_crop_width }\n ;\n const int src_heights [ 3 ] = {\n src -> y_crop_height , src -> uv_crop_height , src -> uv_crop_height }\n ;\n uint8_t * const dsts [ 3 ] = {\n dst -> y_buffer , dst -> u_buffer , dst -> v_buffer }\n ;\n const int dst_strides [ 3 ] = {\n dst -> y_stride , dst -> uv_stride , dst -> uv_stride }\n ;\n const int dst_widths [ 3 ] = {\n dst -> y_crop_width , dst -> uv_crop_width , dst -> uv_crop_width }\n ;\n const int dst_heights [ 3 ] = {\n dst -> y_crop_height , dst -> uv_crop_height , dst -> uv_crop_height }\n ;\n for ( i = 0 ;\n i < MAX_MB_PLANE ;\n ++ i ) vp9_resize_plane ( srcs [ i ] , src_heights [ i ] , src_widths [ i ] , src_strides [ i ] , dsts [ i ] , dst_heights [ i ] , dst_widths [ i ] , dst_strides [ i ] ) ;\n vp9_extend_frame_borders ( dst ) ;\n }", "hash": -2222463888415249941, "project": "chrome", "size": 31, "target": 0, "idx": 17742}
{"code": "static void restore_coding_context ( VP9_COMP * cpi ) {\n CODING_CONTEXT * const cc = & cpi -> coding_context ;\n VP9_COMMON * cm = & cpi -> common ;\n vp9_copy ( cpi -> mb . nmvjointcost , cc -> nmvjointcost ) ;\n vpx_memcpy ( cpi -> nmvcosts [ 0 ] , cc -> nmvcosts [ 0 ] , MV_VALS * sizeof ( * cc -> nmvcosts [ 0 ] ) ) ;\n vpx_memcpy ( cpi -> nmvcosts [ 1 ] , cc -> nmvcosts [ 1 ] , MV_VALS * sizeof ( * cc -> nmvcosts [ 1 ] ) ) ;\n vpx_memcpy ( cpi -> nmvcosts_hp [ 0 ] , cc -> nmvcosts_hp [ 0 ] , MV_VALS * sizeof ( * cc -> nmvcosts_hp [ 0 ] ) ) ;\n vpx_memcpy ( cpi -> nmvcosts_hp [ 1 ] , cc -> nmvcosts_hp [ 1 ] , MV_VALS * sizeof ( * cc -> nmvcosts_hp [ 1 ] ) ) ;\n vp9_copy ( cm -> seg . pred_probs , cc -> segment_pred_probs ) ;\n vpx_memcpy ( cm -> last_frame_seg_map , cpi -> coding_context . last_frame_seg_map_copy , ( cm -> mi_rows * cm -> mi_cols ) ) ;\n vp9_copy ( cm -> lf . last_ref_deltas , cc -> last_ref_lf_deltas ) ;\n vp9_copy ( cm -> lf . last_mode_deltas , cc -> last_mode_lf_deltas ) ;\n cm -> fc = cc -> fc ;\n }", "hash": -2222463888415249941, "project": "chrome", "size": 14, "target": 0, "idx": 17745}
{"code": "static void set_arf_sign_bias ( VP9_COMP * cpi ) {\n VP9_COMMON * const cm = & cpi -> common ;\n int arf_sign_bias ;\n if ( ( cpi -> oxcf . pass == 2 ) && cpi -> multi_arf_allowed ) {\n const GF_GROUP * const gf_group = & cpi -> twopass . gf_group ;\n arf_sign_bias = cpi -> rc . source_alt_ref_active && ( ! cpi -> refresh_alt_ref_frame || ( gf_group -> rf_level [ gf_group -> index ] == GF_ARF_LOW ) ) ;\n }\n else {\n arf_sign_bias = ( cpi -> rc . source_alt_ref_active && ! cpi -> refresh_alt_ref_frame ) ;\n }\n cm -> ref_frame_sign_bias [ ALTREF_FRAME ] = arf_sign_bias ;\n }", "hash": -2222463888415249941, "project": "chrome", "size": 12, "target": 0, "idx": 17754}
{"code": "YV12_BUFFER_CONFIG * vp9_scale_if_required ( VP9_COMMON * cm , YV12_BUFFER_CONFIG * unscaled , YV12_BUFFER_CONFIG * scaled ) {\n if ( cm -> mi_cols * MI_SIZE != unscaled -> y_width || cm -> mi_rows * MI_SIZE != unscaled -> y_height ) {\n scale_and_extend_frame_nonnormative ( unscaled , scaled ) ;\n return scaled ;\n }\n else {\n return unscaled ;\n }\n }", "hash": -2222463888415249941, "project": "chrome", "size": 9, "target": 0, "idx": 17756}
{"code": "int vp9_update_entropy ( VP9_COMP * cpi , int update ) {\n cpi -> ext_refresh_frame_context = update ;\n cpi -> ext_refresh_frame_context_pending = 1 ;\n return 0 ;\n }", "hash": -2222463888415249941, "project": "chrome", "size": 5, "target": 0, "idx": 17760}
{"code": "void vp9_new_framerate ( VP9_COMP * cpi , double framerate ) {\n cpi -> framerate = framerate < 0.1 ? 30 : framerate ;\n vp9_rc_update_framerate ( cpi ) ;\n }", "hash": -2222463888415249941, "project": "chrome", "size": 4, "target": 0, "idx": 17771}
{"code": "int vp9_bigdia_search ( const MACROBLOCK * x , MV * ref_mv , int search_param , int sad_per_bit , int do_init_search , int * sad_list , const vp9_variance_fn_ptr_t * vfp , int use_mvcost , const MV * center_mv , MV * best_mv ) {\n static const int bigdia_num_candidates [ MAX_PATTERN_SCALES ] = {\n 4 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , }\n ;\n static const MV bigdia_candidates [ MAX_PATTERN_SCALES ] [ MAX_PATTERN_CANDIDATES ] = {\n {\n {\n 0 , - 1 }\n , {\n 1 , 0 }\n , {\n 0 , 1 }\n , {\n - 1 , 0 }\n }\n , {\n {\n - 1 , - 1 }\n , {\n 0 , - 2 }\n , {\n 1 , - 1 }\n , {\n 2 , 0 }\n , {\n 1 , 1 }\n , {\n 0 , 2 }\n , {\n - 1 , 1 }\n , {\n - 2 , 0 }\n }\n , {\n {\n - 2 , - 2 }\n , {\n 0 , - 4 }\n , {\n 2 , - 2 }\n , {\n 4 , 0 }\n , {\n 2 , 2 }\n , {\n 0 , 4 }\n , {\n - 2 , 2 }\n , {\n - 4 , 0 }\n }\n , {\n {\n - 4 , - 4 }\n , {\n 0 , - 8 }\n , {\n 4 , - 4 }\n , {\n 8 , 0 }\n , {\n 4 , 4 }\n , {\n 0 , 8 }\n , {\n - 4 , 4 }\n , {\n - 8 , 0 }\n }\n , {\n {\n - 8 , - 8 }\n , {\n 0 , - 16 }\n , {\n 8 , - 8 }\n , {\n 16 , 0 }\n , {\n 8 , 8 }\n , {\n 0 , 16 }\n , {\n - 8 , 8 }\n , {\n - 16 , 0 }\n }\n , {\n {\n - 16 , - 16 }\n , {\n 0 , - 32 }\n , {\n 16 , - 16 }\n , {\n 32 , 0 }\n , {\n 16 , 16 }\n , {\n 0 , 32 }\n , {\n - 16 , 16 }\n , {\n - 32 , 0 }\n }\n , {\n {\n - 32 , - 32 }\n , {\n 0 , - 64 }\n , {\n 32 , - 32 }\n , {\n 64 , 0 }\n , {\n 32 , 32 }\n , {\n 0 , 64 }\n , {\n - 32 , 32 }\n , {\n - 64 , 0 }\n }\n , {\n {\n - 64 , - 64 }\n , {\n 0 , - 128 }\n , {\n 64 , - 64 }\n , {\n 128 , 0 }\n , {\n 64 , 64 }\n , {\n 0 , 128 }\n , {\n - 64 , 64 }\n , {\n - 128 , 0 }\n }\n , {\n {\n - 128 , - 128 }\n , {\n 0 , - 256 }\n , {\n 128 , - 128 }\n , {\n 256 , 0 }\n , {\n 128 , 128 }\n , {\n 0 , 256 }\n , {\n - 128 , 128 }\n , {\n - 256 , 0 }\n }\n , {\n {\n - 256 , - 256 }\n , {\n 0 , - 512 }\n , {\n 256 , - 256 }\n , {\n 512 , 0 }\n , {\n 256 , 256 }\n , {\n 0 , 512 }\n , {\n - 256 , 256 }\n , {\n - 512 , 0 }\n }\n , {\n {\n - 512 , - 512 }\n , {\n 0 , - 1024 }\n , {\n 512 , - 512 }\n , {\n 1024 , 0 }\n , {\n 512 , 512 }\n , {\n 0 , 1024 }\n , {\n - 512 , 512 }\n , {\n - 1024 , 0 }\n }\n , }\n ;\n return vp9_pattern_search_sad ( x , ref_mv , search_param , sad_per_bit , do_init_search , sad_list , vfp , use_mvcost , center_mv , best_mv , bigdia_num_candidates , bigdia_candidates ) ;\n }", "hash": 9160937366035817353, "project": "chrome", "size": 199, "target": 0, "idx": 17783}
{"code": "void vp8_sixtap_predict16x16_neon ( unsigned char * src_ptr , int src_pixels_per_line , int xoffset , int yoffset , unsigned char * dst_ptr , int dst_pitch ) {\n unsigned char * src , * src_tmp , * dst , * tmpp ;\n unsigned char tmp [ 336 ] ;\n int i , j ;\n uint8x8_t d0u8 , d1u8 , d2u8 , d3u8 , d4u8 , d5u8 , d6u8 , d7u8 , d8u8 , d9u8 ;\n uint8x8_t d10u8 , d11u8 , d12u8 , d13u8 , d14u8 , d15u8 , d18u8 , d19u8 ;\n uint8x8_t d20u8 , d21u8 , d22u8 , d23u8 , d24u8 , d25u8 , d26u8 , d27u8 ;\n uint8x8_t d28u8 , d29u8 , d30u8 , d31u8 ;\n int8x8_t dtmps8 , d0s8 , d1s8 , d2s8 , d3s8 , d4s8 , d5s8 ;\n uint8x16_t q3u8 , q4u8 ;\n uint16x8_t q3u16 , q4u16 , q5u16 , q6u16 , q7u16 , q8u16 , q9u16 , q10u16 ;\n uint16x8_t q11u16 , q12u16 , q13u16 , q15u16 ;\n int16x8_t q3s16 , q4s16 , q5s16 , q6s16 , q7s16 , q8s16 , q9s16 , q10s16 ;\n int16x8_t q11s16 , q12s16 , q13s16 , q15s16 ;\n if ( xoffset == 0 ) {\n dtmps8 = vld1_s8 ( vp8_sub_pel_filters [ yoffset ] ) ;\n d0s8 = vdup_lane_s8 ( dtmps8 , 0 ) ;\n d1s8 = vdup_lane_s8 ( dtmps8 , 1 ) ;\n d2s8 = vdup_lane_s8 ( dtmps8 , 2 ) ;\n d3s8 = vdup_lane_s8 ( dtmps8 , 3 ) ;\n d4s8 = vdup_lane_s8 ( dtmps8 , 4 ) ;\n d5s8 = vdup_lane_s8 ( dtmps8 , 5 ) ;\n d0u8 = vreinterpret_u8_s8 ( vabs_s8 ( d0s8 ) ) ;\n d1u8 = vreinterpret_u8_s8 ( vabs_s8 ( d1s8 ) ) ;\n d2u8 = vreinterpret_u8_s8 ( vabs_s8 ( d2s8 ) ) ;\n d3u8 = vreinterpret_u8_s8 ( vabs_s8 ( d3s8 ) ) ;\n d4u8 = vreinterpret_u8_s8 ( vabs_s8 ( d4s8 ) ) ;\n d5u8 = vreinterpret_u8_s8 ( vabs_s8 ( d5s8 ) ) ;\n src_tmp = src_ptr - src_pixels_per_line * 2 ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n src = src_tmp + i * 8 ;\n dst = dst_ptr + i * 8 ;\n d18u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d19u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d20u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d21u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d22u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n d23u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d24u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d25u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n d26u8 = vld1_u8 ( src ) ;\n src += src_pixels_per_line ;\n q3u16 = vmull_u8 ( d18u8 , d0u8 ) ;\n q4u16 = vmull_u8 ( d19u8 , d0u8 ) ;\n q5u16 = vmull_u8 ( d20u8 , d0u8 ) ;\n q6u16 = vmull_u8 ( d21u8 , d0u8 ) ;\n q3u16 = vmlsl_u8 ( q3u16 , d19u8 , d1u8 ) ;\n q4u16 = vmlsl_u8 ( q4u16 , d20u8 , d1u8 ) ;\n q5u16 = vmlsl_u8 ( q5u16 , d21u8 , d1u8 ) ;\n q6u16 = vmlsl_u8 ( q6u16 , d22u8 , d1u8 ) ;\n q3u16 = vmlsl_u8 ( q3u16 , d22u8 , d4u8 ) ;\n q4u16 = vmlsl_u8 ( q4u16 , d23u8 , d4u8 ) ;\n q5u16 = vmlsl_u8 ( q5u16 , d24u8 , d4u8 ) ;\n q6u16 = vmlsl_u8 ( q6u16 , d25u8 , d4u8 ) ;\n q3u16 = vmlal_u8 ( q3u16 , d20u8 , d2u8 ) ;\n q4u16 = vmlal_u8 ( q4u16 , d21u8 , d2u8 ) ;\n q5u16 = vmlal_u8 ( q5u16 , d22u8 , d2u8 ) ;\n q6u16 = vmlal_u8 ( q6u16 , d23u8 , d2u8 ) ;\n q3u16 = vmlal_u8 ( q3u16 , d23u8 , d5u8 ) ;\n q4u16 = vmlal_u8 ( q4u16 , d24u8 , d5u8 ) ;\n q5u16 = vmlal_u8 ( q5u16 , d25u8 , d5u8 ) ;\n q6u16 = vmlal_u8 ( q6u16 , d26u8 , d5u8 ) ;\n q7u16 = vmull_u8 ( d21u8 , d3u8 ) ;\n q8u16 = vmull_u8 ( d22u8 , d3u8 ) ;\n q9u16 = vmull_u8 ( d23u8 , d3u8 ) ;\n q10u16 = vmull_u8 ( d24u8 , d3u8 ) ;\n q3s16 = vreinterpretq_s16_u16 ( q3u16 ) ;\n q4s16 = vreinterpretq_s16_u16 ( q4u16 ) ;\n q5s16 = vreinterpretq_s16_u16 ( q5u16 ) ;\n q6s16 = vreinterpretq_s16_u16 ( q6u16 ) ;\n q7s16 = vreinterpretq_s16_u16 ( q7u16 ) ;\n q8s16 = vreinterpretq_s16_u16 ( q8u16 ) ;\n q9s16 = vreinterpretq_s16_u16 ( q9u16 ) ;\n q10s16 = vreinterpretq_s16_u16 ( q10u16 ) ;\n q7s16 = vqaddq_s16 ( q7s16 , q3s16 ) ;\n q8s16 = vqaddq_s16 ( q8s16 , q4s16 ) ;\n q9s16 = vqaddq_s16 ( q9s16 , q5s16 ) ;\n q10s16 = vqaddq_s16 ( q10s16 , q6s16 ) ;\n d6u8 = vqrshrun_n_s16 ( q7s16 , 7 ) ;\n d7u8 = vqrshrun_n_s16 ( q8s16 , 7 ) ;\n d8u8 = vqrshrun_n_s16 ( q9s16 , 7 ) ;\n d9u8 = vqrshrun_n_s16 ( q10s16 , 7 ) ;\n d18u8 = d22u8 ;\n d19u8 = d23u8 ;\n d20u8 = d24u8 ;\n d21u8 = d25u8 ;\n d22u8 = d26u8 ;\n vst1_u8 ( dst , d6u8 ) ;\n dst += dst_pitch ;\n vst1_u8 ( dst , d7u8 ) ;\n dst += dst_pitch ;\n vst1_u8 ( dst , d8u8 ) ;\n dst += dst_pitch ;\n vst1_u8 ( dst , d9u8 ) ;\n dst += dst_pitch ;\n }\n }\n return ;\n }\n dtmps8 = vld1_s8 ( vp8_sub_pel_filters [ xoffset ] ) ;\n d0s8 = vdup_lane_s8 ( dtmps8 , 0 ) ;\n d1s8 = vdup_lane_s8 ( dtmps8 , 1 ) ;\n d2s8 = vdup_lane_s8 ( dtmps8 , 2 ) ;\n d3s8 = vdup_lane_s8 ( dtmps8 , 3 ) ;\n d4s8 = vdup_lane_s8 ( dtmps8 , 4 ) ;\n d5s8 = vdup_lane_s8 ( dtmps8 , 5 ) ;\n d0u8 = vreinterpret_u8_s8 ( vabs_s8 ( d0s8 ) ) ;\n d1u8 = vreinterpret_u8_s8 ( vabs_s8 ( d1s8 ) ) ;\n d2u8 = vreinterpret_u8_s8 ( vabs_s8 ( d2s8 ) ) ;\n d3u8 = vreinterpret_u8_s8 ( vabs_s8 ( d3s8 ) ) ;\n d4u8 = vreinterpret_u8_s8 ( vabs_s8 ( d4s8 ) ) ;\n d5u8 = vreinterpret_u8_s8 ( vabs_s8 ( d5s8 ) ) ;\n if ( yoffset == 0 ) {\n src = src_ptr - 2 ;\n dst = dst_ptr ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n d6u8 = vld1_u8 ( src ) ;\n d7u8 = vld1_u8 ( src + 8 ) ;\n d8u8 = vld1_u8 ( src + 16 ) ;\n src += src_pixels_per_line ;\n d9u8 = vld1_u8 ( src ) ;\n d10u8 = vld1_u8 ( src + 8 ) ;\n d11u8 = vld1_u8 ( src + 16 ) ;\n src += src_pixels_per_line ;\n __builtin_prefetch ( src ) ;\n __builtin_prefetch ( src + src_pixels_per_line ) ;\n q6u16 = vmull_u8 ( d6u8 , d0u8 ) ;\n q7u16 = vmull_u8 ( d7u8 , d0u8 ) ;\n q8u16 = vmull_u8 ( d9u8 , d0u8 ) ;\n q9u16 = vmull_u8 ( d10u8 , d0u8 ) ;\n d20u8 = vext_u8 ( d6u8 , d7u8 , 1 ) ;\n d21u8 = vext_u8 ( d9u8 , d10u8 , 1 ) ;\n d22u8 = vext_u8 ( d7u8 , d8u8 , 1 ) ;\n d23u8 = vext_u8 ( d10u8 , d11u8 , 1 ) ;\n d24u8 = vext_u8 ( d6u8 , d7u8 , 4 ) ;\n d25u8 = vext_u8 ( d9u8 , d10u8 , 4 ) ;\n d26u8 = vext_u8 ( d7u8 , d8u8 , 4 ) ;\n d27u8 = vext_u8 ( d10u8 , d11u8 , 4 ) ;\n d28u8 = vext_u8 ( d6u8 , d7u8 , 5 ) ;\n d29u8 = vext_u8 ( d9u8 , d10u8 , 5 ) ;\n q6u16 = vmlsl_u8 ( q6u16 , d20u8 , d1u8 ) ;\n q8u16 = vmlsl_u8 ( q8u16 , d21u8 , d1u8 ) ;\n q7u16 = vmlsl_u8 ( q7u16 , d22u8 , d1u8 ) ;\n q9u16 = vmlsl_u8 ( q9u16 , d23u8 , d1u8 ) ;\n q6u16 = vmlsl_u8 ( q6u16 , d24u8 , d4u8 ) ;\n q8u16 = vmlsl_u8 ( q8u16 , d25u8 , d4u8 ) ;\n q7u16 = vmlsl_u8 ( q7u16 , d26u8 , d4u8 ) ;\n q9u16 = vmlsl_u8 ( q9u16 , d27u8 , d4u8 ) ;\n q6u16 = vmlal_u8 ( q6u16 , d28u8 , d5u8 ) ;\n q8u16 = vmlal_u8 ( q8u16 , d29u8 , d5u8 ) ;\n d20u8 = vext_u8 ( d7u8 , d8u8 , 5 ) ;\n d21u8 = vext_u8 ( d10u8 , d11u8 , 5 ) ;\n d22u8 = vext_u8 ( d6u8 , d7u8 , 2 ) ;\n d23u8 = vext_u8 ( d9u8 , d10u8 , 2 ) ;\n d24u8 = vext_u8 ( d7u8 , d8u8 , 2 ) ;\n d25u8 = vext_u8 ( d10u8 , d11u8 , 2 ) ;\n d26u8 = vext_u8 ( d6u8 , d7u8 , 3 ) ;\n d27u8 = vext_u8 ( d9u8 , d10u8 , 3 ) ;\n d28u8 = vext_u8 ( d7u8 , d8u8 , 3 ) ;\n d29u8 = vext_u8 ( d10u8 , d11u8 , 3 ) ;\n q7u16 = vmlal_u8 ( q7u16 , d20u8 , d5u8 ) ;\n q9u16 = vmlal_u8 ( q9u16 , d21u8 , d5u8 ) ;\n q6u16 = vmlal_u8 ( q6u16 , d22u8 , d2u8 ) ;\n q8u16 = vmlal_u8 ( q8u16 , d23u8 , d2u8 ) ;\n q7u16 = vmlal_u8 ( q7u16 , d24u8 , d2u8 ) ;\n q9u16 = vmlal_u8 ( q9u16 , d25u8 , d2u8 ) ;\n q10u16 = vmull_u8 ( d26u8 , d3u8 ) ;\n q11u16 = vmull_u8 ( d27u8 , d3u8 ) ;\n q12u16 = vmull_u8 ( d28u8 , d3u8 ) ;\n q15u16 = vmull_u8 ( d29u8 , d3u8 ) ;\n q6s16 = vreinterpretq_s16_u16 ( q6u16 ) ;\n q7s16 = vreinterpretq_s16_u16 ( q7u16 ) ;\n q8s16 = vreinterpretq_s16_u16 ( q8u16 ) ;\n q9s16 = vreinterpretq_s16_u16 ( q9u16 ) ;\n q10s16 = vreinterpretq_s16_u16 ( q10u16 ) ;\n q11s16 = vreinterpretq_s16_u16 ( q11u16 ) ;\n q12s16 = vreinterpretq_s16_u16 ( q12u16 ) ;\n q15s16 = vreinterpretq_s16_u16 ( q15u16 ) ;\n q6s16 = vqaddq_s16 ( q6s16 , q10s16 ) ;\n q8s16 = vqaddq_s16 ( q8s16 , q11s16 ) ;\n q7s16 = vqaddq_s16 ( q7s16 , q12s16 ) ;\n q9s16 = vqaddq_s16 ( q9s16 , q15s16 ) ;\n d6u8 = vqrshrun_n_s16 ( q6s16 , 7 ) ;\n d7u8 = vqrshrun_n_s16 ( q7s16 , 7 ) ;\n d8u8 = vqrshrun_n_s16 ( q8s16 , 7 ) ;\n d9u8 = vqrshrun_n_s16 ( q9s16 , 7 ) ;\n q3u8 = vcombine_u8 ( d6u8 , d7u8 ) ;\n q4u8 = vcombine_u8 ( d8u8 , d9u8 ) ;\n vst1q_u8 ( dst , q3u8 ) ;\n dst += dst_pitch ;\n vst1q_u8 ( dst , q4u8 ) ;\n dst += dst_pitch ;\n }\n return ;\n }\n src = src_ptr - 2 - src_pixels_per_line * 2 ;\n tmpp = tmp ;\n for ( i = 0 ;\n i < 7 ;\n i ++ ) {\n d6u8 = vld1_u8 ( src ) ;\n d7u8 = vld1_u8 ( src + 8 ) ;\n d8u8 = vld1_u8 ( src + 16 ) ;\n src += src_pixels_per_line ;\n d9u8 = vld1_u8 ( src ) ;\n d10u8 = vld1_u8 ( src + 8 ) ;\n d11u8 = vld1_u8 ( src + 16 ) ;\n src += src_pixels_per_line ;\n d12u8 = vld1_u8 ( src ) ;\n d13u8 = vld1_u8 ( src + 8 ) ;\n d14u8 = vld1_u8 ( src + 16 ) ;\n src += src_pixels_per_line ;\n __builtin_prefetch ( src ) ;\n __builtin_prefetch ( src + src_pixels_per_line ) ;\n __builtin_prefetch ( src + src_pixels_per_line * 2 ) ;\n q8u16 = vmull_u8 ( d6u8 , d0u8 ) ;\n q9u16 = vmull_u8 ( d7u8 , d0u8 ) ;\n q10u16 = vmull_u8 ( d9u8 , d0u8 ) ;\n q11u16 = vmull_u8 ( d10u8 , d0u8 ) ;\n q12u16 = vmull_u8 ( d12u8 , d0u8 ) ;\n q13u16 = vmull_u8 ( d13u8 , d0u8 ) ;\n d28u8 = vext_u8 ( d6u8 , d7u8 , 1 ) ;\n d29u8 = vext_u8 ( d9u8 , d10u8 , 1 ) ;\n d30u8 = vext_u8 ( d12u8 , d13u8 , 1 ) ;\n q8u16 = vmlsl_u8 ( q8u16 , d28u8 , d1u8 ) ;\n q10u16 = vmlsl_u8 ( q10u16 , d29u8 , d1u8 ) ;\n q12u16 = vmlsl_u8 ( q12u16 , d30u8 , d1u8 ) ;\n d28u8 = vext_u8 ( d7u8 , d8u8 , 1 ) ;\n d29u8 = vext_u8 ( d10u8 , d11u8 , 1 ) ;\n d30u8 = vext_u8 ( d13u8 , d14u8 , 1 ) ;\n q9u16 = vmlsl_u8 ( q9u16 , d28u8 , d1u8 ) ;\n q11u16 = vmlsl_u8 ( q11u16 , d29u8 , d1u8 ) ;\n q13u16 = vmlsl_u8 ( q13u16 , d30u8 , d1u8 ) ;\n d28u8 = vext_u8 ( d6u8 , d7u8 , 4 ) ;\n d29u8 = vext_u8 ( d9u8 , d10u8 , 4 ) ;\n d30u8 = vext_u8 ( d12u8 , d13u8 , 4 ) ;\n q8u16 = vmlsl_u8 ( q8u16 , d28u8 , d4u8 ) ;\n q10u16 = vmlsl_u8 ( q10u16 , d29u8 , d4u8 ) ;\n q12u16 = vmlsl_u8 ( q12u16 , d30u8 , d4u8 ) ;\n d28u8 = vext_u8 ( d7u8 , d8u8 , 4 ) ;\n d29u8 = vext_u8 ( d10u8 , d11u8 , 4 ) ;\n d30u8 = vext_u8 ( d13u8 , d14u8 , 4 ) ;\n q9u16 = vmlsl_u8 ( q9u16 , d28u8 , d4u8 ) ;\n q11u16 = vmlsl_u8 ( q11u16 , d29u8 , d4u8 ) ;\n q13u16 = vmlsl_u8 ( q13u16 , d30u8 , d4u8 ) ;\n d28u8 = vext_u8 ( d6u8 , d7u8 , 5 ) ;\n d29u8 = vext_u8 ( d9u8 , d10u8 , 5 ) ;\n d30u8 = vext_u8 ( d12u8 , d13u8 , 5 ) ;\n q8u16 = vmlal_u8 ( q8u16 , d28u8 , d5u8 ) ;\n q10u16 = vmlal_u8 ( q10u16 , d29u8 , d5u8 ) ;\n q12u16 = vmlal_u8 ( q12u16 , d30u8 , d5u8 ) ;\n d28u8 = vext_u8 ( d7u8 , d8u8 , 5 ) ;\n d29u8 = vext_u8 ( d10u8 , d11u8 , 5 ) ;\n d30u8 = vext_u8 ( d13u8 , d14u8 , 5 ) ;\n q9u16 = vmlal_u8 ( q9u16 , d28u8 , d5u8 ) ;\n q11u16 = vmlal_u8 ( q11u16 , d29u8 , d5u8 ) ;\n q13u16 = vmlal_u8 ( q13u16 , d30u8 , d5u8 ) ;\n d28u8 = vext_u8 ( d6u8 , d7u8 , 2 ) ;\n d29u8 = vext_u8 ( d9u8 , d10u8 , 2 ) ;\n d30u8 = vext_u8 ( d12u8 , d13u8 , 2 ) ;\n q8u16 = vmlal_u8 ( q8u16 , d28u8 , d2u8 ) ;\n q10u16 = vmlal_u8 ( q10u16 , d29u8 , d2u8 ) ;\n q12u16 = vmlal_u8 ( q12u16 , d30u8 , d2u8 ) ;\n d28u8 = vext_u8 ( d7u8 , d8u8 , 2 ) ;\n d29u8 = vext_u8 ( d10u8 , d11u8 , 2 ) ;\n d30u8 = vext_u8 ( d13u8 , d14u8 , 2 ) ;\n q9u16 = vmlal_u8 ( q9u16 , d28u8 , d2u8 ) ;\n q11u16 = vmlal_u8 ( q11u16 , d29u8 , d2u8 ) ;\n q13u16 = vmlal_u8 ( q13u16 , d30u8 , d2u8 ) ;\n d28u8 = vext_u8 ( d6u8 , d7u8 , 3 ) ;\n d29u8 = vext_u8 ( d9u8 , d10u8 , 3 ) ;\n d30u8 = vext_u8 ( d12u8 , d13u8 , 3 ) ;\n d15u8 = vext_u8 ( d7u8 , d8u8 , 3 ) ;\n d31u8 = vext_u8 ( d10u8 , d11u8 , 3 ) ;\n d6u8 = vext_u8 ( d13u8 , d14u8 , 3 ) ;\n q4u16 = vmull_u8 ( d28u8 , d3u8 ) ;\n q5u16 = vmull_u8 ( d29u8 , d3u8 ) ;\n q6u16 = vmull_u8 ( d30u8 , d3u8 ) ;\n q4s16 = vreinterpretq_s16_u16 ( q4u16 ) ;\n q5s16 = vreinterpretq_s16_u16 ( q5u16 ) ;\n q6s16 = vreinterpretq_s16_u16 ( q6u16 ) ;\n q8s16 = vreinterpretq_s16_u16 ( q8u16 ) ;\n q10s16 = vreinterpretq_s16_u16 ( q10u16 ) ;\n q12s16 = vreinterpretq_s16_u16 ( q12u16 ) ;\n q8s16 = vqaddq_s16 ( q8s16 , q4s16 ) ;\n q10s16 = vqaddq_s16 ( q10s16 , q5s16 ) ;\n q12s16 = vqaddq_s16 ( q12s16 , q6s16 ) ;\n q6u16 = vmull_u8 ( d15u8 , d3u8 ) ;\n q7u16 = vmull_u8 ( d31u8 , d3u8 ) ;\n q3u16 = vmull_u8 ( d6u8 , d3u8 ) ;\n q3s16 = vreinterpretq_s16_u16 ( q3u16 ) ;\n q6s16 = vreinterpretq_s16_u16 ( q6u16 ) ;\n q7s16 = vreinterpretq_s16_u16 ( q7u16 ) ;\n q9s16 = vreinterpretq_s16_u16 ( q9u16 ) ;\n q11s16 = vreinterpretq_s16_u16 ( q11u16 ) ;\n q13s16 = vreinterpretq_s16_u16 ( q13u16 ) ;\n q9s16 = vqaddq_s16 ( q9s16 , q6s16 ) ;\n q11s16 = vqaddq_s16 ( q11s16 , q7s16 ) ;\n q13s16 = vqaddq_s16 ( q13s16 , q3s16 ) ;\n d6u8 = vqrshrun_n_s16 ( q8s16 , 7 ) ;\n d7u8 = vqrshrun_n_s16 ( q9s16 , 7 ) ;\n d8u8 = vqrshrun_n_s16 ( q10s16 , 7 ) ;\n d9u8 = vqrshrun_n_s16 ( q11s16 , 7 ) ;\n d10u8 = vqrshrun_n_s16 ( q12s16 , 7 ) ;\n d11u8 = vqrshrun_n_s16 ( q13s16 , 7 ) ;\n vst1_u8 ( tmpp , d6u8 ) ;\n tmpp += 8 ;\n vst1_u8 ( tmpp , d7u8 ) ;\n tmpp += 8 ;\n vst1_u8 ( tmpp , d8u8 ) ;\n tmpp += 8 ;\n vst1_u8 ( tmpp , d9u8 ) ;\n tmpp += 8 ;\n vst1_u8 ( tmpp , d10u8 ) ;\n tmpp += 8 ;\n vst1_u8 ( tmpp , d11u8 ) ;\n tmpp += 8 ;\n }\n dtmps8 = vld1_s8 ( vp8_sub_pel_filters [ yoffset ] ) ;\n d0s8 = vdup_lane_s8 ( dtmps8 , 0 ) ;\n d1s8 = vdup_lane_s8 ( dtmps8 , 1 ) ;\n d2s8 = vdup_lane_s8 ( dtmps8 , 2 ) ;\n d3s8 = vdup_lane_s8 ( dtmps8 , 3 ) ;\n d4s8 = vdup_lane_s8 ( dtmps8 , 4 ) ;\n d5s8 = vdup_lane_s8 ( dtmps8 , 5 ) ;\n d0u8 = vreinterpret_u8_s8 ( vabs_s8 ( d0s8 ) ) ;\n d1u8 = vreinterpret_u8_s8 ( vabs_s8 ( d1s8 ) ) ;\n d2u8 = vreinterpret_u8_s8 ( vabs_s8 ( d2s8 ) ) ;\n d3u8 = vreinterpret_u8_s8 ( vabs_s8 ( d3s8 ) ) ;\n d4u8 = vreinterpret_u8_s8 ( vabs_s8 ( d4s8 ) ) ;\n d5u8 = vreinterpret_u8_s8 ( vabs_s8 ( d5s8 ) ) ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n dst = dst_ptr + 8 * i ;\n tmpp = tmp + 8 * i ;\n d18u8 = vld1_u8 ( tmpp ) ;\n tmpp += 16 ;\n d19u8 = vld1_u8 ( tmpp ) ;\n tmpp += 16 ;\n d20u8 = vld1_u8 ( tmpp ) ;\n tmpp += 16 ;\n d21u8 = vld1_u8 ( tmpp ) ;\n tmpp += 16 ;\n d22u8 = vld1_u8 ( tmpp ) ;\n tmpp += 16 ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n d23u8 = vld1_u8 ( tmpp ) ;\n tmpp += 16 ;\n d24u8 = vld1_u8 ( tmpp ) ;\n tmpp += 16 ;\n d25u8 = vld1_u8 ( tmpp ) ;\n tmpp += 16 ;\n d26u8 = vld1_u8 ( tmpp ) ;\n tmpp += 16 ;\n q3u16 = vmull_u8 ( d18u8 , d0u8 ) ;\n q4u16 = vmull_u8 ( d19u8 , d0u8 ) ;\n q5u16 = vmull_u8 ( d20u8 , d0u8 ) ;\n q6u16 = vmull_u8 ( d21u8 , d0u8 ) ;\n q3u16 = vmlsl_u8 ( q3u16 , d19u8 , d1u8 ) ;\n q4u16 = vmlsl_u8 ( q4u16 , d20u8 , d1u8 ) ;\n q5u16 = vmlsl_u8 ( q5u16 , d21u8 , d1u8 ) ;\n q6u16 = vmlsl_u8 ( q6u16 , d22u8 , d1u8 ) ;\n q3u16 = vmlsl_u8 ( q3u16 , d22u8 , d4u8 ) ;\n q4u16 = vmlsl_u8 ( q4u16 , d23u8 , d4u8 ) ;\n q5u16 = vmlsl_u8 ( q5u16 , d24u8 , d4u8 ) ;\n q6u16 = vmlsl_u8 ( q6u16 , d25u8 , d4u8 ) ;\n q3u16 = vmlal_u8 ( q3u16 , d20u8 , d2u8 ) ;\n q4u16 = vmlal_u8 ( q4u16 , d21u8 , d2u8 ) ;\n q5u16 = vmlal_u8 ( q5u16 , d22u8 , d2u8 ) ;\n q6u16 = vmlal_u8 ( q6u16 , d23u8 , d2u8 ) ;\n q3u16 = vmlal_u8 ( q3u16 , d23u8 , d5u8 ) ;\n q4u16 = vmlal_u8 ( q4u16 , d24u8 , d5u8 ) ;\n q5u16 = vmlal_u8 ( q5u16 , d25u8 , d5u8 ) ;\n q6u16 = vmlal_u8 ( q6u16 , d26u8 , d5u8 ) ;\n q7u16 = vmull_u8 ( d21u8 , d3u8 ) ;\n q8u16 = vmull_u8 ( d22u8 , d3u8 ) ;\n q9u16 = vmull_u8 ( d23u8 , d3u8 ) ;\n q10u16 = vmull_u8 ( d24u8 , d3u8 ) ;\n q3s16 = vreinterpretq_s16_u16 ( q3u16 ) ;\n q4s16 = vreinterpretq_s16_u16 ( q4u16 ) ;\n q5s16 = vreinterpretq_s16_u16 ( q5u16 ) ;\n q6s16 = vreinterpretq_s16_u16 ( q6u16 ) ;\n q7s16 = vreinterpretq_s16_u16 ( q7u16 ) ;\n q8s16 = vreinterpretq_s16_u16 ( q8u16 ) ;\n q9s16 = vreinterpretq_s16_u16 ( q9u16 ) ;\n q10s16 = vreinterpretq_s16_u16 ( q10u16 ) ;\n q7s16 = vqaddq_s16 ( q7s16 , q3s16 ) ;\n q8s16 = vqaddq_s16 ( q8s16 , q4s16 ) ;\n q9s16 = vqaddq_s16 ( q9s16 , q5s16 ) ;\n q10s16 = vqaddq_s16 ( q10s16 , q6s16 ) ;\n d6u8 = vqrshrun_n_s16 ( q7s16 , 7 ) ;\n d7u8 = vqrshrun_n_s16 ( q8s16 , 7 ) ;\n d8u8 = vqrshrun_n_s16 ( q9s16 , 7 ) ;\n d9u8 = vqrshrun_n_s16 ( q10s16 , 7 ) ;\n d18u8 = d22u8 ;\n d19u8 = d23u8 ;\n d20u8 = d24u8 ;\n d21u8 = d25u8 ;\n d22u8 = d26u8 ;\n vst1_u8 ( dst , d6u8 ) ;\n dst += dst_pitch ;\n vst1_u8 ( dst , d7u8 ) ;\n dst += dst_pitch ;\n vst1_u8 ( dst , d8u8 ) ;\n dst += dst_pitch ;\n vst1_u8 ( dst , d9u8 ) ;\n dst += dst_pitch ;\n }\n }\n return ;\n }", "hash": 6353572510321903594, "project": "chrome", "size": 429, "target": 0, "idx": 17823}
{"code": "void vp9_update_zbin_extra ( VP9_COMP * cpi , MACROBLOCK * x ) {\n const int qindex = x -> q_index ;\n const int y_zbin_extra = ( cpi -> common . y_dequant [ qindex ] [ 1 ] * cpi -> zbin_mode_boost ) >> 7 ;\n const int uv_zbin_extra = ( cpi -> common . uv_dequant [ qindex ] [ 1 ] * cpi -> zbin_mode_boost ) >> 7 ;\n x -> plane [ 0 ] . zbin_extra = ( int16_t ) y_zbin_extra ;\n x -> plane [ 1 ] . zbin_extra = ( int16_t ) uv_zbin_extra ;\n x -> plane [ 2 ] . zbin_extra = ( int16_t ) uv_zbin_extra ;\n }", "hash": 4423867112908498696, "project": "chrome", "size": 8, "target": 0, "idx": 17828}
{"code": "void vp9_init_quantizer ( VP9_COMP * cpi ) {\n VP9_COMMON * const cm = & cpi -> common ;\n QUANTS * const quants = & cpi -> quants ;\n int i , q , quant ;\n for ( q = 0 ;\n q < QINDEX_RANGE ;\n q ++ ) {\n const int qzbin_factor = get_qzbin_factor ( q , cm -> bit_depth ) ;\n const int qrounding_factor = q == 0 ? 64 : 48 ;\n for ( i = 0 ;\n i < 2 ;\n ++ i ) {\n int qrounding_factor_fp = i == 0 ? 48 : 42 ;\n if ( q == 0 ) qrounding_factor_fp = 64 ;\n quant = i == 0 ? vp9_dc_quant ( q , cm -> y_dc_delta_q , cm -> bit_depth ) : vp9_ac_quant ( q , 0 , cm -> bit_depth ) ;\n invert_quant ( & quants -> y_quant [ q ] [ i ] , & quants -> y_quant_shift [ q ] [ i ] , quant ) ;\n quants -> y_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ;\n quants -> y_round_fp [ q ] [ i ] = ( qrounding_factor_fp * quant ) >> 7 ;\n quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ;\n quants -> y_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ;\n cm -> y_dequant [ q ] [ i ] = quant ;\n quant = i == 0 ? vp9_dc_quant ( q , cm -> uv_dc_delta_q , cm -> bit_depth ) : vp9_ac_quant ( q , cm -> uv_ac_delta_q , cm -> bit_depth ) ;\n invert_quant ( & quants -> uv_quant [ q ] [ i ] , & quants -> uv_quant_shift [ q ] [ i ] , quant ) ;\n quants -> uv_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ;\n quants -> uv_round_fp [ q ] [ i ] = ( qrounding_factor_fp * quant ) >> 7 ;\n quants -> uv_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ;\n quants -> uv_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ;\n cm -> uv_dequant [ q ] [ i ] = quant ;\n }\n for ( i = 2 ;\n i < 8 ;\n i ++ ) {\n quants -> y_quant [ q ] [ i ] = quants -> y_quant [ q ] [ 1 ] ;\n quants -> y_quant_fp [ q ] [ i ] = quants -> y_quant_fp [ q ] [ 1 ] ;\n quants -> y_round_fp [ q ] [ i ] = quants -> y_round_fp [ q ] [ 1 ] ;\n quants -> y_quant_shift [ q ] [ i ] = quants -> y_quant_shift [ q ] [ 1 ] ;\n quants -> y_zbin [ q ] [ i ] = quants -> y_zbin [ q ] [ 1 ] ;\n quants -> y_round [ q ] [ i ] = quants -> y_round [ q ] [ 1 ] ;\n cm -> y_dequant [ q ] [ i ] = cm -> y_dequant [ q ] [ 1 ] ;\n quants -> uv_quant [ q ] [ i ] = quants -> uv_quant [ q ] [ 1 ] ;\n quants -> uv_quant_fp [ q ] [ i ] = quants -> uv_quant_fp [ q ] [ 1 ] ;\n quants -> uv_round_fp [ q ] [ i ] = quants -> uv_round_fp [ q ] [ 1 ] ;\n quants -> uv_quant_shift [ q ] [ i ] = quants -> uv_quant_shift [ q ] [ 1 ] ;\n quants -> uv_zbin [ q ] [ i ] = quants -> uv_zbin [ q ] [ 1 ] ;\n quants -> uv_round [ q ] [ i ] = quants -> uv_round [ q ] [ 1 ] ;\n cm -> uv_dequant [ q ] [ i ] = cm -> uv_dequant [ q ] [ 1 ] ;\n }\n }\n }", "hash": 4423867112908498696, "project": "chrome", "size": 49, "target": 0, "idx": 17834}
{"code": "static vpx_codec_err_t encoder_set_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg ) {\n vpx_codec_err_t res ;\n if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h ) ERROR ( \"Cannot change width or height after initialization\" ) ;\n if ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ERROR ( \"Cannot increase lag_in_frames\" ) ;\n res = validate_config ( ctx , cfg , & ctx -> extra_cfg ) ;\n if ( res == VPX_CODEC_OK ) {\n ctx -> cfg = * cfg ;\n set_encoder_config ( & ctx -> oxcf , & ctx -> cfg , & ctx -> extra_cfg ) ;\n vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ;\n }\n return res ;\n }", "hash": -2723830976796502611, "project": "chrome", "size": 12, "target": 0, "idx": 17840}
{"code": "static vpx_codec_err_t ctrl_get_quantizer ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n int * const arg = va_arg ( args , int * ) ;\n if ( arg == NULL ) return VPX_CODEC_INVALID_PARAM ;\n * arg = vp9_get_quantizer ( ctx -> cpi ) ;\n return VPX_CODEC_OK ;\n }", "hash": -2723830976796502611, "project": "chrome", "size": 6, "target": 0, "idx": 17846}
{"code": "static vpx_image_t * encoder_get_preview ( vpx_codec_alg_priv_t * ctx ) {\n YV12_BUFFER_CONFIG sd ;\n vp9_ppflags_t flags ;\n vp9_zero ( flags ) ;\n if ( ctx -> preview_ppcfg . post_proc_flag ) {\n flags . post_proc_flag = ctx -> preview_ppcfg . post_proc_flag ;\n flags . deblocking_level = ctx -> preview_ppcfg . deblocking_level ;\n flags . noise_level = ctx -> preview_ppcfg . noise_level ;\n }\n if ( vp9_get_preview_raw_frame ( ctx -> cpi , & sd , & flags ) == 0 ) {\n yuvconfig2image ( & ctx -> preview_img , & sd , NULL ) ;\n return & ctx -> preview_img ;\n }\n else {\n return NULL ;\n }\n }", "hash": -2723830976796502611, "project": "chrome", "size": 17, "target": 0, "idx": 17862}
{"code": "static vpx_codec_err_t update_error_state ( vpx_codec_alg_priv_t * ctx , const struct vpx_internal_error_info * error ) {\n const vpx_codec_err_t res = error -> error_code ;\n if ( res != VPX_CODEC_OK ) ctx -> base . err_detail = error -> has_detail ? error -> detail : NULL ;\n return res ;\n }", "hash": -2723830976796502611, "project": "chrome", "size": 5, "target": 0, "idx": 17866}
{"code": "static vpx_codec_err_t ctrl_set_lossless ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n struct vp9_extracfg extra_cfg = ctx -> extra_cfg ;\n extra_cfg . lossless = CAST ( VP9E_SET_LOSSLESS , args ) ;\n return update_extra_cfg ( ctx , & extra_cfg ) ;\n }", "hash": -2723830976796502611, "project": "chrome", "size": 5, "target": 0, "idx": 17870}
{"code": "static const vpx_codec_cx_pkt_t * encoder_get_cxdata ( vpx_codec_alg_priv_t * ctx , vpx_codec_iter_t * iter ) {\n return vpx_codec_pkt_list_get ( & ctx -> pkt_list . head , iter ) ;\n }", "hash": -2723830976796502611, "project": "chrome", "size": 3, "target": 0, "idx": 17871}
{"code": "static vpx_codec_err_t ctrl_set_previewpp ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n # if CONFIG_VP9_POSTPROC vp8_postproc_cfg_t * config = va_arg ( args , vp8_postproc_cfg_t * ) ;\n if ( config != NULL ) {\n ctx -> preview_ppcfg = * config ;\n return VPX_CODEC_OK ;\n }\n else {\n return VPX_CODEC_INVALID_PARAM ;\n }\n # else ( void ) ctx ;\n ( void ) args ;\n return VPX_CODEC_INCAPABLE ;\n # endif }", "hash": -2723830976796502611, "project": "chrome", "size": 13, "target": 0, "idx": 17878}
{"code": "static vpx_codec_err_t ctrl_set_arnr_strength ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n struct vp9_extracfg extra_cfg = ctx -> extra_cfg ;\n extra_cfg . arnr_strength = CAST ( VP8E_SET_ARNR_STRENGTH , args ) ;\n return update_extra_cfg ( ctx , & extra_cfg ) ;\n }", "hash": -2723830976796502611, "project": "chrome", "size": 5, "target": 0, "idx": 17882}
{"code": "void vp9_xform_quant_fp ( MACROBLOCK * x , int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n const struct macroblock_plane * const p = & x -> plane [ plane ] ;\n const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;\n const scan_order * const scan_order = & vp9_default_scan_orders [ tx_size ] ;\n tran_low_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ;\n tran_low_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;\n tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;\n uint16_t * const eob = & p -> eobs [ block ] ;\n const int diff_stride = 4 * num_4x4_blocks_wide_lookup [ plane_bsize ] ;\n int i , j ;\n const int16_t * src_diff ;\n txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ;\n src_diff = & p -> src_diff [ 4 * ( j * diff_stride + i ) ] ;\n switch ( tx_size ) {\n case TX_32X32 : fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ;\n vp9_quantize_fp_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round_fp , p -> quant_fp , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , p -> zbin_extra , eob , scan_order -> scan , scan_order -> iscan ) ;\n break ;\n case TX_16X16 : vp9_fdct16x16 ( src_diff , coeff , diff_stride ) ;\n vp9_quantize_fp ( coeff , 256 , x -> skip_block , p -> zbin , p -> round_fp , p -> quant_fp , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , p -> zbin_extra , eob , scan_order -> scan , scan_order -> iscan ) ;\n break ;\n case TX_8X8 : vp9_fdct8x8 ( src_diff , coeff , diff_stride ) ;\n vp9_quantize_fp ( coeff , 64 , x -> skip_block , p -> zbin , p -> round_fp , p -> quant_fp , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , p -> zbin_extra , eob , scan_order -> scan , scan_order -> iscan ) ;\n break ;\n case TX_4X4 : x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ;\n vp9_quantize_fp ( coeff , 16 , x -> skip_block , p -> zbin , p -> round_fp , p -> quant_fp , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , p -> zbin_extra , eob , scan_order -> scan , scan_order -> iscan ) ;\n break ;\n default : assert ( 0 ) ;\n break ;\n }\n }", "hash": -8128341148043427861, "project": "chrome", "size": 31, "target": 0, "idx": 17891}
{"code": "static void encode_block_pass1 ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) {\n MACROBLOCK * const x = ( MACROBLOCK * ) arg ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n struct macroblock_plane * const p = & x -> plane [ plane ] ;\n struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;\n tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;\n int i , j ;\n uint8_t * dst ;\n txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ;\n dst = & pd -> dst . buf [ 4 * j * pd -> dst . stride + 4 * i ] ;\n vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;\n if ( p -> eobs [ block ] > 0 ) x -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;\n }", "hash": -8128341148043427861, "project": "chrome", "size": 13, "target": 0, "idx": 17892}
{"code": "void vp9_xform_quant_dc ( MACROBLOCK * x , int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n const struct macroblock_plane * const p = & x -> plane [ plane ] ;\n const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;\n tran_low_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ;\n tran_low_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;\n tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;\n uint16_t * const eob = & p -> eobs [ block ] ;\n const int diff_stride = 4 * num_4x4_blocks_wide_lookup [ plane_bsize ] ;\n int i , j ;\n const int16_t * src_diff ;\n txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ;\n src_diff = & p -> src_diff [ 4 * ( j * diff_stride + i ) ] ;\n switch ( tx_size ) {\n case TX_32X32 : vp9_fdct32x32_1 ( src_diff , coeff , diff_stride ) ;\n vp9_quantize_dc_32x32 ( coeff , x -> skip_block , p -> round , p -> quant_fp [ 0 ] , qcoeff , dqcoeff , pd -> dequant [ 0 ] , eob ) ;\n break ;\n case TX_16X16 : vp9_fdct16x16_1 ( src_diff , coeff , diff_stride ) ;\n vp9_quantize_dc ( coeff , x -> skip_block , p -> round , p -> quant_fp [ 0 ] , qcoeff , dqcoeff , pd -> dequant [ 0 ] , eob ) ;\n break ;\n case TX_8X8 : vp9_fdct8x8_1 ( src_diff , coeff , diff_stride ) ;\n vp9_quantize_dc ( coeff , x -> skip_block , p -> round , p -> quant_fp [ 0 ] , qcoeff , dqcoeff , pd -> dequant [ 0 ] , eob ) ;\n break ;\n case TX_4X4 : x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ;\n vp9_quantize_dc ( coeff , x -> skip_block , p -> round , p -> quant_fp [ 0 ] , qcoeff , dqcoeff , pd -> dequant [ 0 ] , eob ) ;\n break ;\n default : assert ( 0 ) ;\n break ;\n }\n }", "hash": -8128341148043427861, "project": "chrome", "size": 30, "target": 0, "idx": 17902}
{"code": "int file_is_raw ( struct VpxInputContext * input ) {\n uint8_t buf [ 32 ] ;\n int is_raw = 0 ;\n vpx_codec_stream_info_t si ;\n si . sz = sizeof ( si ) ;\n if ( fread ( buf , 1 , 32 , input -> file ) == 32 ) {\n int i ;\n if ( mem_get_le32 ( buf ) < 256 * 1024 * 1024 ) {\n for ( i = 0 ;\n i < get_vpx_decoder_count ( ) ;\n ++ i ) {\n const VpxInterface * const decoder = get_vpx_decoder_by_index ( i ) ;\n if ( ! vpx_codec_peek_stream_info ( decoder -> codec_interface ( ) , buf + 4 , 32 - 4 , & si ) ) {\n is_raw = 1 ;\n input -> fourcc = decoder -> fourcc ;\n input -> width = si . w ;\n input -> height = si . h ;\n input -> framerate . numerator = 30 ;\n input -> framerate . denominator = 1 ;\n break ;\n }\n }\n }\n }\n rewind ( input -> file ) ;\n return is_raw ;\n }", "hash": -2338718868165006846, "project": "chrome", "size": 27, "target": 0, "idx": 17919}
{"code": "static double calc_psnr ( double d ) {\n if ( d == 0 ) return 100 ;\n return - 10.0 * log ( d ) / log ( 10.0 ) ;\n }", "hash": 5400542917484463750, "project": "chrome", "size": 4, "target": 0, "idx": 17939}
{"code": "static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) {\n char * input_string ;\n char * option_name ;\n char * option_value ;\n char * input_ptr ;\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n vpx_codec_err_t res = VPX_CODEC_OK ;\n int i , alt_ref_enabled = 0 ;\n if ( options == NULL ) return VPX_CODEC_OK ;\n input_string = strdup ( options ) ;\n option_name = strtok_r ( input_string , \"=\" , & input_ptr ) ;\n while ( option_name != NULL ) {\n option_value = strtok_r ( NULL , \" \" , & input_ptr ) ;\n if ( option_value == NULL ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"option missing value: %s\\n\" , option_name ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n break ;\n }\n if ( strcmp ( \"spatial-layers\" , option_name ) == 0 ) {\n svc_ctx -> spatial_layers = atoi ( option_value ) ;\n }\n else if ( strcmp ( \"temporal-layers\" , option_name ) == 0 ) {\n svc_ctx -> temporal_layers = atoi ( option_value ) ;\n }\n else if ( strcmp ( \"scale-factors\" , option_name ) == 0 ) {\n res = parse_layer_options_from_string ( svc_ctx , SCALE_FACTOR , option_value , si -> svc_params . scaling_factor_num , si -> svc_params . scaling_factor_den ) ;\n if ( res != VPX_CODEC_OK ) break ;\n }\n else if ( strcmp ( \"max-quantizers\" , option_name ) == 0 ) {\n res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . max_quantizers , NULL ) ;\n if ( res != VPX_CODEC_OK ) break ;\n }\n else if ( strcmp ( \"min-quantizers\" , option_name ) == 0 ) {\n res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . min_quantizers , NULL ) ;\n if ( res != VPX_CODEC_OK ) break ;\n }\n else if ( strcmp ( \"auto-alt-refs\" , option_name ) == 0 ) {\n res = parse_layer_options_from_string ( svc_ctx , AUTO_ALT_REF , option_value , si -> enable_auto_alt_ref , NULL ) ;\n if ( res != VPX_CODEC_OK ) break ;\n }\n else if ( strcmp ( \"bitrates\" , option_name ) == 0 ) {\n res = parse_layer_options_from_string ( svc_ctx , BITRATE , option_value , si -> bitrates , NULL ) ;\n if ( res != VPX_CODEC_OK ) break ;\n }\n else if ( strcmp ( \"multi-frame-contexts\" , option_name ) == 0 ) {\n si -> use_multiple_frame_contexts = atoi ( option_value ) ;\n }\n else {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"invalid option: %s\\n\" , option_name ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n break ;\n }\n option_name = strtok_r ( NULL , \"=\" , & input_ptr ) ;\n }\n free ( input_string ) ;\n for ( i = 0 ;\n i < svc_ctx -> spatial_layers ;\n ++ i ) {\n if ( si -> svc_params . max_quantizers [ i ] > MAX_QUANTIZER || si -> svc_params . max_quantizers [ i ] < 0 || si -> svc_params . min_quantizers [ i ] > si -> svc_params . max_quantizers [ i ] || si -> svc_params . min_quantizers [ i ] < 0 ) res = VPX_CODEC_INVALID_PARAM ;\n }\n if ( si -> use_multiple_frame_contexts && ( svc_ctx -> spatial_layers > 3 || svc_ctx -> spatial_layers * svc_ctx -> temporal_layers > 4 ) ) res = VPX_CODEC_INVALID_PARAM ;\n for ( i = 0 ;\n i < svc_ctx -> spatial_layers ;\n ++ i ) alt_ref_enabled += si -> enable_auto_alt_ref [ i ] ;\n if ( alt_ref_enabled > REF_FRAMES - svc_ctx -> spatial_layers ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc: auto alt ref: Maxinum %d(REF_FRAMES - layers) layers could\" \"enabled auto alt reference frame, but % layers are enabled\\n\" , REF_FRAMES - svc_ctx -> spatial_layers , alt_ref_enabled ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n }\n return res ;\n }", "hash": 5400542917484463750, "project": "chrome", "size": 70, "target": 0, "idx": 17941}
{"code": "vpx_codec_err_t vpx_svc_init ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx , vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * enc_cfg ) {\n vpx_codec_err_t res ;\n int i ;\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || codec_ctx == NULL || iface == NULL || enc_cfg == NULL ) {\n return VPX_CODEC_INVALID_PARAM ;\n }\n if ( si == NULL ) return VPX_CODEC_MEM_ERROR ;\n si -> codec_ctx = codec_ctx ;\n si -> width = enc_cfg -> g_w ;\n si -> height = enc_cfg -> g_h ;\n if ( enc_cfg -> kf_max_dist < 2 ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"key frame distance too small: %d\\n\" , enc_cfg -> kf_max_dist ) ;\n return VPX_CODEC_INVALID_PARAM ;\n }\n si -> kf_dist = enc_cfg -> kf_max_dist ;\n if ( svc_ctx -> spatial_layers == 0 ) svc_ctx -> spatial_layers = VPX_SS_DEFAULT_LAYERS ;\n if ( svc_ctx -> spatial_layers < 1 || svc_ctx -> spatial_layers > VPX_SS_MAX_LAYERS ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"spatial layers: invalid value: %d\\n\" , svc_ctx -> spatial_layers ) ;\n return VPX_CODEC_INVALID_PARAM ;\n }\n for ( i = 0 ;\n i < VPX_SS_MAX_LAYERS ;\n ++ i ) {\n si -> svc_params . max_quantizers [ i ] = MAX_QUANTIZER ;\n si -> svc_params . min_quantizers [ i ] = 0 ;\n si -> svc_params . scaling_factor_num [ i ] = DEFAULT_SCALE_FACTORS_NUM [ i ] ;\n si -> svc_params . scaling_factor_den [ i ] = DEFAULT_SCALE_FACTORS_DEN [ i ] ;\n }\n res = parse_options ( svc_ctx , si -> options ) ;\n if ( res != VPX_CODEC_OK ) return res ;\n if ( svc_ctx -> spatial_layers < 1 ) svc_ctx -> spatial_layers = 1 ;\n if ( svc_ctx -> spatial_layers > VPX_SS_MAX_LAYERS ) svc_ctx -> spatial_layers = VPX_SS_MAX_LAYERS ;\n if ( svc_ctx -> temporal_layers < 1 ) svc_ctx -> temporal_layers = 1 ;\n if ( svc_ctx -> temporal_layers > VPX_TS_MAX_LAYERS ) svc_ctx -> temporal_layers = VPX_TS_MAX_LAYERS ;\n assign_layer_bitrates ( svc_ctx , enc_cfg ) ;\n # if CONFIG_SPATIAL_SVC for ( i = 0 ;\n i < svc_ctx -> spatial_layers ;\n ++ i ) enc_cfg -> ss_enable_auto_alt_ref [ i ] = si -> enable_auto_alt_ref [ i ] ;\n # endif if ( svc_ctx -> temporal_layers > 1 ) {\n int i ;\n for ( i = 0 ;\n i < svc_ctx -> temporal_layers ;\n ++ i ) {\n enc_cfg -> ts_target_bitrate [ i ] = enc_cfg -> rc_target_bitrate / svc_ctx -> temporal_layers ;\n enc_cfg -> ts_rate_decimator [ i ] = 1 << ( svc_ctx -> temporal_layers - 1 - i ) ;\n }\n }\n enc_cfg -> ss_number_layers = svc_ctx -> spatial_layers ;\n enc_cfg -> ts_number_layers = svc_ctx -> temporal_layers ;\n if ( enc_cfg -> g_error_resilient == 0 && si -> use_multiple_frame_contexts == 0 ) enc_cfg -> g_error_resilient = 1 ;\n res = vpx_codec_enc_init ( codec_ctx , iface , enc_cfg , VPX_CODEC_USE_PSNR ) ;\n if ( res != VPX_CODEC_OK ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc_enc_init error\\n\" ) ;\n return res ;\n }\n vpx_codec_control ( codec_ctx , VP9E_SET_SVC , 1 ) ;\n vpx_codec_control ( codec_ctx , VP9E_SET_SVC_PARAMETERS , & si -> svc_params ) ;\n return VPX_CODEC_OK ;\n }", "hash": 5400542917484463750, "project": "chrome", "size": 60, "target": 0, "idx": 17942}
{"code": "int vp9_compute_qdelta_by_rate ( const RATE_CONTROL * rc , FRAME_TYPE frame_type , int qindex , double rate_target_ratio , vpx_bit_depth_t bit_depth ) {\n int target_index = rc -> worst_quality ;\n int i ;\n const int base_bits_per_mb = vp9_rc_bits_per_mb ( frame_type , qindex , 1.0 , bit_depth ) ;\n const int target_bits_per_mb = ( int ) ( rate_target_ratio * base_bits_per_mb ) ;\n for ( i = rc -> best_quality ;\n i < rc -> worst_quality ;\n ++ i ) {\n target_index = i ;\n if ( vp9_rc_bits_per_mb ( frame_type , i , 1.0 , bit_depth ) <= target_bits_per_mb ) break ;\n }\n return target_index - qindex ;\n }", "hash": -7117046864335130087, "project": "chrome", "size": 13, "target": 0, "idx": 17950}
{"code": "static int calc_pframe_target_size_one_pass_cbr ( const VP9_COMP * cpi ) {\n const VP9EncoderConfig * oxcf = & cpi -> oxcf ;\n const RATE_CONTROL * rc = & cpi -> rc ;\n const SVC * const svc = & cpi -> svc ;\n const int64_t diff = rc -> optimal_buffer_level - rc -> buffer_level ;\n const int64_t one_pct_bits = 1 + rc -> optimal_buffer_level / 100 ;\n int min_frame_target = MAX ( rc -> avg_frame_bandwidth >> 4 , FRAME_OVERHEAD_BITS ) ;\n int target = rc -> avg_frame_bandwidth ;\n if ( svc -> number_temporal_layers > 1 && oxcf -> rc_mode == VPX_CBR ) {\n int current_temporal_layer = svc -> temporal_layer_id ;\n const LAYER_CONTEXT * lc = & svc -> layer_context [ current_temporal_layer ] ;\n target = lc -> avg_frame_size ;\n min_frame_target = MAX ( lc -> avg_frame_size >> 4 , FRAME_OVERHEAD_BITS ) ;\n }\n if ( diff > 0 ) {\n const int pct_low = ( int ) MIN ( diff / one_pct_bits , oxcf -> under_shoot_pct ) ;\n target -= ( target * pct_low ) / 200 ;\n }\n else if ( diff < 0 ) {\n const int pct_high = ( int ) MIN ( - diff / one_pct_bits , oxcf -> over_shoot_pct ) ;\n target += ( target * pct_high ) / 200 ;\n }\n return MAX ( min_frame_target , target ) ;\n }", "hash": -7117046864335130087, "project": "chrome", "size": 24, "target": 0, "idx": 17954}
{"code": "int vp9_rc_drop_frame ( VP9_COMP * cpi ) {\n const VP9EncoderConfig * oxcf = & cpi -> oxcf ;\n RATE_CONTROL * const rc = & cpi -> rc ;\n if ( ! oxcf -> drop_frames_water_mark ) {\n return 0 ;\n }\n else {\n if ( rc -> buffer_level < 0 ) {\n return 1 ;\n }\n else {\n int drop_mark = ( int ) ( oxcf -> drop_frames_water_mark * rc -> optimal_buffer_level / 100 ) ;\n if ( ( rc -> buffer_level > drop_mark ) && ( rc -> decimation_factor > 0 ) ) {\n -- rc -> decimation_factor ;\n }\n else if ( rc -> buffer_level <= drop_mark && rc -> decimation_factor == 0 ) {\n rc -> decimation_factor = 1 ;\n }\n if ( rc -> decimation_factor > 0 ) {\n if ( rc -> decimation_count > 0 ) {\n -- rc -> decimation_count ;\n return 1 ;\n }\n else {\n rc -> decimation_count = rc -> decimation_factor ;\n return 0 ;\n }\n }\n else {\n rc -> decimation_count = 0 ;\n return 0 ;\n }\n }\n }\n }", "hash": -7117046864335130087, "project": "chrome", "size": 35, "target": 0, "idx": 17956}
{"code": "static int get_active_cq_level ( const RATE_CONTROL * rc , const VP9EncoderConfig * const oxcf ) {\n static const double cq_adjust_threshold = 0.5 ;\n int active_cq_level = oxcf -> cq_level ;\n if ( oxcf -> rc_mode == VPX_CQ && rc -> total_target_bits > 0 ) {\n const double x = ( double ) rc -> total_actual_bits / rc -> total_target_bits ;\n if ( x < cq_adjust_threshold ) {\n active_cq_level = ( int ) ( active_cq_level * x / cq_adjust_threshold ) ;\n }\n }\n return active_cq_level ;\n }", "hash": -7117046864335130087, "project": "chrome", "size": 11, "target": 0, "idx": 17972}
{"code": "static int calc_active_worst_quality_one_pass_cbr ( const VP9_COMP * cpi ) {\n const VP9_COMMON * const cm = & cpi -> common ;\n const RATE_CONTROL * rc = & cpi -> rc ;\n int64_t critical_level = rc -> optimal_buffer_level >> 2 ;\n int64_t buff_lvl_step = 0 ;\n int adjustment = 0 ;\n int active_worst_quality ;\n if ( cm -> frame_type == KEY_FRAME ) return rc -> worst_quality ;\n if ( cm -> current_video_frame > 1 ) active_worst_quality = MIN ( rc -> worst_quality , rc -> avg_frame_qindex [ INTER_FRAME ] * 5 / 4 ) ;\n else active_worst_quality = MIN ( rc -> worst_quality , rc -> avg_frame_qindex [ KEY_FRAME ] * 3 / 2 ) ;\n if ( rc -> buffer_level > rc -> optimal_buffer_level ) {\n int max_adjustment_down = active_worst_quality / 3 ;\n if ( max_adjustment_down ) {\n buff_lvl_step = ( ( rc -> maximum_buffer_size - rc -> optimal_buffer_level ) / max_adjustment_down ) ;\n if ( buff_lvl_step ) adjustment = ( int ) ( ( rc -> buffer_level - rc -> optimal_buffer_level ) / buff_lvl_step ) ;\n active_worst_quality -= adjustment ;\n }\n }\n else if ( rc -> buffer_level > critical_level ) {\n if ( critical_level ) {\n buff_lvl_step = ( rc -> optimal_buffer_level - critical_level ) ;\n if ( buff_lvl_step ) {\n adjustment = ( int ) ( ( rc -> worst_quality - rc -> avg_frame_qindex [ INTER_FRAME ] ) * ( rc -> optimal_buffer_level - rc -> buffer_level ) / buff_lvl_step ) ;\n }\n active_worst_quality = rc -> avg_frame_qindex [ INTER_FRAME ] + adjustment ;\n }\n }\n else {\n active_worst_quality = rc -> worst_quality ;\n }\n return active_worst_quality ;\n }", "hash": -7117046864335130087, "project": "chrome", "size": 32, "target": 0, "idx": 17982}
{"code": "void vp9_rc_init_minq_luts ( ) {\n init_minq_luts ( kf_low_motion_minq_8 , kf_high_motion_minq_8 , arfgf_low_motion_minq_8 , arfgf_high_motion_minq_8 , inter_minq_8 , rtc_minq_8 , VPX_BITS_8 ) ;\n # if CONFIG_VP9_HIGHBITDEPTH init_minq_luts ( kf_low_motion_minq_10 , kf_high_motion_minq_10 , arfgf_low_motion_minq_10 , arfgf_high_motion_minq_10 , inter_minq_10 , rtc_minq_10 , VPX_BITS_10 ) ;\n init_minq_luts ( kf_low_motion_minq_12 , kf_high_motion_minq_12 , arfgf_low_motion_minq_12 , arfgf_high_motion_minq_12 , inter_minq_12 , rtc_minq_12 , VPX_BITS_12 ) ;\n # endif }", "hash": -7117046864335130087, "project": "chrome", "size": 5, "target": 0, "idx": 17986}
{"code": "void vp9_inc_frame_in_layer ( VP9_COMP * const cpi ) {\n LAYER_CONTEXT * const lc = ( cpi -> svc . number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) ? & cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] : & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] ;\n ++ lc -> current_video_frame_in_layer ;\n ++ lc -> frames_from_key_frame ;\n }", "hash": 7719745392319831548, "project": "chrome", "size": 5, "target": 0, "idx": 17988}
{"code": "void vp9_update_spatial_layer_framerate ( VP9_COMP * const cpi , double framerate ) {\n const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;\n LAYER_CONTEXT * const lc = get_layer_context ( cpi ) ;\n RATE_CONTROL * const lrc = & lc -> rc ;\n lc -> framerate = framerate ;\n lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ;\n lrc -> min_frame_bandwidth = ( int ) ( lrc -> avg_frame_bandwidth * oxcf -> two_pass_vbrmin_section / 100 ) ;\n lrc -> max_frame_bandwidth = ( int ) ( ( ( int64_t ) lrc -> avg_frame_bandwidth * oxcf -> two_pass_vbrmax_section ) / 100 ) ;\n vp9_rc_set_gf_max_interval ( cpi , lrc ) ;\n }", "hash": 7719745392319831548, "project": "chrome", "size": 10, "target": 0, "idx": 17991}
{"code": "void vp9_update_temporal_layer_framerate ( VP9_COMP * const cpi ) {\n SVC * const svc = & cpi -> svc ;\n const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;\n LAYER_CONTEXT * const lc = get_layer_context ( cpi ) ;\n RATE_CONTROL * const lrc = & lc -> rc ;\n const int layer = svc -> temporal_layer_id ;\n lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ layer ] ;\n lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ;\n lrc -> max_frame_bandwidth = cpi -> rc . max_frame_bandwidth ;\n if ( layer == 0 ) {\n lc -> avg_frame_size = lrc -> avg_frame_bandwidth ;\n }\n else {\n const double prev_layer_framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ layer - 1 ] ;\n const int prev_layer_target_bandwidth = oxcf -> ts_target_bitrate [ layer - 1 ] ;\n lc -> avg_frame_size = ( int ) ( ( lc -> target_bandwidth - prev_layer_target_bandwidth ) / ( lc -> framerate - prev_layer_framerate ) ) ;\n }\n }", "hash": 7719745392319831548, "project": "chrome", "size": 18, "target": 0, "idx": 17993}
{"code": "void vp9_init_second_pass_spatial_svc ( VP9_COMP * cpi ) {\n SVC * const svc = & cpi -> svc ;\n int i ;\n for ( i = 0 ;\n i < svc -> number_spatial_layers ;\n ++ i ) {\n TWO_PASS * const twopass = & svc -> layer_context [ i ] . twopass ;\n svc -> spatial_layer_id = i ;\n vp9_init_second_pass ( cpi ) ;\n twopass -> total_stats . spatial_layer_id = i ;\n twopass -> total_left_stats . spatial_layer_id = i ;\n }\n svc -> spatial_layer_id = 0 ;\n }", "hash": 7719745392319831548, "project": "chrome", "size": 14, "target": 0, "idx": 17996}
{"code": "TEST_F ( OmniboxViewViewsTest , Emphasis ) {\n constexpr struct {\n const char * input ;\n bool expected_base_text_emphasized ;\n Range expected_emphasis_range ;\n Range expected_scheme_range ;\n }\n test_cases [ ] = {\n {\n \"data:text/html,Hello%20World\" , false , Range ( 0 , 4 ) , Range ( 0 , 4 ) }\n , {\n \"http://www.example.com/path/file.htm\" , false , Range ( 7 , 22 ) , Range ( 0 , 4 ) }\n , {\n \"https://www.example.com/path/file.htm\" , false , Range ( 8 , 23 ) , Range ( 0 , 5 ) }\n , {\n \"chrome-extension://ldfbacdbackkjhclmhnjabngnppnkagl\" , false , Range : : InvalidRange ( ) , Range ( 0 , 16 ) }\n , {\n \"nosuchscheme://opaque/string\" , true , Range : : InvalidRange ( ) , Range ( 0 , 12 ) }\n , {\n \"nosuchscheme:opaquestring\" , true , Range : : InvalidRange ( ) , Range ( 0 , 12 ) }\n , {\n \"host.com/path/file\" , false , Range ( 0 , 8 ) , Range : : InvalidRange ( ) }\n , {\n \"This is plain text\" , true , Range : : InvalidRange ( ) , Range : : InvalidRange ( ) }\n , }\n ;\n for ( const auto & test_case : test_cases ) {\n SCOPED_TRACE ( test_case . input ) ;\n SetAndEmphasizeText ( test_case . input , false ) ;\n EXPECT_EQ ( TestingOmniboxView : : to_base_text_emphasis ( test_case . expected_base_text_emphasized ) , omnibox_view ( ) -> base_text_emphasis ( ) ) ;\n EXPECT_EQ ( test_case . expected_emphasis_range , omnibox_view ( ) -> emphasis_range ( ) ) ;\n EXPECT_FALSE ( omnibox_view ( ) -> scheme_range ( ) . IsValid ( ) ) ;\n if ( test_case . expected_scheme_range . IsValid ( ) ) {\n SetAndEmphasizeText ( test_case . input , true ) ;\n EXPECT_EQ ( TestingOmniboxView : : to_base_text_emphasis ( test_case . expected_base_text_emphasized ) , omnibox_view ( ) -> base_text_emphasis ( ) ) ;\n EXPECT_EQ ( test_case . expected_emphasis_range , omnibox_view ( ) -> emphasis_range ( ) ) ;\n EXPECT_EQ ( test_case . expected_scheme_range , omnibox_view ( ) -> scheme_range ( ) ) ;\n }\n }\n }", "hash": -1968566663266802355, "project": "chrome", "size": 40, "target": 0, "idx": 18007}
{"code": "TEST_F ( BudgetDatabaseTest , AddEngagementBudgetTest ) {\n base : : SimpleTestClock * clock = SetClockForTesting ( ) ;\n base : : Time expiration_time = clock -> Now ( ) + base : : TimeDelta : : FromDays ( kDefaultExpirationInDays ) ;\n SetSiteEngagementScore ( kEngagement ) ;\n double daily_budget = kMaxDailyBudget * ( kEngagement / SiteEngagementScore : : kMaxPoints ) ;\n GetBudgetDetails ( ) ;\n ASSERT_TRUE ( success_ ) ;\n ASSERT_EQ ( 2U , prediction_ . size ( ) ) ;\n ASSERT_DOUBLE_EQ ( daily_budget * kDefaultExpirationInDays , prediction_ [ 0 ] -> budget_at ) ;\n ASSERT_EQ ( 0 , prediction_ [ 1 ] -> budget_at ) ;\n ASSERT_EQ ( expiration_time . ToDoubleT ( ) , prediction_ [ 1 ] -> time ) ;\n clock -> Advance ( base : : TimeDelta : : FromDays ( 1 ) ) ;\n GetBudgetDetails ( ) ;\n ASSERT_TRUE ( success_ ) ;\n ASSERT_EQ ( 3U , prediction_ . size ( ) ) ;\n ASSERT_DOUBLE_EQ ( daily_budget * ( kDefaultExpirationInDays + 1 ) , prediction_ [ 0 ] -> budget_at ) ;\n ASSERT_DOUBLE_EQ ( daily_budget , prediction_ [ 1 ] -> budget_at ) ;\n ASSERT_EQ ( expiration_time . ToDoubleT ( ) , prediction_ [ 1 ] -> time ) ;\n ASSERT_DOUBLE_EQ ( 0 , prediction_ [ 2 ] -> budget_at ) ;\n ASSERT_EQ ( ( expiration_time + base : : TimeDelta : : FromDays ( 1 ) ) . ToDoubleT ( ) , prediction_ [ 2 ] -> time ) ;\n clock -> Advance ( base : : TimeDelta : : FromMinutes ( 59 ) ) ;\n GetBudgetDetails ( ) ;\n ASSERT_TRUE ( success_ ) ;\n ASSERT_EQ ( 3U , prediction_ . size ( ) ) ;\n ASSERT_DOUBLE_EQ ( daily_budget * ( kDefaultExpirationInDays + 1 ) , prediction_ [ 0 ] -> budget_at ) ;\n }", "hash": -5542766341717884706, "project": "chrome", "size": 26, "target": 0, "idx": 18013}
{"code": "IN_PROC_BROWSER_TEST_F ( ClientHintsBrowserTest , ClientHintsNoLifetimeCookiesNotAllowed ) {\n base : : HistogramTester histogram_tester ;\n ContentSettingsForOneType host_settings ;\n scoped_refptr < content_settings : : CookieSettings > cookie_settings_ = CookieSettingsFactory : : GetForProfile ( browser ( ) -> profile ( ) ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;\n EXPECT_EQ ( 0u , host_settings . size ( ) ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> SetContentSettingDefaultScope ( accept_ch_without_lifetime_img_localhost ( ) , GURL ( ) , CONTENT_SETTINGS_TYPE_COOKIES , std : : string ( ) , CONTENT_SETTING_BLOCK ) ;\n base : : RunLoop ( ) . RunUntilIdle ( ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_without_lifetime_img_localhost ( ) ) ;\n EXPECT_EQ ( 0u , count_client_hints_headers_seen ( ) ) ;\n EXPECT_EQ ( 0u , third_party_client_hints_count_seen ( ) ) ;\n VerifyContentSettingsNotNotified ( ) ;\n cookie_settings_ -> SetCookieSetting ( accept_ch_without_lifetime_img_localhost ( ) , CONTENT_SETTING_ALLOW ) ;\n base : : RunLoop ( ) . RunUntilIdle ( ) ;\n SetClientHintExpectationsOnSubresources ( true ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_without_lifetime_img_localhost ( ) ) ;\n EXPECT_EQ ( 3u , count_client_hints_headers_seen ( ) ) ;\n EXPECT_EQ ( 2u , third_party_request_count_seen ( ) ) ;\n EXPECT_EQ ( 0u , third_party_client_hints_count_seen ( ) ) ;\n SetClientHintExpectationsOnSubresources ( false ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> SetContentSettingDefaultScope ( accept_ch_without_lifetime_img_localhost ( ) , GURL ( ) , CONTENT_SETTINGS_TYPE_COOKIES , std : : string ( ) , CONTENT_SETTING_BLOCK ) ;\n base : : RunLoop ( ) . RunUntilIdle ( ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_without_lifetime_img_localhost ( ) ) ;\n EXPECT_EQ ( 3u , count_client_hints_headers_seen ( ) ) ;\n EXPECT_EQ ( 3u , third_party_request_count_seen ( ) ) ;\n EXPECT_EQ ( 0u , third_party_client_hints_count_seen ( ) ) ;\n }", "hash": 6752827389510428348, "project": "chrome", "size": 27, "target": 0, "idx": 18026}
{"code": "IN_PROC_BROWSER_TEST_F ( ClientHintsBrowserTest , ClientHintsLifetimeFollowedByNoClientHintHttpLocal ) {\n base : : HistogramTester histogram_tester ;\n ContentSettingsForOneType host_settings ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;\n EXPECT_EQ ( 0u , host_settings . size ( ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_with_lifetime_http_local_url ( ) ) ;\n histogram_tester . ExpectUniqueSample ( \"ClientHints.UpdateEventCount\" , 1 , 1 ) ;\n content : : FetchHistogramsFromChildProcesses ( ) ;\n SubprocessMetricsProvider : : MergeHistogramDeltasForTesting ( ) ;\n histogram_tester . ExpectUniqueSample ( \"ClientHints.UpdateSize\" , 3 , 1 ) ;\n histogram_tester . ExpectUniqueSample ( \"ClientHints.PersistDuration\" , * 1000 , 1 ) ;\n base : : RunLoop ( ) . RunUntilIdle ( ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;\n EXPECT_EQ ( 1u , host_settings . size ( ) ) ;\n SetClientHintExpectationsOnMainFrame ( true ) ;\n SetClientHintExpectationsOnSubresources ( true ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , without_accept_ch_without_lifetime_local_url ( ) ) ;\n # if defined ( OS_ANDROID ) EXPECT_EQ ( 4u , count_client_hints_headers_seen ( ) ) ;\n # else EXPECT_EQ ( 6u , count_client_hints_headers_seen ( ) ) ;\n # endif }", "hash": 6752827389510428348, "project": "chrome", "size": 20, "target": 0, "idx": 18028}
{"code": "IN_PROC_BROWSER_TEST_F ( ClientHintsBrowserTest , ClientHintsLifetimeNotPersistedCookiesBlocked ) {\n scoped_refptr < content_settings : : CookieSettings > cookie_settings_ = CookieSettingsFactory : : GetForProfile ( browser ( ) -> profile ( ) ) ;\n base : : HistogramTester histogram_tester ;\n ContentSettingsForOneType host_settings ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> SetContentSettingDefaultScope ( accept_ch_without_lifetime_url ( ) , GURL ( ) , CONTENT_SETTINGS_TYPE_COOKIES , std : : string ( ) , CONTENT_SETTING_BLOCK ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_with_lifetime_url ( ) ) ;\n histogram_tester . ExpectTotalCount ( \"ClientHints.UpdateEventCount\" , 0 ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;\n EXPECT_EQ ( 0u , host_settings . size ( ) ) ;\n VerifyContentSettingsNotNotified ( ) ;\n cookie_settings_ -> SetCookieSetting ( accept_ch_without_lifetime_url ( ) , CONTENT_SETTING_ALLOW ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_with_lifetime_url ( ) ) ;\n histogram_tester . ExpectTotalCount ( \"ClientHints.UpdateEventCount\" , 1 ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;\n EXPECT_EQ ( 1u , host_settings . size ( ) ) ;\n }", "hash": 6752827389510428348, "project": "chrome", "size": 16, "target": 0, "idx": 18032}
{"code": "IN_PROC_BROWSER_TEST_F ( CrossOriginXHR , FileAccessNoHosts ) {\n ASSERT_TRUE ( RunExtensionTest ( \"cross_origin_xhr/file_access_no_hosts\" ) ) << message_ ;\n }", "hash": -8815658870890288443, "project": "chrome", "size": 3, "target": 0, "idx": 18037}
{"code": "IN_PROC_BROWSER_TEST_F ( CrossOriginXHR , NoFileAccessAllURLs ) {\n ASSERT_TRUE ( RunExtensionTestNoFileAccess ( \"cross_origin_xhro_file_access_all_urls\" ) ) << message_ ;\n }", "hash": -8815658870890288443, "project": "chrome", "size": 3, "target": 0, "idx": 18038}
{"code": "static __inline__ int ethtool_validate_duplex ( __u8 duplex ) {\n switch ( duplex ) {\n case DUPLEX_HALF : case DUPLEX_FULL : case DUPLEX_UNKNOWN : return 1 ;\n }\n return 0 ;\n }", "hash": -2443662135687614592, "project": "chrome", "size": 6, "target": 0, "idx": 18061}
{"code": "TEST_F ( TemplateURLParserTest , FailOnPost ) {\n ASSERT_NO_FATAL_FAILURE ( ParseFile ( \"post.xml\" , nullptr ) ) ;\n EXPECT_FALSE ( template_url_ ) ;\n }", "hash": 416708768813973469, "project": "chrome", "size": 4, "target": 0, "idx": 18085}
{"code": "TEST_F ( TemplateURLParserTest , TestDictionary ) {\n ASSERT_NO_FATAL_FAILURE ( ParseFile ( \"dictionary.xml\" , nullptr ) ) ;\n ASSERT_TRUE ( template_url_ ) ;\n EXPECT_EQ ( ASCIIToUTF16 ( \"Dictionary.com\" ) , template_url_ -> short_name ( ) ) ;\n EXPECT_EQ ( GURL ( \"http://cache.lexico.com/g/d/favicon.ico\" ) , template_url_ -> favicon_url ( ) ) ;\n EXPECT_TRUE ( template_url_ -> url_ref ( ) . SupportsReplacement ( SearchTermsData ( ) ) ) ;\n EXPECT_EQ ( \"http://dictionary.reference.com/browse/{\nsearchTerms}\n?r=75\" , template_url_ -> url ( ) ) ;\n }", "hash": 416708768813973469, "project": "chrome", "size": 10, "target": 0, "idx": 18087}
{"code": "TEST_F ( TemplateURLParserTest , FailOnBogusURL ) {\n ASSERT_NO_FATAL_FAILURE ( ParseFile ( \"bogus.xml\" , nullptr ) ) ;\n EXPECT_FALSE ( template_url_ ) ;\n }", "hash": 416708768813973469, "project": "chrome", "size": 4, "target": 0, "idx": 18093}
{"code": "TEST_F ( TemplateURLParserTest , TestFirefoxWebster ) {\n ParamFilterImpl filter ( std : : string ( ) , \"Mozilla\" ) ;\n ASSERT_NO_FATAL_FAILURE ( ParseFile ( \"firefox_webster.xml\" , & filter ) ) ;\n ASSERT_TRUE ( template_url_ ) ;\n EXPECT_EQ ( ASCIIToUTF16 ( \"Webster\" ) , template_url_ -> short_name ( ) ) ;\n EXPECT_TRUE ( template_url_ -> url_ref ( ) . SupportsReplacement ( SearchTermsData ( ) ) ) ;\n EXPECT_EQ ( \"http://www.webster.com/cgi-bin/dictionary?va={\nsearchTerms}\n\" , template_url_ -> url ( ) ) ;\n ASSERT_EQ ( 1U , template_url_ -> input_encodings ( ) . size ( ) ) ;\n EXPECT_EQ ( \"ISO-8859-1\" , template_url_ -> input_encodings ( ) [ 0 ] ) ;\n EXPECT_EQ ( GURL ( \"http://www.webster.com/favicon.ico\" ) , template_url_ -> favicon_url ( ) ) ;\n }", "hash": 416708768813973469, "project": "chrome", "size": 13, "target": 0, "idx": 18094}
{"code": "int main ( int argc , char * * argv ) {\n using std : : string ;\n if ( argc != 2 ) {\n fprintf ( stderr , \"One argument, the input filename, must be provided.\\n\" ) ;\n return 1 ;\n }\n string filename ( argv [ 1 ] ) ;\n string outfilename = filename . substr ( 0 , filename . find_last_of ( \".\" ) ) + \".woff2\" ;\n fprintf ( stdout , \"Processing %s => %s\\n\" , filename . c_str ( ) , outfilename . c_str ( ) ) ;\n string input = woff2 : : GetFileContent ( filename ) ;\n const uint8_t * input_data = reinterpret_cast < const uint8_t * > ( input . data ( ) ) ;\n size_t output_size = woff2 : : MaxWOFF2CompressedSize ( input_data , input . size ( ) ) ;\n string output ( output_size , 0 ) ;\n uint8_t * output_data = reinterpret_cast < uint8_t * > ( & output [ 0 ] ) ;\n woff2 : : WOFF2Params params ;\n if ( ! woff2 : : ConvertTTFToWOFF2 ( input_data , input . size ( ) , output_data , & output_size , params ) ) {\n fprintf ( stderr , \"Compression failed.\\n\" ) ;\n return 1 ;\n }\n output . resize ( output_size ) ;\n woff2 : : SetFileContents ( outfilename , output . begin ( ) , output . end ( ) ) ;\n return 0 ;\n }", "hash": -1967830727983583668, "project": "chrome", "size": 23, "target": 0, "idx": 18098}
{"code": "inline UChar * toUCharPtr ( char16_t * p ) {\n # ifdef U_ALIASING_BARRIER U_ALIASING_BARRIER ( p ) ;\n # endif return reinterpret_cast < UChar * > ( p ) ;\n }", "hash": -7587206010331533317, "project": "chrome", "size": 4, "target": 0, "idx": 18101}
{"code": "static int32_t U_CALLCONV lenient8IteratorMove ( UCharIterator * iter , int32_t delta , UCharIteratorOrigin origin ) {\n const uint8_t * s ;\n UChar32 c ;\n int32_t pos ;\n int32_t i ;\n UBool havePos ;\n switch ( origin ) {\n case UITER_ZERO : case UITER_START : pos = delta ;\n havePos = TRUE ;\n break ;\n case UITER_CURRENT : if ( iter -> index >= 0 ) {\n pos = iter -> index + delta ;\n havePos = TRUE ;\n }\n else {\n pos = 0 ;\n havePos = FALSE ;\n }\n break ;\n case UITER_LIMIT : case UITER_LENGTH : if ( iter -> length >= 0 ) {\n pos = iter -> length + delta ;\n havePos = TRUE ;\n }\n else {\n iter -> index = - 1 ;\n iter -> start = iter -> limit ;\n iter -> reservedField = 0 ;\n if ( delta >= 0 ) {\n return UITER_UNKNOWN_INDEX ;\n }\n else {\n pos = 0 ;\n havePos = FALSE ;\n }\n }\n break ;\n default : return - 1 ;\n }\n if ( havePos ) {\n if ( pos <= 0 ) {\n iter -> index = iter -> start = iter -> reservedField = 0 ;\n return 0 ;\n }\n else if ( iter -> length >= 0 && pos >= iter -> length ) {\n iter -> index = iter -> length ;\n iter -> start = iter -> limit ;\n iter -> reservedField = 0 ;\n return iter -> index ;\n }\n if ( iter -> index < 0 || pos < iter -> index / 2 ) {\n iter -> index = iter -> start = iter -> reservedField = 0 ;\n }\n else if ( iter -> length >= 0 && ( iter -> length - pos ) < ( pos - iter -> index ) ) {\n iter -> index = iter -> length ;\n iter -> start = iter -> limit ;\n iter -> reservedField = 0 ;\n }\n delta = pos - iter -> index ;\n if ( delta == 0 ) {\n return iter -> index ;\n }\n }\n else {\n if ( delta == 0 ) {\n return UITER_UNKNOWN_INDEX ;\n }\n else if ( - delta >= iter -> start ) {\n iter -> index = iter -> start = iter -> reservedField = 0 ;\n return 0 ;\n }\n else if ( delta >= ( iter -> limit - iter -> start ) ) {\n iter -> index = iter -> length ;\n iter -> start = iter -> limit ;\n iter -> reservedField = 0 ;\n return iter -> index >= 0 ? iter -> index : UITER_UNKNOWN_INDEX ;\n }\n }\n s = ( const uint8_t * ) iter -> context ;\n pos = iter -> index ;\n i = iter -> start ;\n if ( delta > 0 ) {\n int32_t limit = iter -> limit ;\n if ( iter -> reservedField != 0 ) {\n iter -> reservedField = 0 ;\n ++ pos ;\n -- delta ;\n }\n while ( delta > 0 && i < limit ) {\n L8_NEXT ( s , i , limit , c ) ;\n if ( c < 0xffff ) {\n ++ pos ;\n -- delta ;\n }\n else if ( delta >= 2 ) {\n pos += 2 ;\n delta -= 2 ;\n }\n else {\n iter -> reservedField = c ;\n ++ pos ;\n break ;\n }\n }\n if ( i == limit ) {\n if ( iter -> length < 0 && iter -> index >= 0 ) {\n iter -> length = iter -> reservedField == 0 ? pos : pos + 1 ;\n }\n else if ( iter -> index < 0 && iter -> length >= 0 ) {\n iter -> index = iter -> reservedField == 0 ? iter -> length : iter -> length - 1 ;\n }\n }\n }\n else {\n if ( iter -> reservedField != 0 ) {\n iter -> reservedField = 0 ;\n i -= 4 ;\n -- pos ;\n ++ delta ;\n }\n while ( delta < 0 && i > 0 ) {\n L8_PREV ( s , 0 , i , c ) ;\n if ( c < 0xffff ) {\n -- pos ;\n ++ delta ;\n }\n else if ( delta <= - 2 ) {\n pos -= 2 ;\n delta += 2 ;\n }\n else {\n i += 4 ;\n iter -> reservedField = c ;\n -- pos ;\n break ;\n }\n }\n }\n iter -> start = i ;\n if ( iter -> index >= 0 ) {\n return iter -> index = pos ;\n }\n else {\n if ( i <= 1 ) {\n return iter -> index = i ;\n }\n else {\n return UITER_UNKNOWN_INDEX ;\n }\n }\n }", "hash": -6032494406888257778, "project": "chrome", "size": 150, "target": 0, "idx": 18116}
{"code": "static void U_CALLCONV _LMBCSOpen ## n ( UConverter * _this , UConverterLoadArgs * pArgs , UErrorCode * err ) \\ {\n _LMBCSOpenWorker ( _this , pArgs , err , n ) ;\n }\n static void _LMBCSOpenWorker ( UConverter * _this , UConverterLoadArgs * pArgs , UErrorCode * err , ulmbcs_byte_t OptGroup ) {\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) uprv_malloc ( sizeof ( UConverterDataLMBCS ) ) ;\n _this -> extraInfo = extraInfo ;\n if ( extraInfo != NULL ) {\n UConverterNamePieces stackPieces ;\n UConverterLoadArgs stackArgs = UCNV_LOAD_ARGS_INITIALIZER ;\n ulmbcs_byte_t i ;\n uprv_memset ( extraInfo , 0 , sizeof ( UConverterDataLMBCS ) ) ;\n stackArgs . onlyTestIsLoadable = pArgs -> onlyTestIsLoadable ;\n for ( i = 0 ;\n i <= ULMBCS_GRP_LAST && U_SUCCESS ( * err ) ;\n i ++ ) {\n if ( OptGroupByteToCPName [ i ] != NULL ) {\n extraInfo -> OptGrpConverter [ i ] = ucnv_loadSharedData ( OptGroupByteToCPName [ i ] , & stackPieces , & stackArgs , err ) ;\n }\n }\n if ( U_FAILURE ( * err ) || pArgs -> onlyTestIsLoadable ) {\n _LMBCSClose ( _this ) ;\n return ;\n }\n extraInfo -> OptGroup = OptGroup ;\n extraInfo -> localeConverterIndex = FindLMBCSLocale ( pArgs -> locale ) ;\n }\n else {\n * err = U_MEMORY_ALLOCATION_ERROR ;\n }\n }\n U_CDECL_BEGIN static void U_CALLCONV _LMBCSClose ( UConverter * _this ) {\n if ( _this -> extraInfo != NULL ) {\n ulmbcs_byte_t Ix ;\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) _this -> extraInfo ;\n for ( Ix = 0 ;\n Ix <= ULMBCS_GRP_LAST ;\n Ix ++ ) {\n if ( extraInfo -> OptGrpConverter [ Ix ] != NULL ) ucnv_unloadSharedDataIfReady ( extraInfo -> OptGrpConverter [ Ix ] ) ;\n }\n if ( ! _this -> isExtraLocal ) {\n uprv_free ( _this -> extraInfo ) ;\n _this -> extraInfo = NULL ;\n }\n }\n }\n typedef struct LMBCSClone {\n UConverter cnv ;\n UConverterDataLMBCS lmbcs ;\n }\n LMBCSClone ;\n static UConverter * U_CALLCONV _LMBCSSafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {\n ( void ) status ;\n LMBCSClone * newLMBCS ;\n UConverterDataLMBCS * extraInfo ;\n int32_t i ;\n if ( * pBufferSize <= 0 ) {\n * pBufferSize = ( int32_t ) sizeof ( LMBCSClone ) ;\n return NULL ;\n }\n extraInfo = ( UConverterDataLMBCS * ) cnv -> extraInfo ;\n newLMBCS = ( LMBCSClone * ) stackBuffer ;\n uprv_memcpy ( & newLMBCS -> lmbcs , extraInfo , sizeof ( UConverterDataLMBCS ) ) ;\n for ( i = 0 ;\n i <= ULMBCS_GRP_LAST ;\n ++ i ) {\n if ( extraInfo -> OptGrpConverter [ i ] != NULL ) {\n ucnv_incrementRefCount ( extraInfo -> OptGrpConverter [ i ] ) ;\n }\n }\n newLMBCS -> cnv . extraInfo = & newLMBCS -> lmbcs ;\n newLMBCS -> cnv . isExtraLocal = TRUE ;\n return & newLMBCS -> cnv ;\n }\n static size_t LMBCSConversionWorker ( UConverterDataLMBCS * extraInfo , ulmbcs_byte_t group , ulmbcs_byte_t * pStartLMBCS , UChar * pUniChar , ulmbcs_byte_t * lastConverterIndex , UBool * groups_tried ) {\n ulmbcs_byte_t * pLMBCS = pStartLMBCS ;\n UConverterSharedData * xcnv = extraInfo -> OptGrpConverter [ group ] ;\n int bytesConverted ;\n uint32_t value ;\n ulmbcs_byte_t firstByte ;\n U_ASSERT ( xcnv ) ;\n U_ASSERT ( group < ULMBCS_GRP_UNICODE ) ;\n bytesConverted = ucnv_MBCSFromUChar32 ( xcnv , * pUniChar , & value , FALSE ) ;\n if ( bytesConverted > 0 ) {\n firstByte = ( ulmbcs_byte_t ) ( value >> ( ( bytesConverted - 1 ) * 8 ) ) ;\n }\n else {\n groups_tried [ group ] = TRUE ;\n return 0 ;\n }\n * lastConverterIndex = group ;\n U_ASSERT ( ( firstByte <= ULMBCS_C0END ) || ( firstByte >= ULMBCS_C1START ) || ( group == ULMBCS_GRP_EXCEPT ) ) ;\n if ( group != ULMBCS_GRP_EXCEPT && extraInfo -> OptGroup != group ) {\n * pLMBCS ++ = group ;\n if ( bytesConverted == 1 && group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n * pLMBCS ++ = group ;\n }\n }\n if ( bytesConverted == 1 && firstByte < 0x20 ) return 0 ;\n switch ( bytesConverted ) {\n case 4 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 24 ) ;\n U_FALLTHROUGH ;\n case 3 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 16 ) ;\n U_FALLTHROUGH ;\n case 2 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 8 ) ;\n U_FALLTHROUGH ;\n case 1 : * pLMBCS ++ = ( ulmbcs_byte_t ) value ;\n U_FALLTHROUGH ;\n default : break ;\n }\n return ( pLMBCS - pStartLMBCS ) ;\n }\n static size_t LMBCSConvertUni ( ulmbcs_byte_t * pLMBCS , UChar uniChar ) {\n uint8_t LowCh = ( uint8_t ) ( uniChar & 0x00FF ) ;\n uint8_t HighCh = ( uint8_t ) ( uniChar >> 8 ) ;\n * pLMBCS ++ = ULMBCS_GRP_UNICODE ;\n if ( LowCh == 0 ) {\n * pLMBCS ++ = ULMBCS_UNICOMPATZERO ;\n * pLMBCS ++ = HighCh ;\n }\n else {\n * pLMBCS ++ = HighCh ;\n * pLMBCS ++ = LowCh ;\n }\n return ULMBCS_UNICODE_SIZE ;\n }\n static void U_CALLCONV _LMBCSFromUnicode ( UConverterFromUnicodeArgs * args , UErrorCode * err ) {\n ulmbcs_byte_t lastConverterIndex = 0 ;\n UChar uniChar ;\n ulmbcs_byte_t LMBCS [ ULMBCS_CHARSIZE_MAX ] ;\n ulmbcs_byte_t * pLMBCS ;\n int32_t bytes_written ;\n UBool groups_tried [ ULMBCS_GRP_LAST + 1 ] ;\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n int sourceIndex = 0 ;\n ulmbcs_byte_t OldConverterIndex = 0 ;\n while ( args -> source < args -> sourceLimit && ! U_FAILURE ( * err ) ) {\n OldConverterIndex = extraInfo -> localeConverterIndex ;\n if ( args -> target >= args -> targetLimit ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n uniChar = * ( args -> source ) ;\n bytes_written = 0 ;\n pLMBCS = LMBCS ;\n if ( ( uniChar >= 0x80 ) && ( uniChar <= 0xff ) && ( uniChar != 0xB1 ) && ( uniChar != 0xD7 ) && ( uniChar != 0xF7 ) && ( uniChar != 0xB0 ) && ( uniChar != 0xB4 ) && ( uniChar != 0xB6 ) && ( uniChar != 0xA7 ) && ( uniChar != 0xA8 ) ) {\n extraInfo -> localeConverterIndex = ULMBCS_GRP_L1 ;\n }\n if ( ( ( uniChar > ULMBCS_C0END ) && ( uniChar < ULMBCS_C1START ) ) || uniChar == 0 || uniChar == ULMBCS_HT || uniChar == ULMBCS_CR || uniChar == ULMBCS_LF || uniChar == ULMBCS_123SYSTEMRANGE ) {\n * pLMBCS ++ = ( ulmbcs_byte_t ) uniChar ;\n bytes_written = 1 ;\n }\n if ( ! bytes_written ) {\n ulmbcs_byte_t group = FindLMBCSUniRange ( uniChar ) ;\n if ( group == ULMBCS_GRP_UNICODE ) {\n pLMBCS += LMBCSConvertUni ( pLMBCS , uniChar ) ;\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n else if ( group == ULMBCS_GRP_CTRL ) {\n if ( uniChar <= ULMBCS_C0END ) {\n * pLMBCS ++ = ULMBCS_GRP_CTRL ;\n * pLMBCS ++ = ( ulmbcs_byte_t ) ( ULMBCS_CTRLOFFSET + uniChar ) ;\n }\n else if ( uniChar >= ULMBCS_C1START && uniChar <= ULMBCS_C1START + ULMBCS_CTRLOFFSET ) {\n * pLMBCS ++ = ULMBCS_GRP_CTRL ;\n * pLMBCS ++ = ( ulmbcs_byte_t ) ( uniChar & 0x00FF ) ;\n }\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n else if ( group < ULMBCS_GRP_UNICODE ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , group , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n uprv_memset ( groups_tried , 0 , sizeof ( groups_tried ) ) ;\n if ( ( extraInfo -> OptGroup != 1 ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , extraInfo -> OptGroup ) ) ) {\n if ( extraInfo -> localeConverterIndex < ULMBCS_DOUBLEOPTGROUP_START ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_L1 , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n if ( ! bytes_written ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_EXCEPT , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n else {\n bytes_written = LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written && ( extraInfo -> localeConverterIndex ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , extraInfo -> localeConverterIndex ) ) ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written && ( lastConverterIndex ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , lastConverterIndex ) ) ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , lastConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n ulmbcs_byte_t grp_start ;\n ulmbcs_byte_t grp_end ;\n ulmbcs_byte_t grp_ix ;\n grp_start = ( ulmbcs_byte_t ) ( ( group == ULMBCS_AMBIGUOUS_MBCS ) ? ULMBCS_DOUBLEOPTGROUP_START : ULMBCS_GRP_L1 ) ;\n grp_end = ( ulmbcs_byte_t ) ( ( group == ULMBCS_AMBIGUOUS_MBCS ) ? ULMBCS_GRP_LAST : ULMBCS_GRP_TH ) ;\n if ( group == ULMBCS_AMBIGUOUS_ALL ) {\n grp_start = ULMBCS_GRP_L1 ;\n grp_end = ULMBCS_GRP_LAST ;\n }\n for ( grp_ix = grp_start ;\n grp_ix <= grp_end && ! bytes_written ;\n grp_ix ++ ) {\n if ( extraInfo -> OptGrpConverter [ grp_ix ] && ! groups_tried [ grp_ix ] ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , grp_ix , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written && grp_start == ULMBCS_GRP_L1 ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_EXCEPT , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written ) {\n pLMBCS += LMBCSConvertUni ( pLMBCS , uniChar ) ;\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n }\n }\n args -> source ++ ;\n pLMBCS = LMBCS ;\n while ( args -> target < args -> targetLimit && bytes_written -- ) {\n * ( args -> target ) ++ = * pLMBCS ++ ;\n if ( args -> offsets ) {\n * ( args -> offsets ) ++ = sourceIndex ;\n }\n }\n sourceIndex ++ ;\n if ( bytes_written > 0 ) {\n uint8_t * pErrorBuffer = args -> converter -> charErrorBuffer ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n args -> converter -> charErrorBufferLength = ( int8_t ) bytes_written ;\n while ( bytes_written -- ) {\n * pErrorBuffer ++ = * pLMBCS ++ ;\n }\n }\n extraInfo -> localeConverterIndex = OldConverterIndex ;\n }\n }\n static UChar GetUniFromLMBCSUni ( char const * * ppLMBCSin ) {\n uint8_t HighCh = * ( * ppLMBCSin ) ++ ;\n uint8_t LowCh = * ( * ppLMBCSin ) ++ ;\n if ( HighCh == ULMBCS_UNICOMPATZERO ) {\n HighCh = LowCh ;\n LowCh = 0 ;\n }\n return ( UChar ) ( ( HighCh << 8 ) | LowCh ) ;\n }\n # define CHECK_SOURCE_LIMIT ( index ) if ( args -> source + index > args -> sourceLimit ) {\n * err = U_TRUNCATED_CHAR_FOUND ;\n args -> source = args -> sourceLimit ;\n return 0xffff ;\n }\n static UChar32 U_CALLCONV _LMBCSGetNextUCharWorker ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n UChar32 uniChar = 0 ;\n ulmbcs_byte_t CurByte ;\n if ( args -> source >= args -> sourceLimit ) {\n * err = U_ILLEGAL_ARGUMENT_ERROR ;\n return 0xffff ;\n }\n CurByte = * ( ( ulmbcs_byte_t * ) ( args -> source ++ ) ) ;\n if ( ( ( CurByte > ULMBCS_C0END ) && ( CurByte < ULMBCS_C1START ) ) || ( CurByte == 0 ) || CurByte == ULMBCS_HT || CurByte == ULMBCS_CR || CurByte == ULMBCS_LF || CurByte == ULMBCS_123SYSTEMRANGE ) {\n uniChar = CurByte ;\n }\n else {\n UConverterDataLMBCS * extraInfo ;\n ulmbcs_byte_t group ;\n UConverterSharedData * cnv ;\n if ( CurByte == ULMBCS_GRP_CTRL ) {\n ulmbcs_byte_t C0C1byte ;\n CHECK_SOURCE_LIMIT ( 1 ) ;\n C0C1byte = * ( args -> source ) ++ ;\n uniChar = ( C0C1byte < ULMBCS_C1START ) ? C0C1byte - ULMBCS_CTRLOFFSET : C0C1byte ;\n }\n else if ( CurByte == ULMBCS_GRP_UNICODE ) {\n CHECK_SOURCE_LIMIT ( 2 ) ;\n return GetUniFromLMBCSUni ( & ( args -> source ) ) ;\n }\n else if ( CurByte <= ULMBCS_CTRLOFFSET ) {\n group = CurByte ;\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n if ( group > ULMBCS_GRP_LAST || ( cnv = extraInfo -> OptGrpConverter [ group ] ) == NULL ) {\n * err = U_INVALID_CHAR_FOUND ;\n }\n else if ( group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n CHECK_SOURCE_LIMIT ( 2 ) ;\n if ( * args -> source == group ) {\n ++ args -> source ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source , 1 , FALSE ) ;\n ++ args -> source ;\n }\n else {\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source , 2 , FALSE ) ;\n args -> source += 2 ;\n }\n }\n else {\n CHECK_SOURCE_LIMIT ( 1 ) ;\n CurByte = * ( args -> source ) ++ ;\n if ( CurByte >= ULMBCS_C1START ) {\n uniChar = _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP ( cnv , CurByte ) ;\n }\n else {\n char bytes [ 2 ] ;\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n cnv = extraInfo -> OptGrpConverter [ ULMBCS_GRP_EXCEPT ] ;\n bytes [ 0 ] = group ;\n bytes [ 1 ] = CurByte ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , bytes , 2 , FALSE ) ;\n }\n }\n }\n else if ( CurByte >= ULMBCS_C1START ) {\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n group = extraInfo -> OptGroup ;\n cnv = extraInfo -> OptGrpConverter [ group ] ;\n if ( group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n if ( ! ucnv_MBCSIsLeadByte ( cnv , CurByte ) ) {\n CHECK_SOURCE_LIMIT ( 0 ) ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source - 1 , 1 , FALSE ) ;\n }\n else {\n CHECK_SOURCE_LIMIT ( 1 ) ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source - 1 , 2 , FALSE ) ;\n ++ args -> source ;\n }\n }\n else {\n uniChar = _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP ( cnv , CurByte ) ;\n }\n }\n }\n return uniChar ;\n }\n static void U_CALLCONV _LMBCSToUnicodeWithOffsets ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n char LMBCS [ ULMBCS_CHARSIZE_MAX ] ;\n UChar uniChar ;\n const char * saveSource ;\n const char * pStartLMBCS = args -> source ;\n const char * errSource = NULL ;\n int8_t savebytes = 0 ;\n while ( U_SUCCESS ( * err ) && args -> sourceLimit > args -> source && args -> targetLimit > args -> target ) {\n saveSource = args -> source ;\n if ( args -> converter -> toULength ) {\n const char * saveSourceLimit ;\n size_t size_old = args -> converter -> toULength ;\n size_t size_new_maybe_1 = sizeof ( LMBCS ) - size_old ;\n size_t size_new_maybe_2 = args -> sourceLimit - args -> source ;\n size_t size_new = ( size_new_maybe_1 < size_new_maybe_2 ) ? size_new_maybe_1 : size_new_maybe_2 ;\n uprv_memcpy ( LMBCS , args -> converter -> toUBytes , size_old ) ;\n uprv_memcpy ( LMBCS + size_old , args -> source , size_new ) ;\n saveSourceLimit = args -> sourceLimit ;\n args -> source = errSource = LMBCS ;\n args -> sourceLimit = LMBCS + size_old + size_new ;\n savebytes = ( int8_t ) ( size_old + size_new ) ;\n uniChar = ( UChar ) _LMBCSGetNextUCharWorker ( args , err ) ;\n args -> source = saveSource + ( ( args -> source - LMBCS ) - size_old ) ;\n args -> sourceLimit = saveSourceLimit ;\n if ( * err == U_TRUNCATED_CHAR_FOUND ) {\n args -> converter -> toULength = savebytes ;\n uprv_memcpy ( args -> converter -> toUBytes , LMBCS , savebytes ) ;\n args -> source = args -> sourceLimit ;\n * err = U_ZERO_ERROR ;\n return ;\n }\n else {\n args -> converter -> toULength = 0 ;\n }\n }\n else {\n errSource = saveSource ;\n uniChar = ( UChar ) _LMBCSGetNextUCharWorker ( args , err ) ;\n savebytes = ( int8_t ) ( args -> source - saveSource ) ;\n }\n if ( U_SUCCESS ( * err ) ) {\n if ( uniChar < 0xfffe ) {\n * ( args -> target ) ++ = uniChar ;\n if ( args -> offsets ) {\n * ( args -> offsets ) ++ = ( int32_t ) ( saveSource - pStartLMBCS ) ;\n }\n }\n else if ( uniChar == 0xfffe ) {\n * err = U_INVALID_CHAR_FOUND ;\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n }\n if ( U_SUCCESS ( * err ) && args -> sourceLimit > args -> source && args -> targetLimit <= args -> target ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n else if ( U_FAILURE ( * err ) ) {\n args -> converter -> toULength = savebytes ;\n if ( savebytes > 0 ) {\n uprv_memcpy ( args -> converter -> toUBytes , errSource , savebytes ) ;\n }\n if ( * err == U_TRUNCATED_CHAR_FOUND ) {\n * err = U_ZERO_ERROR ;\n }\n }\n }\n DEFINE_LMBCS_OPEN ( 1 ) DEFINE_LMBCS_OPEN ( 2 )", "hash": 7072059544915633710, "project": "chrome", "size": 404, "target": 0, "idx": 18134}
{"code": "static void U_CALLCONV _LMBCSOpen ## n ( UConverter * _this , UConverterLoadArgs * pArgs , UErrorCode * err ) \\ {\n _LMBCSOpenWorker ( _this , pArgs , err , n ) ;\n }\n static void _LMBCSOpenWorker ( UConverter * _this , UConverterLoadArgs * pArgs , UErrorCode * err , ulmbcs_byte_t OptGroup ) {\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) uprv_malloc ( sizeof ( UConverterDataLMBCS ) ) ;\n _this -> extraInfo = extraInfo ;\n if ( extraInfo != NULL ) {\n UConverterNamePieces stackPieces ;\n UConverterLoadArgs stackArgs = UCNV_LOAD_ARGS_INITIALIZER ;\n ulmbcs_byte_t i ;\n uprv_memset ( extraInfo , 0 , sizeof ( UConverterDataLMBCS ) ) ;\n stackArgs . onlyTestIsLoadable = pArgs -> onlyTestIsLoadable ;\n for ( i = 0 ;\n i <= ULMBCS_GRP_LAST && U_SUCCESS ( * err ) ;\n i ++ ) {\n if ( OptGroupByteToCPName [ i ] != NULL ) {\n extraInfo -> OptGrpConverter [ i ] = ucnv_loadSharedData ( OptGroupByteToCPName [ i ] , & stackPieces , & stackArgs , err ) ;\n }\n }\n if ( U_FAILURE ( * err ) || pArgs -> onlyTestIsLoadable ) {\n _LMBCSClose ( _this ) ;\n return ;\n }\n extraInfo -> OptGroup = OptGroup ;\n extraInfo -> localeConverterIndex = FindLMBCSLocale ( pArgs -> locale ) ;\n }\n else {\n * err = U_MEMORY_ALLOCATION_ERROR ;\n }\n }\n U_CDECL_BEGIN static void U_CALLCONV _LMBCSClose ( UConverter * _this ) {\n if ( _this -> extraInfo != NULL ) {\n ulmbcs_byte_t Ix ;\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) _this -> extraInfo ;\n for ( Ix = 0 ;\n Ix <= ULMBCS_GRP_LAST ;\n Ix ++ ) {\n if ( extraInfo -> OptGrpConverter [ Ix ] != NULL ) ucnv_unloadSharedDataIfReady ( extraInfo -> OptGrpConverter [ Ix ] ) ;\n }\n if ( ! _this -> isExtraLocal ) {\n uprv_free ( _this -> extraInfo ) ;\n _this -> extraInfo = NULL ;\n }\n }\n }\n typedef struct LMBCSClone {\n UConverter cnv ;\n UConverterDataLMBCS lmbcs ;\n }\n LMBCSClone ;\n static UConverter * U_CALLCONV _LMBCSSafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {\n ( void ) status ;\n LMBCSClone * newLMBCS ;\n UConverterDataLMBCS * extraInfo ;\n int32_t i ;\n if ( * pBufferSize <= 0 ) {\n * pBufferSize = ( int32_t ) sizeof ( LMBCSClone ) ;\n return NULL ;\n }\n extraInfo = ( UConverterDataLMBCS * ) cnv -> extraInfo ;\n newLMBCS = ( LMBCSClone * ) stackBuffer ;\n uprv_memcpy ( & newLMBCS -> lmbcs , extraInfo , sizeof ( UConverterDataLMBCS ) ) ;\n for ( i = 0 ;\n i <= ULMBCS_GRP_LAST ;\n ++ i ) {\n if ( extraInfo -> OptGrpConverter [ i ] != NULL ) {\n ucnv_incrementRefCount ( extraInfo -> OptGrpConverter [ i ] ) ;\n }\n }\n newLMBCS -> cnv . extraInfo = & newLMBCS -> lmbcs ;\n newLMBCS -> cnv . isExtraLocal = TRUE ;\n return & newLMBCS -> cnv ;\n }\n static size_t LMBCSConversionWorker ( UConverterDataLMBCS * extraInfo , ulmbcs_byte_t group , ulmbcs_byte_t * pStartLMBCS , UChar * pUniChar , ulmbcs_byte_t * lastConverterIndex , UBool * groups_tried ) {\n ulmbcs_byte_t * pLMBCS = pStartLMBCS ;\n UConverterSharedData * xcnv = extraInfo -> OptGrpConverter [ group ] ;\n int bytesConverted ;\n uint32_t value ;\n ulmbcs_byte_t firstByte ;\n U_ASSERT ( xcnv ) ;\n U_ASSERT ( group < ULMBCS_GRP_UNICODE ) ;\n bytesConverted = ucnv_MBCSFromUChar32 ( xcnv , * pUniChar , & value , FALSE ) ;\n if ( bytesConverted > 0 ) {\n firstByte = ( ulmbcs_byte_t ) ( value >> ( ( bytesConverted - 1 ) * 8 ) ) ;\n }\n else {\n groups_tried [ group ] = TRUE ;\n return 0 ;\n }\n * lastConverterIndex = group ;\n U_ASSERT ( ( firstByte <= ULMBCS_C0END ) || ( firstByte >= ULMBCS_C1START ) || ( group == ULMBCS_GRP_EXCEPT ) ) ;\n if ( group != ULMBCS_GRP_EXCEPT && extraInfo -> OptGroup != group ) {\n * pLMBCS ++ = group ;\n if ( bytesConverted == 1 && group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n * pLMBCS ++ = group ;\n }\n }\n if ( bytesConverted == 1 && firstByte < 0x20 ) return 0 ;\n switch ( bytesConverted ) {\n case 4 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 24 ) ;\n U_FALLTHROUGH ;\n case 3 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 16 ) ;\n U_FALLTHROUGH ;\n case 2 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 8 ) ;\n U_FALLTHROUGH ;\n case 1 : * pLMBCS ++ = ( ulmbcs_byte_t ) value ;\n U_FALLTHROUGH ;\n default : break ;\n }\n return ( pLMBCS - pStartLMBCS ) ;\n }\n static size_t LMBCSConvertUni ( ulmbcs_byte_t * pLMBCS , UChar uniChar ) {\n uint8_t LowCh = ( uint8_t ) ( uniChar & 0x00FF ) ;\n uint8_t HighCh = ( uint8_t ) ( uniChar >> 8 ) ;\n * pLMBCS ++ = ULMBCS_GRP_UNICODE ;\n if ( LowCh == 0 ) {\n * pLMBCS ++ = ULMBCS_UNICOMPATZERO ;\n * pLMBCS ++ = HighCh ;\n }\n else {\n * pLMBCS ++ = HighCh ;\n * pLMBCS ++ = LowCh ;\n }\n return ULMBCS_UNICODE_SIZE ;\n }\n static void U_CALLCONV _LMBCSFromUnicode ( UConverterFromUnicodeArgs * args , UErrorCode * err ) {\n ulmbcs_byte_t lastConverterIndex = 0 ;\n UChar uniChar ;\n ulmbcs_byte_t LMBCS [ ULMBCS_CHARSIZE_MAX ] ;\n ulmbcs_byte_t * pLMBCS ;\n int32_t bytes_written ;\n UBool groups_tried [ ULMBCS_GRP_LAST + 1 ] ;\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n int sourceIndex = 0 ;\n ulmbcs_byte_t OldConverterIndex = 0 ;\n while ( args -> source < args -> sourceLimit && ! U_FAILURE ( * err ) ) {\n OldConverterIndex = extraInfo -> localeConverterIndex ;\n if ( args -> target >= args -> targetLimit ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n uniChar = * ( args -> source ) ;\n bytes_written = 0 ;\n pLMBCS = LMBCS ;\n if ( ( uniChar >= 0x80 ) && ( uniChar <= 0xff ) && ( uniChar != 0xB1 ) && ( uniChar != 0xD7 ) && ( uniChar != 0xF7 ) && ( uniChar != 0xB0 ) && ( uniChar != 0xB4 ) && ( uniChar != 0xB6 ) && ( uniChar != 0xA7 ) && ( uniChar != 0xA8 ) ) {\n extraInfo -> localeConverterIndex = ULMBCS_GRP_L1 ;\n }\n if ( ( ( uniChar > ULMBCS_C0END ) && ( uniChar < ULMBCS_C1START ) ) || uniChar == 0 || uniChar == ULMBCS_HT || uniChar == ULMBCS_CR || uniChar == ULMBCS_LF || uniChar == ULMBCS_123SYSTEMRANGE ) {\n * pLMBCS ++ = ( ulmbcs_byte_t ) uniChar ;\n bytes_written = 1 ;\n }\n if ( ! bytes_written ) {\n ulmbcs_byte_t group = FindLMBCSUniRange ( uniChar ) ;\n if ( group == ULMBCS_GRP_UNICODE ) {\n pLMBCS += LMBCSConvertUni ( pLMBCS , uniChar ) ;\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n else if ( group == ULMBCS_GRP_CTRL ) {\n if ( uniChar <= ULMBCS_C0END ) {\n * pLMBCS ++ = ULMBCS_GRP_CTRL ;\n * pLMBCS ++ = ( ulmbcs_byte_t ) ( ULMBCS_CTRLOFFSET + uniChar ) ;\n }\n else if ( uniChar >= ULMBCS_C1START && uniChar <= ULMBCS_C1START + ULMBCS_CTRLOFFSET ) {\n * pLMBCS ++ = ULMBCS_GRP_CTRL ;\n * pLMBCS ++ = ( ulmbcs_byte_t ) ( uniChar & 0x00FF ) ;\n }\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n else if ( group < ULMBCS_GRP_UNICODE ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , group , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n uprv_memset ( groups_tried , 0 , sizeof ( groups_tried ) ) ;\n if ( ( extraInfo -> OptGroup != 1 ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , extraInfo -> OptGroup ) ) ) {\n if ( extraInfo -> localeConverterIndex < ULMBCS_DOUBLEOPTGROUP_START ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_L1 , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n if ( ! bytes_written ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_EXCEPT , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n else {\n bytes_written = LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written && ( extraInfo -> localeConverterIndex ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , extraInfo -> localeConverterIndex ) ) ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written && ( lastConverterIndex ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , lastConverterIndex ) ) ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , lastConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n ulmbcs_byte_t grp_start ;\n ulmbcs_byte_t grp_end ;\n ulmbcs_byte_t grp_ix ;\n grp_start = ( ulmbcs_byte_t ) ( ( group == ULMBCS_AMBIGUOUS_MBCS ) ? ULMBCS_DOUBLEOPTGROUP_START : ULMBCS_GRP_L1 ) ;\n grp_end = ( ulmbcs_byte_t ) ( ( group == ULMBCS_AMBIGUOUS_MBCS ) ? ULMBCS_GRP_LAST : ULMBCS_GRP_TH ) ;\n if ( group == ULMBCS_AMBIGUOUS_ALL ) {\n grp_start = ULMBCS_GRP_L1 ;\n grp_end = ULMBCS_GRP_LAST ;\n }\n for ( grp_ix = grp_start ;\n grp_ix <= grp_end && ! bytes_written ;\n grp_ix ++ ) {\n if ( extraInfo -> OptGrpConverter [ grp_ix ] && ! groups_tried [ grp_ix ] ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , grp_ix , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written && grp_start == ULMBCS_GRP_L1 ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_EXCEPT , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written ) {\n pLMBCS += LMBCSConvertUni ( pLMBCS , uniChar ) ;\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n }\n }\n args -> source ++ ;\n pLMBCS = LMBCS ;\n while ( args -> target < args -> targetLimit && bytes_written -- ) {\n * ( args -> target ) ++ = * pLMBCS ++ ;\n if ( args -> offsets ) {\n * ( args -> offsets ) ++ = sourceIndex ;\n }\n }\n sourceIndex ++ ;\n if ( bytes_written > 0 ) {\n uint8_t * pErrorBuffer = args -> converter -> charErrorBuffer ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n args -> converter -> charErrorBufferLength = ( int8_t ) bytes_written ;\n while ( bytes_written -- ) {\n * pErrorBuffer ++ = * pLMBCS ++ ;\n }\n }\n extraInfo -> localeConverterIndex = OldConverterIndex ;\n }\n }\n static UChar GetUniFromLMBCSUni ( char const * * ppLMBCSin ) {\n uint8_t HighCh = * ( * ppLMBCSin ) ++ ;\n uint8_t LowCh = * ( * ppLMBCSin ) ++ ;\n if ( HighCh == ULMBCS_UNICOMPATZERO ) {\n HighCh = LowCh ;\n LowCh = 0 ;\n }\n return ( UChar ) ( ( HighCh << 8 ) | LowCh ) ;\n }\n # define CHECK_SOURCE_LIMIT ( index ) if ( args -> source + index > args -> sourceLimit ) {\n * err = U_TRUNCATED_CHAR_FOUND ;\n args -> source = args -> sourceLimit ;\n return 0xffff ;\n }\n static UChar32 U_CALLCONV _LMBCSGetNextUCharWorker ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n UChar32 uniChar = 0 ;\n ulmbcs_byte_t CurByte ;\n if ( args -> source >= args -> sourceLimit ) {\n * err = U_ILLEGAL_ARGUMENT_ERROR ;\n return 0xffff ;\n }\n CurByte = * ( ( ulmbcs_byte_t * ) ( args -> source ++ ) ) ;\n if ( ( ( CurByte > ULMBCS_C0END ) && ( CurByte < ULMBCS_C1START ) ) || ( CurByte == 0 ) || CurByte == ULMBCS_HT || CurByte == ULMBCS_CR || CurByte == ULMBCS_LF || CurByte == ULMBCS_123SYSTEMRANGE ) {\n uniChar = CurByte ;\n }\n else {\n UConverterDataLMBCS * extraInfo ;\n ulmbcs_byte_t group ;\n UConverterSharedData * cnv ;\n if ( CurByte == ULMBCS_GRP_CTRL ) {\n ulmbcs_byte_t C0C1byte ;\n CHECK_SOURCE_LIMIT ( 1 ) ;\n C0C1byte = * ( args -> source ) ++ ;\n uniChar = ( C0C1byte < ULMBCS_C1START ) ? C0C1byte - ULMBCS_CTRLOFFSET : C0C1byte ;\n }\n else if ( CurByte == ULMBCS_GRP_UNICODE ) {\n CHECK_SOURCE_LIMIT ( 2 ) ;\n return GetUniFromLMBCSUni ( & ( args -> source ) ) ;\n }\n else if ( CurByte <= ULMBCS_CTRLOFFSET ) {\n group = CurByte ;\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n if ( group > ULMBCS_GRP_LAST || ( cnv = extraInfo -> OptGrpConverter [ group ] ) == NULL ) {\n * err = U_INVALID_CHAR_FOUND ;\n }\n else if ( group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n CHECK_SOURCE_LIMIT ( 2 ) ;\n if ( * args -> source == group ) {\n ++ args -> source ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source , 1 , FALSE ) ;\n ++ args -> source ;\n }\n else {\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source , 2 , FALSE ) ;\n args -> source += 2 ;\n }\n }\n else {\n CHECK_SOURCE_LIMIT ( 1 ) ;\n CurByte = * ( args -> source ) ++ ;\n if ( CurByte >= ULMBCS_C1START ) {\n uniChar = _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP ( cnv , CurByte ) ;\n }\n else {\n char bytes [ 2 ] ;\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n cnv = extraInfo -> OptGrpConverter [ ULMBCS_GRP_EXCEPT ] ;\n bytes [ 0 ] = group ;\n bytes [ 1 ] = CurByte ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , bytes , 2 , FALSE ) ;\n }\n }\n }\n else if ( CurByte >= ULMBCS_C1START ) {\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n group = extraInfo -> OptGroup ;\n cnv = extraInfo -> OptGrpConverter [ group ] ;\n if ( group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n if ( ! ucnv_MBCSIsLeadByte ( cnv , CurByte ) ) {\n CHECK_SOURCE_LIMIT ( 0 ) ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source - 1 , 1 , FALSE ) ;\n }\n else {\n CHECK_SOURCE_LIMIT ( 1 ) ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source - 1 , 2 , FALSE ) ;\n ++ args -> source ;\n }\n }\n else {\n uniChar = _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP ( cnv , CurByte ) ;\n }\n }\n }\n return uniChar ;\n }\n static void U_CALLCONV _LMBCSToUnicodeWithOffsets ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n char LMBCS [ ULMBCS_CHARSIZE_MAX ] ;\n UChar uniChar ;\n const char * saveSource ;\n const char * pStartLMBCS = args -> source ;\n const char * errSource = NULL ;\n int8_t savebytes = 0 ;\n while ( U_SUCCESS ( * err ) && args -> sourceLimit > args -> source && args -> targetLimit > args -> target ) {\n saveSource = args -> source ;\n if ( args -> converter -> toULength ) {\n const char * saveSourceLimit ;\n size_t size_old = args -> converter -> toULength ;\n size_t size_new_maybe_1 = sizeof ( LMBCS ) - size_old ;\n size_t size_new_maybe_2 = args -> sourceLimit - args -> source ;\n size_t size_new = ( size_new_maybe_1 < size_new_maybe_2 ) ? size_new_maybe_1 : size_new_maybe_2 ;\n uprv_memcpy ( LMBCS , args -> converter -> toUBytes , size_old ) ;\n uprv_memcpy ( LMBCS + size_old , args -> source , size_new ) ;\n saveSourceLimit = args -> sourceLimit ;\n args -> source = errSource = LMBCS ;\n args -> sourceLimit = LMBCS + size_old + size_new ;\n savebytes = ( int8_t ) ( size_old + size_new ) ;\n uniChar = ( UChar ) _LMBCSGetNextUCharWorker ( args , err ) ;\n args -> source = saveSource + ( ( args -> source - LMBCS ) - size_old ) ;\n args -> sourceLimit = saveSourceLimit ;\n if ( * err == U_TRUNCATED_CHAR_FOUND ) {\n args -> converter -> toULength = savebytes ;\n uprv_memcpy ( args -> converter -> toUBytes , LMBCS , savebytes ) ;\n args -> source = args -> sourceLimit ;\n * err = U_ZERO_ERROR ;\n return ;\n }\n else {\n args -> converter -> toULength = 0 ;\n }\n }\n else {\n errSource = saveSource ;\n uniChar = ( UChar ) _LMBCSGetNextUCharWorker ( args , err ) ;\n savebytes = ( int8_t ) ( args -> source - saveSource ) ;\n }\n if ( U_SUCCESS ( * err ) ) {\n if ( uniChar < 0xfffe ) {\n * ( args -> target ) ++ = uniChar ;\n if ( args -> offsets ) {\n * ( args -> offsets ) ++ = ( int32_t ) ( saveSource - pStartLMBCS ) ;\n }\n }\n else if ( uniChar == 0xfffe ) {\n * err = U_INVALID_CHAR_FOUND ;\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n }\n if ( U_SUCCESS ( * err ) && args -> sourceLimit > args -> source && args -> targetLimit <= args -> target ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n else if ( U_FAILURE ( * err ) ) {\n args -> converter -> toULength = savebytes ;\n if ( savebytes > 0 ) {\n uprv_memcpy ( args -> converter -> toUBytes , errSource , savebytes ) ;\n }\n if ( * err == U_TRUNCATED_CHAR_FOUND ) {\n * err = U_ZERO_ERROR ;\n }\n }\n }\n DEFINE_LMBCS_OPEN ( 1 ) DEFINE_LMBCS_OPEN ( 2 ) DEFINE_LMBCS_OPEN ( 3 ) DEFINE_LMBCS_OPEN ( 4 ) DEFINE_LMBCS_OPEN ( 5 ) DEFINE_LMBCS_OPEN ( 6 )", "hash": 7072059544915633710, "project": "chrome", "size": 404, "target": 0, "idx": 18150}
{"code": "static UBool _isAlphaNumericString ( const char * s , int32_t len ) {\n int32_t i ;\n for ( i = 0 ;\n i < len ;\n i ++ ) {\n if ( ! ISALPHA ( * ( s + i ) ) && ! ISNUMERIC ( * ( s + i ) ) ) {\n return FALSE ;\n }\n }\n return TRUE ;\n }", "hash": -5697857125570093892, "project": "chrome", "size": 11, "target": 0, "idx": 18172}
{"code": "static const char * ultag_getScript ( const ULanguageTag * langtag ) {\n return langtag -> script ;\n }", "hash": -5697857125570093892, "project": "chrome", "size": 3, "target": 0, "idx": 18185}
{"code": "static void ultag_close ( ULanguageTag * langtag ) {\n if ( langtag == NULL ) {\n return ;\n }\n uprv_free ( langtag -> buf ) ;\n if ( langtag -> variants ) {\n VariantListEntry * curVar = langtag -> variants ;\n while ( curVar ) {\n VariantListEntry * nextVar = curVar -> next ;\n uprv_free ( curVar ) ;\n curVar = nextVar ;\n }\n }\n if ( langtag -> extensions ) {\n ExtensionListEntry * curExt = langtag -> extensions ;\n while ( curExt ) {\n ExtensionListEntry * nextExt = curExt -> next ;\n uprv_free ( curExt ) ;\n curExt = nextExt ;\n }\n }\n uprv_free ( langtag ) ;\n }", "hash": -5697857125570093892, "project": "chrome", "size": 23, "target": 0, "idx": 18188}
{"code": "static void U_CALLCONV UConverter_fromUnicode_HZ_OFFSETS_LOGIC ( UConverterFromUnicodeArgs * args , UErrorCode * err ) {\n const UChar * mySource = args -> source ;\n char * myTarget = args -> target ;\n int32_t * offsets = args -> offsets ;\n int32_t mySourceIndex = 0 ;\n int32_t myTargetIndex = 0 ;\n int32_t targetLength = ( int32_t ) ( args -> targetLimit - myTarget ) ;\n int32_t mySourceLength = ( int32_t ) ( args -> sourceLimit - args -> source ) ;\n uint32_t targetUniChar = 0x0000 ;\n UChar32 mySourceChar = 0x0000 ;\n UConverterDataHZ * myConverterData = ( UConverterDataHZ * ) args -> converter -> extraInfo ;\n UBool isTargetUCharDBCS = ( UBool ) myConverterData -> isTargetUCharDBCS ;\n UBool oldIsTargetUCharDBCS ;\n int len = 0 ;\n const char * escSeq = NULL ;\n if ( args -> converter -> fromUChar32 != 0 && myTargetIndex < targetLength ) {\n goto getTrail ;\n }\n while ( mySourceIndex < mySourceLength ) {\n targetUniChar = missingCharMarker ;\n if ( myTargetIndex < targetLength ) {\n mySourceChar = ( UChar ) mySource [ mySourceIndex ++ ] ;\n oldIsTargetUCharDBCS = isTargetUCharDBCS ;\n if ( mySourceChar == UCNV_TILDE ) {\n len = ESC_LEN ;\n escSeq = TILDE_ESCAPE ;\n CONCAT_ESCAPE_MACRO ( args , myTargetIndex , targetLength , escSeq , err , len , mySourceIndex ) ;\n continue ;\n }\n else if ( mySourceChar <= 0x7f ) {\n targetUniChar = mySourceChar ;\n }\n else {\n int32_t length = ucnv_MBCSFromUChar32 ( myConverterData -> gbConverter -> sharedData , mySourceChar , & targetUniChar , args -> converter -> useFallback ) ;\n if ( length == 2 && ( uint16_t ) ( targetUniChar - 0xa1a1 ) <= ( 0xfdfe - 0xa1a1 ) && ( uint8_t ) ( targetUniChar - 0xa1 ) <= ( 0xfe - 0xa1 ) ) {\n targetUniChar -= 0x8080 ;\n }\n else {\n targetUniChar = missingCharMarker ;\n }\n }\n if ( targetUniChar != missingCharMarker ) {\n myConverterData -> isTargetUCharDBCS = isTargetUCharDBCS = ( UBool ) ( targetUniChar > 0x00FF ) ;\n if ( oldIsTargetUCharDBCS != isTargetUCharDBCS || ! myConverterData -> isEscapeAppended ) {\n if ( ! isTargetUCharDBCS ) {\n len = ESC_LEN ;\n escSeq = SB_ESCAPE ;\n CONCAT_ESCAPE_MACRO ( args , myTargetIndex , targetLength , escSeq , err , len , mySourceIndex ) ;\n myConverterData -> isEscapeAppended = TRUE ;\n }\n else {\n len = ESC_LEN ;\n escSeq = DB_ESCAPE ;\n CONCAT_ESCAPE_MACRO ( args , myTargetIndex , targetLength , escSeq , err , len , mySourceIndex ) ;\n myConverterData -> isEscapeAppended = TRUE ;\n }\n }\n if ( isTargetUCharDBCS ) {\n if ( myTargetIndex < targetLength ) {\n myTarget [ myTargetIndex ++ ] = ( char ) ( targetUniChar >> 8 ) ;\n if ( offsets ) {\n * ( offsets ++ ) = mySourceIndex - 1 ;\n }\n if ( myTargetIndex < targetLength ) {\n myTarget [ myTargetIndex ++ ] = ( char ) targetUniChar ;\n if ( offsets ) {\n * ( offsets ++ ) = mySourceIndex - 1 ;\n }\n }\n else {\n args -> converter -> charErrorBuffer [ args -> converter -> charErrorBufferLength ++ ] = ( char ) targetUniChar ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n }\n else {\n args -> converter -> charErrorBuffer [ args -> converter -> charErrorBufferLength ++ ] = ( char ) ( targetUniChar >> 8 ) ;\n args -> converter -> charErrorBuffer [ args -> converter -> charErrorBufferLength ++ ] = ( char ) targetUniChar ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n }\n else {\n if ( myTargetIndex < targetLength ) {\n myTarget [ myTargetIndex ++ ] = ( char ) ( targetUniChar ) ;\n if ( offsets ) {\n * ( offsets ++ ) = mySourceIndex - 1 ;\n }\n }\n else {\n args -> converter -> charErrorBuffer [ args -> converter -> charErrorBufferLength ++ ] = ( char ) targetUniChar ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n }\n }\n else {\n if ( U16_IS_SURROGATE ( mySourceChar ) ) {\n if ( U16_IS_SURROGATE_LEAD ( mySourceChar ) ) {\n args -> converter -> fromUChar32 = mySourceChar ;\n getTrail : if ( mySourceIndex < mySourceLength ) {\n UChar trail = ( UChar ) args -> source [ mySourceIndex ] ;\n if ( U16_IS_TRAIL ( trail ) ) {\n ++ mySourceIndex ;\n mySourceChar = U16_GET_SUPPLEMENTARY ( args -> converter -> fromUChar32 , trail ) ;\n args -> converter -> fromUChar32 = 0x00 ;\n * err = U_INVALID_CHAR_FOUND ;\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n else {\n * err = U_ZERO_ERROR ;\n }\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n else {\n * err = U_INVALID_CHAR_FOUND ;\n }\n args -> converter -> fromUChar32 = mySourceChar ;\n break ;\n }\n }\n else {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n targetUniChar = missingCharMarker ;\n }\n args -> target += myTargetIndex ;\n args -> source += mySourceIndex ;\n myConverterData -> isTargetUCharDBCS = isTargetUCharDBCS ;\n }", "hash": 237530479040685467, "project": "chrome", "size": 134, "target": 0, "idx": 18210}
{"code": "static Int decCompare ( const decNumber * lhs , const decNumber * rhs , Flag abs_c ) {\n Int result ;\n Int sigr ;\n Int compare ;\n result = 1 ;\n if ( ISZERO ( lhs ) ) result = 0 ;\n if ( abs_c ) {\n if ( ISZERO ( rhs ) ) return result ;\n if ( result == 0 ) return - 1 ;\n }\n else {\n if ( result && decNumberIsNegative ( lhs ) ) result = - 1 ;\n sigr = 1 ;\n if ( ISZERO ( rhs ) ) sigr = 0 ;\n else if ( decNumberIsNegative ( rhs ) ) sigr = - 1 ;\n if ( result > sigr ) return + 1 ;\n if ( result < sigr ) return - 1 ;\n if ( result == 0 ) return 0 ;\n }\n if ( ( lhs -> bits | rhs -> bits ) & DECINF ) {\n if ( decNumberIsInfinite ( rhs ) ) {\n if ( decNumberIsInfinite ( lhs ) ) result = 0 ;\n else result = - result ;\n }\n return result ;\n }\n if ( lhs -> exponent > rhs -> exponent ) {\n const decNumber * temp = lhs ;\n lhs = rhs ;\n rhs = temp ;\n result = - result ;\n }\n compare = decUnitCompare ( lhs -> lsu , D2U ( lhs -> digits ) , rhs -> lsu , D2U ( rhs -> digits ) , rhs -> exponent - lhs -> exponent ) ;\n if ( compare != BADINT ) compare *= result ;\n return compare ;\n }", "hash": -6872005221209485070, "project": "chrome", "size": 36, "target": 0, "idx": 18235}
{"code": "static decNumber * decNaNs ( decNumber * res , const decNumber * lhs , const decNumber * rhs , decContext * set , uInt * status ) {\n if ( lhs -> bits & DECSNAN ) * status |= DEC_Invalid_operation | DEC_sNaN ;\n else if ( rhs == NULL ) ;\n else if ( rhs -> bits & DECSNAN ) {\n lhs = rhs ;\n * status |= DEC_Invalid_operation | DEC_sNaN ;\n }\n else if ( lhs -> bits & DECNAN ) ;\n else lhs = rhs ;\n if ( lhs -> digits <= set -> digits ) uprv_decNumberCopy ( res , lhs ) ;\n else {\n const Unit * ul ;\n Unit * ur , * uresp1 ;\n res -> bits = lhs -> bits ;\n uresp1 = res -> lsu + D2U ( set -> digits ) ;\n for ( ur = res -> lsu , ul = lhs -> lsu ;\n ur < uresp1 ;\n ur ++ , ul ++ ) * ur = * ul ;\n res -> digits = D2U ( set -> digits ) * DECDPUN ;\n if ( res -> digits > set -> digits ) decDecap ( res , res -> digits - set -> digits ) ;\n }\n res -> bits &= ~ DECSNAN ;\n res -> bits |= DECNAN ;\n res -> exponent = 0 ;\n return res ;\n }", "hash": -6872005221209485070, "project": "chrome", "size": 26, "target": 0, "idx": 18238}
{"code": "static uInt decCheckMath ( const decNumber * rhs , decContext * set , uInt * status ) {\n uInt save = * status ;\n if ( set -> digits > DEC_MAX_MATH || set -> emax > DEC_MAX_MATH || - set -> emin > DEC_MAX_MATH ) * status |= DEC_Invalid_context ;\n else if ( ( rhs -> digits > DEC_MAX_MATH || rhs -> exponent + rhs -> digits > DEC_MAX_MATH + 1 || rhs -> exponent + rhs -> digits < 2 * ( 1 - DEC_MAX_MATH ) ) && ! ISZERO ( rhs ) ) * status |= DEC_Invalid_operation ;\n return ( * status != save ) ;\n }", "hash": -6872005221209485070, "project": "chrome", "size": 6, "target": 0, "idx": 18239}
{"code": "decNumber * decLnOp ( decNumber * res , const decNumber * rhs , decContext * set , uInt * status ) {\n uInt ignore = 0 ;\n uInt needbytes ;\n Int residue ;\n Int r ;\n Int p ;\n Int pp ;\n Int t ;\n decNumber bufa [ D2N ( DECBUFFER + 12 ) ] ;\n decNumber * allocbufa = NULL ;\n decNumber * a = bufa ;\n decNumber bufb [ D2N ( DECBUFFER * 2 + 2 ) ] ;\n decNumber * allocbufb = NULL ;\n decNumber * b = bufb ;\n decNumber numone ;\n decNumber cmp ;\n decContext aset , bset ;\n # if DECCHECK Int iterations = 0 ;\n if ( decCheckOperands ( res , DECUNUSED , rhs , set ) ) return res ;\n # endif do {\n if ( SPECIALARG ) {\n if ( decNumberIsInfinite ( rhs ) ) {\n if ( decNumberIsNegative ( rhs ) ) * status |= DEC_Invalid_operation ;\n else uprv_decNumberCopy ( res , rhs ) ;\n }\n else decNaNs ( res , rhs , NULL , set , status ) ;\n break ;\n }\n if ( ISZERO ( rhs ) ) {\n uprv_decNumberZero ( res ) ;\n res -> bits = DECINF | DECNEG ;\n break ;\n }\n if ( decNumberIsNegative ( rhs ) ) {\n * status |= DEC_Invalid_operation ;\n break ;\n }\n if ( rhs -> exponent == 0 && set -> digits <= 40 ) {\n # if DECDPUN == 1 if ( rhs -> lsu [ 0 ] == 0 && rhs -> lsu [ 1 ] == 1 && rhs -> digits == 2 ) {\n # else if ( rhs -> lsu [ 0 ] == 10 && rhs -> digits == 2 ) {\n # endif aset = * set ;\n aset . round = DEC_ROUND_HALF_EVEN ;\n # define LN10 \"2.302585092994045684017991454684364207601\" uprv_decNumberFromString ( res , LN10 , & aset ) ;\n * status |= ( DEC_Inexact | DEC_Rounded ) ;\n break ;\n }\n if ( rhs -> lsu [ 0 ] == 2 && rhs -> digits == 1 ) {\n aset = * set ;\n aset . round = DEC_ROUND_HALF_EVEN ;\n # define LN2 \"0.6931471805599453094172321214581765680755\" uprv_decNumberFromString ( res , LN2 , & aset ) ;\n * status |= ( DEC_Inexact | DEC_Rounded ) ;\n break ;\n }\n }\n p = MAXI ( rhs -> digits , MAXI ( set -> digits , 7 ) ) + 2 ;\n needbytes = sizeof ( decNumber ) + ( D2U ( MAXI ( p , 16 ) ) - 1 ) * sizeof ( Unit ) ;\n if ( needbytes > sizeof ( bufa ) ) {\n allocbufa = ( decNumber * ) malloc ( needbytes ) ;\n if ( allocbufa == NULL ) {\n * status |= DEC_Insufficient_storage ;\n break ;\n }\n a = allocbufa ;\n }\n pp = p + rhs -> digits ;\n needbytes = sizeof ( decNumber ) + ( D2U ( MAXI ( pp , 16 ) ) - 1 ) * sizeof ( Unit ) ;\n if ( needbytes > sizeof ( bufb ) ) {\n allocbufb = ( decNumber * ) malloc ( needbytes ) ;\n if ( allocbufb == NULL ) {\n * status |= DEC_Insufficient_storage ;\n break ;\n }\n b = allocbufb ;\n }\n uprv_decContextDefault ( & aset , DEC_INIT_DECIMAL64 ) ;\n r = rhs -> exponent + rhs -> digits ;\n uprv_decNumberFromInt32 ( a , r ) ;\n uprv_decNumberFromInt32 ( b , 2302585 ) ;\n b -> exponent = - 6 ;\n decMultiplyOp ( a , a , b , & aset , & ignore ) ;\n residue = 0 ;\n aset . digits = 2 ;\n aset . round = DEC_ROUND_DOWN ;\n decCopyFit ( b , rhs , & aset , & residue , & ignore ) ;\n b -> exponent = 0 ;\n t = decGetInt ( b ) ;\n if ( t < 10 ) t = X10 ( t ) ;\n t = LNnn [ t - 10 ] ;\n uprv_decNumberFromInt32 ( b , t >> 2 ) ;\n b -> exponent = - ( t & 3 ) - 3 ;\n b -> bits = DECNEG ;\n aset . digits = 16 ;\n aset . round = DEC_ROUND_HALF_EVEN ;\n decAddOp ( a , a , b , & aset , 0 , & ignore ) ;\n uprv_decNumberZero ( & numone ) ;\n * numone . lsu = 1 ;\n aset . emax = set -> emax ;\n aset . emin = set -> emin ;\n aset . clamp = 0 ;\n bset = aset ;\n bset . emax = DEC_MAX_MATH * 2 ;\n bset . emin = - DEC_MAX_MATH * 2 ;\n pp = 9 ;\n aset . digits = pp ;\n bset . digits = pp + rhs -> digits ;\n for ( ;\n ;\n ) {\n # if DECCHECK iterations ++ ;\n if ( iterations > 24 ) break ;\n # endif a -> bits ^= DECNEG ;\n decExpOp ( b , a , & bset , & ignore ) ;\n a -> bits ^= DECNEG ;\n decMultiplyOp ( b , b , rhs , & bset , & ignore ) ;\n decAddOp ( b , b , & numone , & bset , DECNEG , & ignore ) ;\n if ( decNumberIsZero ( b ) || ( a -> digits + a -> exponent ) >= ( b -> digits + b -> exponent + set -> digits + 1 ) ) {\n if ( a -> digits == p ) break ;\n if ( decNumberIsZero ( a ) ) {\n decCompareOp ( & cmp , rhs , & numone , & aset , COMPARE , & ignore ) ;\n if ( cmp . lsu [ 0 ] == 0 ) a -> exponent = 0 ;\n else * status |= ( DEC_Inexact | DEC_Rounded ) ;\n break ;\n }\n if ( decNumberIsZero ( b ) ) b -> exponent = a -> exponent - p ;\n }\n decAddOp ( a , a , b , & aset , 0 , & ignore ) ;\n if ( pp == p ) continue ;\n pp = pp * 2 ;\n if ( pp > p ) pp = p ;\n aset . digits = pp ;\n bset . digits = pp + rhs -> digits ;\n }\n # if DECCHECK if ( iterations > 24 ) printf ( \"Ln iterations=%ld, status=%08lx, p=%ld, d=%ld\\n\" , ( LI ) iterations , ( LI ) * status , ( LI ) p , ( LI ) rhs -> digits ) ;\n # endif residue = 1 ;\n if ( ISZERO ( a ) ) residue = 0 ;\n aset . digits = set -> digits ;\n decCopyFit ( res , a , & aset , & residue , status ) ;\n decFinish ( res , set , & residue , status ) ;\n }\n while ( 0 ) ;\n if ( allocbufa != NULL ) free ( allocbufa ) ;\n if ( allocbufb != NULL ) free ( allocbufb ) ;\n return res ;\n }", "hash": -6872005221209485070, "project": "chrome", "size": 144, "target": 0, "idx": 18240}
{"code": "static void U_CALLCONV _UTF16LEFromUnicodeWithOffsets ( UConverterFromUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n UConverter * cnv ;\n const UChar * source ;\n char * target ;\n int32_t * offsets ;\n uint32_t targetCapacity , length , sourceIndex ;\n UChar c , trail ;\n char overflow [ 4 ] ;\n source = pArgs -> source ;\n length = ( int32_t ) ( pArgs -> sourceLimit - source ) ;\n if ( length <= 0 ) {\n return ;\n }\n cnv = pArgs -> converter ;\n if ( cnv -> fromUnicodeStatus == UCNV_NEED_TO_WRITE_BOM ) {\n static const char bom [ ] = {\n ( char ) 0xff , ( char ) 0xfe }\n ;\n ucnv_fromUWriteBytes ( cnv , bom , 2 , & pArgs -> target , pArgs -> targetLimit , & pArgs -> offsets , - 1 , pErrorCode ) ;\n cnv -> fromUnicodeStatus = 0 ;\n }\n target = pArgs -> target ;\n if ( target >= pArgs -> targetLimit ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n return ;\n }\n targetCapacity = ( uint32_t ) ( pArgs -> targetLimit - pArgs -> target ) ;\n offsets = pArgs -> offsets ;\n sourceIndex = 0 ;\n if ( ( c = ( UChar ) cnv -> fromUChar32 ) != 0 && U16_IS_TRAIL ( trail = * source ) && targetCapacity >= 4 ) {\n ++ source ;\n -- length ;\n target [ 0 ] = ( uint8_t ) c ;\n target [ 1 ] = ( uint8_t ) ( c >> 8 ) ;\n target [ 2 ] = ( uint8_t ) trail ;\n target [ 3 ] = ( uint8_t ) ( trail >> 8 ) ;\n target += 4 ;\n targetCapacity -= 4 ;\n if ( offsets != NULL ) {\n * offsets ++ = - 1 ;\n * offsets ++ = - 1 ;\n * offsets ++ = - 1 ;\n * offsets ++ = - 1 ;\n }\n sourceIndex = 1 ;\n cnv -> fromUChar32 = c = 0 ;\n }\n if ( c == 0 ) {\n uint32_t count = 2 * length ;\n if ( count > targetCapacity ) {\n count = targetCapacity & ~ 1 ;\n }\n targetCapacity -= count ;\n count >>= 1 ;\n length -= count ;\n if ( offsets == NULL ) {\n while ( count > 0 ) {\n c = * source ++ ;\n if ( U16_IS_SINGLE ( c ) ) {\n target [ 0 ] = ( uint8_t ) c ;\n target [ 1 ] = ( uint8_t ) ( c >> 8 ) ;\n target += 2 ;\n }\n else if ( U16_IS_SURROGATE_LEAD ( c ) && count >= 2 && U16_IS_TRAIL ( trail = * source ) ) {\n ++ source ;\n -- count ;\n target [ 0 ] = ( uint8_t ) c ;\n target [ 1 ] = ( uint8_t ) ( c >> 8 ) ;\n target [ 2 ] = ( uint8_t ) trail ;\n target [ 3 ] = ( uint8_t ) ( trail >> 8 ) ;\n target += 4 ;\n }\n else {\n break ;\n }\n -- count ;\n }\n }\n else {\n while ( count > 0 ) {\n c = * source ++ ;\n if ( U16_IS_SINGLE ( c ) ) {\n target [ 0 ] = ( uint8_t ) c ;\n target [ 1 ] = ( uint8_t ) ( c >> 8 ) ;\n target += 2 ;\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ++ ;\n }\n else if ( U16_IS_SURROGATE_LEAD ( c ) && count >= 2 && U16_IS_TRAIL ( trail = * source ) ) {\n ++ source ;\n -- count ;\n target [ 0 ] = ( uint8_t ) c ;\n target [ 1 ] = ( uint8_t ) ( c >> 8 ) ;\n target [ 2 ] = ( uint8_t ) trail ;\n target [ 3 ] = ( uint8_t ) ( trail >> 8 ) ;\n target += 4 ;\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ;\n sourceIndex += 2 ;\n }\n else {\n break ;\n }\n -- count ;\n }\n }\n if ( count == 0 ) {\n if ( length > 0 && targetCapacity > 0 ) {\n if ( U16_IS_SINGLE ( c = * source ++ ) ) {\n overflow [ 0 ] = ( char ) c ;\n overflow [ 1 ] = ( char ) ( c >> 8 ) ;\n length = 2 ;\n c = 0 ;\n }\n }\n else {\n length = 0 ;\n c = 0 ;\n }\n }\n else {\n targetCapacity += 2 * count ;\n }\n }\n else {\n length = 0 ;\n }\n if ( c != 0 ) {\n length = 0 ;\n if ( U16_IS_SURROGATE_LEAD ( c ) ) {\n if ( source < pArgs -> sourceLimit ) {\n if ( U16_IS_TRAIL ( trail = * source ) ) {\n ++ source ;\n overflow [ 0 ] = ( char ) c ;\n overflow [ 1 ] = ( char ) ( c >> 8 ) ;\n overflow [ 2 ] = ( char ) trail ;\n overflow [ 3 ] = ( char ) ( trail >> 8 ) ;\n length = 4 ;\n c = 0 ;\n }\n else {\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n else {\n }\n }\n else {\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n }\n cnv -> fromUChar32 = c ;\n }\n if ( length > 0 ) {\n ucnv_fromUWriteBytes ( cnv , overflow , length , & target , pArgs -> targetLimit , & offsets , sourceIndex , pErrorCode ) ;\n targetCapacity = ( uint32_t ) ( pArgs -> targetLimit - ( char * ) target ) ;\n }\n if ( U_SUCCESS ( * pErrorCode ) && source < pArgs -> sourceLimit && targetCapacity == 0 ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n }\n pArgs -> source = source ;\n pArgs -> target = target ;\n pArgs -> offsets = offsets ;\n }", "hash": -7049333455584635197, "project": "chrome", "size": 165, "target": 0, "idx": 18264}
{"code": "static void U_CALLCONV _UTF16LEReset ( UConverter * cnv , UConverterResetChoice choice ) {\n if ( choice <= UCNV_RESET_TO_UNICODE ) {\n if ( UCNV_GET_VERSION ( cnv ) == 0 ) {\n cnv -> mode = 8 ;\n }\n else {\n cnv -> mode = 0 ;\n }\n }\n if ( choice != UCNV_RESET_TO_UNICODE && UCNV_GET_VERSION ( cnv ) == 1 ) {\n cnv -> fromUnicodeStatus = UCNV_NEED_TO_WRITE_BOM ;\n }\n }", "hash": -7049333455584635197, "project": "chrome", "size": 13, "target": 0, "idx": 18269}
{"code": "void ufmt_ptou ( UChar * buffer , int32_t * len , void * value , UBool uselower ) {\n int32_t i ;\n int32_t length = 0 ;\n uint8_t * ptrIdx = ( uint8_t * ) & value ;\n # if U_IS_BIG_ENDIAN for ( i = 0 ;\n i < ( int32_t ) sizeof ( void * ) ;\n i ++ ) # else for ( i = ( int32_t ) sizeof ( void * ) - 1 ;\n i >= 0 ;\n i -- ) # endif {\n uint8_t byteVal = ptrIdx [ i ] ;\n uint16_t firstNibble = ( uint16_t ) ( byteVal >> 4 ) ;\n uint16_t secondNibble = ( uint16_t ) ( byteVal & 0xF ) ;\n if ( uselower ) {\n buffer [ length ++ ] = TO_LC_DIGIT ( firstNibble ) ;\n buffer [ length ++ ] = TO_LC_DIGIT ( secondNibble ) ;\n }\n else {\n buffer [ length ++ ] = TO_UC_DIGIT ( firstNibble ) ;\n buffer [ length ++ ] = TO_UC_DIGIT ( secondNibble ) ;\n }\n }\n * len = length ;\n }", "hash": -396651088599502783, "project": "chrome", "size": 23, "target": 0, "idx": 18297}
{"code": "UBool ufmt_isdigit ( UChar c , int32_t radix ) {\n int digitVal = ufmt_digitvalue ( c ) ;\n return ( UBool ) ( digitVal < radix && digitVal >= 0 ) ;\n }", "hash": -396651088599502783, "project": "chrome", "size": 4, "target": 0, "idx": 18298}
{"code": "static void U_CALLCONV ucnv_toUnicode_UTF8_OFFSETS_LOGIC ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n UConverter * cnv = args -> converter ;\n const unsigned char * mySource = ( unsigned char * ) args -> source ;\n UChar * myTarget = args -> target ;\n int32_t * myOffsets = args -> offsets ;\n int32_t offsetNum = 0 ;\n const unsigned char * sourceLimit = ( unsigned char * ) args -> sourceLimit ;\n const UChar * targetLimit = args -> targetLimit ;\n unsigned char * toUBytes = cnv -> toUBytes ;\n UBool isCESU8 = hasCESU8Data ( cnv ) ;\n uint32_t ch , ch2 = 0 ;\n int32_t i , inBytes ;\n if ( cnv -> toUnicodeStatus && myTarget < targetLimit ) {\n inBytes = cnv -> mode ;\n i = cnv -> toULength ;\n cnv -> toULength = 0 ;\n ch = cnv -> toUnicodeStatus ;\n cnv -> toUnicodeStatus = 0 ;\n goto morebytes ;\n }\n while ( mySource < sourceLimit && myTarget < targetLimit ) {\n ch = * ( mySource ++ ) ;\n if ( ch < 0x80 ) {\n * ( myTarget ++ ) = ( UChar ) ch ;\n * ( myOffsets ++ ) = offsetNum ++ ;\n }\n else {\n toUBytes [ 0 ] = ( char ) ch ;\n inBytes = bytesFromUTF8 [ ch ] ;\n i = 1 ;\n morebytes : while ( i < inBytes ) {\n if ( mySource < sourceLimit ) {\n toUBytes [ i ] = ( char ) ( ch2 = * mySource ) ;\n if ( ! U8_IS_TRAIL ( ch2 ) ) {\n break ;\n }\n ch = ( ch << 6 ) + ch2 ;\n ++ mySource ;\n i ++ ;\n }\n else {\n cnv -> toUnicodeStatus = ch ;\n cnv -> mode = inBytes ;\n cnv -> toULength = ( int8_t ) i ;\n goto donefornow ;\n }\n }\n ch -= offsetsFromUTF8 [ inBytes ] ;\n if ( i == inBytes && ch <= MAXIMUM_UTF && ch >= utf8_minChar32 [ i ] && ( isCESU8 ? i <= 3 : ! U_IS_SURROGATE ( ch ) ) ) {\n if ( ch <= MAXIMUM_UCS2 ) {\n * ( myTarget ++ ) = ( UChar ) ch ;\n * ( myOffsets ++ ) = offsetNum ;\n }\n else {\n ch -= HALF_BASE ;\n * ( myTarget ++ ) = ( UChar ) ( ( ch >> HALF_SHIFT ) + SURROGATE_HIGH_START ) ;\n * ( myOffsets ++ ) = offsetNum ;\n ch = ( ch & HALF_MASK ) + SURROGATE_LOW_START ;\n if ( myTarget < targetLimit ) {\n * ( myTarget ++ ) = ( UChar ) ch ;\n * ( myOffsets ++ ) = offsetNum ;\n }\n else {\n cnv -> UCharErrorBuffer [ 0 ] = ( UChar ) ch ;\n cnv -> UCharErrorBufferLength = 1 ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n }\n offsetNum += i ;\n }\n else {\n cnv -> toULength = ( int8_t ) i ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n }\n donefornow : if ( mySource < sourceLimit && myTarget >= targetLimit && U_SUCCESS ( * err ) ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n args -> target = myTarget ;\n args -> source = ( const char * ) mySource ;\n args -> offsets = myOffsets ;\n }", "hash": -7899851216763489956, "project": "chrome", "size": 84, "target": 0, "idx": 18300}
{"code": "static void U_CALLCONV ucnv_toUnicode_UTF8 ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n UConverter * cnv = args -> converter ;\n const unsigned char * mySource = ( unsigned char * ) args -> source ;\n UChar * myTarget = args -> target ;\n const unsigned char * sourceLimit = ( unsigned char * ) args -> sourceLimit ;\n const UChar * targetLimit = args -> targetLimit ;\n unsigned char * toUBytes = cnv -> toUBytes ;\n UBool isCESU8 = hasCESU8Data ( cnv ) ;\n uint32_t ch , ch2 = 0 ;\n int32_t i , inBytes ;\n if ( cnv -> toUnicodeStatus && myTarget < targetLimit ) {\n inBytes = cnv -> mode ;\n i = cnv -> toULength ;\n cnv -> toULength = 0 ;\n ch = cnv -> toUnicodeStatus ;\n cnv -> toUnicodeStatus = 0 ;\n goto morebytes ;\n }\n while ( mySource < sourceLimit && myTarget < targetLimit ) {\n ch = * ( mySource ++ ) ;\n if ( ch < 0x80 ) {\n * ( myTarget ++ ) = ( UChar ) ch ;\n }\n else {\n toUBytes [ 0 ] = ( char ) ch ;\n inBytes = bytesFromUTF8 [ ch ] ;\n i = 1 ;\n morebytes : while ( i < inBytes ) {\n if ( mySource < sourceLimit ) {\n toUBytes [ i ] = ( char ) ( ch2 = * mySource ) ;\n if ( ! U8_IS_TRAIL ( ch2 ) ) {\n break ;\n }\n ch = ( ch << 6 ) + ch2 ;\n ++ mySource ;\n i ++ ;\n }\n else {\n cnv -> toUnicodeStatus = ch ;\n cnv -> mode = inBytes ;\n cnv -> toULength = ( int8_t ) i ;\n goto donefornow ;\n }\n }\n ch -= offsetsFromUTF8 [ inBytes ] ;\n if ( i == inBytes && ch <= MAXIMUM_UTF && ch >= utf8_minChar32 [ i ] && ( isCESU8 ? i <= 3 : ! U_IS_SURROGATE ( ch ) ) ) {\n if ( ch <= MAXIMUM_UCS2 ) {\n * ( myTarget ++ ) = ( UChar ) ch ;\n }\n else {\n ch -= HALF_BASE ;\n * ( myTarget ++ ) = ( UChar ) ( ( ch >> HALF_SHIFT ) + SURROGATE_HIGH_START ) ;\n ch = ( ch & HALF_MASK ) + SURROGATE_LOW_START ;\n if ( myTarget < targetLimit ) {\n * ( myTarget ++ ) = ( UChar ) ch ;\n }\n else {\n cnv -> UCharErrorBuffer [ 0 ] = ( UChar ) ch ;\n cnv -> UCharErrorBufferLength = 1 ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n }\n }\n else {\n cnv -> toULength = ( int8_t ) i ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n }\n donefornow : if ( mySource < sourceLimit && myTarget >= targetLimit && U_SUCCESS ( * err ) ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n args -> target = myTarget ;\n args -> source = ( const char * ) mySource ;\n }", "hash": -7899851216763489956, "project": "chrome", "size": 77, "target": 0, "idx": 18303}
{"code": "void printEachBackward ( UBreakIterator * boundary , UChar * str ) {\n int32_t start ;\n int32_t end = ubrk_last ( boundary ) ;\n for ( start = ubrk_previous ( boundary ) ;\n start != UBRK_DONE ;\n end = start , start = ubrk_previous ( boundary ) ) {\n printTextRange ( str , start , end ) ;\n }\n }", "hash": -2001852372520287494, "project": "chrome", "size": 9, "target": 0, "idx": 18310}
{"code": "static void push ( UScriptRun * scriptRun , int32_t pairIndex , UScriptCode scriptCode ) {\n scriptRun -> pushCount = LIMIT_INC ( scriptRun -> pushCount ) ;\n scriptRun -> fixupCount = LIMIT_INC ( scriptRun -> fixupCount ) ;\n scriptRun -> parenSP = INC1 ( scriptRun -> parenSP ) ;\n scriptRun -> parenStack [ scriptRun -> parenSP ] . pairIndex = pairIndex ;\n scriptRun -> parenStack [ scriptRun -> parenSP ] . scriptCode = scriptCode ;\n }", "hash": -7510820116196812813, "project": "chrome", "size": 7, "target": 0, "idx": 18313}
{"code": "static void fixup ( UScriptRun * scriptRun , UScriptCode scriptCode ) {\n int32_t fixupSP = DEC ( scriptRun -> parenSP , scriptRun -> fixupCount ) ;\n while ( scriptRun -> fixupCount -- > 0 ) {\n fixupSP = INC1 ( fixupSP ) ;\n scriptRun -> parenStack [ fixupSP ] . scriptCode = scriptCode ;\n }\n }", "hash": -7510820116196812813, "project": "chrome", "size": 7, "target": 0, "idx": 18314}
{"code": "static void reorderLine ( UBiDi * pBiDi , UBiDiLevel minLevel , UBiDiLevel maxLevel ) {\n Run * runs , tempRun ;\n UBiDiLevel * levels ;\n int32_t firstRun , endRun , limitRun , runCount ;\n if ( maxLevel <= ( minLevel | 1 ) ) {\n return ;\n }\n ++ minLevel ;\n runs = pBiDi -> runs ;\n levels = pBiDi -> levels ;\n runCount = pBiDi -> runCount ;\n if ( pBiDi -> trailingWSStart < pBiDi -> length ) {\n -- runCount ;\n }\n while ( -- maxLevel >= minLevel ) {\n firstRun = 0 ;\n for ( ;\n ;\n ) {\n while ( firstRun < runCount && levels [ runs [ firstRun ] . logicalStart ] < maxLevel ) {\n ++ firstRun ;\n }\n if ( firstRun >= runCount ) {\n break ;\n }\n for ( limitRun = firstRun ;\n ++ limitRun < runCount && levels [ runs [ limitRun ] . logicalStart ] >= maxLevel ;\n ) {\n }\n endRun = limitRun - 1 ;\n while ( firstRun < endRun ) {\n tempRun = runs [ firstRun ] ;\n runs [ firstRun ] = runs [ endRun ] ;\n runs [ endRun ] = tempRun ;\n ++ firstRun ;\n -- endRun ;\n }\n if ( limitRun == runCount ) {\n break ;\n }\n else {\n firstRun = limitRun + 1 ;\n }\n }\n }\n if ( ! ( minLevel & 1 ) ) {\n firstRun = 0 ;\n if ( pBiDi -> trailingWSStart == pBiDi -> length ) {\n -- runCount ;\n }\n while ( firstRun < runCount ) {\n tempRun = runs [ firstRun ] ;\n runs [ firstRun ] = runs [ runCount ] ;\n runs [ runCount ] = tempRun ;\n ++ firstRun ;\n -- runCount ;\n }\n }\n }", "hash": 3966033627990943399, "project": "chrome", "size": 59, "target": 0, "idx": 18321}
{"code": "static inline void uprv_arrayCopy ( const icu : : UnicodeString * src , int32_t srcStart , icu : : UnicodeString * dst , int32_t dstStart , int32_t count ) {\n uprv_arrayCopy ( src + srcStart , dst + dstStart , count ) ;\n }", "hash": -273984976102410662, "project": "chrome", "size": 3, "target": 0, "idx": 18334}
{"code": "static UBool action_resolve ( UBiDiTransform * pTransform , UErrorCode * pErrorCode ) {\n ubidi_setPara ( pTransform -> pBidi , pTransform -> src , pTransform -> srcLength , pTransform -> pActiveScheme -> baseLevel , NULL , pErrorCode ) ;\n return FALSE ;\n }", "hash": 3761858035663259067, "project": "chrome", "size": 4, "target": 0, "idx": 18361}
{"code": "static void U_CALLCONV T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC ( UConverterFromUnicodeArgs * args , UErrorCode * err ) {\n const UChar * mySource = args -> source ;\n unsigned char * myTarget ;\n int32_t * myOffsets ;\n const UChar * sourceLimit = args -> sourceLimit ;\n const unsigned char * targetLimit = ( unsigned char * ) args -> targetLimit ;\n UChar32 ch , ch2 ;\n unsigned int indexToWrite ;\n unsigned char temp [ sizeof ( uint32_t ) ] ;\n int32_t offsetNum = 0 ;\n if ( mySource >= sourceLimit ) {\n return ;\n }\n if ( args -> converter -> fromUnicodeStatus == UCNV_NEED_TO_WRITE_BOM ) {\n static const char bom [ ] = {\n ( char ) 0xff , ( char ) 0xfe , 0 , 0 }\n ;\n ucnv_fromUWriteBytes ( args -> converter , bom , 4 , & args -> target , args -> targetLimit , & args -> offsets , - 1 , err ) ;\n args -> converter -> fromUnicodeStatus = 0 ;\n }\n myTarget = ( unsigned char * ) args -> target ;\n myOffsets = args -> offsets ;\n temp [ 3 ] = 0 ;\n if ( args -> converter -> fromUChar32 ) {\n ch = args -> converter -> fromUChar32 ;\n args -> converter -> fromUChar32 = 0 ;\n goto lowsurogate ;\n }\n while ( mySource < sourceLimit && myTarget < targetLimit ) {\n ch = * ( mySource ++ ) ;\n if ( U16_IS_SURROGATE ( ch ) ) {\n if ( U16_IS_LEAD ( ch ) ) {\n lowsurogate : if ( mySource < sourceLimit ) {\n ch2 = * mySource ;\n if ( U16_IS_TRAIL ( ch2 ) ) {\n ch = ( ( ch - SURROGATE_HIGH_START ) << HALF_SHIFT ) + ch2 + SURROGATE_LOW_BASE ;\n mySource ++ ;\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n if ( args -> flush ) {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n break ;\n }\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n temp [ 2 ] = ( uint8_t ) ( ch >> 16 & 0x1F ) ;\n temp [ 1 ] = ( uint8_t ) ( ch >> 8 ) ;\n temp [ 0 ] = ( uint8_t ) ( ch ) ;\n for ( indexToWrite = 0 ;\n indexToWrite <= sizeof ( uint32_t ) - 1 ;\n indexToWrite ++ ) {\n if ( myTarget < targetLimit ) {\n * ( myTarget ++ ) = temp [ indexToWrite ] ;\n * ( myOffsets ++ ) = offsetNum ;\n }\n else {\n args -> converter -> charErrorBuffer [ args -> converter -> charErrorBufferLength ++ ] = temp [ indexToWrite ] ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n }\n offsetNum = offsetNum + 1 + ( temp [ 2 ] != 0 ) ;\n }\n if ( mySource < sourceLimit && myTarget >= targetLimit && U_SUCCESS ( * err ) ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n args -> target = ( char * ) myTarget ;\n args -> source = mySource ;\n args -> offsets = myOffsets ;\n }", "hash": 1891617106617090004, "project": "chrome", "size": 82, "target": 0, "idx": 18395}
{"code": "static int32_t u_scanf_spellout_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n ( void ) fmt ;\n ( void ) fmtConsumed ;\n int32_t len ;\n double num ;\n UNumberFormat * format ;\n int32_t parsePos = 0 ;\n int32_t skipped ;\n UErrorCode status = U_ZERO_ERROR ;\n skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;\n ufile_fill_uchar_buffer ( input ) ;\n len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;\n if ( info -> fWidth != - 1 ) len = ufmt_min ( len , info -> fWidth ) ;\n format = u_locbund_getNumberFormat ( & input -> str . fBundle , UNUM_SPELLOUT ) ;\n if ( format == 0 ) return 0 ;\n num = unum_parseDouble ( format , input -> str . fPos , len , & parsePos , & status ) ;\n if ( ! info -> fSkipArg ) {\n * ( double * ) ( args [ 0 ] . ptrValue ) = num ;\n }\n input -> str . fPos += parsePos ;\n * argConverted = ! info -> fSkipArg ;\n return parsePos + skipped ;\n }", "hash": -8704451445127642833, "project": "chrome", "size": 23, "target": 0, "idx": 18408}
{"code": "static int32_t u_scanf_octal_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n ( void ) fmt ;\n ( void ) fmtConsumed ;\n int32_t len ;\n int32_t skipped ;\n void * num = ( void * ) ( args [ 0 ] . ptrValue ) ;\n int64_t result ;\n skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;\n ufile_fill_uchar_buffer ( input ) ;\n len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;\n if ( info -> fWidth != - 1 ) len = ufmt_min ( len , info -> fWidth ) ;\n result = ufmt_uto64 ( input -> str . fPos , & len , 8 ) ;\n input -> str . fPos += len ;\n if ( ! info -> fSkipArg ) {\n if ( info -> fIsShort ) * ( int16_t * ) num = ( int16_t ) ( UINT16_MAX & result ) ;\n else if ( info -> fIsLongLong ) * ( int64_t * ) num = result ;\n else * ( int32_t * ) num = ( int32_t ) ( UINT32_MAX & result ) ;\n }\n * argConverted = ! info -> fSkipArg ;\n return len + skipped ;\n }", "hash": -8704451445127642833, "project": "chrome", "size": 21, "target": 0, "idx": 18409}
{"code": "static int32_t u_scanf_uchar_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n if ( info -> fWidth < 0 ) {\n info -> fWidth = 1 ;\n }\n info -> fIsString = FALSE ;\n return u_scanf_ustring_handler ( input , info , args , fmt , fmtConsumed , argConverted ) ;\n }", "hash": -8704451445127642833, "project": "chrome", "size": 7, "target": 0, "idx": 18417}
{"code": "static void print_month ( UCalendar * c , UChar * days [ ] , UBool useLongNames , int32_t fdow , UErrorCode * status ) {\n int32_t width , pad , i , day ;\n int32_t lens [ DAY_COUNT ] ;\n int32_t firstday , current ;\n UNumberFormat * nfmt ;\n UDateFormat * dfmt ;\n UChar s [ BUF_SIZE ] ;\n const UChar * pat = ( useLongNames ? sLongPat : sShortPat ) ;\n int32_t len = ( useLongNames ? 9 : 8 ) ;\n if ( U_FAILURE ( * status ) ) return ;\n dfmt = udat_open ( UDAT_PATTERN , UDAT_PATTERN , NULL , NULL , 0 , pat , len , status ) ;\n udat_format ( dfmt , ucal_getMillis ( c , status ) , s , BUF_SIZE , 0 , status ) ;\n get_days ( dfmt , days , useLongNames , fdow , status ) ;\n width = 6 ;\n for ( i = 0 ;\n i < DAY_COUNT ;\n ++ i ) {\n lens [ i ] = u_strlen ( days [ i ] ) ;\n width += lens [ i ] ;\n }\n pad = width - u_strlen ( s ) ;\n indent ( pad / 2 , stdout ) ;\n uprint ( s , stdout , status ) ;\n putc ( '\\n' , stdout ) ;\n print_days ( days , stdout , status ) ;\n putc ( '\\n' , stdout ) ;\n ucal_set ( c , UCAL_DATE , 1 ) ;\n firstday = ucal_get ( c , UCAL_DAY_OF_WEEK , status ) ;\n firstday -= fdow ;\n nfmt = unum_open ( UNUM_DECIMAL , NULL , 0 , NULL , NULL , status ) ;\n current = firstday ;\n if ( current < 0 ) {\n current += 7 ;\n }\n for ( i = 0 ;\n i < current ;\n ++ i ) indent ( lens [ i ] + 1 , stdout ) ;\n day = ucal_get ( c , UCAL_DATE , status ) ;\n do {\n unum_format ( nfmt , day , s , BUF_SIZE , 0 , status ) ;\n pad = lens [ current ] - u_strlen ( s ) ;\n indent ( pad , stdout ) ;\n uprint ( s , stdout , status ) ;\n putc ( ' ' , stdout ) ;\n ++ current ;\n current %= DAY_COUNT ;\n if ( current == 0 ) {\n putc ( '\\n' , stdout ) ;\n }\n ucal_add ( c , UCAL_DATE , 1 , status ) ;\n day = ucal_get ( c , UCAL_DATE , status ) ;\n }\n while ( day != 1 ) ;\n putc ( '\\n' , stdout ) ;\n free_days ( days ) ;\n unum_close ( nfmt ) ;\n udat_close ( dfmt ) ;\n }", "hash": 4208859344475020583, "project": "chrome", "size": 58, "target": 0, "idx": 18448}
{"code": "static UBool CnvExtIsValid ( NewConverter * cnvData , const uint8_t * bytes , int32_t length ) {\n return FALSE ;\n }", "hash": 373200843854506734, "project": "chrome", "size": 3, "target": 0, "idx": 18453}
{"code": "static uint32_t CnvExtWrite ( NewConverter * cnvData , const UConverterStaticData * staticData , UNewDataMemory * pData , int32_t tableType ) {\n CnvExtData * extData = ( CnvExtData * ) cnvData ;\n int32_t length , top , headerSize ;\n int32_t indexes [ UCNV_EXT_INDEXES_MIN_LENGTH ] = {\n 0 }\n ;\n if ( tableType & TABLE_BASE ) {\n headerSize = 0 ;\n }\n else {\n _MBCSHeader header = {\n {\n 0 , 0 , 0 , 0 }\n , 0 , 0 , 0 , 0 , 0 , 0 , 0 }\n ;\n length = ( int32_t ) uprv_strlen ( extData -> ucm -> baseName ) + 1 ;\n while ( length & 3 ) {\n extData -> ucm -> baseName [ length ++ ] = 0 ;\n }\n headerSize = MBCS_HEADER_V4_LENGTH * 4 + length ;\n header . version [ 0 ] = 4 ;\n header . version [ 1 ] = 2 ;\n header . flags = ( uint32_t ) ( ( headerSize << 8 ) | MBCS_OUTPUT_EXT_ONLY ) ;\n udata_writeBlock ( pData , & header , MBCS_HEADER_V4_LENGTH * 4 ) ;\n udata_writeBlock ( pData , extData -> ucm -> baseName , length ) ;\n }\n top = 0 ;\n indexes [ UCNV_EXT_INDEXES_LENGTH ] = length = UCNV_EXT_INDEXES_MIN_LENGTH ;\n top += length * 4 ;\n indexes [ UCNV_EXT_TO_U_INDEX ] = top ;\n indexes [ UCNV_EXT_TO_U_LENGTH ] = length = utm_countItems ( extData -> toUTable ) ;\n top += length * 4 ;\n indexes [ UCNV_EXT_TO_U_UCHARS_INDEX ] = top ;\n indexes [ UCNV_EXT_TO_U_UCHARS_LENGTH ] = length = utm_countItems ( extData -> toUUChars ) ;\n top += length * 2 ;\n indexes [ UCNV_EXT_FROM_U_UCHARS_INDEX ] = top ;\n length = utm_countItems ( extData -> fromUTableUChars ) ;\n top += length * 2 ;\n if ( top & 3 ) {\n * ( ( UChar * ) utm_alloc ( extData -> fromUTableUChars ) ) = 0 ;\n * ( ( uint32_t * ) utm_alloc ( extData -> fromUTableValues ) ) = 0 ;\n ++ length ;\n top += 2 ;\n }\n indexes [ UCNV_EXT_FROM_U_LENGTH ] = length ;\n indexes [ UCNV_EXT_FROM_U_VALUES_INDEX ] = top ;\n top += length * 4 ;\n indexes [ UCNV_EXT_FROM_U_BYTES_INDEX ] = top ;\n length = utm_countItems ( extData -> fromUBytes ) ;\n top += length ;\n if ( top & 1 ) {\n * ( ( uint8_t * ) utm_alloc ( extData -> fromUBytes ) ) = 0 ;\n ++ length ;\n ++ top ;\n }\n indexes [ UCNV_EXT_FROM_U_BYTES_LENGTH ] = length ;\n indexes [ UCNV_EXT_FROM_U_STAGE_12_INDEX ] = top ;\n indexes [ UCNV_EXT_FROM_U_STAGE_1_LENGTH ] = length = extData -> stage1Top ;\n indexes [ UCNV_EXT_FROM_U_STAGE_12_LENGTH ] = length += extData -> stage2Top ;\n top += length * 2 ;\n indexes [ UCNV_EXT_FROM_U_STAGE_3_INDEX ] = top ;\n length = extData -> stage3Top ;\n top += length * 2 ;\n if ( top & 3 ) {\n extData -> stage3 [ extData -> stage3Top ++ ] = 0 ;\n ++ length ;\n top += 2 ;\n }\n indexes [ UCNV_EXT_FROM_U_STAGE_3_LENGTH ] = length ;\n indexes [ UCNV_EXT_FROM_U_STAGE_3B_INDEX ] = top ;\n indexes [ UCNV_EXT_FROM_U_STAGE_3B_LENGTH ] = length = extData -> stage3bTop ;\n top += length * 4 ;\n indexes [ UCNV_EXT_SIZE ] = top ;\n indexes [ UCNV_EXT_COUNT_BYTES ] = ( extData -> maxInBytes << 16 ) | ( extData -> maxOutBytes << 8 ) | extData -> maxBytesPerUChar ;\n indexes [ UCNV_EXT_COUNT_UCHARS ] = ( extData -> maxInUChars << 16 ) | ( extData -> maxOutUChars << 8 ) | extData -> maxUCharsPerByte ;\n indexes [ UCNV_EXT_FLAGS ] = extData -> ucm -> ext -> unicodeMask ;\n udata_writeBlock ( pData , indexes , sizeof ( indexes ) ) ;\n udata_writeBlock ( pData , utm_getStart ( extData -> toUTable ) , indexes [ UCNV_EXT_TO_U_LENGTH ] * 4 ) ;\n udata_writeBlock ( pData , utm_getStart ( extData -> toUUChars ) , indexes [ UCNV_EXT_TO_U_UCHARS_LENGTH ] * 2 ) ;\n udata_writeBlock ( pData , utm_getStart ( extData -> fromUTableUChars ) , indexes [ UCNV_EXT_FROM_U_LENGTH ] * 2 ) ;\n udata_writeBlock ( pData , utm_getStart ( extData -> fromUTableValues ) , indexes [ UCNV_EXT_FROM_U_LENGTH ] * 4 ) ;\n udata_writeBlock ( pData , utm_getStart ( extData -> fromUBytes ) , indexes [ UCNV_EXT_FROM_U_BYTES_LENGTH ] ) ;\n udata_writeBlock ( pData , extData -> stage1 , extData -> stage1Top * 2 ) ;\n udata_writeBlock ( pData , extData -> stage2 , extData -> stage2Top * 2 ) ;\n udata_writeBlock ( pData , extData -> stage3 , extData -> stage3Top * 2 ) ;\n udata_writeBlock ( pData , extData -> stage3b , extData -> stage3bTop * 4 ) ;\n # if 0 {\n int32_t i , j ;\n length = extData -> stage1Top ;\n printf ( \"\\nstage1[%x]:\\n\" , length ) ;\n for ( i = 0 ;\n i < length ;\n ++ i ) {\n if ( extData -> stage1 [ i ] != length ) {\n printf ( \"stage1[%04x]=%04x\\n\" , i , extData -> stage1 [ i ] ) ;\n }\n }\n j = length ;\n length = extData -> stage2Top ;\n printf ( \"\\nstage2[%x]:\\n\" , length ) ;\n for ( i = 0 ;\n i < length ;\n ++ j , ++ i ) {\n if ( extData -> stage2 [ i ] != 0 ) {\n printf ( \"stage12[%04x]=%04x\\n\" , j , extData -> stage2 [ i ] ) ;\n }\n }\n length = extData -> stage3Top ;\n printf ( \"\\nstage3[%x]:\\n\" , length ) ;\n for ( i = 0 ;\n i < length ;\n ++ i ) {\n if ( extData -> stage3 [ i ] != 0 ) {\n printf ( \"stage3[%04x]=%04x\\n\" , i , extData -> stage3 [ i ] ) ;\n }\n }\n length = extData -> stage3bTop ;\n printf ( \"\\nstage3b[%x]:\\n\" , length ) ;\n for ( i = 0 ;\n i < length ;\n ++ i ) {\n if ( extData -> stage3b [ i ] != 0 ) {\n printf ( \"stage3b[%04x]=%08x\\n\" , i , extData -> stage3b [ i ] ) ;\n }\n }\n }\n # endif if ( VERBOSE ) {\n printf ( \"size of extension data: %ld\\n\" , ( long ) top ) ;\n }\n return ( uint32_t ) ( headerSize + top ) ;\n }", "hash": 373200843854506734, "project": "chrome", "size": 131, "target": 0, "idx": 18461}
{"code": "static int32_t u_printf_simple_percent_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n ( void ) formatBundle ;\n ( void ) info ;\n ( void ) args ;\n static const UChar PERCENT [ ] = {\n UP_PERCENT }\n ;\n return handler -> write ( context , PERCENT , 1 ) ;\n }", "hash": 1981604082870872490, "project": "chrome", "size": 9, "target": 0, "idx": 18485}
{"code": "static int32_t u_printf_double_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n double num = ( double ) ( args [ 0 ] . doubleValue ) ;\n UNumberFormat * format ;\n UChar result [ UPRINTF_BUFFER_SIZE ] ;\n UChar prefixBuffer [ UPRINTF_BUFFER_SIZE ] ;\n int32_t prefixBufferLen = sizeof ( prefixBuffer ) ;\n int32_t minDecimalDigits ;\n int32_t maxDecimalDigits ;\n int32_t resultLen ;\n UErrorCode status = U_ZERO_ERROR ;\n prefixBuffer [ 0 ] = 0 ;\n format = u_locbund_getNumberFormat ( formatBundle , UNUM_DECIMAL ) ;\n if ( format == 0 ) return 0 ;\n minDecimalDigits = unum_getAttribute ( format , UNUM_MIN_FRACTION_DIGITS ) ;\n maxDecimalDigits = unum_getAttribute ( format , UNUM_MAX_FRACTION_DIGITS ) ;\n if ( info -> fPrecision != - 1 ) {\n unum_setAttribute ( format , UNUM_FRACTION_DIGITS , info -> fPrecision ) ;\n }\n else if ( info -> fAlt ) {\n unum_setAttribute ( format , UNUM_FRACTION_DIGITS , 6 ) ;\n }\n else {\n unum_setAttribute ( format , UNUM_FRACTION_DIGITS , 6 ) ;\n }\n if ( info -> fShowSign ) {\n u_printf_set_sign ( format , info , prefixBuffer , & prefixBufferLen , & status ) ;\n }\n resultLen = unum_formatDouble ( format , num , result , UPRINTF_BUFFER_SIZE , 0 , & status ) ;\n if ( U_FAILURE ( status ) ) {\n resultLen = 0 ;\n }\n unum_setAttribute ( format , UNUM_MIN_FRACTION_DIGITS , minDecimalDigits ) ;\n unum_setAttribute ( format , UNUM_MAX_FRACTION_DIGITS , maxDecimalDigits ) ;\n if ( info -> fShowSign ) {\n UErrorCode localStatus = U_ZERO_ERROR ;\n u_printf_reset_sign ( format , info , prefixBuffer , & prefixBufferLen , & localStatus ) ;\n }\n return handler -> pad_and_justify ( context , info , result , resultLen ) ;\n }", "hash": 1981604082870872490, "project": "chrome", "size": 39, "target": 0, "idx": 18494}
{"code": "static int32_t u_printf_scidbl_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n u_printf_spec_info scidbl_info ;\n double num = args [ 0 ] . doubleValue ;\n int32_t retVal ;\n UNumberFormat * format ;\n int32_t maxSigDecimalDigits , significantDigits ;\n memcpy ( & scidbl_info , info , sizeof ( u_printf_spec_info ) ) ;\n if ( scidbl_info . fPrecision == - 1 && num == uprv_trunc ( num ) ) {\n scidbl_info . fSpec = 0x0066 ;\n scidbl_info . fPrecision = 0 ;\n retVal = u_printf_double_handler ( handler , context , formatBundle , & scidbl_info , args ) ;\n }\n else if ( num < 0.0001 || ( scidbl_info . fPrecision < 1 && 1000000.0 <= num ) || ( scidbl_info . fPrecision != - 1 && num > uprv_pow10 ( scidbl_info . fPrecision ) ) ) {\n scidbl_info . fSpec = scidbl_info . fSpec - 2 ;\n if ( scidbl_info . fPrecision == - 1 ) {\n scidbl_info . fPrecision = 5 ;\n }\n retVal = u_printf_scientific_handler ( handler , context , formatBundle , & scidbl_info , args ) ;\n }\n else {\n format = u_locbund_getNumberFormat ( formatBundle , UNUM_DECIMAL ) ;\n if ( format == NULL ) {\n return 0 ;\n }\n maxSigDecimalDigits = unum_getAttribute ( format , UNUM_MAX_SIGNIFICANT_DIGITS ) ;\n significantDigits = scidbl_info . fPrecision ;\n scidbl_info . fSpec = 0x0066 ;\n if ( significantDigits == - 1 ) {\n significantDigits = 6 ;\n }\n unum_setAttribute ( format , UNUM_SIGNIFICANT_DIGITS_USED , TRUE ) ;\n unum_setAttribute ( format , UNUM_MAX_SIGNIFICANT_DIGITS , significantDigits ) ;\n retVal = u_printf_double_handler ( handler , context , formatBundle , & scidbl_info , args ) ;\n unum_setAttribute ( format , UNUM_MAX_SIGNIFICANT_DIGITS , maxSigDecimalDigits ) ;\n unum_setAttribute ( format , UNUM_SIGNIFICANT_DIGITS_USED , FALSE ) ;\n }\n return retVal ;\n }", "hash": 1981604082870872490, "project": "chrome", "size": 38, "target": 0, "idx": 18495}
{"code": "static UConverter * U_CALLCONV _SCSUSafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {\n struct cloneSCSUStruct * localClone ;\n int32_t bufferSizeNeeded = sizeof ( struct cloneSCSUStruct ) ;\n if ( U_FAILURE ( * status ) ) {\n return 0 ;\n }\n if ( * pBufferSize == 0 ) {\n * pBufferSize = bufferSizeNeeded ;\n return 0 ;\n }\n localClone = ( struct cloneSCSUStruct * ) stackBuffer ;\n uprv_memcpy ( & localClone -> mydata , cnv -> extraInfo , sizeof ( SCSUData ) ) ;\n localClone -> cnv . extraInfo = & localClone -> mydata ;\n localClone -> cnv . isExtraLocal = TRUE ;\n return & localClone -> cnv ;\n }", "hash": -4032982860280343776, "project": "chrome", "size": 16, "target": 0, "idx": 18518}
{"code": "static void U_CALLCONV _SCSUToUnicodeWithOffsets ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n UConverter * cnv ;\n SCSUData * scsu ;\n const uint8_t * source , * sourceLimit ;\n UChar * target ;\n const UChar * targetLimit ;\n int32_t * offsets ;\n UBool isSingleByteMode ;\n uint8_t state , byteOne ;\n int8_t quoteWindow , dynamicWindow ;\n int32_t sourceIndex , nextSourceIndex ;\n uint8_t b ;\n cnv = pArgs -> converter ;\n scsu = ( SCSUData * ) cnv -> extraInfo ;\n source = ( const uint8_t * ) pArgs -> source ;\n sourceLimit = ( const uint8_t * ) pArgs -> sourceLimit ;\n target = pArgs -> target ;\n targetLimit = pArgs -> targetLimit ;\n offsets = pArgs -> offsets ;\n isSingleByteMode = scsu -> toUIsSingleByteMode ;\n state = scsu -> toUState ;\n quoteWindow = scsu -> toUQuoteWindow ;\n dynamicWindow = scsu -> toUDynamicWindow ;\n byteOne = scsu -> toUByteOne ;\n sourceIndex = state == readCommand ? 0 : - 1 ;\n nextSourceIndex = 0 ;\n if ( isSingleByteMode ) {\n if ( state == readCommand ) {\n fastSingle : while ( source < sourceLimit && target < targetLimit && ( b = * source ) >= 0x20 ) {\n ++ source ;\n ++ nextSourceIndex ;\n if ( b <= 0x7f ) {\n * target ++ = ( UChar ) b ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n }\n else {\n uint32_t c = scsu -> toUDynamicOffsets [ dynamicWindow ] + ( b & 0x7f ) ;\n if ( c <= 0xffff ) {\n * target ++ = ( UChar ) c ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n }\n else {\n * target ++ = ( UChar ) ( 0xd7c0 + ( c >> 10 ) ) ;\n if ( target < targetLimit ) {\n * target ++ = ( UChar ) ( 0xdc00 | ( c & 0x3ff ) ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ;\n }\n }\n else {\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n cnv -> UCharErrorBuffer [ 0 ] = ( UChar ) ( 0xdc00 | ( c & 0x3ff ) ) ;\n cnv -> UCharErrorBufferLength = 1 ;\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n goto endloop ;\n }\n }\n }\n sourceIndex = nextSourceIndex ;\n }\n }\n singleByteMode : while ( source < sourceLimit ) {\n if ( target >= targetLimit ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n b = * source ++ ;\n ++ nextSourceIndex ;\n switch ( state ) {\n case readCommand : if ( ( 1UL << b ) & 0x2601 ) {\n * target ++ = ( UChar ) b ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n sourceIndex = nextSourceIndex ;\n goto fastSingle ;\n }\n else if ( SC0 <= b ) {\n if ( b <= SC7 ) {\n dynamicWindow = ( int8_t ) ( b - SC0 ) ;\n sourceIndex = nextSourceIndex ;\n goto fastSingle ;\n }\n else {\n dynamicWindow = ( int8_t ) ( b - SD0 ) ;\n state = defineOne ;\n }\n }\n else if ( b <= SQ7 ) {\n quoteWindow = ( int8_t ) ( b - SQ0 ) ;\n state = quoteOne ;\n }\n else if ( b == SDX ) {\n state = definePairOne ;\n }\n else if ( b == SQU ) {\n state = quotePairOne ;\n }\n else if ( b == SCU ) {\n sourceIndex = nextSourceIndex ;\n isSingleByteMode = FALSE ;\n goto fastUnicode ;\n }\n else {\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n goto endloop ;\n }\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n break ;\n case quotePairOne : byteOne = b ;\n cnv -> toUBytes [ 1 ] = b ;\n cnv -> toULength = 2 ;\n state = quotePairTwo ;\n break ;\n case quotePairTwo : * target ++ = ( UChar ) ( ( byteOne << 8 ) | b ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n sourceIndex = nextSourceIndex ;\n state = readCommand ;\n goto fastSingle ;\n case quoteOne : if ( b < 0x80 ) {\n * target ++ = ( UChar ) ( staticOffsets [ quoteWindow ] + b ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n }\n else {\n uint32_t c = scsu -> toUDynamicOffsets [ quoteWindow ] + ( b & 0x7f ) ;\n if ( c <= 0xffff ) {\n * target ++ = ( UChar ) c ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n }\n else {\n * target ++ = ( UChar ) ( 0xd7c0 + ( c >> 10 ) ) ;\n if ( target < targetLimit ) {\n * target ++ = ( UChar ) ( 0xdc00 | ( c & 0x3ff ) ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ;\n }\n }\n else {\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n cnv -> UCharErrorBuffer [ 0 ] = ( UChar ) ( 0xdc00 | ( c & 0x3ff ) ) ;\n cnv -> UCharErrorBufferLength = 1 ;\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n goto endloop ;\n }\n }\n }\n sourceIndex = nextSourceIndex ;\n state = readCommand ;\n goto fastSingle ;\n case definePairOne : dynamicWindow = ( int8_t ) ( ( b >> 5 ) & 7 ) ;\n byteOne = ( uint8_t ) ( b & 0x1f ) ;\n cnv -> toUBytes [ 1 ] = b ;\n cnv -> toULength = 2 ;\n state = definePairTwo ;\n break ;\n case definePairTwo : scsu -> toUDynamicOffsets [ dynamicWindow ] = 0x10000 + ( byteOne << 15UL | b << 7UL ) ;\n sourceIndex = nextSourceIndex ;\n state = readCommand ;\n goto fastSingle ;\n case defineOne : if ( b == 0 ) {\n cnv -> toUBytes [ 1 ] = b ;\n cnv -> toULength = 2 ;\n goto endloop ;\n }\n else if ( b < gapThreshold ) {\n scsu -> toUDynamicOffsets [ dynamicWindow ] = b << 7UL ;\n }\n else if ( ( uint8_t ) ( b - gapThreshold ) < ( reservedStart - gapThreshold ) ) {\n scsu -> toUDynamicOffsets [ dynamicWindow ] = ( b << 7UL ) + gapOffset ;\n }\n else if ( b >= fixedThreshold ) {\n scsu -> toUDynamicOffsets [ dynamicWindow ] = fixedOffsets [ b - fixedThreshold ] ;\n }\n else {\n cnv -> toUBytes [ 1 ] = b ;\n cnv -> toULength = 2 ;\n goto endloop ;\n }\n sourceIndex = nextSourceIndex ;\n state = readCommand ;\n goto fastSingle ;\n }\n }\n }\n else {\n if ( state == readCommand ) {\n fastUnicode : while ( source + 1 < sourceLimit && target < targetLimit && ( uint8_t ) ( ( b = * source ) - UC0 ) > ( Urs - UC0 ) ) {\n * target ++ = ( UChar ) ( ( b << 8 ) | source [ 1 ] ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n sourceIndex = nextSourceIndex ;\n nextSourceIndex += 2 ;\n source += 2 ;\n }\n }\n while ( source < sourceLimit ) {\n if ( target >= targetLimit ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n b = * source ++ ;\n ++ nextSourceIndex ;\n switch ( state ) {\n case readCommand : if ( ( uint8_t ) ( b - UC0 ) > ( Urs - UC0 ) ) {\n byteOne = b ;\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n state = quotePairTwo ;\n }\n else if ( b <= UC7 ) {\n dynamicWindow = ( int8_t ) ( b - UC0 ) ;\n sourceIndex = nextSourceIndex ;\n isSingleByteMode = TRUE ;\n goto fastSingle ;\n }\n else if ( b <= UD7 ) {\n dynamicWindow = ( int8_t ) ( b - UD0 ) ;\n isSingleByteMode = TRUE ;\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n state = defineOne ;\n goto singleByteMode ;\n }\n else if ( b == UDX ) {\n isSingleByteMode = TRUE ;\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n state = definePairOne ;\n goto singleByteMode ;\n }\n else if ( b == UQU ) {\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n state = quotePairOne ;\n }\n else {\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n goto endloop ;\n }\n break ;\n case quotePairOne : byteOne = b ;\n cnv -> toUBytes [ 1 ] = b ;\n cnv -> toULength = 2 ;\n state = quotePairTwo ;\n break ;\n case quotePairTwo : * target ++ = ( UChar ) ( ( byteOne << 8 ) | b ) ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n sourceIndex = nextSourceIndex ;\n state = readCommand ;\n goto fastUnicode ;\n }\n }\n }\n endloop : if ( U_FAILURE ( * pErrorCode ) && * pErrorCode != U_BUFFER_OVERFLOW_ERROR ) {\n state = readCommand ;\n }\n else if ( state == readCommand ) {\n cnv -> toULength = 0 ;\n }\n scsu -> toUIsSingleByteMode = isSingleByteMode ;\n scsu -> toUState = state ;\n scsu -> toUQuoteWindow = quoteWindow ;\n scsu -> toUDynamicWindow = dynamicWindow ;\n scsu -> toUByteOne = byteOne ;\n pArgs -> source = ( const char * ) source ;\n pArgs -> target = target ;\n pArgs -> offsets = offsets ;\n return ;\n }", "hash": -4032982860280343776, "project": "chrome", "size": 293, "target": 0, "idx": 18520}
{"code": "static void exsltDynMapFunction ( xmlXPathParserContextPtr ctxt , int nargs ) {\n xmlChar * str = NULL ;\n xmlNodeSetPtr nodeset = NULL ;\n xsltTransformContextPtr tctxt ;\n xmlXPathCompExprPtr comp = NULL ;\n xmlXPathObjectPtr ret = NULL ;\n xmlDocPtr oldDoc , container = NULL ;\n xmlNodePtr oldNode ;\n int oldContextSize ;\n int oldProximityPosition ;\n int i , j ;\n if ( nargs != 2 ) {\n xmlXPathSetArityError ( ctxt ) ;\n return ;\n }\n str = xmlXPathPopString ( ctxt ) ;\n if ( xmlXPathCheckError ( ctxt ) ) {\n xmlXPathSetTypeError ( ctxt ) ;\n return ;\n }\n nodeset = xmlXPathPopNodeSet ( ctxt ) ;\n if ( xmlXPathCheckError ( ctxt ) ) {\n xmlXPathSetTypeError ( ctxt ) ;\n return ;\n }\n if ( str == NULL || ! xmlStrlen ( str ) || ! ( comp = xmlXPathCompile ( str ) ) ) {\n if ( nodeset != NULL ) xmlXPathFreeNodeSet ( nodeset ) ;\n if ( str != NULL ) xmlFree ( str ) ;\n valuePush ( ctxt , xmlXPathNewNodeSet ( NULL ) ) ;\n return ;\n }\n ret = xmlXPathNewNodeSet ( NULL ) ;\n if ( ret == NULL ) {\n xsltGenericError ( xsltGenericErrorContext , \"exsltDynMapFunction: ret == NULL\\n\" ) ;\n goto cleanup ;\n }\n oldDoc = ctxt -> context -> doc ;\n oldNode = ctxt -> context -> node ;\n oldContextSize = ctxt -> context -> contextSize ;\n oldProximityPosition = ctxt -> context -> proximityPosition ;\n tctxt = xsltXPathGetTransformContext ( ctxt ) ;\n if ( tctxt == NULL ) {\n xsltTransformError ( xsltXPathGetTransformContext ( ctxt ) , NULL , NULL , \"dyn:map : internal error tctxt == NULL\\n\" ) ;\n goto cleanup ;\n }\n container = xsltCreateRVT ( tctxt ) ;\n if ( container == NULL ) {\n xsltTransformError ( tctxt , NULL , NULL , \"dyn:map : internal error container == NULL\\n\" ) ;\n goto cleanup ;\n }\n xsltRegisterLocalRVT ( tctxt , container ) ;\n if ( nodeset && nodeset -> nodeNr > 0 ) {\n xmlXPathNodeSetSort ( nodeset ) ;\n ctxt -> context -> contextSize = nodeset -> nodeNr ;\n ctxt -> context -> proximityPosition = 0 ;\n for ( i = 0 ;\n i < nodeset -> nodeNr ;\n i ++ ) {\n xmlXPathObjectPtr subResult = NULL ;\n ctxt -> context -> proximityPosition ++ ;\n ctxt -> context -> node = nodeset -> nodeTab [ i ] ;\n ctxt -> context -> doc = nodeset -> nodeTab [ i ] -> doc ;\n subResult = xmlXPathCompiledEval ( comp , ctxt -> context ) ;\n if ( subResult != NULL ) {\n switch ( subResult -> type ) {\n case XPATH_NODESET : if ( subResult -> nodesetval != NULL ) for ( j = 0 ;\n j < subResult -> nodesetval -> nodeNr ;\n j ++ ) xmlXPathNodeSetAdd ( ret -> nodesetval , subResult -> nodesetval -> nodeTab [ j ] ) ;\n break ;\n case XPATH_BOOLEAN : if ( container != NULL ) {\n xmlNodePtr cur = xmlNewChild ( ( xmlNodePtr ) container , NULL , BAD_CAST \"boolean\" , BAD_CAST ( subResult -> boolval ? \"true\" : \"\" ) ) ;\n if ( cur != NULL ) {\n cur -> ns = xmlNewNs ( cur , BAD_CAST \"http://exslt.org/common\" , BAD_CAST \"exsl\" ) ;\n xmlXPathNodeSetAddUnique ( ret -> nodesetval , cur ) ;\n }\n xsltExtensionInstructionResultRegister ( tctxt , ret ) ;\n }\n break ;\n case XPATH_NUMBER : if ( container != NULL ) {\n xmlChar * val = xmlXPathCastNumberToString ( subResult -> floatval ) ;\n xmlNodePtr cur = xmlNewChild ( ( xmlNodePtr ) container , NULL , BAD_CAST \"number\" , val ) ;\n if ( val != NULL ) xmlFree ( val ) ;\n if ( cur != NULL ) {\n cur -> ns = xmlNewNs ( cur , BAD_CAST \"http://exslt.org/common\" , BAD_CAST \"exsl\" ) ;\n xmlXPathNodeSetAddUnique ( ret -> nodesetval , cur ) ;\n }\n xsltExtensionInstructionResultRegister ( tctxt , ret ) ;\n }\n break ;\n case XPATH_STRING : if ( container != NULL ) {\n xmlNodePtr cur = xmlNewChild ( ( xmlNodePtr ) container , NULL , BAD_CAST \"string\" , subResult -> stringval ) ;\n if ( cur != NULL ) {\n cur -> ns = xmlNewNs ( cur , BAD_CAST \"http://exslt.org/common\" , BAD_CAST \"exsl\" ) ;\n xmlXPathNodeSetAddUnique ( ret -> nodesetval , cur ) ;\n }\n xsltExtensionInstructionResultRegister ( tctxt , ret ) ;\n }\n break ;\n default : break ;\n }\n xmlXPathFreeObject ( subResult ) ;\n }\n }\n }\n ctxt -> context -> doc = oldDoc ;\n ctxt -> context -> node = oldNode ;\n ctxt -> context -> contextSize = oldContextSize ;\n ctxt -> context -> proximityPosition = oldProximityPosition ;\n cleanup : if ( comp != NULL ) xmlXPathFreeCompExpr ( comp ) ;\n if ( nodeset != NULL ) xmlXPathFreeNodeSet ( nodeset ) ;\n if ( str != NULL ) xmlFree ( str ) ;\n valuePush ( ctxt , ret ) ;\n return ;\n }", "hash": -2864619463801931351, "project": "chrome", "size": 114, "target": 0, "idx": 18575}
{"code": "void exsltDynRegister ( void ) {\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"evaluate\" , EXSLT_DYNAMIC_NAMESPACE , exsltDynEvaluateFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"map\" , EXSLT_DYNAMIC_NAMESPACE , exsltDynMapFunction ) ;\n }", "hash": -2864619463801931351, "project": "chrome", "size": 4, "target": 0, "idx": 18576}
{"code": "void xmlHashScanFull3 ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , const xmlChar * name3 , xmlHashScannerFull f , void * data ) {\n int i ;\n xmlHashEntryPtr iter ;\n xmlHashEntryPtr next ;\n if ( table == NULL ) return ;\n if ( f == NULL ) return ;\n if ( table -> table ) {\n for ( i = 0 ;\n i < table -> size ;\n i ++ ) {\n if ( table -> table [ i ] . valid == 0 ) continue ;\n iter = & ( table -> table [ i ] ) ;\n while ( iter ) {\n next = iter -> next ;\n if ( ( ( name == NULL ) || ( xmlStrEqual ( name , iter -> name ) ) ) && ( ( name2 == NULL ) || ( xmlStrEqual ( name2 , iter -> name2 ) ) ) && ( ( name3 == NULL ) || ( xmlStrEqual ( name3 , iter -> name3 ) ) ) && ( iter -> payload != NULL ) ) {\n f ( iter -> payload , data , iter -> name , iter -> name2 , iter -> name3 ) ;\n }\n iter = next ;\n }\n }\n }\n }", "hash": -4239386405881995323, "project": "chrome", "size": 22, "target": 0, "idx": 18585}
{"code": "void xmlHashFree ( xmlHashTablePtr table , xmlHashDeallocator f ) {\n int i ;\n xmlHashEntryPtr iter ;\n xmlHashEntryPtr next ;\n int inside_table = 0 ;\n int nbElems ;\n if ( table == NULL ) return ;\n if ( table -> table ) {\n nbElems = table -> nbElems ;\n for ( i = 0 ;\n ( i < table -> size ) && ( nbElems > 0 ) ;\n i ++ ) {\n iter = & ( table -> table [ i ] ) ;\n if ( iter -> valid == 0 ) continue ;\n inside_table = 1 ;\n while ( iter ) {\n next = iter -> next ;\n if ( ( f != NULL ) && ( iter -> payload != NULL ) ) f ( iter -> payload , iter -> name ) ;\n if ( table -> dict == NULL ) {\n if ( iter -> name ) xmlFree ( iter -> name ) ;\n if ( iter -> name2 ) xmlFree ( iter -> name2 ) ;\n if ( iter -> name3 ) xmlFree ( iter -> name3 ) ;\n }\n iter -> payload = NULL ;\n if ( ! inside_table ) xmlFree ( iter ) ;\n nbElems -- ;\n inside_table = 0 ;\n iter = next ;\n }\n }\n xmlFree ( table -> table ) ;\n }\n if ( table -> dict ) xmlDictFree ( table -> dict ) ;\n xmlFree ( table ) ;\n }", "hash": -4239386405881995323, "project": "chrome", "size": 35, "target": 0, "idx": 18591}
{"code": "void exsltSaxonRegister ( void ) {\n xsltRegisterExtModule ( SAXON_NAMESPACE , ( xsltExtInitFunction ) exsltSaxonInit , ( xsltExtShutdownFunction ) exsltSaxonShutdown ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"expression\" , SAXON_NAMESPACE , exsltSaxonExpressionFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"eval\" , SAXON_NAMESPACE , exsltSaxonEvalFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"evaluate\" , SAXON_NAMESPACE , exsltSaxonEvaluateFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"line-number\" , SAXON_NAMESPACE , exsltSaxonLineNumberFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"systemId\" , SAXON_NAMESPACE , exsltSaxonSystemIdFunction ) ;\n }", "hash": 2120840145598099861, "project": "chrome", "size": 8, "target": 0, "idx": 18612}
{"code": "int xmlIsCombining ( unsigned int ch ) {\n return ( xmlIsCombiningQ ( ch ) ) ;\n }", "hash": -3405049855481807624, "project": "chrome", "size": 3, "target": 0, "idx": 18629}
{"code": "void exsltMathRegister ( void ) {\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"min\" , EXSLT_MATH_NAMESPACE , exsltMathMinFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"max\" , EXSLT_MATH_NAMESPACE , exsltMathMaxFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"highest\" , EXSLT_MATH_NAMESPACE , exsltMathHighestFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"lowest\" , EXSLT_MATH_NAMESPACE , exsltMathLowestFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"constant\" , EXSLT_MATH_NAMESPACE , exsltMathConstantFunction ) ;\n # ifdef HAVE_STDLIB_H xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"random\" , EXSLT_MATH_NAMESPACE , exsltMathRandomFunction ) ;\n # endif # if HAVE_MATH_H xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"abs\" , EXSLT_MATH_NAMESPACE , exsltMathAbsFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"sqrt\" , EXSLT_MATH_NAMESPACE , exsltMathSqrtFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"power\" , EXSLT_MATH_NAMESPACE , exsltMathPowerFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"log\" , EXSLT_MATH_NAMESPACE , exsltMathLogFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"sin\" , EXSLT_MATH_NAMESPACE , exsltMathSinFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"cos\" , EXSLT_MATH_NAMESPACE , exsltMathCosFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"tan\" , EXSLT_MATH_NAMESPACE , exsltMathTanFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"asin\" , EXSLT_MATH_NAMESPACE , exsltMathAsinFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"acos\" , EXSLT_MATH_NAMESPACE , exsltMathAcosFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"atan\" , EXSLT_MATH_NAMESPACE , exsltMathAtanFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"atan2\" , EXSLT_MATH_NAMESPACE , exsltMathAtan2Function ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"exp\" , EXSLT_MATH_NAMESPACE , exsltMathExpFunction ) ;\n # endif }", "hash": -560820000732125076, "project": "chrome", "size": 20, "target": 0, "idx": 18641}
{"code": "int xsltEvalXPathPredicate ( xsltTransformContextPtr ctxt , xmlXPathCompExprPtr comp , xmlNsPtr * nsList , int nsNr ) {\n int ret ;\n xmlXPathObjectPtr res ;\n int oldNsNr ;\n xmlNsPtr * oldNamespaces ;\n xmlNodePtr oldInst ;\n int oldProximityPosition , oldContextSize ;\n oldContextSize = ctxt -> xpathCtxt -> contextSize ;\n oldProximityPosition = ctxt -> xpathCtxt -> proximityPosition ;\n oldNsNr = ctxt -> xpathCtxt -> nsNr ;\n oldNamespaces = ctxt -> xpathCtxt -> namespaces ;\n oldInst = ctxt -> inst ;\n ctxt -> xpathCtxt -> node = ctxt -> node ;\n ctxt -> xpathCtxt -> namespaces = nsList ;\n ctxt -> xpathCtxt -> nsNr = nsNr ;\n res = xmlXPathCompiledEval ( comp , ctxt -> xpathCtxt ) ;\n if ( res != NULL ) {\n ret = xmlXPathEvalPredicate ( ctxt -> xpathCtxt , res ) ;\n xmlXPathFreeObject ( res ) ;\n # ifdef WITH_XSLT_DEBUG_TEMPLATES XSLT_TRACE ( ctxt , XSLT_TRACE_TEMPLATES , xsltGenericDebug ( xsltGenericDebugContext , \"xsltEvalXPathPredicate: returns %d\\n\" , ret ) ) ;\n # endif }\n else {\n # ifdef WITH_XSLT_DEBUG_TEMPLATES XSLT_TRACE ( ctxt , XSLT_TRACE_TEMPLATES , xsltGenericDebug ( xsltGenericDebugContext , \"xsltEvalXPathPredicate: failed\\n\" ) ) ;\n # endif ctxt -> state = XSLT_STATE_STOPPED ;\n ret = 0 ;\n }\n ctxt -> xpathCtxt -> nsNr = oldNsNr ;\n ctxt -> xpathCtxt -> namespaces = oldNamespaces ;\n ctxt -> inst = oldInst ;\n ctxt -> xpathCtxt -> contextSize = oldContextSize ;\n ctxt -> xpathCtxt -> proximityPosition = oldProximityPosition ;\n return ( ret ) ;\n }", "hash": 103178053094187415, "project": "chrome", "size": 33, "target": 0, "idx": 18648}
{"code": "void xsltSetLoaderFunc ( xsltDocLoaderFunc f ) {\n if ( f == NULL ) xsltDocDefaultLoader = xsltDocDefaultLoaderFunc ;\n else xsltDocDefaultLoader = f ;\n }", "hash": 2100112064176019294, "project": "chrome", "size": 4, "target": 0, "idx": 18664}
{"code": "xsltDocumentPtr xsltLoadDocument ( xsltTransformContextPtr ctxt , const xmlChar * URI ) {\n xsltDocumentPtr ret ;\n xmlDocPtr doc ;\n if ( ( ctxt == NULL ) || ( URI == NULL ) ) return ( NULL ) ;\n if ( ctxt -> sec != NULL ) {\n int res ;\n res = xsltCheckRead ( ctxt -> sec , ctxt , URI ) ;\n if ( res == 0 ) {\n xsltTransformError ( ctxt , NULL , NULL , \"xsltLoadDocument: read rights for %s denied\\n\" , URI ) ;\n return ( NULL ) ;\n }\n }\n ret = ctxt -> docList ;\n while ( ret != NULL ) {\n if ( ( ret -> doc != NULL ) && ( ret -> doc -> URL != NULL ) && ( xmlStrEqual ( ret -> doc -> URL , URI ) ) ) return ( ret ) ;\n ret = ret -> next ;\n }\n doc = xsltDocDefaultLoader ( URI , ctxt -> dict , ctxt -> parserOptions , ( void * ) ctxt , XSLT_LOAD_DOCUMENT ) ;\n if ( doc == NULL ) return ( NULL ) ;\n if ( ctxt -> xinclude != 0 ) {\n # ifdef LIBXML_XINCLUDE_ENABLED # if LIBXML_VERSION >= 20603 xmlXIncludeProcessFlags ( doc , ctxt -> parserOptions ) ;\n # else xmlXIncludeProcess ( doc ) ;\n # endif # else xsltTransformError ( ctxt , NULL , NULL , \"xsltLoadDocument(%s) : XInclude processing not compiled in\\n\" , URI ) ;\n # endif }\n if ( xsltNeedElemSpaceHandling ( ctxt ) ) xsltApplyStripSpaces ( ctxt , xmlDocGetRootElement ( doc ) ) ;\n if ( ctxt -> debugStatus == XSLT_DEBUG_NONE ) xmlXPathOrderDocElems ( doc ) ;\n ret = xsltNewDocument ( ctxt , doc ) ;\n return ( ret ) ;\n }", "hash": 2100112064176019294, "project": "chrome", "size": 29, "target": 0, "idx": 18665}
{"code": "void xsltRegisterExtras ( xsltTransformContextPtr ctxt ATTRIBUTE_UNUSED ) {\n xsltRegisterAllExtras ( ) ;\n }", "hash": -2901002460573809300, "project": "chrome", "size": 3, "target": 0, "idx": 18669}
{"code": "void xsltFunctionNodeSet ( xmlXPathParserContextPtr ctxt , int nargs ) {\n if ( nargs != 1 ) {\n xsltTransformError ( xsltXPathGetTransformContext ( ctxt ) , NULL , NULL , \"node-set() : expects one result-tree arg\\n\" ) ;\n ctxt -> error = XPATH_INVALID_ARITY ;\n return ;\n }\n if ( ( ctxt -> value == NULL ) || ( ( ctxt -> value -> type != XPATH_XSLT_TREE ) && ( ctxt -> value -> type != XPATH_NODESET ) ) ) {\n xsltTransformError ( xsltXPathGetTransformContext ( ctxt ) , NULL , NULL , \"node-set() invalid arg expecting a result tree\\n\" ) ;\n ctxt -> error = XPATH_INVALID_TYPE ;\n return ;\n }\n if ( ctxt -> value -> type == XPATH_XSLT_TREE ) {\n ctxt -> value -> type = XPATH_NODESET ;\n }\n }", "hash": -2901002460573809300, "project": "chrome", "size": 15, "target": 0, "idx": 18670}
{"code": "int main ( void ) {\n fprintf ( stderr , \"libxml was not compiled with thread or catalog support\\n\" ) ;\n return ( 0 ) ;\n }", "hash": 7272446382026167147, "project": "chrome", "size": 4, "target": 0, "idx": 18673}
{"code": "int main ( int argc ATTRIBUTE_UNUSED , char * * argv ATTRIBUTE_UNUSED ) {\n printf ( \"%s : HTML support not compiled in\\n\" , argv [ 0 ] ) ;\n return ( 0 ) ;\n }", "hash": 2224077187322763376, "project": "chrome", "size": 4, "target": 0, "idx": 18674}
{"code": "xmlDeregisterNodeFunc * __xmlDeregisterNodeDefaultValue ( void ) {\n if ( IS_MAIN_THREAD ) return ( & xmlDeregisterNodeDefaultValue ) ;\n else return ( & xmlGetGlobalState ( ) -> xmlDeregisterNodeDefaultValue ) ;\n }", "hash": -5780611388839125875, "project": "chrome", "size": 4, "target": 0, "idx": 18692}
{"code": "xmlOutputBufferCreateFilenameFunc * __xmlOutputBufferCreateFilenameValue ( void ) {\n if ( IS_MAIN_THREAD ) return ( & xmlOutputBufferCreateFilenameValue ) ;\n else return ( & xmlGetGlobalState ( ) -> xmlOutputBufferCreateFilenameValue ) ;\n }", "hash": -5780611388839125875, "project": "chrome", "size": 4, "target": 0, "idx": 18694}
{"code": "xmlRegisterNodeFunc xmlRegisterNodeDefault ( xmlRegisterNodeFunc func ) {\n xmlRegisterNodeFunc old = xmlRegisterNodeDefaultValue ;\n __xmlRegisterCallbacks = 1 ;\n xmlRegisterNodeDefaultValue = func ;\n return ( old ) ;\n }", "hash": -5780611388839125875, "project": "chrome", "size": 6, "target": 0, "idx": 18702}
{"code": "int * __xmlDefaultBufferSize ( void ) {\n if ( IS_MAIN_THREAD ) return ( & xmlDefaultBufferSize ) ;\n else return ( & xmlGetGlobalState ( ) -> xmlDefaultBufferSize ) ;\n }", "hash": -5780611388839125875, "project": "chrome", "size": 4, "target": 0, "idx": 18714}
{"code": "int * __xmlSubstituteEntitiesDefaultValue ( void ) {\n if ( IS_MAIN_THREAD ) return ( & xmlSubstituteEntitiesDefaultValue ) ;\n else return ( & xmlGetGlobalState ( ) -> xmlSubstituteEntitiesDefaultValue ) ;\n }", "hash": -5780611388839125875, "project": "chrome", "size": 4, "target": 0, "idx": 18717}
{"code": "xmlSAXLocator * __xmlDefaultSAXLocator ( void ) {\n if ( IS_MAIN_THREAD ) return ( & xmlDefaultSAXLocator ) ;\n else return ( & xmlGetGlobalState ( ) -> xmlDefaultSAXLocator ) ;\n }", "hash": -5780611388839125875, "project": "chrome", "size": 4, "target": 0, "idx": 18723}
{"code": "static int xsltCheckWritePath ( xsltSecurityPrefsPtr sec , xsltTransformContextPtr ctxt , const char * path ) {\n int ret ;\n xsltSecurityCheck check ;\n char * directory ;\n check = xsltGetSecurityPrefs ( sec , XSLT_SECPREF_WRITE_FILE ) ;\n if ( check != NULL ) {\n ret = check ( sec , ctxt , path ) ;\n if ( ret == 0 ) {\n xsltTransformError ( ctxt , NULL , NULL , \"File write for %s refused\\n\" , path ) ;\n return ( 0 ) ;\n }\n }\n directory = xmlParserGetDirectory ( path ) ;\n if ( directory != NULL ) {\n ret = xsltCheckFilename ( directory ) ;\n if ( ret == 0 ) {\n check = xsltGetSecurityPrefs ( sec , XSLT_SECPREF_CREATE_DIRECTORY ) ;\n if ( check != NULL ) {\n ret = check ( sec , ctxt , directory ) ;\n if ( ret == 0 ) {\n xsltTransformError ( ctxt , NULL , NULL , \"Directory creation for %s refused\\n\" , path ) ;\n xmlFree ( directory ) ;\n return ( 0 ) ;\n }\n }\n ret = xsltCheckWritePath ( sec , ctxt , directory ) ;\n if ( ret == 1 ) ret = mkdir ( directory , 0755 ) ;\n }\n xmlFree ( directory ) ;\n if ( ret < 0 ) return ( ret ) ;\n }\n return ( 1 ) ;\n }", "hash": 6850104357049520092, "project": "chrome", "size": 33, "target": 0, "idx": 18731}
{"code": "void xmlListReverse ( xmlListPtr l ) {\n xmlLinkPtr lk ;\n xmlLinkPtr lkPrev ;\n if ( l == NULL ) return ;\n lkPrev = l -> sentinel ;\n for ( lk = l -> sentinel -> next ;\n lk != l -> sentinel ;\n lk = lk -> next ) {\n lkPrev -> next = lkPrev -> prev ;\n lkPrev -> prev = lk ;\n lkPrev = lk ;\n }\n lkPrev -> next = lkPrev -> prev ;\n lkPrev -> prev = lk ;\n }", "hash": -4558261210024070448, "project": "chrome", "size": 15, "target": 0, "idx": 18739}
{"code": "xmlLinkPtr xmlListFront ( xmlListPtr l ) {\n if ( l == NULL ) return ( NULL ) ;\n return ( l -> sentinel -> next ) ;\n }", "hash": -4558261210024070448, "project": "chrome", "size": 4, "target": 0, "idx": 18743}
{"code": "static xmlLinkPtr xmlListHigherSearch ( xmlListPtr l , void * data ) {\n xmlLinkPtr lk ;\n if ( l == NULL ) return ( NULL ) ;\n for ( lk = l -> sentinel -> prev ;\n lk != l -> sentinel && l -> linkCompare ( lk -> data , data ) > 0 ;\n lk = lk -> prev ) ;\n return lk ;\n }", "hash": -4558261210024070448, "project": "chrome", "size": 8, "target": 0, "idx": 18754}
{"code": "static xmlLinkPtr xmlListLinkSearch ( xmlListPtr l , void * data ) {\n xmlLinkPtr lk ;\n if ( l == NULL ) return ( NULL ) ;\n lk = xmlListLowerSearch ( l , data ) ;\n if ( lk == l -> sentinel ) return NULL ;\n else {\n if ( l -> linkCompare ( lk -> data , data ) == 0 ) return lk ;\n return NULL ;\n }\n }", "hash": -4558261210024070448, "project": "chrome", "size": 10, "target": 0, "idx": 18768}
{"code": "TEST_F ( WebFrameTest , AltTextOnAboutBlankPage ) {\n FrameTestHelpers : : WebViewHelper web_view_helper ;\n web_view_helper . InitializeAndLoad ( \"about:blank\" ) ;\n web_view_helper . Resize ( WebSize ( 640 , 480 ) ) ;\n WebLocalFrameImpl * frame = web_view_helper . LocalMainFrame ( ) ;\n const char kSource [ ] = \"<img id='foo' src='foo' alt='foo alt' width='200' height='200'>\" ;\n FrameTestHelpers : : LoadHTMLString ( frame , kSource , ToKURL ( \"about:blank\" ) ) ;\n web_view_helper . GetWebView ( ) -> UpdateAllLifecyclePhases ( ) ;\n RunPendingTasks ( ) ;\n LayoutObject * layout_object = frame -> GetFrame ( ) -> GetDocument ( ) -> getElementById ( \"foo\" ) -> GetLayoutObject ( ) -> SlowFirstChild ( ) ;\n String text = \"\" ;\n for ( LayoutObject * obj = layout_object ;\n obj ;\n obj = obj -> NextInPreOrder ( ) ) {\n if ( obj -> IsText ( ) ) {\n LayoutText * layout_text = ToLayoutText ( obj ) ;\n text = layout_text -> GetText ( ) ;\n break ;\n }\n }\n EXPECT_EQ ( \"foo alt\" , text . Utf8 ( ) ) ;\n }", "hash": -673406620978847526, "project": "chrome", "size": 22, "target": 0, "idx": 18778}
{"code": "TEST_F ( WebFrameTest , ContextMenuDataSelectAll ) {\n EXPECT_FALSE ( TestSelectAll ( \"<textarea></textarea>\" ) ) ;\n EXPECT_TRUE ( TestSelectAll ( \"<textarea>nonempty</textarea>\" ) ) ;\n EXPECT_FALSE ( TestSelectAll ( \"<input>\" ) ) ;\n EXPECT_TRUE ( TestSelectAll ( \"<input value='nonempty'>\" ) ) ;\n EXPECT_FALSE ( TestSelectAll ( \"<div contenteditable></div>\" ) ) ;\n EXPECT_TRUE ( TestSelectAll ( \"<div contenteditable>nonempty</div>\" ) ) ;\n EXPECT_TRUE ( TestSelectAll ( \"<div contenteditable>\\n</div>\" ) ) ;\n }", "hash": -673406620978847526, "project": "chrome", "size": 9, "target": 0, "idx": 18791}
{"code": "TEST_F ( WebFrameSimTest , DisambiguationPopupPixelTest ) {\n WebView ( ) . Resize ( WebSize ( 400 , 600 ) ) ;\n WebView ( ) . GetPage ( ) -> GetSettings ( ) . SetTextAutosizingEnabled ( false ) ;\n UseAndroidSettings ( ) ;\n SimRequest request ( \"https://example.com/test.html\" , \"text/html\" ) ;\n LoadURL ( \"https://example.com/test.html\" ) ;\n request . Complete ( R \"HTML( < ! DOCTYPE html > < style > body , html {\n width : 4000px ;\n height : 4000px ;\n margin : 0 ;\n }\n # box {\n position : absolute ;\n left : 200px ;\n top : 300px ;\n width : 100px ;\n height : 100px ;\n background - color : red ;\n }\n < / style > < div id = \"box\" > < / div > ) HTML \");\n Compositor ( ) . BeginFrame ( ) ;\n ASSERT_EQ ( 0.25f , WebView ( ) . PageScaleFactor ( ) ) ;\n float scale = 4.f ;\n WebRect zoom_rect ( 200 , 300 , 100 , 100 ) ;\n gfx : : Size canvas_size ( zoom_rect . width * scale , zoom_rect . height * scale ) ;\n SkImageInfo info = SkImageInfo : : MakeN32Premul ( canvas_size . width ( ) , canvas_size . height ( ) ) ;\n size_t size = info . computeMinByteSize ( ) ;\n auto buffer = std : : make_unique < uint8_t [ ] > ( size ) ;\n SkBitmap bitmap ;\n bitmap . installPixels ( info , buffer . get ( ) , info . minRowBytes ( ) ) ;\n cc : : SkiaPaintCanvas canvas ( bitmap ) ;\n canvas . scale ( scale , scale ) ;\n canvas . translate ( - zoom_rect . x , - zoom_rect . y ) ;\n WebView ( ) . UpdateAllLifecyclePhases ( ) ;\n WebView ( ) . PaintContentIgnoringCompositing ( & canvas , zoom_rect ) ;\n for ( int x = 0 ;\n x < canvas_size . width ( ) ;\n ++ x ) {\n for ( int y = 0 ;\n y < canvas_size . height ( ) ;\n ++ y ) {\n ASSERT_EQ ( bitmap . getColor ( x , y ) , SK_ColorRED ) << \"Mismatching pixel at (\" << x << \", \" << y << \")\" ;\n }\n }\n }", "hash": -673406620978847526, "project": "chrome", "size": 45, "target": 0, "idx": 18795}
{"code": "TEST_F ( WebFrameTest , ContextMenuDataPasswordSelectedText ) {\n ContextMenuWebFrameClient frame ;\n FrameTestHelpers : : WebViewHelper web_view_helper ;\n WebViewImpl * web_view = web_view_helper . Initialize ( & frame ) ;\n const std : : string & html = \"<input type='password' value='password'>\" ;\n FrameTestHelpers : : LoadHTMLString ( web_view -> MainFrameImpl ( ) , html , ToKURL ( \"about:blank\" ) ) ;\n web_view -> Resize ( WebSize ( 500 , 300 ) ) ;\n web_view -> UpdateAllLifecyclePhases ( ) ;\n RunPendingTasks ( ) ;\n web_view -> SetInitialFocus ( false ) ;\n RunPendingTasks ( ) ;\n web_view -> MainFrameImpl ( ) -> ExecuteCommand ( WebString : : FromUTF8 ( \"SelectAll\" ) ) ;\n WebMouseEvent mouse_event ( WebInputEvent : : kMouseDown , WebInputEvent : : kNoModifiers , WebInputEvent : : GetStaticTimeStampForTests ( ) ) ;\n mouse_event . button = WebMouseEvent : : Button : : kRight ;\n mouse_event . SetPositionInWidget ( 8 , 8 ) ;\n mouse_event . click_count = 1 ;\n web_view -> HandleInputEvent ( WebCoalescedInputEvent ( mouse_event ) ) ;\n RunPendingTasks ( ) ;\n web_view_helper . Reset ( ) ;\n EXPECT_EQ ( frame . GetMenuData ( ) . input_field_type , blink : : WebContextMenuData : : kInputFieldTypePassword ) ;\n EXPECT_FALSE ( frame . GetMenuData ( ) . selected_text . IsEmpty ( ) ) ;\n }", "hash": -673406620978847526, "project": "chrome", "size": 22, "target": 0, "idx": 18814}
{"code": "TEST_F ( IconLabelBubbleViewTest , AnimateLayout ) {\n VerifyWithAnimationStep ( 1 ) ;\n VerifyWithAnimationStep ( 5 ) ;\n VerifyWithAnimationStep ( 10 ) ;\n VerifyWithAnimationStep ( 25 ) ;\n }", "hash": 1339575514457462426, "project": "chrome", "size": 6, "target": 0, "idx": 18818}
{"code": "IN_PROC_BROWSER_TEST_P ( SupervisedUserNavigationThrottleTest , NoNavigationObserverBlock ) {\n Profile * profile = browser ( ) -> profile ( ) ;\n SupervisedUserSettingsService * supervised_user_settings_service = SupervisedUserSettingsServiceFactory : : GetForProfile ( profile ) ;\n supervised_user_settings_service -> SetLocalSetting ( supervised_users : : kContentPackDefaultFilteringBehavior , std : : unique_ptr < base : : Value > ( new base : : Value ( SupervisedUserURLFilter : : BLOCK ) ) ) ;\n std : : unique_ptr < WebContents > web_contents ( WebContents : : Create ( WebContents : : CreateParams ( profile ) ) ) ;\n NavigationController & controller = web_contents -> GetController ( ) ;\n content : : TestNavigationObserver observer ( web_contents . get ( ) ) ;\n controller . LoadURL ( GURL ( \"http://www.example.com\" ) , content : : Referrer ( ) , ui : : PAGE_TRANSITION_TYPED , std : : string ( ) ) ;\n observer . Wait ( ) ;\n content : : NavigationEntry * entry = controller . GetActiveEntry ( ) ;\n ASSERT_TRUE ( entry ) ;\n EXPECT_EQ ( content : : PAGE_TYPE_NORMAL , entry -> GetPageType ( ) ) ;\n EXPECT_FALSE ( observer . last_navigation_succeeded ( ) ) ;\n }", "hash": -3151614232349488244, "project": "chrome", "size": 14, "target": 0, "idx": 18832}
{"code": "IN_PROC_BROWSER_TEST_P ( SupervisedUserNavigationThrottleNotSupervisedTest , DontBlock ) {\n BlockHost ( kExampleHost ) ;\n GURL blocked_url = embedded_test_server ( ) -> GetURL ( kExampleHost , \"/supervised_user/simple.html\" ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , blocked_url ) ;\n EXPECT_FALSE ( IsInterstitialBeingShown ( browser ( ) ) ) ;\n }", "hash": -3151614232349488244, "project": "chrome", "size": 6, "target": 0, "idx": 18834}
{"code": "static void qcms_transform_module_matrix_translate ( struct qcms_modular_transform * transform , float * src , float * dest , size_t length ) {\n size_t i ;\n struct matrix mat ;\n mat . m [ 0 ] [ 0 ] = transform -> matrix . m [ 0 ] [ 0 ] ;\n mat . m [ 1 ] [ 0 ] = transform -> matrix . m [ 0 ] [ 1 ] ;\n mat . m [ 2 ] [ 0 ] = transform -> matrix . m [ 0 ] [ 2 ] ;\n mat . m [ 0 ] [ 1 ] = transform -> matrix . m [ 1 ] [ 0 ] ;\n mat . m [ 1 ] [ 1 ] = transform -> matrix . m [ 1 ] [ 1 ] ;\n mat . m [ 2 ] [ 1 ] = transform -> matrix . m [ 1 ] [ 2 ] ;\n mat . m [ 0 ] [ 2 ] = transform -> matrix . m [ 2 ] [ 0 ] ;\n mat . m [ 1 ] [ 2 ] = transform -> matrix . m [ 2 ] [ 1 ] ;\n mat . m [ 2 ] [ 2 ] = transform -> matrix . m [ 2 ] [ 2 ] ;\n for ( i = 0 ;\n i < length ;\n i ++ ) {\n float in_r = * src ++ ;\n float in_g = * src ++ ;\n float in_b = * src ++ ;\n float out_r = mat . m [ 0 ] [ 0 ] * in_r + mat . m [ 1 ] [ 0 ] * in_g + mat . m [ 2 ] [ 0 ] * in_b + transform -> tx ;\n float out_g = mat . m [ 0 ] [ 1 ] * in_r + mat . m [ 1 ] [ 1 ] * in_g + mat . m [ 2 ] [ 1 ] * in_b + transform -> ty ;\n float out_b = mat . m [ 0 ] [ 2 ] * in_r + mat . m [ 1 ] [ 2 ] * in_g + mat . m [ 2 ] [ 2 ] * in_b + transform -> tz ;\n * dest ++ = clamp_float ( out_r ) ;\n * dest ++ = clamp_float ( out_g ) ;\n * dest ++ = clamp_float ( out_b ) ;\n }\n }", "hash": 2626033973808493247, "project": "chrome", "size": 26, "target": 0, "idx": 18864}
{"code": "static void qcms_transform_module_gamma_lut ( struct qcms_modular_transform * transform , float * src , float * dest , size_t length ) {\n size_t i ;\n float out_r , out_g , out_b ;\n for ( i = 0 ;\n i < length ;\n i ++ ) {\n float in_r = * src ++ ;\n float in_g = * src ++ ;\n float in_b = * src ++ ;\n out_r = lut_interp_linear ( in_r , transform -> output_gamma_lut_r , transform -> output_gamma_lut_r_length ) ;\n out_g = lut_interp_linear ( in_g , transform -> output_gamma_lut_g , transform -> output_gamma_lut_g_length ) ;\n out_b = lut_interp_linear ( in_b , transform -> output_gamma_lut_b , transform -> output_gamma_lut_b_length ) ;\n * dest ++ = clamp_float ( out_r ) ;\n * dest ++ = clamp_float ( out_g ) ;\n * dest ++ = clamp_float ( out_b ) ;\n }\n }", "hash": 2626033973808493247, "project": "chrome", "size": 17, "target": 0, "idx": 18871}
{"code": "TEST_F ( PrintPreviewUIUnitTest , PrintPreviewData ) {\n WebContents * initiator = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n ASSERT_TRUE ( initiator ) ;\n EXPECT_FALSE ( IsShowingWebContentsModalDialog ( initiator ) ) ;\n printing : : PrintPreviewDialogController * controller = printing : : PrintPreviewDialogController : : GetInstance ( ) ;\n ASSERT_TRUE ( controller ) ;\n printing : : PrintViewManager * print_view_manager = printing : : PrintViewManager : : FromWebContents ( initiator ) ;\n print_view_manager -> PrintPreviewNow ( initiator -> GetMainFrame ( ) , false ) ;\n WebContents * preview_dialog = controller -> GetOrCreatePreviewDialog ( initiator ) ;\n EXPECT_NE ( initiator , preview_dialog ) ;\n EXPECT_EQ ( 1 , browser ( ) -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_TRUE ( IsShowingWebContentsModalDialog ( initiator ) ) ;\n PrintPreviewUI * preview_ui = static_cast < PrintPreviewUI * > ( preview_dialog -> GetWebUI ( ) -> GetController ( ) ) ;\n ASSERT_TRUE ( preview_ui != NULL ) ;\n scoped_refptr < base : : RefCountedBytes > data ;\n preview_ui -> GetPrintPreviewDataForIndex ( printing : : COMPLETE_PREVIEW_DOCUMENT_INDEX , & data ) ;\n EXPECT_EQ ( NULL , data . get ( ) ) ;\n scoped_refptr < base : : RefCountedBytes > dummy_data = CreateTestData ( ) ;\n preview_ui -> SetPrintPreviewDataForIndex ( printing : : COMPLETE_PREVIEW_DOCUMENT_INDEX , dummy_data . get ( ) ) ;\n preview_ui -> GetPrintPreviewDataForIndex ( printing : : COMPLETE_PREVIEW_DOCUMENT_INDEX , & data ) ;\n EXPECT_EQ ( dummy_data -> size ( ) , data -> size ( ) ) ;\n EXPECT_EQ ( dummy_data . get ( ) , data . get ( ) ) ;\n dummy_data = new base : : RefCountedBytes ( ) ;\n preview_ui -> SetPrintPreviewDataForIndex ( printing : : FIRST_PAGE_INDEX , dummy_data . get ( ) ) ;\n preview_ui -> ClearAllPreviewData ( ) ;\n preview_ui -> GetPrintPreviewDataForIndex ( printing : : COMPLETE_PREVIEW_DOCUMENT_INDEX , & data ) ;\n EXPECT_EQ ( NULL , data . get ( ) ) ;\n }", "hash": -8487916477825389369, "project": "chrome", "size": 28, "target": 0, "idx": 18877}
{"code": "IN_PROC_BROWSER_TEST_F ( UnloadTest , DISABLED_BrowserCloseInfiniteBeforeUnload ) {\n if ( base : : CommandLine : : ForCurrentProcess ( ) -> HasSwitch ( switches : : kSingleProcess ) ) return ;\n LoadUrlAndQuitBrowser ( INFINITE_BEFORE_UNLOAD_HTML , \"infinitebeforeunload\" ) ;\n }", "hash": -1335877942018854351, "project": "chrome", "size": 4, "target": 0, "idx": 18895}
{"code": "IN_PROC_BROWSER_TEST_F ( FastUnloadTest , MAYBE_WindowCloseAfterBeforeUnloadCrash ) {\n if ( base : : CommandLine : : ForCurrentProcess ( ) -> HasSwitch ( switches : : kSingleProcess ) ) return ;\n NavigateToDataURL ( BEFORE_UNLOAD_HTML , \"beforeunload\" ) ;\n content : : WebContents * beforeunload_contents = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n content : : WindowedNotificationObserver window_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : NotificationService : : AllSources ( ) ) ;\n chrome : : CloseWindow ( browser ( ) ) ;\n CrashTab ( beforeunload_contents ) ;\n window_observer . Wait ( ) ;\n }", "hash": -1335877942018854351, "project": "chrome", "size": 9, "target": 0, "idx": 18900}
{"code": "IN_PROC_BROWSER_TEST_F ( UnloadTest , CrossSiteInfiniteBeforeUnloadAsync ) {\n if ( base : : CommandLine : : ForCurrentProcess ( ) -> HasSwitch ( switches : : kSingleProcess ) ) return ;\n NavigateToDataURL ( INFINITE_BEFORE_UNLOAD_HTML , \"infinitebeforeunload\" ) ;\n NavigateToNolistenersFileTwiceAsync ( ) ;\n }", "hash": -1335877942018854351, "project": "chrome", "size": 5, "target": 0, "idx": 18902}
{"code": "IN_PROC_BROWSER_TEST_F ( UnloadTest , BrowserListDoubleCloseBeforeUnloadOK ) {\n NavigateToDataURL ( BEFORE_UNLOAD_HTML , \"beforeunload\" ) ;\n content : : WindowedNotificationObserver window_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : NotificationService : : AllSources ( ) ) ;\n UnloadResults unload_results ;\n BrowserList : : CloseAllBrowsersWithProfile ( browser ( ) -> profile ( ) , base : : Bind ( & UnloadResults : : AddSuccess , base : : Unretained ( & unload_results ) ) , base : : Bind ( & UnloadResults : : AddAbort , base : : Unretained ( & unload_results ) ) , false ) ;\n BrowserList : : CloseAllBrowsersWithProfile ( browser ( ) -> profile ( ) , base : : Bind ( & UnloadResults : : AddSuccess , base : : Unretained ( & unload_results ) ) , base : : Bind ( & UnloadResults : : AddAbort , base : : Unretained ( & unload_results ) ) , false ) ;\n ClickModalDialogButton ( true ) ;\n window_observer . Wait ( ) ;\n EXPECT_EQ ( 1 , unload_results . get_successes ( ) ) ;\n EXPECT_EQ ( 0 , unload_results . get_aborts ( ) ) ;\n }", "hash": -1335877942018854351, "project": "chrome", "size": 11, "target": 0, "idx": 18904}
{"code": "IN_PROC_BROWSER_TEST_F ( UnloadTest , DISABLED_BrowserCloseUnload ) {\n LoadUrlAndQuitBrowser ( UNLOAD_HTML , \"unload\" ) ;\n }", "hash": -1335877942018854351, "project": "chrome", "size": 3, "target": 0, "idx": 18906}
{"code": "IN_PROC_BROWSER_TEST_F ( UnloadTest , BrowserListForceCloseWithBeforeUnload ) {\n NavigateToDataURL ( BEFORE_UNLOAD_HTML , \"beforeunload\" ) ;\n content : : WindowedNotificationObserver window_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : NotificationService : : AllSources ( ) ) ;\n UnloadResults unload_results ;\n BrowserList : : CloseAllBrowsersWithProfile ( browser ( ) -> profile ( ) , base : : Bind ( & UnloadResults : : AddSuccess , base : : Unretained ( & unload_results ) ) , base : : Bind ( & UnloadResults : : AddAbort , base : : Unretained ( & unload_results ) ) , true ) ;\n window_observer . Wait ( ) ;\n EXPECT_EQ ( 1 , unload_results . get_successes ( ) ) ;\n EXPECT_EQ ( 0 , unload_results . get_aborts ( ) ) ;\n }", "hash": -1335877942018854351, "project": "chrome", "size": 9, "target": 0, "idx": 18911}
{"code": "TEST_F ( FullscreenControllerStateUnitTest , CapturedFullscreenedTabTransferredBetweenBrowserWindows ) {\n content : : WebContentsDelegate * const wc_delegate = static_cast < content : : WebContentsDelegate * > ( browser ( ) ) ;\n ASSERT_TRUE ( wc_delegate -> EmbedsFullscreenWidget ( ) ) ;\n AddTab ( browser ( ) , GURL ( url : : kAboutBlankURL ) ) ;\n AddTab ( browser ( ) , GURL ( url : : kAboutBlankURL ) ) ;\n content : : WebContents * const tab = browser ( ) -> tab_strip_model ( ) -> GetWebContentsAt ( 0 ) ;\n browser ( ) -> tab_strip_model ( ) -> ActivateTabAt ( 0 , true ) ;\n const gfx : : Size kCaptureSize ( 1280 , 720 ) ;\n tab -> IncrementCapturerCount ( kCaptureSize ) ;\n ASSERT_FALSE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n ASSERT_FALSE ( wc_delegate -> IsFullscreenForTabOrPending ( tab ) ) ;\n ASSERT_FALSE ( GetFullscreenController ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n ASSERT_TRUE ( InvokeEvent ( TAB_FULLSCREEN_TRUE ) ) ;\n EXPECT_FALSE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n EXPECT_TRUE ( wc_delegate -> IsFullscreenForTabOrPending ( tab ) ) ;\n EXPECT_FALSE ( GetFullscreenController ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n const scoped_ptr < BrowserWindow > second_browser_window ( CreateBrowserWindow ( ) ) ;\n const scoped_ptr < Browser > second_browser ( CreateBrowser ( browser ( ) -> profile ( ) , browser ( ) -> type ( ) , false , browser ( ) -> host_desktop_type ( ) , second_browser_window . get ( ) ) ) ;\n AddTab ( second_browser . get ( ) , GURL ( url : : kAboutBlankURL ) ) ;\n content : : WebContentsDelegate * const second_wc_delegate = static_cast < content : : WebContentsDelegate * > ( second_browser . get ( ) ) ;\n browser ( ) -> tab_strip_model ( ) -> DetachWebContentsAt ( 0 ) ;\n second_browser -> tab_strip_model ( ) -> InsertWebContentsAt ( 0 , tab , TabStripModel : : ADD_ACTIVE ) ;\n EXPECT_FALSE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n EXPECT_FALSE ( second_browser -> window ( ) -> IsFullscreen ( ) ) ;\n EXPECT_TRUE ( wc_delegate -> IsFullscreenForTabOrPending ( tab ) ) ;\n EXPECT_TRUE ( second_wc_delegate -> IsFullscreenForTabOrPending ( tab ) ) ;\n EXPECT_FALSE ( GetFullscreenController ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n EXPECT_FALSE ( second_browser -> fullscreen_controller ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n second_browser -> tab_strip_model ( ) -> DetachWebContentsAt ( 0 ) ;\n browser ( ) -> tab_strip_model ( ) -> InsertWebContentsAt ( 0 , tab , TabStripModel : : ADD_ACTIVE ) ;\n EXPECT_FALSE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n EXPECT_FALSE ( second_browser -> window ( ) -> IsFullscreen ( ) ) ;\n EXPECT_TRUE ( wc_delegate -> IsFullscreenForTabOrPending ( tab ) ) ;\n EXPECT_TRUE ( second_wc_delegate -> IsFullscreenForTabOrPending ( tab ) ) ;\n EXPECT_FALSE ( GetFullscreenController ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n EXPECT_FALSE ( second_browser -> fullscreen_controller ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n ASSERT_TRUE ( InvokeEvent ( TAB_FULLSCREEN_FALSE ) ) ;\n EXPECT_FALSE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n EXPECT_FALSE ( wc_delegate -> IsFullscreenForTabOrPending ( tab ) ) ;\n EXPECT_FALSE ( second_wc_delegate -> IsFullscreenForTabOrPending ( tab ) ) ;\n EXPECT_FALSE ( GetFullscreenController ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n EXPECT_FALSE ( second_browser -> fullscreen_controller ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n second_browser -> tab_strip_model ( ) -> CloseAllTabs ( ) ;\n }", "hash": -1445906809722253218, "project": "chrome", "size": 44, "target": 0, "idx": 18922}
{"code": "TEST_F ( FullscreenControllerStateUnitTest , DISABLED_ToggleTabWhenPendingTab ) {\n if ( FullscreenControllerStateTest : : IsWindowFullscreenStateChangedReentrant ( ) ) return ;\n AddTab ( browser ( ) , GURL ( url : : kAboutBlankURL ) ) ;\n ASSERT_NO_FATAL_FAILURE ( TransitionToState ( STATE_TO_TAB_FULLSCREEN ) ) << GetAndClearDebugLog ( ) ;\n ASSERT_TRUE ( InvokeEvent ( TAB_FULLSCREEN_TRUE ) ) << GetAndClearDebugLog ( ) ;\n ASSERT_TRUE ( InvokeEvent ( TAB_FULLSCREEN_FALSE ) ) << GetAndClearDebugLog ( ) ;\n ASSERT_TRUE ( InvokeEvent ( WINDOW_CHANGE ) ) << GetAndClearDebugLog ( ) ;\n }", "hash": -1445906809722253218, "project": "chrome", "size": 8, "target": 0, "idx": 18928}
{"code": "TEST_F ( FullscreenControllerStateUnitTest , TwoFullscreenedTabsOneCaptured ) {\n content : : WebContentsDelegate * const wc_delegate = static_cast < content : : WebContentsDelegate * > ( browser ( ) ) ;\n ASSERT_TRUE ( wc_delegate -> EmbedsFullscreenWidget ( ) ) ;\n AddTab ( browser ( ) , GURL ( url : : kAboutBlankURL ) ) ;\n AddTab ( browser ( ) , GURL ( url : : kAboutBlankURL ) ) ;\n content : : WebContents * const first_tab = browser ( ) -> tab_strip_model ( ) -> GetWebContentsAt ( 0 ) ;\n content : : WebContents * const second_tab = browser ( ) -> tab_strip_model ( ) -> GetWebContentsAt ( 1 ) ;\n browser ( ) -> tab_strip_model ( ) -> ActivateTabAt ( 0 , true ) ;\n const gfx : : Size kCaptureSize ( 1280 , 720 ) ;\n first_tab -> IncrementCapturerCount ( kCaptureSize ) ;\n ASSERT_TRUE ( InvokeEvent ( TAB_FULLSCREEN_TRUE ) ) ;\n EXPECT_FALSE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n EXPECT_TRUE ( wc_delegate -> IsFullscreenForTabOrPending ( first_tab ) ) ;\n EXPECT_FALSE ( wc_delegate -> IsFullscreenForTabOrPending ( second_tab ) ) ;\n EXPECT_FALSE ( GetFullscreenController ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n browser ( ) -> tab_strip_model ( ) -> ActivateTabAt ( 1 , true ) ;\n ASSERT_TRUE ( InvokeEvent ( TAB_FULLSCREEN_TRUE ) ) ;\n ASSERT_TRUE ( InvokeEvent ( WINDOW_CHANGE ) ) ;\n EXPECT_TRUE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n EXPECT_TRUE ( wc_delegate -> IsFullscreenForTabOrPending ( first_tab ) ) ;\n EXPECT_TRUE ( wc_delegate -> IsFullscreenForTabOrPending ( second_tab ) ) ;\n EXPECT_TRUE ( GetFullscreenController ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n ASSERT_TRUE ( InvokeEvent ( TAB_FULLSCREEN_FALSE ) ) ;\n ASSERT_TRUE ( InvokeEvent ( WINDOW_CHANGE ) ) ;\n EXPECT_FALSE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n EXPECT_TRUE ( wc_delegate -> IsFullscreenForTabOrPending ( first_tab ) ) ;\n EXPECT_FALSE ( wc_delegate -> IsFullscreenForTabOrPending ( second_tab ) ) ;\n EXPECT_FALSE ( GetFullscreenController ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n browser ( ) -> tab_strip_model ( ) -> ActivateTabAt ( 0 , true ) ;\n ASSERT_TRUE ( InvokeEvent ( TAB_FULLSCREEN_FALSE ) ) ;\n EXPECT_FALSE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n EXPECT_FALSE ( wc_delegate -> IsFullscreenForTabOrPending ( first_tab ) ) ;\n EXPECT_FALSE ( wc_delegate -> IsFullscreenForTabOrPending ( second_tab ) ) ;\n EXPECT_FALSE ( GetFullscreenController ( ) -> IsWindowFullscreenForTabOrPending ( ) ) ;\n }", "hash": -1445906809722253218, "project": "chrome", "size": 35, "target": 0, "idx": 18931}
{"code": "IN_PROC_BROWSER_TEST_F ( FullscreenControllerInteractiveTest , DISABLED_FullscreenMouseLockContentSettings ) {\n TestFullscreenMouseLockContentSettings ( ) ;\n }", "hash": 4537091194729139981, "project": "chrome", "size": 3, "target": 0, "idx": 18936}
{"code": "IN_PROC_BROWSER_TEST_F ( FullscreenControllerInteractiveTest , DISABLED_TestTabExitsItselfFromFullscreen ) {\n ASSERT_TRUE ( test_server ( ) -> Start ( ) ) ;\n AddTabAtIndex ( 0 , GURL ( url : : kAboutBlankURL ) , PAGE_TRANSITION_TYPED ) ;\n ASSERT_NO_FATAL_FAILURE ( ToggleTabFullscreen ( true ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ToggleTabFullscreen ( false ) ) ;\n }", "hash": 4537091194729139981, "project": "chrome", "size": 6, "target": 0, "idx": 18939}
{"code": "IN_PROC_BROWSER_TEST_F ( FullscreenControllerInteractiveTest , MAYBE_MouseLockSilentAfterTargetUnlock ) {\n ASSERT_TRUE ( test_server ( ) -> Start ( ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , test_server ( ) -> GetURL ( kFullscreenMouseLockHTML ) ) ;\n ASSERT_FALSE ( IsFullscreenBubbleDisplayed ( ) ) ;\n ASSERT_TRUE ( ui_test_utils : : SendKeyPressAndWait ( browser ( ) , ui : : VKEY_1 , false , false , false , false , chrome : : NOTIFICATION_MOUSE_LOCK_CHANGED , content : : NotificationService : : AllSources ( ) ) ) ;\n ASSERT_TRUE ( IsFullscreenBubbleDisplayed ( ) ) ;\n ASSERT_TRUE ( IsMouseLockPermissionRequested ( ) ) ;\n ASSERT_FALSE ( IsMouseLocked ( ) ) ;\n AcceptCurrentFullscreenOrMouseLockRequest ( ) ;\n ASSERT_TRUE ( IsMouseLocked ( ) ) ;\n ASSERT_TRUE ( IsFullscreenBubbleDisplayed ( ) ) ;\n ASSERT_TRUE ( ui_test_utils : : SendKeyPressAndWait ( browser ( ) , ui : : VKEY_U , false , false , false , false , chrome : : NOTIFICATION_MOUSE_LOCK_CHANGED , content : : NotificationService : : AllSources ( ) ) ) ;\n ASSERT_FALSE ( IsMouseLocked ( ) ) ;\n ASSERT_FALSE ( IsFullscreenBubbleDisplayed ( ) ) ;\n ASSERT_TRUE ( ui_test_utils : : SendKeyPressAndWait ( browser ( ) , ui : : VKEY_1 , false , false , false , false , chrome : : NOTIFICATION_MOUSE_LOCK_CHANGED , content : : NotificationService : : AllSources ( ) ) ) ;\n ASSERT_TRUE ( IsMouseLocked ( ) ) ;\n ASSERT_FALSE ( IsFullscreenBubbleDisplayed ( ) ) ;\n ASSERT_TRUE ( ui_test_utils : : SendKeyPressAndWait ( browser ( ) , ui : : VKEY_U , false , false , false , false , chrome : : NOTIFICATION_MOUSE_LOCK_CHANGED , content : : NotificationService : : AllSources ( ) ) ) ;\n ASSERT_FALSE ( IsMouseLocked ( ) ) ;\n ASSERT_TRUE ( ui_test_utils : : SendKeyPressAndWait ( browser ( ) , ui : : VKEY_D , false , false , false , false , chrome : : NOTIFICATION_MOUSE_LOCK_CHANGED , content : : NotificationService : : AllSources ( ) ) ) ;\n ASSERT_TRUE ( IsMouseLocked ( ) ) ;\n ASSERT_FALSE ( IsFullscreenBubbleDisplayed ( ) ) ;\n ASSERT_TRUE ( ui_test_utils : : SendKeyPressAndWait ( browser ( ) , ui : : VKEY_ESCAPE , false , false , false , false , chrome : : NOTIFICATION_MOUSE_LOCK_CHANGED , content : : NotificationService : : AllSources ( ) ) ) ;\n ASSERT_FALSE ( IsMouseLocked ( ) ) ;\n ASSERT_TRUE ( ui_test_utils : : SendKeyPressAndWait ( browser ( ) , ui : : VKEY_1 , false , false , false , false , chrome : : NOTIFICATION_MOUSE_LOCK_CHANGED , content : : NotificationService : : AllSources ( ) ) ) ;\n ASSERT_TRUE ( IsFullscreenBubbleDisplayed ( ) ) ;\n ASSERT_TRUE ( IsMouseLocked ( ) ) ;\n }", "hash": 4537091194729139981, "project": "chrome", "size": 28, "target": 0, "idx": 18940}
{"code": "IN_PROC_BROWSER_TEST_F ( AppApiTest , OpenAppFromIframe ) {\n extensions : : ProcessMap * process_map = extensions : : ProcessMap : : Get ( browser ( ) -> profile ( ) ) ;\n GURL base_url = GetTestBaseURL ( \"app_process\" ) ;\n const Extension * app = LoadExtension ( test_data_dir_ . AppendASCII ( \"app_process\" ) ) ;\n ASSERT_TRUE ( app ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , base_url . Resolve ( \"path3/container.html\" ) ) ;\n EXPECT_FALSE ( process_map -> Contains ( browser ( ) -> tab_strip_model ( ) -> GetWebContentsAt ( 0 ) -> GetRenderProcessHost ( ) -> GetID ( ) ) ) ;\n const BrowserList * active_browser_list = BrowserList : : GetInstance ( ) ;\n EXPECT_EQ ( 2U , active_browser_list -> size ( ) ) ;\n content : : WebContents * popup_contents = active_browser_list -> get ( 1 ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n content : : WaitForLoadStop ( popup_contents ) ;\n RenderViewHost * popup_host = popup_contents -> GetRenderViewHost ( ) ;\n EXPECT_TRUE ( process_map -> Contains ( popup_host -> GetProcess ( ) -> GetID ( ) ) ) ;\n }", "hash": 174091092490434632, "project": "chrome", "size": 14, "target": 0, "idx": 18957}
{"code": "IN_PROC_BROWSER_TEST_F ( AppApiTest , ClientRedirectToAppFromExtension ) {\n LoadExtension ( test_data_dir_ . AppendASCII ( \"app_process\" ) ) ;\n const Extension * launcher = LoadExtension ( test_data_dir_ . AppendASCII ( \"app_launcher\" ) ) ;\n content : : TestNavigationObserver test_navigation_observer ( browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) , 3 ) ;\n test_navigation_observer . StartWatchingNewWebContents ( ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , launcher -> GetResourceURL ( \"client_redirect.html\" ) ) ;\n test_navigation_observer . Wait ( ) ;\n bool is_installed = false ;\n ASSERT_TRUE ( content : : ExecuteScriptAndExtractBool ( browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) , \"window.domAutomationController.send(chrome.app.isInstalled)\" , & is_installed ) ) ;\n ASSERT_TRUE ( is_installed ) ;\n }", "hash": 174091092490434632, "project": "chrome", "size": 11, "target": 0, "idx": 18961}
{"code": "void crypto_policy_set_null_cipher_hmac_sha1_80 ( crypto_policy_t * p ) {\n p -> cipher_type = NULL_CIPHER ;\n p -> cipher_key_len = 0 ;\n p -> auth_type = HMAC_SHA1 ;\n p -> auth_key_len = 20 ;\n p -> auth_tag_len = 10 ;\n p -> sec_serv = sec_serv_auth ;\n }", "hash": -8620097311326519087, "project": "chrome", "size": 8, "target": 0, "idx": 18992}
{"code": "err_status_t srtp_dealloc ( srtp_t session ) {\n srtp_stream_ctx_t * stream ;\n err_status_t status ;\n stream = session -> stream_list ;\n while ( stream != NULL ) {\n srtp_stream_t next = stream -> next ;\n status = srtp_stream_dealloc ( session , stream ) ;\n if ( status ) return status ;\n stream = next ;\n }\n if ( session -> stream_template != NULL ) {\n status = auth_dealloc ( session -> stream_template -> rtcp_auth ) ;\n if ( status ) return status ;\n status = cipher_dealloc ( session -> stream_template -> rtcp_cipher ) ;\n if ( status ) return status ;\n crypto_free ( session -> stream_template -> limit ) ;\n status = cipher_dealloc ( session -> stream_template -> rtp_cipher ) ;\n if ( status ) return status ;\n status = auth_dealloc ( session -> stream_template -> rtp_auth ) ;\n if ( status ) return status ;\n status = rdbx_dealloc ( & session -> stream_template -> rtp_rdbx ) ;\n if ( status ) return status ;\n crypto_free ( session -> stream_template ) ;\n }\n crypto_free ( session ) ;\n return err_status_ok ;\n }", "hash": -8620097311326519087, "project": "chrome", "size": 27, "target": 0, "idx": 19014}
{"code": "static void srtp_calc_aead_iv_srtcp ( srtp_stream_ctx_t * stream , v128_t * iv , uint32_t seq_num , srtcp_hdr_t * hdr ) {\n v128_t in ;\n v128_t salt ;\n memset ( & in , 0 , sizeof ( v128_t ) ) ;\n memset ( & salt , 0 , sizeof ( v128_t ) ) ;\n in . v16 [ 0 ] = 0 ;\n memcpy ( & in . v16 [ 1 ] , & hdr -> ssrc , 4 ) ;\n in . v16 [ 3 ] = 0 ;\n in . v32 [ 2 ] = 0x7FFFFFFF & htonl ( seq_num ) ;\n debug_print ( mod_srtp , \"Pre-salted RTCP IV = %s\\n\" , v128_hex_string ( & in ) ) ;\n memcpy ( salt . v8 , stream -> c_salt , 12 ) ;\n debug_print ( mod_srtp , \"RTCP SALT = %s\\n\" , v128_hex_string ( & salt ) ) ;\n v128_xor ( iv , & in , & salt ) ;\n }", "hash": -8620097311326519087, "project": "chrome", "size": 14, "target": 0, "idx": 19018}
{"code": "TEST_F ( ExtensionWelcomeNotificationTest , TimeExpiredNotification ) {\n StartPreferenceSyncing ( ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n EXPECT_EQ ( GetInt64Pref ( prefs : : kWelcomeNotificationExpirationTimestamp ) , 0 ) ;\n EXPECT_TRUE ( task_runner ( ) -> GetPendingTasks ( ) . empty ( ) ) ;\n ShowChromeNowNotification ( ) ;\n base : : TimeDelta requested_show_time = base : : TimeDelta : : FromDays ( ExtensionWelcomeNotification : : kRequestedShowTimeDays ) ;\n EXPECT_EQ ( task_runner ( ) -> GetPendingTasks ( ) . size ( ) , 1U ) ;\n EXPECT_EQ ( task_runner ( ) -> NextPendingTaskDelay ( ) , requested_show_time ) ;\n EXPECT_EQ ( message_center ( ) -> add_notification_calls ( ) , 1 ) ;\n EXPECT_EQ ( message_center ( ) -> remove_notification_calls ( ) , 0 ) ;\n EXPECT_EQ ( message_center ( ) -> notifications_with_shown_as_popup ( ) , 0 ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_TRUE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n EXPECT_EQ ( GetInt64Pref ( prefs : : kWelcomeNotificationExpirationTimestamp ) , ( GetStartTime ( ) + requested_show_time ) . ToInternalValue ( ) ) ;\n SetElapsedTime ( requested_show_time ) ;\n task_runner ( ) -> RunPendingTasks ( ) ;\n EXPECT_TRUE ( task_runner ( ) -> GetPendingTasks ( ) . empty ( ) ) ;\n EXPECT_EQ ( message_center ( ) -> add_notification_calls ( ) , 1 ) ;\n EXPECT_EQ ( message_center ( ) -> remove_notification_calls ( ) , 1 ) ;\n EXPECT_EQ ( message_center ( ) -> notifications_with_shown_as_popup ( ) , 0 ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_TRUE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_TRUE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n EXPECT_EQ ( GetInt64Pref ( prefs : : kWelcomeNotificationExpirationTimestamp ) , ( GetStartTime ( ) + requested_show_time ) . ToInternalValue ( ) ) ;\n }", "hash": 2487534775710400322, "project": "chrome", "size": 29, "target": 0, "idx": 19029}
{"code": "TEST_F ( ExtensionWelcomeNotificationTest , DelayedPreferenceSyncPreviouslyDismissed ) {\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n ShowChromeNowNotification ( ) ;\n EXPECT_EQ ( message_center ( ) -> add_notification_calls ( ) , 0 ) ;\n EXPECT_EQ ( message_center ( ) -> remove_notification_calls ( ) , 0 ) ;\n EXPECT_EQ ( message_center ( ) -> notifications_with_shown_as_popup ( ) , 0 ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n SetBooleanPref ( prefs : : kWelcomeNotificationDismissed , true ) ;\n EXPECT_TRUE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n StartPreferenceSyncing ( ) ;\n EXPECT_EQ ( message_center ( ) -> add_notification_calls ( ) , 0 ) ;\n EXPECT_EQ ( message_center ( ) -> remove_notification_calls ( ) , 0 ) ;\n EXPECT_EQ ( message_center ( ) -> notifications_with_shown_as_popup ( ) , 0 ) ;\n EXPECT_TRUE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n }", "hash": 2487534775710400322, "project": "chrome", "size": 23, "target": 0, "idx": 19033}
{"code": "TEST_F ( ExtensionWelcomeNotificationTest , ShowWelcomeNotificationAgain ) {\n StartPreferenceSyncing ( ) ;\n SetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp , true ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_TRUE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n ShowChromeNowNotification ( ) ;\n EXPECT_EQ ( message_center ( ) -> add_notification_calls ( ) , 1 ) ;\n EXPECT_EQ ( message_center ( ) -> remove_notification_calls ( ) , 0 ) ;\n EXPECT_EQ ( message_center ( ) -> notifications_with_shown_as_popup ( ) , 1 ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissed ) ) ;\n EXPECT_FALSE ( GetBooleanPref ( prefs : : kWelcomeNotificationDismissedLocal ) ) ;\n EXPECT_TRUE ( GetBooleanPref ( prefs : : kWelcomeNotificationPreviouslyPoppedUp ) ) ;\n }", "hash": 2487534775710400322, "project": "chrome", "size": 14, "target": 0, "idx": 19035}
{"code": "IN_PROC_BROWSER_TEST_F ( MessageCenterNotificationsTest , UpdateProgressNotificationWhenCenterVisible ) {\n # if defined ( OS_WIN ) && defined ( USE_ASH ) if ( base : : CommandLine : : ForCurrentProcess ( ) -> HasSwitch ( switches : : kAshBrowserTests ) ) return ;\n # endif TestAddObserver observer ( message_center ( ) ) ;\n TestDelegate * delegate ;\n Notification notification = CreateTestNotification ( \"n\" , & delegate ) ;\n notification . set_type ( message_center : : NOTIFICATION_TYPE_PROGRESS ) ;\n manager ( ) -> Add ( notification , profile ( ) ) ;\n const std : : string notification_id = manager ( ) -> GetMessageCenterNotificationIdForTest ( \"n\" , profile ( ) ) ;\n message_center ( ) -> ClickOnNotification ( notification_id ) ;\n message_center ( ) -> SetVisibility ( message_center : : VISIBILITY_MESSAGE_CENTER ) ;\n observer . reset_logs ( ) ;\n notification . set_progress ( 50 ) ;\n manager ( ) -> Update ( notification , profile ( ) ) ;\n EXPECT_EQ ( base : : StringPrintf ( \"update-%s\" , notification_id . c_str ( ) ) , observer . log ( notification_id ) ) ;\n delegate -> Release ( ) ;\n }", "hash": -4008264846350093451, "project": "chrome", "size": 16, "target": 0, "idx": 19049}
{"code": "TEST_F ( SSLErrorAssistantTest , DynamicInterstitialListMatch ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n EXPECT_EQ ( 1u , ssl_info ( ) . public_key_hashes . size ( ) ) ;\n auto config_proto = std : : make_unique < chrome_browser_ssl : : SSLErrorAssistantConfig > ( ) ;\n config_proto -> set_version_id ( kLargeVersionId ) ;\n chrome_browser_ssl : : DynamicInterstitial * filter = config_proto -> add_dynamic_interstitial ( ) ;\n filter -> set_interstitial_type ( chrome_browser_ssl : : DynamicInterstitial : : INTERSTITIAL_PAGE_CAPTIVE_PORTAL ) ;\n filter -> set_cert_error ( chrome_browser_ssl : : DynamicInterstitial : : UNKNOWN_CERT_ERROR ) ;\n filter -> add_sha256_hash ( \"sha256ightjar\" ) ;\n filter -> add_sha256_hash ( \"sha256/frogmouth\" ) ;\n filter -> add_sha256_hash ( \"sha256/poorwill\" ) ;\n filter -> set_mitm_software_name ( \"UwS\" ) ;\n filter -> set_issuer_common_name_regex ( \"whippoorwill\" ) ;\n filter = config_proto -> add_dynamic_interstitial ( ) ;\n filter -> set_interstitial_type ( chrome_browser_ssl : : DynamicInterstitial : : INTERSTITIAL_PAGE_SSL ) ;\n filter -> set_cert_error ( chrome_browser_ssl : : DynamicInterstitial : : ERR_CERT_COMMON_NAME_INVALID ) ;\n filter -> add_sha256_hash ( \"sha256uthatch\" ) ;\n filter -> add_sha256_hash ( ssl_info ( ) . public_key_hashes [ 0 ] . ToString ( ) ) ;\n filter -> add_sha256_hash ( \"sha256/treecreeper\" ) ;\n filter -> set_mitm_software_name ( \"UwS\" ) ;\n filter -> set_issuer_common_name_regex ( issuer_common_name ( ) ) ;\n filter -> set_issuer_organization_regex ( issuer_organization_name ( ) ) ;\n error_assistant ( ) -> SetErrorAssistantProto ( std : : move ( config_proto ) ) ;\n base : : Optional < DynamicInterstitialInfo > dynamic_interstitial = error_assistant ( ) -> MatchDynamicInterstitial ( ssl_info ( ) ) ;\n ASSERT_TRUE ( dynamic_interstitial ) ;\n EXPECT_EQ ( chrome_browser_ssl : : DynamicInterstitial : : INTERSTITIAL_PAGE_SSL , dynamic_interstitial -> interstitial_type ) ;\n }", "hash": 6862887795439011210, "project": "chrome", "size": 27, "target": 0, "idx": 19064}
{"code": "TEST_F ( SSLErrorAssistantTest , DynamicInterstitialListMatchBlank ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n EXPECT_EQ ( 1u , ssl_info ( ) . public_key_hashes . size ( ) ) ;\n auto config_proto = std : : make_unique < chrome_browser_ssl : : SSLErrorAssistantConfig > ( ) ;\n config_proto -> set_version_id ( kLargeVersionId ) ;\n chrome_browser_ssl : : DynamicInterstitial * filter = config_proto -> add_dynamic_interstitial ( ) ;\n filter -> set_interstitial_type ( chrome_browser_ssl : : DynamicInterstitial : : INTERSTITIAL_PAGE_SSL ) ;\n error_assistant ( ) -> SetErrorAssistantProto ( std : : move ( config_proto ) ) ;\n base : : Optional < DynamicInterstitialInfo > dynamic_interstitial = error_assistant ( ) -> MatchDynamicInterstitial ( ssl_info ( ) ) ;\n ASSERT_TRUE ( dynamic_interstitial ) ;\n EXPECT_EQ ( chrome_browser_ssl : : DynamicInterstitial : : INTERSTITIAL_PAGE_SSL , dynamic_interstitial -> interstitial_type ) ;\n }", "hash": 6862887795439011210, "project": "chrome", "size": 12, "target": 0, "idx": 19066}
{"code": "TEST_F ( BrowsingDataRemoverImplTest , EarlyShutdown ) {\n BrowsingDataRemoverImpl * remover = static_cast < BrowsingDataRemoverImpl * > ( BrowsingDataRemoverFactory : : GetForBrowserContext ( GetBrowserContext ( ) ) ) ;\n InspectableCompletionObserver completion_observer ( remover ) ;\n BrowsingDataRemoverCompletionInhibitor completion_inhibitor ;\n remover -> RemoveAndReply ( base : : Time ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_HISTORY , BrowsingDataHelper : : UNPROTECTED_WEB , & completion_observer ) ;\n completion_inhibitor . BlockUntilNearCompletion ( ) ;\n EXPECT_TRUE ( remover -> is_removing ( ) ) ;\n EXPECT_FALSE ( completion_observer . called ( ) ) ;\n DestroyBrowserContext ( ) ;\n EXPECT_TRUE ( completion_observer . called ( ) ) ;\n completion_inhibitor . ContinueToCompletion ( ) ;\n completion_observer . BlockUntilCompletion ( ) ;\n }", "hash": -1111775978048960297, "project": "chrome", "size": 13, "target": 0, "idx": 19080}
{"code": "TEST_F ( BrowsingDataRemoverImplTest , RemoveQuotaManagedDataForLastWeek ) {\n BlockUntilBrowsingDataRemoved ( base : : Time : : Now ( ) - base : : TimeDelta : : FromDays ( 7 ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_FILE_SYSTEMS | BrowsingDataRemover : : REMOVE_WEBSQL | BrowsingDataRemover : : REMOVE_APPCACHE | BrowsingDataRemover : : REMOVE_SERVICE_WORKERS | BrowsingDataRemover : : REMOVE_CACHE_STORAGE | BrowsingDataRemover : : REMOVE_INDEXEDDB , false ) ;\n EXPECT_EQ ( BrowsingDataRemover : : REMOVE_FILE_SYSTEMS | BrowsingDataRemover : : REMOVE_WEBSQL | BrowsingDataRemover : : REMOVE_APPCACHE | BrowsingDataRemover : : REMOVE_SERVICE_WORKERS | BrowsingDataRemover : : REMOVE_CACHE_STORAGE | BrowsingDataRemover : : REMOVE_INDEXEDDB , GetRemovalMask ( ) ) ;\n EXPECT_EQ ( BrowsingDataHelper : : UNPROTECTED_WEB , GetOriginTypeMask ( ) ) ;\n StoragePartitionRemovalData removal_data = GetStoragePartitionRemovalData ( ) ;\n EXPECT_EQ ( removal_data . remove_mask , StoragePartition : : REMOVE_DATA_MASK_FILE_SYSTEMS | StoragePartition : : REMOVE_DATA_MASK_WEBSQL | StoragePartition : : REMOVE_DATA_MASK_APPCACHE | StoragePartition : : REMOVE_DATA_MASK_SERVICE_WORKERS | StoragePartition : : REMOVE_DATA_MASK_CACHE_STORAGE | StoragePartition : : REMOVE_DATA_MASK_INDEXEDDB ) ;\n uint32_t expected_quota_mask = ~ StoragePartition : : QUOTA_MANAGED_STORAGE_MASK_PERSISTENT ;\n EXPECT_EQ ( removal_data . quota_storage_remove_mask , expected_quota_mask ) ;\n EXPECT_EQ ( removal_data . remove_begin , GetBeginTime ( ) ) ;\n }", "hash": -1111775978048960297, "project": "chrome", "size": 10, "target": 0, "idx": 19090}
{"code": "TEST_F ( BrowsingDataRemoverImplTest , RemoveQuotaManagedDataForeverSpecificOrigin ) {\n std : : unique_ptr < BrowsingDataFilterBuilder > builder ( BrowsingDataFilterBuilder : : Create ( BrowsingDataFilterBuilder : : WHITELIST ) ) ;\n builder -> AddRegisterableDomain ( kTestRegisterableDomain1 ) ;\n BlockUntilOriginDataRemoved ( base : : Time ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_APPCACHE | BrowsingDataRemover : : REMOVE_SERVICE_WORKERS | BrowsingDataRemover : : REMOVE_CACHE_STORAGE | BrowsingDataRemover : : REMOVE_FILE_SYSTEMS | BrowsingDataRemover : : REMOVE_INDEXEDDB | BrowsingDataRemover : : REMOVE_WEBSQL , std : : move ( builder ) ) ;\n EXPECT_EQ ( BrowsingDataRemover : : REMOVE_APPCACHE | BrowsingDataRemover : : REMOVE_SERVICE_WORKERS | BrowsingDataRemover : : REMOVE_CACHE_STORAGE | BrowsingDataRemover : : REMOVE_FILE_SYSTEMS | BrowsingDataRemover : : REMOVE_INDEXEDDB | BrowsingDataRemover : : REMOVE_WEBSQL , GetRemovalMask ( ) ) ;\n EXPECT_EQ ( BrowsingDataHelper : : UNPROTECTED_WEB , GetOriginTypeMask ( ) ) ;\n StoragePartitionRemovalData removal_data = GetStoragePartitionRemovalData ( ) ;\n EXPECT_EQ ( removal_data . remove_mask , StoragePartition : : REMOVE_DATA_MASK_FILE_SYSTEMS | StoragePartition : : REMOVE_DATA_MASK_WEBSQL | StoragePartition : : REMOVE_DATA_MASK_APPCACHE | StoragePartition : : REMOVE_DATA_MASK_SERVICE_WORKERS | StoragePartition : : REMOVE_DATA_MASK_CACHE_STORAGE | StoragePartition : : REMOVE_DATA_MASK_INDEXEDDB ) ;\n EXPECT_EQ ( removal_data . quota_storage_remove_mask , StoragePartition : : QUOTA_MANAGED_STORAGE_MASK_ALL ) ;\n EXPECT_TRUE ( removal_data . origin_matcher . Run ( kOrigin1 , mock_policy ( ) ) ) ;\n EXPECT_FALSE ( removal_data . origin_matcher . Run ( kOrigin2 , mock_policy ( ) ) ) ;\n EXPECT_FALSE ( removal_data . origin_matcher . Run ( kOrigin3 , mock_policy ( ) ) ) ;\n EXPECT_FALSE ( removal_data . origin_matcher . Run ( kOrigin4 , mock_policy ( ) ) ) ;\n }", "hash": -1111775978048960297, "project": "chrome", "size": 14, "target": 0, "idx": 19094}
{"code": "TEST_F ( BrowsingDataRemoverImplTest , RemoveDownloadsByOrigin ) {\n RemoveDownloadsTester tester ( GetBrowserContext ( ) ) ;\n std : : unique_ptr < BrowsingDataFilterBuilder > builder ( BrowsingDataFilterBuilder : : Create ( BrowsingDataFilterBuilder : : WHITELIST ) ) ;\n builder -> AddRegisterableDomain ( kTestRegisterableDomain1 ) ;\n base : : Callback < bool ( const GURL & ) > filter = builder -> BuildGeneralFilter ( ) ;\n EXPECT_CALL ( * tester . download_manager ( ) , RemoveDownloadsByURLAndTime ( ProbablySameFilter ( filter ) , _ , _ ) ) ;\n BlockUntilOriginDataRemoved ( base : : Time ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_DOWNLOADS , std : : move ( builder ) ) ;\n }", "hash": -1111775978048960297, "project": "chrome", "size": 8, "target": 0, "idx": 19103}
{"code": "static bool ModuleSort ( const ModuleEnumerator : : Module & a , const ModuleEnumerator : : Module & b ) {\n if ( a . status != b . status ) return a . status > b . status ;\n if ( a . location == b . location ) return a . name < b . name ;\n return a . location < b . location ;\n }", "hash": -4265423338146153765, "project": "chrome", "size": 5, "target": 0, "idx": 19148}
{"code": "unsigned int hb_blob_get_length ( hb_blob_t * blob ) {\n return blob -> length ;\n }", "hash": -714975729066076397, "project": "chrome", "size": 3, "target": 0, "idx": 19186}
{"code": "static inline void handle_variation_selector_cluster ( const hb_ot_shape_normalize_context_t * c , unsigned int end , bool short_circuit ) {\n hb_buffer_t * const buffer = c -> buffer ;\n hb_font_t * const font = c -> font ;\n for ( ;\n buffer -> idx < end - 1 ;\n ) {\n if ( unlikely ( buffer -> unicode -> is_variation_selector ( buffer -> cur ( + 1 ) . codepoint ) ) ) {\n if ( font -> get_glyph ( buffer -> cur ( ) . codepoint , buffer -> cur ( + 1 ) . codepoint , & buffer -> cur ( ) . glyph_index ( ) ) ) {\n buffer -> replace_glyphs ( 2 , 1 , & buffer -> cur ( ) . codepoint ) ;\n }\n else {\n set_glyph ( buffer -> cur ( ) , font ) ;\n buffer -> next_glyph ( ) ;\n set_glyph ( buffer -> cur ( ) , font ) ;\n buffer -> next_glyph ( ) ;\n }\n while ( buffer -> idx < end && unlikely ( buffer -> unicode -> is_variation_selector ( buffer -> cur ( ) . codepoint ) ) ) {\n set_glyph ( buffer -> cur ( ) , font ) ;\n buffer -> next_glyph ( ) ;\n }\n }\n else {\n set_glyph ( buffer -> cur ( ) , font ) ;\n buffer -> next_glyph ( ) ;\n }\n }\n if ( likely ( buffer -> idx < end ) ) {\n set_glyph ( buffer -> cur ( ) , font ) ;\n buffer -> next_glyph ( ) ;\n }\n }", "hash": -39241708394196484, "project": "chrome", "size": 31, "target": 0, "idx": 19190}
{"code": "static inline void output_char ( hb_buffer_t * buffer , hb_codepoint_t unichar , hb_codepoint_t glyph ) {\n buffer -> cur ( ) . glyph_index ( ) = glyph ;\n buffer -> output_glyph ( unichar ) ;\n _hb_glyph_info_set_unicode_props ( & buffer -> prev ( ) , buffer -> unicode ) ;\n }", "hash": -39241708394196484, "project": "chrome", "size": 5, "target": 0, "idx": 19197}
{"code": "static inline void decompose_multi_char_cluster ( const hb_ot_shape_normalize_context_t * c , unsigned int end , bool short_circuit ) {\n hb_buffer_t * const buffer = c -> buffer ;\n for ( unsigned int i = buffer -> idx ;\n i < end ;\n i ++ ) if ( unlikely ( buffer -> unicode -> is_variation_selector ( buffer -> info [ i ] . codepoint ) ) ) {\n handle_variation_selector_cluster ( c , end , short_circuit ) ;\n return ;\n }\n while ( buffer -> idx < end ) decompose_current_character ( c , short_circuit ) ;\n }", "hash": -39241708394196484, "project": "chrome", "size": 10, "target": 0, "idx": 19198}
{"code": "static hb_unicode_general_category_t hb_icu_unicode_general_category ( hb_unicode_funcs_t * ufuncs HB_UNUSED , hb_codepoint_t unicode , void * user_data HB_UNUSED ) {\n switch ( u_getIntPropertyValue ( unicode , UCHAR_GENERAL_CATEGORY ) ) {\n case U_UNASSIGNED : return HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED ;\n case U_UPPERCASE_LETTER : return HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER ;\n case U_LOWERCASE_LETTER : return HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER ;\n case U_TITLECASE_LETTER : return HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER ;\n case U_MODIFIER_LETTER : return HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER ;\n case U_OTHER_LETTER : return HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER ;\n case U_NON_SPACING_MARK : return HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK ;\n case U_ENCLOSING_MARK : return HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK ;\n case U_COMBINING_SPACING_MARK : return HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK ;\n case U_DECIMAL_DIGIT_NUMBER : return HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER ;\n case U_LETTER_NUMBER : return HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER ;\n case U_OTHER_NUMBER : return HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER ;\n case U_SPACE_SEPARATOR : return HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR ;\n case U_LINE_SEPARATOR : return HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR ;\n case U_PARAGRAPH_SEPARATOR : return HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR ;\n case U_CONTROL_CHAR : return HB_UNICODE_GENERAL_CATEGORY_CONTROL ;\n case U_FORMAT_CHAR : return HB_UNICODE_GENERAL_CATEGORY_FORMAT ;\n case U_PRIVATE_USE_CHAR : return HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE ;\n case U_SURROGATE : return HB_UNICODE_GENERAL_CATEGORY_SURROGATE ;\n case U_DASH_PUNCTUATION : return HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION ;\n case U_START_PUNCTUATION : return HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION ;\n case U_END_PUNCTUATION : return HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION ;\n case U_CONNECTOR_PUNCTUATION : return HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION ;\n case U_OTHER_PUNCTUATION : return HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION ;\n case U_MATH_SYMBOL : return HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL ;\n case U_CURRENCY_SYMBOL : return HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL ;\n case U_MODIFIER_SYMBOL : return HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL ;\n case U_OTHER_SYMBOL : return HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL ;\n case U_INITIAL_PUNCTUATION : return HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION ;\n case U_FINAL_PUNCTUATION : return HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION ;\n }\n return HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED ;\n }", "hash": 8084418997489372457, "project": "chrome", "size": 35, "target": 0, "idx": 19213}
{"code": "static int64_t ogg_calc_pts ( AVFormatContext * s , int idx , int64_t * dts ) {\n struct ogg * ogg = s -> priv_data ;\n struct ogg_stream * os = ogg -> streams + idx ;\n int64_t pts = AV_NOPTS_VALUE ;\n if ( dts ) * dts = AV_NOPTS_VALUE ;\n if ( os -> lastpts != AV_NOPTS_VALUE ) {\n pts = os -> lastpts ;\n os -> lastpts = AV_NOPTS_VALUE ;\n }\n if ( os -> lastdts != AV_NOPTS_VALUE ) {\n if ( dts ) * dts = os -> lastdts ;\n os -> lastdts = AV_NOPTS_VALUE ;\n }\n if ( os -> page_end ) {\n if ( os -> granule != - 1LL ) {\n if ( os -> codec && os -> codec -> granule_is_start ) pts = ogg_gptopts ( s , idx , os -> granule , dts ) ;\n else os -> lastpts = ogg_gptopts ( s , idx , os -> granule , & os -> lastdts ) ;\n os -> granule = - 1LL ;\n }\n }\n return pts ;\n }", "hash": -4765077557530511796, "project": "chrome", "size": 22, "target": 0, "idx": 19222}
{"code": "static int ogg_read_header ( AVFormatContext * s ) {\n struct ogg * ogg = s -> priv_data ;\n int ret , i ;\n ogg -> curidx = - 1 ;\n do {\n ret = ogg_packet ( s , NULL , NULL , NULL , NULL ) ;\n if ( ret < 0 ) {\n ogg_read_close ( s ) ;\n return ret ;\n }\n }\n while ( ! ogg -> headers ) ;\n av_log ( s , AV_LOG_TRACE , \"found headers\\n\" ) ;\n for ( i = 0 ;\n i < ogg -> nstreams ;\n i ++ ) {\n struct ogg_stream * os = ogg -> streams + i ;\n if ( ogg -> streams [ i ] . header < 0 ) {\n av_log ( s , AV_LOG_ERROR , \"Header parsing failed for stream %d\\n\" , i ) ;\n ogg -> streams [ i ] . codec = NULL ;\n av_freep ( & ogg -> streams [ i ] . private ) ;\n }\n else if ( os -> codec && os -> nb_header < os -> codec -> nb_header ) {\n av_log ( s , AV_LOG_WARNING , \"Headers mismatch for stream %d: \" \"expected %d received %d.\\n\" , i , os -> codec -> nb_header , os -> nb_header ) ;\n if ( s -> error_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n }\n if ( os -> start_granule != OGG_NOGRANULE_VALUE ) os -> lastpts = s -> streams [ i ] -> start_time = ogg_gptopts ( s , i , os -> start_granule , NULL ) ;\n }\n ret = ogg_get_length ( s ) ;\n if ( ret < 0 ) {\n ogg_read_close ( s ) ;\n return ret ;\n }\n return 0 ;\n }", "hash": -4765077557530511796, "project": "chrome", "size": 35, "target": 0, "idx": 19227}
{"code": "IN_PROC_BROWSER_TEST_F ( ContentSettingBubbleDialogTest , InvokeDialog_images ) {\n RunDialog ( ) ;\n }", "hash": -6627217369018123590, "project": "chrome", "size": 3, "target": 0, "idx": 19242}
{"code": "IN_PROC_BROWSER_TEST_F ( ContentSettingBubbleDialogTest , InvokeDialog_geolocation ) {\n RunDialog ( ) ;\n }", "hash": -6627217369018123590, "project": "chrome", "size": 3, "target": 0, "idx": 19243}
{"code": "IN_PROC_BROWSER_TEST_F ( ContentSettingBubbleDialogTest , InvokeDialog_mediastream_mic ) {\n RunDialog ( ) ;\n }", "hash": -6627217369018123590, "project": "chrome", "size": 3, "target": 0, "idx": 19251}
{"code": "static bool is_zero_width_char ( hb_font_t * font , hb_codepoint_t unicode ) {\n hb_codepoint_t glyph ;\n return hb_font_get_glyph ( font , unicode , 0 , & glyph ) && hb_font_get_glyph_h_advance ( font , glyph ) == 0 ;\n }", "hash": -3808839139375273429, "project": "chrome", "size": 4, "target": 0, "idx": 19253}
{"code": "static void final_reordering_syllable ( const hb_ot_shape_plan_t * plan , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n const indic_shape_plan_t * indic_plan = ( const indic_shape_plan_t * ) plan -> data ;\n hb_glyph_info_t * info = buffer -> info ;\n if ( indic_plan -> virama_glyph ) {\n unsigned int virama_glyph = indic_plan -> virama_glyph ;\n for ( unsigned int i = start ;\n i < end ;\n i ++ ) if ( info [ i ] . codepoint == virama_glyph && _hb_glyph_info_ligated ( & info [ i ] ) && _hb_glyph_info_multiplied ( & info [ i ] ) ) {\n info [ i ] . indic_category ( ) = OT_H ;\n _hb_glyph_info_clear_ligated_and_multiplied ( & info [ i ] ) ;\n }\n }\n bool try_pref = ! ! indic_plan -> mask_array [ PREF ] ;\n unsigned int base ;\n for ( base = start ;\n base < end ;\n base ++ ) if ( info [ base ] . indic_position ( ) >= POS_BASE_C ) {\n if ( try_pref && base + 1 < end && indic_plan -> config -> pref_len == 2 ) {\n for ( unsigned int i = base + 1 ;\n i < end ;\n i ++ ) if ( ( info [ i ] . mask & indic_plan -> mask_array [ PREF ] ) != 0 ) {\n if ( ! ( _hb_glyph_info_substituted ( & info [ i ] ) && _hb_glyph_info_ligated_and_didnt_multiply ( & info [ i ] ) ) ) {\n base = i ;\n while ( base < end && is_halant_or_coeng ( info [ base ] ) ) base ++ ;\n info [ base ] . indic_position ( ) = POS_BASE_C ;\n try_pref = false ;\n }\n break ;\n }\n }\n if ( start < base && info [ base ] . indic_position ( ) > POS_BASE_C ) base -- ;\n break ;\n }\n if ( base == end && start < base && is_one_of ( info [ base - 1 ] , FLAG ( OT_ZWJ ) ) ) base -- ;\n if ( base < end ) while ( start < base && is_one_of ( info [ base ] , ( FLAG ( OT_N ) | HALANT_OR_COENG_FLAGS ) ) ) base -- ;\n if ( start + 1 < end && start < base ) {\n unsigned int new_pos = base == end ? base - 2 : base - 1 ;\n if ( buffer -> props . script != HB_SCRIPT_MALAYALAM && buffer -> props . script != HB_SCRIPT_TAMIL ) {\n while ( new_pos > start && ! ( is_one_of ( info [ new_pos ] , ( FLAG ( OT_M ) | HALANT_OR_COENG_FLAGS ) ) ) ) new_pos -- ;\n if ( is_halant_or_coeng ( info [ new_pos ] ) && info [ new_pos ] . indic_position ( ) != POS_PRE_M ) {\n if ( new_pos + 1 < end && is_joiner ( info [ new_pos + 1 ] ) ) new_pos ++ ;\n }\n else new_pos = start ;\n }\n if ( start < new_pos && info [ new_pos ] . indic_position ( ) != POS_PRE_M ) {\n for ( unsigned int i = new_pos ;\n i > start ;\n i -- ) if ( info [ i - 1 ] . indic_position ( ) == POS_PRE_M ) {\n unsigned int old_pos = i - 1 ;\n hb_glyph_info_t tmp = info [ old_pos ] ;\n memmove ( & info [ old_pos ] , & info [ old_pos + 1 ] , ( new_pos - old_pos ) * sizeof ( info [ 0 ] ) ) ;\n info [ new_pos ] = tmp ;\n if ( old_pos < base && base <= new_pos ) base -- ;\n buffer -> merge_clusters ( new_pos , MIN ( end , base + 1 ) ) ;\n new_pos -- ;\n }\n }\n else {\n for ( unsigned int i = start ;\n i < base ;\n i ++ ) if ( info [ i ] . indic_position ( ) == POS_PRE_M ) {\n buffer -> merge_clusters ( i , MIN ( end , base + 1 ) ) ;\n break ;\n }\n }\n }\n if ( start + 1 < end && info [ start ] . indic_position ( ) == POS_RA_TO_BECOME_REPH && ( ( info [ start ] . indic_category ( ) == OT_Repha ) ^ _hb_glyph_info_ligated_and_didnt_multiply ( & info [ start ] ) ) ) {\n unsigned int new_reph_pos ;\n reph_position_t reph_pos = indic_plan -> config -> reph_pos ;\n assert ( reph_pos != REPH_POS_DONT_CARE ) ;\n if ( reph_pos == REPH_POS_AFTER_POST ) {\n goto reph_step_5 ;\n }\n {\n new_reph_pos = start + 1 ;\n while ( new_reph_pos < base && ! is_halant_or_coeng ( info [ new_reph_pos ] ) ) new_reph_pos ++ ;\n if ( new_reph_pos < base && is_halant_or_coeng ( info [ new_reph_pos ] ) ) {\n if ( new_reph_pos + 1 < base && is_joiner ( info [ new_reph_pos + 1 ] ) ) new_reph_pos ++ ;\n goto reph_move ;\n }\n }\n if ( reph_pos == REPH_POS_AFTER_MAIN ) {\n new_reph_pos = base ;\n while ( new_reph_pos + 1 < end && info [ new_reph_pos + 1 ] . indic_position ( ) <= POS_AFTER_MAIN ) new_reph_pos ++ ;\n if ( new_reph_pos < end ) goto reph_move ;\n }\n if ( reph_pos == REPH_POS_AFTER_SUB ) {\n new_reph_pos = base ;\n while ( new_reph_pos < end && ! ( FLAG_SAFE ( info [ new_reph_pos + 1 ] . indic_position ( ) ) & ( FLAG ( POS_POST_C ) | FLAG ( POS_AFTER_POST ) | FLAG ( POS_SMVD ) ) ) ) new_reph_pos ++ ;\n if ( new_reph_pos < end ) goto reph_move ;\n }\n reph_step_5 : {\n new_reph_pos = start + 1 ;\n while ( new_reph_pos < base && ! is_halant_or_coeng ( info [ new_reph_pos ] ) ) new_reph_pos ++ ;\n if ( new_reph_pos < base && is_halant_or_coeng ( info [ new_reph_pos ] ) ) {\n if ( new_reph_pos + 1 < base && is_joiner ( info [ new_reph_pos + 1 ] ) ) new_reph_pos ++ ;\n goto reph_move ;\n }\n }\n {\n new_reph_pos = end - 1 ;\n while ( new_reph_pos > start && info [ new_reph_pos ] . indic_position ( ) == POS_SMVD ) new_reph_pos -- ;\n if ( ! hb_options ( ) . uniscribe_bug_compatible && unlikely ( is_halant_or_coeng ( info [ new_reph_pos ] ) ) ) {\n for ( unsigned int i = base + 1 ;\n i < new_reph_pos ;\n i ++ ) if ( info [ i ] . indic_category ( ) == OT_M ) {\n new_reph_pos -- ;\n }\n }\n goto reph_move ;\n }\n reph_move : {\n buffer -> merge_clusters ( start , new_reph_pos + 1 ) ;\n hb_glyph_info_t reph = info [ start ] ;\n memmove ( & info [ start ] , & info [ start + 1 ] , ( new_reph_pos - start ) * sizeof ( info [ 0 ] ) ) ;\n info [ new_reph_pos ] = reph ;\n if ( start < base && base <= new_reph_pos ) base -- ;\n }\n }\n if ( try_pref && base + 1 < end ) {\n unsigned int pref_len = indic_plan -> config -> pref_len ;\n for ( unsigned int i = base + 1 ;\n i < end ;\n i ++ ) if ( ( info [ i ] . mask & indic_plan -> mask_array [ PREF ] ) != 0 ) {\n if ( _hb_glyph_info_substituted ( & info [ i ] ) && ( ( pref_len == 1 ) ^ _hb_glyph_info_ligated_and_didnt_multiply ( & info [ i ] ) ) ) {\n unsigned int new_pos = base ;\n if ( buffer -> props . script != HB_SCRIPT_MALAYALAM && buffer -> props . script != HB_SCRIPT_TAMIL ) {\n while ( new_pos > start && ! ( is_one_of ( info [ new_pos - 1 ] , FLAG ( OT_M ) | HALANT_OR_COENG_FLAGS ) ) ) new_pos -- ;\n if ( new_pos > start && info [ new_pos - 1 ] . indic_category ( ) == OT_M ) {\n unsigned int old_pos = i ;\n for ( unsigned int i = base + 1 ;\n i < old_pos ;\n i ++ ) if ( info [ i ] . indic_category ( ) == OT_M ) {\n new_pos -- ;\n break ;\n }\n }\n }\n if ( new_pos > start && is_halant_or_coeng ( info [ new_pos - 1 ] ) ) {\n if ( new_pos < end && is_joiner ( info [ new_pos ] ) ) new_pos ++ ;\n }\n {\n unsigned int old_pos = i ;\n buffer -> merge_clusters ( new_pos , old_pos + 1 ) ;\n hb_glyph_info_t tmp = info [ old_pos ] ;\n memmove ( & info [ new_pos + 1 ] , & info [ new_pos ] , ( old_pos - new_pos ) * sizeof ( info [ 0 ] ) ) ;\n info [ new_pos ] = tmp ;\n if ( new_pos <= base && base < old_pos ) base ++ ;\n }\n }\n break ;\n }\n }\n if ( info [ start ] . indic_position ( ) == POS_PRE_M && ( ! start || ! ( FLAG_SAFE ( _hb_glyph_info_get_general_category ( & info [ start - 1 ] ) ) & FLAG_RANGE ( HB_UNICODE_GENERAL_CATEGORY_FORMAT , HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK ) ) ) ) info [ start ] . mask |= indic_plan -> mask_array [ INIT ] ;\n if ( hb_options ( ) . uniscribe_bug_compatible ) {\n switch ( ( hb_tag_t ) plan -> props . script ) {\n case HB_SCRIPT_TAMIL : case HB_SCRIPT_SINHALA : break ;\n default : buffer -> merge_clusters ( start , end ) ;\n break ;\n }\n }\n }", "hash": -3165961362620712443, "project": "chrome", "size": 162, "target": 0, "idx": 19281}
{"code": "static inline bool is_consonant ( const hb_glyph_info_t & info ) {\n return is_one_of ( info , CONSONANT_FLAGS ) ;\n }", "hash": -3165961362620712443, "project": "chrome", "size": 3, "target": 0, "idx": 19293}
{"code": "static inline bool is_one_of ( const hb_glyph_info_t & info , unsigned int flags ) {\n if ( _hb_glyph_info_ligated ( & info ) ) return false ;\n return ! ! ( FLAG_SAFE ( info . indic_category ( ) ) & flags ) ;\n }", "hash": -3165961362620712443, "project": "chrome", "size": 4, "target": 0, "idx": 19297}
{"code": "static bool compose_indic ( const hb_ot_shape_normalize_context_t * c , hb_codepoint_t a , hb_codepoint_t b , hb_codepoint_t * ab ) {\n if ( HB_UNICODE_GENERAL_CATEGORY_IS_MARK ( c -> unicode -> general_category ( a ) ) ) return false ;\n if ( a == 0x09AFu && b == 0x09BCu ) {\n * ab = 0x09DFu ;\n return true ;\n }\n return c -> unicode -> compose ( a , b , ab ) ;\n }", "hash": -3165961362620712443, "project": "chrome", "size": 8, "target": 0, "idx": 19299}
{"code": "static void collect_features_indic ( hb_ot_shape_planner_t * plan ) {\n hb_ot_map_builder_t * map = & plan -> map ;\n map -> add_gsub_pause ( setup_syllables ) ;\n map -> add_global_bool_feature ( HB_TAG ( 'l' , 'o' , 'c' , 'l' ) ) ;\n map -> add_global_bool_feature ( HB_TAG ( 'c' , 'c' , 'm' , 'p' ) ) ;\n unsigned int i = 0 ;\n map -> add_gsub_pause ( initial_reordering ) ;\n for ( ;\n i < INDIC_BASIC_FEATURES ;\n i ++ ) {\n map -> add_feature ( indic_features [ i ] . tag , 1 , indic_features [ i ] . flags | F_MANUAL_ZWJ ) ;\n map -> add_gsub_pause ( NULL ) ;\n }\n map -> add_gsub_pause ( final_reordering ) ;\n for ( ;\n i < INDIC_NUM_FEATURES ;\n i ++ ) {\n map -> add_feature ( indic_features [ i ] . tag , 1 , indic_features [ i ] . flags | F_MANUAL_ZWJ ) ;\n }\n map -> add_global_bool_feature ( HB_TAG ( 'c' , 'a' , 'l' , 't' ) ) ;\n map -> add_global_bool_feature ( HB_TAG ( 'c' , 'l' , 'i' , 'g' ) ) ;\n map -> add_gsub_pause ( clear_syllables ) ;\n }", "hash": -3165961362620712443, "project": "chrome", "size": 23, "target": 0, "idx": 19301}
{"code": "static void override_features_myanmar ( hb_ot_shape_planner_t * plan ) {\n plan -> map . add_feature ( HB_TAG ( 'l' , 'i' , 'g' , 'a' ) , 0 , F_GLOBAL ) ;\n }", "hash": 6298409723927571872, "project": "chrome", "size": 3, "target": 0, "idx": 19310}
{"code": "void * hb_set_get_user_data ( hb_set_t * set , hb_user_data_key_t * key ) {\n return hb_object_get_user_data ( set , key ) ;\n }", "hash": 7909110399479437032, "project": "chrome", "size": 3, "target": 0, "idx": 19327}
{"code": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n # define HB_DEFINE_VALUE_TYPE ( name ) static hb_ ## name ## _t * _hb_ ## name ## _reference ( const hb_ ## name ## _t * l ) {\n hb_ ## name ## _t * c = ( hb_ ## name ## _t * ) calloc ( 1 , sizeof ( hb_ ## name ## _t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * l ;\n return c ;\n }\n static void _hb_ ## name ## _destroy ( hb_ ## name ## _t * l ) {\n free ( l ) ;\n }\n HB_DEFINE_BOXED_TYPE ( name , _hb_ ## name ## _reference , _hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan )", "hash": -4527380754569407959, "project": "chrome", "size": 20, "target": 0, "idx": 19365}
{"code": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n # define HB_DEFINE_VALUE_TYPE ( name ) static hb_ ## name ## _t * _hb_ ## name ## _reference ( const hb_ ## name ## _t * l ) {\n hb_ ## name ## _t * c = ( hb_ ## name ## _t * ) calloc ( 1 , sizeof ( hb_ ## name ## _t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * l ;\n return c ;\n }\n static void _hb_ ## name ## _destroy ( hb_ ## name ## _t * l ) {\n free ( l ) ;\n }\n HB_DEFINE_BOXED_TYPE ( name , _hb_ ## name ## _reference , _hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs )", "hash": -4527380754569407959, "project": "chrome", "size": 20, "target": 0, "idx": 19367}
{"code": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n # define HB_DEFINE_VALUE_TYPE ( name ) static hb_ ## name ## _t * _hb_ ## name ## _reference ( const hb_ ## name ## _t * l ) {\n hb_ ## name ## _t * c = ( hb_ ## name ## _t * ) calloc ( 1 , sizeof ( hb_ ## name ## _t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * l ;\n return c ;\n }\n static void _hb_ ## name ## _destroy ( hb_ ## name ## _t * l ) {\n free ( l ) ;\n }\n HB_DEFINE_BOXED_TYPE ( name , _hb_ ## name ## _reference , _hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs ) HB_DEFINE_VALUE_TYPE ( feature ) HB_DEFINE_VALUE_TYPE ( glyph_info ) HB_DEFINE_VALUE_TYPE ( glyph_position )", "hash": -4527380754569407959, "project": "chrome", "size": 20, "target": 0, "idx": 19371}
{"code": "hb_font_funcs_t * hb_font_funcs_create ( void ) {\n hb_font_funcs_t * ffuncs ;\n if ( ! ( ffuncs = hb_object_create < hb_font_funcs_t > ( ) ) ) return hb_font_funcs_get_empty ( ) ;\n ffuncs -> get = _hb_font_funcs_nil . get ;\n return ffuncs ;\n }", "hash": -8562387810778703674, "project": "chrome", "size": 6, "target": 0, "idx": 19408}
{"code": "TEST_F ( ProcessUtilTest , SpawnChild ) {\n base : : Process process = SpawnChild ( \"SimpleChildProcess\" ) ;\n ASSERT_TRUE ( process . IsValid ( ) ) ;\n EXPECT_TRUE ( base : : WaitForSingleProcess ( process . Handle ( ) , TestTimeouts : : action_max_timeout ( ) ) ) ;\n }", "hash": -2994308217034422906, "project": "chrome", "size": 5, "target": 0, "idx": 19443}
{"code": "MULTIPROCESS_TEST_MAIN ( SlowChildProcess ) {\n WaitToDie ( ProcessUtilTest : : GetSignalFilePath ( kSignalFileSlow ) . c_str ( ) ) ;\n return 0 ;\n }", "hash": -2994308217034422906, "project": "chrome", "size": 4, "target": 0, "idx": 19444}
{"code": "TEST ( IdlCompiler , ArrayTypes ) {\n base : : ListValue list ;\n list . AppendInteger ( 33 ) ;\n list . Append ( std : : make_unique < base : : ListValue > ( ) ) ;\n std : : unique_ptr < Function10 : : Params > f10_params = Function10 : : Params : : Create ( list ) ;\n ASSERT_TRUE ( f10_params != NULL ) ;\n EXPECT_EQ ( 33 , f10_params -> x ) ;\n EXPECT_TRUE ( f10_params -> y . empty ( ) ) ;\n list . Clear ( ) ;\n list . AppendInteger ( 33 ) ;\n std : : unique_ptr < base : : ListValue > sublist ( new base : : ListValue ) ;\n sublist -> AppendInteger ( 34 ) ;\n sublist -> AppendInteger ( 35 ) ;\n list . Append ( std : : move ( sublist ) ) ;\n f10_params = Function10 : : Params : : Create ( list ) ;\n ASSERT_TRUE ( f10_params != NULL ) ;\n EXPECT_EQ ( 33 , f10_params -> x ) ;\n ASSERT_EQ ( 2u , f10_params -> y . size ( ) ) ;\n EXPECT_EQ ( 34 , f10_params -> y [ 0 ] ) ;\n EXPECT_EQ ( 35 , f10_params -> y [ 1 ] ) ;\n list . Clear ( ) ;\n MyType1 a ;\n MyType1 b ;\n a . x = 5 ;\n b . x = 6 ;\n a . y = std : : string ( \"foo\" ) ;\n b . y = std : : string ( \"bar\" ) ;\n std : : unique_ptr < base : : ListValue > sublist2 ( new base : : ListValue ) ;\n sublist2 -> Append ( a . ToValue ( ) ) ;\n sublist2 -> Append ( b . ToValue ( ) ) ;\n list . Append ( std : : move ( sublist2 ) ) ;\n std : : unique_ptr < Function11 : : Params > f11_params = Function11 : : Params : : Create ( list ) ;\n ASSERT_TRUE ( f11_params != NULL ) ;\n ASSERT_EQ ( 2u , f11_params -> arg . size ( ) ) ;\n EXPECT_EQ ( 5 , f11_params -> arg [ 0 ] . x ) ;\n EXPECT_EQ ( \"foo\" , f11_params -> arg [ 0 ] . y ) ;\n EXPECT_EQ ( 6 , f11_params -> arg [ 1 ] . x ) ;\n EXPECT_EQ ( \"bar\" , f11_params -> arg [ 1 ] . y ) ;\n }", "hash": -5981110360267990064, "project": "chrome", "size": 39, "target": 0, "idx": 19447}
{"code": "static void copy_picture_range ( Picture * * to , Picture * * from , int count , H264Context * new_base , H264Context * old_base ) {\n int i ;\n for ( i = 0 ;\n i < count ;\n i ++ ) {\n assert ( ( IN_RANGE ( from [ i ] , old_base , sizeof ( * old_base ) ) || IN_RANGE ( from [ i ] , old_base -> DPB , sizeof ( Picture ) * MAX_PICTURE_COUNT ) || ! from [ i ] ) ) ;\n to [ i ] = REBASE_PICTURE ( from [ i ] , new_base , old_base ) ;\n }\n }", "hash": 1859256631654516868, "project": "chrome", "size": 9, "target": 0, "idx": 19471}
{"code": "static int init_dimensions ( H264Context * h ) {\n int width = h -> width - ( h -> sps . crop_right + h -> sps . crop_left ) ;\n int height = h -> height - ( h -> sps . crop_top + h -> sps . crop_bottom ) ;\n av_assert0 ( h -> sps . crop_right + h -> sps . crop_left < ( unsigned ) h -> width ) ;\n av_assert0 ( h -> sps . crop_top + h -> sps . crop_bottom < ( unsigned ) h -> height ) ;\n if ( ! h -> sps . crop && FFALIGN ( h -> avctx -> width , 16 ) == h -> width && FFALIGN ( h -> avctx -> height , 16 ) == h -> height ) {\n width = h -> avctx -> width ;\n height = h -> avctx -> height ;\n }\n if ( width <= 0 || height <= 0 ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"Invalid cropped dimensions: %dx%d.\\n\" , width , height ) ;\n if ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n av_log ( h -> avctx , AV_LOG_WARNING , \"Ignoring cropping information.\\n\" ) ;\n h -> sps . crop_bottom = h -> sps . crop_top = h -> sps . crop_right = h -> sps . crop_left = 0 ;\n h -> sps . crop = 0 ;\n width = h -> width ;\n height = h -> height ;\n }\n h -> avctx -> coded_width = h -> width ;\n h -> avctx -> coded_height = h -> height ;\n h -> avctx -> width = width ;\n h -> avctx -> height = height ;\n return 0 ;\n }", "hash": 1859256631654516868, "project": "chrome", "size": 24, "target": 0, "idx": 19478}
{"code": "int ff_h264_decode_extradata ( H264Context * h , const uint8_t * buf , int size ) {\n AVCodecContext * avctx = h -> avctx ;\n int ret ;\n if ( ! buf || size <= 0 ) return - 1 ;\n if ( buf [ 0 ] == 1 ) {\n int i , cnt , nalsize ;\n const unsigned char * p = buf ;\n h -> is_avc = 1 ;\n if ( size < 7 ) {\n av_log ( avctx , AV_LOG_ERROR , \"avcC too short\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n h -> nal_length_size = 2 ;\n cnt = * ( p + 5 ) & 0x1f ;\n p += 6 ;\n for ( i = 0 ;\n i < cnt ;\n i ++ ) {\n nalsize = AV_RB16 ( p ) + 2 ;\n if ( nalsize > size - ( p - buf ) ) return AVERROR_INVALIDDATA ;\n ret = decode_nal_units ( h , p , nalsize , 1 ) ;\n if ( ret < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Decoding sps %d from avcC failed\\n\" , i ) ;\n return ret ;\n }\n p += nalsize ;\n }\n cnt = * ( p ++ ) ;\n for ( i = 0 ;\n i < cnt ;\n i ++ ) {\n nalsize = AV_RB16 ( p ) + 2 ;\n if ( nalsize > size - ( p - buf ) ) return AVERROR_INVALIDDATA ;\n ret = decode_nal_units ( h , p , nalsize , 1 ) ;\n if ( ret < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Decoding pps %d from avcC failed\\n\" , i ) ;\n return ret ;\n }\n p += nalsize ;\n }\n h -> nal_length_size = ( buf [ 4 ] & 0x03 ) + 1 ;\n }\n else {\n h -> is_avc = 0 ;\n ret = decode_nal_units ( h , buf , size , 1 ) ;\n if ( ret < 0 ) return ret ;\n }\n return size ;\n }", "hash": 1859256631654516868, "project": "chrome", "size": 49, "target": 0, "idx": 19509}
{"code": "int avpriv_h264_has_num_reorder_frames ( AVCodecContext * avctx ) {\n H264Context * h = avctx -> priv_data ;\n return h ? h -> sps . num_reorder_frames : 0 ;\n }", "hash": 1859256631654516868, "project": "chrome", "size": 4, "target": 0, "idx": 19512}
{"code": "IN_PROC_BROWSER_TEST_F ( ExtensionPreferenceApiTest , SessionOnlyIncognito ) {\n PrefService * prefs = profile_ -> GetPrefs ( ) ;\n prefs -> SetBoolean ( prefs : : kBlockThirdPartyCookies , false ) ;\n EXPECT_TRUE ( RunExtensionTestIncognito ( \"preference/session_only_incognito\" ) ) << message_ ;\n EXPECT_TRUE ( profile_ -> HasOffTheRecordProfile ( ) ) ;\n PrefService * otr_prefs = profile_ -> GetOffTheRecordProfile ( ) -> GetPrefs ( ) ;\n const PrefService : : Preference * pref = otr_prefs -> FindPreference ( prefs : : kBlockThirdPartyCookies ) ;\n ASSERT_TRUE ( pref ) ;\n EXPECT_TRUE ( pref -> IsExtensionControlled ( ) ) ;\n EXPECT_FALSE ( otr_prefs -> GetBoolean ( prefs : : kBlockThirdPartyCookies ) ) ;\n pref = prefs -> FindPreference ( prefs : : kBlockThirdPartyCookies ) ;\n ASSERT_TRUE ( pref ) ;\n EXPECT_FALSE ( pref -> IsExtensionControlled ( ) ) ;\n EXPECT_FALSE ( prefs -> GetBoolean ( prefs : : kBlockThirdPartyCookies ) ) ;\n }", "hash": 8693230691624196914, "project": "chrome", "size": 15, "target": 0, "idx": 19526}
{"code": "TEST_F ( BaseSearchProviderTest , PreserveAnswersWhenDeduplicating ) {\n TemplateURLData data ;\n data . SetURL ( \"http://foo.com/url?bar={\nsearchTerms}\n\" ) ;\n std : : unique_ptr < TemplateURL > template_url ( new TemplateURL ( data ) ) ;\n TestBaseSearchProvider : : MatchMap map ;\n base : : string16 query = base : : ASCIIToUTF16 ( \"weather los angeles\" ) ;\n base : : string16 answer_contents = base : : ASCIIToUTF16 ( \"some answer content\" ) ;\n base : : string16 answer_type = base : : ASCIIToUTF16 ( \"2334\" ) ;\n std : : unique_ptr < SuggestionAnswer > answer ( new SuggestionAnswer ( ) ) ;\n answer -> set_type ( 2334 ) ;\n EXPECT_CALL ( * provider_ , GetInput ( _ ) ) . WillRepeatedly ( Return ( AutocompleteInput ( ) ) ) ;\n EXPECT_CALL ( * provider_ , GetTemplateURL ( _ ) ) . WillRepeatedly ( Return ( template_url . get ( ) ) ) ;\n SearchSuggestionParser : : SuggestResult more_relevant ( query , AutocompleteMatchType : : SEARCH_HISTORY , 0 , query , base : : string16 ( ) , base : : string16 ( ) , base : : string16 ( ) , base : : string16 ( ) , nullptr , std : : string ( ) , std : : string ( ) , false , 1300 , true , false , query ) ;\n provider_ -> AddMatchToMap ( more_relevant , std : : string ( ) , TemplateURLRef : : NO_SUGGESTION_CHOSEN , false , false , & map ) ;\n SearchSuggestionParser : : SuggestResult less_relevant ( query , AutocompleteMatchType : : SEARCH_SUGGEST , 0 , query , base : : string16 ( ) , base : : string16 ( ) , answer_contents , answer_type , SuggestionAnswer : : copy ( answer . get ( ) ) , std : : string ( ) , std : : string ( ) , false , 850 , true , false , query ) ;\n provider_ -> AddMatchToMap ( less_relevant , std : : string ( ) , TemplateURLRef : : NO_SUGGESTION_CHOSEN , false , false , & map ) ;\n ASSERT_EQ ( 1U , map . size ( ) ) ;\n AutocompleteMatch match = map . begin ( ) -> second ;\n ASSERT_EQ ( 1U , match . duplicate_matches . size ( ) ) ;\n AutocompleteMatch duplicate = match . duplicate_matches [ 0 ] ;\n EXPECT_EQ ( answer_contents , match . answer_contents ) ;\n EXPECT_EQ ( answer_type , match . answer_type ) ;\n EXPECT_TRUE ( answer -> Equals ( * match . answer ) ) ;\n EXPECT_EQ ( AutocompleteMatchType : : SEARCH_HISTORY , match . type ) ;\n EXPECT_EQ ( 1300 , match . relevance ) ;\n EXPECT_EQ ( answer_contents , duplicate . answer_contents ) ;\n EXPECT_EQ ( answer_type , duplicate . answer_type ) ;\n EXPECT_TRUE ( answer -> Equals ( * duplicate . answer ) ) ;\n EXPECT_EQ ( AutocompleteMatchType : : SEARCH_SUGGEST , duplicate . type ) ;\n EXPECT_EQ ( 850 , duplicate . relevance ) ;\n map . clear ( ) ;\n base : : string16 answer_contents2 = base : : ASCIIToUTF16 ( \"different answer\" ) ;\n base : : string16 answer_type2 = base : : ASCIIToUTF16 ( \"8242\" ) ;\n std : : unique_ptr < SuggestionAnswer > answer2 ( new SuggestionAnswer ( ) ) ;\n answer2 -> set_type ( 8242 ) ;\n more_relevant = SearchSuggestionParser : : SuggestResult ( query , AutocompleteMatchType : : SEARCH_HISTORY , 0 , query , base : : string16 ( ) , base : : string16 ( ) , answer_contents2 , answer_type2 , SuggestionAnswer : : copy ( answer2 . get ( ) ) , std : : string ( ) , std : : string ( ) , false , 1300 , true , false , query ) ;\n provider_ -> AddMatchToMap ( more_relevant , std : : string ( ) , TemplateURLRef : : NO_SUGGESTION_CHOSEN , false , false , & map ) ;\n provider_ -> AddMatchToMap ( less_relevant , std : : string ( ) , TemplateURLRef : : NO_SUGGESTION_CHOSEN , false , false , & map ) ;\n ASSERT_EQ ( 1U , map . size ( ) ) ;\n match = map . begin ( ) -> second ;\n ASSERT_EQ ( 1U , match . duplicate_matches . size ( ) ) ;\n duplicate = match . duplicate_matches [ 0 ] ;\n EXPECT_EQ ( answer_contents2 , match . answer_contents ) ;\n EXPECT_EQ ( answer_type2 , match . answer_type ) ;\n EXPECT_TRUE ( answer2 -> Equals ( * match . answer ) ) ;\n EXPECT_EQ ( AutocompleteMatchType : : SEARCH_HISTORY , match . type ) ;\n EXPECT_EQ ( 1300 , match . relevance ) ;\n EXPECT_EQ ( answer_contents , duplicate . answer_contents ) ;\n EXPECT_EQ ( answer_type , duplicate . answer_type ) ;\n EXPECT_TRUE ( answer -> Equals ( * duplicate . answer ) ) ;\n EXPECT_EQ ( AutocompleteMatchType : : SEARCH_SUGGEST , duplicate . type ) ;\n EXPECT_EQ ( 850 , duplicate . relevance ) ;\n }", "hash": 2665556484162371794, "project": "chrome", "size": 55, "target": 0, "idx": 19554}
{"code": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , BackgroundThenForeground_Http ) {\n StartHttpServer ( ) ;\n base : : TimeDelta upper_bound = NavigateInBackgroundAndCloseInForegroundWithTiming ( http_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpEngagementHistogram ) [ 0 ] . min ;\n EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;\n EXPECT_LT ( 0 , bucket_min ) ;\n FakeUserMetricsUpload ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementSessionPercentage , 1 ) ;\n int32_t ratio_bucket = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementSessionPercentage ) [ 0 ] . min ;\n EXPECT_EQ ( 0 , ratio_bucket ) ;\n }", "hash": 8206514580434225668, "project": "chrome", "size": 13, "target": 0, "idx": 19559}
{"code": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , Simple_Http ) {\n StartHttpServer ( ) ;\n base : : TimeDelta upper_bound = NavigateInForegroundAndCloseWithTiming ( http_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpEngagementHistogram ) [ 0 ] . min ;\n EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;\n EXPECT_LT ( 0 , bucket_min ) ;\n FakeUserMetricsUpload ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementSessionPercentage , 1 ) ;\n int32_t ratio_bucket = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementSessionPercentage ) [ 0 ] . min ;\n EXPECT_EQ ( 0 , ratio_bucket ) ;\n }", "hash": 8206514580434225668, "project": "chrome", "size": 13, "target": 0, "idx": 19560}
{"code": "void BrotliStateInit ( BrotliState * s ) {\n BrotliStateInitWithCustomAllocators ( s , 0 , 0 , 0 ) ;\n }", "hash": -6966071246558644086, "project": "chrome", "size": 3, "target": 0, "idx": 19584}
{"code": "static void DefaultFreeFunc ( void * opaque , void * address ) {\n BROTLI_UNUSED ( opaque ) ;\n free ( address ) ;\n }", "hash": -6966071246558644086, "project": "chrome", "size": 4, "target": 0, "idx": 19589}
{"code": "TEST_F ( OmniboxEditTest , AdjustTextForCopy ) {\n struct Data {\n const char * perm_text ;\n const int sel_start ;\n const bool is_all_selected ;\n const char * input ;\n const char * expected_output ;\n const bool write_url ;\n const char * expected_url ;\n }\n input [ ] = {\n {\n \"a.de/b\" , 0 , true , \"a.de/b\" , \"http://a.de/b\" , true , \"http://a.de/b\" , }\n , {\n \"a.de/b\" , 0 , false , \"a.de/\" , \"http://a.de/\" , true , \"http://a.de/\" }\n , {\n \"a.de/b\" , 0 , false , \"a.de/c\" , \"http://a.de/c\" , true , \"http://a.de/c\" }\n , {\n \"a.de/b\" , 0 , false , \"a.com/b\" , \"a.com/b\" , false , \"\" }\n , {\n \"a.de/b\" , 1 , false , \"a.de/b\" , \"a.de/b\" , false , \"\" }\n , {\n \"a.de/\" , 0 , false , \"a.d\" , \"a.d\" , false , \"\" }\n , {\n \"https://a.com/\" , 0 , false , \"a.com/\" , \"a.com/\" , false , \"\" }\n , {\n \"a.de/\" , 0 , false , \"a.de.com/\" , \"a.de.com/\" , false , \"\" }\n , {\n \"a.de/\" , 0 , false , \"http://a.de/\" , \"http://a.de/\" , true , \"http://a.de/\" }\n , {\n \"b/foo\" , 0 , true , \"b/foo\" , \"http://b/foo\" , true , \"http://b/foo\" }\n , {\n \"www.google.com/search?\" , 0 , false , \"foo\" , \"foo\" , false , \"\" }\n , }\n ;\n for ( size_t i = 0 ;\n i < arraysize ( input ) ;\n ++ i ) {\n toolbar_model ( ) -> set_text ( base : : ASCIIToUTF16 ( input [ i ] . perm_text ) ) ;\n model ( ) -> UpdatePermanentText ( ) ;\n base : : string16 result = base : : ASCIIToUTF16 ( input [ i ] . input ) ;\n GURL url ;\n bool write_url ;\n model ( ) -> AdjustTextForCopy ( input [ i ] . sel_start , input [ i ] . is_all_selected , & result , & url , & write_url ) ;\n EXPECT_EQ ( base : : ASCIIToUTF16 ( input [ i ] . expected_output ) , result ) << \"@: \" << i ;\n EXPECT_EQ ( input [ i ] . write_url , write_url ) << \" @\" << i ;\n if ( write_url ) EXPECT_EQ ( input [ i ] . expected_url , url . spec ( ) ) << \" @\" << i ;\n }\n }", "hash": 7275105534361052337, "project": "chrome", "size": 49, "target": 0, "idx": 19593}
{"code": "static FT_Error t42_load_keyword ( T42_Face face , T42_Loader loader , T1_Field field ) {\n FT_Error error ;\n void * dummy_object ;\n void * * objects ;\n FT_UInt max_objects = 0 ;\n if ( field -> type == T1_FIELD_TYPE_CALLBACK ) {\n field -> reader ( ( FT_Face ) face , loader ) ;\n error = loader -> parser . root . error ;\n goto Exit ;\n }\n switch ( field -> location ) {\n case T1_FIELD_LOCATION_FONT_INFO : dummy_object = & face -> type1 . font_info ;\n break ;\n case T1_FIELD_LOCATION_FONT_EXTRA : dummy_object = & face -> type1 . font_extra ;\n break ;\n case T1_FIELD_LOCATION_BBOX : dummy_object = & face -> type1 . font_bbox ;\n break ;\n default : dummy_object = & face -> type1 ;\n }\n objects = & dummy_object ;\n if ( field -> type == T1_FIELD_TYPE_INTEGER_ARRAY || field -> type == T1_FIELD_TYPE_FIXED_ARRAY ) error = T1_Load_Field_Table ( & loader -> parser , field , objects , max_objects , 0 ) ;\n else error = T1_Load_Field ( & loader -> parser , field , objects , max_objects , 0 ) ;\n Exit : return error ;\n }", "hash": 3919353496513339611, "project": "chrome", "size": 24, "target": 0, "idx": 19610}
{"code": "IN_PROC_BROWSER_TEST_F ( MediaStreamPermissionTest , TestDismissIsNotSticky ) {\n content : : WebContents * tab_contents = LoadTestPageInTab ( ) ;\n GetUserMediaAndDismiss ( tab_contents ) ;\n GetUserMediaAndDismiss ( tab_contents ) ;\n }", "hash": 4952739496652083313, "project": "chrome", "size": 5, "target": 0, "idx": 19643}
{"code": "TEST_F ( NativeBackendLibsecretTest , RemoveLoginsSyncedBetween ) {\n CheckRemoveLoginsBetween ( SYNCED ) ;\n }", "hash": -4886619136962902359, "project": "chrome", "size": 3, "target": 0, "idx": 19668}
{"code": "TEST ( BuildTime , DateLooksValid ) {\n char build_date [ ] = BUILD_DATE ;\n EXPECT_EQ ( 11u , strlen ( build_date ) ) ;\n EXPECT_EQ ( ' ' , build_date [ 3 ] ) ;\n EXPECT_EQ ( ' ' , build_date [ 6 ] ) ;\n }", "hash": -7441512654057958783, "project": "chrome", "size": 6, "target": 0, "idx": 19679}
{"code": "void evsignal_process ( struct event_base * base ) {\n struct evsignal_info * sig = & base -> sig ;\n struct event * ev , * next_ev ;\n sig_atomic_t ncalls ;\n int i ;\n base -> sig . evsignal_caught = 0 ;\n for ( i = 1 ;\n i < NSIG ;\n ++ i ) {\n ncalls = sig -> evsigcaught [ i ] ;\n if ( ncalls == 0 ) continue ;\n sig -> evsigcaught [ i ] -= ncalls ;\n for ( ev = TAILQ_FIRST ( & sig -> evsigevents [ i ] ) ;\n ev != NULL ;\n ev = next_ev ) {\n next_ev = TAILQ_NEXT ( ev , ev_signal_next ) ;\n if ( ! ( ev -> ev_events & EV_PERSIST ) ) event_del ( ev ) ;\n event_active ( ev , EV_SIGNAL , ncalls ) ;\n }\n }\n }", "hash": 6980637897759012306, "project": "chrome", "size": 21, "target": 0, "idx": 19681}
{"code": "void min_heap_shift_down_ ( min_heap_t * s , unsigned hole_index , struct event * e ) {\n unsigned min_child = 2 * ( hole_index + 1 ) ;\n while ( min_child <= s -> n ) {\n min_child -= min_child == s -> n || min_heap_elem_greater ( s -> p [ min_child ] , s -> p [ min_child - 1 ] ) ;\n if ( ! ( min_heap_elem_greater ( e , s -> p [ min_child ] ) ) ) break ;\n ( s -> p [ hole_index ] = s -> p [ min_child ] ) -> min_heap_idx = hole_index ;\n hole_index = min_child ;\n min_child = 2 * ( hole_index + 1 ) ;\n }\n min_heap_shift_up_ ( s , hole_index , e ) ;\n }", "hash": -1514879141119470937, "project": "chrome", "size": 11, "target": 0, "idx": 19690}
{"code": "int min_heap_elem_greater ( struct event * a , struct event * b ) {\n return evutil_timercmp ( & a -> ev_timeout , & b -> ev_timeout , > ) ;\n }", "hash": -1514879141119470937, "project": "chrome", "size": 3, "target": 0, "idx": 19692}
{"code": "int event_dispatch ( void ) {\n return ( event_loop ( 0 ) ) ;\n }", "hash": 8461266595329035000, "project": "chrome", "size": 3, "target": 0, "idx": 19705}
{"code": "void event_active ( struct event * ev , int res , short ncalls ) {\n if ( ev -> ev_flags & EVLIST_ACTIVE ) {\n ev -> ev_res |= res ;\n return ;\n }\n ev -> ev_res = res ;\n ev -> ev_ncalls = ncalls ;\n ev -> ev_pncalls = NULL ;\n event_queue_insert ( ev -> ev_base , ev , EVLIST_ACTIVE ) ;\n }", "hash": 8461266595329035000, "project": "chrome", "size": 10, "target": 0, "idx": 19708}
{"code": "int event_haveevents ( struct event_base * base ) {\n return ( base -> event_count > 0 ) ;\n }", "hash": 8461266595329035000, "project": "chrome", "size": 3, "target": 0, "idx": 19710}
{"code": "void event_queue_insert ( struct event_base * base , struct event * ev , int queue ) {\n if ( ev -> ev_flags & queue ) {\n if ( queue & EVLIST_ACTIVE ) return ;\n event_errx ( 1 , \"%s: %p(fd %d) already on queue %x\" , __func__ , ev , ev -> ev_fd , queue ) ;\n }\n if ( ~ ev -> ev_flags & EVLIST_INTERNAL ) base -> event_count ++ ;\n ev -> ev_flags |= queue ;\n switch ( queue ) {\n case EVLIST_INSERTED : TAILQ_INSERT_TAIL ( & base -> eventqueue , ev , ev_next ) ;\n break ;\n case EVLIST_ACTIVE : base -> event_count_active ++ ;\n TAILQ_INSERT_TAIL ( base -> activequeues [ ev -> ev_pri ] , ev , ev_active_next ) ;\n break ;\n case EVLIST_TIMEOUT : {\n min_heap_push ( & base -> timeheap , ev ) ;\n break ;\n }\n default : event_errx ( 1 , \"%s: unknown queue %x\" , __func__ , queue ) ;\n }\n }", "hash": 8461266595329035000, "project": "chrome", "size": 20, "target": 0, "idx": 19715}
{"code": "const char * event_get_method ( void ) {\n return ( current_base -> evsel -> name ) ;\n }", "hash": 8461266595329035000, "project": "chrome", "size": 3, "target": 0, "idx": 19717}
{"code": "static void test_free_active_base ( void ) {\n struct event_base * base1 ;\n struct event ev1 ;\n setup_test ( \"Free active base: \" ) ;\n base1 = event_init ( ) ;\n event_set ( & ev1 , pair [ 1 ] , EV_READ , simple_read_cb , & ev1 ) ;\n event_base_set ( base1 , & ev1 ) ;\n event_add ( & ev1 , NULL ) ;\n event_base_free ( base1 ) ;\n test_ok = 1 ;\n cleanup_test ( ) ;\n }", "hash": 5347874611477979643, "project": "chrome", "size": 12, "target": 0, "idx": 19749}
{"code": "static void test_signal_while_processing ( void ) {\n struct event_base * base = event_init ( ) ;\n struct event ev , ev_timer ;\n struct timeval tv = {\n 0 , 0 }\n ;\n setup_test ( \"Receiving a signal while processing other signal: \" ) ;\n called = - 1 ;\n test_ok = 1 ;\n signal_set ( & ev , SIGUSR1 , signal_cb_swp , NULL ) ;\n signal_add ( & ev , NULL ) ;\n evtimer_set ( & ev_timer , timeout_cb_swp , & ev_timer ) ;\n evtimer_add ( & ev_timer , & tv ) ;\n event_dispatch ( ) ;\n event_base_free ( base ) ;\n cleanup_test ( ) ;\n return ;\n }", "hash": 5347874611477979643, "project": "chrome", "size": 18, "target": 0, "idx": 19754}
{"code": "static void evtag_int_test ( void ) {\n struct evbuffer * tmp = evbuffer_new ( ) ;\n uint32_t integers [ TEST_MAX_INT ] = {\n 0xaf0 , 0x1000 , 0x1 , 0xdeadbeef , 0x00 , 0xbef000 }\n ;\n uint32_t integer ;\n int i ;\n for ( i = 0 ;\n i < TEST_MAX_INT ;\n i ++ ) {\n int oldlen , newlen ;\n oldlen = EVBUFFER_LENGTH ( tmp ) ;\n encode_int ( tmp , integers [ i ] ) ;\n newlen = EVBUFFER_LENGTH ( tmp ) ;\n fprintf ( stdout , \"\\t\\tencoded 0x%08x with %d bytes\\n\" , integers [ i ] , newlen - oldlen ) ;\n }\n for ( i = 0 ;\n i < TEST_MAX_INT ;\n i ++ ) {\n if ( evtag_decode_int ( & integer , tmp ) == - 1 ) {\n fprintf ( stderr , \"decode %d failed\" , i ) ;\n exit ( 1 ) ;\n }\n if ( integer != integers [ i ] ) {\n fprintf ( stderr , \"got %x, wanted %x\" , integer , integers [ i ] ) ;\n exit ( 1 ) ;\n }\n }\n if ( EVBUFFER_LENGTH ( tmp ) != 0 ) {\n fprintf ( stderr , \"trailing data\" ) ;\n exit ( 1 ) ;\n }\n evbuffer_free ( tmp ) ;\n fprintf ( stdout , \"\\t%s: OK\\n\" , __func__ ) ;\n }", "hash": 5347874611477979643, "project": "chrome", "size": 35, "target": 0, "idx": 19761}
{"code": "static void test_signal_switchbase ( void ) {\n struct event ev1 , ev2 ;\n struct event_base * base1 , * base2 ;\n int is_kqueue ;\n test_ok = 0 ;\n printf ( \"Signal switchbase: \" ) ;\n base1 = event_init ( ) ;\n base2 = event_init ( ) ;\n is_kqueue = ! strcmp ( event_get_method ( ) , \"kqueue\" ) ;\n signal_set ( & ev1 , SIGUSR1 , signal_cb , & ev1 ) ;\n signal_set ( & ev2 , SIGUSR1 , signal_cb , & ev2 ) ;\n if ( event_base_set ( base1 , & ev1 ) || event_base_set ( base2 , & ev2 ) || event_add ( & ev1 , NULL ) || event_add ( & ev2 , NULL ) ) {\n fprintf ( stderr , \"%s: cannot set base, add\\n\" , __func__ ) ;\n exit ( 1 ) ;\n }\n test_ok = 0 ;\n raise ( SIGUSR1 ) ;\n event_base_loop ( base2 , EVLOOP_NONBLOCK ) ;\n if ( is_kqueue ) {\n if ( ! test_ok ) goto done ;\n test_ok = 0 ;\n }\n event_base_loop ( base1 , EVLOOP_NONBLOCK ) ;\n if ( test_ok && ! is_kqueue ) {\n test_ok = 0 ;\n event_base_loop ( base1 , EVLOOP_NONBLOCK ) ;\n raise ( SIGUSR1 ) ;\n event_base_loop ( base1 , EVLOOP_NONBLOCK ) ;\n event_base_loop ( base2 , EVLOOP_NONBLOCK ) ;\n }\n done : event_base_free ( base1 ) ;\n event_base_free ( base2 ) ;\n cleanup_test ( ) ;\n }", "hash": 5347874611477979643, "project": "chrome", "size": 34, "target": 0, "idx": 19764}
{"code": "static void child_signal_cb ( int fd , short event , void * arg ) {\n struct timeval tv ;\n int * pint = arg ;\n * pint = 1 ;\n tv . tv_usec = 500000 ;\n tv . tv_sec = 0 ;\n event_loopexit ( & tv ) ;\n }", "hash": 5347874611477979643, "project": "chrome", "size": 8, "target": 0, "idx": 19783}
{"code": "static void test_multiple_cb ( int fd , short event , void * arg ) {\n if ( event & EV_READ ) test_ok |= 1 ;\n else if ( event & EV_WRITE ) test_ok |= 2 ;\n }", "hash": 5347874611477979643, "project": "chrome", "size": 4, "target": 0, "idx": 19800}
{"code": "static void test_combined ( void ) {\n struct both r1 , r2 , w1 , w2 ;\n setup_test ( \"Combined read/write: \" ) ;\n memset ( & r1 , 0 , sizeof ( r1 ) ) ;\n memset ( & r2 , 0 , sizeof ( r2 ) ) ;\n memset ( & w1 , 0 , sizeof ( w1 ) ) ;\n memset ( & w2 , 0 , sizeof ( w2 ) ) ;\n w1 . nread = 4096 ;\n w2 . nread = 8192 ;\n event_set ( & r1 . ev , pair [ 0 ] , EV_READ , combined_read_cb , & r1 ) ;\n event_set ( & w1 . ev , pair [ 0 ] , EV_WRITE , combined_write_cb , & w1 ) ;\n event_set ( & r2 . ev , pair [ 1 ] , EV_READ , combined_read_cb , & r2 ) ;\n event_set ( & w2 . ev , pair [ 1 ] , EV_WRITE , combined_write_cb , & w2 ) ;\n if ( event_add ( & r1 . ev , NULL ) == - 1 ) exit ( 1 ) ;\n if ( event_add ( & w1 . ev , NULL ) ) exit ( 1 ) ;\n if ( event_add ( & r2 . ev , NULL ) ) exit ( 1 ) ;\n if ( event_add ( & w2 . ev , NULL ) ) exit ( 1 ) ;\n event_dispatch ( ) ;\n if ( r1 . nread == 8192 && r2 . nread == 4096 ) test_ok = 1 ;\n cleanup_test ( ) ;\n }", "hash": 5347874611477979643, "project": "chrome", "size": 21, "target": 0, "idx": 19805}
{"code": "static void signal_cb ( int fd , short event , void * arg ) {\n struct event * signal = arg ;\n printf ( \"%s: got signal %d\\n\" , __func__ , EVENT_SIGNAL ( signal ) ) ;\n if ( called >= 2 ) event_del ( signal ) ;\n called ++ ;\n }", "hash": 2058562589071273546, "project": "chrome", "size": 6, "target": 0, "idx": 19815}
{"code": "int evbuffer_remove ( struct evbuffer * buf , void * data , size_t datlen ) {\n size_t nread = datlen ;\n if ( nread >= buf -> off ) nread = buf -> off ;\n memcpy ( data , buf -> buffer , nread ) ;\n evbuffer_drain ( buf , nread ) ;\n return ( nread ) ;\n }", "hash": 5704453449583823009, "project": "chrome", "size": 7, "target": 0, "idx": 19819}
{"code": "int evbuffer_expand ( struct evbuffer * buf , size_t datlen ) {\n size_t used = buf -> misalign + buf -> off ;\n assert ( buf -> totallen >= used ) ;\n if ( buf -> totallen - used >= datlen ) return ( 0 ) ;\n if ( datlen > SIZE_MAX - buf -> off ) return ( - 1 ) ;\n if ( buf -> totallen - buf -> off >= datlen ) {\n evbuffer_align ( buf ) ;\n }\n else {\n void * newbuf ;\n size_t length = buf -> totallen ;\n size_t need = buf -> off + datlen ;\n if ( length < 256 ) length = 256 ;\n if ( need < SIZE_MAX / 2 ) {\n while ( length < need ) {\n length <<= 1 ;\n }\n }\n else {\n length = need ;\n }\n if ( buf -> orig_buffer != buf -> buffer ) evbuffer_align ( buf ) ;\n if ( ( newbuf = realloc ( buf -> buffer , length ) ) == NULL ) return ( - 1 ) ;\n buf -> orig_buffer = buf -> buffer = newbuf ;\n buf -> totallen = length ;\n }\n return ( 0 ) ;\n }", "hash": 5704453449583823009, "project": "chrome", "size": 28, "target": 0, "idx": 19824}
{"code": "char * evbuffer_readline ( struct evbuffer * buffer ) {\n u_char * data = EVBUFFER_DATA ( buffer ) ;\n size_t len = EVBUFFER_LENGTH ( buffer ) ;\n char * line ;\n unsigned int i ;\n for ( i = 0 ;\n i < len ;\n i ++ ) {\n if ( data [ i ] == '\\r' || data [ i ] == '\\n' ) break ;\n }\n if ( i == len ) return ( NULL ) ;\n if ( ( line = malloc ( i + 1 ) ) == NULL ) {\n fprintf ( stderr , \"%s: out of memory\\n\" , __func__ ) ;\n return ( NULL ) ;\n }\n memcpy ( line , data , i ) ;\n line [ i ] = '\\0' ;\n if ( i < len - 1 ) {\n char fch = data [ i ] , sch = data [ i + 1 ] ;\n if ( ( sch == '\\r' || sch == '\\n' ) && sch != fch ) i += 1 ;\n }\n evbuffer_drain ( buffer , i + 1 ) ;\n return ( line ) ;\n }", "hash": 5704453449583823009, "project": "chrome", "size": 24, "target": 0, "idx": 19828}
{"code": "struct evdns_server_port * evdns_add_server_port ( int socket , int is_tcp , evdns_request_callback_fn_type cb , void * user_data ) {\n struct evdns_server_port * port ;\n if ( ! ( port = malloc ( sizeof ( struct evdns_server_port ) ) ) ) return NULL ;\n memset ( port , 0 , sizeof ( struct evdns_server_port ) ) ;\n assert ( ! is_tcp ) ;\n port -> socket = socket ;\n port -> refcnt = 1 ;\n port -> choked = 0 ;\n port -> closing = 0 ;\n port -> user_callback = cb ;\n port -> user_data = user_data ;\n port -> pending_replies = NULL ;\n event_set ( & port -> event , port -> socket , EV_READ | EV_PERSIST , server_port_ready_callback , port ) ;\n event_add ( & port -> event , NULL ) ;\n return port ;\n }", "hash": 2687336064028423153, "project": "chrome", "size": 16, "target": 0, "idx": 19847}
{"code": "static struct request * request_find_from_trans_id ( u16 trans_id ) {\n struct request * req = req_head , * const started_at = req_head ;\n if ( req ) {\n do {\n if ( req -> trans_id == trans_id ) return req ;\n req = req -> next ;\n }\n while ( req != started_at ) ;\n }\n return NULL ;\n }", "hash": 2687336064028423153, "project": "chrome", "size": 11, "target": 0, "idx": 19854}
{"code": "static const char * debug_ntoa ( u32 address ) {\n static char buf [ 32 ] ;\n u32 a = ntohl ( address ) ;\n evutil_snprintf ( buf , sizeof ( buf ) , \"%d.%d.%d.%d\" , ( int ) ( u8 ) ( ( a >> 24 ) & 0xff ) , ( int ) ( u8 ) ( ( a >> 16 ) & 0xff ) , ( int ) ( u8 ) ( ( a >> 8 ) & 0xff ) , ( int ) ( u8 ) ( ( a ) & 0xff ) ) ;\n return buf ;\n }", "hash": 2687336064028423153, "project": "chrome", "size": 6, "target": 0, "idx": 19867}
{"code": "static void nameserver_failed ( struct nameserver * const ns , const char * msg ) {\n struct request * req , * started_at ;\n if ( ! ns -> state ) return ;\n log ( EVDNS_LOG_WARN , \"Nameserver %s has failed: %s\" , debug_ntoa ( ns -> address ) , msg ) ;\n global_good_nameservers -- ;\n assert ( global_good_nameservers >= 0 ) ;\n if ( global_good_nameservers == 0 ) {\n log ( EVDNS_LOG_WARN , \"All nameservers have failed\" ) ;\n }\n ns -> state = 0 ;\n ns -> failed_times = 1 ;\n if ( evtimer_add ( & ns -> timeout_event , ( struct timeval * ) & global_nameserver_timeouts [ 0 ] ) < 0 ) {\n log ( EVDNS_LOG_WARN , \"Error from libevent when adding timer event for %s\" , debug_ntoa ( ns -> address ) ) ;\n }\n if ( ! global_good_nameservers ) return ;\n req = req_head ;\n started_at = req_head ;\n if ( req ) {\n do {\n if ( req -> tx_count == 0 && req -> ns == ns ) {\n req -> ns = nameserver_pick ( ) ;\n }\n req = req -> next ;\n }\n while ( req != started_at ) ;\n }\n }", "hash": 2687336064028423153, "project": "chrome", "size": 27, "target": 0, "idx": 19868}
{"code": "void evdns_set_transaction_id_fn ( ev_uint16_t ( * fn ) ( void ) ) {\n if ( fn ) trans_id_function = fn ;\n else trans_id_function = default_transaction_id_fn ;\n }", "hash": 2687336064028423153, "project": "chrome", "size": 4, "target": 0, "idx": 19877}
{"code": "static void evdns_request_timeout_callback ( int fd , short events , void * arg ) {\n struct request * const req = ( struct request * ) arg ;\n ( void ) fd ;\n ( void ) events ;\n log ( EVDNS_LOG_DEBUG , \"Request %lx timed out\" , ( unsigned long ) arg ) ;\n req -> ns -> timedout ++ ;\n if ( req -> ns -> timedout > global_max_nameserver_timeout ) {\n req -> ns -> timedout = 0 ;\n nameserver_failed ( req -> ns , \"request timed out.\" ) ;\n }\n ( void ) evtimer_del ( & req -> timeout_event ) ;\n if ( req -> tx_count >= global_max_retransmits ) {\n reply_callback ( req , 0 , DNS_ERR_TIMEOUT , NULL ) ;\n request_finished ( req , & req_head ) ;\n }\n else {\n evdns_request_transmit ( req ) ;\n }\n }", "hash": 2687336064028423153, "project": "chrome", "size": 19, "target": 0, "idx": 19881}
{"code": "static int name_parse ( u8 * packet , int length , int * idx , char * name_out , int name_out_len ) {\n int name_end = - 1 ;\n int j = * idx ;\n int ptr_count = 0 ;\n # define GET32 ( x ) do {\n if ( j + 4 > length ) goto err ;\n memcpy ( & _t32 , packet + j , 4 ) ;\n j += 4 ;\n x = ntohl ( _t32 ) ;\n }\n while ( 0 ) # define GET16 ( x ) do {\n if ( j + 2 > length ) goto err ;\n memcpy ( & _t , packet + j , 2 ) ;\n j += 2 ;\n x = ntohs ( _t ) ;\n }\n while ( 0 ) # define GET8 ( x ) do {\n if ( j >= length ) goto err ;\n x = packet [ j ++ ] ;\n }\n while ( 0 ) char * cp = name_out ;\n const char * const end = name_out + name_out_len ;\n for ( ;\n ;\n ) {\n u8 label_len ;\n if ( j >= length ) return - 1 ;\n GET8 ( label_len ) ;\n if ( ! label_len ) break ;\n if ( label_len & 0xc0 ) {\n u8 ptr_low ;\n GET8 ( ptr_low ) ;\n if ( name_end < 0 ) name_end = j ;\n j = ( ( ( int ) label_len & 0x3f ) << 8 ) + ptr_low ;\n if ( j < 0 || j >= length ) return - 1 ;\n if ( ++ ptr_count > length ) return - 1 ;\n continue ;\n }\n if ( label_len > 63 ) return - 1 ;\n if ( cp != name_out ) {\n if ( cp + 1 >= end ) return - 1 ;\n * cp ++ = '.' ;\n }\n if ( cp + label_len >= end ) return - 1 ;\n memcpy ( cp , packet + j , label_len ) ;\n cp += label_len ;\n j += label_len ;\n }\n if ( cp >= end ) return - 1 ;\n * cp = '\\0' ;\n if ( name_end < 0 ) * idx = j ;\n else * idx = name_end ;\n return 0 ;\n err : return - 1 ;\n }", "hash": 2687336064028423153, "project": "chrome", "size": 55, "target": 0, "idx": 19883}
{"code": "static int server_request_free ( struct server_request * req ) {\n int i , rc = 1 ;\n if ( req -> base . questions ) {\n for ( i = 0 ;\n i < req -> base . nquestions ;\n ++ i ) free ( req -> base . questions [ i ] ) ;\n free ( req -> base . questions ) ;\n }\n if ( req -> port ) {\n if ( req -> port -> pending_replies == req ) {\n if ( req -> next_pending ) req -> port -> pending_replies = req -> next_pending ;\n else req -> port -> pending_replies = NULL ;\n }\n rc = -- req -> port -> refcnt ;\n }\n if ( req -> response ) {\n free ( req -> response ) ;\n }\n server_request_free_answers ( req ) ;\n if ( req -> next_pending && req -> next_pending != req ) {\n req -> next_pending -> prev_pending = req -> prev_pending ;\n req -> prev_pending -> next_pending = req -> next_pending ;\n }\n if ( rc == 0 ) {\n server_port_free ( req -> port ) ;\n free ( req ) ;\n return ( 1 ) ;\n }\n free ( req ) ;\n return ( 0 ) ;\n }", "hash": 2687336064028423153, "project": "chrome", "size": 31, "target": 0, "idx": 19887}
{"code": "static void http_close_detection ( int with_delay ) {\n short port = - 1 ;\n struct evhttp_connection * evcon = NULL ;\n struct evhttp_request * req = NULL ;\n test_ok = 0 ;\n fprintf ( stdout , \"Testing Connection Close Detection%s: \" , with_delay ? \" (with delay)\" : \"\" ) ;\n http = http_setup ( & port , NULL ) ;\n evhttp_set_timeout ( http , 2 ) ;\n evcon = evhttp_connection_new ( \"127.0.0.1\" , port ) ;\n if ( evcon == NULL ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n delayed_client = evcon ;\n req = evhttp_request_new ( close_detect_cb , evcon ) ;\n evhttp_add_header ( req -> output_headers , \"Host\" , \"somehost\" ) ;\n if ( evhttp_make_request ( evcon , req , EVHTTP_REQ_GET , with_delay ? \"/largedelay\" : \"/test\" ) == - 1 ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n event_dispatch ( ) ;\n if ( test_ok != 1 ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n if ( TAILQ_FIRST ( & http -> connections ) != NULL ) {\n fprintf ( stdout , \"FAILED (left connections)\\n\" ) ;\n exit ( 1 ) ;\n }\n evhttp_connection_free ( evcon ) ;\n evhttp_free ( http ) ;\n fprintf ( stdout , \"OK\\n\" ) ;\n }", "hash": 6415329349331062723, "project": "chrome", "size": 33, "target": 0, "idx": 19942}
{"code": "static void http_failure_readcb ( struct bufferevent * bev , void * arg ) {\n const char * what = \"400 Bad Request\" ;\n if ( evbuffer_find ( bev -> input , ( const unsigned char * ) what , strlen ( what ) ) != NULL ) {\n test_ok = 2 ;\n bufferevent_disable ( bev , EV_READ ) ;\n event_loopexit ( NULL ) ;\n }\n }", "hash": 6415329349331062723, "project": "chrome", "size": 8, "target": 0, "idx": 19952}
{"code": "static struct evhttp * http_setup ( short * pport , struct event_base * base ) {\n int i ;\n struct evhttp * myhttp ;\n short port = - 1 ;\n myhttp = evhttp_new ( base ) ;\n for ( i = 0 ;\n i < 50 ;\n ++ i ) {\n if ( evhttp_bind_socket ( myhttp , \"127.0.0.1\" , 8080 + i ) != - 1 ) {\n port = 8080 + i ;\n break ;\n }\n }\n if ( port == - 1 ) event_errx ( 1 , \"Could not start web server\" ) ;\n evhttp_set_cb ( myhttp , \"/test\" , http_basic_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/chunked\" , http_chunked_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/postit\" , http_post_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/largedelay\" , http_large_delay_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/badrequest\" , http_badreq_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/\" , http_dispatcher_cb , NULL ) ;\n * pport = port ;\n return ( myhttp ) ;\n }", "hash": 6415329349331062723, "project": "chrome", "size": 23, "target": 0, "idx": 19953}
{"code": "static void http_dispatcher_test ( void ) {\n short port = - 1 ;\n struct evhttp_connection * evcon = NULL ;\n struct evhttp_request * req = NULL ;\n test_ok = 0 ;\n fprintf ( stdout , \"Testing HTTP Dispatcher: \" ) ;\n http = http_setup ( & port , NULL ) ;\n evcon = evhttp_connection_new ( \"127.0.0.1\" , port ) ;\n if ( evcon == NULL ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n evhttp_connection_set_local_address ( evcon , \"127.0.0.1\" ) ;\n req = evhttp_request_new ( http_dispatcher_test_done , NULL ) ;\n if ( req == NULL ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n evhttp_add_header ( req -> output_headers , \"Host\" , \"somehost\" ) ;\n if ( evhttp_make_request ( evcon , req , EVHTTP_REQ_GET , \"/?arg=val\" ) == - 1 ) {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n event_dispatch ( ) ;\n evhttp_connection_free ( evcon ) ;\n evhttp_free ( http ) ;\n if ( test_ok != 1 ) {\n fprintf ( stdout , \"FAILED: %d\\n\" , test_ok ) ;\n exit ( 1 ) ;\n }\n fprintf ( stdout , \"OK\\n\" ) ;\n }", "hash": 6415329349331062723, "project": "chrome", "size": 32, "target": 0, "idx": 19957}
{"code": "struct evhttp_connection * evhttp_request_get_connection ( struct evhttp_request * req ) {\n return req -> evcon ;\n }", "hash": -7076754245473579218, "project": "chrome", "size": 3, "target": 0, "idx": 19983}
{"code": "static enum message_read_status evhttp_handle_chunked_read ( struct evhttp_request * req , struct evbuffer * buf ) {\n int len ;\n while ( ( len = EVBUFFER_LENGTH ( buf ) ) > 0 ) {\n if ( req -> ntoread < 0 ) {\n ev_int64_t ntoread ;\n char * p = evbuffer_readline ( buf ) ;\n char * endp ;\n int error ;\n if ( p == NULL ) break ;\n if ( strlen ( p ) == 0 ) {\n free ( p ) ;\n continue ;\n }\n ntoread = evutil_strtoll ( p , & endp , 16 ) ;\n error = ( * p == '\\0' || ( * endp != '\\0' && * endp != ' ' ) || ntoread < 0 ) ;\n free ( p ) ;\n if ( error ) {\n return ( DATA_CORRUPTED ) ;\n }\n req -> ntoread = ntoread ;\n if ( req -> ntoread == 0 ) {\n return ( ALL_DATA_READ ) ;\n }\n continue ;\n }\n if ( len < req -> ntoread ) return ( MORE_DATA_EXPECTED ) ;\n evbuffer_add ( req -> input_buffer , EVBUFFER_DATA ( buf ) , ( size_t ) req -> ntoread ) ;\n evbuffer_drain ( buf , ( size_t ) req -> ntoread ) ;\n req -> ntoread = - 1 ;\n if ( req -> chunk_cb != NULL ) {\n ( * req -> chunk_cb ) ( req , req -> cb_arg ) ;\n evbuffer_drain ( req -> input_buffer , EVBUFFER_LENGTH ( req -> input_buffer ) ) ;\n }\n }\n return ( MORE_DATA_EXPECTED ) ;\n }", "hash": -7076754245473579218, "project": "chrome", "size": 36, "target": 0, "idx": 19987}
{"code": "static int evhttp_associate_new_request_with_connection ( struct evhttp_connection * evcon ) {\n struct evhttp * http = evcon -> http_server ;\n struct evhttp_request * req ;\n if ( ( req = evhttp_request_new ( evhttp_handle_request , http ) ) == NULL ) return ( - 1 ) ;\n req -> evcon = evcon ;\n req -> flags |= EVHTTP_REQ_OWN_CONNECTION ;\n TAILQ_INSERT_TAIL ( & evcon -> requests , req , next ) ;\n req -> kind = EVHTTP_REQUEST ;\n if ( ( req -> remote_host = strdup ( evcon -> address ) ) == NULL ) event_err ( 1 , \"%s: strdup\" , __func__ ) ;\n req -> remote_port = evcon -> port ;\n evhttp_start_read ( evcon ) ;\n return ( 0 ) ;\n }", "hash": -7076754245473579218, "project": "chrome", "size": 13, "target": 0, "idx": 19993}
{"code": "static int evhttp_parse_response_line ( struct evhttp_request * req , char * line ) {\n char * protocol ;\n char * number ;\n const char * readable = \"\" ;\n protocol = strsep ( & line , \" \" ) ;\n if ( line == NULL ) return ( - 1 ) ;\n number = strsep ( & line , \" \" ) ;\n if ( line != NULL ) readable = line ;\n if ( strcmp ( protocol , \"HTTP/1.0\" ) == 0 ) {\n req -> major = 1 ;\n req -> minor = 0 ;\n }\n else if ( strcmp ( protocol , \"HTTP/1.1\" ) == 0 ) {\n req -> major = 1 ;\n req -> minor = 1 ;\n }\n else {\n event_debug ( ( \"%s: bad protocol \\\"%s\\\"\" , __func__ , protocol ) ) ;\n return ( - 1 ) ;\n }\n req -> response_code = atoi ( number ) ;\n if ( ! evhttp_valid_response_code ( req -> response_code ) ) {\n event_debug ( ( \"%s: bad response code \\\"%s\\\"\" , __func__ , number ) ) ;\n return ( - 1 ) ;\n }\n if ( ( req -> response_code_line = strdup ( readable ) ) == NULL ) event_err ( 1 , \"%s: strdup\" , __func__ ) ;\n return ( 0 ) ;\n }", "hash": -7076754245473579218, "project": "chrome", "size": 28, "target": 0, "idx": 19996}
{"code": "static int evhttp_append_to_last_header ( struct evkeyvalq * headers , const char * line ) {\n struct evkeyval * header = TAILQ_LAST ( headers , evkeyvalq ) ;\n char * newval ;\n size_t old_len , line_len ;\n if ( header == NULL ) return ( - 1 ) ;\n old_len = strlen ( header -> value ) ;\n line_len = strlen ( line ) ;\n newval = realloc ( header -> value , old_len + line_len + 1 ) ;\n if ( newval == NULL ) return ( - 1 ) ;\n memcpy ( newval + old_len , line , line_len + 1 ) ;\n header -> value = newval ;\n return ( 0 ) ;\n }", "hash": -7076754245473579218, "project": "chrome", "size": 13, "target": 0, "idx": 19998}
{"code": "int evhttp_remove_header ( struct evkeyvalq * headers , const char * key ) {\n struct evkeyval * header ;\n TAILQ_FOREACH ( header , headers , next ) {\n if ( strcasecmp ( header -> key , key ) == 0 ) break ;\n }\n if ( header == NULL ) return ( - 1 ) ;\n TAILQ_REMOVE ( headers , header , next ) ;\n free ( header -> key ) ;\n free ( header -> value ) ;\n free ( header ) ;\n return ( 0 ) ;\n }", "hash": -7076754245473579218, "project": "chrome", "size": 12, "target": 0, "idx": 20010}
{"code": "static void evhttp_make_header_request ( struct evhttp_connection * evcon , struct evhttp_request * req ) {\n const char * method ;\n evhttp_remove_header ( req -> output_headers , \"Proxy-Connection\" ) ;\n method = evhttp_method ( req -> type ) ;\n evbuffer_add_printf ( evcon -> output_buffer , \"%s %s HTTP/%d.%d\\r\\n\" , method , req -> uri , req -> major , req -> minor ) ;\n if ( req -> type == EVHTTP_REQ_POST && evhttp_find_header ( req -> output_headers , \"Content-Length\" ) == NULL ) {\n char size [ 22 ] ;\n evutil_snprintf ( size , sizeof ( size ) , \"%ld\" , ( long ) EVBUFFER_LENGTH ( req -> output_buffer ) ) ;\n evhttp_add_header ( req -> output_headers , \"Content-Length\" , size ) ;\n }\n }", "hash": -7076754245473579218, "project": "chrome", "size": 11, "target": 0, "idx": 20020}
{"code": "static int evhttp_parse_request_line ( struct evhttp_request * req , char * line ) {\n char * method ;\n char * uri ;\n char * version ;\n method = strsep ( & line , \" \" ) ;\n if ( line == NULL ) return ( - 1 ) ;\n uri = strsep ( & line , \" \" ) ;\n if ( line == NULL ) return ( - 1 ) ;\n version = strsep ( & line , \" \" ) ;\n if ( line != NULL ) return ( - 1 ) ;\n if ( strcmp ( method , \"GET\" ) == 0 ) {\n req -> type = EVHTTP_REQ_GET ;\n }\n else if ( strcmp ( method , \"POST\" ) == 0 ) {\n req -> type = EVHTTP_REQ_POST ;\n }\n else if ( strcmp ( method , \"HEAD\" ) == 0 ) {\n req -> type = EVHTTP_REQ_HEAD ;\n }\n else {\n event_debug ( ( \"%s: bad method %s on request %p from %s\" , __func__ , method , req , req -> remote_host ) ) ;\n return ( - 1 ) ;\n }\n if ( strcmp ( version , \"HTTP/1.0\" ) == 0 ) {\n req -> major = 1 ;\n req -> minor = 0 ;\n }\n else if ( strcmp ( version , \"HTTP/1.1\" ) == 0 ) {\n req -> major = 1 ;\n req -> minor = 1 ;\n }\n else {\n event_debug ( ( \"%s: bad version %s on request %p from %s\" , __func__ , version , req , req -> remote_host ) ) ;\n return ( - 1 ) ;\n }\n if ( ( req -> uri = strdup ( uri ) ) == NULL ) {\n event_debug ( ( \"%s: strdup\" , __func__ ) ) ;\n return ( - 1 ) ;\n }\n if ( strlen ( req -> uri ) > 0 && req -> uri [ 0 ] != '/' ) req -> flags |= EVHTTP_PROXY_REQUEST ;\n return ( 0 ) ;\n }", "hash": -7076754245473579218, "project": "chrome", "size": 42, "target": 0, "idx": 20021}
{"code": "enum message_read_status evhttp_parse_headers ( struct evhttp_request * req , struct evbuffer * buffer ) {\n char * line ;\n enum message_read_status status = MORE_DATA_EXPECTED ;\n struct evkeyvalq * headers = req -> input_headers ;\n while ( ( line = evbuffer_readline ( buffer ) ) != NULL ) {\n char * skey , * svalue ;\n if ( * line == '\\0' ) {\n status = ALL_DATA_READ ;\n free ( line ) ;\n break ;\n }\n if ( * line == ' ' || * line == '\\t' ) {\n if ( evhttp_append_to_last_header ( headers , line ) == - 1 ) goto error ;\n free ( line ) ;\n continue ;\n }\n svalue = line ;\n skey = strsep ( & svalue , \":\" ) ;\n if ( svalue == NULL ) goto error ;\n svalue += strspn ( svalue , \" \" ) ;\n if ( evhttp_add_header ( headers , skey , svalue ) == - 1 ) goto error ;\n free ( line ) ;\n }\n return ( status ) ;\n error : free ( line ) ;\n return ( DATA_CORRUPTED ) ;\n }", "hash": -7076754245473579218, "project": "chrome", "size": 27, "target": 0, "idx": 20026}
{"code": "static void evhttp_add_event ( struct event * ev , int timeout , int default_timeout ) {\n if ( timeout != 0 ) {\n struct timeval tv ;\n evutil_timerclear ( & tv ) ;\n tv . tv_sec = timeout != - 1 ? timeout : default_timeout ;\n event_add ( ev , & tv ) ;\n }\n else {\n event_add ( ev , NULL ) ;\n }\n }", "hash": -7076754245473579218, "project": "chrome", "size": 11, "target": 0, "idx": 20030}
{"code": "static void evhttp_read_header ( struct evhttp_connection * evcon , struct evhttp_request * req ) {\n enum message_read_status res ;\n int fd = evcon -> fd ;\n res = evhttp_parse_headers ( req , evcon -> input_buffer ) ;\n if ( res == DATA_CORRUPTED ) {\n event_debug ( ( \"%s: bad header lines on %d\\n\" , __func__ , fd ) ) ;\n evhttp_connection_fail ( evcon , EVCON_HTTP_INVALID_HEADER ) ;\n return ;\n }\n else if ( res == MORE_DATA_EXPECTED ) {\n evhttp_add_event ( & evcon -> ev , evcon -> timeout , HTTP_READ_TIMEOUT ) ;\n return ;\n }\n switch ( req -> kind ) {\n case EVHTTP_REQUEST : event_debug ( ( \"%s: checking for post data on %d\\n\" , __func__ , fd ) ) ;\n evhttp_get_body ( evcon , req ) ;\n break ;\n case EVHTTP_RESPONSE : if ( req -> response_code == HTTP_NOCONTENT || req -> response_code == HTTP_NOTMODIFIED || ( req -> response_code >= 100 && req -> response_code < 200 ) ) {\n event_debug ( ( \"%s: skipping body for code %d\\n\" , __func__ , req -> response_code ) ) ;\n evhttp_connection_done ( evcon ) ;\n }\n else {\n event_debug ( ( \"%s: start of read body for %s on %d\\n\" , __func__ , req -> remote_host , fd ) ) ;\n evhttp_get_body ( evcon , req ) ;\n }\n break ;\n default : event_warnx ( \"%s: bad header on %d\" , __func__ , fd ) ;\n evhttp_connection_fail ( evcon , EVCON_HTTP_INVALID_HEADER ) ;\n break ;\n }\n }", "hash": -7076754245473579218, "project": "chrome", "size": 31, "target": 0, "idx": 20031}
{"code": "static int evhttp_header_is_valid_value ( const char * value ) {\n const char * p = value ;\n while ( ( p = strpbrk ( p , \"\\r\\n\" ) ) != NULL ) {\n p += strspn ( p , \"\\r\\n\" ) ;\n if ( * p != ' ' && * p != '\\t' ) return ( 0 ) ;\n }\n return ( 1 ) ;\n }", "hash": -7076754245473579218, "project": "chrome", "size": 8, "target": 0, "idx": 20044}
{"code": "void evhttp_request_set_chunked_cb ( struct evhttp_request * req , void ( * cb ) ( struct evhttp_request * , void * ) ) {\n req -> chunk_cb = cb ;\n }", "hash": -7076754245473579218, "project": "chrome", "size": 3, "target": 0, "idx": 20046}
{"code": "static int evhttp_get_body_length ( struct evhttp_request * req ) {\n struct evkeyvalq * headers = req -> input_headers ;\n const char * content_length ;\n const char * connection ;\n content_length = evhttp_find_header ( headers , \"Content-Length\" ) ;\n connection = evhttp_find_header ( headers , \"Connection\" ) ;\n if ( content_length == NULL && connection == NULL ) req -> ntoread = - 1 ;\n else if ( content_length == NULL && strcasecmp ( connection , \"Close\" ) != 0 ) {\n event_warnx ( \"%s: we got no content length, but the \" \"server wants to keep the connection open: %s.\" , __func__ , connection ) ;\n return ( - 1 ) ;\n }\n else if ( content_length == NULL ) {\n req -> ntoread = - 1 ;\n }\n else {\n char * endp ;\n ev_int64_t ntoread = evutil_strtoll ( content_length , & endp , 10 ) ;\n if ( * content_length == '\\0' || * endp != '\\0' || ntoread < 0 ) {\n event_debug ( ( \"%s: illegal content length: %s\" , __func__ , content_length ) ) ;\n return ( - 1 ) ;\n }\n req -> ntoread = ntoread ;\n }\n event_debug ( ( \"%s: bytes to read: %lld (in buffer %ld)\\n\" , __func__ , req -> ntoread , EVBUFFER_LENGTH ( req -> evcon -> input_buffer ) ) ) ;\n return ( 0 ) ;\n }", "hash": -7076754245473579218, "project": "chrome", "size": 26, "target": 0, "idx": 20047}
{"code": "static struct addrinfo * make_addrinfo ( const char * address , u_short port ) {\n struct addrinfo * aitop = NULL ;\n # ifdef HAVE_GETADDRINFO struct addrinfo ai ;\n char strport [ NI_MAXSERV ] ;\n int ai_result ;\n memset ( & ai , 0 , sizeof ( ai ) ) ;\n ai . ai_family = AF_INET ;\n ai . ai_socktype = SOCK_STREAM ;\n ai . ai_flags = AI_PASSIVE ;\n evutil_snprintf ( strport , sizeof ( strport ) , \"%d\" , port ) ;\n if ( ( ai_result = getaddrinfo ( address , strport , & ai , & aitop ) ) != 0 ) {\n if ( ai_result == EAI_SYSTEM ) event_warn ( \"getaddrinfo\" ) ;\n else event_warnx ( \"getaddrinfo: %s\" , gai_strerror ( ai_result ) ) ;\n return ( NULL ) ;\n }\n # else static int cur ;\n static struct addrinfo ai [ 2 ] ;\n if ( ++ cur == 2 ) cur = 0 ;\n if ( fake_getaddrinfo ( address , & ai [ cur ] ) < 0 ) {\n event_warn ( \"fake_getaddrinfo\" ) ;\n return ( NULL ) ;\n }\n aitop = & ai [ cur ] ;\n ( ( struct sockaddr_in * ) aitop -> ai_addr ) -> sin_port = htons ( port ) ;\n # endif return ( aitop ) ;\n }", "hash": -7076754245473579218, "project": "chrome", "size": 26, "target": 0, "idx": 20075}
{"code": "IN_PROC_BROWSER_TEST_F ( DownloadNotificationTest , DISABLED_DiscardDangerousFile ) {\n GURL download_url ( embedded_test_server ( ) -> GetURL ( \"/downloads/dangerous/dangerous.swf\" ) ) ;\n content : : DownloadTestObserverTerminal download_terminal_observer ( GetDownloadManager ( browser ( ) ) , 1u , content : : DownloadTestObserver : : ON_DANGEROUS_DOWNLOAD_IGNORE ) ;\n CreateDownloadForBrowserAndURL ( browser ( ) , download_url ) ;\n base : : FilePath filename = download_item ( ) -> GetFileNameToReportUser ( ) ;\n EXPECT_EQ ( download : : DOWNLOAD_DANGER_TYPE_DANGEROUS_FILE , download_item ( ) -> GetDangerType ( ) ) ;\n EXPECT_TRUE ( download_item ( ) -> IsDangerous ( ) ) ;\n EXPECT_TRUE ( notification ( ) ) ;\n display_service_ -> SimulateClick ( NotificationHandler : : Type : : TRANSIENT , notification_id ( ) , 0 , base : : nullopt ) ;\n EXPECT_FALSE ( notification ( ) ) ;\n download_terminal_observer . WaitForFinished ( ) ;\n EXPECT_FALSE ( notification ( ) ) ;\n EXPECT_EQ ( 0u , GetDownloadNotifications ( ) . size ( ) ) ;\n std : : vector < download : : DownloadItem * > downloads ;\n GetDownloadManager ( browser ( ) ) -> GetAllDownloads ( & downloads ) ;\n EXPECT_EQ ( 0u , downloads . size ( ) ) ;\n EXPECT_FALSE ( base : : PathExists ( GetDownloadPath ( ) . Append ( filename . BaseName ( ) ) ) ) ;\n }", "hash": -2181129709629421970, "project": "chrome", "size": 18, "target": 0, "idx": 20105}
{"code": "IN_PROC_BROWSER_TEST_F ( DownloadNotificationTest , DISABLED_DownloadImageFile ) {\n GURL download_url ( embedded_test_server ( ) -> GetURL ( \"/downloads/image-octet-stream.png\" ) ) ;\n content : : DownloadTestObserverTerminal download_terminal_observer ( GetDownloadManager ( browser ( ) ) , 1u , content : : DownloadTestObserver : : ON_DANGEROUS_DOWNLOAD_IGNORE ) ;\n CreateDownloadForBrowserAndURL ( browser ( ) , download_url ) ;\n download_terminal_observer . WaitForFinished ( ) ;\n WaitForDownloadNotification ( ) ;\n EXPECT_FALSE ( notification ( ) -> image ( ) . IsEmpty ( ) ) ;\n }", "hash": -2181129709629421970, "project": "chrome", "size": 8, "target": 0, "idx": 20115}
{"code": "IN_PROC_BROWSER_TEST_F ( DownloadNotificationTest , IncognitoDownloadFile ) {\n PrepareIncognitoBrowser ( ) ;\n CreateDownloadForBrowserAndURL ( incognito_browser ( ) , GURL ( net : : URLRequestSlowDownloadJob : : kKnownSizeUrl ) ) ;\n EXPECT_EQ ( l10n_util : : GetStringFUTF16 ( IDS_DOWNLOAD_STATUS_IN_PROGRESS_TITLE , download_item ( ) -> GetFileNameToReportUser ( ) . LossyDisplayName ( ) ) , notification ( ) -> title ( ) ) ;\n EXPECT_EQ ( message_center : : NOTIFICATION_TYPE_PROGRESS , notification ( ) -> type ( ) ) ;\n EXPECT_TRUE ( content : : DownloadItemUtils : : GetBrowserContext ( download_item ( ) ) -> IsOffTheRecord ( ) ) ;\n content : : DownloadTestObserverTerminal download_terminal_observer ( GetDownloadManager ( incognito_browser ( ) ) , 1 , content : : DownloadTestObserver : : ON_DANGEROUS_DOWNLOAD_FAIL ) ;\n ui_test_utils : : NavigateToURL ( incognito_browser ( ) , GURL ( net : : URLRequestSlowDownloadJob : : kFinishDownloadUrl ) ) ;\n download_terminal_observer . WaitForFinished ( ) ;\n EXPECT_EQ ( l10n_util : : GetStringUTF16 ( IDS_DOWNLOAD_STATUS_COMPLETE_TITLE ) , notification ( ) -> title ( ) ) ;\n EXPECT_EQ ( download_item ( ) -> GetFileNameToReportUser ( ) . LossyDisplayName ( ) , notification ( ) -> message ( ) ) ;\n EXPECT_EQ ( message_center : : NOTIFICATION_TYPE_BASE_FORMAT , notification ( ) -> type ( ) ) ;\n EXPECT_TRUE ( incognito_display_service_ -> GetNotification ( notification_id ( ) ) ) ;\n EXPECT_FALSE ( GetIncognitoDownloadManagerDelegate ( ) -> opened ( ) ) ;\n incognito_display_service_ -> SimulateClick ( NotificationHandler : : Type : : TRANSIENT , notification_id ( ) , base : : nullopt , base : : nullopt ) ;\n EXPECT_TRUE ( GetIncognitoDownloadManagerDelegate ( ) -> opened ( ) ) ;\n EXPECT_FALSE ( GetDownloadManagerDelegate ( ) -> opened ( ) ) ;\n EXPECT_FALSE ( incognito_display_service_ -> GetNotification ( notification_id ( ) ) ) ;\n chrome : : CloseWindow ( incognito_browser ( ) ) ;\n }", "hash": -2181129709629421970, "project": "chrome", "size": 20, "target": 0, "idx": 20117}
{"code": "IN_PROC_BROWSER_TEST_F ( DownloadNotificationTest , CloseNotificationWhileDownloading ) {\n CreateDownload ( ) ;\n CloseNotification ( ) ;\n VerifyDownloadState ( download : : DownloadItem : : IN_PROGRESS ) ;\n CompleteTheDownload ( ) ;\n EXPECT_TRUE ( notification ( ) ) ;\n }", "hash": -2181129709629421970, "project": "chrome", "size": 7, "target": 0, "idx": 20118}
{"code": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , NoDocumentWriteScript ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/page_load_metrics/document_write_no_script.html\" ) ) ;\n waiter -> Wait ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstContentfulPaint , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramDocWriteBlockParseStartToFirstContentfulPaint , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramDocWriteBlockCount , 0 ) ;\n }", "hash": 927123821003322045, "project": "chrome", "size": 10, "target": 0, "idx": 20151}
{"code": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , NewPage ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n GURL url = embedded_test_server ( ) -> GetURL ( \"/title1.html\" ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_PAINT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , url ) ;\n waiter -> Wait ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramDomContentLoaded , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramLoad , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstLayout , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstPaint , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramParseDuration , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramParseBlockedOnScriptLoad , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramParseBlockedOnScriptExecution , 1 ) ;\n NavigateToUntrackedUrl ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramPageLoadTotalBytes , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramPageTimingForegroundDuration , 1 ) ;\n const auto & entries = test_ukm_recorder_ -> GetMergedEntriesByName ( internal : : kUkmPageLoadEventName ) ;\n EXPECT_EQ ( 1u , entries . size ( ) ) ;\n for ( const auto & kv : entries ) {\n test_ukm_recorder_ -> ExpectEntrySourceHasUrl ( kv . second . get ( ) , url ) ;\n EXPECT_TRUE ( test_ukm_recorder_ -> EntryHasMetric ( kv . second . get ( ) , internal : : kUkmDomContentLoadedName ) ) ;\n EXPECT_TRUE ( test_ukm_recorder_ -> EntryHasMetric ( kv . second . get ( ) , internal : : kUkmLoadEventName ) ) ;\n EXPECT_TRUE ( test_ukm_recorder_ -> EntryHasMetric ( kv . second . get ( ) , internal : : kUkmFirstPaintName ) ) ;\n EXPECT_TRUE ( test_ukm_recorder_ -> EntryHasMetric ( kv . second . get ( ) , internal : : kUkmFirstContentfulPaintName ) ) ;\n }\n EXPECT_FALSE ( NoPageLoadMetricsRecorded ( ) ) ;\n }", "hash": 927123821003322045, "project": "chrome", "size": 28, "target": 0, "idx": 20159}
{"code": "IN_PROC_BROWSER_TEST_F ( PrefsFunctionalTest , TestDownloadDirPref ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n base : : FilePath new_download_dir = DownloadPrefs ( browser ( ) -> profile ( ) ) . DownloadPath ( ) . AppendASCII ( \"subdir\" ) ;\n base : : FilePath downloaded_pkg = new_download_dir . AppendASCII ( \"a_zip_file.zip\" ) ;\n browser ( ) -> profile ( ) -> GetPrefs ( ) -> SetFilePath ( prefs : : kDownloadDefaultDirectory , new_download_dir ) ;\n std : : unique_ptr < content : : DownloadTestObserver > downloads_observer ( CreateWaiter ( browser ( ) , 1 ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/downloads/a_zip_file.zip\" ) ) ;\n downloads_observer -> WaitForFinished ( ) ;\n base : : ScopedAllowBlockingForTesting allow_blocking ;\n EXPECT_TRUE ( base : : PathExists ( downloaded_pkg ) ) ;\n }", "hash": -992498691684812004, "project": "chrome", "size": 11, "target": 0, "idx": 20192}
{"code": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , TestOpenAndCloseWindowDuringShutdown ) {\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 0 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browsers_ [ 0 ] ) ;\n RepeatedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , 2 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n browsers_ . push_back ( CreateBrowser ( browser ( ) -> profile ( ) ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 1 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browsers_ [ 1 ] ) ;\n ASSERT_FALSE ( browsers_ [ 1 ] -> ShouldCloseWindow ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n cancel_observer . Wait ( ) ;\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_EQ ( 1 , browsers_ [ 0 ] -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_EQ ( 1 , browsers_ [ 1 ] -> tab_strip_model ( ) -> count ( ) ) ;\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 2 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_FALSE ( browsers_ [ 1 ] -> ShouldCloseWindow ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n }", "hash": 4839943401171415484, "project": "chrome", "size": 24, "target": 0, "idx": 20207}
{"code": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , TestAddTabWithBeforeUnloadDuringShutdown ) {\n browsers_ . push_back ( CreateBrowser ( browser ( ) -> profile ( ) ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 0 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 1 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browsers_ [ 0 ] ) ;\n PrepareForDialog ( browsers_ [ 1 ] ) ;\n RepeatedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , 2 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n AddBlankTabAndShow ( browsers_ [ 0 ] ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 0 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n AddBlankTabAndShow ( browsers_ [ 1 ] ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 1 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browsers_ [ 0 ] ) ;\n PrepareForDialog ( browsers_ [ 1 ] ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n cancel_observer . Wait ( ) ;\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_EQ ( 2 , browsers_ [ 0 ] -> tab_strip_model ( ) -> count ( ) ) ;\n EXPECT_EQ ( 2 , browsers_ [ 1 ] -> tab_strip_model ( ) -> count ( ) ) ;\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 2 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n }", "hash": 4839943401171415484, "project": "chrome", "size": 31, "target": 0, "idx": 20210}
{"code": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , MAYBE_TestUnloadMultipleSlowTabs ) {\n const int kTabCount = 5 ;\n const int kResposiveTabIndex = 2 ;\n for ( int i = 0 ;\n i < kTabCount ;\n i ++ ) {\n if ( i ) AddBlankTabAndShow ( browsers_ [ 0 ] ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 0 ] , embedded_test_server ( ) -> GetURL ( ( i == kResposiveTabIndex ) ? \"/beforeunload.html\" : \"/beforeunload_slow.html\" ) ) ) ;\n }\n PrepareForDialog ( browsers_ [ 0 ] -> tab_strip_model ( ) -> GetWebContentsAt ( kResposiveTabIndex ) ) ;\n RepeatedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , 1 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n cancel_observer . Wait ( ) ;\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_EQ ( kTabCount , browsers_ [ 0 ] -> tab_strip_model ( ) -> count ( ) ) ;\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 1 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n }", "hash": 4839943401171415484, "project": "chrome", "size": 23, "target": 0, "idx": 20217}
{"code": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerBrowserTest , TestHangInBeforeUnloadMultipleTabs ) {\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 0 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload_hang.html\" ) ) ) ;\n AddBlankTabAndShow ( browsers_ [ 0 ] ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 0 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n AddBlankTabAndShow ( browsers_ [ 0 ] ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browsers_ [ 0 ] , embedded_test_server ( ) -> GetURL ( \"/beforeunload_hang.html\" ) ) ) ;\n PrepareForDialog ( browsers_ [ 0 ] -> tab_strip_model ( ) -> GetWebContentsAt ( 1 ) ) ;\n RepeatedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , 1 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( CancelClose ( ) ) ;\n cancel_observer . Wait ( ) ;\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_EQ ( 3 , browsers_ [ 0 ] -> tab_strip_model ( ) -> count ( ) ) ;\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 1 ) ;\n chrome : : CloseAllBrowsersAndQuit ( ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n }", "hash": 4839943401171415484, "project": "chrome", "size": 20, "target": 0, "idx": 20219}
{"code": "IN_PROC_BROWSER_TEST_F ( DownloadExtensionTest , DownloadExtensionTest_OnDeterminingFilename_ReferencesParentInvalid ) {\n GoOnTheRecord ( ) ;\n LoadExtension ( \"downloads_split\" ) ;\n AddFilenameDeterminer ( ) ;\n ASSERT_TRUE ( StartEmbeddedTestServer ( ) ) ;\n std : : string download_url = embedded_test_server ( ) -> GetURL ( \"/slow?0\" ) . spec ( ) ;\n std : : unique_ptr < base : : Value > result ( RunFunctionAndReturnResult ( new DownloadsDownloadFunction ( ) , base : : StringPrintf ( \"[{\n\\\"url\\\": \\\"%s\\\"}\n]\" , download_url . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( result . get ( ) ) ;\n int result_id = - 1 ;\n ASSERT_TRUE ( result -> GetAsInteger ( & result_id ) ) ;\n DownloadItem * item = GetCurrentManager ( ) -> GetDownload ( result_id ) ;\n ASSERT_TRUE ( item ) ;\n ScopedCancellingItem canceller ( item ) ;\n ASSERT_EQ ( download_url , item -> GetOriginalUrl ( ) . spec ( ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnCreated : : kEventName , base : : StringPrintf ( \"[{\n\\\"danger\\\": \\\"safe\\\",\" \" \\\"incognito\\\": false,\" \" \\\"id\\\": %d,\" \" \\\"mime\\\": \\\"text/plain\\\",\" \" \\\"paused\\\": false,\" \" \\\"url\\\": \\\"%s\\\"}\n]\" , result_id , download_url . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnDeterminingFilename : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"filename\\\":\\\"slow.txt\\\"}\n]\" , result_id ) ) ) ;\n ASSERT_TRUE ( item -> GetTargetFilePath ( ) . empty ( ) ) ;\n ASSERT_EQ ( DownloadItem : : IN_PROGRESS , item -> GetState ( ) ) ;\n std : : string error ;\n ASSERT_FALSE ( ExtensionDownloadsEventRouter : : DetermineFilename ( browser ( ) -> profile ( ) , false , GetExtensionId ( ) , result_id , base : : FilePath ( FILE_PATH_LITERAL ( \"sneaky/../../sneaky.txt\" ) ) , downloads : : FILENAME_CONFLICT_ACTION_UNIQUIFY , & error ) ) ;\n EXPECT_STREQ ( errors : : kInvalidFilename , error . c_str ( ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnChanged : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"filename\\\": {\n\" \" \\\"previous\\\": \\\"\\\",\" \" \\\"current\\\": \\\"%s\\\"}\n}\n]\" , result_id , GetFilename ( \"slow.txt\" ) . c_str ( ) ) ) ) ;\n ASSERT_TRUE ( WaitFor ( downloads : : OnChanged : : kEventName , base : : StringPrintf ( \"[{\n\\\"id\\\": %d,\" \" \\\"state\\\": {\n\" \" \\\"previous\\\": \\\"in_progress\\\",\" \" \\\"current\\\": \\\"complete\\\"}\n}\n]\" , result_id ) ) ) ;\n }", "hash": -2323311514228246061, "project": "chrome", "size": 38, "target": 0, "idx": 20240}
{"code": "static uint16_t * invert_lut ( uint16_t * table , int length , size_t out_length ) {\n int NumZeroes ;\n int NumPoles ;\n int i ;\n uint16_t * output = malloc ( sizeof ( uint16_t ) * out_length ) ;\n if ( ! output ) return NULL ;\n count_zeroes_and_poles ( table , length , & NumZeroes , & NumPoles ) ;\n for ( i = 0 ;\n i < out_length ;\n i ++ ) {\n double x = ( ( double ) i * 65535. ) / ( double ) ( out_length - 1 ) ;\n uint16_fract_t input = floor ( x + .5 ) ;\n output [ i ] = lut_inverse_interp16 ( input , table , length , NumZeroes , NumPoles ) ;\n }\n return output ;\n }", "hash": -46053003459728034, "project": "chrome", "size": 16, "target": 0, "idx": 20258}
{"code": "void compute_precache_linear ( uint8_t * output ) {\n uint32_t v = 0 ;\n for ( v = 0 ;\n v < PRECACHE_OUTPUT_SIZE ;\n v ++ ) {\n output [ v ] = v / ( PRECACHE_OUTPUT_SIZE / 256 ) ;\n }\n }", "hash": -46053003459728034, "project": "chrome", "size": 8, "target": 0, "idx": 20259}
{"code": "void compute_precache_lut ( uint8_t * output , uint16_t * table , int length ) {\n uint32_t v = 0 ;\n for ( v = 0 ;\n v < PRECACHE_OUTPUT_SIZE ;\n v ++ ) {\n output [ v ] = lut_interp_linear_precache_output ( v , table , length ) ;\n }\n }", "hash": -46053003459728034, "project": "chrome", "size": 8, "target": 0, "idx": 20261}
{"code": "uint16_t lut_interp_linear16 ( uint16_t input_value , uint16_t * table , size_t length ) {\n uintptr_t value = ( input_value * ( length - 1 ) ) ;\n uint32_t upper = ( value + 65534 ) / 65535 ;\n uint32_t lower = value / 65535 ;\n uint32_t interp = value % 65535 ;\n value = ( table [ upper ] * ( interp ) + table [ lower ] * ( 65535 - interp ) ) / 65535 ;\n return value ;\n }", "hash": -46053003459728034, "project": "chrome", "size": 8, "target": 0, "idx": 20263}
{"code": "static uint8_t lut_interp_linear_precache_output ( uint32_t input_value , uint16_t * table , size_t length ) {\n uintptr_t value = ( input_value * ( length - 1 ) ) ;\n uint32_t upper = ( value + PRECACHE_OUTPUT_MAX - 1 ) / PRECACHE_OUTPUT_MAX ;\n uint32_t lower = value / PRECACHE_OUTPUT_MAX ;\n uint32_t interp = value % PRECACHE_OUTPUT_MAX ;\n value = ( table [ upper ] * ( interp ) + table [ lower ] * ( PRECACHE_OUTPUT_MAX - interp ) ) ;\n value += ( PRECACHE_OUTPUT_MAX * 65535 / 255 ) / 2 ;\n value /= ( PRECACHE_OUTPUT_MAX * 65535 / 255 ) ;\n return value ;\n }", "hash": -46053003459728034, "project": "chrome", "size": 10, "target": 0, "idx": 20265}
{"code": "void validate_gamma_table ( float gamma_table [ 256 ] ) {\n int i ;\n for ( i = 0 ;\n i < 256 ;\n i ++ ) {\n if ( ! ( gamma_table [ i ] >= 0.f && gamma_table [ i ] <= 1.f ) ) {\n gamma_table [ i ] = 0.f ;\n }\n }\n }", "hash": -46053003459728034, "project": "chrome", "size": 10, "target": 0, "idx": 20270}
{"code": "TEST_F ( ExtensionServiceSyncTest , GetSyncExtensionDataUserSettings ) {\n InitializeEmptyExtensionService ( ) ;\n InstallCRX ( data_dir ( ) . AppendASCII ( \"good.crx\" ) , INSTALL_NEW ) ;\n const Extension * extension = service ( ) -> GetInstalledExtension ( good_crx ) ;\n ASSERT_TRUE ( extension ) ;\n extension_sync_service ( ) -> MergeDataAndStartSyncing ( syncer : : EXTENSIONS , syncer : : SyncDataList ( ) , base : : MakeUnique < syncer : : FakeSyncChangeProcessor > ( ) , base : : MakeUnique < syncer : : SyncErrorFactoryMock > ( ) ) ;\n {\n syncer : : SyncDataList list = extension_sync_service ( ) -> GetAllSyncData ( syncer : : EXTENSIONS ) ;\n ASSERT_EQ ( list . size ( ) , 1U ) ;\n std : : unique_ptr < ExtensionSyncData > data = ExtensionSyncData : : CreateFromSyncData ( list [ 0 ] ) ;\n ASSERT_TRUE ( data . get ( ) ) ;\n EXPECT_TRUE ( data -> enabled ( ) ) ;\n EXPECT_FALSE ( data -> incognito_enabled ( ) ) ;\n EXPECT_EQ ( ExtensionSyncData : : BOOLEAN_UNSET , data -> all_urls_enabled ( ) ) ;\n }\n service ( ) -> DisableExtension ( good_crx , extensions : : disable_reason : : DISABLE_USER_ACTION ) ;\n {\n syncer : : SyncDataList list = extension_sync_service ( ) -> GetAllSyncData ( syncer : : EXTENSIONS ) ;\n ASSERT_EQ ( list . size ( ) , 1U ) ;\n std : : unique_ptr < ExtensionSyncData > data = ExtensionSyncData : : CreateFromSyncData ( list [ 0 ] ) ;\n ASSERT_TRUE ( data . get ( ) ) ;\n EXPECT_FALSE ( data -> enabled ( ) ) ;\n EXPECT_FALSE ( data -> incognito_enabled ( ) ) ;\n EXPECT_EQ ( ExtensionSyncData : : BOOLEAN_UNSET , data -> all_urls_enabled ( ) ) ;\n }\n extensions : : util : : SetIsIncognitoEnabled ( good_crx , profile ( ) , true ) ;\n ScriptingPermissionsModifier permissions_modifier ( profile ( ) , registry ( ) -> GetExtensionById ( good_crx , extensions : : ExtensionRegistry : : EVERYTHING ) ) ;\n permissions_modifier . SetAllowedOnAllUrls ( false ) ;\n {\n syncer : : SyncDataList list = extension_sync_service ( ) -> GetAllSyncData ( syncer : : EXTENSIONS ) ;\n ASSERT_EQ ( list . size ( ) , 1U ) ;\n std : : unique_ptr < ExtensionSyncData > data = ExtensionSyncData : : CreateFromSyncData ( list [ 0 ] ) ;\n ASSERT_TRUE ( data . get ( ) ) ;\n EXPECT_FALSE ( data -> enabled ( ) ) ;\n EXPECT_TRUE ( data -> incognito_enabled ( ) ) ;\n EXPECT_EQ ( ExtensionSyncData : : BOOLEAN_FALSE , data -> all_urls_enabled ( ) ) ;\n }\n service ( ) -> EnableExtension ( good_crx ) ;\n permissions_modifier . SetAllowedOnAllUrls ( true ) ;\n {\n syncer : : SyncDataList list = extension_sync_service ( ) -> GetAllSyncData ( syncer : : EXTENSIONS ) ;\n ASSERT_EQ ( list . size ( ) , 1U ) ;\n std : : unique_ptr < ExtensionSyncData > data = ExtensionSyncData : : CreateFromSyncData ( list [ 0 ] ) ;\n ASSERT_TRUE ( data . get ( ) ) ;\n EXPECT_TRUE ( data -> enabled ( ) ) ;\n EXPECT_TRUE ( data -> incognito_enabled ( ) ) ;\n EXPECT_EQ ( ExtensionSyncData : : BOOLEAN_TRUE , data -> all_urls_enabled ( ) ) ;\n }\n }", "hash": -7422764464424760982, "project": "chrome", "size": 49, "target": 0, "idx": 20291}
{"code": "TEST_F ( ExternalProtocolHandlerTest , DISABLED_TestLaunchSchemeUnknownChromeNotDefault ) {\n DoTest ( ExternalProtocolHandler : : UNKNOWN , shell_integration : : NOT_DEFAULT , Action : : PROMPT ) ;\n }", "hash": 7823043019110226810, "project": "chrome", "size": 3, "target": 0, "idx": 20300}
{"code": "TEST_F ( ExternalProtocolHandlerTest , TestLaunchSchemeBlockedChromeOtherModeDefault ) {\n DoTest ( ExternalProtocolHandler : : BLOCK , shell_integration : : OTHER_MODE_IS_DEFAULT , Action : : BLOCK ) ;\n }", "hash": 7823043019110226810, "project": "chrome", "size": 3, "target": 0, "idx": 20304}
{"code": "TEST_F ( ProfileInfoCacheTest , GAIAName ) {\n GetCache ( ) -> AddProfileToCache ( GetProfilePath ( \"path_1\" ) , ASCIIToUTF16 ( \"Person 1\" ) , base : : string16 ( ) , 0 , std : : string ( ) ) ;\n base : : string16 profile_name ( ASCIIToUTF16 ( \"Person 2\" ) ) ;\n GetCache ( ) -> AddProfileToCache ( GetProfilePath ( \"path_2\" ) , profile_name , base : : string16 ( ) , 0 , std : : string ( ) ) ;\n int index1 = GetCache ( ) -> GetIndexOfProfileWithPath ( GetProfilePath ( \"path_1\" ) ) ;\n int index2 = GetCache ( ) -> GetIndexOfProfileWithPath ( GetProfilePath ( \"path_2\" ) ) ;\n EXPECT_TRUE ( GetCache ( ) -> GetGAIANameOfProfileAtIndex ( index1 ) . empty ( ) ) ;\n EXPECT_TRUE ( GetCache ( ) -> GetGAIANameOfProfileAtIndex ( index2 ) . empty ( ) ) ;\n base : : string16 gaia_name ( ASCIIToUTF16 ( \"Pat Smith\" ) ) ;\n GetCache ( ) -> SetGAIANameOfProfileAtIndex ( index2 , gaia_name ) ;\n index1 = GetCache ( ) -> GetIndexOfProfileWithPath ( GetProfilePath ( \"path_1\" ) ) ;\n index2 = GetCache ( ) -> GetIndexOfProfileWithPath ( GetProfilePath ( \"path_2\" ) ) ;\n EXPECT_TRUE ( GetCache ( ) -> GetGAIANameOfProfileAtIndex ( index1 ) . empty ( ) ) ;\n EXPECT_EQ ( gaia_name , GetCache ( ) -> GetGAIANameOfProfileAtIndex ( index2 ) ) ;\n EXPECT_EQ ( gaia_name , GetCache ( ) -> GetNameOfProfileAtIndex ( index2 ) ) ;\n base : : string16 custom_name ( ASCIIToUTF16 ( \"Custom name\" ) ) ;\n GetCache ( ) -> SetNameOfProfileAtIndex ( index2 , custom_name ) ;\n GetCache ( ) -> SetProfileIsUsingDefaultNameAtIndex ( index2 , false ) ;\n index1 = GetCache ( ) -> GetIndexOfProfileWithPath ( GetProfilePath ( \"path_1\" ) ) ;\n index2 = GetCache ( ) -> GetIndexOfProfileWithPath ( GetProfilePath ( \"path_2\" ) ) ;\n EXPECT_EQ ( custom_name , GetCache ( ) -> GetNameOfProfileAtIndex ( index2 ) ) ;\n EXPECT_EQ ( gaia_name , GetCache ( ) -> GetGAIANameOfProfileAtIndex ( index2 ) ) ;\n }", "hash": -7614722514335375899, "project": "chrome", "size": 23, "target": 0, "idx": 20331}
{"code": "TEST_F ( ProfileInfoCacheTest , AddStubProfile ) {\n EXPECT_EQ ( 0u , GetCache ( ) -> GetNumberOfProfiles ( ) ) ;\n const struct {\n const char * profile_path ;\n const char * profile_name ;\n }\n kTestCases [ ] = {\n {\n \"path.test0\" , \"name_0\" }\n , {\n \"path_test1\" , \"name_1\" }\n , {\n \"path.test2\" , \"name_2\" }\n , {\n \"path_test3\" , \"name_3\" }\n , }\n ;\n for ( size_t i = 0 ;\n i < arraysize ( kTestCases ) ;\n ++ i ) {\n base : : FilePath profile_path = GetProfilePath ( kTestCases [ i ] . profile_path ) ;\n base : : string16 profile_name = ASCIIToUTF16 ( kTestCases [ i ] . profile_name ) ;\n GetCache ( ) -> AddProfileToCache ( profile_path , profile_name , base : : string16 ( ) , i , \"\" ) ;\n EXPECT_EQ ( profile_path , GetCache ( ) -> GetPathOfProfileAtIndex ( i ) ) ;\n EXPECT_EQ ( profile_name , GetCache ( ) -> GetNameOfProfileAtIndex ( i ) ) ;\n }\n ASSERT_EQ ( 4U , GetCache ( ) -> GetNumberOfProfiles ( ) ) ;\n std : : vector < base : : string16 > names ;\n PrefService * local_state = g_browser_process -> local_state ( ) ;\n const base : : DictionaryValue * cache = local_state -> GetDictionary ( prefs : : kProfileInfoCache ) ;\n base : : string16 name ;\n for ( base : : DictionaryValue : : Iterator it ( * cache ) ;\n ! it . IsAtEnd ( ) ;\n it . Advance ( ) ) {\n const base : : DictionaryValue * info = NULL ;\n it . value ( ) . GetAsDictionary ( & info ) ;\n info -> GetString ( \"name\" , & name ) ;\n names . push_back ( name ) ;\n }\n for ( size_t i = 0 ;\n i < 4 ;\n i ++ ) ASSERT_FALSE ( names [ i ] . empty ( ) ) ;\n }", "hash": -7614722514335375899, "project": "chrome", "size": 43, "target": 0, "idx": 20332}
{"code": "TEST_F ( TemplateURLTest , TestValidWithComplete ) {\n TemplateURLData data ;\n data . SetURL ( \"{\nsearchTerms}\n\" ) ;\n TemplateURL url ( data ) ;\n EXPECT_TRUE ( url . url_ref ( ) . IsValid ( search_terms_data_ ) ) ;\n }", "hash": -5456913190944844754, "project": "chrome", "size": 8, "target": 0, "idx": 20338}
{"code": "TEST_F ( TemplateURLTest , URLRefTestSearchTermsUsingTermsData ) {\n struct SearchTermsCase {\n const char * url ;\n const base : : string16 terms ;\n const char * output ;\n }\n search_term_cases [ ] = {\n {\n \"{\ngoogle:baseURL}\n{\nlanguage}\n{\nsearchTerms}\n\" , base : : string16 ( ) , \"http://example.com/e/en\" }\n , {\n \"{\ngoogle:baseSuggestURL}\n{\nsearchTerms}\n\" , base : : string16 ( ) , \"http://example.com/complete/\" }\n }\n ;\n TestingSearchTermsData search_terms_data ( \"http://example.com/e/\" ) ;\n TemplateURLData data ;\n for ( size_t i = 0 ;\n i < arraysize ( search_term_cases ) ;\n ++ i ) {\n const SearchTermsCase & value = search_term_cases [ i ] ;\n data . SetURL ( value . url ) ;\n TemplateURL url ( data ) ;\n EXPECT_TRUE ( url . url_ref ( ) . IsValid ( search_terms_data ) ) ;\n ASSERT_TRUE ( url . url_ref ( ) . SupportsReplacement ( search_terms_data ) ) ;\n GURL result ( url . url_ref ( ) . ReplaceSearchTerms ( TemplateURLRef : : SearchTermsArgs ( value . terms ) , search_terms_data , NULL ) ) ;\n ASSERT_TRUE ( result . is_valid ( ) ) ;\n EXPECT_EQ ( value . output , result . spec ( ) ) ;\n }\n }", "hash": -5456913190944844754, "project": "chrome", "size": 38, "target": 0, "idx": 20341}
{"code": "TEST_F ( TemplateURLTest , URLRefTestEncoding ) {\n TemplateURLData data ;\n data . SetURL ( \"http://foo{\nsearchTerms}\nx{\ninputEncoding?}\ny{\noutputEncoding?}\na\" ) ;\n TemplateURL url ( data ) ;\n EXPECT_TRUE ( url . url_ref ( ) . IsValid ( search_terms_data_ ) ) ;\n ASSERT_TRUE ( url . url_ref ( ) . SupportsReplacement ( search_terms_data_ ) ) ;\n GURL result ( url . url_ref ( ) . ReplaceSearchTerms ( TemplateURLRef : : SearchTermsArgs ( ASCIIToUTF16 ( \"X\" ) ) , search_terms_data_ ) ) ;\n ASSERT_TRUE ( result . is_valid ( ) ) ;\n EXPECT_EQ ( \"http://fooxxutf-8ya/\" , result . spec ( ) ) ;\n }", "hash": -5456913190944844754, "project": "chrome", "size": 16, "target": 0, "idx": 20361}
{"code": "TEST_F ( TemplateURLTest , URLRefTestEncoding2 ) {\n TemplateURLData data ;\n data . SetURL ( \"http://foo{\nsearchTerms}\nx{\ninputEncoding}\ny{\noutputEncoding}\na\" ) ;\n TemplateURL url ( data ) ;\n EXPECT_TRUE ( url . url_ref ( ) . IsValid ( search_terms_data_ ) ) ;\n ASSERT_TRUE ( url . url_ref ( ) . SupportsReplacement ( search_terms_data_ ) ) ;\n GURL result ( url . url_ref ( ) . ReplaceSearchTerms ( TemplateURLRef : : SearchTermsArgs ( ASCIIToUTF16 ( \"X\" ) ) , search_terms_data_ ) ) ;\n ASSERT_TRUE ( result . is_valid ( ) ) ;\n EXPECT_EQ ( \"http://fooxxutf-8yutf-8a/\" , result . spec ( ) ) ;\n }", "hash": -5456913190944844754, "project": "chrome", "size": 16, "target": 0, "idx": 20365}
{"code": "TEST_F ( TemplateURLTest , SessionToken ) {\n TemplateURLData data ;\n search_terms_data_ . set_google_base_url ( \"http://bar/\" ) ;\n data . SetURL ( \"http://bar/search?q={\nsearchTerms}\n&{\ngoogle:sessionToken}\nxssi=t\" ) ;\n TemplateURL url ( data ) ;\n TemplateURLRef : : SearchTermsArgs search_terms_args ( ASCIIToUTF16 ( \"foo\" ) ) ;\n search_terms_args . session_token = \"SESSIONTOKENGOESHERE\" ;\n std : : string result = url . url_ref ( ) . ReplaceSearchTerms ( search_terms_args , search_terms_data_ ) ;\n EXPECT_EQ ( \"http://bar/search?q=foo&psi=SESSIONTOKENGOESHERE&xssi=t\" , result ) ;\n TemplateURL url2 ( data ) ;\n search_terms_args . session_token = \"\" ;\n result = url . url_ref ( ) . ReplaceSearchTerms ( search_terms_args , search_terms_data_ ) ;\n EXPECT_EQ ( \"http://bar/search?q=foo&xssi=t\" , result ) ;\n }", "hash": -5456913190944844754, "project": "chrome", "size": 18, "target": 0, "idx": 20379}
{"code": "TEST_F ( TemplateURLTest , GenerateSearchURL ) {\n struct GenerateSearchURLCase {\n const char * test_name ;\n const char * url ;\n const char * expected ;\n }\n generate_url_cases [ ] = {\n {\n \"invalid URL\" , \"foo{\nsearchTerms}\n\" , \"\" }\n , {\n \"URL with no replacements\" , \"http://foo/\" , \"http://foo/\" }\n , {\n \"basic functionality\" , \"http://foo/{\nsearchTerms}\n\" , \"http://foo/blah.blah.blah.blah.blah\" }\n }\n ;\n for ( size_t i = 0 ;\n i < arraysize ( generate_url_cases ) ;\n ++ i ) {\n TemplateURLData data ;\n data . SetURL ( generate_url_cases [ i ] . url ) ;\n TemplateURL t_url ( data ) ;\n EXPECT_EQ ( t_url . GenerateSearchURL ( search_terms_data_ ) . spec ( ) , generate_url_cases [ i ] . expected ) << generate_url_cases [ i ] . test_name << \" failed.\" ;\n }\n }", "hash": -5456913190944844754, "project": "chrome", "size": 28, "target": 0, "idx": 20380}
{"code": "TEST_F ( HistoryQuickProviderTest , DoesNotProvideMatchesOnFocus ) {\n AutocompleteInput input ( ASCIIToUTF16 ( \"popularsite\" ) , base : : string16 : : npos , std : : string ( ) , GURL ( ) , metrics : : OmniboxEventProto : : INVALID_SPEC , false , false , true , true , true , TestSchemeClassifier ( ) ) ;\n provider_ -> Start ( input , false ) ;\n EXPECT_TRUE ( provider_ -> matches ( ) . empty ( ) ) ;\n }", "hash": -8176848763607321091, "project": "chrome", "size": 5, "target": 0, "idx": 20416}
{"code": "TEST_F ( ScoredHistoryMatchTest , ScoringTLD ) {\n base : : Time now = base : : Time : : NowFromSystemTime ( ) ;\n std : : string url_string ( \"http://fedcba.com/\" ) ;\n const GURL url ( url_string ) ;\n history : : URLRow row ( MakeURLRow ( url_string . c_str ( ) , \"\" , 8 , 3 , 1 ) ) ;\n RowWordStarts word_starts ;\n PopulateWordStarts ( row , & word_starts ) ;\n WordStarts two_words_no_offsets ( 2 , 0u ) ;\n VisitInfoVector visits = CreateVisitInfoVector ( 8 , 3 , now ) ;\n ScoredHistoryMatch scored ( row , visits , ASCIIToUTF16 ( \"fed com\" ) , Make2Terms ( \"fed\" , \"com\" ) , two_words_no_offsets , word_starts , false , nullptr , now ) ;\n EXPECT_EQ ( 0 , scored . raw_score ) ;\n base : : AutoReset < bool > reset ( & ScoredHistoryMatch : : allow_tld_matches_ , true ) ;\n ScoredHistoryMatch scored_with_tld ( row , visits , ASCIIToUTF16 ( \"fed com\" ) , Make2Terms ( \"fed\" , \"com\" ) , two_words_no_offsets , word_starts , false , nullptr , now ) ;\n EXPECT_GT ( scored_with_tld . raw_score , 0 ) ;\n }", "hash": 5838244232542871853, "project": "chrome", "size": 15, "target": 0, "idx": 20426}
{"code": "TEST_F ( AutocompleteResultTest , SortAndCullDuplicateSearchURLs ) {\n TemplateURLData url_data ;\n url_data . SetShortName ( base : : ASCIIToUTF16 ( \"unittest\" ) ) ;\n url_data . SetKeyword ( base : : ASCIIToUTF16 ( \"foo\" ) ) ;\n url_data . SetURL ( \"http://www.foo.com/s?q={\nsearchTerms}\n\" ) ;\n template_url_service_ . get ( ) -> Add ( new TemplateURL ( url_data ) ) ;\n TestData data [ ] = {\n {\n 0 , 1 , 1300 , true }\n , {\n 1 , 1 , 1200 , true }\n , {\n 2 , 1 , 1100 , true }\n , {\n 3 , 1 , 1000 , true }\n , {\n 4 , 2 , 900 , true }\n , }\n ;\n ACMatches matches ;\n PopulateAutocompleteMatches ( data , arraysize ( data ) , & matches ) ;\n matches [ 0 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo\" ) ;\n matches [ 1 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo2\" ) ;\n matches [ 2 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo&oq=f\" ) ;\n matches [ 3 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo&aqs=0\" ) ;\n matches [ 4 ] . destination_url = GURL ( \"http://www.foo.com/\" ) ;\n AutocompleteInput input ( base : : string16 ( ) , base : : string16 : : npos , std : : string ( ) , GURL ( ) , OmniboxEventProto : : INVALID_SPEC , false , false , false , true , false , TestSchemeClassifier ( ) ) ;\n AutocompleteResult result ;\n result . AppendMatches ( input , matches ) ;\n result . SortAndCull ( input , template_url_service_ . get ( ) ) ;\n ASSERT_EQ ( 3U , result . size ( ) ) ;\n EXPECT_EQ ( \"http://www.foo.com/s?q=foo\" , result . match_at ( 0 ) -> destination_url . spec ( ) ) ;\n EXPECT_EQ ( 1300 , result . match_at ( 0 ) -> relevance ) ;\n EXPECT_EQ ( \"http://www.foo.com/s?q=foo2\" , result . match_at ( 1 ) -> destination_url . spec ( ) ) ;\n EXPECT_EQ ( 1200 , result . match_at ( 1 ) -> relevance ) ;\n EXPECT_EQ ( \"http://www.foo.com/\" , result . match_at ( 2 ) -> destination_url . spec ( ) ) ;\n EXPECT_EQ ( 900 , result . match_at ( 2 ) -> relevance ) ;\n }", "hash": 8073241806104522127, "project": "chrome", "size": 40, "target": 0, "idx": 20443}
{"code": "TEST_F ( ShortcutsProviderTest , ClassifyAllMatchesInString ) {\n ACMatchClassifications matches = AutocompleteMatch : : ClassificationsFromString ( \"0,0\" ) ;\n ClassifyTest classify_test ( ASCIIToUTF16 ( \"A man, a plan, a canal Panama\" ) , matches ) ;\n ACMatchClassifications spans_a = classify_test . RunTest ( ASCIIToUTF16 ( \"man\" ) ) ;\n EXPECT_EQ ( \"0,0,2,2,5,0\" , AutocompleteMatch : : ClassificationsToString ( spans_a ) ) ;\n ACMatchClassifications spans_b = classify_test . RunTest ( ASCIIToUTF16 ( \"man p\" ) ) ;\n EXPECT_EQ ( \"0,0,2,2,5,0,9,2,10,0,23,2,24,0\" , AutocompleteMatch : : ClassificationsToString ( spans_b ) ) ;\n ACMatchClassifications spans_c = classify_test . RunTest ( ASCIIToUTF16 ( \"man plan panama\" ) ) ;\n EXPECT_EQ ( \"0,0,2,2,5,0,9,2,13,0,23,2\" , AutocompleteMatch : : ClassificationsToString ( spans_c ) ) ;\n ClassifyTest classify_test2 ( ASCIIToUTF16 ( \"Yahoo! Sports - Sports News, \" \"Scores, Rumors, Fantasy Games, and more\" ) , matches ) ;\n ACMatchClassifications spans_d = classify_test2 . RunTest ( ASCIIToUTF16 ( \"ne\" ) ) ;\n EXPECT_EQ ( \"0,0,23,2,25,0\" , AutocompleteMatch : : ClassificationsToString ( spans_d ) ) ;\n ACMatchClassifications spans_e = classify_test2 . RunTest ( ASCIIToUTF16 ( \"news r\" ) ) ;\n EXPECT_EQ ( \"0,0,10,2,11,0,19,2,20,0,23,2,27,0,32,2,33,0,37,2,38,0,41,2,42,0,\" \"66,2,67,0\" , AutocompleteMatch : : ClassificationsToString ( spans_e ) ) ;\n matches = AutocompleteMatch : : ClassificationsFromString ( \"0,1\" ) ;\n ClassifyTest classify_test3 ( ASCIIToUTF16 ( \"livescore.goal.com\" ) , matches ) ;\n ACMatchClassifications spans_f = classify_test3 . RunTest ( ASCIIToUTF16 ( \"go\" ) ) ;\n EXPECT_EQ ( \"0,1,10,3,12,1\" , AutocompleteMatch : : ClassificationsToString ( spans_f ) ) ;\n matches = AutocompleteMatch : : ClassificationsFromString ( \"0,0,13,1\" ) ;\n ClassifyTest classify_test4 ( ASCIIToUTF16 ( \"Email login: mail.somecorp.com\" ) , matches ) ;\n ACMatchClassifications spans_g = classify_test4 . RunTest ( ASCIIToUTF16 ( \"ail\" ) ) ;\n EXPECT_EQ ( \"0,0,2,2,5,0,13,1,14,3,17,1\" , AutocompleteMatch : : ClassificationsToString ( spans_g ) ) ;\n ACMatchClassifications spans_h = classify_test4 . RunTest ( ASCIIToUTF16 ( \"lo log\" ) ) ;\n EXPECT_EQ ( \"0,0,6,2,9,0,13,1\" , AutocompleteMatch : : ClassificationsToString ( spans_h ) ) ;\n ACMatchClassifications spans_i = classify_test4 . RunTest ( ASCIIToUTF16 ( \"ail em\" ) ) ;\n EXPECT_EQ ( \"0,2,5,0,13,1,14,3,17,1\" , AutocompleteMatch : : ClassificationsToString ( spans_i ) ) ;\n class ClassifyTest classify_test5 ( ( base : : string16 ( ) ) , ACMatchClassifications ( ) ) ;\n ACMatchClassifications spans_j = classify_test5 . RunTest ( ASCIIToUTF16 ( \"man\" ) ) ;\n ASSERT_EQ ( 0U , spans_j . size ( ) ) ;\n matches = AutocompleteMatch : : ClassificationsFromString ( \"0,4,9,0\" ) ;\n ClassifyTest classify_test6 ( ASCIIToUTF16 ( \"html password example\" ) , matches ) ;\n ACMatchClassifications spans_k = classify_test6 . RunTest ( ASCIIToUTF16 ( \"html pass\" ) ) ;\n EXPECT_EQ ( \"0,6,4,4,5,6,9,0\" , AutocompleteMatch : : ClassificationsToString ( spans_k ) ) ;\n matches = AutocompleteMatch : : ClassificationsFromString ( \"0,1,11,0\" ) ;\n ClassifyTest classify_test7 ( ASCIIToUTF16 ( \"http://a.co is great\" ) , matches ) ;\n ACMatchClassifications spans_l = classify_test7 . RunTest ( ASCIIToUTF16 ( \"ht co\" ) ) ;\n EXPECT_EQ ( \"0,3,2,1,9,3,11,0\" , AutocompleteMatch : : ClassificationsToString ( spans_l ) ) ;\n }", "hash": 7484321273243811670, "project": "chrome", "size": 38, "target": 0, "idx": 20465}
{"code": "IN_PROC_BROWSER_TEST_F ( ExtensionMessageBubbleViewBrowserTest , ExtensionBubbleAnchoredToAppMenu ) {\n TestBubbleAnchoredToAppMenu ( ) ;\n }", "hash": -5300415683778646743, "project": "chrome", "size": 3, "target": 0, "idx": 20481}
{"code": "static int jbig2_word_stream_buf_get_next_word ( Jbig2WordStream * self , int offset , uint32_t * word ) {\n Jbig2WordStreamBuf * z = ( Jbig2WordStreamBuf * ) self ;\n const byte * data = z -> data ;\n uint32_t result ;\n if ( offset + 4 < z -> size ) result = ( data [ offset ] << 24 ) | ( data [ offset + 1 ] << 16 ) | ( data [ offset + 2 ] << 8 ) | data [ offset + 3 ] ;\n else if ( offset > z -> size ) return - 1 ;\n else {\n int i ;\n result = 0 ;\n for ( i = 0 ;\n i < z -> size - offset ;\n i ++ ) result |= data [ offset + i ] << ( ( 3 - i ) << 3 ) ;\n }\n * word = result ;\n return 0 ;\n }", "hash": -1768728156572022708, "project": "debian", "size": 16, "target": 1, "idx": 20495}
{"code": "int jbig2_decode_halftone_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , Jbig2HalftoneRegionParams * params , const byte * data , const size_t size , Jbig2Image * image , Jbig2ArithCx * GB_stats ) {\n uint32_t HBPP ;\n uint32_t HNUMPATS ;\n uint8_t * * GI ;\n Jbig2Image * HSKIP = NULL ;\n Jbig2PatternDict * HPATS ;\n int i ;\n uint32_t mg , ng ;\n int32_t x , y ;\n uint8_t gray_val ;\n memset ( image -> data , params -> HDEFPIXEL , image -> stride * image -> height ) ;\n if ( params -> HENABLESKIP == 1 ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"unhandled option HENABLESKIP\" ) ;\n }\n HPATS = jbig2_decode_ht_region_get_hpats ( ctx , segment ) ;\n if ( ! HPATS ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"no pattern dictionary found, skipping halftone image\" ) ;\n return - 1 ;\n }\n HNUMPATS = HPATS -> n_patterns ;\n HBPP = 0 ;\n while ( HNUMPATS > ( 1 << ++ HBPP ) ) ;\n GI = jbig2_decode_gray_scale_image ( ctx , segment , data , size , params -> HMMR , params -> HGW , params -> HGH , HBPP , params -> HENABLESKIP , HSKIP , params -> HTEMPLATE , GB_stats ) ;\n if ( ! GI ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"unable to acquire gray-scale image, skipping halftone image\" ) ;\n return - 1 ;\n }\n for ( mg = 0 ;\n mg < params -> HGH ;\n ++ mg ) {\n for ( ng = 0 ;\n ng < params -> HGW ;\n ++ ng ) {\n x = ( params -> HGX + mg * params -> HRY + ng * params -> HRX ) >> 8 ;\n y = ( params -> HGY + mg * params -> HRX - ng * params -> HRY ) >> 8 ;\n gray_val = GI [ ng ] [ mg ] ;\n if ( gray_val >= HNUMPATS ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"gray-scale image uses value %d which larger than pattern dictionary\" , gray_val ) ;\n gray_val = HNUMPATS - 1 ;\n }\n jbig2_image_compose ( ctx , image , HPATS -> patterns [ gray_val ] , x , y , params -> op ) ;\n }\n }\n for ( i = 0 ;\n i < params -> HGW ;\n ++ i ) {\n jbig2_free ( ctx -> allocator , GI [ i ] ) ;\n }\n jbig2_free ( ctx -> allocator , GI ) ;\n return 0 ;\n }", "hash": -3955770052982962380, "project": "debian", "size": 51, "target": 1, "idx": 20499}
{"code": "Jbig2Segment * jbig2_parse_segment_header ( Jbig2Ctx * ctx , uint8_t * buf , size_t buf_size , size_t * p_header_size ) {\n Jbig2Segment * result ;\n uint8_t rtscarf ;\n uint32_t rtscarf_long ;\n uint32_t * referred_to_segments ;\n int referred_to_segment_count ;\n int referred_to_segment_size ;\n int pa_size ;\n int offset ;\n if ( buf_size < 11 ) return NULL ;\n result = jbig2_new ( ctx , Jbig2Segment , 1 ) ;\n if ( result == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , - 1 , \"failed to allocate segment in jbig2_parse_segment_header\" ) ;\n return result ;\n }\n result -> number = jbig2_get_uint32 ( buf ) ;\n result -> flags = buf [ 4 ] ;\n rtscarf = buf [ 5 ] ;\n if ( ( rtscarf & 0xe0 ) == 0xe0 ) {\n rtscarf_long = jbig2_get_uint32 ( buf + 5 ) ;\n referred_to_segment_count = rtscarf_long & 0x1fffffff ;\n offset = 5 + 4 + ( referred_to_segment_count + 1 ) / 8 ;\n }\n else {\n referred_to_segment_count = ( rtscarf >> 5 ) ;\n offset = 5 + 1 ;\n }\n result -> referred_to_segment_count = referred_to_segment_count ;\n referred_to_segment_size = result -> number <= 256 ? 1 : result -> number <= 65536 ? 2 : 4 ;\n pa_size = result -> flags & 0x40 ? 4 : 1 ;\n if ( offset + referred_to_segment_count * referred_to_segment_size + pa_size + 4 > buf_size ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , result -> number , \"jbig2_parse_segment_header() called with insufficient data\" , - 1 ) ;\n jbig2_free ( ctx -> allocator , result ) ;\n return NULL ;\n }\n if ( referred_to_segment_count ) {\n int i ;\n referred_to_segments = jbig2_new ( ctx , uint32_t , referred_to_segment_count * referred_to_segment_size ) ;\n if ( referred_to_segments == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , - 1 , \"could not allocate referred_to_segments \" \"in jbig2_parse_segment_header\" ) ;\n return NULL ;\n }\n for ( i = 0 ;\n i < referred_to_segment_count ;\n i ++ ) {\n referred_to_segments [ i ] = ( referred_to_segment_size == 1 ) ? buf [ offset ] : ( referred_to_segment_size == 2 ) ? jbig2_get_uint16 ( buf + offset ) : jbig2_get_uint32 ( buf + offset ) ;\n offset += referred_to_segment_size ;\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , result -> number , \"segment %d refers to segment %d\" , result -> number , referred_to_segments [ i ] ) ;\n }\n result -> referred_to_segments = referred_to_segments ;\n }\n else {\n result -> referred_to_segments = NULL ;\n }\n if ( result -> flags & 0x40 ) {\n result -> page_association = jbig2_get_uint32 ( buf + offset ) ;\n offset += 4 ;\n }\n else {\n result -> page_association = buf [ offset ++ ] ;\n }\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , result -> number , \"segment %d is associated with page %d\" , result -> number , result -> page_association ) ;\n result -> data_length = jbig2_get_uint32 ( buf + offset ) ;\n * p_header_size = offset + 4 ;\n result -> result = NULL ;\n return result ;\n }", "hash": -2492312952058578720, "project": "debian", "size": 67, "target": 1, "idx": 20510}
{"code": "static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char ) typedef void * OPENSSL_BLOCK ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_BLOCK , void )", "hash": 3599206110384554647, "project": "debian", "size": 28, "target": 1, "idx": 20518}
{"code": "static ossl_inline t2 * sk_ ## t1 ## _delete_ptr ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_delete_ptr ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char ) typedef void * OPENSSL_BLOCK ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_BLOCK , void )", "hash": 3599206110384554647, "project": "debian", "size": 49, "target": 1, "idx": 20547}
{"code": "static ossl_inline t2 * sk_ ## t1 ## _delete ( STACK_OF ( t1 ) * sk , int i ) {\n return ( t2 * ) OPENSSL_sk_delete ( ( OPENSSL_STACK * ) sk , i ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete_ptr ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_delete_ptr ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char )", "hash": 3599206110384554647, "project": "debian", "size": 51, "target": 1, "idx": 20564}
{"code": "static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new_null ( void ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new_null ( ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _new_reserve ( sk_ ## t1 ## _compfunc compare , int n ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_new_reserve ( ( OPENSSL_sk_compfunc ) compare , n ) ;\n }\n static ossl_inline int sk_ ## t1 ## _reserve ( STACK_OF ( t1 ) * sk , int n ) {\n return OPENSSL_sk_reserve ( ( OPENSSL_STACK * ) sk , n ) ;\n }\n static ossl_inline void sk_ ## t1 ## _free ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_free ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _zero ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_zero ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete ( STACK_OF ( t1 ) * sk , int i ) {\n return ( t2 * ) OPENSSL_sk_delete ( ( OPENSSL_STACK * ) sk , i ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _delete_ptr ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_delete_ptr ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _push ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_push ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _unshift ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_unshift ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _pop ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_pop ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _shift ( STACK_OF ( t1 ) * sk ) {\n return ( t2 * ) OPENSSL_sk_shift ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline void sk_ ## t1 ## _pop_free ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _freefunc freefunc ) {\n OPENSSL_sk_pop_free ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline int sk_ ## t1 ## _insert ( STACK_OF ( t1 ) * sk , t2 * ptr , int idx ) {\n return OPENSSL_sk_insert ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr , idx ) ;\n }\n static ossl_inline t2 * sk_ ## t1 ## _set ( STACK_OF ( t1 ) * sk , int idx , t2 * ptr ) {\n return ( t2 * ) OPENSSL_sk_set ( ( OPENSSL_STACK * ) sk , idx , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline int sk_ ## t1 ## _find_ex ( STACK_OF ( t1 ) * sk , t2 * ptr ) {\n return OPENSSL_sk_find_ex ( ( OPENSSL_STACK * ) sk , ( const void * ) ptr ) ;\n }\n static ossl_inline void sk_ ## t1 ## _sort ( STACK_OF ( t1 ) * sk ) {\n OPENSSL_sk_sort ( ( OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline int sk_ ## t1 ## _is_sorted ( const STACK_OF ( t1 ) * sk ) {\n return OPENSSL_sk_is_sorted ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _dup ( const STACK_OF ( t1 ) * sk ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_dup ( ( const OPENSSL_STACK * ) sk ) ;\n }\n static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char ) typedef void * OPENSSL_BLOCK ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_BLOCK , void )", "hash": 3599206110384554647, "project": "debian", "size": 67, "target": 1, "idx": 20568}
{"code": "void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING )", "hash": 1366214969540455677, "project": "debian", "size": 90, "target": 1, "idx": 20585}
{"code": "void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_NULL ) DECLARE_ASN1_FUNCTIONS ( ASN1_BMPSTRING ) int UTF8_getc ( const unsigned char * str , int len , unsigned long * val ) ;\n int UTF8_putc ( unsigned char * str , int len , unsigned long value ) ;\n DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , ASN1_PRINTABLE ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DIRECTORYSTRING ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DISPLAYTEXT ) DECLARE_ASN1_FUNCTIONS ( ASN1_PRINTABLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_T61STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_IA5STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_GENERALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTCTIME ) DECLARE_ASN1_FUNCTIONS ( ASN1_GENERALIZEDTIME ) DECLARE_ASN1_FUNCTIONS ( ASN1_TIME )", "hash": 1366214969540455677, "project": "debian", "size": 92, "target": 1, "idx": 20591}
{"code": "int i2d_ ## name ( type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( itname ) # define DECLARE_ASN1_ENCODE_FUNCTIONS_const ( type , name ) type * d2i_ ## name ( type * * a , const unsigned char * * in , long len ) ;\n int i2d_ ## name ( const type * a , unsigned char * * out ) ;\n DECLARE_ASN1_ITEM ( name ) # define DECLARE_ASN1_NDEF_FUNCTION ( name ) int i2d_ ## name ## _NDEF ( name * a , unsigned char * * out ) ;\n # define DECLARE_ASN1_FUNCTIONS_const ( name ) DECLARE_ASN1_ALLOC_FUNCTIONS ( name ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( name , name ) # define DECLARE_ASN1_ALLOC_FUNCTIONS_name ( type , name ) type * name ## _new ( void ) ;\n void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED )", "hash": 1366214969540455677, "project": "debian", "size": 82, "target": 1, "idx": 20595}
{"code": "void name ## _free ( type * a ) ;\n # define DECLARE_ASN1_PRINT_FUNCTION ( stname ) DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , stname ) # define DECLARE_ASN1_PRINT_FUNCTION_fname ( stname , fname ) int fname ## _print_ctx ( BIO * out , stname * x , int indent , const ASN1_PCTX * pctx ) ;\n # define D2I_OF ( type ) type * ( * ) ( type * * , const unsigned char * * , long ) # define I2D_OF ( type ) int ( * ) ( type * , unsigned char * * ) # define I2D_OF_const ( type ) int ( * ) ( const type * , unsigned char * * ) # define CHECKED_D2I_OF ( type , d2i ) ( ( d2i_of_void * ) ( 1 ? d2i : ( ( D2I_OF ( type ) ) 0 ) ) ) # define CHECKED_I2D_OF ( type , i2d ) ( ( i2d_of_void * ) ( 1 ? i2d : ( ( I2D_OF ( type ) ) 0 ) ) ) # define CHECKED_NEW_OF ( type , xnew ) ( ( void * ( * ) ( void ) ) ( 1 ? xnew : ( ( type * ( * ) ( void ) ) 0 ) ) ) # define CHECKED_PTR_OF ( type , p ) ( ( void * ) ( 1 ? p : ( type * ) 0 ) ) # define CHECKED_PPTR_OF ( type , p ) ( ( void * * ) ( 1 ? p : ( type * * ) 0 ) ) # define TYPEDEF_D2I_OF ( type ) typedef type * d2i_of_ ## type ( type * * , const unsigned char * * , long ) # define TYPEDEF_I2D_OF ( type ) typedef int i2d_of_ ## type ( type * , unsigned char * * ) # define TYPEDEF_D2I2D_OF ( type ) TYPEDEF_D2I_OF ( type ) ;\n TYPEDEF_I2D_OF ( type ) TYPEDEF_D2I2D_OF ( void ) ;\n # ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION typedef const ASN1_ITEM ASN1_ITEM_EXP ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ) # define ASN1_ITEM_ref ( iptr ) ( & ( iptr ## _it ) ) # define ASN1_ITEM_rptr ( ref ) ( & ( ref ## _it ) ) # define DECLARE_ASN1_ITEM ( name ) OPENSSL_EXTERN const ASN1_ITEM name ## _it ;\n # else typedef const ASN1_ITEM * ASN1_ITEM_EXP ( void ) ;\n # define ASN1_ITEM_ptr ( iptr ) ( iptr ( ) ) # define ASN1_ITEM_ref ( iptr ) ( iptr ## _it ) # define ASN1_ITEM_rptr ( ref ) ( ref ## _it ( ) ) # define DECLARE_ASN1_ITEM ( name ) const ASN1_ITEM * name ## _it ( void ) ;\n # endif # define ASN1_STRFLGS_ESC_2253 1 # define ASN1_STRFLGS_ESC_CTRL 2 # define ASN1_STRFLGS_ESC_MSB 4 # define ASN1_STRFLGS_ESC_QUOTE 8 # define CHARTYPE_PRINTABLESTRING 0x10 # define CHARTYPE_FIRST_ESC_2253 0x20 # define CHARTYPE_LAST_ESC_2253 0x40 # define ASN1_STRFLGS_UTF8_CONVERT 0x10 # define ASN1_STRFLGS_IGNORE_TYPE 0x20 # define ASN1_STRFLGS_SHOW_TYPE 0x40 # define ASN1_STRFLGS_DUMP_ALL 0x80 # define ASN1_STRFLGS_DUMP_UNKNOWN 0x100 # define ASN1_STRFLGS_DUMP_DER 0x200 # define ASN1_STRFLGS_ESC_2254 0x400 # define ASN1_STRFLGS_RFC2253 ( ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN | ASN1_STRFLGS_DUMP_DER ) DEFINE_STACK_OF ( ASN1_INTEGER ) DEFINE_STACK_OF ( ASN1_GENERALSTRING ) DEFINE_STACK_OF ( ASN1_UTF8STRING ) typedef struct asn1_type_st {\n int type ;\n union {\n char * ptr ;\n ASN1_BOOLEAN boolean ;\n ASN1_STRING * asn1_string ;\n ASN1_OBJECT * object ;\n ASN1_INTEGER * integer ;\n ASN1_ENUMERATED * enumerated ;\n ASN1_BIT_STRING * bit_string ;\n ASN1_OCTET_STRING * octet_string ;\n ASN1_PRINTABLESTRING * printablestring ;\n ASN1_T61STRING * t61string ;\n ASN1_IA5STRING * ia5string ;\n ASN1_GENERALSTRING * generalstring ;\n ASN1_BMPSTRING * bmpstring ;\n ASN1_UNIVERSALSTRING * universalstring ;\n ASN1_UTCTIME * utctime ;\n ASN1_GENERALIZEDTIME * generalizedtime ;\n ASN1_VISIBLESTRING * visiblestring ;\n ASN1_UTF8STRING * utf8string ;\n ASN1_STRING * set ;\n ASN1_STRING * sequence ;\n ASN1_VALUE * asn1_value ;\n }\n value ;\n }\n ASN1_TYPE ;\n DEFINE_STACK_OF ( ASN1_TYPE ) typedef STACK_OF ( ASN1_TYPE ) ASN1_SEQUENCE_ANY ;\n DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SEQUENCE_ANY ) DECLARE_ASN1_ENCODE_FUNCTIONS_const ( ASN1_SEQUENCE_ANY , ASN1_SET_ANY ) typedef struct BIT_STRING_BITNAME_st {\n int bitnum ;\n const char * lname ;\n const char * sname ;\n }\n BIT_STRING_BITNAME ;\n # define B_ASN1_TIME B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME # define B_ASN1_PRINTABLE B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN # define B_ASN1_DIRECTORYSTRING B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING # define B_ASN1_DISPLAYTEXT B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | B_ASN1_UTF8STRING DECLARE_ASN1_FUNCTIONS_fname ( ASN1_TYPE , ASN1_ANY , ASN1_TYPE ) int ASN1_TYPE_get ( const ASN1_TYPE * a ) ;\n void ASN1_TYPE_set ( ASN1_TYPE * a , int type , void * value ) ;\n int ASN1_TYPE_set1 ( ASN1_TYPE * a , int type , const void * value ) ;\n int ASN1_TYPE_cmp ( const ASN1_TYPE * a , const ASN1_TYPE * b ) ;\n ASN1_TYPE * ASN1_TYPE_pack_sequence ( const ASN1_ITEM * it , void * s , ASN1_TYPE * * t ) ;\n void * ASN1_TYPE_unpack_sequence ( const ASN1_ITEM * it , const ASN1_TYPE * t ) ;\n ASN1_OBJECT * ASN1_OBJECT_new ( void ) ;\n void ASN1_OBJECT_free ( ASN1_OBJECT * a ) ;\n int i2d_ASN1_OBJECT ( const ASN1_OBJECT * a , unsigned char * * pp ) ;\n ASN1_OBJECT * d2i_ASN1_OBJECT ( ASN1_OBJECT * * a , const unsigned char * * pp , long length ) ;\n DECLARE_ASN1_ITEM ( ASN1_OBJECT ) DEFINE_STACK_OF ( ASN1_OBJECT ) ASN1_STRING * ASN1_STRING_new ( void ) ;\n void ASN1_STRING_free ( ASN1_STRING * a ) ;\n void ASN1_STRING_clear_free ( ASN1_STRING * a ) ;\n int ASN1_STRING_copy ( ASN1_STRING * dst , const ASN1_STRING * str ) ;\n ASN1_STRING * ASN1_STRING_dup ( const ASN1_STRING * a ) ;\n ASN1_STRING * ASN1_STRING_type_new ( int type ) ;\n int ASN1_STRING_cmp ( const ASN1_STRING * a , const ASN1_STRING * b ) ;\n int ASN1_STRING_set ( ASN1_STRING * str , const void * data , int len ) ;\n void ASN1_STRING_set0 ( ASN1_STRING * str , void * data , int len ) ;\n int ASN1_STRING_length ( const ASN1_STRING * x ) ;\n void ASN1_STRING_length_set ( ASN1_STRING * x , int n ) ;\n int ASN1_STRING_type ( const ASN1_STRING * x ) ;\n DEPRECATEDIN_1_1_0 ( unsigned char * ASN1_STRING_data ( ASN1_STRING * x ) ) const unsigned char * ASN1_STRING_get0_data ( const ASN1_STRING * x ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_BIT_STRING ) int ASN1_BIT_STRING_set ( ASN1_BIT_STRING * a , unsigned char * d , int length ) ;\n int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) ;\n int ASN1_BIT_STRING_get_bit ( const ASN1_BIT_STRING * a , int n ) ;\n int ASN1_BIT_STRING_check ( const ASN1_BIT_STRING * a , const unsigned char * flags , int flags_len ) ;\n int ASN1_BIT_STRING_name_print ( BIO * out , ASN1_BIT_STRING * bs , BIT_STRING_BITNAME * tbl , int indent ) ;\n int ASN1_BIT_STRING_num_asc ( const char * name , BIT_STRING_BITNAME * tbl ) ;\n int ASN1_BIT_STRING_set_asc ( ASN1_BIT_STRING * bs , const char * name , int value , BIT_STRING_BITNAME * tbl ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_INTEGER ) ASN1_INTEGER * d2i_ASN1_UINTEGER ( ASN1_INTEGER * * a , const unsigned char * * pp , long length ) ;\n ASN1_INTEGER * ASN1_INTEGER_dup ( const ASN1_INTEGER * x ) ;\n int ASN1_INTEGER_cmp ( const ASN1_INTEGER * x , const ASN1_INTEGER * y ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_ENUMERATED ) int ASN1_UTCTIME_check ( const ASN1_UTCTIME * a ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_set ( ASN1_UTCTIME * s , time_t t ) ;\n ASN1_UTCTIME * ASN1_UTCTIME_adj ( ASN1_UTCTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_UTCTIME_set_string ( ASN1_UTCTIME * s , const char * str ) ;\n int ASN1_UTCTIME_cmp_time_t ( const ASN1_UTCTIME * s , time_t t ) ;\n int ASN1_GENERALIZEDTIME_check ( const ASN1_GENERALIZEDTIME * a ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_set ( ASN1_GENERALIZEDTIME * s , time_t t ) ;\n ASN1_GENERALIZEDTIME * ASN1_GENERALIZEDTIME_adj ( ASN1_GENERALIZEDTIME * s , time_t t , int offset_day , long offset_sec ) ;\n int ASN1_GENERALIZEDTIME_set_string ( ASN1_GENERALIZEDTIME * s , const char * str ) ;\n int ASN1_TIME_diff ( int * pday , int * psec , const ASN1_TIME * from , const ASN1_TIME * to ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_OCTET_STRING ) ASN1_OCTET_STRING * ASN1_OCTET_STRING_dup ( const ASN1_OCTET_STRING * a ) ;\n int ASN1_OCTET_STRING_cmp ( const ASN1_OCTET_STRING * a , const ASN1_OCTET_STRING * b ) ;\n int ASN1_OCTET_STRING_set ( ASN1_OCTET_STRING * str , const unsigned char * data , int len ) ;\n DECLARE_ASN1_FUNCTIONS ( ASN1_VISIBLESTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UNIVERSALSTRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_UTF8STRING ) DECLARE_ASN1_FUNCTIONS ( ASN1_NULL ) DECLARE_ASN1_FUNCTIONS ( ASN1_BMPSTRING ) int UTF8_getc ( const unsigned char * str , int len , unsigned long * val ) ;\n int UTF8_putc ( unsigned char * str , int len , unsigned long value ) ;\n DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , ASN1_PRINTABLE ) DECLARE_ASN1_FUNCTIONS_name ( ASN1_STRING , DIRECTORYSTRING )", "hash": 1366214969540455677, "project": "debian", "size": 92, "target": 1, "idx": 20605}
{"code": "static int dtls1_retrieve_buffered_fragment ( SSL * s , int * ok ) {\n pitem * item ;\n hm_fragment * frag ;\n int al ;\n * ok = 0 ;\n item = pqueue_peek ( s -> d1 -> buffered_messages ) ;\n if ( item == NULL ) return 0 ;\n frag = ( hm_fragment * ) item -> data ;\n if ( frag -> reassembly != NULL ) return 0 ;\n if ( s -> d1 -> handshake_read_seq == frag -> msg_header . seq ) {\n unsigned long frag_len = frag -> msg_header . frag_len ;\n pqueue_pop ( s -> d1 -> buffered_messages ) ;\n al = dtls1_preprocess_fragment ( s , & frag -> msg_header ) ;\n if ( al == 0 ) {\n unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ;\n memcpy ( & p [ frag -> msg_header . frag_off ] , frag -> fragment , frag -> msg_header . frag_len ) ;\n }\n dtls1_hm_fragment_free ( frag ) ;\n pitem_free ( item ) ;\n if ( al == 0 ) {\n * ok = 1 ;\n return frag_len ;\n }\n ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ;\n s -> init_num = 0 ;\n * ok = 0 ;\n return - 1 ;\n }\n else return 0 ;\n }", "hash": 5575425611513297119, "project": "debian", "size": 30, "target": 1, "idx": 20614}
{"code": "static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )", "hash": -3062453801436404700, "project": "debian", "size": 6, "target": 1, "idx": 20618}
{"code": "static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )", "hash": -3062453801436404700, "project": "debian", "size": 9, "target": 1, "idx": 20624}
{"code": "int ImagingFliDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) {\n UINT8 * ptr ;\n int framesize ;\n int c , chunks ;\n int l , lines ;\n int i , j , x = 0 , y , ymax ;\n if ( bytes < 4 ) return 0 ;\n ptr = buf ;\n framesize = I32 ( ptr ) ;\n if ( framesize < I32 ( ptr ) ) return 0 ;\n if ( I16 ( ptr + 4 ) != 0xF1FA ) {\n state -> errcode = IMAGING_CODEC_UNKNOWN ;\n return - 1 ;\n }\n chunks = I16 ( ptr + 6 ) ;\n ptr += 16 ;\n for ( c = 0 ;\n c < chunks ;\n c ++ ) {\n UINT8 * data = ptr + 6 ;\n switch ( I16 ( ptr + 4 ) ) {\n case 4 : case 11 : break ;\n case 7 : lines = I16 ( data ) ;\n data += 2 ;\n for ( l = y = 0 ;\n l < lines && y < state -> ysize ;\n l ++ , y ++ ) {\n UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n int p , packets ;\n packets = I16 ( data ) ;\n data += 2 ;\n while ( packets & 0x8000 ) {\n if ( packets & 0x4000 ) {\n y += 65536 - packets ;\n if ( y >= state -> ysize ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n buf = ( UINT8 * ) im -> image [ y ] ;\n }\n else {\n buf [ state -> xsize - 1 ] = ( UINT8 ) packets ;\n }\n packets = I16 ( data ) ;\n data += 2 ;\n }\n for ( p = x = 0 ;\n p < packets ;\n p ++ ) {\n x += data [ 0 ] ;\n if ( data [ 1 ] >= 128 ) {\n i = 256 - data [ 1 ] ;\n if ( x + i + i > state -> xsize ) break ;\n for ( j = 0 ;\n j < i ;\n j ++ ) {\n buf [ x ++ ] = data [ 2 ] ;\n buf [ x ++ ] = data [ 3 ] ;\n }\n data += 2 + 2 ;\n }\n else {\n i = 2 * ( int ) data [ 1 ] ;\n if ( x + i > state -> xsize ) break ;\n memcpy ( buf + x , data + 2 , i ) ;\n data += 2 + i ;\n x += i ;\n }\n }\n if ( p < packets ) break ;\n }\n if ( l < lines ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n break ;\n case 12 : y = I16 ( data ) ;\n ymax = y + I16 ( data + 2 ) ;\n data += 4 ;\n for ( ;\n y < ymax && y < state -> ysize ;\n y ++ ) {\n UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n int p , packets = * data ++ ;\n for ( p = x = 0 ;\n p < packets ;\n p ++ , x += i ) {\n x += data [ 0 ] ;\n if ( data [ 1 ] & 0x80 ) {\n i = 256 - data [ 1 ] ;\n if ( x + i > state -> xsize ) break ;\n memset ( out + x , data [ 2 ] , i ) ;\n data += 3 ;\n }\n else {\n i = data [ 1 ] ;\n if ( x + i > state -> xsize ) break ;\n memcpy ( out + x , data + 2 , i ) ;\n data += i + 2 ;\n }\n }\n if ( p < packets ) break ;\n }\n if ( y < ymax ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n break ;\n case 13 : for ( y = 0 ;\n y < state -> ysize ;\n y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ;\n break ;\n case 15 : for ( y = 0 ;\n y < state -> ysize ;\n y ++ ) {\n UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n data += 1 ;\n for ( x = 0 ;\n x < state -> xsize ;\n x += i ) {\n if ( data [ 0 ] & 0x80 ) {\n i = 256 - data [ 0 ] ;\n if ( x + i > state -> xsize ) break ;\n memcpy ( out + x , data + 1 , i ) ;\n data += i + 1 ;\n }\n else {\n i = data [ 0 ] ;\n if ( x + i > state -> xsize ) break ;\n memset ( out + x , data [ 1 ] , i ) ;\n data += 2 ;\n }\n }\n if ( x != state -> xsize ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n }\n break ;\n case 16 : for ( y = 0 ;\n y < state -> ysize ;\n y ++ ) {\n UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n memcpy ( buf + x , data , state -> xsize ) ;\n data += state -> xsize ;\n }\n break ;\n case 18 : break ;\n default : state -> errcode = IMAGING_CODEC_UNKNOWN ;\n return - 1 ;\n }\n ptr += I32 ( ptr ) ;\n }\n return - 1 ;\n }", "hash": -8416645554750795024, "project": "debian", "size": 155, "target": 1, "idx": 20637}
{"code": "void * jas_realloc ( void * ptr , size_t size ) {\n void * result ;\n JAS_DBGLOG ( 101 , ( \"jas_realloc called with %x,%zu\\n\" , ptr , size ) ) ;\n result = realloc ( ptr , size ) ;\n JAS_DBGLOG ( 100 , ( \"jas_realloc(%p, %zu) -> %p\\n\" , ptr , size , result ) ) ;\n return result ;\n }", "hash": -4967913570211470865, "project": "debian", "size": 7, "target": 1, "idx": 20639}
{"code": "ParseResult mime_parser_parse ( MIMEParser * parser , HdrHeap * heap , MIMEHdrImpl * mh , const char * * real_s , const char * real_e , bool must_copy_strings , bool eof ) {\n ParseResult err ;\n bool line_is_real ;\n const char * colon ;\n const char * line_c ;\n const char * line_s = nullptr ;\n const char * line_e = nullptr ;\n const char * field_name_first ;\n const char * field_name_last ;\n const char * field_value_first ;\n const char * field_value_last ;\n const char * field_line_first ;\n const char * field_line_last ;\n int field_name_length , field_value_length ;\n MIMEScanner * scanner = & parser -> m_scanner ;\n while ( true ) {\n err = mime_scanner_get ( scanner , real_s , real_e , & line_s , & line_e , & line_is_real , eof , MIME_SCANNER_TYPE_FIELD ) ;\n if ( err != PARSE_RESULT_OK ) {\n return err ;\n }\n line_c = line_s ;\n if ( ( line_e - line_c >= 2 ) && ( line_c [ 0 ] == ParseRules : : CHAR_CR ) && ( line_c [ 1 ] == ParseRules : : CHAR_LF ) ) {\n return PARSE_RESULT_DONE ;\n }\n if ( ( line_e - line_c >= 1 ) && ( line_c [ 0 ] == ParseRules : : CHAR_LF ) ) {\n return PARSE_RESULT_DONE ;\n }\n field_line_first = line_c ;\n field_line_last = line_e - 1 ;\n field_name_first = line_c ;\n if ( ( ! ParseRules : : is_token ( * field_name_first ) ) && ( * field_name_first != '@' ) ) {\n continue ;\n }\n colon = ( char * ) memchr ( line_c , ':' , ( line_e - line_c ) ) ;\n if ( ! colon ) {\n continue ;\n }\n field_name_last = colon - 1 ;\n while ( ( field_name_last >= field_name_first ) && is_ws ( * field_name_last ) ) {\n -- field_name_last ;\n }\n field_value_first = colon + 1 ;\n while ( ( field_value_first < line_e ) && is_ws ( * field_value_first ) ) {\n ++ field_value_first ;\n }\n field_value_last = line_e - 1 ;\n while ( ( field_value_last >= field_value_first ) && ParseRules : : is_wslfcr ( * field_value_last ) ) {\n -- field_value_last ;\n }\n field_name_length = ( int ) ( field_name_last - field_name_first + 1 ) ;\n field_value_length = ( int ) ( field_value_last - field_value_first + 1 ) ;\n if ( field_name_length >= UINT16_MAX || field_value_length >= UINT16_MAX ) {\n return PARSE_RESULT_ERROR ;\n }\n int total_line_length = ( int ) ( field_line_last - field_line_first + 1 ) ;\n if ( must_copy_strings || ( ! line_is_real ) ) {\n int length = total_line_length ;\n char * dup = heap -> duplicate_str ( field_name_first , length ) ;\n intptr_t delta = dup - field_name_first ;\n field_name_first += delta ;\n field_value_first += delta ;\n }\n int field_name_wks_idx = hdrtoken_tokenize ( field_name_first , field_name_length ) ;\n MIMEField * field = mime_field_create ( heap , mh ) ;\n mime_field_name_value_set ( heap , mh , field , field_name_wks_idx , field_name_first , field_name_length , field_value_first , field_value_length , true , total_line_length , false ) ;\n mime_hdr_field_attach ( mh , field , 1 , nullptr ) ;\n }\n }", "hash": 2546373479020365143, "project": "debian", "size": 68, "target": 1, "idx": 20642}
{"code": "SPL_METHOD ( SplFileInfo , getPath ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n char * path ;\n int path_len ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n path = spl_filesystem_object_get_path ( intern , & path_len TSRMLS_CC ) ;\n RETURN_STRINGL ( path , path_len , 1 ) ;\n }", "hash": 1223258652239369123, "project": "debian", "size": 10, "target": 1, "idx": 20656}
{"code": "SPL_METHOD ( SplTempFileObject , __construct ) {\n long max_memory = PHP_STREAM_MAX_MEM ;\n char tmp_fname [ 48 ] ;\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n zend_error_handling error_handling ;\n zend_replace_error_handling ( EH_THROW , spl_ce_RuntimeException , & error_handling TSRMLS_CC ) ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|l\" , & max_memory ) == FAILURE ) {\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n return ;\n }\n if ( max_memory < 0 ) {\n intern -> file_name = \"php://memory\" ;\n intern -> file_name_len = 12 ;\n }\n else if ( ZEND_NUM_ARGS ( ) ) {\n intern -> file_name_len = slprintf ( tmp_fname , sizeof ( tmp_fname ) , \"php://temp/maxmemory:%ld\" , max_memory ) ;\n intern -> file_name = tmp_fname ;\n }\n else {\n intern -> file_name = \"php://temp\" ;\n intern -> file_name_len = 10 ;\n }\n intern -> u . file . open_mode = \"wb\" ;\n intern -> u . file . open_mode_len = 1 ;\n intern -> u . file . zcontext = NULL ;\n if ( spl_filesystem_file_open ( intern , 0 , 0 TSRMLS_CC ) == SUCCESS ) {\n intern -> _path_len = 0 ;\n intern -> _path = estrndup ( \"\" , 0 ) ;\n }\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n }", "hash": 1223258652239369123, "project": "debian", "size": 31, "target": 1, "idx": 20657}
{"code": "SPL_METHOD ( DirectoryIterator , getBasename ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n char * suffix = 0 , * fname ;\n int slen = 0 ;\n size_t flen ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|s\" , & suffix , & slen ) == FAILURE ) {\n return ;\n }\n php_basename ( intern -> u . dir . entry . d_name , strlen ( intern -> u . dir . entry . d_name ) , suffix , slen , & fname , & flen TSRMLS_CC ) ;\n RETURN_STRINGL ( fname , flen , 0 ) ;\n }", "hash": 1223258652239369123, "project": "debian", "size": 11, "target": 1, "idx": 20661}
{"code": "SPL_METHOD ( SplFileObject , hasChildren ) {\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_FALSE ;\n }", "hash": 1223258652239369123, "project": "debian", "size": 6, "target": 1, "idx": 20669}
{"code": "static spl_filesystem_object * spl_filesystem_object_create_info ( spl_filesystem_object * source , char * file_path , int file_path_len , int use_copy , zend_class_entry * ce , zval * return_value TSRMLS_DC ) {\n spl_filesystem_object * intern ;\n zval * arg1 ;\n zend_error_handling error_handling ;\n if ( ! file_path || ! file_path_len ) {\n # if defined ( PHP_WIN32 ) zend_throw_exception_ex ( spl_ce_RuntimeException , 0 TSRMLS_CC , \"Cannot create SplFileInfo for empty path\" ) ;\n if ( file_path && ! use_copy ) {\n efree ( file_path ) ;\n }\n # else if ( file_path && ! use_copy ) {\n efree ( file_path ) ;\n }\n file_path_len = 1 ;\n file_path = \"/\" ;\n # endif return NULL ;\n }\n zend_replace_error_handling ( EH_THROW , spl_ce_RuntimeException , & error_handling TSRMLS_CC ) ;\n ce = ce ? ce : source -> info_class ;\n zend_update_class_constants ( ce TSRMLS_CC ) ;\n return_value -> value . obj = spl_filesystem_object_new_ex ( ce , & intern TSRMLS_CC ) ;\n Z_TYPE_P ( return_value ) = IS_OBJECT ;\n if ( ce -> constructor -> common . scope != spl_ce_SplFileInfo ) {\n MAKE_STD_ZVAL ( arg1 ) ;\n ZVAL_STRINGL ( arg1 , file_path , file_path_len , use_copy ) ;\n zend_call_method_with_1_params ( & return_value , ce , & ce -> constructor , \"__construct\" , NULL , arg1 ) ;\n zval_ptr_dtor ( & arg1 ) ;\n }\n else {\n spl_filesystem_info_set_filename ( intern , file_path , file_path_len , use_copy TSRMLS_CC ) ;\n }\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n return intern ;\n }", "hash": 1223258652239369123, "project": "debian", "size": 33, "target": 1, "idx": 20672}
{"code": "SPL_METHOD ( SplFileObject , seek ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n long line_pos ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"l\" , & line_pos ) == FAILURE ) {\n return ;\n }\n if ( line_pos < 0 ) {\n zend_throw_exception_ex ( spl_ce_LogicException , 0 TSRMLS_CC , \"Can't seek file %s to negative line %ld\" , intern -> file_name , line_pos ) ;\n RETURN_FALSE ;\n }\n spl_filesystem_file_rewind ( getThis ( ) , intern TSRMLS_CC ) ;\n while ( intern -> u . file . current_line_num < line_pos ) {\n if ( spl_filesystem_file_read_line ( getThis ( ) , intern , 1 TSRMLS_CC ) == FAILURE ) {\n break ;\n }\n }\n }", "hash": 1223258652239369123, "project": "debian", "size": 17, "target": 1, "idx": 20675}
{"code": "SPL_METHOD ( SplFileObject , __construct ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n zend_bool use_include_path = 0 ;\n char * p1 , * p2 ;\n char * tmp_path ;\n int tmp_path_len ;\n zend_error_handling error_handling ;\n zend_replace_error_handling ( EH_THROW , spl_ce_RuntimeException , & error_handling TSRMLS_CC ) ;\n intern -> u . file . open_mode = NULL ;\n intern -> u . file . open_mode_len = 0 ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"p|sbr!\" , & intern -> file_name , & intern -> file_name_len , & intern -> u . file . open_mode , & intern -> u . file . open_mode_len , & use_include_path , & intern -> u . file . zcontext ) == FAILURE ) {\n intern -> u . file . open_mode = NULL ;\n intern -> file_name = NULL ;\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n return ;\n }\n if ( intern -> u . file . open_mode == NULL ) {\n intern -> u . file . open_mode = \"r\" ;\n intern -> u . file . open_mode_len = 1 ;\n }\n if ( spl_filesystem_file_open ( intern , use_include_path , 0 TSRMLS_CC ) == SUCCESS ) {\n tmp_path_len = strlen ( intern -> u . file . stream -> orig_path ) ;\n if ( tmp_path_len > 1 && IS_SLASH_AT ( intern -> u . file . stream -> orig_path , tmp_path_len - 1 ) ) {\n tmp_path_len -- ;\n }\n tmp_path = estrndup ( intern -> u . file . stream -> orig_path , tmp_path_len ) ;\n p1 = strrchr ( tmp_path , '/' ) ;\n # if defined ( PHP_WIN32 ) || defined ( NETWARE ) p2 = strrchr ( tmp_path , '\\\\' ) ;\n # else p2 = 0 ;\n # endif if ( p1 || p2 ) {\n intern -> _path_len = ( p1 > p2 ? p1 : p2 ) - tmp_path ;\n }\n else {\n intern -> _path_len = 0 ;\n }\n efree ( tmp_path ) ;\n intern -> _path = estrndup ( intern -> u . file . stream -> orig_path , intern -> _path_len ) ;\n }\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n }", "hash": 1223258652239369123, "project": "debian", "size": 40, "target": 1, "idx": 20677}
{"code": "SPL_METHOD ( DirectoryIterator , rewind ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n intern -> u . dir . index = 0 ;\n if ( intern -> u . dir . dirp ) {\n php_stream_rewinddir ( intern -> u . dir . dirp ) ;\n }\n spl_filesystem_dir_read ( intern TSRMLS_CC ) ;\n }", "hash": 1223258652239369123, "project": "debian", "size": 11, "target": 1, "idx": 20678}
{"code": "static int spl_filesystem_file_read ( spl_filesystem_object * intern , int silent TSRMLS_DC ) {\n char * buf ;\n size_t line_len = 0 ;\n long line_add = ( intern -> u . file . current_line || intern -> u . file . current_zval ) ? 1 : 0 ;\n spl_filesystem_file_free_line ( intern TSRMLS_CC ) ;\n if ( php_stream_eof ( intern -> u . file . stream ) ) {\n if ( ! silent ) {\n zend_throw_exception_ex ( spl_ce_RuntimeException , 0 TSRMLS_CC , \"Cannot read from file %s\" , intern -> file_name ) ;\n }\n return FAILURE ;\n }\n if ( intern -> u . file . max_line_len > 0 ) {\n buf = safe_emalloc ( ( intern -> u . file . max_line_len + 1 ) , sizeof ( char ) , 0 ) ;\n if ( php_stream_get_line ( intern -> u . file . stream , buf , intern -> u . file . max_line_len + 1 , & line_len ) == NULL ) {\n efree ( buf ) ;\n buf = NULL ;\n }\n else {\n buf [ line_len ] = '\\0' ;\n }\n }\n else {\n buf = php_stream_get_line ( intern -> u . file . stream , NULL , 0 , & line_len ) ;\n }\n if ( ! buf ) {\n intern -> u . file . current_line = estrdup ( \"\" ) ;\n intern -> u . file . current_line_len = 0 ;\n }\n else {\n if ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_DROP_NEW_LINE ) ) {\n line_len = strcspn ( buf , \"\\r\\n\" ) ;\n buf [ line_len ] = '\\0' ;\n }\n intern -> u . file . current_line = buf ;\n intern -> u . file . current_line_len = line_len ;\n }\n intern -> u . file . current_line_num += line_add ;\n return SUCCESS ;\n }", "hash": 1223258652239369123, "project": "debian", "size": 39, "target": 1, "idx": 20682}
{"code": "static void spl_filesystem_tree_it_rewind ( zend_object_iterator * iter TSRMLS_DC ) {\n spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ;\n spl_filesystem_object * object = spl_filesystem_iterator_to_object ( iterator ) ;\n object -> u . dir . index = 0 ;\n if ( object -> u . dir . dirp ) {\n php_stream_rewinddir ( object -> u . dir . dirp ) ;\n }\n do {\n spl_filesystem_dir_read ( object TSRMLS_CC ) ;\n }\n while ( spl_filesystem_is_dot ( object -> u . dir . entry . d_name ) ) ;\n if ( iterator -> current ) {\n zval_ptr_dtor ( & iterator -> current ) ;\n iterator -> current = NULL ;\n }\n }", "hash": 1223258652239369123, "project": "debian", "size": 16, "target": 1, "idx": 20690}
{"code": "static int spl_filesystem_file_read_line ( zval * this_ptr , spl_filesystem_object * intern , int silent TSRMLS_DC ) {\n int ret = spl_filesystem_file_read_line_ex ( this_ptr , intern , silent TSRMLS_CC ) ;\n while ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_SKIP_EMPTY ) && ret == SUCCESS && spl_filesystem_file_is_empty_line ( intern TSRMLS_CC ) ) {\n spl_filesystem_file_free_line ( intern TSRMLS_CC ) ;\n ret = spl_filesystem_file_read_line_ex ( this_ptr , intern , silent TSRMLS_CC ) ;\n }\n return ret ;\n }", "hash": 1223258652239369123, "project": "debian", "size": 8, "target": 1, "idx": 20698}
{"code": "extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;\n __exctype_l ( isalpha_l ) ;\n __exctype_l ( iscntrl_l ) ;\n __exctype_l ( isdigit_l ) ;\n __exctype_l ( islower_l ) ;\n __exctype_l ( isgraph_l ) ;\n __exctype_l ( isprint_l )", "hash": 455172021572601154, "project": "debian", "size": 7, "target": 1, "idx": 20721}
{"code": "int set_wep_key ( char * string ) {\n int bit = 0 ;\n char * p , type ;\n char * tok ;\n char s [ strlen ( string ) + 1 ] ;\n u_char tmp_wkey [ 512 ] ;\n size_t tmp_wkey_len ;\n char tmp [ 128 ] ;\n memset ( GBL_WIFI -> wkey , 0 , sizeof ( GBL_WIFI -> wkey ) ) ;\n GBL_WIFI -> wkey_len = 0 ;\n strcpy ( s , string ) ;\n p = ec_strtok ( s , \":\" , & tok ) ;\n if ( p == NULL ) SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n bit = atoi ( p ) ;\n if ( bit <= 0 ) SEMIFATAL_ERROR ( \"Unsupported WEP key length\" ) ;\n tmp_wkey_len = bit / 8 - WEP_IV_LEN ;\n if ( bit != 64 && bit != 128 ) SEMIFATAL_ERROR ( \"Unsupported WEP key length\" ) ;\n p = ec_strtok ( NULL , \":\" , & tok ) ;\n if ( p == NULL ) SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n type = * p ;\n p = ec_strtok ( NULL , \":\" , & tok ) ;\n if ( p == NULL ) SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n if ( type == 's' ) {\n if ( strescape ( ( char * ) tmp_wkey , p ) != ( int ) tmp_wkey_len ) SEMIFATAL_ERROR ( \"Specified WEP key length does not match the given string\" ) ;\n }\n else if ( type == 'p' ) {\n if ( bit == 64 ) make_key_64 ( ( u_char * ) p , tmp_wkey ) ;\n else if ( bit == 128 ) make_key_128 ( ( u_char * ) p , tmp_wkey ) ;\n }\n else {\n SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n }\n USER_MSG ( \"Using WEP key: %s\\n\" , str_tohex ( tmp_wkey , tmp_wkey_len , tmp , sizeof ( tmp ) ) ) ;\n memcpy ( GBL_WIFI -> wkey , tmp_wkey , sizeof ( GBL_WIFI -> wkey ) ) ;\n GBL_WIFI -> wkey_len = tmp_wkey_len ;\n return E_SUCCESS ;\n }", "hash": 9083170310480750768, "project": "debian", "size": 37, "target": 1, "idx": 20727}
{"code": "void registerSimpleTypes ( int proto ) {\n expert_module_t * expert_proto ;\n static hf_register_info hf [ ] = {\n {\n & hf_opcua_diag_mask , {\n \"EncodingMask\" , \"opcua.diag.mask\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_diag_mask_symbolicflag , {\n \"has symbolic id\" , \"opcua.diag.has_symbolic_id\" , FT_BOOLEAN , 8 , NULL , DIAGNOSTICINFO_ENCODINGMASK_SYMBOLICID_FLAG , NULL , HFILL }\n }\n , {\n & hf_opcua_diag_mask_namespaceflag , {\n \"has namespace\" , \"opcua.diag.has_namespace\" , FT_BOOLEAN , 8 , NULL , DIAGNOSTICINFO_ENCODINGMASK_NAMESPACE_FLAG , NULL , HFILL }\n }\n , {\n & hf_opcua_diag_mask_localizedtextflag , {\n \"has localizedtext\" , \"opcua.diag.has_localizedtext\" , FT_BOOLEAN , 8 , NULL , DIAGNOSTICINFO_ENCODINGMASK_LOCALIZEDTEXT_FLAG , NULL , HFILL }\n }\n , {\n & hf_opcua_diag_mask_localeflag , {\n \"has locale\" , \"opcua.diag.has_locale\" , FT_BOOLEAN , 8 , NULL , DIAGNOSTICINFO_ENCODINGMASK_LOCALE_FLAG , NULL , HFILL }\n }\n , {\n & hf_opcua_diag_mask_additionalinfoflag , {\n \"has additional info\" , \"opcua.diag.has_additional_info\" , FT_BOOLEAN , 8 , NULL , DIAGNOSTICINFO_ENCODINGMASK_ADDITIONALINFO_FLAG , NULL , HFILL }\n }\n , {\n & hf_opcua_diag_mask_innerstatuscodeflag , {\n \"has inner statuscode\" , \"opcua.diag.has_inner_statuscode\" , FT_BOOLEAN , 8 , NULL , DIAGNOSTICINFO_ENCODINGMASK_INNERSTATUSCODE_FLAG , NULL , HFILL }\n }\n , {\n & hf_opcua_diag_mask_innerdiaginfoflag , {\n \"has inner diagnostic info\" , \"opcua.diag.has_inner_diagnostic_code\" , FT_BOOLEAN , 8 , NULL , DIAGNOSTICINFO_ENCODINGMASK_INNERDIAGNOSTICINFO_FLAG , NULL , HFILL }\n }\n , {\n & hf_opcua_loctext_mask , {\n \"EncodingMask\" , \"opcua.loctext.mask\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_loctext_mask_localeflag , {\n \"has locale information\" , \"opcua.loctext.has_locale_information\" , FT_BOOLEAN , 8 , NULL , LOCALIZEDTEXT_ENCODINGBYTE_LOCALE , NULL , HFILL }\n }\n , {\n & hf_opcua_loctext_mask_textflag , {\n \"has text\" , \"opcua.loctext.has_text\" , FT_BOOLEAN , 8 , NULL , LOCALIZEDTEXT_ENCODINGBYTE_TEXT , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeid_encodingmask , {\n \"EncodingMask\" , \"opcua.nodeid.encodingmask\" , FT_UINT8 , BASE_HEX , VALS ( g_nodeidmasks ) , 0x0F , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeid_nsindex , {\n \"Namespace Index\" , \"opcua.nodeid.nsindex\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeid_numeric , {\n \"Identifier Numeric\" , \"opcua.nodeid.numeric\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeid_string , {\n \"Identifier String\" , \"opcua.nodeid.string\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeid_guid , {\n \"Identifier Guid\" , \"opcua.nodeid.guid\" , FT_GUID , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeid_bytestring , {\n \"Identifier ByteString\" , \"opcua.nodeid.bytestring\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_expandednodeid_mask , {\n \"EncodingMask\" , \"opcua.expandednodeid.mask\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_expandednodeid_mask_namespaceuri , {\n \"has namespace uri\" , \"opcua.expandednodeid.has_namespace_uri\" , FT_BOOLEAN , 8 , NULL , NODEID_NAMESPACEURIFLAG , NULL , HFILL }\n }\n , {\n & hf_opcua_expandednodeid_mask_serverindex , {\n \"has server index\" , \"opcua.expandednodeid.has_server_index\" , FT_BOOLEAN , 8 , NULL , NODEID_SERVERINDEXFLAG , NULL , HFILL }\n }\n , {\n & hf_opcua_localizedtext_locale , {\n \"Locale\" , \"opcua.loctext.Locale\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_localizedtext_text , {\n \"Text\" , \"opcua.loctext.Text\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_qualifiedname_id , {\n \"Id\" , \"opcua.qualname.Id\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_qualifiedname_name , {\n \"Name\" , \"opcua.qualname.Name\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_datavalue_mask , {\n \"EncodingMask\" , \"opcua.datavalue.mask\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_datavalue_mask_valueflag , {\n \"has value\" , \"opcua.datavalue.has_value\" , FT_BOOLEAN , 8 , NULL , DATAVALUE_ENCODINGBYTE_VALUE , NULL , HFILL }\n }\n , {\n & hf_opcua_datavalue_mask_statuscodeflag , {\n \"has statuscode\" , \"opcua.datavalue.has_statuscode\" , FT_BOOLEAN , 8 , NULL , DATAVALUE_ENCODINGBYTE_STATUSCODE , NULL , HFILL }\n }\n , {\n & hf_opcua_datavalue_mask_sourcetimestampflag , {\n \"has source timestamp\" , \"opcua.datavalue.has_source_timestamp\" , FT_BOOLEAN , 8 , NULL , DATAVALUE_ENCODINGBYTE_SOURCETIMESTAMP , NULL , HFILL }\n }\n , {\n & hf_opcua_datavalue_mask_servertimestampflag , {\n \"has server timestamp\" , \"opcua.datavalue.has_server_timestamp\" , FT_BOOLEAN , 8 , NULL , DATAVALUE_ENCODINGBYTE_SERVERTIMESTAMP , NULL , HFILL }\n }\n , {\n & hf_opcua_datavalue_mask_sourcepicoseconds , {\n \"has source picoseconds\" , \"opcua.datavalue.has_source_picoseconds\" , FT_BOOLEAN , 8 , NULL , DATAVALUE_ENCODINGBYTE_SOURCEPICOSECONDS , NULL , HFILL }\n }\n , {\n & hf_opcua_datavalue_mask_serverpicoseconds , {\n \"has server picoseconds\" , \"opcua.datavalue.has_server_picoseconds\" , FT_BOOLEAN , 8 , NULL , DATAVALUE_ENCODINGBYTE_SERVERPICOSECONDS , NULL , HFILL }\n }\n , {\n & hf_opcua_variant_encodingmask , {\n \"Variant Type\" , \"opcua.variant.has_value\" , FT_UINT8 , BASE_HEX , VALS ( g_VariantTypes ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_SourceTimestamp , {\n \"SourceTimestamp\" , \"opcua.datavalue.SourceTimestamp\" , FT_ABSOLUTE_TIME , ABSOLUTE_TIME_LOCAL , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_SourcePicoseconds , {\n \"SourcePicoseconds\" , \"opcua.datavalue.SourcePicoseconds\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_ServerTimestamp , {\n \"ServerTimestamp\" , \"opcua.datavalue.ServerTimestamp\" , FT_ABSOLUTE_TIME , ABSOLUTE_TIME_LOCAL , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_ServerPicoseconds , {\n \"ServerPicoseconds\" , \"opcua.datavalue.ServerPicoseconds\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_diag_symbolicid , {\n \"SymbolicId\" , \"opcua.diag.SymbolicId\" , FT_INT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_diag_namespace , {\n \"Namespace\" , \"opcua.diag.Namespace\" , FT_INT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_diag_localizedtext , {\n \"LocalizedText\" , \"opcua.diag.LocalizedText\" , FT_INT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_diag_locale , {\n \"Locale\" , \"opcua.diag.Locale\" , FT_INT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_diag_additionalinfo , {\n \"AdditionalInfo\" , \"opcua.diag.AdditionalInfo\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_diag_innerstatuscode , {\n \"InnerStatusCode\" , \"opcua.diag.InnerStatusCode\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_extobj_mask , {\n \"EncodingMask\" , \"opcua.extobj.mask\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_extobj_mask_binbodyflag , {\n \"has binary body\" , \"opcua.extobj.has_binary_body\" , FT_BOOLEAN , 8 , NULL , EXTOBJ_ENCODINGMASK_BINBODY_FLAG , NULL , HFILL }\n }\n , {\n & hf_opcua_extobj_mask_xmlbodyflag , {\n \"has xml body\" , \"opcua.extobj.has_xml_body\" , FT_BOOLEAN , 8 , NULL , EXTOBJ_ENCODINGMASK_XMLBODY_FLAG , NULL , HFILL }\n }\n , {\n & hf_opcua_ArraySize , {\n \"ArraySize\" , \"opcua.variant.ArraySize\" , FT_INT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_ServerIndex , {\n \"ServerIndex\" , \"opcua.expandednodeid.ServerIndex\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_status_StructureChanged , {\n \"StructureChanged\" , \"opcua.statuscode.structureChanged\" , FT_BOOLEAN , 16 , NULL , STATUSCODE_STRUCTURECHANGED , NULL , HFILL }\n }\n , {\n & hf_opcua_status_SemanticsChanged , {\n \"SemanticsChanged\" , \"opcua.statuscode.semanticsChanged\" , FT_BOOLEAN , 16 , NULL , STATUSCODE_SEMANTICSCHANGED , NULL , HFILL }\n }\n , {\n & hf_opcua_status_InfoBit_Limit_Overflow , {\n \"Overflow\" , \"opcua.statuscode.overflow\" , FT_BOOLEAN , 16 , NULL , STATUSCODE_INFOBIT_OVERFLOW , NULL , HFILL }\n }\n , {\n & hf_opcua_status_InfoBit_Historian_Partial , {\n \"HistorianBit: Partial\" , \"opcua.statuscode.historian.partial\" , FT_BOOLEAN , 16 , NULL , STATUSCODE_INFOBIT_HISTORIAN_PARTIAL , NULL , HFILL }\n }\n , {\n & hf_opcua_status_InfoBit_Historian_ExtraData , {\n \"HistorianBit: ExtraData\" , \"opcua.statuscode.historian.extraData\" , FT_BOOLEAN , 16 , NULL , STATUSCODE_INFOBIT_HISTORIAN_EXTRADATA , NULL , HFILL }\n }\n , {\n & hf_opcua_status_InfoBit_Historian_MultiValue , {\n \"HistorianBit: MultiValue\" , \"opcua.statuscode.historian.multiValue\" , FT_BOOLEAN , 16 , NULL , STATUSCODE_INFOBIT_HISTORIAN_MULTIVALUE , NULL , HFILL }\n }\n , {\n & hf_opcua_status_InfoType , {\n \"InfoType\" , \"opcua.statuscode.infoType\" , FT_UINT16 , BASE_HEX , VALS ( g_infotype ) , 0x0C00 , NULL , HFILL }\n }\n , {\n & hf_opcua_status_Limit , {\n \"Limit\" , \"opcua.statuscode.limit\" , FT_UINT16 , BASE_HEX , VALS ( g_limit ) , 0x0300 , NULL , HFILL }\n }\n , {\n & hf_opcua_status_Historian , {\n \"Historian\" , \"opcua.statuscode.historian\" , FT_UINT16 , BASE_HEX , VALS ( g_historian ) , 0x0003 , NULL , HFILL }\n }\n , {\n & hf_opcua_returnDiag , {\n \"Return Diagnostics\" , \"opcua.returndiag\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_returnDiag_mask_sl_symbolicId , {\n \"ServiceLevel / SymbolicId\" , \"opcua.returndiag.servicelevel.symbolicid\" , FT_BOOLEAN , 16 , NULL , RETURNDIAGNOSTICS_SERVICELEVEL_SYMBOLICID , NULL , HFILL }\n }\n , {\n & hf_opcua_returnDiag_mask_sl_localizedText , {\n \"ServiceLevel / LocalizedText\" , \"opcua.returndiag.servicelevel.localizedtext\" , FT_BOOLEAN , 16 , NULL , RETURNDIAGNOSTICS_SERVICELEVEL_LOCALIZEDTEXT , NULL , HFILL }\n }\n , {\n & hf_opcua_returnDiag_mask_sl_additionalinfo , {\n \"ServiceLevel / AdditionalInfo\" , \"opcua.returndiag.servicelevel.additionalinfo\" , FT_BOOLEAN , 16 , NULL , RETURNDIAGNOSTICS_SERVICELEVEL_ADDITIONALINFO , NULL , HFILL }\n }\n , {\n & hf_opcua_returnDiag_mask_sl_innerstatuscode , {\n \"ServiceLevel / Inner StatusCode\" , \"opcua.returndiag.servicelevel.innerstatuscode\" , FT_BOOLEAN , 16 , NULL , RETURNDIAGNOSTICS_SERVICELEVEL_INNERSTATUSCODE , NULL , HFILL }\n }\n , {\n & hf_opcua_returnDiag_mask_sl_innerdiagnostics , {\n \"ServiceLevel / Inner Diagnostics\" , \"opcua.returndiag.servicelevel.innerdiagnostics\" , FT_BOOLEAN , 16 , NULL , RETURNDIAGNOSTICS_SERVICELEVEL_INNERDIAGNOSTICS , NULL , HFILL }\n }\n , {\n & hf_opcua_returnDiag_mask_ol_symbolicId , {\n \"OperationLevel / SymbolicId\" , \"opcua.returndiag.operationlevel.symbolicid\" , FT_BOOLEAN , 16 , NULL , RETURNDIAGNOSTICS_OPERATIONLEVEL_SYMBOLICID , NULL , HFILL }\n }\n , {\n & hf_opcua_returnDiag_mask_ol_localizedText , {\n \"OperationLevel / LocalizedText\" , \"opcua.returndiag.operationlevel.localizedtext\" , FT_BOOLEAN , 16 , NULL , RETURNDIAGNOSTICS_OPERATIONLEVEL_LOCALIZEDTEXT , NULL , HFILL }\n }\n , {\n & hf_opcua_returnDiag_mask_ol_additionalinfo , {\n \"OperationLevel / AdditionalInfo\" , \"opcua.returndiag.operationlevel.additionalinfo\" , FT_BOOLEAN , 16 , NULL , RETURNDIAGNOSTICS_OPERATIONLEVEL_ADDITIONALINFO , NULL , HFILL }\n }\n , {\n & hf_opcua_returnDiag_mask_ol_innerstatuscode , {\n \"OperationLevel / Inner StatusCode\" , \"opcua.returndiag.operationlevel.innerstatuscode\" , FT_BOOLEAN , 16 , NULL , RETURNDIAGNOSTICS_OPERATIONLEVEL_INNERSTATUSCODE , NULL , HFILL }\n }\n , {\n & hf_opcua_returnDiag_mask_ol_innerdiagnostics , {\n \"OperationLevel / Inner Diagnostics\" , \"opcua.returndiag.operationlevel.innerdiagnostics\" , FT_BOOLEAN , 16 , NULL , RETURNDIAGNOSTICS_OPERATIONLEVEL_INNERDIAGNOSTICS , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeClassMask , {\n \"Node Class Mask\" , \"opcua.nodeclassmask\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeClassMask_all , {\n \"Node Class Mask\" , \"opcua.nodeclassmask.all\" , FT_UINT32 , BASE_HEX , VALS ( g_NodeClassMask ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeClassMask_object , {\n \"Object\" , \"opcua.nodeclassmask.object\" , FT_BOOLEAN , 16 , NULL , NODECLASSMASK_OBJECT , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeClassMask_variable , {\n \"Variable\" , \"opcua.nodeclassmask.variable\" , FT_BOOLEAN , 16 , NULL , NODECLASSMASK_VARIABLE , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeClassMask_method , {\n \"Method\" , \"opcua.nodeclassmask.method\" , FT_BOOLEAN , 16 , NULL , NODECLASSMASK_METHOD , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeClassMask_objecttype , {\n \"ObjectType\" , \"opcua.nodeclassmask.objecttype\" , FT_BOOLEAN , 16 , NULL , NODECLASSMASK_OBJECTTYPE , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeClassMask_variabletype , {\n \"VariableType\" , \"opcua.nodeclassmask.variabletype\" , FT_BOOLEAN , 16 , NULL , NODECLASSMASK_VARIABLETYPE , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeClassMask_referencetype , {\n \"ReferenceType\" , \"opcua.nodeclassmask.referencetype\" , FT_BOOLEAN , 16 , NULL , NODECLASSMASK_REFERENCETYPE , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeClassMask_datatype , {\n \"DataType\" , \"opcua.nodeclassmask.datatype\" , FT_BOOLEAN , 16 , NULL , NODECLASSMASK_DATATYPE , NULL , HFILL }\n }\n , {\n & hf_opcua_nodeClassMask_view , {\n \"View\" , \"opcua.nodeclassmask.view\" , FT_BOOLEAN , 16 , NULL , NODECLASSMASK_VIEW , NULL , HFILL }\n }\n , {\n & hf_opcua_resultMask , {\n \"Result Mask\" , \"opcua.resultmask\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_opcua_resultMask_referencetype , {\n \"Reference Type\" , \"opcua.resultmask.referencetype\" , FT_BOOLEAN , 16 , NULL , RESULTMASK_REFERENCETYPE , NULL , HFILL }\n }\n , {\n & hf_opcua_resultMask_isforward , {\n \"Is Forward\" , \"opcua.resultmask.isforward\" , FT_BOOLEAN , 16 , NULL , RESULTMASK_ISFORWARD , NULL , HFILL }\n }\n , {\n & hf_opcua_resultMask_nodeclass , {\n \"Node Class\" , \"opcua.resultmask.nodeclass\" , FT_BOOLEAN , 16 , NULL , RESULTMASK_NODECLASS , NULL , HFILL }\n }\n , {\n & hf_opcua_resultMask_browsename , {\n \"Browse Name\" , \"opcua.resultmask.browsename\" , FT_BOOLEAN , 16 , NULL , RESULTMASK_BROWSENAME , NULL , HFILL }\n }\n , {\n & hf_opcua_resultMask_displayname , {\n \"Display Name\" , \"opcua.resultmask.displayname\" , FT_BOOLEAN , 16 , NULL , RESULTMASK_DISPLAYNAME , NULL , HFILL }\n }\n , {\n & hf_opcua_resultMask_typedefinition , {\n \"Type Definiton\" , \"opcua.resultmask.typedefinition\" , FT_BOOLEAN , 16 , NULL , RESULTMASK_TYPEDEFINITION , NULL , HFILL }\n }\n , {\n & hf_opcua_resultMask_all , {\n \"Result Mask\" , \"opcua.resultmask.all\" , FT_UINT32 , BASE_HEX , VALS ( g_ResultMask ) , 0x0 , NULL , HFILL }\n }\n , }\n ;\n static ei_register_info ei [ ] = {\n {\n & ei_array_length , {\n \"opcua.array.length\" , PI_UNDECODED , PI_ERROR , \"Max array length exceeded\" , EXPFILL }\n }\n , }\n ;\n proto_register_field_array ( proto , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n expert_proto = expert_register_protocol ( proto ) ;\n expert_register_field_array ( expert_proto , ei , array_length ( ei ) ) ;\n }", "hash": 1208165234047591297, "project": "debian", "size": 357, "target": 1, "idx": 20732}
{"code": "void parseVariant ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo , gint * pOffset , const char * szFieldName ) {\n proto_item * ti ;\n proto_tree * subtree = proto_tree_add_subtree_format ( tree , tvb , * pOffset , - 1 , ett_opcua_variant , & ti , \"%s: Variant\" , szFieldName ) ;\n gint iOffset = * pOffset ;\n guint8 EncodingMask ;\n gint32 ArrayDimensions = 0 ;\n EncodingMask = tvb_get_guint8 ( tvb , iOffset ) ;\n proto_tree_add_item ( subtree , hf_opcua_variant_encodingmask , tvb , iOffset , 1 , ENC_LITTLE_ENDIAN ) ;\n iOffset ++ ;\n if ( EncodingMask & VARIANT_ARRAYMASK ) {\n switch ( EncodingMask & 0x3f ) {\n case OpcUaType_Null : break ;\n case OpcUaType_Boolean : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Boolean\" , \"Boolean\" , hf_opcua_Boolean , parseBoolean , ett_opcua_array_Boolean ) ;\n break ;\n case OpcUaType_SByte : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"SByte\" , \"SByte\" , hf_opcua_SByte , parseSByte , ett_opcua_array_SByte ) ;\n break ;\n case OpcUaType_Byte : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Byte\" , \"Byte\" , hf_opcua_Byte , parseByte , ett_opcua_array_Byte ) ;\n break ;\n case OpcUaType_Int16 : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Int16\" , \"Int16\" , hf_opcua_Int16 , parseInt16 , ett_opcua_array_Int16 ) ;\n break ;\n case OpcUaType_UInt16 : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"UInt16\" , \"UInt16\" , hf_opcua_UInt16 , parseUInt16 , ett_opcua_array_UInt16 ) ;\n break ;\n case OpcUaType_Int32 : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Int32\" , \"Int32\" , hf_opcua_Int32 , parseInt32 , ett_opcua_array_Int32 ) ;\n break ;\n case OpcUaType_UInt32 : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"UInt32\" , \"UInt32\" , hf_opcua_UInt32 , parseUInt32 , ett_opcua_array_UInt32 ) ;\n break ;\n case OpcUaType_Int64 : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Int64\" , \"Int64\" , hf_opcua_Int64 , parseInt64 , ett_opcua_array_Int64 ) ;\n break ;\n case OpcUaType_UInt64 : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"UInt64\" , \"UInt64\" , hf_opcua_UInt64 , parseUInt64 , ett_opcua_array_UInt64 ) ;\n break ;\n case OpcUaType_Float : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Float\" , \"Float\" , hf_opcua_Float , parseFloat , ett_opcua_array_Float ) ;\n break ;\n case OpcUaType_Double : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Double\" , \"Double\" , hf_opcua_Double , parseDouble , ett_opcua_array_Double ) ;\n break ;\n case OpcUaType_String : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"String\" , \"String\" , hf_opcua_String , parseString , ett_opcua_array_String ) ;\n break ;\n case OpcUaType_DateTime : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"DateTime\" , \"DateTime\" , hf_opcua_DateTime , parseDateTime , ett_opcua_array_DateTime ) ;\n break ;\n case OpcUaType_Guid : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"Guid\" , \"Guid\" , hf_opcua_Guid , parseGuid , ett_opcua_array_Guid ) ;\n break ;\n case OpcUaType_ByteString : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"ByteString\" , \"ByteString\" , hf_opcua_ByteString , parseByteString , ett_opcua_array_ByteString ) ;\n break ;\n case OpcUaType_XmlElement : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"XmlElement\" , \"XmlElement\" , hf_opcua_XmlElement , parseXmlElement , ett_opcua_array_XmlElement ) ;\n break ;\n case OpcUaType_NodeId : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"NodeId\" , \"NodeId\" , parseNodeId , ett_opcua_array_NodeId ) ;\n break ;\n case OpcUaType_ExpandedNodeId : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"ExpandedNodeId\" , \"ExpandedNodeId\" , parseExpandedNodeId , ett_opcua_array_ExpandedNodeId ) ;\n break ;\n case OpcUaType_StatusCode : parseArraySimple ( subtree , tvb , pinfo , & iOffset , \"StatusCode\" , \"StatusCode\" , hf_opcua_StatusCode , parseStatusCode , ett_opcua_array_StatusCode ) ;\n break ;\n case OpcUaType_DiagnosticInfo : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"DiagnosticInfo\" , \"DiagnosticInfo\" , parseDiagnosticInfo , ett_opcua_array_DiagnosticInfo ) ;\n break ;\n case OpcUaType_QualifiedName : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"QualifiedName\" , \"QualifiedName\" , parseQualifiedName , ett_opcua_array_QualifiedName ) ;\n break ;\n case OpcUaType_LocalizedText : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"LocalizedText\" , \"LocalizedText\" , parseLocalizedText , ett_opcua_array_LocalizedText ) ;\n break ;\n case OpcUaType_ExtensionObject : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"ExtensionObject\" , \"ExtensionObject\" , parseExtensionObject , ett_opcua_array_ExtensionObject ) ;\n break ;\n case OpcUaType_DataValue : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"DataValue\" , \"DataValue\" , parseDataValue , ett_opcua_array_DataValue ) ;\n break ;\n case OpcUaType_Variant : parseArrayComplex ( subtree , tvb , pinfo , & iOffset , \"Variant\" , \"Variant\" , parseVariant , ett_opcua_array_Variant ) ;\n break ;\n }\n if ( EncodingMask & VARIANT_ARRAYDIMENSIONS ) {\n proto_item * ti_2 ;\n proto_tree * subtree_2 = proto_tree_add_subtree ( subtree , tvb , iOffset , - 1 , ett_opcua_variant_arraydims , & ti_2 , \"ArrayDimensions\" ) ;\n int i ;\n ArrayDimensions = tvb_get_letohl ( tvb , iOffset ) ;\n proto_tree_add_item ( subtree_2 , hf_opcua_ArraySize , tvb , iOffset , 4 , ENC_LITTLE_ENDIAN ) ;\n if ( ArrayDimensions > MAX_ARRAY_LEN ) {\n proto_tree_add_expert_format ( subtree_2 , pinfo , & ei_array_length , tvb , iOffset , 4 , \"ArrayDimensions length %d too large to process\" , ArrayDimensions ) ;\n return ;\n }\n iOffset += 4 ;\n for ( i = 0 ;\n i < ArrayDimensions ;\n i ++ ) {\n parseInt32 ( subtree_2 , tvb , pinfo , & iOffset , hf_opcua_Int32 ) ;\n }\n proto_item_set_end ( ti_2 , tvb , iOffset ) ;\n }\n }\n else {\n switch ( EncodingMask & 0x3f ) {\n case OpcUaType_Null : break ;\n case OpcUaType_Boolean : parseBoolean ( subtree , tvb , pinfo , & iOffset , hf_opcua_Boolean ) ;\n break ;\n case OpcUaType_SByte : parseSByte ( subtree , tvb , pinfo , & iOffset , hf_opcua_SByte ) ;\n break ;\n case OpcUaType_Byte : parseByte ( subtree , tvb , pinfo , & iOffset , hf_opcua_Byte ) ;\n break ;\n case OpcUaType_Int16 : parseInt16 ( subtree , tvb , pinfo , & iOffset , hf_opcua_Int16 ) ;\n break ;\n case OpcUaType_UInt16 : parseUInt16 ( subtree , tvb , pinfo , & iOffset , hf_opcua_UInt16 ) ;\n break ;\n case OpcUaType_Int32 : parseInt32 ( subtree , tvb , pinfo , & iOffset , hf_opcua_Int32 ) ;\n break ;\n case OpcUaType_UInt32 : parseUInt32 ( subtree , tvb , pinfo , & iOffset , hf_opcua_UInt32 ) ;\n break ;\n case OpcUaType_Int64 : parseInt64 ( subtree , tvb , pinfo , & iOffset , hf_opcua_Int64 ) ;\n break ;\n case OpcUaType_UInt64 : parseUInt64 ( subtree , tvb , pinfo , & iOffset , hf_opcua_UInt64 ) ;\n break ;\n case OpcUaType_Float : parseFloat ( subtree , tvb , pinfo , & iOffset , hf_opcua_Float ) ;\n break ;\n case OpcUaType_Double : parseDouble ( subtree , tvb , pinfo , & iOffset , hf_opcua_Double ) ;\n break ;\n case OpcUaType_String : parseString ( subtree , tvb , pinfo , & iOffset , hf_opcua_String ) ;\n break ;\n case OpcUaType_DateTime : parseDateTime ( subtree , tvb , pinfo , & iOffset , hf_opcua_DateTime ) ;\n break ;\n case OpcUaType_Guid : parseGuid ( subtree , tvb , pinfo , & iOffset , hf_opcua_Guid ) ;\n break ;\n case OpcUaType_ByteString : parseByteString ( subtree , tvb , pinfo , & iOffset , hf_opcua_ByteString ) ;\n break ;\n case OpcUaType_XmlElement : parseXmlElement ( subtree , tvb , pinfo , & iOffset , hf_opcua_XmlElement ) ;\n break ;\n case OpcUaType_NodeId : parseNodeId ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n case OpcUaType_ExpandedNodeId : parseExpandedNodeId ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n case OpcUaType_StatusCode : parseStatusCode ( subtree , tvb , pinfo , & iOffset , hf_opcua_StatusCode ) ;\n break ;\n case OpcUaType_DiagnosticInfo : parseDiagnosticInfo ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n case OpcUaType_QualifiedName : parseQualifiedName ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n case OpcUaType_LocalizedText : parseLocalizedText ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n case OpcUaType_ExtensionObject : parseExtensionObject ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n case OpcUaType_DataValue : parseDataValue ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n case OpcUaType_Variant : parseVariant ( subtree , tvb , pinfo , & iOffset , \"Value\" ) ;\n break ;\n }\n }\n proto_item_set_end ( ti , tvb , iOffset ) ;\n * pOffset = iOffset ;\n }", "hash": 1208165234047591297, "project": "debian", "size": 140, "target": 1, "idx": 20735}
{"code": "int udpv6_queue_rcv_skb ( struct sock * sk , struct sk_buff * skb ) {\n struct udp_sock * up = udp_sk ( sk ) ;\n int rc ;\n int is_udplite = IS_UDPLITE ( sk ) ;\n if ( ! xfrm6_policy_check ( sk , XFRM_POLICY_IN , skb ) ) goto drop ;\n if ( ( is_udplite & UDPLITE_RECV_CC ) && UDP_SKB_CB ( skb ) -> partial_cov ) {\n if ( up -> pcrlen == 0 ) {\n LIMIT_NETDEBUG ( KERN_WARNING \"UDPLITE6: partial coverage\" \" %d while full coverage %d requested\\n\" , UDP_SKB_CB ( skb ) -> cscov , skb -> len ) ;\n goto drop ;\n }\n if ( UDP_SKB_CB ( skb ) -> cscov < up -> pcrlen ) {\n LIMIT_NETDEBUG ( KERN_WARNING \"UDPLITE6: coverage %d \" \"too small, need min %d\\n\" , UDP_SKB_CB ( skb ) -> cscov , up -> pcrlen ) ;\n goto drop ;\n }\n }\n if ( sk -> sk_filter ) {\n if ( udp_lib_checksum_complete ( skb ) ) goto drop ;\n }\n if ( ( rc = sock_queue_rcv_skb ( sk , skb ) ) < 0 ) {\n if ( rc == - ENOMEM ) UDP6_INC_STATS_BH ( sock_net ( sk ) , UDP_MIB_RCVBUFERRORS , is_udplite ) ;\n goto drop_no_sk_drops_inc ;\n }\n return 0 ;\n drop : atomic_inc ( & sk -> sk_drops ) ;\n drop_no_sk_drops_inc : UDP6_INC_STATS_BH ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ;\n kfree_skb ( skb ) ;\n return - 1 ;\n }", "hash": 7889142355347191490, "project": "debian", "size": 28, "target": 1, "idx": 20775}
{"code": "static int jpc_enc_encodemainbody ( jpc_enc_t * enc ) {\n int tileno ;\n int tilex ;\n int tiley ;\n int i ;\n jpc_sot_t * sot ;\n jpc_enc_tcmpt_t * comp ;\n jpc_enc_tcmpt_t * endcomps ;\n jpc_enc_band_t * band ;\n jpc_enc_band_t * endbands ;\n jpc_enc_rlvl_t * lvl ;\n int rlvlno ;\n jpc_qcc_t * qcc ;\n jpc_cod_t * cod ;\n int adjust ;\n int j ;\n int absbandno ;\n long numbytes ;\n long tilehdrlen ;\n long tilelen ;\n jpc_enc_tile_t * tile ;\n jpc_enc_cp_t * cp ;\n double rho ;\n int lyrno ;\n int cmptno ;\n int samestepsizes ;\n jpc_enc_ccp_t * ccps ;\n jpc_enc_tccp_t * tccp ;\n int bandno ;\n uint_fast32_t x ;\n uint_fast32_t y ;\n int mingbits ;\n int actualnumbps ;\n jpc_fix_t mxmag ;\n jpc_fix_t mag ;\n int numgbits ;\n cp = enc -> cp ;\n numbytes = 0 ;\n for ( tileno = 0 ;\n tileno < JAS_CAST ( int , cp -> numtiles ) ;\n ++ tileno ) {\n tilex = tileno % cp -> numhtiles ;\n tiley = tileno / cp -> numhtiles ;\n if ( ! ( enc -> curtile = jpc_enc_tile_create ( enc -> cp , enc -> image , tileno ) ) ) {\n abort ( ) ;\n }\n tile = enc -> curtile ;\n if ( jas_getdbglevel ( ) >= 10 ) {\n jpc_enc_dump ( enc ) ;\n }\n endcomps = & tile -> tcmpts [ tile -> numtcmpts ] ;\n for ( cmptno = 0 , comp = tile -> tcmpts ;\n cmptno < tile -> numtcmpts ;\n ++ cmptno , ++ comp ) {\n if ( ! cp -> ccps [ cmptno ] . sgnd ) {\n adjust = 1 << ( cp -> ccps [ cmptno ] . prec - 1 ) ;\n for ( i = 0 ;\n i < jas_matrix_numrows ( comp -> data ) ;\n ++ i ) {\n for ( j = 0 ;\n j < jas_matrix_numcols ( comp -> data ) ;\n ++ j ) {\n * jas_matrix_getref ( comp -> data , i , j ) -= adjust ;\n }\n }\n }\n }\n if ( ! tile -> intmode ) {\n endcomps = & tile -> tcmpts [ tile -> numtcmpts ] ;\n for ( comp = tile -> tcmpts ;\n comp != endcomps ;\n ++ comp ) {\n jas_matrix_asl ( comp -> data , JPC_FIX_FRACBITS ) ;\n }\n }\n switch ( tile -> mctid ) {\n case JPC_MCT_RCT : assert ( jas_image_numcmpts ( enc -> image ) == 3 ) ;\n jpc_rct ( tile -> tcmpts [ 0 ] . data , tile -> tcmpts [ 1 ] . data , tile -> tcmpts [ 2 ] . data ) ;\n break ;\n case JPC_MCT_ICT : assert ( jas_image_numcmpts ( enc -> image ) == 3 ) ;\n jpc_ict ( tile -> tcmpts [ 0 ] . data , tile -> tcmpts [ 1 ] . data , tile -> tcmpts [ 2 ] . data ) ;\n break ;\n default : break ;\n }\n for ( i = 0 ;\n i < jas_image_numcmpts ( enc -> image ) ;\n ++ i ) {\n comp = & tile -> tcmpts [ i ] ;\n jpc_tsfb_analyze ( comp -> tsfb , comp -> data ) ;\n }\n endcomps = & tile -> tcmpts [ tile -> numtcmpts ] ;\n for ( cmptno = 0 , comp = tile -> tcmpts ;\n comp != endcomps ;\n ++ cmptno , ++ comp ) {\n mingbits = 0 ;\n absbandno = 0 ;\n memset ( comp -> stepsizes , 0 , sizeof ( comp -> stepsizes ) ) ;\n for ( rlvlno = 0 , lvl = comp -> rlvls ;\n rlvlno < comp -> numrlvls ;\n ++ rlvlno , ++ lvl ) {\n if ( ! lvl -> bands ) {\n absbandno += rlvlno ? 3 : 1 ;\n continue ;\n }\n endbands = & lvl -> bands [ lvl -> numbands ] ;\n for ( band = lvl -> bands ;\n band != endbands ;\n ++ band ) {\n if ( ! band -> data ) {\n ++ absbandno ;\n continue ;\n }\n actualnumbps = 0 ;\n mxmag = 0 ;\n for ( y = 0 ;\n y < JAS_CAST ( uint_fast32_t , jas_matrix_numrows ( band -> data ) ) ;\n ++ y ) {\n for ( x = 0 ;\n x < JAS_CAST ( uint_fast32_t , jas_matrix_numcols ( band -> data ) ) ;\n ++ x ) {\n mag = JAS_ABS ( jas_matrix_get ( band -> data , y , x ) ) ;\n if ( mag > mxmag ) {\n mxmag = mag ;\n }\n }\n }\n if ( tile -> intmode ) {\n actualnumbps = jpc_firstone ( mxmag ) + 1 ;\n }\n else {\n actualnumbps = jpc_firstone ( mxmag ) + 1 - JPC_FIX_FRACBITS ;\n }\n numgbits = actualnumbps - ( cp -> ccps [ cmptno ] . prec - 1 + band -> analgain ) ;\n # if 0 jas_eprintf ( \"%d %d mag=%d actual=%d numgbits=%d\\n\" , cp -> ccps [ cmptno ] . prec , band -> analgain , mxmag , actualnumbps , numgbits ) ;\n # endif if ( numgbits > mingbits ) {\n mingbits = numgbits ;\n }\n if ( ! tile -> intmode ) {\n band -> absstepsize = jpc_fix_div ( jpc_inttofix ( 1 << ( band -> analgain + 1 ) ) , band -> synweight ) ;\n }\n else {\n band -> absstepsize = jpc_inttofix ( 1 ) ;\n }\n band -> stepsize = jpc_abstorelstepsize ( band -> absstepsize , cp -> ccps [ cmptno ] . prec + band -> analgain ) ;\n band -> numbps = cp -> tccp . numgbits + JPC_QCX_GETEXPN ( band -> stepsize ) - 1 ;\n if ( ( ! tile -> intmode ) && band -> data ) {\n jpc_quantize ( band -> data , band -> absstepsize ) ;\n }\n comp -> stepsizes [ absbandno ] = band -> stepsize ;\n ++ absbandno ;\n }\n }\n assert ( JPC_FIX_FRACBITS >= JPC_NUMEXTRABITS ) ;\n if ( ! tile -> intmode ) {\n jas_matrix_divpow2 ( comp -> data , JPC_FIX_FRACBITS - JPC_NUMEXTRABITS ) ;\n }\n else {\n jas_matrix_asl ( comp -> data , JPC_NUMEXTRABITS ) ;\n }\n # if 0 jas_eprintf ( \"mingbits %d\\n\" , mingbits ) ;\n # endif if ( mingbits > cp -> tccp . numgbits ) {\n jas_eprintf ( \"error: too few guard bits (need at least %d)\\n\" , mingbits ) ;\n return - 1 ;\n }\n }\n if ( ! ( enc -> tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) {\n jas_eprintf ( \"cannot open tmp file\\n\" ) ;\n return - 1 ;\n }\n if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_SOT ) ) ) {\n return - 1 ;\n }\n sot = & enc -> mrk -> parms . sot ;\n sot -> len = 0 ;\n sot -> tileno = tileno ;\n sot -> partno = 0 ;\n sot -> numparts = 1 ;\n if ( jpc_putms ( enc -> tmpstream , enc -> cstate , enc -> mrk ) ) {\n jas_eprintf ( \"cannot write SOT marker\\n\" ) ;\n return - 1 ;\n }\n jpc_ms_destroy ( enc -> mrk ) ;\n enc -> mrk = 0 ;\n tccp = & cp -> tccp ;\n for ( cmptno = 0 ;\n cmptno < JAS_CAST ( int , cp -> numcmpts ) ;\n ++ cmptno ) {\n comp = & tile -> tcmpts [ cmptno ] ;\n if ( comp -> numrlvls != tccp -> maxrlvls ) {\n if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_COD ) ) ) {\n return - 1 ;\n }\n comp = & tile -> tcmpts [ 0 ] ;\n cod = & enc -> mrk -> parms . cod ;\n cod -> compparms . csty = 0 ;\n cod -> compparms . numdlvls = comp -> numrlvls - 1 ;\n cod -> prg = tile -> prg ;\n cod -> numlyrs = tile -> numlyrs ;\n cod -> compparms . cblkwidthval = JPC_COX_CBLKSIZEEXPN ( comp -> cblkwidthexpn ) ;\n cod -> compparms . cblkheightval = JPC_COX_CBLKSIZEEXPN ( comp -> cblkheightexpn ) ;\n cod -> compparms . cblksty = comp -> cblksty ;\n cod -> compparms . qmfbid = comp -> qmfbid ;\n cod -> mctrans = ( tile -> mctid != JPC_MCT_NONE ) ;\n for ( i = 0 ;\n i < comp -> numrlvls ;\n ++ i ) {\n cod -> compparms . rlvls [ i ] . parwidthval = comp -> rlvls [ i ] . prcwidthexpn ;\n cod -> compparms . rlvls [ i ] . parheightval = comp -> rlvls [ i ] . prcheightexpn ;\n }\n if ( jpc_putms ( enc -> tmpstream , enc -> cstate , enc -> mrk ) ) {\n return - 1 ;\n }\n jpc_ms_destroy ( enc -> mrk ) ;\n enc -> mrk = 0 ;\n }\n }\n for ( cmptno = 0 , comp = tile -> tcmpts ;\n cmptno < JAS_CAST ( int , cp -> numcmpts ) ;\n ++ cmptno , ++ comp ) {\n ccps = & cp -> ccps [ cmptno ] ;\n if ( JAS_CAST ( int , ccps -> numstepsizes ) == comp -> numstepsizes ) {\n samestepsizes = 1 ;\n for ( bandno = 0 ;\n bandno < JAS_CAST ( int , ccps -> numstepsizes ) ;\n ++ bandno ) {\n if ( ccps -> stepsizes [ bandno ] != comp -> stepsizes [ bandno ] ) {\n samestepsizes = 0 ;\n break ;\n }\n }\n }\n else {\n samestepsizes = 0 ;\n }\n if ( ! samestepsizes ) {\n if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_QCC ) ) ) {\n return - 1 ;\n }\n qcc = & enc -> mrk -> parms . qcc ;\n qcc -> compno = cmptno ;\n qcc -> compparms . numguard = cp -> tccp . numgbits ;\n qcc -> compparms . qntsty = ( comp -> qmfbid == JPC_COX_INS ) ? JPC_QCX_SEQNT : JPC_QCX_NOQNT ;\n qcc -> compparms . numstepsizes = comp -> numstepsizes ;\n qcc -> compparms . stepsizes = comp -> stepsizes ;\n if ( jpc_putms ( enc -> tmpstream , enc -> cstate , enc -> mrk ) ) {\n return - 1 ;\n }\n qcc -> compparms . stepsizes = 0 ;\n jpc_ms_destroy ( enc -> mrk ) ;\n enc -> mrk = 0 ;\n }\n }\n if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_SOD ) ) ) {\n return - 1 ;\n }\n if ( jpc_putms ( enc -> tmpstream , enc -> cstate , enc -> mrk ) ) {\n jas_eprintf ( \"cannot write SOD marker\\n\" ) ;\n return - 1 ;\n }\n jpc_ms_destroy ( enc -> mrk ) ;\n enc -> mrk = 0 ;\n tilehdrlen = jas_stream_getrwcount ( enc -> tmpstream ) ;\n assert ( tilehdrlen >= 0 ) ;\n if ( jpc_enc_enccblks ( enc ) ) {\n abort ( ) ;\n return - 1 ;\n }\n cp = enc -> cp ;\n rho = ( double ) ( tile -> brx - tile -> tlx ) * ( tile -> bry - tile -> tly ) / ( ( cp -> refgrdwidth - cp -> imgareatlx ) * ( cp -> refgrdheight - cp -> imgareatly ) ) ;\n tile -> rawsize = cp -> rawsize * rho ;\n for ( lyrno = 0 ;\n lyrno < tile -> numlyrs - 1 ;\n ++ lyrno ) {\n tile -> lyrsizes [ lyrno ] = tile -> rawsize * jpc_fixtodbl ( cp -> tcp . ilyrrates [ lyrno ] ) ;\n }\n # if ! defined ( __clang__ ) tile -> lyrsizes [ tile -> numlyrs - 1 ] = ( cp -> totalsize != UINT_FAST32_MAX ) ? ( rho * enc -> mainbodysize ) : UINT_FAST32_MAX ;\n # else if ( cp -> totalsize != UINT_FAST32_MAX ) {\n tile -> lyrsizes [ tile -> numlyrs - 1 ] = ( rho * enc -> mainbodysize ) ;\n }\n else {\n tile -> lyrsizes [ tile -> numlyrs - 1 ] = UINT_FAST32_MAX ;\n }\n # endif for ( lyrno = 0 ;\n lyrno < tile -> numlyrs ;\n ++ lyrno ) {\n if ( tile -> lyrsizes [ lyrno ] != UINT_FAST32_MAX ) {\n if ( JAS_CAST ( uint_fast32_t , tilehdrlen ) <= tile -> lyrsizes [ lyrno ] ) {\n tile -> lyrsizes [ lyrno ] -= tilehdrlen ;\n }\n else {\n tile -> lyrsizes [ lyrno ] = 0 ;\n }\n }\n }\n if ( rateallocate ( enc , tile -> numlyrs , tile -> lyrsizes ) ) {\n return - 1 ;\n }\n # if 0 jas_eprintf ( \"ENCODE TILE DATA\\n\" ) ;\n # endif if ( jpc_enc_encodetiledata ( enc ) ) {\n jas_eprintf ( \"dotile failed\\n\" ) ;\n return - 1 ;\n }\n tilelen = jas_stream_tell ( enc -> tmpstream ) ;\n if ( jas_stream_seek ( enc -> tmpstream , 6 , SEEK_SET ) < 0 ) {\n return - 1 ;\n }\n jpc_putuint32 ( enc -> tmpstream , tilelen ) ;\n if ( jas_stream_seek ( enc -> tmpstream , 0 , SEEK_SET ) < 0 ) {\n return - 1 ;\n }\n if ( jpc_putdata ( enc -> out , enc -> tmpstream , - 1 ) ) {\n return - 1 ;\n }\n enc -> len += tilelen ;\n jas_stream_close ( enc -> tmpstream ) ;\n enc -> tmpstream = 0 ;\n jpc_enc_tile_destroy ( enc -> curtile ) ;\n enc -> curtile = 0 ;\n }\n return 0 ;\n }", "hash": -8721757784652752372, "project": "debian", "size": 321, "target": 1, "idx": 20782}
{"code": "static int cinepak_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int ret = 0 , buf_size = avpkt -> size ;\n CinepakContext * s = avctx -> priv_data ;\n s -> data = buf ;\n s -> size = buf_size ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( s -> palette_video ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n s -> frame . palette_has_changed = 1 ;\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n }\n }\n cinepak_decode ( s ) ;\n if ( s -> palette_video ) memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }", "hash": 6105314356608381376, "project": "debian", "size": 25, "target": 1, "idx": 20795}
{"code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n TargaContext * const s = avctx -> priv_data ;\n AVFrame * picture = data ;\n AVFrame * const p = & s -> picture ;\n uint8_t * dst ;\n int stride ;\n int idlen , compr , y , w , h , bpp , flags , ret ;\n int first_clr , colors , csize ;\n bytestream2_init ( & s -> gb , avpkt -> data , avpkt -> size ) ;\n idlen = bytestream2_get_byte ( & s -> gb ) ;\n bytestream2_skip ( & s -> gb , 1 ) ;\n compr = bytestream2_get_byte ( & s -> gb ) ;\n first_clr = bytestream2_get_le16 ( & s -> gb ) ;\n colors = bytestream2_get_le16 ( & s -> gb ) ;\n csize = bytestream2_get_byte ( & s -> gb ) ;\n bytestream2_skip ( & s -> gb , 4 ) ;\n w = bytestream2_get_le16 ( & s -> gb ) ;\n h = bytestream2_get_le16 ( & s -> gb ) ;\n bpp = bytestream2_get_byte ( & s -> gb ) ;\n flags = bytestream2_get_byte ( & s -> gb ) ;\n bytestream2_skip ( & s -> gb , idlen ) ;\n switch ( bpp ) {\n case 8 : avctx -> pix_fmt = ( ( compr & ( ~ TGA_RLE ) ) == TGA_BW ) ? AV_PIX_FMT_GRAY8 : AV_PIX_FMT_PAL8 ;\n break ;\n case 15 : avctx -> pix_fmt = AV_PIX_FMT_RGB555LE ;\n break ;\n case 16 : avctx -> pix_fmt = AV_PIX_FMT_RGB555LE ;\n break ;\n case 24 : avctx -> pix_fmt = AV_PIX_FMT_BGR24 ;\n break ;\n case 32 : avctx -> pix_fmt = AV_PIX_FMT_BGRA ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Bit depth %i is not supported\\n\" , bpp ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( s -> picture . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> picture ) ;\n if ( ( ret = av_image_check_size ( w , h , 0 , avctx ) ) < 0 ) return ret ;\n if ( w != avctx -> width || h != avctx -> height ) avcodec_set_dimensions ( avctx , w , h ) ;\n if ( ( ret = ff_get_buffer ( avctx , p ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( flags & 0x20 ) {\n dst = p -> data [ 0 ] ;\n stride = p -> linesize [ 0 ] ;\n }\n else {\n dst = p -> data [ 0 ] + p -> linesize [ 0 ] * ( h - 1 ) ;\n stride = - p -> linesize [ 0 ] ;\n }\n if ( colors ) {\n int pal_size , pal_sample_size ;\n if ( ( colors + first_clr ) > 256 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Incorrect palette: %i colors with offset %i\\n\" , colors , first_clr ) ;\n return AVERROR_INVALIDDATA ;\n }\n switch ( csize ) {\n case 24 : pal_sample_size = 3 ;\n break ;\n case 16 : case 15 : pal_sample_size = 2 ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Palette entry size %i bits is not supported\\n\" , csize ) ;\n return AVERROR_INVALIDDATA ;\n }\n pal_size = colors * pal_sample_size ;\n if ( avctx -> pix_fmt != AV_PIX_FMT_PAL8 ) bytestream2_skip ( & s -> gb , pal_size ) ;\n else {\n int t ;\n uint32_t * pal = ( ( uint32_t * ) p -> data [ 1 ] ) + first_clr ;\n if ( bytestream2_get_bytes_left ( & s -> gb ) < pal_size ) {\n av_log ( avctx , AV_LOG_ERROR , \"Not enough data to read palette\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n switch ( pal_sample_size ) {\n case 3 : for ( t = 0 ;\n t < colors ;\n t ++ ) * pal ++ = bytestream2_get_le24u ( & s -> gb ) ;\n break ;\n case 2 : for ( t = 0 ;\n t < colors ;\n t ++ ) {\n uint32_t v = bytestream2_get_le16u ( & s -> gb ) ;\n v = ( ( v & 0x7C00 ) << 9 ) | ( ( v & 0x03E0 ) << 6 ) | ( ( v & 0x001F ) << 3 ) ;\n v |= ( v & 0xE0E0E0U ) >> 5 ;\n * pal ++ = v ;\n }\n break ;\n }\n p -> palette_has_changed = 1 ;\n }\n }\n if ( ( compr & ( ~ TGA_RLE ) ) == TGA_NODATA ) {\n memset ( p -> data [ 0 ] , 0 , p -> linesize [ 0 ] * h ) ;\n }\n else {\n if ( compr & TGA_RLE ) {\n int res = targa_decode_rle ( avctx , s , dst , w , h , stride , bpp ) ;\n if ( res < 0 ) return res ;\n }\n else {\n size_t img_size = w * ( ( bpp + 1 ) >> 3 ) ;\n if ( bytestream2_get_bytes_left ( & s -> gb ) < img_size * h ) {\n av_log ( avctx , AV_LOG_ERROR , \"Not enough data available for image\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( y = 0 ;\n y < h ;\n y ++ ) {\n bytestream2_get_bufferu ( & s -> gb , dst , img_size ) ;\n dst += stride ;\n }\n }\n }\n * picture = s -> picture ;\n * got_frame = 1 ;\n return avpkt -> size ;\n }", "hash": 7690587584364497392, "project": "debian", "size": 117, "target": 1, "idx": 20798}
{"code": "static int adx_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n int buf_size = avpkt -> size ;\n ADXContext * c = avctx -> priv_data ;\n int16_t * * samples ;\n int samples_offset ;\n const uint8_t * buf = avpkt -> data ;\n int num_blocks , ch , ret ;\n if ( c -> eof ) {\n * got_frame_ptr = 0 ;\n return buf_size ;\n }\n if ( ! c -> header_parsed && buf_size >= 2 && AV_RB16 ( buf ) == 0x8000 ) {\n int header_size ;\n if ( ( ret = avpriv_adx_decode_header ( avctx , buf , buf_size , & header_size , c -> coeff ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"error parsing ADX header\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> channels = avctx -> channels ;\n c -> header_parsed = 1 ;\n if ( buf_size < header_size ) return AVERROR_INVALIDDATA ;\n buf += header_size ;\n buf_size -= header_size ;\n }\n if ( ! c -> header_parsed ) return AVERROR_INVALIDDATA ;\n num_blocks = buf_size / ( BLOCK_SIZE * c -> channels ) ;\n if ( ! num_blocks || buf_size % ( BLOCK_SIZE * avctx -> channels ) ) {\n if ( buf_size >= 4 && ( AV_RB16 ( buf ) & 0x8000 ) ) {\n c -> eof = 1 ;\n * got_frame_ptr = 0 ;\n return avpkt -> size ;\n }\n return AVERROR_INVALIDDATA ;\n }\n frame -> nb_samples = num_blocks * BLOCK_SAMPLES ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n samples = ( int16_t * * ) frame -> extended_data ;\n samples_offset = 0 ;\n while ( num_blocks -- ) {\n for ( ch = 0 ;\n ch < c -> channels ;\n ch ++ ) {\n if ( adx_decode ( c , samples [ ch ] , samples_offset , buf , ch ) ) {\n c -> eof = 1 ;\n buf = avpkt -> data + avpkt -> size ;\n break ;\n }\n buf_size -= BLOCK_SIZE ;\n buf += BLOCK_SIZE ;\n }\n samples_offset += BLOCK_SAMPLES ;\n }\n * got_frame_ptr = 1 ;\n return buf - avpkt -> data ;\n }", "hash": -5220436875389458065, "project": "debian", "size": 58, "target": 1, "idx": 20800}
{"code": "static int mpc7_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size ;\n MPCContext * c = avctx -> priv_data ;\n GetBitContext gb ;\n int i , ch ;\n int mb = - 1 ;\n Band * bands = c -> bands ;\n int off , ret , last_frame , skip ;\n int bits_used , bits_avail ;\n memset ( bands , 0 , sizeof ( * bands ) * ( c -> maxbands + 1 ) ) ;\n buf_size = avpkt -> size & ~ 3 ;\n if ( buf_size <= 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"packet size is too small (%i bytes)\\n\" , avpkt -> size ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( buf_size != avpkt -> size ) {\n av_log ( avctx , AV_LOG_WARNING , \"packet size is not a multiple of 4. \" \"extra bytes at the end will be skipped.\\n\" ) ;\n }\n skip = buf [ 0 ] ;\n last_frame = buf [ 1 ] ;\n buf += 4 ;\n buf_size -= 4 ;\n frame -> nb_samples = last_frame ? c -> lastframelen : MPC_FRAME_SIZE ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n av_fast_padded_malloc ( & c -> bits , & c -> buf_size , buf_size ) ;\n if ( ! c -> bits ) return AVERROR ( ENOMEM ) ;\n c -> dsp . bswap_buf ( ( uint32_t * ) c -> bits , ( const uint32_t * ) buf , buf_size >> 2 ) ;\n init_get_bits ( & gb , c -> bits , buf_size * 8 ) ;\n skip_bits_long ( & gb , skip ) ;\n for ( i = 0 ;\n i <= c -> maxbands ;\n i ++ ) {\n for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) {\n int t = 4 ;\n if ( i ) t = get_vlc2 ( & gb , hdr_vlc . table , MPC7_HDR_BITS , 1 ) - 5 ;\n if ( t == 4 ) bands [ i ] . res [ ch ] = get_bits ( & gb , 4 ) ;\n else bands [ i ] . res [ ch ] = av_clip ( bands [ i - 1 ] . res [ ch ] + t , 0 , 17 ) ;\n }\n if ( bands [ i ] . res [ 0 ] || bands [ i ] . res [ 1 ] ) {\n mb = i ;\n if ( c -> MSS ) bands [ i ] . msf = get_bits1 ( & gb ) ;\n }\n }\n for ( i = 0 ;\n i <= mb ;\n i ++ ) for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) if ( bands [ i ] . res [ ch ] ) bands [ i ] . scfi [ ch ] = get_vlc2 ( & gb , scfi_vlc . table , MPC7_SCFI_BITS , 1 ) ;\n for ( i = 0 ;\n i <= mb ;\n i ++ ) {\n for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) {\n if ( bands [ i ] . res [ ch ] ) {\n bands [ i ] . scf_idx [ ch ] [ 2 ] = c -> oldDSCF [ ch ] [ i ] ;\n bands [ i ] . scf_idx [ ch ] [ 0 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 2 ] ) ;\n switch ( bands [ i ] . scfi [ ch ] ) {\n case 0 : bands [ i ] . scf_idx [ ch ] [ 1 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 0 ] ) ;\n bands [ i ] . scf_idx [ ch ] [ 2 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 1 ] ) ;\n break ;\n case 1 : bands [ i ] . scf_idx [ ch ] [ 1 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 0 ] ) ;\n bands [ i ] . scf_idx [ ch ] [ 2 ] = bands [ i ] . scf_idx [ ch ] [ 1 ] ;\n break ;\n case 2 : bands [ i ] . scf_idx [ ch ] [ 1 ] = bands [ i ] . scf_idx [ ch ] [ 0 ] ;\n bands [ i ] . scf_idx [ ch ] [ 2 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 1 ] ) ;\n break ;\n case 3 : bands [ i ] . scf_idx [ ch ] [ 2 ] = bands [ i ] . scf_idx [ ch ] [ 1 ] = bands [ i ] . scf_idx [ ch ] [ 0 ] ;\n break ;\n }\n c -> oldDSCF [ ch ] [ i ] = bands [ i ] . scf_idx [ ch ] [ 2 ] ;\n }\n }\n }\n memset ( c -> Q , 0 , sizeof ( c -> Q ) ) ;\n off = 0 ;\n for ( i = 0 ;\n i < BANDS ;\n i ++ , off += SAMPLES_PER_BAND ) for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) idx_to_quant ( c , & gb , bands [ i ] . res [ ch ] , c -> Q [ ch ] + off ) ;\n ff_mpc_dequantize_and_synth ( c , mb , ( int16_t * * ) frame -> extended_data , 2 ) ;\n bits_used = get_bits_count ( & gb ) ;\n bits_avail = buf_size * 8 ;\n if ( ! last_frame && ( ( bits_avail < bits_used ) || ( bits_used + 32 <= bits_avail ) ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error decoding frame: used %i of %i bits\\n\" , bits_used , bits_avail ) ;\n return - 1 ;\n }\n if ( c -> frames_to_skip ) {\n c -> frames_to_skip -- ;\n * got_frame_ptr = 0 ;\n return avpkt -> size ;\n }\n * got_frame_ptr = 1 ;\n return avpkt -> size ;\n }", "hash": -482717283558482293, "project": "debian", "size": 103, "target": 1, "idx": 20804}
{"code": "static int decode_cabac_field_decoding_flag ( H264Context * h ) {\n const long mbb_xy = h -> mb_xy - 2L * h -> mb_stride ;\n unsigned long ctx = 0 ;\n ctx += h -> mb_field_decoding_flag & ! ! h -> mb_x ;\n ctx += ( h -> cur_pic . f . mb_type [ mbb_xy ] >> 7 ) & ( h -> slice_table [ mbb_xy ] == h -> slice_num ) ;\n return get_cabac_noinline ( & h -> cabac , & ( h -> cabac_state + 70 ) [ ctx ] ) ;\n }", "hash": -4456702502726364053, "project": "debian", "size": 7, "target": 1, "idx": 20829}
{"code": "static int vc1_decode_p_mb_intfi ( VC1Context * v ) {\n MpegEncContext * s = & v -> s ;\n GetBitContext * gb = & s -> gb ;\n int i ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int cbp = 0 ;\n int mqdiff , mquant ;\n int ttmb = v -> ttfrm ;\n int mb_has_coeffs = 1 ;\n int dmv_x , dmv_y ;\n int val ;\n int first_block = 1 ;\n int dst_idx , off ;\n int pred_flag ;\n int block_cbp = 0 , pat , block_tt = 0 ;\n int idx_mbmode = 0 ;\n mquant = v -> pq ;\n idx_mbmode = get_vlc2 ( gb , v -> mbmode_vlc -> table , VC1_IF_MBMODE_VLC_BITS , 2 ) ;\n if ( idx_mbmode <= 1 ) {\n s -> mb_intra = v -> is_intra [ s -> mb_x ] = 1 ;\n s -> current_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 0 ] = 0 ;\n s -> current_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 1 ] = 0 ;\n s -> current_picture . f . mb_type [ mb_pos + v -> mb_off ] = MB_TYPE_INTRA ;\n GET_MQUANT ( ) ;\n s -> current_picture . f . qscale_table [ mb_pos ] = mquant ;\n s -> y_dc_scale = s -> y_dc_scale_table [ mquant ] ;\n s -> c_dc_scale = s -> c_dc_scale_table [ mquant ] ;\n v -> s . ac_pred = v -> acpred_plane [ mb_pos ] = get_bits1 ( gb ) ;\n mb_has_coeffs = idx_mbmode & 1 ;\n if ( mb_has_coeffs ) cbp = 1 + get_vlc2 ( & v -> s . gb , v -> cbpcy_vlc -> table , VC1_ICBPCY_VLC_BITS , 2 ) ;\n dst_idx = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = 1 ;\n dst_idx += i >> 2 ;\n val = ( ( cbp >> ( 5 - i ) ) & 1 ) ;\n v -> a_avail = v -> c_avail = 0 ;\n if ( i == 2 || i == 3 || ! s -> first_slice_line ) v -> a_avail = v -> mb_type [ 0 ] [ s -> block_index [ i ] - s -> block_wrap [ i ] ] ;\n if ( i == 1 || i == 3 || s -> mb_x ) v -> c_avail = v -> mb_type [ 0 ] [ s -> block_index [ i ] - 1 ] ;\n vc1_decode_intra_block ( v , s -> block [ i ] , i , val , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n if ( ( i > 3 ) && ( s -> flags & CODEC_FLAG_GRAY ) ) continue ;\n v -> vc1dsp . vc1_inv_trans_8x8 ( s -> block [ i ] ) ;\n off = ( i & 4 ) ? 0 : ( ( i & 1 ) * 8 + ( i & 2 ) * 4 * s -> linesize ) ;\n off += v -> cur_field_type ? ( ( i & 4 ) ? s -> current_picture_ptr -> f . linesize [ 1 ] : s -> current_picture_ptr -> f . linesize [ 0 ] ) : 0 ;\n s -> dsp . put_signed_pixels_clamped ( s -> block [ i ] , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : s -> linesize ) ;\n }\n }\n else {\n s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n s -> current_picture . f . mb_type [ mb_pos + v -> mb_off ] = MB_TYPE_16x16 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n if ( idx_mbmode <= 5 ) {\n dmv_x = dmv_y = pred_flag = 0 ;\n if ( idx_mbmode & 1 ) {\n get_mvdata_interlaced ( v , & dmv_x , & dmv_y , & pred_flag ) ;\n }\n vc1_pred_mv ( v , 0 , dmv_x , dmv_y , 1 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] , pred_flag , 0 ) ;\n vc1_mc_1mv ( v , 0 ) ;\n mb_has_coeffs = ! ( idx_mbmode & 2 ) ;\n }\n else {\n v -> fourmvbp = get_vlc2 ( gb , v -> fourmvbp_vlc -> table , VC1_4MV_BLOCK_PATTERN_VLC_BITS , 1 ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( i < 4 ) {\n dmv_x = dmv_y = pred_flag = 0 ;\n val = ( ( v -> fourmvbp >> ( 3 - i ) ) & 1 ) ;\n if ( val ) {\n get_mvdata_interlaced ( v , & dmv_x , & dmv_y , & pred_flag ) ;\n }\n vc1_pred_mv ( v , i , dmv_x , dmv_y , 0 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] , pred_flag , 0 ) ;\n vc1_mc_4mv_luma ( v , i , 0 ) ;\n }\n else if ( i == 4 ) vc1_mc_4mv_chroma ( v , 0 ) ;\n }\n mb_has_coeffs = idx_mbmode & 1 ;\n }\n if ( mb_has_coeffs ) cbp = 1 + get_vlc2 ( & v -> s . gb , v -> cbpcy_vlc -> table , VC1_CBPCY_P_VLC_BITS , 2 ) ;\n if ( cbp ) {\n GET_MQUANT ( ) ;\n }\n s -> current_picture . f . qscale_table [ mb_pos ] = mquant ;\n if ( ! v -> ttmbf && cbp ) {\n ttmb = get_vlc2 ( gb , ff_vc1_ttmb_vlc [ v -> tt_index ] . table , VC1_TTMB_VLC_BITS , 2 ) ;\n }\n dst_idx = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n dst_idx += i >> 2 ;\n val = ( ( cbp >> ( 5 - i ) ) & 1 ) ;\n off = ( i & 4 ) ? 0 : ( i & 1 ) * 8 + ( i & 2 ) * 4 * s -> linesize ;\n if ( v -> cur_field_type ) off += ( i & 4 ) ? s -> current_picture_ptr -> f . linesize [ 1 ] : s -> current_picture_ptr -> f . linesize [ 0 ] ;\n if ( val ) {\n pat = vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : s -> linesize , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , & block_tt ) ;\n block_cbp |= pat << ( i << 2 ) ;\n if ( ! v -> ttmbf && ttmb < 8 ) ttmb = - 1 ;\n first_block = 0 ;\n }\n }\n }\n if ( s -> mb_x == s -> mb_width - 1 ) memmove ( v -> is_intra_base , v -> is_intra , sizeof ( v -> is_intra_base [ 0 ] ) * s -> mb_stride ) ;\n return 0 ;\n }", "hash": 6080147530626246065, "project": "debian", "size": 110, "target": 1, "idx": 20845}
{"code": "static int vc1_decode_intra_block ( VC1Context * v , int16_t block [ 64 ] , int n , int coded , int mquant , int codingset ) {\n GetBitContext * gb = & v -> s . gb ;\n MpegEncContext * s = & v -> s ;\n int dc_pred_dir = 0 ;\n int i ;\n int16_t * dc_val ;\n int16_t * ac_val , * ac_val2 ;\n int dcdiff ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int a_avail = v -> a_avail , c_avail = v -> c_avail ;\n int use_pred = s -> ac_pred ;\n int scale ;\n int q1 , q2 = 0 ;\n s -> dsp . clear_block ( block ) ;\n mquant = ( mquant < 1 ) ? 0 : ( ( mquant > 31 ) ? 31 : mquant ) ;\n s -> y_dc_scale = s -> y_dc_scale_table [ mquant ] ;\n s -> c_dc_scale = s -> c_dc_scale_table [ mquant ] ;\n if ( n < 4 ) {\n dcdiff = get_vlc2 ( & s -> gb , ff_msmp4_dc_luma_vlc [ s -> dc_table_index ] . table , DC_VLC_BITS , 3 ) ;\n }\n else {\n dcdiff = get_vlc2 ( & s -> gb , ff_msmp4_dc_chroma_vlc [ s -> dc_table_index ] . table , DC_VLC_BITS , 3 ) ;\n }\n if ( dcdiff < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Illegal DC VLC\\n\" ) ;\n return - 1 ;\n }\n if ( dcdiff ) {\n if ( dcdiff == 119 ) {\n if ( mquant == 1 ) dcdiff = get_bits ( gb , 10 ) ;\n else if ( mquant == 2 ) dcdiff = get_bits ( gb , 9 ) ;\n else dcdiff = get_bits ( gb , 8 ) ;\n }\n else {\n if ( mquant == 1 ) dcdiff = ( dcdiff << 2 ) + get_bits ( gb , 2 ) - 3 ;\n else if ( mquant == 2 ) dcdiff = ( dcdiff << 1 ) + get_bits1 ( gb ) - 1 ;\n }\n if ( get_bits1 ( gb ) ) dcdiff = - dcdiff ;\n }\n dcdiff += vc1_pred_dc ( & v -> s , v -> overlap , mquant , n , a_avail , c_avail , & dc_val , & dc_pred_dir ) ;\n * dc_val = dcdiff ;\n if ( n < 4 ) {\n block [ 0 ] = dcdiff * s -> y_dc_scale ;\n }\n else {\n block [ 0 ] = dcdiff * s -> c_dc_scale ;\n }\n i = 1 ;\n if ( ! a_avail ) dc_pred_dir = 1 ;\n if ( ! c_avail ) dc_pred_dir = 0 ;\n if ( ! a_avail && ! c_avail ) use_pred = 0 ;\n ac_val = s -> ac_val [ 0 ] [ 0 ] + s -> block_index [ n ] * 16 ;\n ac_val2 = ac_val ;\n scale = mquant * 2 + v -> halfpq ;\n if ( dc_pred_dir ) ac_val -= 16 ;\n else ac_val -= 16 * s -> block_wrap [ n ] ;\n q1 = s -> current_picture . f . qscale_table [ mb_pos ] ;\n if ( dc_pred_dir && c_avail && mb_pos ) q2 = s -> current_picture . f . qscale_table [ mb_pos - 1 ] ;\n if ( ! dc_pred_dir && a_avail && mb_pos >= s -> mb_stride ) q2 = s -> current_picture . f . qscale_table [ mb_pos - s -> mb_stride ] ;\n if ( dc_pred_dir && n == 1 ) q2 = q1 ;\n if ( ! dc_pred_dir && n == 2 ) q2 = q1 ;\n if ( n == 3 ) q2 = q1 ;\n if ( coded ) {\n int last = 0 , skip , value ;\n int k ;\n while ( ! last ) {\n vc1_decode_ac_coeff ( v , & last , & skip , & value , codingset ) ;\n i += skip ;\n if ( i > 63 ) break ;\n if ( v -> fcm == PROGRESSIVE ) block [ v -> zz_8x8 [ 0 ] [ i ++ ] ] = value ;\n else {\n if ( use_pred && ( v -> fcm == ILACE_FRAME ) ) {\n if ( ! dc_pred_dir ) block [ v -> zz_8x8 [ 2 ] [ i ++ ] ] = value ;\n else block [ v -> zz_8x8 [ 3 ] [ i ++ ] ] = value ;\n }\n else {\n block [ v -> zzi_8x8 [ i ++ ] ] = value ;\n }\n }\n }\n if ( use_pred ) {\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> left_blk_sh ] += ( ac_val [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> top_blk_sh ] += ( ac_val [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n else {\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> left_blk_sh ] += ac_val [ k ] ;\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> top_blk_sh ] += ac_val [ k + 8 ] ;\n }\n }\n }\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n ac_val2 [ k ] = block [ k << v -> left_blk_sh ] ;\n ac_val2 [ k + 8 ] = block [ k << v -> top_blk_sh ] ;\n }\n for ( k = 1 ;\n k < 64 ;\n k ++ ) if ( block [ k ] ) {\n block [ k ] *= scale ;\n if ( ! v -> pquantizer ) block [ k ] += ( block [ k ] < 0 ) ? - mquant : mquant ;\n }\n if ( use_pred ) i = 63 ;\n }\n else {\n int k ;\n memset ( ac_val2 , 0 , 16 * 2 ) ;\n if ( dc_pred_dir ) {\n if ( use_pred ) {\n memcpy ( ac_val2 , ac_val , 8 * 2 ) ;\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n for ( k = 1 ;\n k < 8 ;\n k ++ ) ac_val2 [ k ] = ( ac_val2 [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n }\n else {\n if ( use_pred ) {\n memcpy ( ac_val2 + 8 , ac_val + 8 , 8 * 2 ) ;\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n for ( k = 1 ;\n k < 8 ;\n k ++ ) ac_val2 [ k + 8 ] = ( ac_val2 [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n }\n if ( use_pred ) {\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n block [ k << v -> left_blk_sh ] = ac_val2 [ k ] * scale ;\n if ( ! v -> pquantizer && block [ k << v -> left_blk_sh ] ) block [ k << v -> left_blk_sh ] += ( block [ k << v -> left_blk_sh ] < 0 ) ? - mquant : mquant ;\n }\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n block [ k << v -> top_blk_sh ] = ac_val2 [ k + 8 ] * scale ;\n if ( ! v -> pquantizer && block [ k << v -> top_blk_sh ] ) block [ k << v -> top_blk_sh ] += ( block [ k << v -> top_blk_sh ] < 0 ) ? - mquant : mquant ;\n }\n }\n i = 63 ;\n }\n }\n s -> block_last_index [ n ] = i ;\n return 0 ;\n }", "hash": 6080147530626246065, "project": "debian", "size": 175, "target": 1, "idx": 20851}
{"code": "static int decode_chunks ( AVCodecContext * avctx , AVFrame * picture , int * got_output , const uint8_t * buf , int buf_size ) {\n Mpeg1Context * s = avctx -> priv_data ;\n MpegEncContext * s2 = & s -> mpeg_enc_ctx ;\n const uint8_t * buf_ptr = buf ;\n const uint8_t * buf_end = buf + buf_size ;\n int ret , input_size ;\n int last_code = 0 ;\n for ( ;\n ;\n ) {\n uint32_t start_code = - 1 ;\n buf_ptr = avpriv_mpv_find_start_code ( buf_ptr , buf_end , & start_code ) ;\n if ( start_code > 0x1ff ) {\n if ( s2 -> pict_type != AV_PICTURE_TYPE_B || avctx -> skip_frame <= AVDISCARD_DEFAULT ) {\n if ( HAVE_THREADS && ( avctx -> active_thread_type & FF_THREAD_SLICE ) ) {\n int i ;\n avctx -> execute ( avctx , slice_decode_thread , & s2 -> thread_context [ 0 ] , NULL , s -> slice_count , sizeof ( void * ) ) ;\n for ( i = 0 ;\n i < s -> slice_count ;\n i ++ ) s2 -> er . error_count += s2 -> thread_context [ i ] -> er . error_count ;\n }\n if ( CONFIG_MPEG_VDPAU_DECODER && avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) ff_vdpau_mpeg_picture_complete ( s2 , buf , buf_size , s -> slice_count ) ;\n if ( slice_end ( avctx , picture ) ) {\n if ( s2 -> last_picture_ptr || s2 -> low_delay ) * got_output = 1 ;\n }\n }\n s2 -> pict_type = 0 ;\n return FFMAX ( 0 , buf_ptr - buf - s2 -> parse_context . last_index ) ;\n }\n input_size = buf_end - buf_ptr ;\n if ( avctx -> debug & FF_DEBUG_STARTCODE ) {\n av_log ( avctx , AV_LOG_DEBUG , \"%3X at %td left %d\\n\" , start_code , buf_ptr - buf , input_size ) ;\n }\n switch ( start_code ) {\n case SEQ_START_CODE : if ( last_code == 0 ) {\n mpeg1_decode_sequence ( avctx , buf_ptr , input_size ) ;\n s -> sync = 1 ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"ignoring SEQ_START_CODE after %X\\n\" , last_code ) ;\n if ( avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n }\n break ;\n case PICTURE_START_CODE : if ( HAVE_THREADS && ( avctx -> active_thread_type & FF_THREAD_SLICE ) && s -> slice_count ) {\n int i ;\n avctx -> execute ( avctx , slice_decode_thread , s2 -> thread_context , NULL , s -> slice_count , sizeof ( void * ) ) ;\n for ( i = 0 ;\n i < s -> slice_count ;\n i ++ ) s2 -> er . error_count += s2 -> thread_context [ i ] -> er . error_count ;\n s -> slice_count = 0 ;\n }\n if ( last_code == 0 || last_code == SLICE_MIN_START_CODE ) {\n ret = mpeg_decode_postinit ( avctx ) ;\n if ( ret < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"mpeg_decode_postinit() failure\\n\" ) ;\n return ret ;\n }\n if ( mpeg1_decode_picture ( avctx , buf_ptr , input_size ) < 0 ) s2 -> pict_type = 0 ;\n s2 -> first_slice = 1 ;\n last_code = PICTURE_START_CODE ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"ignoring pic after %X\\n\" , last_code ) ;\n if ( avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n }\n break ;\n case EXT_START_CODE : init_get_bits ( & s2 -> gb , buf_ptr , input_size * 8 ) ;\n switch ( get_bits ( & s2 -> gb , 4 ) ) {\n case 0x1 : if ( last_code == 0 ) {\n mpeg_decode_sequence_extension ( s ) ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"ignoring seq ext after %X\\n\" , last_code ) ;\n if ( avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n }\n break ;\n case 0x2 : mpeg_decode_sequence_display_extension ( s ) ;\n break ;\n case 0x3 : mpeg_decode_quant_matrix_extension ( s2 ) ;\n break ;\n case 0x7 : mpeg_decode_picture_display_extension ( s ) ;\n break ;\n case 0x8 : if ( last_code == PICTURE_START_CODE ) {\n mpeg_decode_picture_coding_extension ( s ) ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"ignoring pic cod ext after %X\\n\" , last_code ) ;\n if ( avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n }\n break ;\n }\n break ;\n case USER_START_CODE : mpeg_decode_user_data ( avctx , buf_ptr , input_size ) ;\n break ;\n case GOP_START_CODE : if ( last_code == 0 ) {\n s2 -> first_field = 0 ;\n mpeg_decode_gop ( avctx , buf_ptr , input_size ) ;\n s -> sync = 1 ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"ignoring GOP_START_CODE after %X\\n\" , last_code ) ;\n if ( avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n }\n break ;\n default : if ( start_code >= SLICE_MIN_START_CODE && start_code <= SLICE_MAX_START_CODE && last_code != 0 ) {\n const int field_pic = s2 -> picture_structure != PICT_FRAME ;\n int mb_y = ( start_code - SLICE_MIN_START_CODE ) << field_pic ;\n last_code = SLICE_MIN_START_CODE ;\n if ( s2 -> picture_structure == PICT_BOTTOM_FIELD ) mb_y ++ ;\n if ( mb_y >= s2 -> mb_height ) {\n av_log ( s2 -> avctx , AV_LOG_ERROR , \"slice below image (%d >= %d)\\n\" , mb_y , s2 -> mb_height ) ;\n return - 1 ;\n }\n if ( s2 -> last_picture_ptr == NULL ) {\n if ( s2 -> pict_type == AV_PICTURE_TYPE_B ) {\n if ( ! s -> closed_gop ) break ;\n }\n }\n if ( s2 -> pict_type == AV_PICTURE_TYPE_I ) s -> sync = 1 ;\n if ( s2 -> next_picture_ptr == NULL ) {\n if ( s2 -> pict_type == AV_PICTURE_TYPE_P && ! s -> sync ) break ;\n }\n if ( ( avctx -> skip_frame >= AVDISCARD_NONREF && s2 -> pict_type == AV_PICTURE_TYPE_B ) || ( avctx -> skip_frame >= AVDISCARD_NONKEY && s2 -> pict_type != AV_PICTURE_TYPE_I ) || avctx -> skip_frame >= AVDISCARD_ALL ) break ;\n if ( ! s -> mpeg_enc_ctx_allocated ) break ;\n if ( s2 -> codec_id == AV_CODEC_ID_MPEG2VIDEO ) {\n if ( mb_y < avctx -> skip_top || mb_y >= s2 -> mb_height - avctx -> skip_bottom ) break ;\n }\n if ( ! s2 -> pict_type ) {\n av_log ( avctx , AV_LOG_ERROR , \"Missing picture start code\\n\" ) ;\n if ( avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ;\n break ;\n }\n if ( s2 -> first_slice ) {\n s2 -> first_slice = 0 ;\n if ( mpeg_field_start ( s2 , buf , buf_size ) < 0 ) return - 1 ;\n }\n if ( ! s2 -> current_picture_ptr ) {\n av_log ( avctx , AV_LOG_ERROR , \"current_picture not initialized\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) {\n s -> slice_count ++ ;\n break ;\n }\n if ( HAVE_THREADS && ( avctx -> active_thread_type & FF_THREAD_SLICE ) ) {\n int threshold = ( s2 -> mb_height * s -> slice_count + s2 -> slice_context_count / 2 ) / s2 -> slice_context_count ;\n if ( threshold <= mb_y ) {\n MpegEncContext * thread_context = s2 -> thread_context [ s -> slice_count ] ;\n thread_context -> start_mb_y = mb_y ;\n thread_context -> end_mb_y = s2 -> mb_height ;\n if ( s -> slice_count ) {\n s2 -> thread_context [ s -> slice_count - 1 ] -> end_mb_y = mb_y ;\n ret = ff_update_duplicate_context ( thread_context , s2 ) ;\n if ( ret < 0 ) return ret ;\n }\n init_get_bits ( & thread_context -> gb , buf_ptr , input_size * 8 ) ;\n s -> slice_count ++ ;\n }\n buf_ptr += 2 ;\n }\n else {\n ret = mpeg_decode_slice ( s2 , mb_y , & buf_ptr , input_size ) ;\n emms_c ( ) ;\n if ( ret < 0 ) {\n if ( avctx -> err_recognition & AV_EF_EXPLODE ) return ret ;\n if ( s2 -> resync_mb_x >= 0 && s2 -> resync_mb_y >= 0 ) ff_er_add_slice ( & s2 -> er , s2 -> resync_mb_x , s2 -> resync_mb_y , s2 -> mb_x , s2 -> mb_y , ER_AC_ERROR | ER_DC_ERROR | ER_MV_ERROR ) ;\n }\n else {\n ff_er_add_slice ( & s2 -> er , s2 -> resync_mb_x , s2 -> resync_mb_y , s2 -> mb_x - 1 , s2 -> mb_y , ER_AC_END | ER_DC_END | ER_MV_END ) ;\n }\n }\n }\n break ;\n }\n }\n }", "hash": -6435087038712482873, "project": "debian", "size": 176, "target": 1, "idx": 20887}
{"code": "void ff_estimate_p_frame_motion ( MpegEncContext * s , int mb_x , int mb_y ) {\n MotionEstContext * const c = & s -> me ;\n uint8_t * pix , * ppix ;\n int sum , mx , my , dmin ;\n int varc ;\n int vard ;\n int P [ 10 ] [ 2 ] ;\n const int shift = 1 + s -> quarter_sample ;\n int mb_type = 0 ;\n Picture * const pic = & s -> current_picture ;\n init_ref ( c , s -> new_picture . f . data , s -> last_picture . f . data , NULL , 16 * mb_x , 16 * mb_y , 0 ) ;\n assert ( s -> quarter_sample == 0 || s -> quarter_sample == 1 ) ;\n assert ( s -> linesize == c -> stride ) ;\n assert ( s -> uvlinesize == c -> uvstride ) ;\n c -> penalty_factor = get_penalty_factor ( s -> lambda , s -> lambda2 , c -> avctx -> me_cmp ) ;\n c -> sub_penalty_factor = get_penalty_factor ( s -> lambda , s -> lambda2 , c -> avctx -> me_sub_cmp ) ;\n c -> mb_penalty_factor = get_penalty_factor ( s -> lambda , s -> lambda2 , c -> avctx -> mb_cmp ) ;\n c -> current_mv_penalty = c -> mv_penalty [ s -> f_code ] + MAX_MV ;\n get_limits ( s , 16 * mb_x , 16 * mb_y ) ;\n c -> skip = 0 ;\n pix = c -> src [ 0 ] [ 0 ] ;\n sum = s -> dsp . pix_sum ( pix , s -> linesize ) ;\n varc = s -> dsp . pix_norm1 ( pix , s -> linesize ) - ( ( ( unsigned ) sum * sum ) >> 8 ) + 500 ;\n pic -> mb_mean [ s -> mb_stride * mb_y + mb_x ] = ( sum + 128 ) >> 8 ;\n pic -> mb_var [ s -> mb_stride * mb_y + mb_x ] = ( varc + 128 ) >> 8 ;\n c -> mb_var_sum_temp += ( varc + 128 ) >> 8 ;\n switch ( s -> me_method ) {\n case ME_ZERO : default : mx = 0 ;\n my = 0 ;\n dmin = 0 ;\n break ;\n case ME_X1 : case ME_EPZS : {\n const int mot_stride = s -> b8_stride ;\n const int mot_xy = s -> block_index [ 0 ] ;\n P_LEFT [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ mot_xy - 1 ] [ 0 ] ;\n P_LEFT [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ mot_xy - 1 ] [ 1 ] ;\n if ( P_LEFT [ 0 ] > ( c -> xmax << shift ) ) P_LEFT [ 0 ] = ( c -> xmax << shift ) ;\n if ( ! s -> first_slice_line ) {\n P_TOP [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ mot_xy - mot_stride ] [ 0 ] ;\n P_TOP [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ mot_xy - mot_stride ] [ 1 ] ;\n P_TOPRIGHT [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ mot_xy - mot_stride + 2 ] [ 0 ] ;\n P_TOPRIGHT [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ mot_xy - mot_stride + 2 ] [ 1 ] ;\n if ( P_TOP [ 1 ] > ( c -> ymax << shift ) ) P_TOP [ 1 ] = ( c -> ymax << shift ) ;\n if ( P_TOPRIGHT [ 0 ] < ( c -> xmin << shift ) ) P_TOPRIGHT [ 0 ] = ( c -> xmin << shift ) ;\n if ( P_TOPRIGHT [ 1 ] > ( c -> ymax << shift ) ) P_TOPRIGHT [ 1 ] = ( c -> ymax << shift ) ;\n P_MEDIAN [ 0 ] = mid_pred ( P_LEFT [ 0 ] , P_TOP [ 0 ] , P_TOPRIGHT [ 0 ] ) ;\n P_MEDIAN [ 1 ] = mid_pred ( P_LEFT [ 1 ] , P_TOP [ 1 ] , P_TOPRIGHT [ 1 ] ) ;\n if ( s -> out_format == FMT_H263 ) {\n c -> pred_x = P_MEDIAN [ 0 ] ;\n c -> pred_y = P_MEDIAN [ 1 ] ;\n }\n else {\n c -> pred_x = P_LEFT [ 0 ] ;\n c -> pred_y = P_LEFT [ 1 ] ;\n }\n }\n else {\n c -> pred_x = P_LEFT [ 0 ] ;\n c -> pred_y = P_LEFT [ 1 ] ;\n }\n }\n dmin = ff_epzs_motion_search ( s , & mx , & my , P , 0 , 0 , s -> p_mv_table , ( 1 << 16 ) >> shift , 0 , 16 ) ;\n break ;\n }\n ppix = c -> ref [ 0 ] [ 0 ] + ( my * s -> linesize ) + mx ;\n vard = s -> dsp . sse [ 0 ] ( NULL , pix , ppix , s -> linesize , 16 ) ;\n pic -> mc_mb_var [ s -> mb_stride * mb_y + mb_x ] = ( vard + 128 ) >> 8 ;\n c -> mc_mb_var_sum_temp += ( vard + 128 ) >> 8 ;\n if ( mb_type ) {\n int p_score = FFMIN ( vard , varc - 500 + ( s -> lambda2 >> FF_LAMBDA_SHIFT ) * 100 ) ;\n int i_score = varc - 500 + ( s -> lambda2 >> FF_LAMBDA_SHIFT ) * 20 ;\n c -> scene_change_score += ff_sqrt ( p_score ) - ff_sqrt ( i_score ) ;\n if ( mb_type == CANDIDATE_MB_TYPE_INTER ) {\n c -> sub_motion_search ( s , & mx , & my , dmin , 0 , 0 , 0 , 16 ) ;\n set_p_mv_tables ( s , mx , my , 1 ) ;\n }\n else {\n mx <<= shift ;\n my <<= shift ;\n }\n if ( mb_type == CANDIDATE_MB_TYPE_INTER4V ) {\n h263_mv4_search ( s , mx , my , shift ) ;\n set_p_mv_tables ( s , mx , my , 0 ) ;\n }\n if ( mb_type == CANDIDATE_MB_TYPE_INTER_I ) {\n interlaced_search ( s , 0 , s -> p_field_mv_table , s -> p_field_select_table , mx , my , 1 ) ;\n }\n }\n else if ( c -> avctx -> mb_decision > FF_MB_DECISION_SIMPLE ) {\n int p_score = FFMIN ( vard , varc - 500 + ( s -> lambda2 >> FF_LAMBDA_SHIFT ) * 100 ) ;\n int i_score = varc - 500 + ( s -> lambda2 >> FF_LAMBDA_SHIFT ) * 20 ;\n c -> scene_change_score += ff_sqrt ( p_score ) - ff_sqrt ( i_score ) ;\n if ( vard * 2 + 200 * 256 > varc ) mb_type |= CANDIDATE_MB_TYPE_INTRA ;\n if ( varc * 2 + 200 * 256 > vard || s -> qscale > 24 ) {\n mb_type |= CANDIDATE_MB_TYPE_INTER ;\n c -> sub_motion_search ( s , & mx , & my , dmin , 0 , 0 , 0 , 16 ) ;\n if ( s -> flags & CODEC_FLAG_MV0 ) if ( mx || my ) mb_type |= CANDIDATE_MB_TYPE_SKIPPED ;\n }\n else {\n mx <<= shift ;\n my <<= shift ;\n }\n if ( ( s -> flags & CODEC_FLAG_4MV ) && ! c -> skip && varc > 50 << 8 && vard > 10 << 8 ) {\n if ( h263_mv4_search ( s , mx , my , shift ) < INT_MAX ) mb_type |= CANDIDATE_MB_TYPE_INTER4V ;\n set_p_mv_tables ( s , mx , my , 0 ) ;\n }\n else set_p_mv_tables ( s , mx , my , 1 ) ;\n if ( ( s -> flags & CODEC_FLAG_INTERLACED_ME ) && ! c -> skip ) {\n if ( interlaced_search ( s , 0 , s -> p_field_mv_table , s -> p_field_select_table , mx , my , 0 ) < INT_MAX ) mb_type |= CANDIDATE_MB_TYPE_INTER_I ;\n }\n }\n else {\n int intra_score , i ;\n mb_type = CANDIDATE_MB_TYPE_INTER ;\n dmin = c -> sub_motion_search ( s , & mx , & my , dmin , 0 , 0 , 0 , 16 ) ;\n if ( c -> avctx -> me_sub_cmp != c -> avctx -> mb_cmp && ! c -> skip ) dmin = get_mb_score ( s , mx , my , 0 , 0 , 0 , 16 , 1 ) ;\n if ( ( s -> flags & CODEC_FLAG_4MV ) && ! c -> skip && varc > 50 << 8 && vard > 10 << 8 ) {\n int dmin4 = h263_mv4_search ( s , mx , my , shift ) ;\n if ( dmin4 < dmin ) {\n mb_type = CANDIDATE_MB_TYPE_INTER4V ;\n dmin = dmin4 ;\n }\n }\n if ( ( s -> flags & CODEC_FLAG_INTERLACED_ME ) && ! c -> skip ) {\n int dmin_i = interlaced_search ( s , 0 , s -> p_field_mv_table , s -> p_field_select_table , mx , my , 0 ) ;\n if ( dmin_i < dmin ) {\n mb_type = CANDIDATE_MB_TYPE_INTER_I ;\n dmin = dmin_i ;\n }\n }\n set_p_mv_tables ( s , mx , my , mb_type != CANDIDATE_MB_TYPE_INTER4V ) ;\n if ( ( c -> avctx -> mb_cmp & 0xFF ) == FF_CMP_SSE ) {\n intra_score = varc - 500 ;\n }\n else {\n unsigned mean = ( sum + 128 ) >> 8 ;\n mean *= 0x01010101 ;\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n * ( uint32_t * ) ( & c -> scratchpad [ i * s -> linesize + 0 ] ) = mean ;\n * ( uint32_t * ) ( & c -> scratchpad [ i * s -> linesize + 4 ] ) = mean ;\n * ( uint32_t * ) ( & c -> scratchpad [ i * s -> linesize + 8 ] ) = mean ;\n * ( uint32_t * ) ( & c -> scratchpad [ i * s -> linesize + 12 ] ) = mean ;\n }\n intra_score = s -> dsp . mb_cmp [ 0 ] ( s , c -> scratchpad , pix , s -> linesize , 16 ) ;\n }\n intra_score += c -> mb_penalty_factor * 16 ;\n if ( intra_score < dmin ) {\n mb_type = CANDIDATE_MB_TYPE_INTRA ;\n s -> current_picture . f . mb_type [ mb_y * s -> mb_stride + mb_x ] = CANDIDATE_MB_TYPE_INTRA ;\n }\n else s -> current_picture . f . mb_type [ mb_y * s -> mb_stride + mb_x ] = 0 ;\n {\n int p_score = FFMIN ( vard , varc - 500 + ( s -> lambda2 >> FF_LAMBDA_SHIFT ) * 100 ) ;\n int i_score = varc - 500 + ( s -> lambda2 >> FF_LAMBDA_SHIFT ) * 20 ;\n c -> scene_change_score += ff_sqrt ( p_score ) - ff_sqrt ( i_score ) ;\n }\n }\n s -> mb_type [ mb_y * s -> mb_stride + mb_x ] = mb_type ;\n }", "hash": 1788300783882316916, "project": "debian", "size": 161, "target": 1, "idx": 20900}
{"code": "static int flic_decode_frame_8BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n FlicDecodeContext * s = avctx -> priv_data ;\n GetByteContext g2 ;\n int stream_ptr_after_color_chunk ;\n int pixel_ptr ;\n int palette_ptr ;\n unsigned char palette_idx1 ;\n unsigned char palette_idx2 ;\n unsigned int frame_size ;\n int num_chunks ;\n unsigned int chunk_size ;\n int chunk_type ;\n int i , j , ret ;\n int color_packets ;\n int color_changes ;\n int color_shift ;\n unsigned char r , g , b ;\n int lines ;\n int compressed_lines ;\n int starting_line ;\n signed short line_packets ;\n int y_ptr ;\n int byte_run ;\n int pixel_skip ;\n int pixel_countdown ;\n unsigned char * pixels ;\n unsigned int pixel_limit ;\n bytestream2_init ( & g2 , buf , buf_size ) ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n pixels = s -> frame . data [ 0 ] ;\n pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ] ;\n frame_size = bytestream2_get_le32 ( & g2 ) ;\n bytestream2_skip ( & g2 , 2 ) ;\n num_chunks = bytestream2_get_le16 ( & g2 ) ;\n bytestream2_skip ( & g2 , 8 ) ;\n frame_size -= 16 ;\n while ( ( frame_size > 0 ) && ( num_chunks > 0 ) ) {\n chunk_size = bytestream2_get_le32 ( & g2 ) ;\n chunk_type = bytestream2_get_le16 ( & g2 ) ;\n switch ( chunk_type ) {\n case FLI_256_COLOR : case FLI_COLOR : stream_ptr_after_color_chunk = bytestream2_tell ( & g2 ) + chunk_size - 6 ;\n if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) ) color_shift = 0 ;\n else color_shift = 2 ;\n color_packets = bytestream2_get_le16 ( & g2 ) ;\n palette_ptr = 0 ;\n for ( i = 0 ;\n i < color_packets ;\n i ++ ) {\n palette_ptr += bytestream2_get_byte ( & g2 ) ;\n color_changes = bytestream2_get_byte ( & g2 ) ;\n if ( color_changes == 0 ) color_changes = 256 ;\n for ( j = 0 ;\n j < color_changes ;\n j ++ ) {\n unsigned int entry ;\n if ( ( unsigned ) palette_ptr >= 256 ) palette_ptr = 0 ;\n r = bytestream2_get_byte ( & g2 ) << color_shift ;\n g = bytestream2_get_byte ( & g2 ) << color_shift ;\n b = bytestream2_get_byte ( & g2 ) << color_shift ;\n entry = ( r << 16 ) | ( g << 8 ) | b ;\n if ( s -> palette [ palette_ptr ] != entry ) s -> new_palette = 1 ;\n s -> palette [ palette_ptr ++ ] = entry ;\n }\n }\n if ( stream_ptr_after_color_chunk - bytestream2_tell ( & g2 ) > 0 ) bytestream2_skip ( & g2 , stream_ptr_after_color_chunk - bytestream2_tell ( & g2 ) ) ;\n break ;\n case FLI_DELTA : y_ptr = 0 ;\n compressed_lines = bytestream2_get_le16 ( & g2 ) ;\n while ( compressed_lines > 0 ) {\n line_packets = bytestream2_get_le16 ( & g2 ) ;\n if ( ( line_packets & 0xC000 ) == 0xC000 ) {\n line_packets = - line_packets ;\n y_ptr += line_packets * s -> frame . linesize [ 0 ] ;\n }\n else if ( ( line_packets & 0xC000 ) == 0x4000 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Undefined opcode (%x) in DELTA_FLI\\n\" , line_packets ) ;\n }\n else if ( ( line_packets & 0xC000 ) == 0x8000 ) {\n pixel_ptr = y_ptr + s -> frame . linesize [ 0 ] - 1 ;\n CHECK_PIXEL_PTR ( 0 ) ;\n pixels [ pixel_ptr ] = line_packets & 0xff ;\n }\n else {\n compressed_lines -- ;\n pixel_ptr = y_ptr ;\n CHECK_PIXEL_PTR ( 0 ) ;\n pixel_countdown = s -> avctx -> width ;\n for ( i = 0 ;\n i < line_packets ;\n i ++ ) {\n pixel_skip = bytestream2_get_byte ( & g2 ) ;\n pixel_ptr += pixel_skip ;\n pixel_countdown -= pixel_skip ;\n byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n if ( byte_run < 0 ) {\n byte_run = - byte_run ;\n palette_idx1 = bytestream2_get_byte ( & g2 ) ;\n palette_idx2 = bytestream2_get_byte ( & g2 ) ;\n CHECK_PIXEL_PTR ( byte_run * 2 ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ , pixel_countdown -= 2 ) {\n pixels [ pixel_ptr ++ ] = palette_idx1 ;\n pixels [ pixel_ptr ++ ] = palette_idx2 ;\n }\n }\n else {\n CHECK_PIXEL_PTR ( byte_run * 2 ) ;\n for ( j = 0 ;\n j < byte_run * 2 ;\n j ++ , pixel_countdown -- ) {\n pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n }\n }\n }\n y_ptr += s -> frame . linesize [ 0 ] ;\n }\n }\n break ;\n case FLI_LC : starting_line = bytestream2_get_le16 ( & g2 ) ;\n y_ptr = 0 ;\n y_ptr += starting_line * s -> frame . linesize [ 0 ] ;\n compressed_lines = bytestream2_get_le16 ( & g2 ) ;\n while ( compressed_lines > 0 ) {\n pixel_ptr = y_ptr ;\n CHECK_PIXEL_PTR ( 0 ) ;\n pixel_countdown = s -> avctx -> width ;\n line_packets = bytestream2_get_byte ( & g2 ) ;\n if ( line_packets > 0 ) {\n for ( i = 0 ;\n i < line_packets ;\n i ++ ) {\n pixel_skip = bytestream2_get_byte ( & g2 ) ;\n pixel_ptr += pixel_skip ;\n pixel_countdown -= pixel_skip ;\n byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n if ( byte_run > 0 ) {\n CHECK_PIXEL_PTR ( byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ , pixel_countdown -- ) {\n pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n }\n }\n else if ( byte_run < 0 ) {\n byte_run = - byte_run ;\n palette_idx1 = bytestream2_get_byte ( & g2 ) ;\n CHECK_PIXEL_PTR ( byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ , pixel_countdown -- ) {\n pixels [ pixel_ptr ++ ] = palette_idx1 ;\n }\n }\n }\n }\n y_ptr += s -> frame . linesize [ 0 ] ;\n compressed_lines -- ;\n }\n break ;\n case FLI_BLACK : memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;\n break ;\n case FLI_BRUN : y_ptr = 0 ;\n for ( lines = 0 ;\n lines < s -> avctx -> height ;\n lines ++ ) {\n pixel_ptr = y_ptr ;\n bytestream2_skip ( & g2 , 1 ) ;\n pixel_countdown = s -> avctx -> width ;\n while ( pixel_countdown > 0 ) {\n byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n if ( ! byte_run ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid byte run value.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( byte_run > 0 ) {\n palette_idx1 = bytestream2_get_byte ( & g2 ) ;\n CHECK_PIXEL_PTR ( byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ ) {\n pixels [ pixel_ptr ++ ] = palette_idx1 ;\n pixel_countdown -- ;\n if ( pixel_countdown < 0 ) av_log ( avctx , AV_LOG_ERROR , \"pixel_countdown < 0 (%d) at line %d\\n\" , pixel_countdown , lines ) ;\n }\n }\n else {\n byte_run = - byte_run ;\n CHECK_PIXEL_PTR ( byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ ) {\n pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n pixel_countdown -- ;\n if ( pixel_countdown < 0 ) av_log ( avctx , AV_LOG_ERROR , \"pixel_countdown < 0 (%d) at line %d\\n\" , pixel_countdown , lines ) ;\n }\n }\n }\n y_ptr += s -> frame . linesize [ 0 ] ;\n }\n break ;\n case FLI_COPY : if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height ) {\n av_log ( avctx , AV_LOG_ERROR , \"In chunk FLI_COPY : source data (%d bytes) \" \\ \"bigger than image, skipping chunk\\n\" , chunk_size - 6 ) ;\n bytestream2_skip ( & g2 , chunk_size - 6 ) ;\n }\n else {\n for ( y_ptr = 0 ;\n y_ptr < s -> frame . linesize [ 0 ] * s -> avctx -> height ;\n y_ptr += s -> frame . linesize [ 0 ] ) {\n bytestream2_get_buffer ( & g2 , & pixels [ y_ptr ] , s -> avctx -> width ) ;\n }\n }\n break ;\n case FLI_MINI : bytestream2_skip ( & g2 , chunk_size - 6 ) ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unrecognized chunk type: %d\\n\" , chunk_type ) ;\n break ;\n }\n frame_size -= chunk_size ;\n num_chunks -- ;\n }\n if ( ( bytestream2_get_bytes_left ( & g2 ) != 0 ) && ( bytestream2_get_bytes_left ( & g2 ) != 1 ) ) av_log ( avctx , AV_LOG_ERROR , \"Processed FLI chunk where chunk size = %d \" \\ \"and final chunk ptr = %d\\n\" , buf_size , buf_size - bytestream2_get_bytes_left ( & g2 ) ) ;\n memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n if ( s -> new_palette ) {\n s -> frame . palette_has_changed = 1 ;\n s -> new_palette = 0 ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }", "hash": 6030508190585699741, "project": "debian", "size": 236, "target": 1, "idx": 20907}
{"code": "static int output_data ( MLPDecodeContext * m , unsigned int substr , AVFrame * frame , int * got_frame_ptr ) {\n AVCodecContext * avctx = m -> avctx ;\n SubStream * s = & m -> substream [ substr ] ;\n unsigned int i , out_ch = 0 ;\n int32_t * data_32 ;\n int16_t * data_16 ;\n int ret ;\n int is32 = ( m -> avctx -> sample_fmt == AV_SAMPLE_FMT_S32 ) ;\n if ( m -> avctx -> channels != s -> max_matrix_channel + 1 ) {\n av_log ( m -> avctx , AV_LOG_ERROR , \"channel count mismatch\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ! s -> blockpos ) {\n av_log ( avctx , AV_LOG_ERROR , \"No samples to output.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n frame -> nb_samples = s -> blockpos ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n data_32 = ( int32_t * ) frame -> data [ 0 ] ;\n data_16 = ( int16_t * ) frame -> data [ 0 ] ;\n for ( i = 0 ;\n i < s -> blockpos ;\n i ++ ) {\n for ( out_ch = 0 ;\n out_ch <= s -> max_matrix_channel ;\n out_ch ++ ) {\n int mat_ch = s -> ch_assign [ out_ch ] ;\n int32_t sample = m -> sample_buffer [ i ] [ mat_ch ] << s -> output_shift [ mat_ch ] ;\n s -> lossless_check_data ^= ( sample & 0xffffff ) << mat_ch ;\n if ( is32 ) * data_32 ++ = sample << 8 ;\n else * data_16 ++ = sample >> 8 ;\n }\n }\n * got_frame_ptr = 1 ;\n return 0 ;\n }", "hash": 8218188955508624394, "project": "debian", "size": 39, "target": 1, "idx": 20912}
{"code": "static int sipr_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n SiprContext * ctx = avctx -> priv_data ;\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n SiprParameters parm ;\n const SiprModeParam * mode_par = & modes [ ctx -> mode ] ;\n GetBitContext gb ;\n float * samples ;\n int subframe_size = ctx -> mode == MODE_16k ? L_SUBFR_16k : SUBFR_SIZE ;\n int i , ret ;\n ctx -> avctx = avctx ;\n if ( avpkt -> size < ( mode_par -> bits_per_frame >> 3 ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error processing packet: packet size (%d) too small\\n\" , avpkt -> size ) ;\n return - 1 ;\n }\n frame -> nb_samples = mode_par -> frames_per_packet * subframe_size * mode_par -> subframe_count ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n samples = ( float * ) frame -> data [ 0 ] ;\n init_get_bits ( & gb , buf , mode_par -> bits_per_frame ) ;\n for ( i = 0 ;\n i < mode_par -> frames_per_packet ;\n i ++ ) {\n decode_parameters ( & parm , & gb , mode_par ) ;\n ctx -> decode_frame ( ctx , & parm , samples ) ;\n samples += subframe_size * mode_par -> subframe_count ;\n }\n * got_frame_ptr = 1 ;\n return mode_par -> bits_per_frame >> 3 ;\n }", "hash": -4370220620850259177, "project": "debian", "size": 32, "target": 1, "idx": 20921}
{"code": "static int decode_pic ( AVSContext * h ) {\n int skip_count = - 1 ;\n enum cavs_mb mb_type ;\n skip_bits ( & h -> gb , 16 ) ;\n if ( h -> stc == PIC_PB_START_CODE ) {\n h -> cur . f -> pict_type = get_bits ( & h -> gb , 2 ) + AV_PICTURE_TYPE_I ;\n if ( h -> cur . f -> pict_type > AV_PICTURE_TYPE_B ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"illegal picture type\\n\" ) ;\n return - 1 ;\n }\n if ( ! h -> DPB [ 0 ] . f -> data [ 0 ] || ( ! h -> DPB [ 1 ] . f -> data [ 0 ] && h -> cur . f -> pict_type == AV_PICTURE_TYPE_B ) ) return - 1 ;\n }\n else {\n h -> cur . f -> pict_type = AV_PICTURE_TYPE_I ;\n if ( get_bits1 ( & h -> gb ) ) skip_bits ( & h -> gb , 24 ) ;\n if ( h -> low_delay || ! ( show_bits ( & h -> gb , 9 ) & 1 ) ) h -> stream_revision = 1 ;\n else if ( show_bits ( & h -> gb , 11 ) & 3 ) h -> stream_revision = 1 ;\n if ( h -> stream_revision > 0 ) skip_bits ( & h -> gb , 1 ) ;\n }\n if ( h -> cur . f -> data [ 0 ] ) h -> avctx -> release_buffer ( h -> avctx , h -> cur . f ) ;\n ff_get_buffer ( h -> avctx , h -> cur . f ) ;\n if ( ! h -> edge_emu_buffer ) {\n int alloc_size = FFALIGN ( FFABS ( h -> cur . f -> linesize [ 0 ] ) + 32 , 32 ) ;\n h -> edge_emu_buffer = av_mallocz ( alloc_size * 2 * 24 ) ;\n if ( ! h -> edge_emu_buffer ) return AVERROR ( ENOMEM ) ;\n }\n ff_cavs_init_pic ( h ) ;\n h -> cur . poc = get_bits ( & h -> gb , 8 ) * 2 ;\n if ( h -> cur . f -> pict_type != AV_PICTURE_TYPE_B ) {\n h -> dist [ 0 ] = ( h -> cur . poc - h -> DPB [ 0 ] . poc + 512 ) % 512 ;\n }\n else {\n h -> dist [ 0 ] = ( h -> DPB [ 0 ] . poc - h -> cur . poc + 512 ) % 512 ;\n }\n h -> dist [ 1 ] = ( h -> cur . poc - h -> DPB [ 1 ] . poc + 512 ) % 512 ;\n h -> scale_den [ 0 ] = h -> dist [ 0 ] ? 512 / h -> dist [ 0 ] : 0 ;\n h -> scale_den [ 1 ] = h -> dist [ 1 ] ? 512 / h -> dist [ 1 ] : 0 ;\n if ( h -> cur . f -> pict_type == AV_PICTURE_TYPE_B ) {\n h -> sym_factor = h -> dist [ 0 ] * h -> scale_den [ 1 ] ;\n }\n else {\n h -> direct_den [ 0 ] = h -> dist [ 0 ] ? 16384 / h -> dist [ 0 ] : 0 ;\n h -> direct_den [ 1 ] = h -> dist [ 1 ] ? 16384 / h -> dist [ 1 ] : 0 ;\n }\n if ( h -> low_delay ) get_ue_golomb ( & h -> gb ) ;\n h -> progressive = get_bits1 ( & h -> gb ) ;\n h -> pic_structure = 1 ;\n if ( ! h -> progressive ) h -> pic_structure = get_bits1 ( & h -> gb ) ;\n if ( ! h -> pic_structure && h -> stc == PIC_PB_START_CODE ) skip_bits1 ( & h -> gb ) ;\n skip_bits1 ( & h -> gb ) ;\n skip_bits1 ( & h -> gb ) ;\n h -> qp_fixed = get_bits1 ( & h -> gb ) ;\n h -> qp = get_bits ( & h -> gb , 6 ) ;\n if ( h -> cur . f -> pict_type == AV_PICTURE_TYPE_I ) {\n if ( ! h -> progressive && ! h -> pic_structure ) skip_bits1 ( & h -> gb ) ;\n skip_bits ( & h -> gb , 4 ) ;\n }\n else {\n if ( ! ( h -> cur . f -> pict_type == AV_PICTURE_TYPE_B && h -> pic_structure == 1 ) ) h -> ref_flag = get_bits1 ( & h -> gb ) ;\n skip_bits ( & h -> gb , 4 ) ;\n h -> skip_mode_flag = get_bits1 ( & h -> gb ) ;\n }\n h -> loop_filter_disable = get_bits1 ( & h -> gb ) ;\n if ( ! h -> loop_filter_disable && get_bits1 ( & h -> gb ) ) {\n h -> alpha_offset = get_se_golomb ( & h -> gb ) ;\n h -> beta_offset = get_se_golomb ( & h -> gb ) ;\n }\n else {\n h -> alpha_offset = h -> beta_offset = 0 ;\n }\n if ( h -> cur . f -> pict_type == AV_PICTURE_TYPE_I ) {\n do {\n check_for_slice ( h ) ;\n decode_mb_i ( h , 0 ) ;\n }\n while ( ff_cavs_next_mb ( h ) ) ;\n }\n else if ( h -> cur . f -> pict_type == AV_PICTURE_TYPE_P ) {\n do {\n if ( check_for_slice ( h ) ) skip_count = - 1 ;\n if ( h -> skip_mode_flag && ( skip_count < 0 ) ) skip_count = get_ue_golomb ( & h -> gb ) ;\n if ( h -> skip_mode_flag && skip_count -- ) {\n decode_mb_p ( h , P_SKIP ) ;\n }\n else {\n mb_type = get_ue_golomb ( & h -> gb ) + P_SKIP + h -> skip_mode_flag ;\n if ( mb_type > P_8X8 ) decode_mb_i ( h , mb_type - P_8X8 - 1 ) ;\n else decode_mb_p ( h , mb_type ) ;\n }\n }\n while ( ff_cavs_next_mb ( h ) ) ;\n }\n else {\n do {\n if ( check_for_slice ( h ) ) skip_count = - 1 ;\n if ( h -> skip_mode_flag && ( skip_count < 0 ) ) skip_count = get_ue_golomb ( & h -> gb ) ;\n if ( h -> skip_mode_flag && skip_count -- ) {\n decode_mb_b ( h , B_SKIP ) ;\n }\n else {\n mb_type = get_ue_golomb ( & h -> gb ) + B_SKIP + h -> skip_mode_flag ;\n if ( mb_type > B_8X8 ) decode_mb_i ( h , mb_type - B_8X8 - 1 ) ;\n else decode_mb_b ( h , mb_type ) ;\n }\n }\n while ( ff_cavs_next_mb ( h ) ) ;\n }\n if ( h -> cur . f -> pict_type != AV_PICTURE_TYPE_B ) {\n if ( h -> DPB [ 1 ] . f -> data [ 0 ] ) h -> avctx -> release_buffer ( h -> avctx , h -> DPB [ 1 ] . f ) ;\n FFSWAP ( AVSFrame , h -> cur , h -> DPB [ 1 ] ) ;\n FFSWAP ( AVSFrame , h -> DPB [ 0 ] , h -> DPB [ 1 ] ) ;\n }\n return 0 ;\n }", "hash": -4271192073087306668, "project": "debian", "size": 114, "target": 1, "idx": 20926}
{"code": "static void rv30_loop_filter ( RV34DecContext * r , int row ) {\n MpegEncContext * s = & r -> s ;\n int mb_pos , mb_x ;\n int i , j , k ;\n uint8_t * Y , * C ;\n int loc_lim , cur_lim , left_lim = 0 , top_lim = 0 ;\n mb_pos = row * s -> mb_stride ;\n for ( mb_x = 0 ;\n mb_x < s -> mb_width ;\n mb_x ++ , mb_pos ++ ) {\n int mbtype = s -> current_picture_ptr -> f . mb_type [ mb_pos ] ;\n if ( IS_INTRA ( mbtype ) || IS_SEPARATE_DC ( mbtype ) ) r -> deblock_coefs [ mb_pos ] = 0xFFFF ;\n if ( IS_INTRA ( mbtype ) ) r -> cbp_chroma [ mb_pos ] = 0xFF ;\n }\n mb_pos = row * s -> mb_stride ;\n for ( mb_x = 0 ;\n mb_x < s -> mb_width ;\n mb_x ++ , mb_pos ++ ) {\n cur_lim = rv30_loop_filt_lim [ s -> current_picture_ptr -> f . qscale_table [ mb_pos ] ] ;\n if ( mb_x ) left_lim = rv30_loop_filt_lim [ s -> current_picture_ptr -> f . qscale_table [ mb_pos - 1 ] ] ;\n for ( j = 0 ;\n j < 16 ;\n j += 4 ) {\n Y = s -> current_picture_ptr -> f . data [ 0 ] + mb_x * 16 + ( row * 16 + j ) * s -> linesize + 4 * ! mb_x ;\n for ( i = ! mb_x ;\n i < 4 ;\n i ++ , Y += 4 ) {\n int ij = i + j ;\n loc_lim = 0 ;\n if ( r -> deblock_coefs [ mb_pos ] & ( 1 << ij ) ) loc_lim = cur_lim ;\n else if ( ! i && r -> deblock_coefs [ mb_pos - 1 ] & ( 1 << ( ij + 3 ) ) ) loc_lim = left_lim ;\n else if ( i && r -> deblock_coefs [ mb_pos ] & ( 1 << ( ij - 1 ) ) ) loc_lim = cur_lim ;\n if ( loc_lim ) rv30_weak_loop_filter ( Y , 1 , s -> linesize , loc_lim ) ;\n }\n }\n for ( k = 0 ;\n k < 2 ;\n k ++ ) {\n int cur_cbp , left_cbp = 0 ;\n cur_cbp = ( r -> cbp_chroma [ mb_pos ] >> ( k * 4 ) ) & 0xF ;\n if ( mb_x ) left_cbp = ( r -> cbp_chroma [ mb_pos - 1 ] >> ( k * 4 ) ) & 0xF ;\n for ( j = 0 ;\n j < 8 ;\n j += 4 ) {\n C = s -> current_picture_ptr -> f . data [ k + 1 ] + mb_x * 8 + ( row * 8 + j ) * s -> uvlinesize + 4 * ! mb_x ;\n for ( i = ! mb_x ;\n i < 2 ;\n i ++ , C += 4 ) {\n int ij = i + ( j >> 1 ) ;\n loc_lim = 0 ;\n if ( cur_cbp & ( 1 << ij ) ) loc_lim = cur_lim ;\n else if ( ! i && left_cbp & ( 1 << ( ij + 1 ) ) ) loc_lim = left_lim ;\n else if ( i && cur_cbp & ( 1 << ( ij - 1 ) ) ) loc_lim = cur_lim ;\n if ( loc_lim ) rv30_weak_loop_filter ( C , 1 , s -> uvlinesize , loc_lim ) ;\n }\n }\n }\n }\n mb_pos = row * s -> mb_stride ;\n for ( mb_x = 0 ;\n mb_x < s -> mb_width ;\n mb_x ++ , mb_pos ++ ) {\n cur_lim = rv30_loop_filt_lim [ s -> current_picture_ptr -> f . qscale_table [ mb_pos ] ] ;\n if ( row ) top_lim = rv30_loop_filt_lim [ s -> current_picture_ptr -> f . qscale_table [ mb_pos - s -> mb_stride ] ] ;\n for ( j = 4 * ! row ;\n j < 16 ;\n j += 4 ) {\n Y = s -> current_picture_ptr -> f . data [ 0 ] + mb_x * 16 + ( row * 16 + j ) * s -> linesize ;\n for ( i = 0 ;\n i < 4 ;\n i ++ , Y += 4 ) {\n int ij = i + j ;\n loc_lim = 0 ;\n if ( r -> deblock_coefs [ mb_pos ] & ( 1 << ij ) ) loc_lim = cur_lim ;\n else if ( ! j && r -> deblock_coefs [ mb_pos - s -> mb_stride ] & ( 1 << ( ij + 12 ) ) ) loc_lim = top_lim ;\n else if ( j && r -> deblock_coefs [ mb_pos ] & ( 1 << ( ij - 4 ) ) ) loc_lim = cur_lim ;\n if ( loc_lim ) rv30_weak_loop_filter ( Y , s -> linesize , 1 , loc_lim ) ;\n }\n }\n for ( k = 0 ;\n k < 2 ;\n k ++ ) {\n int cur_cbp , top_cbp = 0 ;\n cur_cbp = ( r -> cbp_chroma [ mb_pos ] >> ( k * 4 ) ) & 0xF ;\n if ( row ) top_cbp = ( r -> cbp_chroma [ mb_pos - s -> mb_stride ] >> ( k * 4 ) ) & 0xF ;\n for ( j = 4 * ! row ;\n j < 8 ;\n j += 4 ) {\n C = s -> current_picture_ptr -> f . data [ k + 1 ] + mb_x * 8 + ( row * 8 + j ) * s -> uvlinesize ;\n for ( i = 0 ;\n i < 2 ;\n i ++ , C += 4 ) {\n int ij = i + ( j >> 1 ) ;\n loc_lim = 0 ;\n if ( r -> cbp_chroma [ mb_pos ] & ( 1 << ij ) ) loc_lim = cur_lim ;\n else if ( ! j && top_cbp & ( 1 << ( ij + 2 ) ) ) loc_lim = top_lim ;\n else if ( j && cur_cbp & ( 1 << ( ij - 2 ) ) ) loc_lim = cur_lim ;\n if ( loc_lim ) rv30_weak_loop_filter ( C , s -> uvlinesize , 1 , loc_lim ) ;\n }\n }\n }\n }\n }", "hash": -2625033791912996344, "project": "debian", "size": 103, "target": 1, "idx": 20939}
{"code": "static void fill_decode_caches ( H264Context * h , int mb_type ) {\n int topleft_xy , top_xy , topright_xy , left_xy [ LEFT_MBS ] ;\n int topleft_type , top_type , topright_type , left_type [ LEFT_MBS ] ;\n const uint8_t * left_block = h -> left_block ;\n int i ;\n uint8_t * nnz ;\n uint8_t * nnz_cache ;\n topleft_xy = h -> topleft_mb_xy ;\n top_xy = h -> top_mb_xy ;\n topright_xy = h -> topright_mb_xy ;\n left_xy [ LTOP ] = h -> left_mb_xy [ LTOP ] ;\n left_xy [ LBOT ] = h -> left_mb_xy [ LBOT ] ;\n topleft_type = h -> topleft_type ;\n top_type = h -> top_type ;\n topright_type = h -> topright_type ;\n left_type [ LTOP ] = h -> left_type [ LTOP ] ;\n left_type [ LBOT ] = h -> left_type [ LBOT ] ;\n if ( ! IS_SKIP ( mb_type ) ) {\n if ( IS_INTRA ( mb_type ) ) {\n int type_mask = h -> pps . constrained_intra_pred ? IS_INTRA ( - 1 ) : - 1 ;\n h -> topleft_samples_available = h -> top_samples_available = h -> left_samples_available = 0xFFFF ;\n h -> topright_samples_available = 0xEEEA ;\n if ( ! ( top_type & type_mask ) ) {\n h -> topleft_samples_available = 0xB3FF ;\n h -> top_samples_available = 0x33FF ;\n h -> topright_samples_available = 0x26EA ;\n }\n if ( IS_INTERLACED ( mb_type ) != IS_INTERLACED ( left_type [ LTOP ] ) ) {\n if ( IS_INTERLACED ( mb_type ) ) {\n if ( ! ( left_type [ LTOP ] & type_mask ) ) {\n h -> topleft_samples_available &= 0xDFFF ;\n h -> left_samples_available &= 0x5FFF ;\n }\n if ( ! ( left_type [ LBOT ] & type_mask ) ) {\n h -> topleft_samples_available &= 0xFF5F ;\n h -> left_samples_available &= 0xFF5F ;\n }\n }\n else {\n int left_typei = h -> cur_pic . f . mb_type [ left_xy [ LTOP ] + h -> mb_stride ] ;\n assert ( left_xy [ LTOP ] == left_xy [ LBOT ] ) ;\n if ( ! ( ( left_typei & type_mask ) && ( left_type [ LTOP ] & type_mask ) ) ) {\n h -> topleft_samples_available &= 0xDF5F ;\n h -> left_samples_available &= 0x5F5F ;\n }\n }\n }\n else {\n if ( ! ( left_type [ LTOP ] & type_mask ) ) {\n h -> topleft_samples_available &= 0xDF5F ;\n h -> left_samples_available &= 0x5F5F ;\n }\n }\n if ( ! ( topleft_type & type_mask ) ) h -> topleft_samples_available &= 0x7FFF ;\n if ( ! ( topright_type & type_mask ) ) h -> topright_samples_available &= 0xFBFF ;\n if ( IS_INTRA4x4 ( mb_type ) ) {\n if ( IS_INTRA4x4 ( top_type ) ) {\n AV_COPY32 ( h -> intra4x4_pred_mode_cache + 4 + 8 * 0 , h -> intra4x4_pred_mode + h -> mb2br_xy [ top_xy ] ) ;\n }\n else {\n h -> intra4x4_pred_mode_cache [ 4 + 8 * 0 ] = h -> intra4x4_pred_mode_cache [ 5 + 8 * 0 ] = h -> intra4x4_pred_mode_cache [ 6 + 8 * 0 ] = h -> intra4x4_pred_mode_cache [ 7 + 8 * 0 ] = 2 - 3 * ! ( top_type & type_mask ) ;\n }\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n if ( IS_INTRA4x4 ( left_type [ LEFT ( i ) ] ) ) {\n int8_t * mode = h -> intra4x4_pred_mode + h -> mb2br_xy [ left_xy [ LEFT ( i ) ] ] ;\n h -> intra4x4_pred_mode_cache [ 3 + 8 * 1 + 2 * 8 * i ] = mode [ 6 - left_block [ 0 + 2 * i ] ] ;\n h -> intra4x4_pred_mode_cache [ 3 + 8 * 2 + 2 * 8 * i ] = mode [ 6 - left_block [ 1 + 2 * i ] ] ;\n }\n else {\n h -> intra4x4_pred_mode_cache [ 3 + 8 * 1 + 2 * 8 * i ] = h -> intra4x4_pred_mode_cache [ 3 + 8 * 2 + 2 * 8 * i ] = 2 - 3 * ! ( left_type [ LEFT ( i ) ] & type_mask ) ;\n }\n }\n }\n }\n nnz_cache = h -> non_zero_count_cache ;\n if ( top_type ) {\n nnz = h -> non_zero_count [ top_xy ] ;\n AV_COPY32 ( & nnz_cache [ 4 + 8 * 0 ] , & nnz [ 4 * 3 ] ) ;\n if ( ! h -> chroma_y_shift ) {\n AV_COPY32 ( & nnz_cache [ 4 + 8 * 5 ] , & nnz [ 4 * 7 ] ) ;\n AV_COPY32 ( & nnz_cache [ 4 + 8 * 10 ] , & nnz [ 4 * 11 ] ) ;\n }\n else {\n AV_COPY32 ( & nnz_cache [ 4 + 8 * 5 ] , & nnz [ 4 * 5 ] ) ;\n AV_COPY32 ( & nnz_cache [ 4 + 8 * 10 ] , & nnz [ 4 * 9 ] ) ;\n }\n }\n else {\n uint32_t top_empty = CABAC && ! IS_INTRA ( mb_type ) ? 0 : 0x40404040 ;\n AV_WN32A ( & nnz_cache [ 4 + 8 * 0 ] , top_empty ) ;\n AV_WN32A ( & nnz_cache [ 4 + 8 * 5 ] , top_empty ) ;\n AV_WN32A ( & nnz_cache [ 4 + 8 * 10 ] , top_empty ) ;\n }\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n if ( left_type [ LEFT ( i ) ] ) {\n nnz = h -> non_zero_count [ left_xy [ LEFT ( i ) ] ] ;\n nnz_cache [ 3 + 8 * 1 + 2 * 8 * i ] = nnz [ left_block [ 8 + 0 + 2 * i ] ] ;\n nnz_cache [ 3 + 8 * 2 + 2 * 8 * i ] = nnz [ left_block [ 8 + 1 + 2 * i ] ] ;\n if ( CHROMA444 ) {\n nnz_cache [ 3 + 8 * 6 + 2 * 8 * i ] = nnz [ left_block [ 8 + 0 + 2 * i ] + 4 * 4 ] ;\n nnz_cache [ 3 + 8 * 7 + 2 * 8 * i ] = nnz [ left_block [ 8 + 1 + 2 * i ] + 4 * 4 ] ;\n nnz_cache [ 3 + 8 * 11 + 2 * 8 * i ] = nnz [ left_block [ 8 + 0 + 2 * i ] + 8 * 4 ] ;\n nnz_cache [ 3 + 8 * 12 + 2 * 8 * i ] = nnz [ left_block [ 8 + 1 + 2 * i ] + 8 * 4 ] ;\n }\n else if ( CHROMA422 ) {\n nnz_cache [ 3 + 8 * 6 + 2 * 8 * i ] = nnz [ left_block [ 8 + 0 + 2 * i ] - 2 + 4 * 4 ] ;\n nnz_cache [ 3 + 8 * 7 + 2 * 8 * i ] = nnz [ left_block [ 8 + 1 + 2 * i ] - 2 + 4 * 4 ] ;\n nnz_cache [ 3 + 8 * 11 + 2 * 8 * i ] = nnz [ left_block [ 8 + 0 + 2 * i ] - 2 + 8 * 4 ] ;\n nnz_cache [ 3 + 8 * 12 + 2 * 8 * i ] = nnz [ left_block [ 8 + 1 + 2 * i ] - 2 + 8 * 4 ] ;\n }\n else {\n nnz_cache [ 3 + 8 * 6 + 8 * i ] = nnz [ left_block [ 8 + 4 + 2 * i ] ] ;\n nnz_cache [ 3 + 8 * 11 + 8 * i ] = nnz [ left_block [ 8 + 5 + 2 * i ] ] ;\n }\n }\n else {\n nnz_cache [ 3 + 8 * 1 + 2 * 8 * i ] = nnz_cache [ 3 + 8 * 2 + 2 * 8 * i ] = nnz_cache [ 3 + 8 * 6 + 2 * 8 * i ] = nnz_cache [ 3 + 8 * 7 + 2 * 8 * i ] = nnz_cache [ 3 + 8 * 11 + 2 * 8 * i ] = nnz_cache [ 3 + 8 * 12 + 2 * 8 * i ] = CABAC && ! IS_INTRA ( mb_type ) ? 0 : 64 ;\n }\n }\n if ( CABAC ) {\n if ( top_type ) h -> top_cbp = h -> cbp_table [ top_xy ] ;\n else h -> top_cbp = IS_INTRA ( mb_type ) ? 0x7CF : 0x00F ;\n if ( left_type [ LTOP ] ) {\n h -> left_cbp = ( h -> cbp_table [ left_xy [ LTOP ] ] & 0x7F0 ) | ( ( h -> cbp_table [ left_xy [ LTOP ] ] >> ( left_block [ 0 ] & ( ~ 1 ) ) ) & 2 ) | ( ( ( h -> cbp_table [ left_xy [ LBOT ] ] >> ( left_block [ 2 ] & ( ~ 1 ) ) ) & 2 ) << 2 ) ;\n }\n else {\n h -> left_cbp = IS_INTRA ( mb_type ) ? 0x7CF : 0x00F ;\n }\n }\n }\n if ( IS_INTER ( mb_type ) || ( IS_DIRECT ( mb_type ) && h -> direct_spatial_mv_pred ) ) {\n int list ;\n int b_stride = h -> b_stride ;\n for ( list = 0 ;\n list < h -> list_count ;\n list ++ ) {\n int8_t * ref_cache = & h -> ref_cache [ list ] [ scan8 [ 0 ] ] ;\n int8_t * ref = h -> cur_pic . f . ref_index [ list ] ;\n int16_t ( * mv_cache ) [ 2 ] = & h -> mv_cache [ list ] [ scan8 [ 0 ] ] ;\n int16_t ( * mv ) [ 2 ] = h -> cur_pic . f . motion_val [ list ] ;\n if ( ! USES_LIST ( mb_type , list ) ) continue ;\n assert ( ! ( IS_DIRECT ( mb_type ) && ! h -> direct_spatial_mv_pred ) ) ;\n if ( USES_LIST ( top_type , list ) ) {\n const int b_xy = h -> mb2b_xy [ top_xy ] + 3 * b_stride ;\n AV_COPY128 ( mv_cache [ 0 - 1 * 8 ] , mv [ b_xy + 0 ] ) ;\n ref_cache [ 0 - 1 * 8 ] = ref_cache [ 1 - 1 * 8 ] = ref [ 4 * top_xy + 2 ] ;\n ref_cache [ 2 - 1 * 8 ] = ref_cache [ 3 - 1 * 8 ] = ref [ 4 * top_xy + 3 ] ;\n }\n else {\n AV_ZERO128 ( mv_cache [ 0 - 1 * 8 ] ) ;\n AV_WN32A ( & ref_cache [ 0 - 1 * 8 ] , ( ( top_type ? LIST_NOT_USED : PART_NOT_AVAILABLE ) & 0xFF ) * 0x01010101u ) ;\n }\n if ( mb_type & ( MB_TYPE_16x8 | MB_TYPE_8x8 ) ) {\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n int cache_idx = - 1 + i * 2 * 8 ;\n if ( USES_LIST ( left_type [ LEFT ( i ) ] , list ) ) {\n const int b_xy = h -> mb2b_xy [ left_xy [ LEFT ( i ) ] ] + 3 ;\n const int b8_xy = 4 * left_xy [ LEFT ( i ) ] + 1 ;\n AV_COPY32 ( mv_cache [ cache_idx ] , mv [ b_xy + b_stride * left_block [ 0 + i * 2 ] ] ) ;\n AV_COPY32 ( mv_cache [ cache_idx + 8 ] , mv [ b_xy + b_stride * left_block [ 1 + i * 2 ] ] ) ;\n ref_cache [ cache_idx ] = ref [ b8_xy + ( left_block [ 0 + i * 2 ] & ~ 1 ) ] ;\n ref_cache [ cache_idx + 8 ] = ref [ b8_xy + ( left_block [ 1 + i * 2 ] & ~ 1 ) ] ;\n }\n else {\n AV_ZERO32 ( mv_cache [ cache_idx ] ) ;\n AV_ZERO32 ( mv_cache [ cache_idx + 8 ] ) ;\n ref_cache [ cache_idx ] = ref_cache [ cache_idx + 8 ] = ( left_type [ LEFT ( i ) ] ) ? LIST_NOT_USED : PART_NOT_AVAILABLE ;\n }\n }\n }\n else {\n if ( USES_LIST ( left_type [ LTOP ] , list ) ) {\n const int b_xy = h -> mb2b_xy [ left_xy [ LTOP ] ] + 3 ;\n const int b8_xy = 4 * left_xy [ LTOP ] + 1 ;\n AV_COPY32 ( mv_cache [ - 1 ] , mv [ b_xy + b_stride * left_block [ 0 ] ] ) ;\n ref_cache [ - 1 ] = ref [ b8_xy + ( left_block [ 0 ] & ~ 1 ) ] ;\n }\n else {\n AV_ZERO32 ( mv_cache [ - 1 ] ) ;\n ref_cache [ - 1 ] = left_type [ LTOP ] ? LIST_NOT_USED : PART_NOT_AVAILABLE ;\n }\n }\n if ( USES_LIST ( topright_type , list ) ) {\n const int b_xy = h -> mb2b_xy [ topright_xy ] + 3 * b_stride ;\n AV_COPY32 ( mv_cache [ 4 - 1 * 8 ] , mv [ b_xy ] ) ;\n ref_cache [ 4 - 1 * 8 ] = ref [ 4 * topright_xy + 2 ] ;\n }\n else {\n AV_ZERO32 ( mv_cache [ 4 - 1 * 8 ] ) ;\n ref_cache [ 4 - 1 * 8 ] = topright_type ? LIST_NOT_USED : PART_NOT_AVAILABLE ;\n }\n if ( ref_cache [ 4 - 1 * 8 ] < 0 ) {\n if ( USES_LIST ( topleft_type , list ) ) {\n const int b_xy = h -> mb2b_xy [ topleft_xy ] + 3 + b_stride + ( h -> topleft_partition & 2 * b_stride ) ;\n const int b8_xy = 4 * topleft_xy + 1 + ( h -> topleft_partition & 2 ) ;\n AV_COPY32 ( mv_cache [ - 1 - 1 * 8 ] , mv [ b_xy ] ) ;\n ref_cache [ - 1 - 1 * 8 ] = ref [ b8_xy ] ;\n }\n else {\n AV_ZERO32 ( mv_cache [ - 1 - 1 * 8 ] ) ;\n ref_cache [ - 1 - 1 * 8 ] = topleft_type ? LIST_NOT_USED : PART_NOT_AVAILABLE ;\n }\n }\n if ( ( mb_type & ( MB_TYPE_SKIP | MB_TYPE_DIRECT2 ) ) && ! FRAME_MBAFF ) continue ;\n if ( ! ( mb_type & ( MB_TYPE_SKIP | MB_TYPE_DIRECT2 ) ) ) {\n uint8_t ( * mvd_cache ) [ 2 ] = & h -> mvd_cache [ list ] [ scan8 [ 0 ] ] ;\n uint8_t ( * mvd ) [ 2 ] = h -> mvd_table [ list ] ;\n ref_cache [ 2 + 8 * 0 ] = ref_cache [ 2 + 8 * 2 ] = PART_NOT_AVAILABLE ;\n AV_ZERO32 ( mv_cache [ 2 + 8 * 0 ] ) ;\n AV_ZERO32 ( mv_cache [ 2 + 8 * 2 ] ) ;\n if ( CABAC ) {\n if ( USES_LIST ( top_type , list ) ) {\n const int b_xy = h -> mb2br_xy [ top_xy ] ;\n AV_COPY64 ( mvd_cache [ 0 - 1 * 8 ] , mvd [ b_xy + 0 ] ) ;\n }\n else {\n AV_ZERO64 ( mvd_cache [ 0 - 1 * 8 ] ) ;\n }\n if ( USES_LIST ( left_type [ LTOP ] , list ) ) {\n const int b_xy = h -> mb2br_xy [ left_xy [ LTOP ] ] + 6 ;\n AV_COPY16 ( mvd_cache [ - 1 + 0 * 8 ] , mvd [ b_xy - left_block [ 0 ] ] ) ;\n AV_COPY16 ( mvd_cache [ - 1 + 1 * 8 ] , mvd [ b_xy - left_block [ 1 ] ] ) ;\n }\n else {\n AV_ZERO16 ( mvd_cache [ - 1 + 0 * 8 ] ) ;\n AV_ZERO16 ( mvd_cache [ - 1 + 1 * 8 ] ) ;\n }\n if ( USES_LIST ( left_type [ LBOT ] , list ) ) {\n const int b_xy = h -> mb2br_xy [ left_xy [ LBOT ] ] + 6 ;\n AV_COPY16 ( mvd_cache [ - 1 + 2 * 8 ] , mvd [ b_xy - left_block [ 2 ] ] ) ;\n AV_COPY16 ( mvd_cache [ - 1 + 3 * 8 ] , mvd [ b_xy - left_block [ 3 ] ] ) ;\n }\n else {\n AV_ZERO16 ( mvd_cache [ - 1 + 2 * 8 ] ) ;\n AV_ZERO16 ( mvd_cache [ - 1 + 3 * 8 ] ) ;\n }\n AV_ZERO16 ( mvd_cache [ 2 + 8 * 0 ] ) ;\n AV_ZERO16 ( mvd_cache [ 2 + 8 * 2 ] ) ;\n if ( h -> slice_type_nos == AV_PICTURE_TYPE_B ) {\n uint8_t * direct_cache = & h -> direct_cache [ scan8 [ 0 ] ] ;\n uint8_t * direct_table = h -> direct_table ;\n fill_rectangle ( direct_cache , 4 , 4 , 8 , MB_TYPE_16x16 >> 1 , 1 ) ;\n if ( IS_DIRECT ( top_type ) ) {\n AV_WN32A ( & direct_cache [ - 1 * 8 ] , 0x01010101u * ( MB_TYPE_DIRECT2 >> 1 ) ) ;\n }\n else if ( IS_8X8 ( top_type ) ) {\n int b8_xy = 4 * top_xy ;\n direct_cache [ 0 - 1 * 8 ] = direct_table [ b8_xy + 2 ] ;\n direct_cache [ 2 - 1 * 8 ] = direct_table [ b8_xy + 3 ] ;\n }\n else {\n AV_WN32A ( & direct_cache [ - 1 * 8 ] , 0x01010101 * ( MB_TYPE_16x16 >> 1 ) ) ;\n }\n if ( IS_DIRECT ( left_type [ LTOP ] ) ) direct_cache [ - 1 + 0 * 8 ] = MB_TYPE_DIRECT2 >> 1 ;\n else if ( IS_8X8 ( left_type [ LTOP ] ) ) direct_cache [ - 1 + 0 * 8 ] = direct_table [ 4 * left_xy [ LTOP ] + 1 + ( left_block [ 0 ] & ~ 1 ) ] ;\n else direct_cache [ - 1 + 0 * 8 ] = MB_TYPE_16x16 >> 1 ;\n if ( IS_DIRECT ( left_type [ LBOT ] ) ) direct_cache [ - 1 + 2 * 8 ] = MB_TYPE_DIRECT2 >> 1 ;\n else if ( IS_8X8 ( left_type [ LBOT ] ) ) direct_cache [ - 1 + 2 * 8 ] = direct_table [ 4 * left_xy [ LBOT ] + 1 + ( left_block [ 2 ] & ~ 1 ) ] ;\n else direct_cache [ - 1 + 2 * 8 ] = MB_TYPE_16x16 >> 1 ;\n }\n }\n }\n # define MAP_MVS MAP_F2F ( scan8 [ 0 ] - 1 - 1 * 8 , topleft_type ) MAP_F2F ( scan8 [ 0 ] + 0 - 1 * 8 , top_type ) MAP_F2F ( scan8 [ 0 ] + 1 - 1 * 8 , top_type ) MAP_F2F ( scan8 [ 0 ] + 2 - 1 * 8 , top_type ) MAP_F2F ( scan8 [ 0 ] + 3 - 1 * 8 , top_type ) MAP_F2F ( scan8 [ 0 ] + 4 - 1 * 8 , topright_type ) MAP_F2F ( scan8 [ 0 ] - 1 + 0 * 8 , left_type [ LTOP ] ) MAP_F2F ( scan8 [ 0 ] - 1 + 1 * 8 , left_type [ LTOP ] ) MAP_F2F ( scan8 [ 0 ] - 1 + 2 * 8 , left_type [ LBOT ] ) MAP_F2F ( scan8 [ 0 ] - 1 + 3 * 8 , left_type [ LBOT ] ) if ( FRAME_MBAFF ) {\n if ( MB_FIELD ) {\n # define MAP_F2F ( idx , mb_type ) if ( ! IS_INTERLACED ( mb_type ) && h -> ref_cache [ list ] [ idx ] >= 0 ) {\n h -> ref_cache [ list ] [ idx ] <<= 1 ;\n h -> mv_cache [ list ] [ idx ] [ 1 ] /= 2 ;\n h -> mvd_cache [ list ] [ idx ] [ 1 ] >>= 1 ;\n }\n MAP_MVS }\n else {\n # undef MAP_F2F # define MAP_F2F ( idx , mb_type ) if ( IS_INTERLACED ( mb_type ) && h -> ref_cache [ list ] [ idx ] >= 0 ) {\n h -> ref_cache [ list ] [ idx ] >>= 1 ;\n h -> mv_cache [ list ] [ idx ] [ 1 ] <<= 1 ;\n h -> mvd_cache [ list ] [ idx ] [ 1 ] <<= 1 ;\n }\n MAP_MVS # undef MAP_F2F }\n }\n }\n }\n h -> neighbor_transform_size = ! ! IS_8x8DCT ( top_type ) + ! ! IS_8x8DCT ( left_type [ LTOP ] ) ;\n }", "hash": 6878874717615726198, "project": "debian", "size": 288, "target": 1, "idx": 20948}
{"code": "static inline int unreference_pic ( H264Context * h , Picture * pic , int refmask ) {\n int i ;\n if ( pic -> f . reference &= refmask ) {\n return 0 ;\n }\n else {\n for ( i = 0 ;\n h -> delayed_pic [ i ] ;\n i ++ ) if ( pic == h -> delayed_pic [ i ] ) {\n pic -> f . reference = DELAYED_PIC_REF ;\n break ;\n }\n return 1 ;\n }\n }", "hash": -1658505547857059267, "project": "debian", "size": 15, "target": 1, "idx": 20959}
{"code": "static void pred_spatial_direct_motion ( H264Context * const h , int * mb_type ) {\n int b8_stride = 2 ;\n int b4_stride = h -> b_stride ;\n int mb_xy = h -> mb_xy , mb_y = h -> mb_y ;\n int mb_type_col [ 2 ] ;\n const int16_t ( * l1mv0 ) [ 2 ] , ( * l1mv1 ) [ 2 ] ;\n const int8_t * l1ref0 , * l1ref1 ;\n const int is_b8x8 = IS_8X8 ( * mb_type ) ;\n unsigned int sub_mb_type = MB_TYPE_L0L1 ;\n int i8 , i4 ;\n int ref [ 2 ] ;\n int mv [ 2 ] ;\n int list ;\n assert ( h -> ref_list [ 1 ] [ 0 ] . f . reference & 3 ) ;\n await_reference_mb_row ( h , & h -> ref_list [ 1 ] [ 0 ] , h -> mb_y + ! ! IS_INTERLACED ( * mb_type ) ) ;\n # define MB_TYPE_16x16_OR_INTRA ( MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM ) for ( list = 0 ;\n list < 2 ;\n list ++ ) {\n int left_ref = h -> ref_cache [ list ] [ scan8 [ 0 ] - 1 ] ;\n int top_ref = h -> ref_cache [ list ] [ scan8 [ 0 ] - 8 ] ;\n int refc = h -> ref_cache [ list ] [ scan8 [ 0 ] - 8 + 4 ] ;\n const int16_t * C = h -> mv_cache [ list ] [ scan8 [ 0 ] - 8 + 4 ] ;\n if ( refc == PART_NOT_AVAILABLE ) {\n refc = h -> ref_cache [ list ] [ scan8 [ 0 ] - 8 - 1 ] ;\n C = h -> mv_cache [ list ] [ scan8 [ 0 ] - 8 - 1 ] ;\n }\n ref [ list ] = FFMIN3 ( ( unsigned ) left_ref , ( unsigned ) top_ref , ( unsigned ) refc ) ;\n if ( ref [ list ] >= 0 ) {\n const int16_t * const A = h -> mv_cache [ list ] [ scan8 [ 0 ] - 1 ] ;\n const int16_t * const B = h -> mv_cache [ list ] [ scan8 [ 0 ] - 8 ] ;\n int match_count = ( left_ref == ref [ list ] ) + ( top_ref == ref [ list ] ) + ( refc == ref [ list ] ) ;\n if ( match_count > 1 ) {\n mv [ list ] = pack16to32 ( mid_pred ( A [ 0 ] , B [ 0 ] , C [ 0 ] ) , mid_pred ( A [ 1 ] , B [ 1 ] , C [ 1 ] ) ) ;\n }\n else {\n assert ( match_count == 1 ) ;\n if ( left_ref == ref [ list ] ) {\n mv [ list ] = AV_RN32A ( A ) ;\n }\n else if ( top_ref == ref [ list ] ) {\n mv [ list ] = AV_RN32A ( B ) ;\n }\n else {\n mv [ list ] = AV_RN32A ( C ) ;\n }\n }\n }\n else {\n int mask = ~ ( MB_TYPE_L0 << ( 2 * list ) ) ;\n mv [ list ] = 0 ;\n ref [ list ] = - 1 ;\n if ( ! is_b8x8 ) * mb_type &= mask ;\n sub_mb_type &= mask ;\n }\n }\n if ( ref [ 0 ] < 0 && ref [ 1 ] < 0 ) {\n ref [ 0 ] = ref [ 1 ] = 0 ;\n if ( ! is_b8x8 ) * mb_type |= MB_TYPE_L0L1 ;\n sub_mb_type |= MB_TYPE_L0L1 ;\n }\n if ( ! ( is_b8x8 | mv [ 0 ] | mv [ 1 ] ) ) {\n fill_rectangle ( & h -> ref_cache [ 0 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , ( uint8_t ) ref [ 0 ] , 1 ) ;\n fill_rectangle ( & h -> ref_cache [ 1 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , ( uint8_t ) ref [ 1 ] , 1 ) ;\n fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , 0 , 4 ) ;\n fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , 0 , 4 ) ;\n * mb_type = ( * mb_type & ~ ( MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1 ) ) | MB_TYPE_16x16 | MB_TYPE_DIRECT2 ;\n return ;\n }\n if ( IS_INTERLACED ( h -> ref_list [ 1 ] [ 0 ] . f . mb_type [ mb_xy ] ) ) {\n if ( ! IS_INTERLACED ( * mb_type ) ) {\n mb_y = ( h -> mb_y & ~ 1 ) + h -> col_parity ;\n mb_xy = h -> mb_x + ( ( h -> mb_y & ~ 1 ) + h -> col_parity ) * h -> mb_stride ;\n b8_stride = 0 ;\n }\n else {\n mb_y += h -> col_fieldoff ;\n mb_xy += h -> mb_stride * h -> col_fieldoff ;\n }\n goto single_col ;\n }\n else {\n if ( IS_INTERLACED ( * mb_type ) ) {\n mb_y = h -> mb_y & ~ 1 ;\n mb_xy = h -> mb_x + ( h -> mb_y & ~ 1 ) * h -> mb_stride ;\n mb_type_col [ 0 ] = h -> ref_list [ 1 ] [ 0 ] . f . mb_type [ mb_xy ] ;\n mb_type_col [ 1 ] = h -> ref_list [ 1 ] [ 0 ] . f . mb_type [ mb_xy + h -> mb_stride ] ;\n b8_stride = 2 + 4 * h -> mb_stride ;\n b4_stride *= 6 ;\n if ( IS_INTERLACED ( mb_type_col [ 0 ] ) != IS_INTERLACED ( mb_type_col [ 1 ] ) ) {\n mb_type_col [ 0 ] &= ~ MB_TYPE_INTERLACED ;\n mb_type_col [ 1 ] &= ~ MB_TYPE_INTERLACED ;\n }\n sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2 ;\n if ( ( mb_type_col [ 0 ] & MB_TYPE_16x16_OR_INTRA ) && ( mb_type_col [ 1 ] & MB_TYPE_16x16_OR_INTRA ) && ! is_b8x8 ) {\n * mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2 ;\n }\n else {\n * mb_type |= MB_TYPE_8x8 ;\n }\n }\n else {\n single_col : mb_type_col [ 0 ] = mb_type_col [ 1 ] = h -> ref_list [ 1 ] [ 0 ] . f . mb_type [ mb_xy ] ;\n sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2 ;\n if ( ! is_b8x8 && ( mb_type_col [ 0 ] & MB_TYPE_16x16_OR_INTRA ) ) {\n * mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2 ;\n }\n else if ( ! is_b8x8 && ( mb_type_col [ 0 ] & ( MB_TYPE_16x8 | MB_TYPE_8x16 ) ) ) {\n * mb_type |= MB_TYPE_DIRECT2 | ( mb_type_col [ 0 ] & ( MB_TYPE_16x8 | MB_TYPE_8x16 ) ) ;\n }\n else {\n if ( ! h -> sps . direct_8x8_inference_flag ) {\n sub_mb_type += ( MB_TYPE_8x8 - MB_TYPE_16x16 ) ;\n }\n * mb_type |= MB_TYPE_8x8 ;\n }\n }\n }\n await_reference_mb_row ( h , & h -> ref_list [ 1 ] [ 0 ] , mb_y ) ;\n l1mv0 = & h -> ref_list [ 1 ] [ 0 ] . f . motion_val [ 0 ] [ h -> mb2b_xy [ mb_xy ] ] ;\n l1mv1 = & h -> ref_list [ 1 ] [ 0 ] . f . motion_val [ 1 ] [ h -> mb2b_xy [ mb_xy ] ] ;\n l1ref0 = & h -> ref_list [ 1 ] [ 0 ] . f . ref_index [ 0 ] [ 4 * mb_xy ] ;\n l1ref1 = & h -> ref_list [ 1 ] [ 0 ] . f . ref_index [ 1 ] [ 4 * mb_xy ] ;\n if ( ! b8_stride ) {\n if ( h -> mb_y & 1 ) {\n l1ref0 += 2 ;\n l1ref1 += 2 ;\n l1mv0 += 2 * b4_stride ;\n l1mv1 += 2 * b4_stride ;\n }\n }\n if ( IS_INTERLACED ( * mb_type ) != IS_INTERLACED ( mb_type_col [ 0 ] ) ) {\n int n = 0 ;\n for ( i8 = 0 ;\n i8 < 4 ;\n i8 ++ ) {\n int x8 = i8 & 1 ;\n int y8 = i8 >> 1 ;\n int xy8 = x8 + y8 * b8_stride ;\n int xy4 = 3 * x8 + y8 * b4_stride ;\n int a , b ;\n if ( is_b8x8 && ! IS_DIRECT ( h -> sub_mb_type [ i8 ] ) ) continue ;\n h -> sub_mb_type [ i8 ] = sub_mb_type ;\n fill_rectangle ( & h -> ref_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , ( uint8_t ) ref [ 0 ] , 1 ) ;\n fill_rectangle ( & h -> ref_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , ( uint8_t ) ref [ 1 ] , 1 ) ;\n if ( ! IS_INTRA ( mb_type_col [ y8 ] ) && ! h -> ref_list [ 1 ] [ 0 ] . long_ref && ( ( l1ref0 [ xy8 ] == 0 && FFABS ( l1mv0 [ xy4 ] [ 0 ] ) <= 1 && FFABS ( l1mv0 [ xy4 ] [ 1 ] ) <= 1 ) || ( l1ref0 [ xy8 ] < 0 && l1ref1 [ xy8 ] == 0 && FFABS ( l1mv1 [ xy4 ] [ 0 ] ) <= 1 && FFABS ( l1mv1 [ xy4 ] [ 1 ] ) <= 1 ) ) ) {\n a = b = 0 ;\n if ( ref [ 0 ] > 0 ) a = mv [ 0 ] ;\n if ( ref [ 1 ] > 0 ) b = mv [ 1 ] ;\n n ++ ;\n }\n else {\n a = mv [ 0 ] ;\n b = mv [ 1 ] ;\n }\n fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , a , 4 ) ;\n fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , b , 4 ) ;\n }\n if ( ! is_b8x8 && ! ( n & 3 ) ) * mb_type = ( * mb_type & ~ ( MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1 ) ) | MB_TYPE_16x16 | MB_TYPE_DIRECT2 ;\n }\n else if ( IS_16X16 ( * mb_type ) ) {\n int a , b ;\n fill_rectangle ( & h -> ref_cache [ 0 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , ( uint8_t ) ref [ 0 ] , 1 ) ;\n fill_rectangle ( & h -> ref_cache [ 1 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , ( uint8_t ) ref [ 1 ] , 1 ) ;\n if ( ! IS_INTRA ( mb_type_col [ 0 ] ) && ! h -> ref_list [ 1 ] [ 0 ] . long_ref && ( ( l1ref0 [ 0 ] == 0 && FFABS ( l1mv0 [ 0 ] [ 0 ] ) <= 1 && FFABS ( l1mv0 [ 0 ] [ 1 ] ) <= 1 ) || ( l1ref0 [ 0 ] < 0 && l1ref1 [ 0 ] == 0 && FFABS ( l1mv1 [ 0 ] [ 0 ] ) <= 1 && FFABS ( l1mv1 [ 0 ] [ 1 ] ) <= 1 && h -> x264_build > 33U ) ) ) {\n a = b = 0 ;\n if ( ref [ 0 ] > 0 ) a = mv [ 0 ] ;\n if ( ref [ 1 ] > 0 ) b = mv [ 1 ] ;\n }\n else {\n a = mv [ 0 ] ;\n b = mv [ 1 ] ;\n }\n fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , a , 4 ) ;\n fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , b , 4 ) ;\n }\n else {\n int n = 0 ;\n for ( i8 = 0 ;\n i8 < 4 ;\n i8 ++ ) {\n const int x8 = i8 & 1 ;\n const int y8 = i8 >> 1 ;\n if ( is_b8x8 && ! IS_DIRECT ( h -> sub_mb_type [ i8 ] ) ) continue ;\n h -> sub_mb_type [ i8 ] = sub_mb_type ;\n fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , mv [ 0 ] , 4 ) ;\n fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , mv [ 1 ] , 4 ) ;\n fill_rectangle ( & h -> ref_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , ( uint8_t ) ref [ 0 ] , 1 ) ;\n fill_rectangle ( & h -> ref_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , ( uint8_t ) ref [ 1 ] , 1 ) ;\n assert ( b8_stride == 2 ) ;\n if ( ! IS_INTRA ( mb_type_col [ 0 ] ) && ! h -> ref_list [ 1 ] [ 0 ] . long_ref && ( l1ref0 [ i8 ] == 0 || ( l1ref0 [ i8 ] < 0 && l1ref1 [ i8 ] == 0 && h -> x264_build > 33U ) ) ) {\n const int16_t ( * l1mv ) [ 2 ] = l1ref0 [ i8 ] == 0 ? l1mv0 : l1mv1 ;\n if ( IS_SUB_8X8 ( sub_mb_type ) ) {\n const int16_t * mv_col = l1mv [ x8 * 3 + y8 * 3 * b4_stride ] ;\n if ( FFABS ( mv_col [ 0 ] ) <= 1 && FFABS ( mv_col [ 1 ] ) <= 1 ) {\n if ( ref [ 0 ] == 0 ) fill_rectangle ( & h -> mv_cache [ 0 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , 0 , 4 ) ;\n if ( ref [ 1 ] == 0 ) fill_rectangle ( & h -> mv_cache [ 1 ] [ scan8 [ i8 * 4 ] ] , 2 , 2 , 8 , 0 , 4 ) ;\n n += 4 ;\n }\n }\n else {\n int m = 0 ;\n for ( i4 = 0 ;\n i4 < 4 ;\n i4 ++ ) {\n const int16_t * mv_col = l1mv [ x8 * 2 + ( i4 & 1 ) + ( y8 * 2 + ( i4 >> 1 ) ) * b4_stride ] ;\n if ( FFABS ( mv_col [ 0 ] ) <= 1 && FFABS ( mv_col [ 1 ] ) <= 1 ) {\n if ( ref [ 0 ] == 0 ) AV_ZERO32 ( h -> mv_cache [ 0 ] [ scan8 [ i8 * 4 + i4 ] ] ) ;\n if ( ref [ 1 ] == 0 ) AV_ZERO32 ( h -> mv_cache [ 1 ] [ scan8 [ i8 * 4 + i4 ] ] ) ;\n m ++ ;\n }\n }\n if ( ! ( m & 3 ) ) h -> sub_mb_type [ i8 ] += MB_TYPE_16x16 - MB_TYPE_8x8 ;\n n += m ;\n }\n }\n }\n if ( ! is_b8x8 && ! ( n & 15 ) ) * mb_type = ( * mb_type & ~ ( MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 | MB_TYPE_P1L0 | MB_TYPE_P1L1 ) ) | MB_TYPE_16x16 | MB_TYPE_DIRECT2 ;\n }\n }", "hash": 1743019814289113128, "project": "debian", "size": 219, "target": 1, "idx": 20968}
{"code": "static int xan_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int ret , buf_size = avpkt -> size ;\n XanContext * s = avctx -> priv_data ;\n GetByteContext ctx ;\n int tag = 0 ;\n bytestream2_init ( & ctx , buf , buf_size ) ;\n while ( bytestream2_get_bytes_left ( & ctx ) > 8 && tag != VGA__TAG ) {\n unsigned * tmpptr ;\n uint32_t new_pal ;\n int size ;\n int i ;\n tag = bytestream2_get_le32 ( & ctx ) ;\n size = bytestream2_get_be32 ( & ctx ) ;\n size = FFMIN ( size , bytestream2_get_bytes_left ( & ctx ) ) ;\n switch ( tag ) {\n case PALT_TAG : if ( size < PALETTE_SIZE ) return AVERROR_INVALIDDATA ;\n if ( s -> palettes_count >= PALETTES_MAX ) return AVERROR_INVALIDDATA ;\n tmpptr = av_realloc ( s -> palettes , ( s -> palettes_count + 1 ) * AVPALETTE_SIZE ) ;\n if ( ! tmpptr ) return AVERROR ( ENOMEM ) ;\n s -> palettes = tmpptr ;\n tmpptr += s -> palettes_count * AVPALETTE_COUNT ;\n for ( i = 0 ;\n i < PALETTE_COUNT ;\n i ++ ) {\n # if RUNTIME_GAMMA int r = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n int g = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n int b = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n # else int r = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n int g = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n int b = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n # endif * tmpptr ++ = ( r << 16 ) | ( g << 8 ) | b ;\n }\n s -> palettes_count ++ ;\n break ;\n case SHOT_TAG : if ( size < 4 ) return AVERROR_INVALIDDATA ;\n new_pal = bytestream2_get_le32 ( & ctx ) ;\n if ( new_pal < s -> palettes_count ) {\n s -> cur_palette = new_pal ;\n }\n else av_log ( avctx , AV_LOG_ERROR , \"Invalid palette selected\\n\" ) ;\n break ;\n case VGA__TAG : break ;\n default : bytestream2_skip ( & ctx , size ) ;\n break ;\n }\n }\n buf_size = bytestream2_get_bytes_left ( & ctx ) ;\n if ( s -> palettes_count <= 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"No palette found\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ( ret = ff_get_buffer ( avctx , & s -> current_frame ) ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n s -> current_frame . reference = 3 ;\n if ( ! s -> frame_size ) s -> frame_size = s -> current_frame . linesize [ 0 ] * s -> avctx -> height ;\n memcpy ( s -> current_frame . data [ 1 ] , s -> palettes + s -> cur_palette * AVPALETTE_COUNT , AVPALETTE_SIZE ) ;\n s -> buf = ctx . buffer ;\n s -> size = buf_size ;\n if ( xan_wc3_decode_frame ( s ) < 0 ) return AVERROR_INVALIDDATA ;\n if ( s -> last_frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> last_frame ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> current_frame ;\n FFSWAP ( AVFrame , s -> current_frame , s -> last_frame ) ;\n return buf_size ;\n }", "hash": 8953904005695962093, "project": "debian", "size": 68, "target": 1, "idx": 20973}
{"code": "static int tgv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n TgvContext * s = avctx -> priv_data ;\n const uint8_t * buf_end = buf + buf_size ;\n int chunk_type , ret ;\n chunk_type = AV_RL32 ( & buf [ 0 ] ) ;\n buf += EA_PREAMBLE_SIZE ;\n if ( chunk_type == kVGT_TAG ) {\n int pal_count , i ;\n if ( buf + 12 > buf_end ) {\n av_log ( avctx , AV_LOG_WARNING , \"truncated header\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n s -> width = AV_RL16 ( & buf [ 0 ] ) ;\n s -> height = AV_RL16 ( & buf [ 2 ] ) ;\n if ( s -> avctx -> width != s -> width || s -> avctx -> height != s -> height ) {\n avcodec_set_dimensions ( s -> avctx , s -> width , s -> height ) ;\n cond_release_buffer ( & s -> frame ) ;\n cond_release_buffer ( & s -> last_frame ) ;\n }\n pal_count = AV_RL16 ( & buf [ 6 ] ) ;\n buf += 12 ;\n for ( i = 0 ;\n i < pal_count && i < AVPALETTE_COUNT && buf + 2 < buf_end ;\n i ++ ) {\n s -> palette [ i ] = AV_RB24 ( buf ) ;\n buf += 3 ;\n }\n }\n if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) return ret ;\n FFSWAP ( AVFrame , s -> frame , s -> last_frame ) ;\n if ( ! s -> frame . data [ 0 ] ) {\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID ;\n s -> frame . linesize [ 0 ] = s -> width ;\n s -> frame . data [ 0 ] = av_malloc ( s -> width * s -> height ) ;\n if ( ! s -> frame . data [ 0 ] ) return AVERROR ( ENOMEM ) ;\n s -> frame . data [ 1 ] = av_malloc ( AVPALETTE_SIZE ) ;\n if ( ! s -> frame . data [ 1 ] ) {\n av_freep ( & s -> frame . data [ 0 ] ) ;\n return AVERROR ( ENOMEM ) ;\n }\n }\n memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n if ( chunk_type == kVGT_TAG ) {\n s -> frame . key_frame = 1 ;\n s -> frame . pict_type = AV_PICTURE_TYPE_I ;\n if ( unpack ( buf , buf_end , s -> frame . data [ 0 ] , s -> avctx -> width , s -> avctx -> height ) < 0 ) {\n av_log ( avctx , AV_LOG_WARNING , \"truncated intra frame\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n else {\n if ( ! s -> last_frame . data [ 0 ] ) {\n av_log ( avctx , AV_LOG_WARNING , \"inter frame without corresponding intra frame\\n\" ) ;\n return buf_size ;\n }\n s -> frame . key_frame = 0 ;\n s -> frame . pict_type = AV_PICTURE_TYPE_P ;\n if ( tgv_decode_inter ( s , buf , buf_end ) < 0 ) {\n av_log ( avctx , AV_LOG_WARNING , \"truncated inter frame\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }", "hash": -6734821889507212232, "project": "debian", "size": 69, "target": 1, "idx": 20978}
{"code": "static int mpeg4_decode_partition_b ( MpegEncContext * s , int mb_count ) {\n int mb_num = 0 ;\n static const int8_t quant_tab [ 4 ] = {\n - 1 , - 2 , 1 , 2 }\n ;\n s -> mb_x = s -> resync_mb_x ;\n s -> first_slice_line = 1 ;\n for ( s -> mb_y = s -> resync_mb_y ;\n mb_num < mb_count ;\n s -> mb_y ++ ) {\n ff_init_block_index ( s ) ;\n for ( ;\n mb_num < mb_count && s -> mb_x < s -> mb_width ;\n s -> mb_x ++ ) {\n const int xy = s -> mb_x + s -> mb_y * s -> mb_stride ;\n mb_num ++ ;\n ff_update_block_index ( s ) ;\n if ( s -> mb_x == s -> resync_mb_x && s -> mb_y == s -> resync_mb_y + 1 ) s -> first_slice_line = 0 ;\n if ( s -> pict_type == AV_PICTURE_TYPE_I ) {\n int ac_pred = get_bits1 ( & s -> gb ) ;\n int cbpy = get_vlc2 ( & s -> gb , ff_h263_cbpy_vlc . table , CBPY_VLC_BITS , 1 ) ;\n if ( cbpy < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"cbpy corrupted at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n s -> cbp_table [ xy ] |= cbpy << 2 ;\n s -> current_picture . f . mb_type [ xy ] |= ac_pred * MB_TYPE_ACPRED ;\n }\n else {\n if ( IS_INTRA ( s -> current_picture . f . mb_type [ xy ] ) ) {\n int dir = 0 , i ;\n int ac_pred = get_bits1 ( & s -> gb ) ;\n int cbpy = get_vlc2 ( & s -> gb , ff_h263_cbpy_vlc . table , CBPY_VLC_BITS , 1 ) ;\n if ( cbpy < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"I cbpy corrupted at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n if ( s -> cbp_table [ xy ] & 8 ) {\n ff_set_qscale ( s , s -> qscale + quant_tab [ get_bits ( & s -> gb , 2 ) ] ) ;\n }\n s -> current_picture . f . qscale_table [ xy ] = s -> qscale ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n int dc_pred_dir ;\n int dc = mpeg4_decode_dc ( s , i , & dc_pred_dir ) ;\n if ( dc < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"DC corrupted at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n dir <<= 1 ;\n if ( dc_pred_dir ) dir |= 1 ;\n }\n s -> cbp_table [ xy ] &= 3 ;\n s -> cbp_table [ xy ] |= cbpy << 2 ;\n s -> current_picture . f . mb_type [ xy ] |= ac_pred * MB_TYPE_ACPRED ;\n s -> pred_dir_table [ xy ] = dir ;\n }\n else if ( IS_SKIP ( s -> current_picture . f . mb_type [ xy ] ) ) {\n s -> current_picture . f . qscale_table [ xy ] = s -> qscale ;\n s -> cbp_table [ xy ] = 0 ;\n }\n else {\n int cbpy = get_vlc2 ( & s -> gb , ff_h263_cbpy_vlc . table , CBPY_VLC_BITS , 1 ) ;\n if ( cbpy < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"P cbpy corrupted at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n if ( s -> cbp_table [ xy ] & 8 ) {\n ff_set_qscale ( s , s -> qscale + quant_tab [ get_bits ( & s -> gb , 2 ) ] ) ;\n }\n s -> current_picture . f . qscale_table [ xy ] = s -> qscale ;\n s -> cbp_table [ xy ] &= 3 ;\n s -> cbp_table [ xy ] |= ( cbpy ^ 0xf ) << 2 ;\n }\n }\n }\n if ( mb_num >= mb_count ) return 0 ;\n s -> mb_x = 0 ;\n }\n return 0 ;\n }", "hash": 8672904772426696383, "project": "debian", "size": 82, "target": 1, "idx": 20980}
{"code": "static void render_slice ( Vp3DecodeContext * s , int slice ) {\n int x , y , i , j , fragment ;\n int16_t * block = s -> block ;\n int motion_x = 0xdeadbeef , motion_y = 0xdeadbeef ;\n int motion_halfpel_index ;\n uint8_t * motion_source ;\n int plane , first_pixel ;\n if ( slice >= s -> c_superblock_height ) return ;\n for ( plane = 0 ;\n plane < 3 ;\n plane ++ ) {\n uint8_t * output_plane = s -> current_frame . data [ plane ] + s -> data_offset [ plane ] ;\n uint8_t * last_plane = s -> last_frame . data [ plane ] + s -> data_offset [ plane ] ;\n uint8_t * golden_plane = s -> golden_frame . data [ plane ] + s -> data_offset [ plane ] ;\n int stride = s -> current_frame . linesize [ plane ] ;\n int plane_width = s -> width >> ( plane && s -> chroma_x_shift ) ;\n int plane_height = s -> height >> ( plane && s -> chroma_y_shift ) ;\n int8_t ( * motion_val ) [ 2 ] = s -> motion_val [ ! ! plane ] ;\n int sb_x , sb_y = slice << ( ! plane && s -> chroma_y_shift ) ;\n int slice_height = sb_y + 1 + ( ! plane && s -> chroma_y_shift ) ;\n int slice_width = plane ? s -> c_superblock_width : s -> y_superblock_width ;\n int fragment_width = s -> fragment_width [ ! ! plane ] ;\n int fragment_height = s -> fragment_height [ ! ! plane ] ;\n int fragment_start = s -> fragment_start [ plane ] ;\n int do_await = ! plane && HAVE_THREADS && ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ;\n if ( ! s -> flipped_image ) stride = - stride ;\n if ( CONFIG_GRAY && plane && ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) continue ;\n for ( ;\n sb_y < slice_height ;\n sb_y ++ ) {\n for ( sb_x = 0 ;\n sb_x < slice_width ;\n sb_x ++ ) {\n for ( j = 0 ;\n j < 16 ;\n j ++ ) {\n x = 4 * sb_x + hilbert_offset [ j ] [ 0 ] ;\n y = 4 * sb_y + hilbert_offset [ j ] [ 1 ] ;\n fragment = y * fragment_width + x ;\n i = fragment_start + fragment ;\n if ( x >= fragment_width || y >= fragment_height ) continue ;\n first_pixel = 8 * y * stride + 8 * x ;\n if ( do_await && s -> all_fragments [ i ] . coding_method != MODE_INTRA ) await_reference_row ( s , & s -> all_fragments [ i ] , motion_val [ fragment ] [ 1 ] , ( 16 * y ) >> s -> chroma_y_shift ) ;\n if ( s -> all_fragments [ i ] . coding_method != MODE_COPY ) {\n if ( ( s -> all_fragments [ i ] . coding_method == MODE_USING_GOLDEN ) || ( s -> all_fragments [ i ] . coding_method == MODE_GOLDEN_MV ) ) motion_source = golden_plane ;\n else motion_source = last_plane ;\n motion_source += first_pixel ;\n motion_halfpel_index = 0 ;\n if ( ( s -> all_fragments [ i ] . coding_method > MODE_INTRA ) && ( s -> all_fragments [ i ] . coding_method != MODE_USING_GOLDEN ) ) {\n int src_x , src_y ;\n motion_x = motion_val [ fragment ] [ 0 ] ;\n motion_y = motion_val [ fragment ] [ 1 ] ;\n src_x = ( motion_x >> 1 ) + 8 * x ;\n src_y = ( motion_y >> 1 ) + 8 * y ;\n motion_halfpel_index = motion_x & 0x01 ;\n motion_source += ( motion_x >> 1 ) ;\n motion_halfpel_index |= ( motion_y & 0x01 ) << 1 ;\n motion_source += ( ( motion_y >> 1 ) * stride ) ;\n if ( src_x < 0 || src_y < 0 || src_x + 9 >= plane_width || src_y + 9 >= plane_height ) {\n uint8_t * temp = s -> edge_emu_buffer ;\n if ( stride < 0 ) temp -= 8 * stride ;\n s -> vdsp . emulated_edge_mc ( temp , motion_source , stride , 9 , 9 , src_x , src_y , plane_width , plane_height ) ;\n motion_source = temp ;\n }\n }\n if ( s -> all_fragments [ i ] . coding_method != MODE_INTRA ) {\n if ( motion_halfpel_index != 3 ) {\n s -> dsp . put_no_rnd_pixels_tab [ 1 ] [ motion_halfpel_index ] ( output_plane + first_pixel , motion_source , stride , 8 ) ;\n }\n else {\n int d = ( motion_x ^ motion_y ) >> 31 ;\n s -> vp3dsp . put_no_rnd_pixels_l2 ( output_plane + first_pixel , motion_source - d , motion_source + stride + 1 + d , stride , 8 ) ;\n }\n }\n if ( s -> all_fragments [ i ] . coding_method == MODE_INTRA ) {\n int index ;\n index = vp3_dequant ( s , s -> all_fragments + i , plane , 0 , block ) ;\n if ( index > 63 ) continue ;\n s -> vp3dsp . idct_put ( output_plane + first_pixel , stride , block ) ;\n }\n else {\n int index = vp3_dequant ( s , s -> all_fragments + i , plane , 1 , block ) ;\n if ( index > 63 ) continue ;\n if ( index > 0 ) {\n s -> vp3dsp . idct_add ( output_plane + first_pixel , stride , block ) ;\n }\n else {\n s -> vp3dsp . idct_dc_add ( output_plane + first_pixel , stride , block ) ;\n }\n }\n }\n else {\n s -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( output_plane + first_pixel , last_plane + first_pixel , stride , 8 ) ;\n }\n }\n }\n if ( ! s -> skip_loop_filter ) apply_loop_filter ( s , plane , 4 * sb_y - ! ! sb_y , FFMIN ( 4 * sb_y + 3 , fragment_height - 1 ) ) ;\n }\n }\n vp3_draw_horiz_band ( s , FFMIN ( ( 32 << s -> chroma_y_shift ) * ( slice + 1 ) - 16 , s -> height - 16 ) ) ;\n }", "hash": -7990991774694156606, "project": "debian", "size": 101, "target": 1, "idx": 21049}
{"code": "static int decode_frame ( WmallDecodeCtx * s ) {\n GetBitContext * gb = & s -> gb ;\n int more_frames = 0 , len = 0 , i , ret ;\n s -> frame . nb_samples = s -> samples_per_frame ;\n if ( ( ret = ff_get_buffer ( s -> avctx , & s -> frame ) ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"not enough space for the output samples\\n\" ) ;\n s -> packet_loss = 1 ;\n return ret ;\n }\n for ( i = 0 ;\n i < s -> num_channels ;\n i ++ ) {\n s -> samples_16 [ i ] = ( int16_t * ) s -> frame . extended_data [ i ] ;\n s -> samples_32 [ i ] = ( int32_t * ) s -> frame . extended_data [ i ] ;\n }\n if ( s -> len_prefix ) len = get_bits ( gb , s -> log2_frame_size ) ;\n if ( decode_tilehdr ( s ) ) {\n s -> packet_loss = 1 ;\n return 0 ;\n }\n if ( s -> dynamic_range_compression ) s -> drc_gain = get_bits ( gb , 8 ) ;\n if ( get_bits1 ( gb ) ) {\n int av_unused skip ;\n if ( get_bits1 ( gb ) ) {\n skip = get_bits ( gb , av_log2 ( s -> samples_per_frame * 2 ) ) ;\n av_dlog ( s -> avctx , \"start skip: %i\\n\" , skip ) ;\n }\n if ( get_bits1 ( gb ) ) {\n skip = get_bits ( gb , av_log2 ( s -> samples_per_frame * 2 ) ) ;\n av_dlog ( s -> avctx , \"end skip: %i\\n\" , skip ) ;\n }\n }\n s -> parsed_all_subframes = 0 ;\n for ( i = 0 ;\n i < s -> num_channels ;\n i ++ ) {\n s -> channel [ i ] . decoded_samples = 0 ;\n s -> channel [ i ] . cur_subframe = 0 ;\n }\n while ( ! s -> parsed_all_subframes ) {\n if ( decode_subframe ( s ) < 0 ) {\n s -> packet_loss = 1 ;\n return 0 ;\n }\n }\n av_dlog ( s -> avctx , \"Frame done\\n\" ) ;\n if ( s -> skip_frame ) s -> skip_frame = 0 ;\n if ( s -> len_prefix ) {\n if ( len != ( get_bits_count ( gb ) - s -> frame_offset ) + 2 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"frame[%i] would have to skip %i bits\\n\" , s -> frame_num , len - ( get_bits_count ( gb ) - s -> frame_offset ) - 1 ) ;\n s -> packet_loss = 1 ;\n return 0 ;\n }\n skip_bits_long ( gb , len - ( get_bits_count ( gb ) - s -> frame_offset ) - 1 ) ;\n }\n more_frames = get_bits1 ( gb ) ;\n ++ s -> frame_num ;\n return more_frames ;\n }", "hash": -2915908172644760936, "project": "debian", "size": 59, "target": 1, "idx": 21059}
{"code": "static int roq_encode_end ( AVCodecContext * avctx ) {\n RoqContext * enc = avctx -> priv_data ;\n avctx -> release_buffer ( avctx , enc -> last_frame ) ;\n avctx -> release_buffer ( avctx , enc -> current_frame ) ;\n av_free ( enc -> tmpData ) ;\n av_free ( enc -> this_motion4 ) ;\n av_free ( enc -> last_motion4 ) ;\n av_free ( enc -> this_motion8 ) ;\n av_free ( enc -> last_motion8 ) ;\n return 0 ;\n }", "hash": -8046645508582876963, "project": "debian", "size": 11, "target": 1, "idx": 21062}
{"code": "static void erase_line ( AVCodecContext * avctx , int xoffset , int xlength ) {\n AnsiContext * s = avctx -> priv_data ;\n int i ;\n for ( i = 0 ;\n i < s -> font_height ;\n i ++ ) memset ( s -> frame . data [ 0 ] + ( s -> y + i ) * s -> frame . linesize [ 0 ] + xoffset , DEFAULT_BG_COLOR , xlength ) ;\n }", "hash": 2776415072272421122, "project": "debian", "size": 7, "target": 1, "idx": 21068}
{"code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n ProresContext * ctx = avctx -> priv_data ;\n AVFrame * picture = avctx -> coded_frame ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int frame_hdr_size , pic_num , pic_data_size ;\n if ( buf_size < 28 || buf_size < AV_RB32 ( buf ) || AV_RB32 ( buf + 4 ) != FRAME_ID ) {\n av_log ( avctx , AV_LOG_ERROR , \"invalid frame\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n MOVE_DATA_PTR ( 8 ) ;\n frame_hdr_size = decode_frame_header ( ctx , buf , buf_size , avctx ) ;\n if ( frame_hdr_size < 0 ) return AVERROR_INVALIDDATA ;\n MOVE_DATA_PTR ( frame_hdr_size ) ;\n if ( picture -> data [ 0 ] ) avctx -> release_buffer ( avctx , picture ) ;\n picture -> reference = 0 ;\n if ( ff_get_buffer ( avctx , picture ) < 0 ) return - 1 ;\n for ( pic_num = 0 ;\n ctx -> picture . interlaced_frame - pic_num + 1 ;\n pic_num ++ ) {\n pic_data_size = decode_picture_header ( ctx , buf , buf_size , avctx ) ;\n if ( pic_data_size < 0 ) return AVERROR_INVALIDDATA ;\n if ( decode_picture ( ctx , pic_num , avctx ) ) return - 1 ;\n MOVE_DATA_PTR ( pic_data_size ) ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = * avctx -> coded_frame ;\n return avpkt -> size ;\n }", "hash": -1594970847928262768, "project": "debian", "size": 29, "target": 1, "idx": 21072}
{"code": "static void free_picture ( MpegEncContext * s , Picture * pic ) {\n int i ;\n if ( pic -> f . data [ 0 ] && pic -> f . type != FF_BUFFER_TYPE_SHARED ) {\n free_frame_buffer ( s , pic ) ;\n }\n av_freep ( & pic -> mb_var ) ;\n av_freep ( & pic -> mc_mb_var ) ;\n av_freep ( & pic -> mb_mean ) ;\n av_freep ( & pic -> f . mbskip_table ) ;\n av_freep ( & pic -> qscale_table_base ) ;\n pic -> f . qscale_table = NULL ;\n av_freep ( & pic -> mb_type_base ) ;\n pic -> f . mb_type = NULL ;\n av_freep ( & pic -> f . dct_coeff ) ;\n av_freep ( & pic -> f . pan_scan ) ;\n pic -> f . mb_type = NULL ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n av_freep ( & pic -> motion_val_base [ i ] ) ;\n av_freep ( & pic -> f . ref_index [ i ] ) ;\n pic -> f . motion_val [ i ] = NULL ;\n }\n if ( pic -> f . type == FF_BUFFER_TYPE_SHARED ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n pic -> f . base [ i ] = pic -> f . data [ i ] = NULL ;\n }\n pic -> f . type = 0 ;\n }\n }", "hash": 2713698759296604855, "project": "debian", "size": 32, "target": 1, "idx": 21079}
{"code": "static void free_frame_buffer ( MpegEncContext * s , Picture * pic ) {\n if ( s -> codec_id != AV_CODEC_ID_WMV3IMAGE && s -> codec_id != AV_CODEC_ID_VC1IMAGE && s -> codec_id != AV_CODEC_ID_MSS2 ) ff_thread_release_buffer ( s -> avctx , & pic -> f ) ;\n else avcodec_default_release_buffer ( s -> avctx , & pic -> f ) ;\n av_freep ( & pic -> hwaccel_picture_private ) ;\n }", "hash": 2713698759296604855, "project": "debian", "size": 5, "target": 1, "idx": 21082}
{"code": "static void tgq_decode_mb ( TgqContext * s , int mb_y , int mb_x ) {\n int mode ;\n int i ;\n int8_t dc [ 6 ] ;\n mode = bytestream2_get_byte ( & s -> gb ) ;\n if ( mode > 12 ) {\n GetBitContext gb ;\n init_get_bits ( & gb , s -> gb . buffer , FFMIN ( s -> gb . buffer_end - s -> gb . buffer , mode ) * 8 ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) tgq_decode_block ( s , s -> block [ i ] , & gb ) ;\n tgq_idct_put_mb ( s , s -> block , mb_x , mb_y ) ;\n bytestream2_skip ( & s -> gb , mode ) ;\n }\n else {\n if ( mode == 3 ) {\n memset ( dc , bytestream2_get_byte ( & s -> gb ) , 4 ) ;\n dc [ 4 ] = bytestream2_get_byte ( & s -> gb ) ;\n dc [ 5 ] = bytestream2_get_byte ( & s -> gb ) ;\n }\n else if ( mode == 6 ) {\n bytestream2_get_buffer ( & s -> gb , dc , 6 ) ;\n }\n else if ( mode == 12 ) {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n dc [ i ] = bytestream2_get_byte ( & s -> gb ) ;\n bytestream2_skip ( & s -> gb , 1 ) ;\n }\n }\n else {\n av_log ( s -> avctx , AV_LOG_ERROR , \"unsupported mb mode %i\\n\" , mode ) ;\n }\n tgq_idct_put_mb_dconly ( s , mb_x , mb_y , dc ) ;\n }\n }", "hash": 8588713512322173474, "project": "debian", "size": 37, "target": 1, "idx": 21099}
{"code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n C93DecoderContext * const c93 = avctx -> priv_data ;\n AVFrame * const newpic = & c93 -> pictures [ c93 -> currentpic ] ;\n AVFrame * const oldpic = & c93 -> pictures [ c93 -> currentpic ^ 1 ] ;\n AVFrame * picture = data ;\n GetByteContext gb ;\n uint8_t * out ;\n int stride , ret , i , x , y , b , bt = 0 ;\n c93 -> currentpic ^= 1 ;\n newpic -> reference = 1 ;\n newpic -> buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE | FF_BUFFER_HINTS_READABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , newpic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n stride = newpic -> linesize [ 0 ] ;\n bytestream2_init ( & gb , buf , buf_size ) ;\n b = bytestream2_get_byte ( & gb ) ;\n if ( b & C93_FIRST_FRAME ) {\n newpic -> pict_type = AV_PICTURE_TYPE_I ;\n newpic -> key_frame = 1 ;\n }\n else {\n newpic -> pict_type = AV_PICTURE_TYPE_P ;\n newpic -> key_frame = 0 ;\n }\n for ( y = 0 ;\n y < HEIGHT ;\n y += 8 ) {\n out = newpic -> data [ 0 ] + y * stride ;\n for ( x = 0 ;\n x < WIDTH ;\n x += 8 ) {\n uint8_t * copy_from = oldpic -> data [ 0 ] ;\n unsigned int offset , j ;\n uint8_t cols [ 4 ] , grps [ 4 ] ;\n C93BlockType block_type ;\n if ( ! bt ) bt = bytestream2_get_byte ( & gb ) ;\n block_type = bt & 0x0F ;\n switch ( block_type ) {\n case C93_8X8_FROM_PREV : offset = bytestream2_get_le16 ( & gb ) ;\n if ( ( ret = copy_block ( avctx , out , copy_from , offset , 8 , stride ) ) < 0 ) return ret ;\n break ;\n case C93_4X4_FROM_CURR : copy_from = newpic -> data [ 0 ] ;\n case C93_4X4_FROM_PREV : for ( j = 0 ;\n j < 8 ;\n j += 4 ) {\n for ( i = 0 ;\n i < 8 ;\n i += 4 ) {\n offset = bytestream2_get_le16 ( & gb ) ;\n if ( ( ret = copy_block ( avctx , & out [ j * stride + i ] , copy_from , offset , 4 , stride ) ) < 0 ) return ret ;\n }\n }\n break ;\n case C93_8X8_2COLOR : bytestream2_get_buffer ( & gb , cols , 2 ) ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n draw_n_color ( out + i * stride , stride , 8 , 1 , 1 , cols , NULL , bytestream2_get_byte ( & gb ) ) ;\n }\n break ;\n case C93_4X4_2COLOR : case C93_4X4_4COLOR : case C93_4X4_4COLOR_GRP : for ( j = 0 ;\n j < 8 ;\n j += 4 ) {\n for ( i = 0 ;\n i < 8 ;\n i += 4 ) {\n if ( block_type == C93_4X4_2COLOR ) {\n bytestream2_get_buffer ( & gb , cols , 2 ) ;\n draw_n_color ( out + i + j * stride , stride , 4 , 4 , 1 , cols , NULL , bytestream2_get_le16 ( & gb ) ) ;\n }\n else if ( block_type == C93_4X4_4COLOR ) {\n bytestream2_get_buffer ( & gb , cols , 4 ) ;\n draw_n_color ( out + i + j * stride , stride , 4 , 4 , 2 , cols , NULL , bytestream2_get_le32 ( & gb ) ) ;\n }\n else {\n bytestream2_get_buffer ( & gb , grps , 4 ) ;\n draw_n_color ( out + i + j * stride , stride , 4 , 4 , 1 , cols , grps , bytestream2_get_le16 ( & gb ) ) ;\n }\n }\n }\n break ;\n case C93_NOOP : break ;\n case C93_8X8_INTRA : for ( j = 0 ;\n j < 8 ;\n j ++ ) bytestream2_get_buffer ( & gb , out + j * stride , 8 ) ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"unexpected type %x at %dx%d\\n\" , block_type , x , y ) ;\n return AVERROR_INVALIDDATA ;\n }\n bt >>= 4 ;\n out += 8 ;\n }\n }\n if ( b & C93_HAS_PALETTE ) {\n uint32_t * palette = ( uint32_t * ) newpic -> data [ 1 ] ;\n for ( i = 0 ;\n i < 256 ;\n i ++ ) {\n palette [ i ] = bytestream2_get_be24 ( & gb ) ;\n }\n newpic -> palette_has_changed = 1 ;\n }\n else {\n if ( oldpic -> data [ 1 ] ) memcpy ( newpic -> data [ 1 ] , oldpic -> data [ 1 ] , 256 * 4 ) ;\n }\n * picture = * newpic ;\n * got_frame = 1 ;\n return buf_size ;\n }", "hash": 423181909456162215, "project": "debian", "size": 113, "target": 1, "idx": 21105}
{"code": "static int msvideo1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n Msvideo1Context * s = avctx -> priv_data ;\n s -> buf = buf ;\n s -> size = buf_size ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( avctx -> reget_buffer ( avctx , & s -> frame ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return - 1 ;\n }\n if ( s -> mode_8bit ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n s -> frame . palette_has_changed = 1 ;\n }\n }\n if ( s -> mode_8bit ) msvideo1_decode_8bit ( s ) ;\n else msvideo1_decode_16bit ( s ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }", "hash": 2716625165137468453, "project": "debian", "size": 25, "target": 1, "idx": 21118}
{"code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n RALFContext * ctx = avctx -> priv_data ;\n AVFrame * frame = data ;\n int16_t * samples0 ;\n int16_t * samples1 ;\n int ret ;\n GetBitContext gb ;\n int table_size , table_bytes , i ;\n const uint8_t * src , * block_pointer ;\n int src_size ;\n int bytes_left ;\n if ( ctx -> has_pkt ) {\n ctx -> has_pkt = 0 ;\n table_bytes = ( AV_RB16 ( avpkt -> data ) + 7 ) >> 3 ;\n if ( table_bytes + 3 > avpkt -> size || avpkt -> size > RALF_MAX_PKT_SIZE ) {\n av_log ( avctx , AV_LOG_ERROR , \"Wrong packet's breath smells of wrong data!\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( memcmp ( ctx -> pkt , avpkt -> data , 2 + table_bytes ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Wrong packet tails are wrong!\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n src = ctx -> pkt ;\n src_size = RALF_MAX_PKT_SIZE + avpkt -> size ;\n memcpy ( ctx -> pkt + RALF_MAX_PKT_SIZE , avpkt -> data + 2 + table_bytes , avpkt -> size - 2 - table_bytes ) ;\n }\n else {\n if ( avpkt -> size == RALF_MAX_PKT_SIZE ) {\n memcpy ( ctx -> pkt , avpkt -> data , avpkt -> size ) ;\n ctx -> has_pkt = 1 ;\n * got_frame_ptr = 0 ;\n return avpkt -> size ;\n }\n src = avpkt -> data ;\n src_size = avpkt -> size ;\n }\n frame -> nb_samples = ctx -> max_frame_size ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Me fail get_buffer()? That's unpossible!\\n\" ) ;\n return ret ;\n }\n samples0 = ( int16_t * ) frame -> data [ 0 ] ;\n samples1 = ( int16_t * ) frame -> data [ 1 ] ;\n if ( src_size < 5 ) {\n av_log ( avctx , AV_LOG_ERROR , \"too short packets are too short!\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n table_size = AV_RB16 ( src ) ;\n table_bytes = ( table_size + 7 ) >> 3 ;\n if ( src_size < table_bytes + 3 ) {\n av_log ( avctx , AV_LOG_ERROR , \"short packets are short!\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n init_get_bits ( & gb , src + 2 , table_size ) ;\n ctx -> num_blocks = 0 ;\n while ( get_bits_left ( & gb ) > 0 ) {\n ctx -> block_size [ ctx -> num_blocks ] = get_bits ( & gb , 15 ) ;\n if ( get_bits1 ( & gb ) ) {\n ctx -> block_pts [ ctx -> num_blocks ] = get_bits ( & gb , 9 ) ;\n }\n else {\n ctx -> block_pts [ ctx -> num_blocks ] = 0 ;\n }\n ctx -> num_blocks ++ ;\n }\n block_pointer = src + table_bytes + 2 ;\n bytes_left = src_size - table_bytes - 2 ;\n ctx -> sample_offset = 0 ;\n for ( i = 0 ;\n i < ctx -> num_blocks ;\n i ++ ) {\n if ( bytes_left < ctx -> block_size [ i ] ) {\n av_log ( avctx , AV_LOG_ERROR , \"I'm pedaling backwards\\n\" ) ;\n break ;\n }\n init_get_bits ( & gb , block_pointer , ctx -> block_size [ i ] * 8 ) ;\n if ( decode_block ( avctx , & gb , samples0 + ctx -> sample_offset , samples1 + ctx -> sample_offset ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Sir, I got carsick in your office. Not decoding the rest of packet.\\n\" ) ;\n break ;\n }\n block_pointer += ctx -> block_size [ i ] ;\n bytes_left -= ctx -> block_size [ i ] ;\n }\n frame -> nb_samples = ctx -> sample_offset ;\n * got_frame_ptr = ctx -> sample_offset > 0 ;\n return avpkt -> size ;\n }", "hash": -2385618084223928445, "project": "debian", "size": 87, "target": 1, "idx": 21128}
{"code": "static void rv34_pred_mv ( RV34DecContext * r , int block_type , int subblock_no , int dmv_no ) {\n MpegEncContext * s = & r -> s ;\n int mv_pos = s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ;\n int A [ 2 ] = {\n 0 }\n , B [ 2 ] , C [ 2 ] ;\n int i , j ;\n int mx , my ;\n int * avail = r -> avail_cache + avail_indexes [ subblock_no ] ;\n int c_off = part_sizes_w [ block_type ] ;\n mv_pos += ( subblock_no & 1 ) + ( subblock_no >> 1 ) * s -> b8_stride ;\n if ( subblock_no == 3 ) c_off = - 1 ;\n if ( avail [ - 1 ] ) {\n A [ 0 ] = s -> current_picture_ptr -> f . motion_val [ 0 ] [ mv_pos - 1 ] [ 0 ] ;\n A [ 1 ] = s -> current_picture_ptr -> f . motion_val [ 0 ] [ mv_pos - 1 ] [ 1 ] ;\n }\n if ( avail [ - 4 ] ) {\n B [ 0 ] = s -> current_picture_ptr -> f . motion_val [ 0 ] [ mv_pos - s -> b8_stride ] [ 0 ] ;\n B [ 1 ] = s -> current_picture_ptr -> f . motion_val [ 0 ] [ mv_pos - s -> b8_stride ] [ 1 ] ;\n }\n else {\n B [ 0 ] = A [ 0 ] ;\n B [ 1 ] = A [ 1 ] ;\n }\n if ( ! avail [ c_off - 4 ] ) {\n if ( avail [ - 4 ] && ( avail [ - 1 ] || r -> rv30 ) ) {\n C [ 0 ] = s -> current_picture_ptr -> f . motion_val [ 0 ] [ mv_pos - s -> b8_stride - 1 ] [ 0 ] ;\n C [ 1 ] = s -> current_picture_ptr -> f . motion_val [ 0 ] [ mv_pos - s -> b8_stride - 1 ] [ 1 ] ;\n }\n else {\n C [ 0 ] = A [ 0 ] ;\n C [ 1 ] = A [ 1 ] ;\n }\n }\n else {\n C [ 0 ] = s -> current_picture_ptr -> f . motion_val [ 0 ] [ mv_pos - s -> b8_stride + c_off ] [ 0 ] ;\n C [ 1 ] = s -> current_picture_ptr -> f . motion_val [ 0 ] [ mv_pos - s -> b8_stride + c_off ] [ 1 ] ;\n }\n mx = mid_pred ( A [ 0 ] , B [ 0 ] , C [ 0 ] ) ;\n my = mid_pred ( A [ 1 ] , B [ 1 ] , C [ 1 ] ) ;\n mx += r -> dmv [ dmv_no ] [ 0 ] ;\n my += r -> dmv [ dmv_no ] [ 1 ] ;\n for ( j = 0 ;\n j < part_sizes_h [ block_type ] ;\n j ++ ) {\n for ( i = 0 ;\n i < part_sizes_w [ block_type ] ;\n i ++ ) {\n s -> current_picture_ptr -> f . motion_val [ 0 ] [ mv_pos + i + j * s -> b8_stride ] [ 0 ] = mx ;\n s -> current_picture_ptr -> f . motion_val [ 0 ] [ mv_pos + i + j * s -> b8_stride ] [ 1 ] = my ;\n }\n }\n }", "hash": 2335222688263906532, "project": "debian", "size": 53, "target": 1, "idx": 21133}
{"code": "static int mxpeg_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n MXpegDecodeContext * s = avctx -> priv_data ;\n MJpegDecodeContext * jpg = & s -> jpg ;\n const uint8_t * buf_end , * buf_ptr ;\n const uint8_t * unescaped_buf_ptr ;\n int unescaped_buf_size ;\n int start_code ;\n AVFrame * picture = data ;\n int ret ;\n buf_ptr = buf ;\n buf_end = buf + buf_size ;\n jpg -> got_picture = 0 ;\n s -> got_mxm_bitmask = 0 ;\n while ( buf_ptr < buf_end ) {\n start_code = ff_mjpeg_find_marker ( jpg , & buf_ptr , buf_end , & unescaped_buf_ptr , & unescaped_buf_size ) ;\n if ( start_code < 0 ) goto the_end ;\n {\n init_get_bits ( & jpg -> gb , unescaped_buf_ptr , unescaped_buf_size * 8 ) ;\n if ( start_code >= APP0 && start_code <= APP15 ) {\n mxpeg_decode_app ( s , unescaped_buf_ptr , unescaped_buf_size ) ;\n }\n switch ( start_code ) {\n case SOI : if ( jpg -> got_picture ) goto the_end ;\n break ;\n case EOI : goto the_end ;\n case DQT : ret = ff_mjpeg_decode_dqt ( jpg ) ;\n if ( ret < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"quantization table decode error\\n\" ) ;\n return ret ;\n }\n break ;\n case DHT : ret = ff_mjpeg_decode_dht ( jpg ) ;\n if ( ret < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"huffman table decode error\\n\" ) ;\n return ret ;\n }\n break ;\n case COM : ret = mxpeg_decode_com ( s , unescaped_buf_ptr , unescaped_buf_size ) ;\n if ( ret < 0 ) return ret ;\n break ;\n case SOF0 : s -> got_sof_data = 0 ;\n ret = ff_mjpeg_decode_sof ( jpg ) ;\n if ( ret < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"SOF data decode error\\n\" ) ;\n return ret ;\n }\n if ( jpg -> interlaced ) {\n av_log ( avctx , AV_LOG_ERROR , \"Interlaced mode not supported in MxPEG\\n\" ) ;\n return AVERROR ( EINVAL ) ;\n }\n s -> got_sof_data = 1 ;\n break ;\n case SOS : if ( ! s -> got_sof_data ) {\n av_log ( avctx , AV_LOG_WARNING , \"Can not process SOS without SOF data, skipping\\n\" ) ;\n break ;\n }\n if ( ! jpg -> got_picture ) {\n if ( jpg -> first_picture ) {\n av_log ( avctx , AV_LOG_WARNING , \"First picture has no SOF, skipping\\n\" ) ;\n break ;\n }\n if ( ! s -> got_mxm_bitmask ) {\n av_log ( avctx , AV_LOG_WARNING , \"Non-key frame has no MXM, skipping\\n\" ) ;\n break ;\n }\n if ( jpg -> picture_ptr -> data [ 0 ] ) avctx -> release_buffer ( avctx , jpg -> picture_ptr ) ;\n if ( ff_get_buffer ( avctx , jpg -> picture_ptr ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return AVERROR ( ENOMEM ) ;\n }\n jpg -> picture_ptr -> pict_type = AV_PICTURE_TYPE_P ;\n jpg -> picture_ptr -> key_frame = 0 ;\n jpg -> got_picture = 1 ;\n }\n else {\n jpg -> picture_ptr -> pict_type = AV_PICTURE_TYPE_I ;\n jpg -> picture_ptr -> key_frame = 1 ;\n }\n if ( s -> got_mxm_bitmask ) {\n AVFrame * reference_ptr = & s -> picture [ s -> picture_index ^ 1 ] ;\n if ( mxpeg_check_dimensions ( s , jpg , reference_ptr ) < 0 ) break ;\n if ( ! reference_ptr -> data [ 0 ] && ff_get_buffer ( avctx , reference_ptr ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return AVERROR ( ENOMEM ) ;\n }\n ret = ff_mjpeg_decode_sos ( jpg , s -> mxm_bitmask , reference_ptr ) ;\n if ( ret < 0 && ( avctx -> err_recognition & AV_EF_EXPLODE ) ) return ret ;\n }\n else {\n ret = ff_mjpeg_decode_sos ( jpg , NULL , NULL ) ;\n if ( ret < 0 && ( avctx -> err_recognition & AV_EF_EXPLODE ) ) return ret ;\n }\n break ;\n }\n buf_ptr += ( get_bits_count ( & jpg -> gb ) + 7 ) >> 3 ;\n }\n }\n the_end : if ( jpg -> got_picture ) {\n * got_frame = 1 ;\n * picture = * jpg -> picture_ptr ;\n s -> picture_index ^= 1 ;\n jpg -> picture_ptr = & s -> picture [ s -> picture_index ] ;\n if ( ! s -> has_complete_frame ) {\n if ( ! s -> got_mxm_bitmask ) s -> has_complete_frame = 1 ;\n else * got_frame = 0 ;\n }\n }\n return buf_ptr - buf ;\n }", "hash": 7153080989267739132, "project": "debian", "size": 111, "target": 1, "idx": 21143}
{"code": "void rtp_add_address ( packet_info * pinfo , address * addr , int port , int other_port , const gchar * setup_method , guint32 setup_frame_number , gboolean is_video , GHashTable * rtp_dyn_payload ) {\n srtp_add_address ( pinfo , addr , port , other_port , setup_method , setup_frame_number , is_video , rtp_dyn_payload , NULL ) ;\n }", "hash": -6333668321124139371, "project": "debian", "size": 3, "target": 1, "idx": 21157}
{"code": "static bool _is_valid_will_run_user ( job_desc_msg_t * job_desc_msg , uid_t uid ) {\n char * account = NULL ;\n if ( ( uid == job_desc_msg -> user_id ) || validate_operator ( uid ) ) return true ;\n if ( job_desc_msg -> job_id != NO_VAL ) {\n struct job_record * job_ptr ;\n job_ptr = find_job_record ( job_desc_msg -> job_id ) ;\n if ( job_ptr ) account = job_ptr -> account ;\n }\n else if ( job_desc_msg -> account ) account = job_desc_msg -> account ;\n if ( account && assoc_mgr_is_user_acct_coord ( acct_db_conn , uid , account ) ) return true ;\n return false ;\n }", "hash": -1672864273235910388, "project": "debian", "size": 12, "target": 1, "idx": 21167}
{"code": "int main ( int argc , char * argv [ ] ) {\n static char buff [ 16384 ] ;\n struct cpio _cpio ;\n struct cpio * cpio ;\n const char * errmsg ;\n int uid , gid ;\n int opt ;\n cpio = & _cpio ;\n memset ( cpio , 0 , sizeof ( * cpio ) ) ;\n cpio -> buff = buff ;\n cpio -> buff_size = sizeof ( buff ) ;\n # if defined ( HAVE_SIGACTION ) && defined ( SIGPIPE ) {\n struct sigaction sa ;\n sigemptyset ( & sa . sa_mask ) ;\n sa . sa_flags = 0 ;\n sa . sa_handler = SIG_IGN ;\n sigaction ( SIGPIPE , & sa , NULL ) ;\n }\n # endif lafe_setprogname ( * argv , \"bsdcpio\" ) ;\n # if HAVE_SETLOCALE if ( setlocale ( LC_ALL , \"\" ) == NULL ) lafe_warnc ( 0 , \"Failed to set default locale\" ) ;\n # endif cpio -> uid_override = - 1 ;\n cpio -> gid_override = - 1 ;\n cpio -> argv = argv ;\n cpio -> argc = argc ;\n cpio -> mode = '\\0' ;\n cpio -> verbose = 0 ;\n cpio -> compress = '\\0' ;\n cpio -> extract_flags = ARCHIVE_EXTRACT_NO_AUTODIR ;\n cpio -> extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ;\n cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS ;\n cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT ;\n cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ;\n cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ;\n cpio -> extract_flags |= ARCHIVE_EXTRACT_ACL ;\n # if ! defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) if ( geteuid ( ) == 0 ) cpio -> extract_flags |= ARCHIVE_EXTRACT_OWNER ;\n # endif cpio -> bytes_per_block = 512 ;\n cpio -> filename = NULL ;\n cpio -> matching = archive_match_new ( ) ;\n if ( cpio -> matching == NULL ) lafe_errc ( 1 , 0 , \"Out of memory\" ) ;\n while ( ( opt = cpio_getopt ( cpio ) ) != - 1 ) {\n switch ( opt ) {\n case '0' : cpio -> option_null = 1 ;\n break ;\n case 'A' : cpio -> option_append = 1 ;\n break ;\n case 'a' : cpio -> option_atime_restore = 1 ;\n break ;\n case 'B' : cpio -> bytes_per_block = 5120 ;\n break ;\n case OPTION_B64ENCODE : cpio -> add_filter = opt ;\n break ;\n case 'C' : cpio -> bytes_per_block = atoi ( cpio -> argument ) ;\n if ( cpio -> bytes_per_block <= 0 ) lafe_errc ( 1 , 0 , \"Invalid blocksize %s\" , cpio -> argument ) ;\n break ;\n case 'c' : cpio -> format = \"odc\" ;\n break ;\n case 'd' : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_NO_AUTODIR ;\n break ;\n case 'E' : if ( archive_match_include_pattern_from_file ( cpio -> matching , cpio -> argument , cpio -> option_null ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , \"Error : %s\" , archive_error_string ( cpio -> matching ) ) ;\n break ;\n case 'F' : cpio -> filename = cpio -> argument ;\n break ;\n case 'f' : if ( archive_match_exclude_pattern ( cpio -> matching , cpio -> argument ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , \"Error : %s\" , archive_error_string ( cpio -> matching ) ) ;\n break ;\n case OPTION_GRZIP : cpio -> compress = opt ;\n break ;\n case 'H' : cpio -> format = cpio -> argument ;\n break ;\n case 'h' : long_help ( ) ;\n break ;\n case 'I' : cpio -> filename = cpio -> argument ;\n break ;\n case 'i' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , \"Cannot use both -i and -%c\" , cpio -> mode ) ;\n cpio -> mode = opt ;\n break ;\n case 'J' : cpio -> compress = opt ;\n break ;\n case 'j' : cpio -> compress = opt ;\n break ;\n case OPTION_INSECURE : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_SYMLINKS ;\n cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ;\n break ;\n case 'L' : cpio -> option_follow_links = 1 ;\n break ;\n case 'l' : cpio -> option_link = 1 ;\n break ;\n case OPTION_LRZIP : case OPTION_LZ4 : case OPTION_LZMA : case OPTION_LZOP : cpio -> compress = opt ;\n break ;\n case 'm' : cpio -> extract_flags |= ARCHIVE_EXTRACT_TIME ;\n break ;\n case 'n' : cpio -> option_numeric_uid_gid = 1 ;\n break ;\n case OPTION_NO_PRESERVE_OWNER : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_OWNER ;\n break ;\n case 'O' : cpio -> filename = cpio -> argument ;\n break ;\n case 'o' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , \"Cannot use both -o and -%c\" , cpio -> mode ) ;\n cpio -> mode = opt ;\n break ;\n case 'p' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , \"Cannot use both -p and -%c\" , cpio -> mode ) ;\n cpio -> mode = opt ;\n cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ;\n break ;\n case OPTION_PASSPHRASE : cpio -> passphrase = cpio -> argument ;\n break ;\n case OPTION_PRESERVE_OWNER : cpio -> extract_flags |= ARCHIVE_EXTRACT_OWNER ;\n break ;\n case OPTION_QUIET : cpio -> quiet = 1 ;\n break ;\n case 'R' : errmsg = owner_parse ( cpio -> argument , & uid , & gid ) ;\n if ( errmsg ) {\n lafe_warnc ( - 1 , \"%s\" , errmsg ) ;\n usage ( ) ;\n }\n if ( uid != - 1 ) {\n cpio -> uid_override = uid ;\n cpio -> uname_override = NULL ;\n }\n if ( gid != - 1 ) {\n cpio -> gid_override = gid ;\n cpio -> gname_override = NULL ;\n }\n break ;\n case 'r' : cpio -> option_rename = 1 ;\n break ;\n case 't' : cpio -> option_list = 1 ;\n break ;\n case 'u' : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ;\n break ;\n case OPTION_UUENCODE : cpio -> add_filter = opt ;\n break ;\n case 'v' : cpio -> verbose ++ ;\n break ;\n case 'V' : cpio -> dot ++ ;\n break ;\n case OPTION_VERSION : version ( ) ;\n break ;\n # if 0 case 'W' : break ;\n # endif case 'y' : cpio -> compress = opt ;\n break ;\n case 'Z' : cpio -> compress = opt ;\n break ;\n case 'z' : cpio -> compress = opt ;\n break ;\n default : usage ( ) ;\n }\n }\n if ( cpio -> option_list && cpio -> mode == '\\0' ) cpio -> mode = 'i' ;\n if ( cpio -> option_list && cpio -> mode != 'i' ) lafe_errc ( 1 , 0 , \"Option -t requires -i\" ) ;\n if ( cpio -> option_numeric_uid_gid && ! cpio -> option_list ) lafe_errc ( 1 , 0 , \"Option -n requires -it\" ) ;\n if ( cpio -> format != NULL && cpio -> mode != 'o' ) lafe_errc ( 1 , 0 , \"Option --format requires -o\" ) ;\n if ( cpio -> option_link && cpio -> mode != 'p' ) lafe_errc ( 1 , 0 , \"Option -l requires -p\" ) ;\n if ( cpio -> dot && cpio -> verbose ) cpio -> dot = 0 ;\n switch ( cpio -> mode ) {\n case 'o' : if ( cpio -> format == NULL ) cpio -> format = \"odc\" ;\n mode_out ( cpio ) ;\n break ;\n case 'i' : while ( * cpio -> argv != NULL ) {\n if ( archive_match_include_pattern ( cpio -> matching , * cpio -> argv ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , \"Error : %s\" , archive_error_string ( cpio -> matching ) ) ;\n -- cpio -> argc ;\n ++ cpio -> argv ;\n }\n if ( cpio -> option_list ) mode_list ( cpio ) ;\n else mode_in ( cpio ) ;\n break ;\n case 'p' : if ( * cpio -> argv == NULL || * * cpio -> argv == '\\0' ) lafe_errc ( 1 , 0 , \"-p mode requires a target directory\" ) ;\n mode_pass ( cpio , * cpio -> argv ) ;\n break ;\n default : lafe_errc ( 1 , 0 , \"Must specify at least one of -i, -o, or -p\" ) ;\n }\n archive_match_free ( cpio -> matching ) ;\n free_cache ( cpio -> gname_cache ) ;\n free_cache ( cpio -> uname_cache ) ;\n free ( cpio -> destdir ) ;\n passphrase_free ( cpio -> ppbuff ) ;\n return ( cpio -> return_value ) ;\n }", "hash": -6704066512670389306, "project": "debian", "size": 177, "target": 1, "idx": 21186}
{"code": "static void basic_ec_math_simplified ( void ) {\n gpg_error_t err ;\n gcry_ctx_t ctx ;\n gcry_mpi_point_t G , Q ;\n gcry_mpi_t d ;\n gcry_mpi_t x , y , z ;\n gcry_sexp_t sexp ;\n wherestr = \"basic_ec_math_simplified\" ;\n show ( \"checking basic math functions for EC (variant)\\n\" ) ;\n d = hex2mpi ( \"D4EF27E32F8AD8E2A1C6DDEBB1D235A69E3CEF9BCE90273D\" ) ;\n Q = gcry_mpi_point_new ( 0 ) ;\n err = gcry_mpi_ec_new ( & ctx , NULL , \"NIST P-192\" ) ;\n if ( err ) die ( \"gcry_mpi_ec_new failed: %s\\n\" , gpg_strerror ( err ) ) ;\n G = gcry_mpi_ec_get_point ( \"g\" , ctx , 1 ) ;\n if ( ! G ) die ( \"gcry_mpi_ec_get_point(G) failed\\n\" ) ;\n gcry_mpi_ec_mul ( Q , d , G , ctx ) ;\n x = gcry_mpi_new ( 0 ) ;\n y = gcry_mpi_new ( 0 ) ;\n z = gcry_mpi_new ( 0 ) ;\n gcry_mpi_point_get ( x , y , z , Q ) ;\n if ( cmp_mpihex ( x , \"222D9EC717C89D047E0898C9185B033CD11C0A981EE6DC66\" ) || cmp_mpihex ( y , \"605DE0A82D70D3E0F84A127D0739ED33D657DF0D054BFDE8\" ) || cmp_mpihex ( z , \"00B06B519071BC536999AC8F2D3934B3C1FC9EACCD0A31F88F\" ) ) fail ( \"computed public key does not match\\n\" ) ;\n if ( debug ) {\n print_mpi ( \"Q.x\" , x ) ;\n print_mpi ( \"Q.y\" , y ) ;\n print_mpi ( \"Q.z\" , z ) ;\n }\n if ( gcry_mpi_ec_get_affine ( x , y , Q , ctx ) ) fail ( \"failed to get affine coordinates\\n\" ) ;\n if ( cmp_mpihex ( x , \"008532093BA023F4D55C0424FA3AF9367E05F309DC34CDC3FE\" ) || cmp_mpihex ( y , \"00C13CA9E617C6C8487BFF6A726E3C4F277913D97117939966\" ) ) fail ( \"computed affine coordinates of public key do not match\\n\" ) ;\n if ( debug ) {\n print_mpi ( \"q.x\" , x ) ;\n print_mpi ( \"q.y\" , y ) ;\n }\n gcry_mpi_release ( z ) ;\n gcry_mpi_release ( y ) ;\n gcry_mpi_release ( x ) ;\n err = gcry_mpi_ec_set_point ( \"g\" , G , ctx ) ;\n if ( err ) die ( \"gcry_mpi_ec_set_point(G) failed\\n\" ) ;\n err = gcry_mpi_ec_set_mpi ( \"d\" , d , ctx ) ;\n if ( err ) die ( \"gcry_mpi_ec_set_mpi(d) failed\\n\" ) ;\n err = gcry_pubkey_get_sexp ( & sexp , 0 , ctx ) ;\n if ( err ) fail ( \"gcry_pubkey_get_sexp(0) failed: %s\\n\" , gpg_strerror ( err ) ) ;\n else if ( verbose ) print_sexp ( \"Result of gcry_pubkey_get_sexp (0):\\n\" , sexp ) ;\n gcry_sexp_release ( sexp ) ;\n err = gcry_pubkey_get_sexp ( & sexp , GCRY_PK_GET_PUBKEY , ctx ) ;\n if ( err ) fail ( \"gcry_pubkey_get_sexp(GET_PUBKEY) failed: %s\\n\" , gpg_strerror ( err ) ) ;\n else if ( verbose ) print_sexp ( \"Result of gcry_pubkey_get_sexp (GET_PUBKEY):\\n\" , sexp ) ;\n gcry_sexp_release ( sexp ) ;\n err = gcry_mpi_ec_set_mpi ( \"d\" , NULL , ctx ) ;\n if ( err ) die ( \"gcry_mpi_ec_set_mpi(d=NULL) failed\\n\" ) ;\n err = gcry_pubkey_get_sexp ( & sexp , 0 , ctx ) ;\n if ( err ) fail ( \"gcry_pubkey_get_sexp(0 w/o d) failed: %s\\n\" , gpg_strerror ( err ) ) ;\n else if ( verbose ) print_sexp ( \"Result of gcry_pubkey_get_sexp (0 w/o d):\\n\" , sexp ) ;\n gcry_sexp_release ( sexp ) ;\n err = gcry_pubkey_get_sexp ( & sexp , GCRY_PK_GET_SECKEY , ctx ) ;\n if ( gpg_err_code ( err ) != GPG_ERR_NO_SECKEY ) fail ( \"gcry_pubkey_get_sexp(GET_SECKEY) returned wrong error: %s\\n\" , gpg_strerror ( err ) ) ;\n gcry_sexp_release ( sexp ) ;\n err = gcry_mpi_ec_set_point ( \"q\" , NULL , ctx ) ;\n if ( err ) die ( \"gcry_mpi_ec_set_point(q=NULL) failed\\n\" ) ;\n err = gcry_pubkey_get_sexp ( & sexp , 0 , ctx ) ;\n if ( gpg_err_code ( err ) != GPG_ERR_BAD_CRYPT_CTX ) fail ( \"gcry_pubkey_get_sexp(0 w/o Q,d) returned wrong error: %s\\n\" , gpg_strerror ( err ) ) ;\n gcry_sexp_release ( sexp ) ;\n gcry_mpi_point_release ( Q ) ;\n gcry_mpi_release ( d ) ;\n gcry_mpi_point_release ( G ) ;\n gcry_ctx_release ( ctx ) ;\n }", "hash": -6474315190511670247, "project": "debian", "size": 66, "target": 1, "idx": 21211}
{"code": "int parse_RANGEBOUNDARY ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n guint32 ulType ;\n guint8 labelPresent ;\n proto_item * item ;\n proto_tree * tree ;\n const char * txt ;\n struct CBaseStorageVariant prval ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_RANGEBOUNDARY , & item , txt ) ;\n ulType = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_mswsp_rangeboundry_ultype , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n proto_item_append_text ( item , \": Type 0x%08x\" , ulType ) ;\n offset += 4 ;\n ZERO_STRUCT ( prval ) ;\n offset = parse_CBaseStorageVariant ( tvb , offset , tree , pad_tree , & prval , \"prVal\" ) ;\n labelPresent = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_mswsp_rangeboundry_labelpresent , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ;\n offset += 1 ;\n if ( labelPresent ) {\n guint32 ccLabel ;\n const guint8 * label ;\n offset = parse_padding ( tvb , offset , 4 , pad_tree , \"paddingLabelPresent\" ) ;\n ccLabel = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_item_ret_uint ( tree , hf_mswsp_rangeboundry_cclabel , tvb , offset , 4 , ENC_LITTLE_ENDIAN , & ccLabel ) ;\n offset += 4 ;\n proto_tree_add_item_ret_string ( tree , hf_mswsp_rangeboundry_label , tvb , offset , 2 * ccLabel , ENC_LITTLE_ENDIAN | ENC_UCS_2 , wmem_packet_scope ( ) , & label ) ;\n proto_item_append_text ( item , \" Label: \\\"%s\\\"\" , label ) ;\n offset += 2 * ccLabel ;\n }\n proto_item_append_text ( item , \" Val: %s\" , str_CBaseStorageVariant ( & prval , TRUE ) ) ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "hash": 3584320764213684062, "project": "debian", "size": 36, "target": 1, "idx": 21230}
{"code": "static int parse_CDbProp ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , struct GuidPropertySet * propset , const char * fmt , ... ) {\n static const value_string EMPTY_VS [ ] = {\n {\n 0 , NULL }\n }\n ;\n const value_string * vs = ( propset && propset -> id_map ) ? propset -> id_map : EMPTY_VS ;\n guint32 id , opt , status ;\n struct CBaseStorageVariant value ;\n proto_item * item ;\n proto_tree * tree ;\n const char * str , * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CDbProp , & item , txt ) ;\n id = tvb_get_letohl ( tvb , offset ) ;\n str = val_to_str ( id , vs , \"0x%08x\" ) ;\n proto_tree_add_string_format_value ( tree , hf_mswsp_cdbprop_id , tvb , offset , 4 , str , \"%s (0x%08x)\" , ( str [ 0 ] == '0' ? \"\" : str ) , id ) ;\n offset += 4 ;\n proto_item_append_text ( item , \" Id: %s\" , str ) ;\n opt = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_cdbprop_options , tvb , offset , 4 , opt ) ;\n offset += 4 ;\n status = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_cdbprop_status , tvb , offset , 4 , status ) ;\n offset += 4 ;\n offset = parse_CDbColId ( tvb , offset , tree , pad_tree , \"colid\" ) ;\n offset = parse_CBaseStorageVariant ( tvb , offset , tree , pad_tree , & value , \"vValue\" ) ;\n str = str_CBaseStorageVariant ( & value , TRUE ) ;\n proto_item_append_text ( item , \" %s\" , str ) ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "hash": 3584320764213684062, "project": "debian", "size": 35, "target": 1, "idx": 21238}
{"code": "int parse_CCategorizationSpec ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n proto_item * item ;\n proto_tree * tree ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CCategorizationSpec , & item , txt ) ;\n offset = parse_CColumnSet ( tvb , offset , tree , \"csColumns\" ) ;\n offset = parse_CCategSpec ( tvb , offset , tree , pad_tree , \"Spec\" ) ;\n offset = parse_CAggregSet ( tvb , offset , tree , pad_tree , \"AggregSet\" ) ;\n offset = parse_CSortAggregSet ( tvb , offset , tree , pad_tree , \"SortAggregSet\" ) ;\n offset = parse_CInGroupSortAggregSets ( tvb , offset , tree , pad_tree , \"InGroupSortAggregSets\" ) ;\n proto_tree_add_item ( tree , hf_mswsp_categorizationspec_cmaxres , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "hash": 3584320764213684062, "project": "debian", "size": 19, "target": 1, "idx": 21244}
{"code": "int parse_CRangeCategSpec ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n proto_item * item ;\n proto_tree * tree ;\n va_list ap ;\n unsigned i ;\n const char * txt ;\n guint32 cRange ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CRangeCategSpec , & item , txt ) ;\n offset = parse_lcid ( tvb , offset , tree , \"lcid\" ) ;\n cRange = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_crangecategspec_crange , tvb , offset , 4 , cRange ) ;\n offset += 4 ;\n for ( i = 0 ;\n i < cRange ;\n i ++ ) {\n offset = parse_RANGEBOUNDARY ( tvb , offset , tree , pad_tree , \"aRangeBegin[%u]\" , i ) ;\n }\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }", "hash": 3584320764213684062, "project": "debian", "size": 23, "target": 1, "idx": 21247}
{"code": "static guint16 dissect_mpa_fpdu ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , mpa_state_t * state , struct tcpinfo * tcpinfo , guint8 endpoint ) {\n proto_item * mpa_item = NULL ;\n proto_item * mpa_header_item = NULL ;\n proto_tree * mpa_tree = NULL ;\n proto_tree * mpa_header_tree = NULL ;\n guint8 pad_length ;\n guint16 ulpdu_length , exp_ulpdu_length ;\n guint32 offset , total_length ;\n guint32 num_of_m = 0 ;\n if ( state -> minfo [ endpoint ] . valid && get_first_marker_offset ( state , tcpinfo , endpoint ) == 0 ) {\n offset = MPA_MARKER_LEN ;\n }\n else {\n offset = 0 ;\n }\n ulpdu_length = ( guint16 ) tvb_get_ntohs ( tvb , offset ) ;\n mpa_packetlist ( pinfo , MPA_FPDU ) ;\n if ( state -> minfo [ endpoint ] . valid ) {\n num_of_m = number_of_markers ( state , tcpinfo , endpoint ) ;\n }\n pad_length = fpdu_pad_length ( ulpdu_length ) ;\n exp_ulpdu_length = expected_ulpdu_length ( state , tcpinfo , endpoint ) ;\n if ( ! exp_ulpdu_length || exp_ulpdu_length != ( ulpdu_length + pad_length ) ) {\n proto_tree_add_expert_format ( tree , pinfo , & ei_mpa_bad_length , tvb , offset , MPA_ULPDU_LENGTH_LEN , \"[ULPDU length [%u] field does not contain the expected length[%u]]\" , exp_ulpdu_length , ulpdu_length + pad_length ) ;\n }\n mpa_item = proto_tree_add_item ( tree , proto_iwarp_mpa , tvb , 0 , - 1 , ENC_NA ) ;\n mpa_tree = proto_item_add_subtree ( mpa_item , ett_mpa ) ;\n mpa_header_item = proto_tree_add_item ( mpa_tree , hf_mpa_fpdu , tvb , offset , - 1 , ENC_NA ) ;\n mpa_header_tree = proto_item_add_subtree ( mpa_header_item , ett_mpa ) ;\n proto_tree_add_uint ( mpa_header_tree , hf_mpa_ulpdu_length , tvb , offset , MPA_ULPDU_LENGTH_LEN , ulpdu_length ) ;\n if ( state -> minfo [ endpoint ] . valid && num_of_m > 0 ) {\n total_length = fpdu_total_length ( tcpinfo ) ;\n if ( pad_length > 0 ) {\n proto_tree_add_item ( mpa_header_tree , hf_mpa_pad , tvb , pad_offset ( tcpinfo , total_length , pad_length ) , pad_length , ENC_NA ) ;\n }\n dissect_fpdu_crc ( tvb , mpa_header_tree , state , total_length - MPA_CRC_LEN , num_of_m * MPA_MARKER_LEN + ulpdu_length + pad_length + MPA_ULPDU_LENGTH_LEN ) ;\n dissect_fpdu_markers ( tvb , mpa_tree , state , tcpinfo , endpoint ) ;\n }\n else {\n offset += MPA_ULPDU_LENGTH_LEN + ulpdu_length ;\n if ( pad_length > 0 ) {\n proto_tree_add_item ( mpa_header_tree , hf_mpa_pad , tvb , offset , pad_length , ENC_NA ) ;\n offset += pad_length ;\n }\n dissect_fpdu_crc ( tvb , mpa_header_tree , state , offset , ulpdu_length + pad_length + MPA_ULPDU_LENGTH_LEN ) ;\n }\n return ulpdu_length ;\n }", "hash": -8178805850432684665, "project": "debian", "size": 48, "target": 1, "idx": 21256}
{"code": "double mcv_selectivity ( VariableStatData * vardata , FmgrInfo * opproc , Datum constval , bool varonleft , double * sumcommonp ) {\n double mcv_selec , sumcommon ;\n Datum * values ;\n int nvalues ;\n float4 * numbers ;\n int nnumbers ;\n int i ;\n mcv_selec = 0.0 ;\n sumcommon = 0.0 ;\n if ( HeapTupleIsValid ( vardata -> statsTuple ) && get_attstatsslot ( vardata -> statsTuple , vardata -> atttype , vardata -> atttypmod , STATISTIC_KIND_MCV , InvalidOid , NULL , & values , & nvalues , & numbers , & nnumbers ) ) {\n for ( i = 0 ;\n i < nvalues ;\n i ++ ) {\n if ( varonleft ? DatumGetBool ( FunctionCall2Coll ( opproc , DEFAULT_COLLATION_OID , values [ i ] , constval ) ) : DatumGetBool ( FunctionCall2Coll ( opproc , DEFAULT_COLLATION_OID , constval , values [ i ] ) ) ) mcv_selec += numbers [ i ] ;\n sumcommon += numbers [ i ] ;\n }\n free_attstatsslot ( vardata -> atttype , values , nvalues , numbers , nnumbers ) ;\n }\n * sumcommonp = sumcommon ;\n return mcv_selec ;\n }", "hash": 355220887711506893, "project": "debian", "size": 21, "target": 1, "idx": 21270}
{"code": "void examine_variable ( PlannerInfo * root , Node * node , int varRelid , VariableStatData * vardata ) {\n Node * basenode ;\n Relids varnos ;\n RelOptInfo * onerel ;\n MemSet ( vardata , 0 , sizeof ( VariableStatData ) ) ;\n vardata -> vartype = exprType ( node ) ;\n if ( IsA ( node , RelabelType ) ) basenode = ( Node * ) ( ( RelabelType * ) node ) -> arg ;\n else basenode = node ;\n if ( IsA ( basenode , Var ) && ( varRelid == 0 || varRelid == ( ( Var * ) basenode ) -> varno ) ) {\n Var * var = ( Var * ) basenode ;\n vardata -> var = basenode ;\n vardata -> rel = find_base_rel ( root , var -> varno ) ;\n vardata -> atttype = var -> vartype ;\n vardata -> atttypmod = var -> vartypmod ;\n vardata -> isunique = has_unique_index ( vardata -> rel , var -> varattno ) ;\n examine_simple_variable ( root , var , vardata ) ;\n return ;\n }\n varnos = pull_varnos ( basenode ) ;\n onerel = NULL ;\n switch ( bms_membership ( varnos ) ) {\n case BMS_EMPTY_SET : break ;\n case BMS_SINGLETON : if ( varRelid == 0 || bms_is_member ( varRelid , varnos ) ) {\n onerel = find_base_rel ( root , ( varRelid ? varRelid : bms_singleton_member ( varnos ) ) ) ;\n vardata -> rel = onerel ;\n node = basenode ;\n }\n break ;\n case BMS_MULTIPLE : if ( varRelid == 0 ) {\n vardata -> rel = find_join_rel ( root , varnos ) ;\n node = basenode ;\n }\n else if ( bms_is_member ( varRelid , varnos ) ) {\n vardata -> rel = find_base_rel ( root , varRelid ) ;\n node = basenode ;\n }\n break ;\n }\n bms_free ( varnos ) ;\n vardata -> var = node ;\n vardata -> atttype = exprType ( node ) ;\n vardata -> atttypmod = exprTypmod ( node ) ;\n if ( onerel ) {\n ListCell * ilist ;\n foreach ( ilist , onerel -> indexlist ) {\n IndexOptInfo * index = ( IndexOptInfo * ) lfirst ( ilist ) ;\n ListCell * indexpr_item ;\n int pos ;\n indexpr_item = list_head ( index -> indexprs ) ;\n if ( indexpr_item == NULL ) continue ;\n for ( pos = 0 ;\n pos < index -> ncolumns ;\n pos ++ ) {\n if ( index -> indexkeys [ pos ] == 0 ) {\n Node * indexkey ;\n if ( indexpr_item == NULL ) elog ( ERROR , \"too few entries in indexprs list\" ) ;\n indexkey = ( Node * ) lfirst ( indexpr_item ) ;\n if ( indexkey && IsA ( indexkey , RelabelType ) ) indexkey = ( Node * ) ( ( RelabelType * ) indexkey ) -> arg ;\n if ( equal ( node , indexkey ) ) {\n if ( index -> unique && index -> ncolumns == 1 && ( index -> indpred == NIL || index -> predOK ) ) vardata -> isunique = true ;\n if ( get_index_stats_hook && ( * get_index_stats_hook ) ( root , index -> indexoid , pos + 1 , vardata ) ) {\n if ( HeapTupleIsValid ( vardata -> statsTuple ) && ! vardata -> freefunc ) elog ( ERROR , \"no function provided to release variable stats with\" ) ;\n }\n else if ( index -> indpred == NIL ) {\n vardata -> statsTuple = SearchSysCache3 ( STATRELATTINH , ObjectIdGetDatum ( index -> indexoid ) , Int16GetDatum ( pos + 1 ) , BoolGetDatum ( false ) ) ;\n vardata -> freefunc = ReleaseSysCache ;\n }\n if ( vardata -> statsTuple ) break ;\n }\n indexpr_item = lnext ( indexpr_item ) ;\n }\n }\n if ( vardata -> statsTuple ) break ;\n }\n }\n }", "hash": 355220887711506893, "project": "debian", "size": 76, "target": 1, "idx": 21272}
{"code": "static void save_command ( guint32 cmd , guint32 arg0 , guint32 arg1 , guint32 data_length , guint32 crc32 , service_data_t * service_data , gint proto , void * data , packet_info * pinfo , service_data_t * * returned_service_data , command_data_t * * returned_command_data ) {\n wmem_tree_key_t key [ 6 ] ;\n guint32 interface_id ;\n guint32 bus_id ;\n guint32 device_address ;\n guint32 side_id ;\n guint32 frame_number ;\n command_data_t * command_data ;\n wmem_tree_t * wmem_tree ;\n gint direction = P2P_DIR_UNKNOWN ;\n usb_conv_info_t * usb_conv_info = ( usb_conv_info_t * ) data ;\n frame_number = pinfo -> num ;\n if ( pinfo -> phdr -> presence_flags & WTAP_HAS_INTERFACE_ID ) interface_id = pinfo -> phdr -> interface_id ;\n else interface_id = 0 ;\n if ( proto == proto_usb ) {\n usb_conv_info = ( usb_conv_info_t * ) data ;\n DISSECTOR_ASSERT ( usb_conv_info ) ;\n direction = usb_conv_info -> direction ;\n bus_id = usb_conv_info -> bus_id ;\n device_address = usb_conv_info -> device_address ;\n key [ 0 ] . length = 1 ;\n key [ 0 ] . key = & interface_id ;\n key [ 1 ] . length = 1 ;\n key [ 1 ] . key = & bus_id ;\n key [ 2 ] . length = 1 ;\n key [ 2 ] . key = & device_address ;\n key [ 3 ] . length = 1 ;\n key [ 3 ] . key = & side_id ;\n key [ 4 ] . length = 1 ;\n key [ 4 ] . key = & frame_number ;\n key [ 5 ] . length = 0 ;\n key [ 5 ] . key = NULL ;\n }\n else {\n if ( pinfo -> destport == ADB_TCP_PORT ) direction = P2P_DIR_SENT ;\n else direction = P2P_DIR_RECV ;\n key [ 0 ] . length = 1 ;\n key [ 0 ] . key = & interface_id ;\n key [ 1 ] . length = 1 ;\n key [ 2 ] . length = 1 ;\n if ( direction == P2P_DIR_SENT ) {\n key [ 1 ] . key = & pinfo -> srcport ;\n key [ 2 ] . key = & pinfo -> destport ;\n }\n else {\n key [ 1 ] . key = & pinfo -> destport ;\n key [ 2 ] . key = & pinfo -> srcport ;\n }\n key [ 3 ] . length = 1 ;\n key [ 3 ] . key = & side_id ;\n key [ 4 ] . length = 1 ;\n key [ 4 ] . key = & frame_number ;\n key [ 5 ] . length = 0 ;\n key [ 5 ] . key = NULL ;\n }\n if ( direction == P2P_DIR_SENT ) if ( cmd == A_CLSE ) side_id = arg1 ;\n else side_id = arg0 ;\n else side_id = arg1 ;\n if ( cmd == A_OPEN ) {\n service_data = wmem_new ( wmem_file_scope ( ) , service_data_t ) ;\n service_data -> start_in_frame = pinfo -> num ;\n service_data -> close_local_in_frame = max_in_frame ;\n service_data -> close_remote_in_frame = max_in_frame ;\n service_data -> local_id = arg0 ;\n service_data -> remote_id = arg1 ;\n service_data -> service = \"unknown\" ;\n wmem_tree_insert32_array ( service_info , key , service_data ) ;\n }\n command_data = wmem_new ( wmem_file_scope ( ) , command_data_t ) ;\n command_data -> command = cmd ;\n command_data -> arg0 = arg0 ;\n command_data -> arg1 = arg1 ;\n command_data -> command_in_frame = pinfo -> num ;\n command_data -> response_in_frame = max_in_frame ;\n command_data -> crc32 = crc32 ;\n command_data -> data_length = data_length ;\n if ( data_length == 0 ) command_data -> completed_in_frame = pinfo -> num ;\n else command_data -> completed_in_frame = max_in_frame ;\n command_data -> reassemble_data_length = 0 ;\n command_data -> reassemble_data = ( guint8 * ) wmem_alloc ( wmem_file_scope ( ) , command_data -> data_length ) ;\n key [ 3 ] . length = 1 ;\n key [ 3 ] . key = & frame_number ;\n key [ 4 ] . length = 0 ;\n key [ 4 ] . key = NULL ;\n wmem_tree_insert32_array ( command_info , key , command_data ) ;\n if ( direction == P2P_DIR_SENT ) if ( command_data -> command == A_CLSE ) side_id = command_data -> arg1 ;\n else side_id = command_data -> arg0 ;\n else side_id = command_data -> arg1 ;\n key [ 3 ] . length = 1 ;\n key [ 3 ] . key = & side_id ;\n key [ 4 ] . length = 0 ;\n key [ 4 ] . key = NULL ;\n wmem_tree = ( wmem_tree_t * ) wmem_tree_lookup32_array ( service_info , key ) ;\n if ( wmem_tree ) {\n service_data = ( service_data_t * ) wmem_tree_lookup32_le ( wmem_tree , frame_number ) ;\n }\n if ( cmd == A_OKAY ) {\n if ( ! service_data ) {\n if ( direction == P2P_DIR_SENT ) side_id = command_data -> arg0 ;\n else side_id = command_data -> arg1 ;\n wmem_tree = ( wmem_tree_t * ) wmem_tree_lookup32_array ( service_info , key ) ;\n if ( wmem_tree ) {\n service_data = ( service_data_t * ) wmem_tree_lookup32_le ( wmem_tree , frame_number ) ;\n }\n }\n if ( service_data && service_data -> remote_id == 0 && direction == P2P_DIR_RECV ) {\n if ( direction == P2P_DIR_SENT ) {\n service_data -> remote_id = arg1 ;\n }\n else {\n service_data -> remote_id = arg0 ;\n }\n side_id = service_data -> remote_id ;\n key [ 4 ] . length = 1 ;\n key [ 4 ] . key = & frame_number ;\n key [ 5 ] . length = 0 ;\n key [ 5 ] . key = NULL ;\n wmem_tree_insert32_array ( service_info , key , service_data ) ;\n }\n }\n else if ( cmd == A_CLSE ) {\n if ( service_data ) {\n if ( direction == P2P_DIR_RECV && service_data -> local_id == arg1 ) service_data -> close_local_in_frame = pinfo -> num ;\n else if ( direction == P2P_DIR_SENT && service_data -> remote_id == arg1 ) service_data -> close_remote_in_frame = pinfo -> num ;\n }\n }\n DISSECTOR_ASSERT ( returned_service_data && returned_command_data ) ;\n * returned_service_data = service_data ;\n * returned_command_data = command_data ;\n }", "hash": 2666714143406757810, "project": "debian", "size": 130, "target": 1, "idx": 21301}
{"code": "static __inline__ __u32 __arch_swab32 ( __u32 val ) {\n __asm__ ( \"bswapl %0\" : \"=r\" ( val ) : \"0\" ( val ) ) ;\n return val ;\n }", "hash": 2930500905204315787, "project": "debian", "size": 4, "target": 1, "idx": 21323}
{"code": "static void record_recent_object ( struct object * obj , const struct name_path * path , const char * last , void * data ) {\n sha1_array_append ( & recent_objects , obj -> oid . hash ) ;\n }", "hash": 3919646340804521652, "project": "debian", "size": 3, "target": 1, "idx": 21339}
{"code": "const EVP_CIPHER * EVP_aes_ ## keylen ## _ ## mode ( void ) \\ {\n return & aes_ ## keylen ## _ ## mode ;\n }\n # endif # if defined ( OPENSSL_CPUID_OBJ ) && ( defined ( __arm__ ) || defined ( __arm ) || defined ( __aarch64__ ) ) # include \"arm_arch.h\" # if __ARM_MAX_ARCH__ >= 7 # if defined ( BSAES_ASM ) # define BSAES_CAPABLE ( OPENSSL_armcap_P & ARMV7_NEON ) # endif # if defined ( VPAES_ASM ) # define VPAES_CAPABLE ( OPENSSL_armcap_P & ARMV7_NEON ) # endif # define HWAES_CAPABLE ( OPENSSL_armcap_P & ARMV8_AES ) # define HWAES_set_encrypt_key aes_v8_set_encrypt_key # define HWAES_set_decrypt_key aes_v8_set_decrypt_key # define HWAES_encrypt aes_v8_encrypt # define HWAES_decrypt aes_v8_decrypt # define HWAES_cbc_encrypt aes_v8_cbc_encrypt # define HWAES_ctr32_encrypt_blocks aes_v8_ctr32_encrypt_blocks # endif # endif # if defined ( HWAES_CAPABLE ) int HWAES_set_encrypt_key ( const unsigned char * userKey , const int bits , AES_KEY * key ) ;\n int HWAES_set_decrypt_key ( const unsigned char * userKey , const int bits , AES_KEY * key ) ;\n void HWAES_encrypt ( const unsigned char * in , unsigned char * out , const AES_KEY * key ) ;\n void HWAES_decrypt ( const unsigned char * in , unsigned char * out , const AES_KEY * key ) ;\n void HWAES_cbc_encrypt ( const unsigned char * in , unsigned char * out , size_t length , const AES_KEY * key , unsigned char * ivec , const int enc ) ;\n void HWAES_ctr32_encrypt_blocks ( const unsigned char * in , unsigned char * out , size_t len , const AES_KEY * key , const unsigned char ivec [ 16 ] ) ;\n void HWAES_xts_encrypt ( const unsigned char * inp , unsigned char * out , size_t len , const AES_KEY * key1 , const AES_KEY * key2 , const unsigned char iv [ 16 ] ) ;\n void HWAES_xts_decrypt ( const unsigned char * inp , unsigned char * out , size_t len , const AES_KEY * key1 , const AES_KEY * key2 , const unsigned char iv [ 16 ] ) ;\n # endif # define BLOCK_CIPHER_generic_pack ( nid , keylen , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 16 , 16 , cbc , cbc , CBC , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 16 , 0 , ecb , ecb , ECB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , ofb128 , ofb , OFB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb128 , cfb , CFB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb1 , cfb1 , CFB , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb8 , cfb8 , CFB , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , ctr , ctr , CTR , flags ) static int aes_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n int ret , mode ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n mode = EVP_CIPHER_CTX_mode ( ctx ) ;\n if ( ( mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE ) && ! enc ) {\n # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n ret = HWAES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) HWAES_decrypt ;\n dat -> stream . cbc = NULL ;\n # ifdef HWAES_cbc_encrypt if ( mode == EVP_CIPH_CBC_MODE ) dat -> stream . cbc = ( cbc128_f ) HWAES_cbc_encrypt ;\n # endif }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE && mode == EVP_CIPH_CBC_MODE ) {\n ret = AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_decrypt ;\n dat -> stream . cbc = ( cbc128_f ) bsaes_cbc_encrypt ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n ret = vpaes_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) vpaes_decrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) vpaes_cbc_encrypt : NULL ;\n }\n else # endif {\n ret = AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_decrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) AES_cbc_encrypt : NULL ;\n }\n }\n else # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n ret = HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) HWAES_encrypt ;\n dat -> stream . cbc = NULL ;\n # ifdef HWAES_cbc_encrypt if ( mode == EVP_CIPH_CBC_MODE ) dat -> stream . cbc = ( cbc128_f ) HWAES_cbc_encrypt ;\n else # endif # ifdef HWAES_ctr32_encrypt_blocks if ( mode == EVP_CIPH_CTR_MODE ) dat -> stream . ctr = ( ctr128_f ) HWAES_ctr32_encrypt_blocks ;\n else # endif ( void ) 0 ;\n }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE && mode == EVP_CIPH_CTR_MODE ) {\n ret = AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_encrypt ;\n dat -> stream . ctr = ( ctr128_f ) bsaes_ctr32_encrypt_blocks ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n ret = vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) vpaes_encrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) vpaes_cbc_encrypt : NULL ;\n }\n else # endif {\n ret = AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_encrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) AES_cbc_encrypt : NULL ;\n # ifdef AES_CTR_ASM if ( mode == EVP_CIPH_CTR_MODE ) dat -> stream . ctr = ( ctr128_f ) AES_ctr32_encrypt ;\n # endif }\n if ( ret < 0 ) {\n EVPerr ( EVP_F_AES_INIT_KEY , EVP_R_AES_KEY_SETUP_FAILED ) ;\n return 0 ;\n }\n return 1 ;\n }\n static int aes_cbc_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( dat -> stream . cbc ) ( * dat -> stream . cbc ) ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_encrypting ( ctx ) ) ;\n else if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) CRYPTO_cbc128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , dat -> block ) ;\n else CRYPTO_cbc128_decrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , dat -> block ) ;\n return 1 ;\n }\n static int aes_ecb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n size_t bl = EVP_CIPHER_CTX_block_size ( ctx ) ;\n size_t i ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( len < bl ) return 1 ;\n for ( i = 0 , len -= bl ;\n i <= len ;\n i += bl ) ( * dat -> block ) ( in + i , out + i , & dat -> ks ) ;\n return 1 ;\n }\n static int aes_ofb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_ofb128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb8_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_8_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb1_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( EVP_CIPHER_CTX_test_flags ( ctx , EVP_CIPH_FLAG_LENGTH_BITS ) ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n while ( len >= MAXBITCHUNK ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , MAXBITCHUNK * 8 , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n len -= MAXBITCHUNK ;\n }\n if ( len ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , len * 8 , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n }\n return 1 ;\n }\n static int aes_ctr_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n unsigned int num = EVP_CIPHER_CTX_num ( ctx ) ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( dat -> stream . ctr ) CRYPTO_ctr128_encrypt_ctr32 ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_buf_noconst ( ctx ) , & num , dat -> stream . ctr ) ;\n else CRYPTO_ctr128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_buf_noconst ( ctx ) , & num , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n BLOCK_CIPHER_generic_pack ( NID_aes , 128 , 0 ) BLOCK_CIPHER_generic_pack ( NID_aes , 192 , 0 ) BLOCK_CIPHER_generic_pack ( NID_aes , 256 , 0 ) static int aes_gcm_cleanup ( EVP_CIPHER_CTX * c ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n OPENSSL_cleanse ( & gctx -> gcm , sizeof ( gctx -> gcm ) ) ;\n if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ;\n return 1 ;\n }\n static void ctr64_inc ( unsigned char * counter ) {\n int n = 8 ;\n unsigned char c ;\n do {\n -- n ;\n c = counter [ n ] ;\n ++ c ;\n counter [ n ] = c ;\n if ( c ) return ;\n }\n while ( n ) ;\n }\n static int aes_gcm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n switch ( type ) {\n case EVP_CTRL_INIT : gctx -> key_set = 0 ;\n gctx -> iv_set = 0 ;\n gctx -> ivlen = EVP_CIPHER_CTX_iv_length ( c ) ;\n gctx -> iv = EVP_CIPHER_CTX_iv_noconst ( c ) ;\n gctx -> taglen = - 1 ;\n gctx -> iv_gen = 0 ;\n gctx -> tls_aad_len = - 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 ) return 0 ;\n if ( ( arg > EVP_MAX_IV_LENGTH ) && ( arg > gctx -> ivlen ) ) {\n if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ;\n gctx -> iv = OPENSSL_malloc ( arg ) ;\n if ( gctx -> iv == NULL ) return 0 ;\n }\n gctx -> ivlen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n gctx -> taglen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > 16 || ! EVP_CIPHER_CTX_encrypting ( c ) || gctx -> taglen < 0 ) return 0 ;\n memcpy ( ptr , EVP_CIPHER_CTX_buf_noconst ( c ) , arg ) ;\n return 1 ;\n case EVP_CTRL_GCM_SET_IV_FIXED : if ( arg == - 1 ) {\n memcpy ( gctx -> iv , ptr , gctx -> ivlen ) ;\n gctx -> iv_gen = 1 ;\n return 1 ;\n }\n if ( ( arg < 4 ) || ( gctx -> ivlen - arg ) < 8 ) return 0 ;\n if ( arg ) memcpy ( gctx -> iv , ptr , arg ) ;\n if ( EVP_CIPHER_CTX_encrypting ( c ) && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 ) return 0 ;\n gctx -> iv_gen = 1 ;\n return 1 ;\n case EVP_CTRL_GCM_IV_GEN : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 ) return 0 ;\n CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ;\n if ( arg <= 0 || arg > gctx -> ivlen ) arg = gctx -> ivlen ;\n memcpy ( ptr , gctx -> iv + gctx -> ivlen - arg , arg ) ;\n ctr64_inc ( gctx -> iv + gctx -> ivlen - 8 ) ;\n gctx -> iv_set = 1 ;\n return 1 ;\n case EVP_CTRL_GCM_SET_IV_INV : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( gctx -> iv + gctx -> ivlen - arg , ptr , arg ) ;\n CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n gctx -> tls_aad_len = arg ;\n {\n unsigned int len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) len -= EVP_GCM_TLS_TAG_LEN ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ;\n }\n return EVP_GCM_TLS_TAG_LEN ;\n case EVP_CTRL_COPY : {\n EVP_CIPHER_CTX * out = ptr ;\n EVP_AES_GCM_CTX * gctx_out = EVP_C_DATA ( EVP_AES_GCM_CTX , out ) ;\n if ( gctx -> gcm . key ) {\n if ( gctx -> gcm . key != & gctx -> ks ) return 0 ;\n gctx_out -> gcm . key = & gctx_out -> ks ;\n }\n if ( gctx -> iv == EVP_CIPHER_CTX_iv_noconst ( c ) ) gctx_out -> iv = EVP_CIPHER_CTX_iv_noconst ( out ) ;\n else {\n gctx_out -> iv = OPENSSL_malloc ( gctx -> ivlen ) ;\n if ( gctx_out -> iv == NULL ) return 0 ;\n memcpy ( gctx_out -> iv , gctx -> iv , gctx -> ivlen ) ;\n }\n return 1 ;\n }\n default : return - 1 ;\n }\n }\n static int aes_gcm_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n if ( ! iv && ! key ) return 1 ;\n if ( key ) {\n do {\n # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) HWAES_encrypt ) ;\n # ifdef HWAES_ctr32_encrypt_blocks gctx -> ctr = ( ctr128_f ) HWAES_ctr32_encrypt_blocks ;\n # else gctx -> ctr = NULL ;\n # endif break ;\n }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE ) {\n AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) AES_encrypt ) ;\n gctx -> ctr = ( ctr128_f ) bsaes_ctr32_encrypt_blocks ;\n break ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) vpaes_encrypt ) ;\n gctx -> ctr = NULL ;\n break ;\n }\n else # endif ( void ) 0 ;\n AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) AES_encrypt ) ;\n # ifdef AES_CTR_ASM gctx -> ctr = ( ctr128_f ) AES_ctr32_encrypt ;\n # else gctx -> ctr = NULL ;\n # endif }\n while ( 0 ) ;\n if ( iv == NULL && gctx -> iv_set ) iv = gctx -> iv ;\n if ( iv ) {\n CRYPTO_gcm128_setiv ( & gctx -> gcm , iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n }\n gctx -> key_set = 1 ;\n }\n else {\n if ( gctx -> key_set ) CRYPTO_gcm128_setiv ( & gctx -> gcm , iv , gctx -> ivlen ) ;\n else memcpy ( gctx -> iv , iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n gctx -> iv_gen = 0 ;\n }\n return 1 ;\n }\n static int aes_gcm_tls_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n int rv = - 1 ;\n if ( out != in || len < ( EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ) ) return - 1 ;\n if ( EVP_CIPHER_CTX_ctrl ( ctx , EVP_CIPHER_CTX_encrypting ( ctx ) ? EVP_CTRL_GCM_IV_GEN : EVP_CTRL_GCM_SET_IV_INV , EVP_GCM_TLS_EXPLICIT_IV_LEN , out ) <= 0 ) goto err ;\n if ( CRYPTO_gcm128_aad ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , gctx -> tls_aad_len ) ) goto err ;\n in += EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n out += EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n len -= EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ;\n if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 32 && AES_GCM_ASM ( gctx ) ) {\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_encrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) goto err ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 32 && AES_GCM_ASM2 ( gctx ) ) {\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) goto err ;\n }\n out += len ;\n CRYPTO_gcm128_tag ( & gctx -> gcm , out , EVP_GCM_TLS_TAG_LEN ) ;\n rv = len + EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ;\n }\n else {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 16 && AES_GCM_ASM ( gctx ) ) {\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_decrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) goto err ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 16 && AES_GCM_ASM2 ( gctx ) ) {\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) goto err ;\n }\n CRYPTO_gcm128_tag ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , EVP_GCM_TLS_TAG_LEN ) ;\n if ( CRYPTO_memcmp ( EVP_CIPHER_CTX_buf_noconst ( ctx ) , in + len , EVP_GCM_TLS_TAG_LEN ) ) {\n OPENSSL_cleanse ( out , len ) ;\n goto err ;\n }\n rv = len ;\n }\n err : gctx -> iv_set = 0 ;\n gctx -> tls_aad_len = - 1 ;\n return rv ;\n }\n static int aes_gcm_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n if ( ! gctx -> key_set ) return - 1 ;\n if ( gctx -> tls_aad_len >= 0 ) return aes_gcm_tls_cipher ( ctx , out , in , len ) ;\n if ( ! gctx -> iv_set ) return - 1 ;\n if ( in ) {\n if ( out == NULL ) {\n if ( CRYPTO_gcm128_aad ( & gctx -> gcm , in , len ) ) return - 1 ;\n }\n else if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 32 && AES_GCM_ASM ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_encrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) return - 1 ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 32 && AES_GCM_ASM2 ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) return - 1 ;\n }\n }\n else {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 16 && AES_GCM_ASM ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_decrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) return - 1 ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 16 && AES_GCM_ASM2 ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) return - 1 ;\n }\n }\n return len ;\n }\n else {\n if ( ! EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> taglen < 0 ) return - 1 ;\n if ( CRYPTO_gcm128_finish ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , gctx -> taglen ) != 0 ) return - 1 ;\n gctx -> iv_set = 0 ;\n return 0 ;\n }\n CRYPTO_gcm128_tag ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , 16 ) ;\n gctx -> taglen = 16 ;\n gctx -> iv_set = 0 ;\n return 0 ;\n }\n }\n # define CUSTOM_FLAGS ( EVP_CIPH_FLAG_DEFAULT_ASN1 \\ | EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \\ | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \\ | EVP_CIPH_CUSTOM_COPY ) BLOCK_CIPHER_custom ( NID_aes , 128 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS ) BLOCK_CIPHER_custom ( NID_aes , 192 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS ) BLOCK_CIPHER_custom ( NID_aes , 256 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS ) static int aes_xts_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n EVP_AES_XTS_CTX * xctx = EVP_C_DATA ( EVP_AES_XTS_CTX , c ) ;\n if ( type == EVP_CTRL_COPY ) {\n EVP_CIPHER_CTX * out = ptr ;\n EVP_AES_XTS_CTX * xctx_out = EVP_C_DATA ( EVP_AES_XTS_CTX , out ) ;\n if ( xctx -> xts . key1 ) {\n if ( xctx -> xts . key1 != & xctx -> ks1 ) return 0 ;\n xctx_out -> xts . key1 = & xctx_out -> ks1 ;\n }\n if ( xctx -> xts . key2 ) {\n if ( xctx -> xts . key2 != & xctx -> ks2 ) return 0 ;\n xctx_out -> xts . key2 = & xctx_out -> ks2 ;\n }\n return 1 ;\n }\n else if ( type != EVP_CTRL_INIT ) return - 1 ;\n xctx -> xts . key1 = NULL ;\n xctx -> xts . key2 = NULL ;\n return 1 ;\n }\n static int aes_xts_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n EVP_AES_XTS_CTX * xctx = EVP_C_DATA ( EVP_AES_XTS_CTX , ctx ) ;\n if ( ! iv && ! key ) return 1 ;\n if ( key ) do {\n # ifdef AES_XTS_ASM xctx -> stream = enc ? AES_xts_encrypt : AES_xts_decrypt ;\n # else xctx -> stream = NULL ;\n # endif # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n if ( enc ) {\n HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) HWAES_encrypt ;\n # ifdef HWAES_xts_encrypt xctx -> stream = HWAES_xts_encrypt ;\n # endif }\n else {\n HWAES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) HWAES_decrypt ;\n # ifdef HWAES_xts_decrypt xctx -> stream = HWAES_xts_decrypt ;\n # endif }\n HWAES_set_encrypt_key ( key + EVP_CIPHER_CTX_key_length ( ctx ) / 2 , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks2 . ks ) ;\n xctx -> xts . block2 = ( block128_f ) HWAES_encrypt ;\n xctx -> xts . key1 = & xctx -> ks1 ;\n break ;\n }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE ) xctx -> stream = enc ? bsaes_xts_encrypt : bsaes_xts_decrypt ;\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n if ( enc ) {\n vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) vpaes_encrypt ;\n }\n else {\n vpaes_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) vpaes_decrypt ;\n }\n vpaes_set_encrypt_key ( key + EVP_CIPHER_CTX_key_length ( ctx ) / 2 , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks2 . ks ) ;\n xctx -> xts . block2 = ( block128_f ) vpaes_encrypt ;\n xctx -> xts . key1 = & xctx -> ks1 ;\n break ;\n }\n else # endif ( void ) 0 ;\n if ( enc ) {\n AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) AES_encrypt ;\n }\n else {\n AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) AES_decrypt ;\n }\n AES_set_encrypt_key ( key + EVP_CIPHER_CTX_key_length ( ctx ) / 2 , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks2 . ks ) ;\n xctx -> xts . block2 = ( block128_f ) AES_encrypt ;\n xctx -> xts . key1 = & xctx -> ks1 ;\n }\n while ( 0 ) ;\n if ( iv ) {\n xctx -> xts . key2 = & xctx -> ks2 ;\n memcpy ( EVP_CIPHER_CTX_iv_noconst ( ctx ) , iv , 16 ) ;\n }\n return 1 ;\n }\n static int aes_xts_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_XTS_CTX * xctx = EVP_C_DATA ( EVP_AES_XTS_CTX , ctx ) ;\n if ( ! xctx -> xts . key1 || ! xctx -> xts . key2 ) return 0 ;\n if ( ! out || ! in || len < AES_BLOCK_SIZE ) return 0 ;\n if ( xctx -> stream ) ( * xctx -> stream ) ( in , out , len , xctx -> xts . key1 , xctx -> xts . key2 , EVP_CIPHER_CTX_iv_noconst ( ctx ) ) ;\n else if ( CRYPTO_xts128_encrypt ( & xctx -> xts , EVP_CIPHER_CTX_iv_noconst ( ctx ) , in , out , len , EVP_CIPHER_CTX_encrypting ( ctx ) ) ) return 0 ;\n return 1 ;\n }\n # define aes_xts_cleanup NULL # define XTS_FLAGS ( EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \\ | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \\ | EVP_CIPH_CUSTOM_COPY ) BLOCK_CIPHER_custom ( NID_aes , 128 , 1 , 16 , xts , XTS , XTS_FLAGS )", "hash": 8801969307247112896, "project": "debian", "size": 496, "target": 1, "idx": 21393}
{"code": "const EVP_CIPHER * EVP_aes_ ## keylen ## _ ## mode ( void ) \\ {\n return & aes_ ## keylen ## _ ## mode ;\n }\n # endif # if defined ( OPENSSL_CPUID_OBJ ) && ( defined ( __arm__ ) || defined ( __arm ) || defined ( __aarch64__ ) ) # include \"arm_arch.h\" # if __ARM_MAX_ARCH__ >= 7 # if defined ( BSAES_ASM ) # define BSAES_CAPABLE ( OPENSSL_armcap_P & ARMV7_NEON ) # endif # if defined ( VPAES_ASM ) # define VPAES_CAPABLE ( OPENSSL_armcap_P & ARMV7_NEON ) # endif # define HWAES_CAPABLE ( OPENSSL_armcap_P & ARMV8_AES ) # define HWAES_set_encrypt_key aes_v8_set_encrypt_key # define HWAES_set_decrypt_key aes_v8_set_decrypt_key # define HWAES_encrypt aes_v8_encrypt # define HWAES_decrypt aes_v8_decrypt # define HWAES_cbc_encrypt aes_v8_cbc_encrypt # define HWAES_ctr32_encrypt_blocks aes_v8_ctr32_encrypt_blocks # endif # endif # if defined ( HWAES_CAPABLE ) int HWAES_set_encrypt_key ( const unsigned char * userKey , const int bits , AES_KEY * key ) ;\n int HWAES_set_decrypt_key ( const unsigned char * userKey , const int bits , AES_KEY * key ) ;\n void HWAES_encrypt ( const unsigned char * in , unsigned char * out , const AES_KEY * key ) ;\n void HWAES_decrypt ( const unsigned char * in , unsigned char * out , const AES_KEY * key ) ;\n void HWAES_cbc_encrypt ( const unsigned char * in , unsigned char * out , size_t length , const AES_KEY * key , unsigned char * ivec , const int enc ) ;\n void HWAES_ctr32_encrypt_blocks ( const unsigned char * in , unsigned char * out , size_t len , const AES_KEY * key , const unsigned char ivec [ 16 ] ) ;\n void HWAES_xts_encrypt ( const unsigned char * inp , unsigned char * out , size_t len , const AES_KEY * key1 , const AES_KEY * key2 , const unsigned char iv [ 16 ] ) ;\n void HWAES_xts_decrypt ( const unsigned char * inp , unsigned char * out , size_t len , const AES_KEY * key1 , const AES_KEY * key2 , const unsigned char iv [ 16 ] ) ;\n # endif # define BLOCK_CIPHER_generic_pack ( nid , keylen , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 16 , 16 , cbc , cbc , CBC , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 16 , 0 , ecb , ecb , ECB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , ofb128 , ofb , OFB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb128 , cfb , CFB , flags | EVP_CIPH_FLAG_DEFAULT_ASN1 ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb1 , cfb1 , CFB , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , cfb8 , cfb8 , CFB , flags ) \\ BLOCK_CIPHER_generic ( nid , keylen , 1 , 16 , ctr , ctr , CTR , flags ) static int aes_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n int ret , mode ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n mode = EVP_CIPHER_CTX_mode ( ctx ) ;\n if ( ( mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE ) && ! enc ) {\n # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n ret = HWAES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) HWAES_decrypt ;\n dat -> stream . cbc = NULL ;\n # ifdef HWAES_cbc_encrypt if ( mode == EVP_CIPH_CBC_MODE ) dat -> stream . cbc = ( cbc128_f ) HWAES_cbc_encrypt ;\n # endif }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE && mode == EVP_CIPH_CBC_MODE ) {\n ret = AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_decrypt ;\n dat -> stream . cbc = ( cbc128_f ) bsaes_cbc_encrypt ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n ret = vpaes_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) vpaes_decrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) vpaes_cbc_encrypt : NULL ;\n }\n else # endif {\n ret = AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_decrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) AES_cbc_encrypt : NULL ;\n }\n }\n else # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n ret = HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) HWAES_encrypt ;\n dat -> stream . cbc = NULL ;\n # ifdef HWAES_cbc_encrypt if ( mode == EVP_CIPH_CBC_MODE ) dat -> stream . cbc = ( cbc128_f ) HWAES_cbc_encrypt ;\n else # endif # ifdef HWAES_ctr32_encrypt_blocks if ( mode == EVP_CIPH_CTR_MODE ) dat -> stream . ctr = ( ctr128_f ) HWAES_ctr32_encrypt_blocks ;\n else # endif ( void ) 0 ;\n }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE && mode == EVP_CIPH_CTR_MODE ) {\n ret = AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_encrypt ;\n dat -> stream . ctr = ( ctr128_f ) bsaes_ctr32_encrypt_blocks ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n ret = vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) vpaes_encrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) vpaes_cbc_encrypt : NULL ;\n }\n else # endif {\n ret = AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & dat -> ks . ks ) ;\n dat -> block = ( block128_f ) AES_encrypt ;\n dat -> stream . cbc = mode == EVP_CIPH_CBC_MODE ? ( cbc128_f ) AES_cbc_encrypt : NULL ;\n # ifdef AES_CTR_ASM if ( mode == EVP_CIPH_CTR_MODE ) dat -> stream . ctr = ( ctr128_f ) AES_ctr32_encrypt ;\n # endif }\n if ( ret < 0 ) {\n EVPerr ( EVP_F_AES_INIT_KEY , EVP_R_AES_KEY_SETUP_FAILED ) ;\n return 0 ;\n }\n return 1 ;\n }\n static int aes_cbc_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( dat -> stream . cbc ) ( * dat -> stream . cbc ) ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_encrypting ( ctx ) ) ;\n else if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) CRYPTO_cbc128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , dat -> block ) ;\n else CRYPTO_cbc128_decrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , dat -> block ) ;\n return 1 ;\n }\n static int aes_ecb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n size_t bl = EVP_CIPHER_CTX_block_size ( ctx ) ;\n size_t i ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( len < bl ) return 1 ;\n for ( i = 0 , len -= bl ;\n i <= len ;\n i += bl ) ( * dat -> block ) ( in + i , out + i , & dat -> ks ) ;\n return 1 ;\n }\n static int aes_ofb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_ofb128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb8_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_8_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n static int aes_cfb1_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( EVP_CIPHER_CTX_test_flags ( ctx , EVP_CIPH_FLAG_LENGTH_BITS ) ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n while ( len >= MAXBITCHUNK ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , MAXBITCHUNK * 8 , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n len -= MAXBITCHUNK ;\n }\n if ( len ) {\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_1_encrypt ( in , out , len * 8 , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n }\n return 1 ;\n }\n static int aes_ctr_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n unsigned int num = EVP_CIPHER_CTX_num ( ctx ) ;\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n if ( dat -> stream . ctr ) CRYPTO_ctr128_encrypt_ctr32 ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_buf_noconst ( ctx ) , & num , dat -> stream . ctr ) ;\n else CRYPTO_ctr128_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , EVP_CIPHER_CTX_buf_noconst ( ctx ) , & num , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }\n BLOCK_CIPHER_generic_pack ( NID_aes , 128 , 0 ) BLOCK_CIPHER_generic_pack ( NID_aes , 192 , 0 ) BLOCK_CIPHER_generic_pack ( NID_aes , 256 , 0 ) static int aes_gcm_cleanup ( EVP_CIPHER_CTX * c ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n OPENSSL_cleanse ( & gctx -> gcm , sizeof ( gctx -> gcm ) ) ;\n if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ;\n return 1 ;\n }\n static void ctr64_inc ( unsigned char * counter ) {\n int n = 8 ;\n unsigned char c ;\n do {\n -- n ;\n c = counter [ n ] ;\n ++ c ;\n counter [ n ] = c ;\n if ( c ) return ;\n }\n while ( n ) ;\n }\n static int aes_gcm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n switch ( type ) {\n case EVP_CTRL_INIT : gctx -> key_set = 0 ;\n gctx -> iv_set = 0 ;\n gctx -> ivlen = EVP_CIPHER_CTX_iv_length ( c ) ;\n gctx -> iv = EVP_CIPHER_CTX_iv_noconst ( c ) ;\n gctx -> taglen = - 1 ;\n gctx -> iv_gen = 0 ;\n gctx -> tls_aad_len = - 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 ) return 0 ;\n if ( ( arg > EVP_MAX_IV_LENGTH ) && ( arg > gctx -> ivlen ) ) {\n if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ;\n gctx -> iv = OPENSSL_malloc ( arg ) ;\n if ( gctx -> iv == NULL ) return 0 ;\n }\n gctx -> ivlen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n gctx -> taglen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > 16 || ! EVP_CIPHER_CTX_encrypting ( c ) || gctx -> taglen < 0 ) return 0 ;\n memcpy ( ptr , EVP_CIPHER_CTX_buf_noconst ( c ) , arg ) ;\n return 1 ;\n case EVP_CTRL_GCM_SET_IV_FIXED : if ( arg == - 1 ) {\n memcpy ( gctx -> iv , ptr , gctx -> ivlen ) ;\n gctx -> iv_gen = 1 ;\n return 1 ;\n }\n if ( ( arg < 4 ) || ( gctx -> ivlen - arg ) < 8 ) return 0 ;\n if ( arg ) memcpy ( gctx -> iv , ptr , arg ) ;\n if ( EVP_CIPHER_CTX_encrypting ( c ) && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 ) return 0 ;\n gctx -> iv_gen = 1 ;\n return 1 ;\n case EVP_CTRL_GCM_IV_GEN : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 ) return 0 ;\n CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ;\n if ( arg <= 0 || arg > gctx -> ivlen ) arg = gctx -> ivlen ;\n memcpy ( ptr , gctx -> iv + gctx -> ivlen - arg , arg ) ;\n ctr64_inc ( gctx -> iv + gctx -> ivlen - 8 ) ;\n gctx -> iv_set = 1 ;\n return 1 ;\n case EVP_CTRL_GCM_SET_IV_INV : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( gctx -> iv + gctx -> ivlen - arg , ptr , arg ) ;\n CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n gctx -> tls_aad_len = arg ;\n {\n unsigned int len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) len -= EVP_GCM_TLS_TAG_LEN ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ;\n }\n return EVP_GCM_TLS_TAG_LEN ;\n case EVP_CTRL_COPY : {\n EVP_CIPHER_CTX * out = ptr ;\n EVP_AES_GCM_CTX * gctx_out = EVP_C_DATA ( EVP_AES_GCM_CTX , out ) ;\n if ( gctx -> gcm . key ) {\n if ( gctx -> gcm . key != & gctx -> ks ) return 0 ;\n gctx_out -> gcm . key = & gctx_out -> ks ;\n }\n if ( gctx -> iv == EVP_CIPHER_CTX_iv_noconst ( c ) ) gctx_out -> iv = EVP_CIPHER_CTX_iv_noconst ( out ) ;\n else {\n gctx_out -> iv = OPENSSL_malloc ( gctx -> ivlen ) ;\n if ( gctx_out -> iv == NULL ) return 0 ;\n memcpy ( gctx_out -> iv , gctx -> iv , gctx -> ivlen ) ;\n }\n return 1 ;\n }\n default : return - 1 ;\n }\n }\n static int aes_gcm_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n if ( ! iv && ! key ) return 1 ;\n if ( key ) {\n do {\n # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) HWAES_encrypt ) ;\n # ifdef HWAES_ctr32_encrypt_blocks gctx -> ctr = ( ctr128_f ) HWAES_ctr32_encrypt_blocks ;\n # else gctx -> ctr = NULL ;\n # endif break ;\n }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE ) {\n AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) AES_encrypt ) ;\n gctx -> ctr = ( ctr128_f ) bsaes_ctr32_encrypt_blocks ;\n break ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) vpaes_encrypt ) ;\n gctx -> ctr = NULL ;\n break ;\n }\n else # endif ( void ) 0 ;\n AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & gctx -> ks . ks ) ;\n CRYPTO_gcm128_init ( & gctx -> gcm , & gctx -> ks , ( block128_f ) AES_encrypt ) ;\n # ifdef AES_CTR_ASM gctx -> ctr = ( ctr128_f ) AES_ctr32_encrypt ;\n # else gctx -> ctr = NULL ;\n # endif }\n while ( 0 ) ;\n if ( iv == NULL && gctx -> iv_set ) iv = gctx -> iv ;\n if ( iv ) {\n CRYPTO_gcm128_setiv ( & gctx -> gcm , iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n }\n gctx -> key_set = 1 ;\n }\n else {\n if ( gctx -> key_set ) CRYPTO_gcm128_setiv ( & gctx -> gcm , iv , gctx -> ivlen ) ;\n else memcpy ( gctx -> iv , iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n gctx -> iv_gen = 0 ;\n }\n return 1 ;\n }\n static int aes_gcm_tls_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n int rv = - 1 ;\n if ( out != in || len < ( EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ) ) return - 1 ;\n if ( EVP_CIPHER_CTX_ctrl ( ctx , EVP_CIPHER_CTX_encrypting ( ctx ) ? EVP_CTRL_GCM_IV_GEN : EVP_CTRL_GCM_SET_IV_INV , EVP_GCM_TLS_EXPLICIT_IV_LEN , out ) <= 0 ) goto err ;\n if ( CRYPTO_gcm128_aad ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , gctx -> tls_aad_len ) ) goto err ;\n in += EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n out += EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n len -= EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ;\n if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 32 && AES_GCM_ASM ( gctx ) ) {\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_encrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) goto err ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 32 && AES_GCM_ASM2 ( gctx ) ) {\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) goto err ;\n }\n out += len ;\n CRYPTO_gcm128_tag ( & gctx -> gcm , out , EVP_GCM_TLS_TAG_LEN ) ;\n rv = len + EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN ;\n }\n else {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 16 && AES_GCM_ASM ( gctx ) ) {\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_decrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) goto err ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 16 && AES_GCM_ASM2 ( gctx ) ) {\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , NULL , NULL , 0 ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in , out , len , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n }\n # endif if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) goto err ;\n }\n CRYPTO_gcm128_tag ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , EVP_GCM_TLS_TAG_LEN ) ;\n if ( CRYPTO_memcmp ( EVP_CIPHER_CTX_buf_noconst ( ctx ) , in + len , EVP_GCM_TLS_TAG_LEN ) ) {\n OPENSSL_cleanse ( out , len ) ;\n goto err ;\n }\n rv = len ;\n }\n err : gctx -> iv_set = 0 ;\n gctx -> tls_aad_len = - 1 ;\n return rv ;\n }\n static int aes_gcm_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , ctx ) ;\n if ( ! gctx -> key_set ) return - 1 ;\n if ( gctx -> tls_aad_len >= 0 ) return aes_gcm_tls_cipher ( ctx , out , in , len ) ;\n if ( ! gctx -> iv_set ) return - 1 ;\n if ( in ) {\n if ( out == NULL ) {\n if ( CRYPTO_gcm128_aad ( & gctx -> gcm , in , len ) ) return - 1 ;\n }\n else if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 32 && AES_GCM_ASM ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_encrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) return - 1 ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 32 && AES_GCM_ASM2 ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_encrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_encrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) return - 1 ;\n }\n }\n else {\n if ( gctx -> ctr ) {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM ) if ( len >= 16 && AES_GCM_ASM ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_decrypt_ctr32 ( & gctx -> gcm , in + bulk , out + bulk , len - bulk , gctx -> ctr ) ) return - 1 ;\n }\n else {\n size_t bulk = 0 ;\n # if defined ( AES_GCM_ASM2 ) if ( len >= 16 && AES_GCM_ASM2 ( gctx ) ) {\n size_t res = ( 16 - gctx -> gcm . mres ) % 16 ;\n if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in , out , res ) ) return - 1 ;\n bulk = AES_gcm_decrypt ( in + res , out + res , len - res , gctx -> gcm . key , gctx -> gcm . Yi . c , gctx -> gcm . Xi . u ) ;\n gctx -> gcm . len . u [ 1 ] += bulk ;\n bulk += res ;\n }\n # endif if ( CRYPTO_gcm128_decrypt ( & gctx -> gcm , in + bulk , out + bulk , len - bulk ) ) return - 1 ;\n }\n }\n return len ;\n }\n else {\n if ( ! EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( gctx -> taglen < 0 ) return - 1 ;\n if ( CRYPTO_gcm128_finish ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , gctx -> taglen ) != 0 ) return - 1 ;\n gctx -> iv_set = 0 ;\n return 0 ;\n }\n CRYPTO_gcm128_tag ( & gctx -> gcm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , 16 ) ;\n gctx -> taglen = 16 ;\n gctx -> iv_set = 0 ;\n return 0 ;\n }\n }\n # define CUSTOM_FLAGS ( EVP_CIPH_FLAG_DEFAULT_ASN1 \\ | EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \\ | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \\ | EVP_CIPH_CUSTOM_COPY ) BLOCK_CIPHER_custom ( NID_aes , 128 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS ) BLOCK_CIPHER_custom ( NID_aes , 192 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS ) BLOCK_CIPHER_custom ( NID_aes , 256 , 1 , 12 , gcm , GCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS ) static int aes_xts_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n EVP_AES_XTS_CTX * xctx = EVP_C_DATA ( EVP_AES_XTS_CTX , c ) ;\n if ( type == EVP_CTRL_COPY ) {\n EVP_CIPHER_CTX * out = ptr ;\n EVP_AES_XTS_CTX * xctx_out = EVP_C_DATA ( EVP_AES_XTS_CTX , out ) ;\n if ( xctx -> xts . key1 ) {\n if ( xctx -> xts . key1 != & xctx -> ks1 ) return 0 ;\n xctx_out -> xts . key1 = & xctx_out -> ks1 ;\n }\n if ( xctx -> xts . key2 ) {\n if ( xctx -> xts . key2 != & xctx -> ks2 ) return 0 ;\n xctx_out -> xts . key2 = & xctx_out -> ks2 ;\n }\n return 1 ;\n }\n else if ( type != EVP_CTRL_INIT ) return - 1 ;\n xctx -> xts . key1 = NULL ;\n xctx -> xts . key2 = NULL ;\n return 1 ;\n }\n static int aes_xts_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n EVP_AES_XTS_CTX * xctx = EVP_C_DATA ( EVP_AES_XTS_CTX , ctx ) ;\n if ( ! iv && ! key ) return 1 ;\n if ( key ) do {\n # ifdef AES_XTS_ASM xctx -> stream = enc ? AES_xts_encrypt : AES_xts_decrypt ;\n # else xctx -> stream = NULL ;\n # endif # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n if ( enc ) {\n HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) HWAES_encrypt ;\n # ifdef HWAES_xts_encrypt xctx -> stream = HWAES_xts_encrypt ;\n # endif }\n else {\n HWAES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) HWAES_decrypt ;\n # ifdef HWAES_xts_decrypt xctx -> stream = HWAES_xts_decrypt ;\n # endif }\n HWAES_set_encrypt_key ( key + EVP_CIPHER_CTX_key_length ( ctx ) / 2 , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks2 . ks ) ;\n xctx -> xts . block2 = ( block128_f ) HWAES_encrypt ;\n xctx -> xts . key1 = & xctx -> ks1 ;\n break ;\n }\n else # endif # ifdef BSAES_CAPABLE if ( BSAES_CAPABLE ) xctx -> stream = enc ? bsaes_xts_encrypt : bsaes_xts_decrypt ;\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n if ( enc ) {\n vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) vpaes_encrypt ;\n }\n else {\n vpaes_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) vpaes_decrypt ;\n }\n vpaes_set_encrypt_key ( key + EVP_CIPHER_CTX_key_length ( ctx ) / 2 , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks2 . ks ) ;\n xctx -> xts . block2 = ( block128_f ) vpaes_encrypt ;\n xctx -> xts . key1 = & xctx -> ks1 ;\n break ;\n }\n else # endif ( void ) 0 ;\n if ( enc ) {\n AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) AES_encrypt ;\n }\n else {\n AES_set_decrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks1 . ks ) ;\n xctx -> xts . block1 = ( block128_f ) AES_decrypt ;\n }\n AES_set_encrypt_key ( key + EVP_CIPHER_CTX_key_length ( ctx ) / 2 , EVP_CIPHER_CTX_key_length ( ctx ) * 4 , & xctx -> ks2 . ks ) ;\n xctx -> xts . block2 = ( block128_f ) AES_encrypt ;\n xctx -> xts . key1 = & xctx -> ks1 ;\n }\n while ( 0 ) ;\n if ( iv ) {\n xctx -> xts . key2 = & xctx -> ks2 ;\n memcpy ( EVP_CIPHER_CTX_iv_noconst ( ctx ) , iv , 16 ) ;\n }\n return 1 ;\n }\n static int aes_xts_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_XTS_CTX * xctx = EVP_C_DATA ( EVP_AES_XTS_CTX , ctx ) ;\n if ( ! xctx -> xts . key1 || ! xctx -> xts . key2 ) return 0 ;\n if ( ! out || ! in || len < AES_BLOCK_SIZE ) return 0 ;\n if ( xctx -> stream ) ( * xctx -> stream ) ( in , out , len , xctx -> xts . key1 , xctx -> xts . key2 , EVP_CIPHER_CTX_iv_noconst ( ctx ) ) ;\n else if ( CRYPTO_xts128_encrypt ( & xctx -> xts , EVP_CIPHER_CTX_iv_noconst ( ctx ) , in , out , len , EVP_CIPHER_CTX_encrypting ( ctx ) ) ) return 0 ;\n return 1 ;\n }\n # define aes_xts_cleanup NULL # define XTS_FLAGS ( EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \\ | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \\ | EVP_CIPH_CUSTOM_COPY ) BLOCK_CIPHER_custom ( NID_aes , 128 , 1 , 16 , xts , XTS , XTS_FLAGS ) BLOCK_CIPHER_custom ( NID_aes , 256 , 1 , 16 , xts , XTS , XTS_FLAGS ) static int aes_ccm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , c ) ;\n switch ( type ) {\n case EVP_CTRL_INIT : cctx -> key_set = 0 ;\n cctx -> iv_set = 0 ;\n cctx -> L = 8 ;\n cctx -> M = 12 ;\n cctx -> tag_set = 0 ;\n cctx -> len_set = 0 ;\n cctx -> tls_aad_len = - 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n cctx -> tls_aad_len = arg ;\n {\n uint16_t len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ;\n if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) len -= cctx -> M ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ;\n }\n return cctx -> M ;\n case EVP_CTRL_CCM_SET_IV_FIXED : if ( arg != EVP_CCM_TLS_FIXED_IV_LEN ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_iv_noconst ( c ) , ptr , arg ) ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_IVLEN : arg = 15 - arg ;\n case EVP_CTRL_CCM_SET_L : if ( arg < 2 || arg > 8 ) return 0 ;\n cctx -> L = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_TAG : if ( ( arg & 1 ) || arg < 4 || arg > 16 ) return 0 ;\n if ( EVP_CIPHER_CTX_encrypting ( c ) && ptr ) return 0 ;\n if ( ptr ) {\n cctx -> tag_set = 1 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n }\n cctx -> M = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_GET_TAG : if ( ! EVP_CIPHER_CTX_encrypting ( c ) || ! cctx -> tag_set ) return 0 ;\n if ( ! CRYPTO_ccm128_tag ( & cctx -> ccm , ptr , ( size_t ) arg ) ) return 0 ;\n cctx -> tag_set = 0 ;\n cctx -> iv_set = 0 ;\n cctx -> len_set = 0 ;\n return 1 ;\n case EVP_CTRL_COPY : {\n EVP_CIPHER_CTX * out = ptr ;\n EVP_AES_CCM_CTX * cctx_out = EVP_C_DATA ( EVP_AES_CCM_CTX , out ) ;\n if ( cctx -> ccm . key ) {\n if ( cctx -> ccm . key != & cctx -> ks ) return 0 ;\n cctx_out -> ccm . key = & cctx_out -> ks ;\n }\n return 1 ;\n }\n default : return - 1 ;\n }\n }\n static int aes_ccm_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , ctx ) ;\n if ( ! iv && ! key ) return 1 ;\n if ( key ) do {\n # ifdef HWAES_CAPABLE if ( HWAES_CAPABLE ) {\n HWAES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & cctx -> ks . ks ) ;\n CRYPTO_ccm128_init ( & cctx -> ccm , cctx -> M , cctx -> L , & cctx -> ks , ( block128_f ) HWAES_encrypt ) ;\n cctx -> str = NULL ;\n cctx -> key_set = 1 ;\n break ;\n }\n else # endif # ifdef VPAES_CAPABLE if ( VPAES_CAPABLE ) {\n vpaes_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & cctx -> ks . ks ) ;\n CRYPTO_ccm128_init ( & cctx -> ccm , cctx -> M , cctx -> L , & cctx -> ks , ( block128_f ) vpaes_encrypt ) ;\n cctx -> str = NULL ;\n cctx -> key_set = 1 ;\n break ;\n }\n # endif AES_set_encrypt_key ( key , EVP_CIPHER_CTX_key_length ( ctx ) * 8 , & cctx -> ks . ks ) ;\n CRYPTO_ccm128_init ( & cctx -> ccm , cctx -> M , cctx -> L , & cctx -> ks , ( block128_f ) AES_encrypt ) ;\n cctx -> str = NULL ;\n cctx -> key_set = 1 ;\n }\n while ( 0 ) ;\n if ( iv ) {\n memcpy ( EVP_CIPHER_CTX_iv_noconst ( ctx ) , iv , 15 - cctx -> L ) ;\n cctx -> iv_set = 1 ;\n }\n return 1 ;\n }\n static int aes_ccm_tls_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , ctx ) ;\n CCM128_CONTEXT * ccm = & cctx -> ccm ;\n if ( out != in || len < ( EVP_CCM_TLS_EXPLICIT_IV_LEN + ( size_t ) cctx -> M ) ) return - 1 ;\n if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) memcpy ( out , EVP_CIPHER_CTX_buf_noconst ( ctx ) , EVP_CCM_TLS_EXPLICIT_IV_LEN ) ;\n memcpy ( EVP_CIPHER_CTX_iv_noconst ( ctx ) + EVP_CCM_TLS_FIXED_IV_LEN , in , EVP_CCM_TLS_EXPLICIT_IV_LEN ) ;\n len -= EVP_CCM_TLS_EXPLICIT_IV_LEN + cctx -> M ;\n if ( CRYPTO_ccm128_setiv ( ccm , EVP_CIPHER_CTX_iv_noconst ( ctx ) , 15 - cctx -> L , len ) ) return - 1 ;\n CRYPTO_ccm128_aad ( ccm , EVP_CIPHER_CTX_buf_noconst ( ctx ) , cctx -> tls_aad_len ) ;\n in += EVP_CCM_TLS_EXPLICIT_IV_LEN ;\n out += EVP_CCM_TLS_EXPLICIT_IV_LEN ;\n if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( cctx -> str ? CRYPTO_ccm128_encrypt_ccm64 ( ccm , in , out , len , cctx -> str ) : CRYPTO_ccm128_encrypt ( ccm , in , out , len ) ) return - 1 ;\n if ( ! CRYPTO_ccm128_tag ( ccm , out + len , cctx -> M ) ) return - 1 ;\n return len + EVP_CCM_TLS_EXPLICIT_IV_LEN + cctx -> M ;\n }\n else {\n if ( cctx -> str ? ! CRYPTO_ccm128_decrypt_ccm64 ( ccm , in , out , len , cctx -> str ) : ! CRYPTO_ccm128_decrypt ( ccm , in , out , len ) ) {\n unsigned char tag [ 16 ] ;\n if ( CRYPTO_ccm128_tag ( ccm , tag , cctx -> M ) ) {\n if ( ! CRYPTO_memcmp ( tag , in + len , cctx -> M ) ) return len ;\n }\n }\n OPENSSL_cleanse ( out , len ) ;\n return - 1 ;\n }\n }\n static int aes_ccm_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , ctx ) ;\n CCM128_CONTEXT * ccm = & cctx -> ccm ;\n if ( ! cctx -> key_set ) return - 1 ;\n if ( cctx -> tls_aad_len >= 0 ) return aes_ccm_tls_cipher ( ctx , out , in , len ) ;\n if ( ! cctx -> iv_set ) return - 1 ;\n if ( ! EVP_CIPHER_CTX_encrypting ( ctx ) && ! cctx -> tag_set ) return - 1 ;\n if ( ! out ) {\n if ( ! in ) {\n if ( CRYPTO_ccm128_setiv ( ccm , EVP_CIPHER_CTX_iv_noconst ( ctx ) , 15 - cctx -> L , len ) ) return - 1 ;\n cctx -> len_set = 1 ;\n return len ;\n }\n if ( ! cctx -> len_set && len ) return - 1 ;\n CRYPTO_ccm128_aad ( ccm , in , len ) ;\n return len ;\n }\n if ( ! in ) return 0 ;\n if ( ! cctx -> len_set ) {\n if ( CRYPTO_ccm128_setiv ( ccm , EVP_CIPHER_CTX_iv_noconst ( ctx ) , 15 - cctx -> L , len ) ) return - 1 ;\n cctx -> len_set = 1 ;\n }\n if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) {\n if ( cctx -> str ? CRYPTO_ccm128_encrypt_ccm64 ( ccm , in , out , len , cctx -> str ) : CRYPTO_ccm128_encrypt ( ccm , in , out , len ) ) return - 1 ;\n cctx -> tag_set = 1 ;\n return len ;\n }\n else {\n int rv = - 1 ;\n if ( cctx -> str ? ! CRYPTO_ccm128_decrypt_ccm64 ( ccm , in , out , len , cctx -> str ) : ! CRYPTO_ccm128_decrypt ( ccm , in , out , len ) ) {\n unsigned char tag [ 16 ] ;\n if ( CRYPTO_ccm128_tag ( ccm , tag , cctx -> M ) ) {\n if ( ! CRYPTO_memcmp ( tag , EVP_CIPHER_CTX_buf_noconst ( ctx ) , cctx -> M ) ) rv = len ;\n }\n }\n if ( rv == - 1 ) OPENSSL_cleanse ( out , len ) ;\n cctx -> iv_set = 0 ;\n cctx -> tag_set = 0 ;\n cctx -> len_set = 0 ;\n return rv ;\n }\n }\n # define aes_ccm_cleanup NULL BLOCK_CIPHER_custom ( NID_aes , 128 , 1 , 12 , ccm , CCM , EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS )", "hash": 8801969307247112896, "project": "debian", "size": 650, "target": 1, "idx": 21400}
{"code": "static PGconn * get_db_conn ( ClusterInfo * cluster , const char * db_name ) {\n char conn_opts [ 2 * NAMEDATALEN + MAXPGPATH + 100 ] ;\n if ( cluster -> sockdir ) snprintf ( conn_opts , sizeof ( conn_opts ) , \"dbname = '%s' user = '%s' host = '%s' port = %d\" , db_name , os_info . user , cluster -> sockdir , cluster -> port ) ;\n else snprintf ( conn_opts , sizeof ( conn_opts ) , \"dbname = '%s' user = '%s' port = %d\" , db_name , os_info . user , cluster -> port ) ;\n return PQconnectdb ( conn_opts ) ;\n }", "hash": -4979531020783644238, "project": "debian", "size": 6, "target": 1, "idx": 21411}
{"code": "void appendConnStrVal ( PQExpBuffer buf , const char * str ) {\n const char * s ;\n bool needquotes ;\n needquotes = false ;\n for ( s = str ;\n * s ;\n s ++ ) {\n if ( ! ( ( * s >= 'a' && * s <= 'z' ) || ( * s >= 'A' && * s <= 'Z' ) || ( * s >= '0' && * s <= '9' ) || * s == '_' || * s == '.' ) ) {\n needquotes = true ;\n break ;\n }\n }\n if ( needquotes ) {\n appendPQExpBufferChar ( buf , '\\'' ) ;\n while ( * str ) {\n if ( * str == '\\'' || * str == '\\\\' ) appendPQExpBufferChar ( buf , '\\\\' ) ;\n appendPQExpBufferChar ( buf , * str ) ;\n str ++ ;\n }\n appendPQExpBufferChar ( buf , '\\'' ) ;\n }\n else appendPQExpBufferStr ( buf , str ) ;\n }", "hash": -650231346353974279, "project": "debian", "size": 23, "target": 1, "idx": 21419}
{"code": "static int dissect_ipmi_trace ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n guint block_type , chn_num , data_type , tmp ;\n tvbuff_t * next_tvb ;\n if ( tvb_captured_length ( tvb ) < 11 ) {\n call_data_dissector ( tvb , pinfo , tree ) ;\n return tvb_captured_length ( tvb ) ;\n }\n tmp = tvb_get_guint8 ( tvb , 0 ) ;\n block_type = ( tmp >> 4 ) & 3 ;\n chn_num = tmp & 0xF ;\n data_type = tvb_get_guint8 ( tvb , 7 ) ;\n col_add_fstr ( pinfo -> cinfo , COL_DEF_SRC , \"Channel %d\" , chn_num ) ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , val_to_str ( data_type , str_protocol_types , \"Reserved (0x%02x)\" ) ) ;\n col_clear ( pinfo -> cinfo , COL_INFO ) ;\n if ( block_type == HPM2_TRACE_PACKET_DATA ) {\n col_set_str ( pinfo -> cinfo , COL_INFO , \"Trace Packet Data\" ) ;\n }\n else if ( block_type == HPM2_CHN_STATE_NOTIFY ) {\n col_set_str ( pinfo -> cinfo , COL_INFO , \"Channel State Change Notification\" ) ;\n }\n else if ( block_type == HPM2_EMBED_ASCII_MSG ) {\n char str [ 257 ] ;\n guint str_len = tvb_get_guint8 ( tvb , 10 ) ;\n if ( str_len ) {\n tvb_memcpy ( tvb , str , 11 , str_len ) ;\n str [ str_len ] = 0 ;\n col_add_str ( pinfo -> cinfo , COL_INFO , str ) ;\n }\n }\n else {\n col_set_str ( pinfo -> cinfo , COL_INFO , \"Reserved\" ) ;\n }\n if ( tree ) {\n proto_item * ti ;\n proto_tree * trace_tree ;\n proto_tree * stamp_tree ;\n nstime_t timestamp ;\n ti = proto_tree_add_item ( tree , proto_ipmi_trace , tvb , 0 , - 1 , ENC_NA ) ;\n trace_tree = proto_item_add_subtree ( ti , ett_ipmi_trace ) ;\n proto_tree_add_bitmask ( trace_tree , tvb , 0 , hf_trace_block_type , ett_trace_block_type , bits_trace_block_type , ENC_LITTLE_ENDIAN ) ;\n timestamp . secs = tvb_get_letohl ( tvb , 1 ) ;\n timestamp . nsecs = ( int ) tvb_get_letohs ( tvb , 5 ) * 1000000 ;\n ti = proto_tree_add_time ( trace_tree , hf_trace_timestamp , tvb , 1 , 6 , & timestamp ) ;\n stamp_tree = proto_item_add_subtree ( ti , ett_trace_timestamp ) ;\n proto_tree_add_item ( stamp_tree , hf_trace_timestamp_sec , tvb , 1 , 4 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( stamp_tree , hf_trace_timestamp_msec , tvb , 5 , 2 , ENC_LITTLE_ENDIAN ) ;\n proto_tree_add_item ( trace_tree , hf_trace_data_type , tvb , 7 , 1 , ENC_LITTLE_ENDIAN ) ;\n if ( data_type == IPMI_PROTO_IPMB_1_0 ) {\n proto_tree_add_bitmask ( trace_tree , tvb , 8 , hf_trace_protocol_data , ett_trace_protocol_data , bits_ipmb_protocol_data , ENC_LITTLE_ENDIAN ) ;\n }\n else if ( data_type == IPMI_PROTO_KCS || data_type == IPMI_PROTO_SMIC || data_type == IPMI_PROTO_BT_10 || data_type == IPMI_PROTO_BT_15 ) {\n proto_tree_add_bitmask ( trace_tree , tvb , 8 , hf_trace_protocol_data , ett_trace_protocol_data , bits_host_protocol_data , ENC_LITTLE_ENDIAN ) ;\n }\n else {\n proto_tree_add_item ( trace_tree , hf_trace_protocol_data , tvb , 8 , 2 , ENC_LITTLE_ENDIAN ) ;\n }\n proto_tree_add_item ( trace_tree , hf_trace_data_len , tvb , 10 , 1 , ENC_LITTLE_ENDIAN ) ;\n }\n next_tvb = tvb_new_subset_remaining ( tvb , 11 ) ;\n if ( block_type == HPM2_TRACE_PACKET_DATA ) {\n ipmi_dissect_arg_t arg ;\n arg . context = IPMI_E_NONE ;\n arg . channel = chn_num ;\n arg . flags = tvb_get_guint8 ( tvb , 8 ) ;\n if ( ! dissector_try_uint_new ( proto_dissector_table , data_type , next_tvb , pinfo , tree , TRUE , & arg ) ) {\n call_data_dissector ( next_tvb , pinfo , tree ) ;\n }\n }\n else if ( block_type == HPM2_CHN_STATE_NOTIFY && data_type == IPMI_PROTO_IPMB_1_0 ) {\n dissect_ipmb_state_notify ( next_tvb , tree ) ;\n }\n else {\n call_data_dissector ( next_tvb , pinfo , tree ) ;\n }\n return tvb_captured_length ( tvb ) ;\n }", "hash": 7285311557513831583, "project": "debian", "size": 76, "target": 1, "idx": 21426}
{"code": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower )", "hash": 2447070537606626244, "project": "debian", "size": 5, "target": 1, "idx": 21439}
{"code": "static PyObject * get_value ( PyObject * self , const char * buffer , int * position , int type , int max , PyObject * as_class , unsigned char tz_aware , unsigned char uuid_subtype ) {\n struct module_state * state = GETSTATE ( self ) ;\n PyObject * value ;\n PyObject * error ;\n switch ( type ) {\n case 1 : {\n double d ;\n if ( max < 8 ) {\n goto invalid ;\n }\n memcpy ( & d , buffer + * position , 8 ) ;\n value = PyFloat_FromDouble ( d ) ;\n if ( ! value ) {\n return NULL ;\n }\n * position += 8 ;\n break ;\n }\n case 2 : case 14 : {\n int value_length = ( ( int * ) ( buffer + * position ) ) [ 0 ] - 1 ;\n if ( max < value_length ) {\n goto invalid ;\n }\n * position += 4 ;\n value = PyUnicode_DecodeUTF8 ( buffer + * position , value_length , \"strict\" ) ;\n if ( ! value ) {\n return NULL ;\n }\n * position += value_length + 1 ;\n break ;\n }\n case 3 : {\n int size ;\n memcpy ( & size , buffer + * position , 4 ) ;\n if ( max < size ) {\n goto invalid ;\n }\n value = elements_to_dict ( self , buffer + * position + 4 , size - 5 , as_class , tz_aware , uuid_subtype ) ;\n if ( ! value ) {\n return NULL ;\n }\n if ( strcmp ( buffer + * position + 5 , \"$ref\" ) == 0 ) {\n PyObject * dbref ;\n PyObject * collection = PyDict_GetItemString ( value , \"$ref\" ) ;\n PyObject * id = PyDict_GetItemString ( value , \"$id\" ) ;\n PyObject * database = PyDict_GetItemString ( value , \"$db\" ) ;\n Py_INCREF ( collection ) ;\n PyDict_DelItemString ( value , \"$ref\" ) ;\n Py_INCREF ( id ) ;\n PyDict_DelItemString ( value , \"$id\" ) ;\n if ( database == NULL ) {\n database = Py_None ;\n Py_INCREF ( database ) ;\n }\n else {\n Py_INCREF ( database ) ;\n PyDict_DelItemString ( value , \"$db\" ) ;\n }\n dbref = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , database , value , NULL ) ;\n Py_DECREF ( value ) ;\n value = dbref ;\n Py_DECREF ( id ) ;\n Py_DECREF ( collection ) ;\n Py_DECREF ( database ) ;\n if ( ! value ) {\n return NULL ;\n }\n }\n * position += size ;\n break ;\n }\n case 4 : {\n int size , end ;\n memcpy ( & size , buffer + * position , 4 ) ;\n if ( max < size ) {\n goto invalid ;\n }\n end = * position + size - 1 ;\n * position += 4 ;\n value = PyList_New ( 0 ) ;\n if ( ! value ) {\n return NULL ;\n }\n while ( * position < end ) {\n PyObject * to_append ;\n int type = ( int ) buffer [ ( * position ) ++ ] ;\n int key_size = strlen ( buffer + * position ) ;\n * position += key_size + 1 ;\n to_append = get_value ( self , buffer , position , type , max - key_size , as_class , tz_aware , uuid_subtype ) ;\n if ( ! to_append ) {\n Py_DECREF ( value ) ;\n return NULL ;\n }\n PyList_Append ( value , to_append ) ;\n Py_DECREF ( to_append ) ;\n }\n ( * position ) ++ ;\n break ;\n }\n case 5 : {\n PyObject * data ;\n PyObject * st ;\n int length , subtype ;\n memcpy ( & length , buffer + * position , 4 ) ;\n if ( max < length ) {\n goto invalid ;\n }\n subtype = ( unsigned char ) buffer [ * position + 4 ] ;\n # if PY_MAJOR_VERSION >= 3 if ( subtype == 0 ) {\n value = PyBytes_FromStringAndSize ( buffer + * position + 5 , length ) ;\n * position += length + 5 ;\n break ;\n }\n if ( subtype == 2 ) {\n data = PyBytes_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ;\n }\n else {\n data = PyBytes_FromStringAndSize ( buffer + * position + 5 , length ) ;\n }\n # else if ( subtype == 2 ) {\n data = PyString_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ;\n }\n else {\n data = PyString_FromStringAndSize ( buffer + * position + 5 , length ) ;\n }\n # endif if ( ! data ) {\n return NULL ;\n }\n if ( ( subtype == 3 || subtype == 4 ) && state -> UUID ) {\n PyObject * kwargs ;\n PyObject * args = PyTuple_New ( 0 ) ;\n if ( ! args ) {\n Py_DECREF ( data ) ;\n return NULL ;\n }\n kwargs = PyDict_New ( ) ;\n if ( ! kwargs ) {\n Py_DECREF ( data ) ;\n Py_DECREF ( args ) ;\n return NULL ;\n }\n assert ( length == 16 ) ;\n if ( uuid_subtype == CSHARP_LEGACY ) {\n PyDict_SetItemString ( kwargs , \"bytes_le\" , data ) ;\n }\n else {\n if ( uuid_subtype == JAVA_LEGACY ) {\n char big_endian [ 16 ] ;\n _fix_java ( buffer + * position + 5 , big_endian ) ;\n Py_DECREF ( data ) ;\n # if PY_MAJOR_VERSION >= 3 data = PyBytes_FromStringAndSize ( big_endian , length ) ;\n # else data = PyString_FromStringAndSize ( big_endian , length ) ;\n # endif }\n PyDict_SetItemString ( kwargs , \"bytes\" , data ) ;\n }\n value = PyObject_Call ( state -> UUID , args , kwargs ) ;\n Py_DECREF ( args ) ;\n Py_DECREF ( kwargs ) ;\n Py_DECREF ( data ) ;\n if ( ! value ) {\n return NULL ;\n }\n * position += length + 5 ;\n break ;\n }\n # if PY_MAJOR_VERSION >= 3 st = PyLong_FromLong ( subtype ) ;\n # else st = PyInt_FromLong ( subtype ) ;\n # endif if ( ! st ) {\n Py_DECREF ( data ) ;\n return NULL ;\n }\n value = PyObject_CallFunctionObjArgs ( state -> Binary , data , st , NULL ) ;\n Py_DECREF ( st ) ;\n Py_DECREF ( data ) ;\n if ( ! value ) {\n return NULL ;\n }\n * position += length + 5 ;\n break ;\n }\n case 6 : case 10 : {\n value = Py_None ;\n Py_INCREF ( value ) ;\n break ;\n }\n case 7 : {\n if ( max < 12 ) {\n goto invalid ;\n }\n # if PY_MAJOR_VERSION >= 3 value = PyObject_CallFunction ( state -> ObjectId , \"y#\" , buffer + * position , 12 ) ;\n # else value = PyObject_CallFunction ( state -> ObjectId , \"s#\" , buffer + * position , 12 ) ;\n # endif if ( ! value ) {\n return NULL ;\n }\n * position += 12 ;\n break ;\n }\n case 8 : {\n value = buffer [ ( * position ) ++ ] ? Py_True : Py_False ;\n Py_INCREF ( value ) ;\n break ;\n }\n case 9 : {\n PyObject * naive ;\n PyObject * replace ;\n PyObject * args ;\n PyObject * kwargs ;\n if ( max < 8 ) {\n goto invalid ;\n }\n naive = datetime_from_millis ( * ( long long * ) ( buffer + * position ) ) ;\n * position += 8 ;\n if ( ! tz_aware ) {\n value = naive ;\n break ;\n }\n if ( ! naive ) {\n return NULL ;\n }\n replace = PyObject_GetAttrString ( naive , \"replace\" ) ;\n Py_DECREF ( naive ) ;\n if ( ! replace ) {\n return NULL ;\n }\n args = PyTuple_New ( 0 ) ;\n if ( ! args ) {\n Py_DECREF ( replace ) ;\n return NULL ;\n }\n kwargs = PyDict_New ( ) ;\n if ( ! kwargs ) {\n Py_DECREF ( replace ) ;\n Py_DECREF ( args ) ;\n return NULL ;\n }\n if ( PyDict_SetItemString ( kwargs , \"tzinfo\" , state -> UTC ) == - 1 ) {\n Py_DECREF ( replace ) ;\n Py_DECREF ( args ) ;\n Py_DECREF ( kwargs ) ;\n return NULL ;\n }\n value = PyObject_Call ( replace , args , kwargs ) ;\n Py_DECREF ( replace ) ;\n Py_DECREF ( args ) ;\n Py_DECREF ( kwargs ) ;\n break ;\n }\n case 11 : {\n PyObject * pattern ;\n int flags_length , flags , i ;\n int pattern_length = strlen ( buffer + * position ) ;\n if ( max < pattern_length ) {\n goto invalid ;\n }\n pattern = PyUnicode_DecodeUTF8 ( buffer + * position , pattern_length , \"strict\" ) ;\n if ( ! pattern ) {\n return NULL ;\n }\n * position += pattern_length + 1 ;\n flags_length = strlen ( buffer + * position ) ;\n if ( max < pattern_length + flags_length ) {\n Py_DECREF ( pattern ) ;\n goto invalid ;\n }\n flags = 0 ;\n for ( i = 0 ;\n i < flags_length ;\n i ++ ) {\n if ( buffer [ * position + i ] == 'i' ) {\n flags |= 2 ;\n }\n else if ( buffer [ * position + i ] == 'l' ) {\n flags |= 4 ;\n }\n else if ( buffer [ * position + i ] == 'm' ) {\n flags |= 8 ;\n }\n else if ( buffer [ * position + i ] == 's' ) {\n flags |= 16 ;\n }\n else if ( buffer [ * position + i ] == 'u' ) {\n flags |= 32 ;\n }\n else if ( buffer [ * position + i ] == 'x' ) {\n flags |= 64 ;\n }\n }\n * position += flags_length + 1 ;\n value = PyObject_CallFunction ( state -> RECompile , \"Oi\" , pattern , flags ) ;\n Py_DECREF ( pattern ) ;\n break ;\n }\n case 12 : {\n int collection_length ;\n PyObject * collection ;\n PyObject * id ;\n * position += 4 ;\n collection_length = strlen ( buffer + * position ) ;\n if ( max < collection_length ) {\n goto invalid ;\n }\n collection = PyUnicode_DecodeUTF8 ( buffer + * position , collection_length , \"strict\" ) ;\n if ( ! collection ) {\n return NULL ;\n }\n * position += collection_length + 1 ;\n if ( max < collection_length + 12 ) {\n Py_DECREF ( collection ) ;\n goto invalid ;\n }\n id = PyObject_CallFunction ( state -> ObjectId , \"s#\" , buffer + * position , 12 ) ;\n if ( ! id ) {\n Py_DECREF ( collection ) ;\n return NULL ;\n }\n * position += 12 ;\n value = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , NULL ) ;\n Py_DECREF ( collection ) ;\n Py_DECREF ( id ) ;\n break ;\n }\n case 13 : {\n PyObject * code ;\n int value_length = ( ( int * ) ( buffer + * position ) ) [ 0 ] - 1 ;\n if ( max < value_length ) {\n goto invalid ;\n }\n * position += 4 ;\n code = PyUnicode_DecodeUTF8 ( buffer + * position , value_length , \"strict\" ) ;\n if ( ! code ) {\n return NULL ;\n }\n * position += value_length + 1 ;\n value = PyObject_CallFunctionObjArgs ( state -> Code , code , NULL , NULL ) ;\n Py_DECREF ( code ) ;\n break ;\n }\n case 15 : {\n int code_length , scope_size ;\n PyObject * code ;\n PyObject * scope ;\n * position += 8 ;\n code_length = strlen ( buffer + * position ) ;\n if ( max < 8 + code_length ) {\n goto invalid ;\n }\n code = PyUnicode_DecodeUTF8 ( buffer + * position , code_length , \"strict\" ) ;\n if ( ! code ) {\n return NULL ;\n }\n * position += code_length + 1 ;\n memcpy ( & scope_size , buffer + * position , 4 ) ;\n scope = elements_to_dict ( self , buffer + * position + 4 , scope_size - 5 , ( PyObject * ) & PyDict_Type , tz_aware , uuid_subtype ) ;\n if ( ! scope ) {\n Py_DECREF ( code ) ;\n return NULL ;\n }\n * position += scope_size ;\n value = PyObject_CallFunctionObjArgs ( state -> Code , code , scope , NULL ) ;\n Py_DECREF ( code ) ;\n Py_DECREF ( scope ) ;\n break ;\n }\n case 16 : {\n int i ;\n if ( max < 4 ) {\n goto invalid ;\n }\n memcpy ( & i , buffer + * position , 4 ) ;\n # if PY_MAJOR_VERSION >= 3 value = PyLong_FromLong ( i ) ;\n # else value = PyInt_FromLong ( i ) ;\n # endif if ( ! value ) {\n return NULL ;\n }\n * position += 4 ;\n break ;\n }\n case 17 : {\n unsigned int time , inc ;\n if ( max < 8 ) {\n goto invalid ;\n }\n memcpy ( & inc , buffer + * position , 4 ) ;\n memcpy ( & time , buffer + * position + 4 , 4 ) ;\n value = PyObject_CallFunction ( state -> Timestamp , \"II\" , time , inc ) ;\n if ( ! value ) {\n return NULL ;\n }\n * position += 8 ;\n break ;\n }\n case 18 : {\n long long ll ;\n if ( max < 8 ) {\n goto invalid ;\n }\n memcpy ( & ll , buffer + * position , 8 ) ;\n value = PyLong_FromLongLong ( ll ) ;\n if ( ! value ) {\n return NULL ;\n }\n * position += 8 ;\n break ;\n }\n case - 1 : {\n value = PyObject_CallFunctionObjArgs ( state -> MinKey , NULL ) ;\n break ;\n }\n case 127 : {\n value = PyObject_CallFunctionObjArgs ( state -> MaxKey , NULL ) ;\n break ;\n }\n default : {\n PyObject * InvalidDocument = _error ( \"InvalidDocument\" ) ;\n PyErr_SetString ( InvalidDocument , \"no c decoder for this type yet\" ) ;\n Py_DECREF ( InvalidDocument ) ;\n return NULL ;\n }\n }\n return value ;\n invalid : error = _error ( \"InvalidBSON\" ) ;\n PyErr_SetNone ( error ) ;\n Py_DECREF ( error ) ;\n return NULL ;\n }", "hash": -5689214734378699681, "project": "debian", "size": 425, "target": 1, "idx": 21444}
{"code": "static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo {\n unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ;\n char comment [ 512 ] ;\n unsigned int rows , columns , subrows ;\n int x_offset , y_offset ;\n float x_bits_per_pixel , y_bits_per_pixel ;\n unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ;\n }\n ViffInfo ;\n double min_value , scale_factor , value ;\n Image * image ;\n int bit ;\n MagickBooleanType status ;\n MagickSizeType number_pixels ;\n register IndexPacket * indexes ;\n register ssize_t x ;\n register PixelPacket * q ;\n register ssize_t i ;\n register unsigned char * p ;\n size_t bytes_per_pixel , max_packets , quantum ;\n ssize_t count , y ;\n unsigned char * pixels ;\n unsigned long lsb_first ;\n ViffInfo viff_info ;\n assert ( image_info != ( const ImageInfo * ) NULL ) ;\n assert ( image_info -> signature == MagickSignature ) ;\n if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ;\n assert ( exception != ( ExceptionInfo * ) NULL ) ;\n assert ( exception -> signature == MagickSignature ) ;\n image = AcquireImage ( image_info ) ;\n status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ;\n if ( status == MagickFalse ) {\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n count = ReadBlob ( image , 1 , & viff_info . identifier ) ;\n do {\n if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , \"NotAVIFFImage\" ) ;\n ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ;\n ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ;\n ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ;\n ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ;\n ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ;\n ( void ) ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ;\n viff_info . comment [ 511 ] = '\\0' ;\n if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , \"comment\" , viff_info . comment ) ;\n if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ;\n else image -> endian = MSBEndian ;\n viff_info . rows = ReadBlobLong ( image ) ;\n viff_info . columns = ReadBlobLong ( image ) ;\n viff_info . subrows = ReadBlobLong ( image ) ;\n viff_info . x_offset = ( int ) ReadBlobLong ( image ) ;\n viff_info . y_offset = ( int ) ReadBlobLong ( image ) ;\n viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ;\n viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ;\n viff_info . location_type = ReadBlobLong ( image ) ;\n viff_info . location_dimension = ReadBlobLong ( image ) ;\n viff_info . number_of_images = ReadBlobLong ( image ) ;\n viff_info . number_data_bands = ReadBlobLong ( image ) ;\n viff_info . data_storage_type = ReadBlobLong ( image ) ;\n viff_info . data_encode_scheme = ReadBlobLong ( image ) ;\n viff_info . map_scheme = ReadBlobLong ( image ) ;\n viff_info . map_storage_type = ReadBlobLong ( image ) ;\n viff_info . map_rows = ReadBlobLong ( image ) ;\n viff_info . map_columns = ReadBlobLong ( image ) ;\n viff_info . map_subrows = ReadBlobLong ( image ) ;\n viff_info . map_enable = ReadBlobLong ( image ) ;\n viff_info . maps_per_cycle = ReadBlobLong ( image ) ;\n viff_info . color_space_model = ReadBlobLong ( image ) ;\n for ( i = 0 ;\n i < 420 ;\n i ++ ) ( void ) ReadBlobByte ( image ) ;\n if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , \"UnexpectedEndOfFile\" ) ;\n image -> columns = viff_info . rows ;\n image -> rows = viff_info . columns ;\n image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ;\n number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ;\n if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n if ( number_pixels == 0 ) ThrowReaderException ( CoderError , \"ImageColumnOrRowSizeIsNotSupported\" ) ;\n if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ;\n if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , \"DataStorageTypeIsNotSupported\" ) ;\n if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , \"DataEncodingSchemeIsNotSupported\" ) ;\n if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , \"MapStorageTypeIsNotSupported\" ) ;\n if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , \"ColorspaceModelIsNotSupported\" ) ;\n if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , \"LocationTypeIsNotSupported\" ) ;\n if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , \"NumberOfImagesIsNotSupported\" ) ;\n if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ;\n switch ( ( int ) viff_info . map_scheme ) {\n case VFF_MS_NONE : {\n if ( viff_info . number_data_bands < 3 ) {\n if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ;\n else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ;\n else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ;\n if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n }\n break ;\n }\n case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : {\n unsigned char * viff_colormap ;\n switch ( ( int ) viff_info . map_storage_type ) {\n case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ;\n break ;\n case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ;\n break ;\n case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ;\n break ;\n case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ;\n break ;\n case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ;\n break ;\n default : bytes_per_pixel = 1 ;\n break ;\n }\n image -> colors = viff_info . map_columns ;\n if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ;\n viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ;\n if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n ( void ) ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ;\n lsb_first = 1 ;\n if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) {\n case VFF_MAPTYP_2_BYTE : {\n MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;\n break ;\n }\n case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : {\n MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ;\n break ;\n }\n default : break ;\n }\n for ( i = 0 ;\n i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ;\n i ++ ) {\n switch ( ( int ) viff_info . map_storage_type ) {\n case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ;\n break ;\n case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ;\n break ;\n case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ;\n break ;\n case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ;\n break ;\n default : value = 1.0 * viff_colormap [ i ] ;\n break ;\n }\n if ( i < ( ssize_t ) image -> colors ) {\n image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ;\n image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;\n image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;\n }\n else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ;\n else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ;\n }\n viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ;\n break ;\n }\n default : ThrowReaderException ( CoderError , \"ColormapTypeNotSupported\" ) ;\n }\n image -> matte = viff_info . number_data_bands == 4 ? MagickTrue : MagickFalse ;\n image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ;\n image -> columns = viff_info . rows ;\n image -> rows = viff_info . columns ;\n if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;\n status = SetImageExtent ( image , image -> columns , image -> rows ) ;\n if ( status == MagickFalse ) {\n InheritException ( exception , & image -> exception ) ;\n return ( DestroyImageList ( image ) ) ;\n }\n switch ( ( int ) viff_info . data_storage_type ) {\n case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ;\n break ;\n case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ;\n break ;\n case VFF_TYP_FLOAT : bytes_per_pixel = 4 ;\n break ;\n case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ;\n break ;\n default : bytes_per_pixel = 1 ;\n break ;\n }\n if ( viff_info . data_storage_type == VFF_TYP_BIT ) max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ;\n else max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ;\n pixels = ( unsigned char * ) AcquireQuantumMemory ( max_packets , bytes_per_pixel * sizeof ( * pixels ) ) ;\n if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ;\n ( void ) ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ;\n lsb_first = 1 ;\n if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . data_storage_type ) {\n case VFF_TYP_2_BYTE : {\n MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ;\n break ;\n }\n case VFF_TYP_4_BYTE : case VFF_TYP_FLOAT : {\n MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ;\n break ;\n }\n default : break ;\n }\n min_value = 0.0 ;\n scale_factor = 1.0 ;\n if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . map_scheme == VFF_MS_NONE ) ) {\n double max_value ;\n switch ( ( int ) viff_info . data_storage_type ) {\n case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ;\n break ;\n case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ;\n break ;\n case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ;\n break ;\n case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ;\n break ;\n default : value = 1.0 * pixels [ 0 ] ;\n break ;\n }\n max_value = value ;\n min_value = value ;\n for ( i = 0 ;\n i < ( ssize_t ) max_packets ;\n i ++ ) {\n switch ( ( int ) viff_info . data_storage_type ) {\n case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ;\n break ;\n case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ;\n break ;\n case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ;\n break ;\n case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ;\n break ;\n default : value = 1.0 * pixels [ i ] ;\n break ;\n }\n if ( value > max_value ) max_value = value ;\n else if ( value < min_value ) min_value = value ;\n }\n if ( ( min_value == 0 ) && ( max_value == 0 ) ) scale_factor = 0 ;\n else if ( min_value == max_value ) {\n scale_factor = ( MagickRealType ) QuantumRange / min_value ;\n min_value = 0 ;\n }\n else scale_factor = ( MagickRealType ) QuantumRange / ( max_value - min_value ) ;\n }\n p = ( unsigned char * ) pixels ;\n for ( i = 0 ;\n i < ( ssize_t ) max_packets ;\n i ++ ) {\n switch ( ( int ) viff_info . data_storage_type ) {\n case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ;\n break ;\n case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ;\n break ;\n case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ;\n break ;\n case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ;\n break ;\n default : value = 1.0 * pixels [ i ] ;\n break ;\n }\n if ( viff_info . map_scheme == VFF_MS_NONE ) {\n value = ( value - min_value ) * scale_factor ;\n if ( value > QuantumRange ) value = QuantumRange ;\n else if ( value < 0 ) value = 0 ;\n }\n * p = ( unsigned char ) ( ( Quantum ) value ) ;\n p ++ ;\n }\n p = ( unsigned char * ) pixels ;\n if ( viff_info . data_storage_type == VFF_TYP_BIT ) {\n if ( image -> storage_class != PseudoClass ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ;\n for ( y = 0 ;\n y < ( ssize_t ) image -> rows ;\n y ++ ) {\n q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;\n if ( q == ( PixelPacket * ) NULL ) break ;\n indexes = GetAuthenticIndexQueue ( image ) ;\n for ( x = 0 ;\n x < ( ssize_t ) ( image -> columns - 7 ) ;\n x += 8 ) {\n for ( bit = 0 ;\n bit < 8 ;\n bit ++ ) {\n quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ;\n SetPixelRed ( q , quantum == 0 ? 0 : QuantumRange ) ;\n SetPixelGreen ( q , quantum == 0 ? 0 : QuantumRange ) ;\n SetPixelBlue ( q , quantum == 0 ? 0 : QuantumRange ) ;\n if ( image -> storage_class == PseudoClass ) SetPixelIndex ( indexes + x + bit , quantum ) ;\n }\n p ++ ;\n }\n if ( ( image -> columns % 8 ) != 0 ) {\n for ( bit = 0 ;\n bit < ( int ) ( image -> columns % 8 ) ;\n bit ++ ) {\n quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ;\n SetPixelRed ( q , quantum == 0 ? 0 : QuantumRange ) ;\n SetPixelGreen ( q , quantum == 0 ? 0 : QuantumRange ) ;\n SetPixelBlue ( q , quantum == 0 ? 0 : QuantumRange ) ;\n if ( image -> storage_class == PseudoClass ) SetPixelIndex ( indexes + x + bit , quantum ) ;\n }\n p ++ ;\n }\n if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;\n if ( image -> previous == ( Image * ) NULL ) {\n status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;\n if ( status == MagickFalse ) break ;\n }\n }\n }\n else if ( image -> storage_class == PseudoClass ) for ( y = 0 ;\n y < ( ssize_t ) image -> rows ;\n y ++ ) {\n q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;\n if ( q == ( PixelPacket * ) NULL ) break ;\n indexes = GetAuthenticIndexQueue ( image ) ;\n for ( x = 0 ;\n x < ( ssize_t ) image -> columns ;\n x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ;\n if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;\n if ( image -> previous == ( Image * ) NULL ) {\n status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;\n if ( status == MagickFalse ) break ;\n }\n }\n else {\n number_pixels = ( MagickSizeType ) image -> columns * image -> rows ;\n for ( y = 0 ;\n y < ( ssize_t ) image -> rows ;\n y ++ ) {\n q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ;\n if ( q == ( PixelPacket * ) NULL ) break ;\n for ( x = 0 ;\n x < ( ssize_t ) image -> columns ;\n x ++ ) {\n SetPixelRed ( q , ScaleCharToQuantum ( * p ) ) ;\n SetPixelGreen ( q , ScaleCharToQuantum ( * ( p + number_pixels ) ) ) ;\n SetPixelBlue ( q , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) ) ;\n if ( image -> colors != 0 ) {\n ssize_t index ;\n index = ( ssize_t ) GetPixelRed ( q ) ;\n SetPixelRed ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . red ) ;\n index = ( ssize_t ) GetPixelGreen ( q ) ;\n SetPixelGreen ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . green ) ;\n index = ( ssize_t ) GetPixelRed ( q ) ;\n SetPixelBlue ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . blue ) ;\n }\n SetPixelOpacity ( q , image -> matte != MagickFalse ? QuantumRange - ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueOpacity ) ;\n p ++ ;\n q ++ ;\n }\n if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ;\n if ( image -> previous == ( Image * ) NULL ) {\n status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ;\n if ( status == MagickFalse ) break ;\n }\n }\n }\n pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ;\n if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image ) ;\n if ( EOFBlob ( image ) != MagickFalse ) {\n ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ;\n break ;\n }\n if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ;\n count = ReadBlob ( image , 1 , & viff_info . identifier ) ;\n if ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) {\n AcquireNextImage ( image_info , image ) ;\n if ( GetNextImageInList ( image ) == ( Image * ) NULL ) {\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n image = SyncNextImageInList ( image ) ;\n status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ;\n if ( status == MagickFalse ) break ;\n }\n }\n while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ;\n ( void ) CloseBlob ( image ) ;\n return ( GetFirstImageInList ( image ) ) ;\n }", "hash": 7817292828288926681, "project": "debian", "size": 379, "target": 1, "idx": 21448}
{"code": "static void dump_table ( char * table , char * db ) {\n char ignore_flag ;\n char buf [ 200 ] , table_buff [ NAME_LEN + 3 ] ;\n DYNAMIC_STRING query_string ;\n char table_type [ NAME_LEN ] ;\n char * result_table , table_buff2 [ NAME_LEN * 2 + 3 ] , * opt_quoted_table ;\n int error = 0 ;\n ulong rownr , row_break , total_length , init_length ;\n uint num_fields ;\n MYSQL_RES * res ;\n MYSQL_FIELD * field ;\n MYSQL_ROW row ;\n DBUG_ENTER ( \"dump_table\" ) ;\n num_fields = get_table_structure ( table , db , table_type , & ignore_flag ) ;\n if ( strcmp ( table_type , \"VIEW\" ) == 0 ) DBUG_VOID_RETURN ;\n if ( opt_no_data ) {\n verbose_msg ( \"-- Skipping dump data for table '%s', --no-data was used\\n\" , table ) ;\n DBUG_VOID_RETURN ;\n }\n DBUG_PRINT ( \"info\" , ( \"ignore_flag: %x num_fields: %d\" , ( int ) ignore_flag , num_fields ) ) ;\n if ( ignore_flag & IGNORE_DATA ) {\n verbose_msg ( \"-- Warning: Skipping data for table '%s' because \" \"it's of type %s\\n\" , table , table_type ) ;\n DBUG_VOID_RETURN ;\n }\n if ( num_fields == 0 ) {\n verbose_msg ( \"-- Skipping dump data for table '%s', it has no fields\\n\" , table ) ;\n DBUG_VOID_RETURN ;\n }\n if ( ! opt_events && ! my_strcasecmp ( & my_charset_latin1 , db , \"mysql\" ) && ! my_strcasecmp ( & my_charset_latin1 , table , \"event\" ) ) {\n verbose_msg ( \"-- Skipping data table mysql.event, --skip-events was used\\n\" ) ;\n DBUG_VOID_RETURN ;\n }\n result_table = quote_name ( table , table_buff , 1 ) ;\n opt_quoted_table = quote_name ( table , table_buff2 , 0 ) ;\n verbose_msg ( \"-- Sending SELECT query...\\n\" ) ;\n init_dynamic_string_checked ( & query_string , \"\" , 1024 , 1024 ) ;\n if ( path ) {\n char filename [ FN_REFLEN ] , tmp_path [ FN_REFLEN ] ;\n convert_dirname ( tmp_path , path , NullS ) ;\n my_load_path ( tmp_path , tmp_path , NULL ) ;\n fn_format ( filename , table , tmp_path , \".txt\" , MYF ( MY_UNPACK_FILENAME ) ) ;\n my_delete ( filename , MYF ( 0 ) ) ;\n to_unix_path ( filename ) ;\n dynstr_append_checked ( & query_string , \"SELECT /*!40001 SQL_NO_CACHE */ * INTO OUTFILE '\" ) ;\n dynstr_append_checked ( & query_string , filename ) ;\n dynstr_append_checked ( & query_string , \"'\" ) ;\n dynstr_append_checked ( & query_string , \" /*!50138 CHARACTER SET \" ) ;\n dynstr_append_checked ( & query_string , default_charset == mysql_universal_client_charset ? my_charset_bin . name : default_charset ) ;\n dynstr_append_checked ( & query_string , \" */\" ) ;\n if ( fields_terminated || enclosed || opt_enclosed || escaped ) dynstr_append_checked ( & query_string , \" FIELDS\" ) ;\n add_load_option ( & query_string , \" TERMINATED BY \" , fields_terminated ) ;\n add_load_option ( & query_string , \" ENCLOSED BY \" , enclosed ) ;\n add_load_option ( & query_string , \" OPTIONALLY ENCLOSED BY \" , opt_enclosed ) ;\n add_load_option ( & query_string , \" ESCAPED BY \" , escaped ) ;\n add_load_option ( & query_string , \" LINES TERMINATED BY \" , lines_terminated ) ;\n dynstr_append_checked ( & query_string , \" FROM \" ) ;\n dynstr_append_checked ( & query_string , result_table ) ;\n if ( where ) {\n dynstr_append_checked ( & query_string , \" WHERE \" ) ;\n dynstr_append_checked ( & query_string , where ) ;\n }\n if ( order_by ) {\n dynstr_append_checked ( & query_string , \" ORDER BY \" ) ;\n dynstr_append_checked ( & query_string , order_by ) ;\n }\n if ( mysql_real_query ( mysql , query_string . str , query_string . length ) ) {\n DB_error ( mysql , \"when executing 'SELECT INTO OUTFILE'\" ) ;\n dynstr_free ( & query_string ) ;\n DBUG_VOID_RETURN ;\n }\n }\n else {\n print_comment ( md_result_file , 0 , \"\\n--\\n-- Dumping data for table %s\\n--\\n\" , result_table ) ;\n dynstr_append_checked ( & query_string , \"SELECT /*!40001 SQL_NO_CACHE */ * FROM \" ) ;\n dynstr_append_checked ( & query_string , result_table ) ;\n if ( where ) {\n print_comment ( md_result_file , 0 , \"-- WHERE: %s\\n\" , where ) ;\n dynstr_append_checked ( & query_string , \" WHERE \" ) ;\n dynstr_append_checked ( & query_string , where ) ;\n }\n if ( order_by ) {\n print_comment ( md_result_file , 0 , \"-- ORDER BY: %s\\n\" , order_by ) ;\n dynstr_append_checked ( & query_string , \" ORDER BY \" ) ;\n dynstr_append_checked ( & query_string , order_by ) ;\n }\n if ( ! opt_xml && ! opt_compact ) {\n fputs ( \"\\n\" , md_result_file ) ;\n check_io ( md_result_file ) ;\n }\n if ( mysql_query_with_error_report ( mysql , 0 , query_string . str ) ) {\n DB_error ( mysql , \"when retrieving data from server\" ) ;\n goto err ;\n }\n if ( quick ) res = mysql_use_result ( mysql ) ;\n else res = mysql_store_result ( mysql ) ;\n if ( ! res ) {\n DB_error ( mysql , \"when retrieving data from server\" ) ;\n goto err ;\n }\n verbose_msg ( \"-- Retrieving rows...\\n\" ) ;\n if ( mysql_num_fields ( res ) != num_fields ) {\n fprintf ( stderr , \"%s: Error in field count for table: %s ! Aborting.\\n\" , my_progname_short , result_table ) ;\n error = EX_CONSCHECK ;\n goto err ;\n }\n if ( opt_lock ) {\n fprintf ( md_result_file , \"LOCK TABLES %s WRITE;\n\\n\" , opt_quoted_table ) ;\n check_io ( md_result_file ) ;\n }\n if ( opt_disable_keys ) {\n fprintf ( md_result_file , \"/*!40000 ALTER TABLE %s DISABLE KEYS */;\n\\n\" , opt_quoted_table ) ;\n check_io ( md_result_file ) ;\n }\n total_length = opt_net_buffer_length ;\n row_break = 0 ;\n rownr = 0 ;\n init_length = ( uint ) insert_pat . length + 4 ;\n if ( opt_xml ) print_xml_tag ( md_result_file , \"\\t\" , \"\\n\" , \"table_data\" , \"name=\" , table , NullS ) ;\n if ( opt_autocommit ) {\n fprintf ( md_result_file , \"set autocommit=0;\n\\n\" ) ;\n check_io ( md_result_file ) ;\n }\n while ( ( row = mysql_fetch_row ( res ) ) ) {\n uint i ;\n ulong * lengths = mysql_fetch_lengths ( res ) ;\n rownr ++ ;\n if ( ! extended_insert && ! opt_xml ) {\n fputs ( insert_pat . str , md_result_file ) ;\n check_io ( md_result_file ) ;\n }\n mysql_field_seek ( res , 0 ) ;\n if ( opt_xml ) {\n fputs ( \"\\t<row>\\n\" , md_result_file ) ;\n check_io ( md_result_file ) ;\n }\n for ( i = 0 ;\n i < mysql_num_fields ( res ) ;\n i ++ ) {\n int is_blob ;\n ulong length = lengths [ i ] ;\n if ( ! ( field = mysql_fetch_field ( res ) ) ) die ( EX_CONSCHECK , \"Not enough fields from table %s! Aborting.\\n\" , result_table ) ;\n is_blob = ( opt_hex_blob && field -> charsetnr == 63 && ( field -> type == MYSQL_TYPE_BIT || field -> type == MYSQL_TYPE_STRING || field -> type == MYSQL_TYPE_VAR_STRING || field -> type == MYSQL_TYPE_VARCHAR || field -> type == MYSQL_TYPE_BLOB || field -> type == MYSQL_TYPE_LONG_BLOB || field -> type == MYSQL_TYPE_MEDIUM_BLOB || field -> type == MYSQL_TYPE_TINY_BLOB || field -> type == MYSQL_TYPE_GEOMETRY ) ) ? 1 : 0 ;\n if ( extended_insert && ! opt_xml ) {\n if ( i == 0 ) dynstr_set_checked ( & extended_row , \"(\" ) ;\n else dynstr_append_checked ( & extended_row , \",\" ) ;\n if ( row [ i ] ) {\n if ( length ) {\n if ( ! ( field -> flags & NUM_FLAG ) ) {\n dynstr_realloc_checked ( & extended_row , length * 2 + 2 + 1 ) ;\n if ( opt_hex_blob && is_blob ) {\n dynstr_append_checked ( & extended_row , \"0x\" ) ;\n extended_row . length += mysql_hex_string ( extended_row . str + extended_row . length , row [ i ] , length ) ;\n DBUG_ASSERT ( extended_row . length + 1 <= extended_row . max_length ) ;\n DBUG_ASSERT ( extended_row . str [ extended_row . length ] == '\\0' ) ;\n }\n else {\n dynstr_append_checked ( & extended_row , \"'\" ) ;\n extended_row . length += mysql_real_escape_string ( & mysql_connection , & extended_row . str [ extended_row . length ] , row [ i ] , length ) ;\n extended_row . str [ extended_row . length ] = '\\0' ;\n dynstr_append_checked ( & extended_row , \"'\" ) ;\n }\n }\n else {\n char * ptr = row [ i ] ;\n if ( my_isalpha ( charset_info , * ptr ) || ( * ptr == '-' && my_isalpha ( charset_info , ptr [ 1 ] ) ) ) dynstr_append_checked ( & extended_row , \"NULL\" ) ;\n else {\n if ( field -> type == MYSQL_TYPE_DECIMAL ) {\n dynstr_append_checked ( & extended_row , \"'\" ) ;\n dynstr_append_checked ( & extended_row , ptr ) ;\n dynstr_append_checked ( & extended_row , \"'\" ) ;\n }\n else dynstr_append_checked ( & extended_row , ptr ) ;\n }\n }\n }\n else dynstr_append_checked ( & extended_row , \"''\" ) ;\n }\n else dynstr_append_checked ( & extended_row , \"NULL\" ) ;\n }\n else {\n if ( i && ! opt_xml ) {\n fputc ( ',' , md_result_file ) ;\n check_io ( md_result_file ) ;\n }\n if ( row [ i ] ) {\n if ( ! ( field -> flags & NUM_FLAG ) ) {\n if ( opt_xml ) {\n if ( opt_hex_blob && is_blob && length ) {\n print_xml_tag ( md_result_file , \"\\t\\t\" , \"\" , \"field\" , \"name=\" , field -> name , \"xsi:type=\" , \"xs:hexBinary\" , NullS ) ;\n print_blob_as_hex ( md_result_file , row [ i ] , length ) ;\n }\n else {\n print_xml_tag ( md_result_file , \"\\t\\t\" , \"\" , \"field\" , \"name=\" , field -> name , NullS ) ;\n print_quoted_xml ( md_result_file , row [ i ] , length , 0 ) ;\n }\n fputs ( \"</field>\\n\" , md_result_file ) ;\n }\n else if ( opt_hex_blob && is_blob && length ) {\n fputs ( \"0x\" , md_result_file ) ;\n print_blob_as_hex ( md_result_file , row [ i ] , length ) ;\n }\n else unescape ( md_result_file , row [ i ] , length ) ;\n }\n else {\n char * ptr = row [ i ] ;\n if ( opt_xml ) {\n print_xml_tag ( md_result_file , \"\\t\\t\" , \"\" , \"field\" , \"name=\" , field -> name , NullS ) ;\n fputs ( ! my_isalpha ( charset_info , * ptr ) ? ptr : \"NULL\" , md_result_file ) ;\n fputs ( \"</field>\\n\" , md_result_file ) ;\n }\n else if ( my_isalpha ( charset_info , * ptr ) || ( * ptr == '-' && my_isalpha ( charset_info , ptr [ 1 ] ) ) ) fputs ( \"NULL\" , md_result_file ) ;\n else if ( field -> type == MYSQL_TYPE_DECIMAL ) {\n fputc ( '\\'' , md_result_file ) ;\n fputs ( ptr , md_result_file ) ;\n fputc ( '\\'' , md_result_file ) ;\n }\n else fputs ( ptr , md_result_file ) ;\n }\n }\n else {\n if ( ! opt_xml ) fputs ( \"NULL\" , md_result_file ) ;\n else print_xml_null_tag ( md_result_file , \"\\t\\t\" , \"field name=\" , field -> name , \"\\n\" ) ;\n }\n check_io ( md_result_file ) ;\n }\n }\n if ( opt_xml ) {\n fputs ( \"\\t</row>\\n\" , md_result_file ) ;\n check_io ( md_result_file ) ;\n }\n if ( extended_insert ) {\n ulong row_length ;\n dynstr_append_checked ( & extended_row , \")\" ) ;\n row_length = 2 + extended_row . length ;\n if ( total_length + row_length < opt_net_buffer_length ) {\n total_length += row_length ;\n fputc ( ',' , md_result_file ) ;\n fputs ( extended_row . str , md_result_file ) ;\n }\n else {\n if ( row_break ) fputs ( \";\n\\n\" , md_result_file ) ;\n row_break = 1 ;\n fputs ( insert_pat . str , md_result_file ) ;\n fputs ( extended_row . str , md_result_file ) ;\n total_length = row_length + init_length ;\n }\n check_io ( md_result_file ) ;\n }\n else if ( ! opt_xml ) {\n fputs ( \");\n\\n\" , md_result_file ) ;\n check_io ( md_result_file ) ;\n }\n }\n if ( opt_xml ) fputs ( \"\\t</table_data>\\n\" , md_result_file ) ;\n else if ( extended_insert && row_break ) fputs ( \";\n\\n\" , md_result_file ) ;\n fflush ( md_result_file ) ;\n check_io ( md_result_file ) ;\n if ( mysql_errno ( mysql ) ) {\n my_snprintf ( buf , sizeof ( buf ) , \"%s: Error %d: %s when dumping table %s at row: %ld\\n\" , my_progname_short , mysql_errno ( mysql ) , mysql_error ( mysql ) , result_table , rownr ) ;\n fputs ( buf , stderr ) ;\n error = EX_CONSCHECK ;\n goto err ;\n }\n if ( opt_disable_keys ) {\n fprintf ( md_result_file , \"/*!40000 ALTER TABLE %s ENABLE KEYS */;\n\\n\" , opt_quoted_table ) ;\n check_io ( md_result_file ) ;\n }\n if ( opt_lock ) {\n fputs ( \"UNLOCK TABLES;\n\\n\" , md_result_file ) ;\n check_io ( md_result_file ) ;\n }\n if ( opt_autocommit ) {\n fprintf ( md_result_file , \"commit;\n\\n\" ) ;\n check_io ( md_result_file ) ;\n }\n mysql_free_result ( res ) ;\n }\n dynstr_free ( & query_string ) ;\n DBUG_VOID_RETURN ;\n err : dynstr_free ( & query_string ) ;\n maybe_exit ( error ) ;\n DBUG_VOID_RETURN ;\n }", "hash": 6667142528452941476, "project": "debian", "size": 292, "target": 1, "idx": 21455}
{"code": "static uint dump_events_for_db ( char * db ) {\n char query_buff [ QUERY_LENGTH ] ;\n char db_name_buff [ NAME_LEN * 2 + 3 ] , name_buff [ NAME_LEN * 2 + 3 ] ;\n char * event_name ;\n char delimiter [ QUERY_LENGTH ] ;\n FILE * sql_file = md_result_file ;\n MYSQL_RES * event_res , * event_list_res ;\n MYSQL_ROW row , event_list_row ;\n char db_cl_name [ MY_CS_NAME_SIZE ] ;\n int db_cl_altered = FALSE ;\n DBUG_ENTER ( \"dump_events_for_db\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"db: '%s'\" , db ) ) ;\n mysql_real_escape_string ( mysql , db_name_buff , db , ( ulong ) strlen ( db ) ) ;\n print_comment ( sql_file , 0 , \"\\n--\\n-- Dumping events for database '%s'\\n--\\n\" , db ) ;\n if ( lock_tables ) mysql_query ( mysql , \"LOCK TABLES mysql.event READ\" ) ;\n if ( mysql_query_with_error_report ( mysql , & event_list_res , \"show events\" ) ) DBUG_RETURN ( 0 ) ;\n strcpy ( delimiter , \";\n\" ) ;\n if ( mysql_num_rows ( event_list_res ) > 0 ) {\n if ( opt_xml ) fputs ( \"\\t<events>\\n\" , sql_file ) ;\n else {\n fprintf ( sql_file , \"/*!50106 SET @save_time_zone= @@TIME_ZONE */ ;\n\\n\" ) ;\n if ( fetch_db_collation ( db_name_buff , db_cl_name , sizeof ( db_cl_name ) ) ) DBUG_RETURN ( 1 ) ;\n }\n if ( switch_character_set_results ( mysql , \"binary\" ) ) DBUG_RETURN ( 1 ) ;\n while ( ( event_list_row = mysql_fetch_row ( event_list_res ) ) != NULL ) {\n event_name = quote_name ( event_list_row [ 1 ] , name_buff , 0 ) ;\n DBUG_PRINT ( \"info\" , ( \"retrieving CREATE EVENT for %s\" , name_buff ) ) ;\n my_snprintf ( query_buff , sizeof ( query_buff ) , \"SHOW CREATE EVENT %s\" , event_name ) ;\n if ( mysql_query_with_error_report ( mysql , & event_res , query_buff ) ) DBUG_RETURN ( 1 ) ;\n while ( ( row = mysql_fetch_row ( event_res ) ) != NULL ) {\n if ( opt_xml ) {\n print_xml_row ( sql_file , \"event\" , event_res , & row , \"Create Event\" ) ;\n continue ;\n }\n if ( strlen ( row [ 3 ] ) != 0 ) {\n char * query_str ;\n if ( opt_drop ) fprintf ( sql_file , \"/*!50106 DROP EVENT IF EXISTS %s */%s\\n\" , event_name , delimiter ) ;\n if ( create_delimiter ( row [ 3 ] , delimiter , sizeof ( delimiter ) ) == NULL ) {\n fprintf ( stderr , \"%s: Warning: Can't create delimiter for event '%s'\\n\" , my_progname_short , event_name ) ;\n DBUG_RETURN ( 1 ) ;\n }\n fprintf ( sql_file , \"DELIMITER %s\\n\" , delimiter ) ;\n if ( mysql_num_fields ( event_res ) >= 7 ) {\n if ( switch_db_collation ( sql_file , db_name_buff , delimiter , db_cl_name , row [ 6 ] , & db_cl_altered ) ) {\n DBUG_RETURN ( 1 ) ;\n }\n switch_cs_variables ( sql_file , delimiter , row [ 4 ] , row [ 4 ] , row [ 5 ] ) ;\n }\n else {\n fprintf ( sql_file , \"--\\n\" \"-- WARNING: old server version. \" \"The following dump may be incomplete.\\n\" \"--\\n\" ) ;\n }\n switch_sql_mode ( sql_file , delimiter , row [ 1 ] ) ;\n switch_time_zone ( sql_file , delimiter , row [ 2 ] ) ;\n query_str = cover_definer_clause ( row [ 3 ] , strlen ( row [ 3 ] ) , C_STRING_WITH_LEN ( \"50117\" ) , C_STRING_WITH_LEN ( \"50106\" ) , C_STRING_WITH_LEN ( \" EVENT\" ) ) ;\n fprintf ( sql_file , \"/*!50106 %s */ %s\\n\" , ( const char * ) ( query_str != NULL ? query_str : row [ 3 ] ) , ( const char * ) delimiter ) ;\n my_free ( query_str ) ;\n restore_time_zone ( sql_file , delimiter ) ;\n restore_sql_mode ( sql_file , delimiter ) ;\n if ( mysql_num_fields ( event_res ) >= 7 ) {\n restore_cs_variables ( sql_file , delimiter ) ;\n if ( db_cl_altered ) {\n if ( restore_db_collation ( sql_file , db_name_buff , delimiter , db_cl_name ) ) DBUG_RETURN ( 1 ) ;\n }\n }\n }\n }\n mysql_free_result ( event_res ) ;\n }\n if ( opt_xml ) {\n fputs ( \"\\t</events>\\n\" , sql_file ) ;\n check_io ( sql_file ) ;\n }\n else {\n fprintf ( sql_file , \"DELIMITER ;\n\\n\" ) ;\n fprintf ( sql_file , \"/*!50106 SET TIME_ZONE= @save_time_zone */ ;\n\\n\" ) ;\n }\n if ( switch_character_set_results ( mysql , default_charset ) ) DBUG_RETURN ( 1 ) ;\n }\n mysql_free_result ( event_list_res ) ;\n if ( lock_tables ) ( void ) mysql_query_with_error_report ( mysql , 0 , \"UNLOCK TABLES\" ) ;\n DBUG_RETURN ( 0 ) ;\n }", "hash": 6667142528452941476, "project": "debian", "size": 86, "target": 1, "idx": 21457}
{"code": "static int ec_GF2m_montgomery_point_multiply ( const EC_GROUP * group , EC_POINT * r , const BIGNUM * scalar , const EC_POINT * point , BN_CTX * ctx ) {\n BIGNUM * x1 , * x2 , * z1 , * z2 ;\n int ret = 0 , i ;\n BN_ULONG mask , word ;\n if ( r == point ) {\n ECerr ( EC_F_EC_GF2M_MONTGOMERY_POINT_MULTIPLY , EC_R_INVALID_ARGUMENT ) ;\n return 0 ;\n }\n if ( ( scalar == NULL ) || BN_is_zero ( scalar ) || ( point == NULL ) || EC_POINT_is_at_infinity ( group , point ) ) {\n return EC_POINT_set_to_infinity ( group , r ) ;\n }\n if ( ! point -> Z_is_one ) return 0 ;\n BN_CTX_start ( ctx ) ;\n x1 = BN_CTX_get ( ctx ) ;\n z1 = BN_CTX_get ( ctx ) ;\n if ( z1 == NULL ) goto err ;\n x2 = & r -> X ;\n z2 = & r -> Y ;\n if ( ! BN_GF2m_mod_arr ( x1 , & point -> X , group -> poly ) ) goto err ;\n if ( ! BN_one ( z1 ) ) goto err ;\n if ( ! group -> meth -> field_sqr ( group , z2 , x1 , ctx ) ) goto err ;\n if ( ! group -> meth -> field_sqr ( group , x2 , z2 , ctx ) ) goto err ;\n if ( ! BN_GF2m_add ( x2 , x2 , & group -> b ) ) goto err ;\n i = scalar -> top - 1 ;\n mask = BN_TBIT ;\n word = scalar -> d [ i ] ;\n while ( ! ( word & mask ) ) mask >>= 1 ;\n mask >>= 1 ;\n if ( ! mask ) {\n i -- ;\n mask = BN_TBIT ;\n }\n for ( ;\n i >= 0 ;\n i -- ) {\n word = scalar -> d [ i ] ;\n while ( mask ) {\n if ( word & mask ) {\n if ( ! gf2m_Madd ( group , & point -> X , x1 , z1 , x2 , z2 , ctx ) ) goto err ;\n if ( ! gf2m_Mdouble ( group , x2 , z2 , ctx ) ) goto err ;\n }\n else {\n if ( ! gf2m_Madd ( group , & point -> X , x2 , z2 , x1 , z1 , ctx ) ) goto err ;\n if ( ! gf2m_Mdouble ( group , x1 , z1 , ctx ) ) goto err ;\n }\n mask >>= 1 ;\n }\n mask = BN_TBIT ;\n }\n i = gf2m_Mxy ( group , & point -> X , & point -> Y , x1 , z1 , x2 , z2 , ctx ) ;\n if ( i == 0 ) goto err ;\n else if ( i == 1 ) {\n if ( ! EC_POINT_set_to_infinity ( group , r ) ) goto err ;\n }\n else {\n if ( ! BN_one ( & r -> Z ) ) goto err ;\n r -> Z_is_one = 1 ;\n }\n BN_set_negative ( & r -> X , 0 ) ;\n BN_set_negative ( & r -> Y , 0 ) ;\n ret = 1 ;\n err : BN_CTX_end ( ctx ) ;\n return ret ;\n }", "hash": 5468438784905165517, "project": "debian", "size": 64, "target": 1, "idx": 21463}
{"code": "extern int as_mysql_job_complete ( mysql_conn_t * mysql_conn , struct job_record * job_ptr ) {\n char * query = NULL ;\n int rc = SLURM_SUCCESS , job_state ;\n time_t submit_time , end_time ;\n uint32_t exit_code = 0 ;\n if ( ! job_ptr -> db_index && ( ( ! job_ptr -> details || ! job_ptr -> details -> submit_time ) && ! job_ptr -> resize_time ) ) {\n error ( \"as_mysql_job_complete: \" \"Not inputing this job, it has no submit time.\" ) ;\n return SLURM_ERROR ;\n }\n if ( check_connection ( mysql_conn ) != SLURM_SUCCESS ) return ESLURM_DB_CONNECTION ;\n debug2 ( \"as_mysql_slurmdb_job_complete() called\" ) ;\n if ( job_ptr -> resize_time ) submit_time = job_ptr -> resize_time ;\n else submit_time = job_ptr -> details -> submit_time ;\n if ( IS_JOB_RESIZING ( job_ptr ) ) {\n end_time = job_ptr -> resize_time ;\n job_state = JOB_RESIZING ;\n }\n else {\n if ( job_ptr -> end_time == 0 ) {\n if ( job_ptr -> start_time ) {\n error ( \"%s: We are trying to end a job (%u) with no end time, setting it to the start time (%ld) of the job.\" , __func__ , job_ptr -> job_id , job_ptr -> start_time ) ;\n job_ptr -> end_time = job_ptr -> start_time ;\n }\n else {\n error ( \"%s: job %u never started\" , __func__ , job_ptr -> job_id ) ;\n return SLURM_SUCCESS ;\n }\n }\n end_time = job_ptr -> end_time ;\n if ( IS_JOB_REQUEUED ( job_ptr ) ) job_state = JOB_REQUEUE ;\n else if ( IS_JOB_REVOKED ( job_ptr ) ) job_state = JOB_REVOKED ;\n else job_state = job_ptr -> job_state & JOB_STATE_BASE ;\n }\n slurm_mutex_lock ( & rollup_lock ) ;\n if ( end_time < global_last_rollup ) {\n global_last_rollup = job_ptr -> end_time ;\n slurm_mutex_unlock ( & rollup_lock ) ;\n query = xstrdup_printf ( \"update \\\"%s_%s\\\" set \" \"hourly_rollup=%ld, \" \"daily_rollup=%ld, monthly_rollup=%ld\" , mysql_conn -> cluster_name , last_ran_table , end_time , end_time , end_time ) ;\n if ( debug_flags & DEBUG_FLAG_DB_JOB ) DB_DEBUG ( mysql_conn -> conn , \"query\\n%s\" , query ) ;\n ( void ) mysql_db_query ( mysql_conn , query ) ;\n xfree ( query ) ;\n }\n else slurm_mutex_unlock ( & rollup_lock ) ;\n if ( ! job_ptr -> db_index ) {\n if ( ! ( job_ptr -> db_index = _get_db_index ( mysql_conn , submit_time , job_ptr -> job_id , job_ptr -> assoc_id ) ) ) {\n char * comment = job_ptr -> comment ;\n job_ptr -> comment = NULL ;\n if ( as_mysql_job_start ( mysql_conn , job_ptr ) == SLURM_ERROR ) {\n job_ptr -> comment = comment ;\n error ( \"couldn't add job %u at job completion\" , job_ptr -> job_id ) ;\n return SLURM_SUCCESS ;\n }\n job_ptr -> comment = comment ;\n }\n }\n query = xstrdup_printf ( \"update \\\"%s_%s\\\" set \" \"mod_time=UNIX_TIMESTAMP(), \" \"time_end=%ld, state=%d\" , mysql_conn -> cluster_name , job_table , end_time , job_state ) ;\n if ( job_ptr -> derived_ec != NO_VAL ) xstrfmtcat ( query , \", derived_ec=%u\" , job_ptr -> derived_ec ) ;\n if ( job_ptr -> comment ) {\n char * comment = slurm_add_slash_to_quotes ( job_ptr -> comment ) ;\n xstrfmtcat ( query , \", derived_es='%s'\" , comment ) ;\n xfree ( comment ) ;\n }\n if ( job_ptr -> admin_comment ) {\n char * comment = slurm_add_slash_to_quotes ( job_ptr -> admin_comment ) ;\n xstrfmtcat ( query , \", admin_comment='%s'\" , comment ) ;\n xfree ( comment ) ;\n }\n exit_code = job_ptr -> exit_code ;\n if ( exit_code == 1 ) {\n exit_code = 256 ;\n }\n xstrfmtcat ( query , \", exit_code=%d, kill_requid=%d where job_db_inx=%\" PRIu64 \";\n\" , exit_code , job_ptr -> requid , job_ptr -> db_index ) ;\n if ( debug_flags & DEBUG_FLAG_DB_JOB ) DB_DEBUG ( mysql_conn -> conn , \"query\\n%s\" , query ) ;\n rc = mysql_db_query ( mysql_conn , query ) ;\n xfree ( query ) ;\n return rc ;\n }", "hash": -483869641057106085, "project": "debian", "size": 78, "target": 1, "idx": 21472}
{"code": "static void * i_alloc_struct_array ( gs_memory_t * mem , uint num_elements , gs_memory_type_ptr_t pstype , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n obj_header_t * obj ;\n # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;\n # endif ALLOC_CHECK_SIZE ( mem , pstype ) ;\n # ifdef DEBUG if ( pstype -> enum_ptrs == basic_enum_ptrs ) {\n dmprintf2 ( mem , \" i_alloc_struct_array: called with incorrect structure type (not element), struct='%s', client='%s'\\n\" , pstype -> sname , cname ) ;\n return NULL ;\n }\n # endif obj = alloc_obj ( imem , ( ulong ) num_elements * pstype -> ssize , pstype , ALLOC_DIRECT , cname ) ;\n if_debug7m ( 'A' , mem , \"[a%d:+<.]%s %s*(%lu=%u*%u) = 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , struct_type_name_string ( pstype ) , ( ulong ) num_elements * pstype -> ssize , num_elements , pstype -> ssize , ( ulong ) obj ) ;\n return ( char * ) obj ;\n }", "hash": 6600620671673714486, "project": "debian", "size": 13, "target": 1, "idx": 21479}
{"code": "static byte * i_alloc_byte_array ( gs_memory_t * mem , uint num_elements , uint elt_size , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n obj_header_t * obj ;\n # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;\n # endif obj = alloc_obj ( imem , ( ulong ) num_elements * elt_size , & st_bytes , ALLOC_DIRECT , cname ) ;\n if_debug6m ( 'A' , mem , \"[a%d:+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , ( ulong ) num_elements * elt_size , num_elements , elt_size , ( ulong ) obj ) ;\n return ( byte * ) obj ;\n }", "hash": 6600620671673714486, "project": "debian", "size": 8, "target": 1, "idx": 21480}
{"code": "static guint32 dissect_minipacket ( tvbuff_t * tvb , guint32 offset , guint16 scallno , packet_info * pinfo , proto_tree * iax2_tree , proto_tree * main_tree ) {\n guint32 ts ;\n iax_packet_data * iax_packet ;\n proto_item * item ;\n ts = tvb_get_ntohs ( tvb , offset ) ;\n iax_packet = iax2_get_packet_data_for_minipacket ( pinfo , scallno , FALSE ) ;\n if ( iax2_tree ) {\n if ( iax_packet -> call_data ) {\n item = proto_tree_add_uint ( iax2_tree , hf_iax2_callno , tvb , 0 , 4 , iax_packet -> call_data -> forward_circuit_ids [ 0 ] ) ;\n PROTO_ITEM_SET_GENERATED ( item ) ;\n }\n proto_tree_add_uint ( iax2_tree , hf_iax2_minits , tvb , offset , 2 , ts ) ;\n iax2_add_ts_fields ( pinfo , iax2_tree , iax_packet , ( guint16 ) ts ) ;\n }\n else {\n iax2_add_ts_fields ( pinfo , iax2_tree , iax_packet , ( guint16 ) ts ) ;\n }\n offset += 2 ;\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"Mini packet, source call# %d, timestamp %ums\" , scallno , ts ) ;\n dissect_payload ( tvb , offset , pinfo , iax2_tree , main_tree , ts , FALSE , iax_packet ) ;\n iax_packet -> first_time = FALSE ;\n return offset ;\n }", "hash": -4055702019813176658, "project": "debian", "size": 23, "target": 1, "idx": 21490}
{"code": "void bn_mul_comba8 ( BN_ULONG * r , BN_ULONG * a , BN_ULONG * b ) {\n BN_ULONG t1 , t2 ;\n BN_ULONG c1 , c2 , c3 ;\n c1 = 0 ;\n c2 = 0 ;\n c3 = 0 ;\n mul_add_c ( a [ 0 ] , b [ 0 ] , c1 , c2 , c3 ) ;\n r [ 0 ] = c1 ;\n c1 = 0 ;\n mul_add_c ( a [ 0 ] , b [ 1 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 1 ] , b [ 0 ] , c2 , c3 , c1 ) ;\n r [ 1 ] = c2 ;\n c2 = 0 ;\n mul_add_c ( a [ 2 ] , b [ 0 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 1 ] , b [ 1 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 0 ] , b [ 2 ] , c3 , c1 , c2 ) ;\n r [ 2 ] = c3 ;\n c3 = 0 ;\n mul_add_c ( a [ 0 ] , b [ 3 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 1 ] , b [ 2 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 2 ] , b [ 1 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 3 ] , b [ 0 ] , c1 , c2 , c3 ) ;\n r [ 3 ] = c1 ;\n c1 = 0 ;\n mul_add_c ( a [ 4 ] , b [ 0 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 3 ] , b [ 1 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 2 ] , b [ 2 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 1 ] , b [ 3 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 0 ] , b [ 4 ] , c2 , c3 , c1 ) ;\n r [ 4 ] = c2 ;\n c2 = 0 ;\n mul_add_c ( a [ 0 ] , b [ 5 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 1 ] , b [ 4 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 2 ] , b [ 3 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 3 ] , b [ 2 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 4 ] , b [ 1 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 5 ] , b [ 0 ] , c3 , c1 , c2 ) ;\n r [ 5 ] = c3 ;\n c3 = 0 ;\n mul_add_c ( a [ 6 ] , b [ 0 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 5 ] , b [ 1 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 4 ] , b [ 2 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 3 ] , b [ 3 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 2 ] , b [ 4 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 1 ] , b [ 5 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 0 ] , b [ 6 ] , c1 , c2 , c3 ) ;\n r [ 6 ] = c1 ;\n c1 = 0 ;\n mul_add_c ( a [ 0 ] , b [ 7 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 1 ] , b [ 6 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 2 ] , b [ 5 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 3 ] , b [ 4 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 4 ] , b [ 3 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 5 ] , b [ 2 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 6 ] , b [ 1 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 7 ] , b [ 0 ] , c2 , c3 , c1 ) ;\n r [ 7 ] = c2 ;\n c2 = 0 ;\n mul_add_c ( a [ 7 ] , b [ 1 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 6 ] , b [ 2 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 5 ] , b [ 3 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 4 ] , b [ 4 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 3 ] , b [ 5 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 2 ] , b [ 6 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 1 ] , b [ 7 ] , c3 , c1 , c2 ) ;\n r [ 8 ] = c3 ;\n c3 = 0 ;\n mul_add_c ( a [ 2 ] , b [ 7 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 3 ] , b [ 6 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 4 ] , b [ 5 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 5 ] , b [ 4 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 6 ] , b [ 3 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 7 ] , b [ 2 ] , c1 , c2 , c3 ) ;\n r [ 9 ] = c1 ;\n c1 = 0 ;\n mul_add_c ( a [ 7 ] , b [ 3 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 6 ] , b [ 4 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 5 ] , b [ 5 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 4 ] , b [ 6 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 3 ] , b [ 7 ] , c2 , c3 , c1 ) ;\n r [ 10 ] = c2 ;\n c2 = 0 ;\n mul_add_c ( a [ 4 ] , b [ 7 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 5 ] , b [ 6 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 6 ] , b [ 5 ] , c3 , c1 , c2 ) ;\n mul_add_c ( a [ 7 ] , b [ 4 ] , c3 , c1 , c2 ) ;\n r [ 11 ] = c3 ;\n c3 = 0 ;\n mul_add_c ( a [ 7 ] , b [ 5 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 6 ] , b [ 6 ] , c1 , c2 , c3 ) ;\n mul_add_c ( a [ 5 ] , b [ 7 ] , c1 , c2 , c3 ) ;\n r [ 12 ] = c1 ;\n c1 = 0 ;\n mul_add_c ( a [ 6 ] , b [ 7 ] , c2 , c3 , c1 ) ;\n mul_add_c ( a [ 7 ] , b [ 6 ] , c2 , c3 , c1 ) ;\n r [ 13 ] = c2 ;\n c2 = 0 ;\n mul_add_c ( a [ 7 ] , b [ 7 ] , c3 , c1 , c2 ) ;\n r [ 14 ] = c3 ;\n r [ 15 ] = c1 ;\n }", "hash": 3192165150896245305, "project": "debian", "size": 101, "target": 1, "idx": 21501}
{"code": "static void apply_frame_size ( VP9_COMMON * cm , int width , int height ) {\n if ( cm -> width != width || cm -> height != height ) {\n if ( width > cm -> width || height > cm -> height ) {\n if ( vp9_resize_frame_buffers ( cm , width , height ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , \"Failed to allocate frame buffers\" ) ;\n }\n cm -> width = width ;\n cm -> height = height ;\n vp9_update_frame_size ( cm ) ;\n }\n if ( vp9_realloc_frame_buffer ( get_frame_new_buffer ( cm ) , cm -> width , cm -> height , cm -> subsampling_x , cm -> subsampling_y , VP9_DEC_BORDER_IN_PIXELS , & cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer , cm -> get_fb_cb , cm -> cb_priv ) ) {\n vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , \"Failed to allocate frame buffer\" ) ;\n }\n }", "hash": 252275190935145023, "project": "debian", "size": 13, "target": 1, "idx": 21508}
{"code": "END_TEST START_TEST ( test_find_available_user ) {\n in_addr_t ip ;\n int i ;\n ip = inet_addr ( \"127.0.0.1\" ) ;\n init_users ( ip , 27 ) ;\n for ( i = 0 ;\n i < USERS ;\n i ++ ) {\n fail_unless ( find_available_user ( ) == i ) ;\n }\n for ( i = 0 ;\n i < USERS ;\n i ++ ) {\n fail_unless ( find_available_user ( ) == - 1 ) ;\n }\n users [ 3 ] . active = 0 ;\n fail_unless ( find_available_user ( ) == 3 ) ;\n fail_unless ( find_available_user ( ) == - 1 ) ;\n users [ 3 ] . last_pkt = 55 ;\n fail_unless ( find_available_user ( ) == 3 ) ;\n fail_unless ( find_available_user ( ) == - 1 ) ;\n }", "hash": -303065274055369342, "project": "debian", "size": 22, "target": 1, "idx": 21517}
{"code": "static const char * cmd_hash_engine ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n if ( dcfg == NULL ) return NULL ;\n if ( strcasecmp ( p1 , \"on\" ) == 0 ) {\n dcfg -> hash_is_enabled = HASH_ENABLED ;\n dcfg -> hash_enforcement = HASH_ENABLED ;\n }\n else if ( strcasecmp ( p1 , \"off\" ) == 0 ) {\n dcfg -> hash_is_enabled = HASH_DISABLED ;\n dcfg -> hash_enforcement = HASH_DISABLED ;\n }\n else return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid value for SecRuleEngine: %s\" , p1 ) ;\n return NULL ;\n }", "hash": -5493081488206619677, "project": "debian", "size": 14, "target": 1, "idx": 21537}
{"code": "static int cert_status_cb ( SSL * s , void * arg ) {\n tlsextstatusctx * srctx = arg ;\n BIO * err = srctx -> err ;\n char * host , * port , * path ;\n int use_ssl ;\n unsigned char * rspder = NULL ;\n int rspderlen ;\n STACK_OF ( OPENSSL_STRING ) * aia = NULL ;\n X509 * x = NULL ;\n X509_STORE_CTX inctx ;\n X509_OBJECT obj ;\n OCSP_REQUEST * req = NULL ;\n OCSP_RESPONSE * resp = NULL ;\n OCSP_CERTID * id = NULL ;\n STACK_OF ( X509_EXTENSION ) * exts ;\n int ret = SSL_TLSEXT_ERR_NOACK ;\n int i ;\n # if 0 STACK_OF ( OCSP_RESPID ) * ids ;\n SSL_get_tlsext_status_ids ( s , & ids ) ;\n BIO_printf ( err , \"cert_status: received %d ids\\n\" , sk_OCSP_RESPID_num ( ids ) ) ;\n # endif if ( srctx -> verbose ) BIO_puts ( err , \"cert_status: callback called\\n\" ) ;\n x = SSL_get_certificate ( s ) ;\n aia = X509_get1_ocsp ( x ) ;\n if ( aia ) {\n if ( ! OCSP_parse_url ( sk_OPENSSL_STRING_value ( aia , 0 ) , & host , & port , & path , & use_ssl ) ) {\n BIO_puts ( err , \"cert_status: can't parse AIA URL\\n\" ) ;\n goto err ;\n }\n if ( srctx -> verbose ) BIO_printf ( err , \"cert_status: AIA URL: %s\\n\" , sk_OPENSSL_STRING_value ( aia , 0 ) ) ;\n }\n else {\n if ( ! srctx -> host ) {\n BIO_puts ( srctx -> err , \"cert_status: no AIA and no default responder URL\\n\" ) ;\n goto done ;\n }\n host = srctx -> host ;\n path = srctx -> path ;\n port = srctx -> port ;\n use_ssl = srctx -> use_ssl ;\n }\n if ( ! X509_STORE_CTX_init ( & inctx , SSL_CTX_get_cert_store ( SSL_get_SSL_CTX ( s ) ) , NULL , NULL ) ) goto err ;\n if ( X509_STORE_get_by_subject ( & inctx , X509_LU_X509 , X509_get_issuer_name ( x ) , & obj ) <= 0 ) {\n BIO_puts ( err , \"cert_status: Can't retrieve issuer certificate.\\n\" ) ;\n X509_STORE_CTX_cleanup ( & inctx ) ;\n goto done ;\n }\n req = OCSP_REQUEST_new ( ) ;\n if ( ! req ) goto err ;\n id = OCSP_cert_to_id ( NULL , x , obj . data . x509 ) ;\n X509_free ( obj . data . x509 ) ;\n X509_STORE_CTX_cleanup ( & inctx ) ;\n if ( ! id ) goto err ;\n if ( ! OCSP_request_add0_id ( req , id ) ) goto err ;\n id = NULL ;\n SSL_get_tlsext_status_exts ( s , & exts ) ;\n for ( i = 0 ;\n i < sk_X509_EXTENSION_num ( exts ) ;\n i ++ ) {\n X509_EXTENSION * ext = sk_X509_EXTENSION_value ( exts , i ) ;\n if ( ! OCSP_REQUEST_add_ext ( req , ext , - 1 ) ) goto err ;\n }\n resp = process_responder ( err , req , host , path , port , use_ssl , NULL , srctx -> timeout ) ;\n if ( ! resp ) {\n BIO_puts ( err , \"cert_status: error querying responder\\n\" ) ;\n goto done ;\n }\n rspderlen = i2d_OCSP_RESPONSE ( resp , & rspder ) ;\n if ( rspderlen <= 0 ) goto err ;\n SSL_set_tlsext_status_ocsp_resp ( s , rspder , rspderlen ) ;\n if ( srctx -> verbose ) {\n BIO_puts ( err , \"cert_status: ocsp response sent:\\n\" ) ;\n OCSP_RESPONSE_print ( err , resp , 2 ) ;\n }\n ret = SSL_TLSEXT_ERR_OK ;\n done : if ( ret != SSL_TLSEXT_ERR_OK ) ERR_print_errors ( err ) ;\n if ( aia ) {\n OPENSSL_free ( host ) ;\n OPENSSL_free ( path ) ;\n OPENSSL_free ( port ) ;\n X509_email_free ( aia ) ;\n }\n if ( id ) OCSP_CERTID_free ( id ) ;\n if ( req ) OCSP_REQUEST_free ( req ) ;\n if ( resp ) OCSP_RESPONSE_free ( resp ) ;\n return ret ;\n err : ret = SSL_TLSEXT_ERR_ALERT_FATAL ;\n goto done ;\n }\n # ifndef OPENSSL_NO_NEXTPROTONEG typedef struct tlsextnextprotoctx_st {\n unsigned char * data ;\n unsigned int len ;\n }\n tlsextnextprotoctx ;\n static int next_proto_cb ( SSL * s , const unsigned char * * data , unsigned int * len , void * arg ) {\n tlsextnextprotoctx * next_proto = arg ;\n * data = next_proto -> data ;\n * len = next_proto -> len ;\n return SSL_TLSEXT_ERR_OK ;\n }\n # endif # endif int MAIN ( int , char * * ) ;\n # ifndef OPENSSL_NO_JPAKE static char * jpake_secret = NULL ;\n # endif # ifndef OPENSSL_NO_SRP static srpsrvparm srp_callback_parm ;\n # endif # ifndef OPENSSL_NO_SRTP static char * srtp_profiles = NULL ;\n # endif int MAIN ( int argc , char * argv [ ] ) {\n X509_VERIFY_PARAM * vpm = NULL ;\n int badarg = 0 ;\n short port = PORT ;\n char * CApath = NULL , * CAfile = NULL ;\n unsigned char * context = NULL ;\n char * dhfile = NULL ;\n # ifndef OPENSSL_NO_ECDH char * named_curve = NULL ;\n # endif int badop = 0 , bugs = 0 ;\n int ret = 1 ;\n int off = 0 ;\n int no_tmp_rsa = 0 , no_dhe = 0 , nocert = 0 ;\n # ifndef OPENSSL_NO_ECDH int no_ecdhe = 0 ;\n # endif int state = 0 ;\n const SSL_METHOD * meth = NULL ;\n int socket_type = SOCK_STREAM ;\n ENGINE * e = NULL ;\n char * inrand = NULL ;\n int s_cert_format = FORMAT_PEM , s_key_format = FORMAT_PEM ;\n char * passarg = NULL , * pass = NULL ;\n char * dpassarg = NULL , * dpass = NULL ;\n int s_dcert_format = FORMAT_PEM , s_dkey_format = FORMAT_PEM ;\n X509 * s_cert = NULL , * s_dcert = NULL ;\n EVP_PKEY * s_key = NULL , * s_dkey = NULL ;\n int no_cache = 0 ;\n # ifndef OPENSSL_NO_TLSEXT EVP_PKEY * s_key2 = NULL ;\n X509 * s_cert2 = NULL ;\n tlsextctx tlsextcbp = {\n NULL , NULL , SSL_TLSEXT_ERR_ALERT_WARNING }\n ;\n # ifndef OPENSSL_NO_NEXTPROTONEG const char * next_proto_neg_in = NULL ;\n tlsextnextprotoctx next_proto ;\n # endif # endif # ifndef OPENSSL_NO_PSK static char * psk_identity_hint = NULL ;\n # endif # ifndef OPENSSL_NO_SRP char * srpuserseed = NULL ;\n char * srp_verifier_file = NULL ;\n # endif meth = SSLv23_server_method ( ) ;\n local_argc = argc ;\n local_argv = argv ;\n apps_startup ( ) ;\n # ifdef MONOLITH s_server_init ( ) ;\n # endif if ( bio_err == NULL ) bio_err = BIO_new_fp ( stderr , BIO_NOCLOSE ) ;\n if ( ! load_config ( bio_err , NULL ) ) goto end ;\n verify_depth = 0 ;\n # ifdef FIONBIO s_nbio = 0 ;\n # endif s_nbio_test = 0 ;\n argc -- ;\n argv ++ ;\n while ( argc >= 1 ) {\n if ( ( strcmp ( * argv , \"-port\" ) == 0 ) || ( strcmp ( * argv , \"-accept\" ) == 0 ) ) {\n if ( -- argc < 1 ) goto bad ;\n if ( ! extract_port ( * ( ++ argv ) , & port ) ) goto bad ;\n }\n else if ( strcmp ( * argv , \"-verify\" ) == 0 ) {\n s_server_verify = SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE ;\n if ( -- argc < 1 ) goto bad ;\n verify_depth = atoi ( * ( ++ argv ) ) ;\n BIO_printf ( bio_err , \"verify depth is %d\\n\" , verify_depth ) ;\n }\n else if ( strcmp ( * argv , \"-Verify\" ) == 0 ) {\n s_server_verify = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT | SSL_VERIFY_CLIENT_ONCE ;\n if ( -- argc < 1 ) goto bad ;\n verify_depth = atoi ( * ( ++ argv ) ) ;\n BIO_printf ( bio_err , \"verify depth is %d, must return a certificate\\n\" , verify_depth ) ;\n }\n else if ( strcmp ( * argv , \"-context\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n context = ( unsigned char * ) * ( ++ argv ) ;\n }\n else if ( strcmp ( * argv , \"-cert\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n s_cert_file = * ( ++ argv ) ;\n }\n else if ( strcmp ( * argv , \"-certform\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n s_cert_format = str2fmt ( * ( ++ argv ) ) ;\n }\n else if ( strcmp ( * argv , \"-key\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n s_key_file = * ( ++ argv ) ;\n }\n else if ( strcmp ( * argv , \"-keyform\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n s_key_format = str2fmt ( * ( ++ argv ) ) ;\n }\n else if ( strcmp ( * argv , \"-pass\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n passarg = * ( ++ argv ) ;\n }\n else if ( strcmp ( * argv , \"-dhparam\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n dhfile = * ( ++ argv ) ;\n }\n # ifndef OPENSSL_NO_ECDH else if ( strcmp ( * argv , \"-named_curve\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n named_curve = * ( ++ argv ) ;\n }\n # endif else if ( strcmp ( * argv , \"-dcertform\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n s_dcert_format = str2fmt ( * ( ++ argv ) ) ;\n }\n else if ( strcmp ( * argv , \"-dcert\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n s_dcert_file = * ( ++ argv ) ;\n }\n else if ( strcmp ( * argv , \"-dkeyform\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n s_dkey_format = str2fmt ( * ( ++ argv ) ) ;\n }\n else if ( strcmp ( * argv , \"-dpass\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n dpassarg = * ( ++ argv ) ;\n }\n else if ( strcmp ( * argv , \"-dkey\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n s_dkey_file = * ( ++ argv ) ;\n }\n else if ( strcmp ( * argv , \"-nocert\" ) == 0 ) {\n nocert = 1 ;\n }\n else if ( strcmp ( * argv , \"-CApath\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n CApath = * ( ++ argv ) ;\n }\n else if ( strcmp ( * argv , \"-no_cache\" ) == 0 ) no_cache = 1 ;\n else if ( args_verify ( & argv , & argc , & badarg , bio_err , & vpm ) ) {\n if ( badarg ) goto bad ;\n continue ;\n }\n else if ( strcmp ( * argv , \"-verify_return_error\" ) == 0 ) verify_return_error = 1 ;\n else if ( strcmp ( * argv , \"-serverpref\" ) == 0 ) {\n off |= SSL_OP_CIPHER_SERVER_PREFERENCE ;\n }\n else if ( strcmp ( * argv , \"-legacy_renegotiation\" ) == 0 ) off |= SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ;\n else if ( strcmp ( * argv , \"-cipher\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n cipher = * ( ++ argv ) ;\n }\n else if ( strcmp ( * argv , \"-CAfile\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n CAfile = * ( ++ argv ) ;\n }\n # ifdef FIONBIO else if ( strcmp ( * argv , \"-nbio\" ) == 0 ) {\n s_nbio = 1 ;\n }\n # endif else if ( strcmp ( * argv , \"-nbio_test\" ) == 0 ) {\n # ifdef FIONBIO s_nbio = 1 ;\n # endif s_nbio_test = 1 ;\n }\n else if ( strcmp ( * argv , \"-debug\" ) == 0 ) {\n s_debug = 1 ;\n }\n # ifndef OPENSSL_NO_TLSEXT else if ( strcmp ( * argv , \"-tlsextdebug\" ) == 0 ) s_tlsextdebug = 1 ;\n else if ( strcmp ( * argv , \"-status\" ) == 0 ) s_tlsextstatus = 1 ;\n else if ( strcmp ( * argv , \"-status_verbose\" ) == 0 ) {\n s_tlsextstatus = 1 ;\n tlscstatp . verbose = 1 ;\n }\n else if ( ! strcmp ( * argv , \"-status_timeout\" ) ) {\n s_tlsextstatus = 1 ;\n if ( -- argc < 1 ) goto bad ;\n tlscstatp . timeout = atoi ( * ( ++ argv ) ) ;\n }\n else if ( ! strcmp ( * argv , \"-status_url\" ) ) {\n s_tlsextstatus = 1 ;\n if ( -- argc < 1 ) goto bad ;\n if ( ! OCSP_parse_url ( * ( ++ argv ) , & tlscstatp . host , & tlscstatp . port , & tlscstatp . path , & tlscstatp . use_ssl ) ) {\n BIO_printf ( bio_err , \"Error parsing URL\\n\" ) ;\n goto bad ;\n }\n }\n # endif else if ( strcmp ( * argv , \"-msg\" ) == 0 ) {\n s_msg = 1 ;\n }\n else if ( strcmp ( * argv , \"-hack\" ) == 0 ) {\n hack = 1 ;\n }\n else if ( strcmp ( * argv , \"-state\" ) == 0 ) {\n state = 1 ;\n }\n else if ( strcmp ( * argv , \"-crlf\" ) == 0 ) {\n s_crlf = 1 ;\n }\n else if ( strcmp ( * argv , \"-quiet\" ) == 0 ) {\n s_quiet = 1 ;\n }\n else if ( strcmp ( * argv , \"-bugs\" ) == 0 ) {\n bugs = 1 ;\n }\n else if ( strcmp ( * argv , \"-no_tmp_rsa\" ) == 0 ) {\n no_tmp_rsa = 1 ;\n }\n else if ( strcmp ( * argv , \"-no_dhe\" ) == 0 ) {\n no_dhe = 1 ;\n }\n # ifndef OPENSSL_NO_ECDH else if ( strcmp ( * argv , \"-no_ecdhe\" ) == 0 ) {\n no_ecdhe = 1 ;\n }\n # endif # ifndef OPENSSL_NO_PSK else if ( strcmp ( * argv , \"-psk_hint\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n psk_identity_hint = * ( ++ argv ) ;\n }\n else if ( strcmp ( * argv , \"-psk\" ) == 0 ) {\n size_t i ;\n if ( -- argc < 1 ) goto bad ;\n psk_key = * ( ++ argv ) ;\n for ( i = 0 ;\n i < strlen ( psk_key ) ;\n i ++ ) {\n if ( isxdigit ( ( unsigned char ) psk_key [ i ] ) ) continue ;\n BIO_printf ( bio_err , \"Not a hex number '%s'\\n\" , * argv ) ;\n goto bad ;\n }\n }\n # endif # ifndef OPENSSL_NO_SRP else if ( strcmp ( * argv , \"-srpvfile\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n srp_verifier_file = * ( ++ argv ) ;\n meth = TLSv1_server_method ( ) ;\n }\n else if ( strcmp ( * argv , \"-srpuserseed\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n srpuserseed = * ( ++ argv ) ;\n meth = TLSv1_server_method ( ) ;\n }\n # endif else if ( strcmp ( * argv , \"-www\" ) == 0 ) {\n www = 1 ;\n }\n else if ( strcmp ( * argv , \"-WWW\" ) == 0 ) {\n www = 2 ;\n }\n else if ( strcmp ( * argv , \"-HTTP\" ) == 0 ) {\n www = 3 ;\n }\n else if ( strcmp ( * argv , \"-no_ssl2\" ) == 0 ) {\n off |= SSL_OP_NO_SSLv2 ;\n }\n else if ( strcmp ( * argv , \"-no_ssl3\" ) == 0 ) {\n off |= SSL_OP_NO_SSLv3 ;\n }\n else if ( strcmp ( * argv , \"-no_tls1\" ) == 0 ) {\n off |= SSL_OP_NO_TLSv1 ;\n }\n else if ( strcmp ( * argv , \"-no_tls1_1\" ) == 0 ) {\n off |= SSL_OP_NO_TLSv1_1 ;\n }\n else if ( strcmp ( * argv , \"-no_tls1_2\" ) == 0 ) {\n off |= SSL_OP_NO_TLSv1_2 ;\n }\n else if ( strcmp ( * argv , \"-no_comp\" ) == 0 ) {\n off |= SSL_OP_NO_COMPRESSION ;\n }\n # ifndef OPENSSL_NO_TLSEXT else if ( strcmp ( * argv , \"-no_ticket\" ) == 0 ) {\n off |= SSL_OP_NO_TICKET ;\n }\n # endif # ifndef OPENSSL_NO_SSL2 else if ( strcmp ( * argv , \"-ssl2\" ) == 0 ) {\n meth = SSLv2_server_method ( ) ;\n }\n # endif # ifndef OPENSSL_NO_SSL3_METHOD else if ( strcmp ( * argv , \"-ssl3\" ) == 0 ) {\n meth = SSLv3_server_method ( ) ;\n }\n # endif # ifndef OPENSSL_NO_TLS1 else if ( strcmp ( * argv , \"-tls1\" ) == 0 ) {\n meth = TLSv1_server_method ( ) ;\n }\n else if ( strcmp ( * argv , \"-tls1_1\" ) == 0 ) {\n meth = TLSv1_1_server_method ( ) ;\n }\n else if ( strcmp ( * argv , \"-tls1_2\" ) == 0 ) {\n meth = TLSv1_2_server_method ( ) ;\n }\n # endif # ifndef OPENSSL_NO_DTLS1 else if ( strcmp ( * argv , \"-dtls1\" ) == 0 ) {\n meth = DTLSv1_server_method ( ) ;\n socket_type = SOCK_DGRAM ;\n }\n else if ( strcmp ( * argv , \"-timeout\" ) == 0 ) enable_timeouts = 1 ;\n else if ( strcmp ( * argv , \"-mtu\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n socket_mtu = atol ( * ( ++ argv ) ) ;\n }\n else if ( strcmp ( * argv , \"-chain\" ) == 0 ) cert_chain = 1 ;\n # endif else if ( strcmp ( * argv , \"-id_prefix\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n session_id_prefix = * ( ++ argv ) ;\n }\n # ifndef OPENSSL_NO_ENGINE else if ( strcmp ( * argv , \"-engine\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n engine_id = * ( ++ argv ) ;\n }\n # endif else if ( strcmp ( * argv , \"-rand\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n inrand = * ( ++ argv ) ;\n }\n # ifndef OPENSSL_NO_TLSEXT else if ( strcmp ( * argv , \"-servername\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n tlsextcbp . servername = * ( ++ argv ) ;\n }\n else if ( strcmp ( * argv , \"-servername_fatal\" ) == 0 ) {\n tlsextcbp . extension_error = SSL_TLSEXT_ERR_ALERT_FATAL ;\n }\n else if ( strcmp ( * argv , \"-cert2\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n s_cert_file2 = * ( ++ argv ) ;\n }\n else if ( strcmp ( * argv , \"-key2\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n s_key_file2 = * ( ++ argv ) ;\n }\n # ifndef OPENSSL_NO_NEXTPROTONEG else if ( strcmp ( * argv , \"-nextprotoneg\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n next_proto_neg_in = * ( ++ argv ) ;\n }\n # endif # endif # if ! defined ( OPENSSL_NO_JPAKE ) && ! defined ( OPENSSL_NO_PSK ) else if ( strcmp ( * argv , \"-jpake\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n jpake_secret = * ( ++ argv ) ;\n }\n # endif # ifndef OPENSSL_NO_SRTP else if ( strcmp ( * argv , \"-use_srtp\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n srtp_profiles = * ( ++ argv ) ;\n }\n # endif else if ( strcmp ( * argv , \"-keymatexport\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n keymatexportlabel = * ( ++ argv ) ;\n }\n else if ( strcmp ( * argv , \"-keymatexportlen\" ) == 0 ) {\n if ( -- argc < 1 ) goto bad ;\n keymatexportlen = atoi ( * ( ++ argv ) ) ;\n if ( keymatexportlen == 0 ) goto bad ;\n }\n else {\n BIO_printf ( bio_err , \"unknown option %s\\n\" , * argv ) ;\n badop = 1 ;\n break ;\n }\n argc -- ;\n argv ++ ;\n }\n if ( badop ) {\n bad : sv_usage ( ) ;\n goto end ;\n }\n # ifndef OPENSSL_NO_DTLS1 if ( www && socket_type == SOCK_DGRAM ) {\n BIO_printf ( bio_err , \"Can't use -HTTP, -www or -WWW with DTLS\\n\" ) ;\n goto end ;\n }\n # endif # if ! defined ( OPENSSL_NO_JPAKE ) && ! defined ( OPENSSL_NO_PSK ) if ( jpake_secret ) {\n if ( psk_key ) {\n BIO_printf ( bio_err , \"Can't use JPAKE and PSK together\\n\" ) ;\n goto end ;\n }\n psk_identity = \"JPAKE\" ;\n if ( cipher ) {\n BIO_printf ( bio_err , \"JPAKE sets cipher to PSK\\n\" ) ;\n goto end ;\n }\n cipher = \"PSK\" ;\n }\n # endif SSL_load_error_strings ( ) ;\n OpenSSL_add_ssl_algorithms ( ) ;\n # ifndef OPENSSL_NO_ENGINE e = setup_engine ( bio_err , engine_id , 1 ) ;\n # endif if ( ! app_passwd ( bio_err , passarg , dpassarg , & pass , & dpass ) ) {\n BIO_printf ( bio_err , \"Error getting password\\n\" ) ;\n goto end ;\n }\n if ( s_key_file == NULL ) s_key_file = s_cert_file ;\n # ifndef OPENSSL_NO_TLSEXT if ( s_key_file2 == NULL ) s_key_file2 = s_cert_file2 ;\n # endif if ( nocert == 0 ) {\n s_key = load_key ( bio_err , s_key_file , s_key_format , 0 , pass , e , \"server certificate private key file\" ) ;\n if ( ! s_key ) {\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n s_cert = load_cert ( bio_err , s_cert_file , s_cert_format , NULL , e , \"server certificate file\" ) ;\n if ( ! s_cert ) {\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n # ifndef OPENSSL_NO_TLSEXT if ( tlsextcbp . servername ) {\n s_key2 = load_key ( bio_err , s_key_file2 , s_key_format , 0 , pass , e , \"second server certificate private key file\" ) ;\n if ( ! s_key2 ) {\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n s_cert2 = load_cert ( bio_err , s_cert_file2 , s_cert_format , NULL , e , \"second server certificate file\" ) ;\n if ( ! s_cert2 ) {\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n }\n # endif }\n # if ! defined ( OPENSSL_NO_TLSEXT ) && ! defined ( OPENSSL_NO_NEXTPROTONEG ) if ( next_proto_neg_in ) {\n unsigned short len ;\n next_proto . data = next_protos_parse ( & len , next_proto_neg_in ) ;\n if ( next_proto . data == NULL ) goto end ;\n next_proto . len = len ;\n }\n else {\n next_proto . data = NULL ;\n }\n # endif if ( s_dcert_file ) {\n if ( s_dkey_file == NULL ) s_dkey_file = s_dcert_file ;\n s_dkey = load_key ( bio_err , s_dkey_file , s_dkey_format , 0 , dpass , e , \"second certificate private key file\" ) ;\n if ( ! s_dkey ) {\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n s_dcert = load_cert ( bio_err , s_dcert_file , s_dcert_format , NULL , e , \"second server certificate file\" ) ;\n if ( ! s_dcert ) {\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n }\n if ( ! app_RAND_load_file ( NULL , bio_err , 1 ) && inrand == NULL && ! RAND_status ( ) ) {\n BIO_printf ( bio_err , \"warning, not much extra random data, consider using the -rand option\\n\" ) ;\n }\n if ( inrand != NULL ) BIO_printf ( bio_err , \"%ld semi-random bytes loaded\\n\" , app_RAND_load_files ( inrand ) ) ;\n if ( bio_s_out == NULL ) {\n if ( s_quiet && ! s_debug && ! s_msg ) {\n bio_s_out = BIO_new ( BIO_s_null ( ) ) ;\n }\n else {\n if ( bio_s_out == NULL ) bio_s_out = BIO_new_fp ( stdout , BIO_NOCLOSE ) ;\n }\n }\n # if ! defined ( OPENSSL_NO_RSA ) || ! defined ( OPENSSL_NO_DSA ) || ! defined ( OPENSSL_NO_ECDSA ) if ( nocert ) # endif {\n s_cert_file = NULL ;\n s_key_file = NULL ;\n s_dcert_file = NULL ;\n s_dkey_file = NULL ;\n # ifndef OPENSSL_NO_TLSEXT s_cert_file2 = NULL ;\n s_key_file2 = NULL ;\n # endif }\n ctx = SSL_CTX_new ( meth ) ;\n if ( ctx == NULL ) {\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n if ( session_id_prefix ) {\n if ( strlen ( session_id_prefix ) >= 32 ) BIO_printf ( bio_err , \"warning: id_prefix is too long, only one new session will be possible\\n\" ) ;\n else if ( strlen ( session_id_prefix ) >= 16 ) BIO_printf ( bio_err , \"warning: id_prefix is too long if you use SSLv2\\n\" ) ;\n if ( ! SSL_CTX_set_generate_session_id ( ctx , generate_session_id ) ) {\n BIO_printf ( bio_err , \"error setting 'id_prefix'\\n\" ) ;\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n BIO_printf ( bio_err , \"id_prefix '%s' set.\\n\" , session_id_prefix ) ;\n }\n SSL_CTX_set_quiet_shutdown ( ctx , 1 ) ;\n if ( bugs ) SSL_CTX_set_options ( ctx , SSL_OP_ALL ) ;\n if ( hack ) SSL_CTX_set_options ( ctx , SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG ) ;\n SSL_CTX_set_options ( ctx , off ) ;\n if ( state ) SSL_CTX_set_info_callback ( ctx , apps_ssl_info_callback ) ;\n if ( no_cache ) SSL_CTX_set_session_cache_mode ( ctx , SSL_SESS_CACHE_OFF ) ;\n else SSL_CTX_sess_set_cache_size ( ctx , 128 ) ;\n # ifndef OPENSSL_NO_SRTP if ( srtp_profiles != NULL ) SSL_CTX_set_tlsext_use_srtp ( ctx , srtp_profiles ) ;\n # endif # if 0 if ( cipher == NULL ) cipher = getenv ( \"SSL_CIPHER\" ) ;\n # endif # if 0 if ( s_cert_file == NULL ) {\n BIO_printf ( bio_err , \"You must specify a certificate file for the server to use\\n\" ) ;\n goto end ;\n }\n # endif if ( ( ! SSL_CTX_load_verify_locations ( ctx , CAfile , CApath ) ) || ( ! SSL_CTX_set_default_verify_paths ( ctx ) ) ) {\n ERR_print_errors ( bio_err ) ;\n }\n if ( vpm ) SSL_CTX_set1_param ( ctx , vpm ) ;\n # ifndef OPENSSL_NO_TLSEXT if ( s_cert2 ) {\n ctx2 = SSL_CTX_new ( meth ) ;\n if ( ctx2 == NULL ) {\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n }\n if ( ctx2 ) {\n BIO_printf ( bio_s_out , \"Setting secondary ctx parameters\\n\" ) ;\n if ( session_id_prefix ) {\n if ( strlen ( session_id_prefix ) >= 32 ) BIO_printf ( bio_err , \"warning: id_prefix is too long, only one new session will be possible\\n\" ) ;\n else if ( strlen ( session_id_prefix ) >= 16 ) BIO_printf ( bio_err , \"warning: id_prefix is too long if you use SSLv2\\n\" ) ;\n if ( ! SSL_CTX_set_generate_session_id ( ctx2 , generate_session_id ) ) {\n BIO_printf ( bio_err , \"error setting 'id_prefix'\\n\" ) ;\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n BIO_printf ( bio_err , \"id_prefix '%s' set.\\n\" , session_id_prefix ) ;\n }\n SSL_CTX_set_quiet_shutdown ( ctx2 , 1 ) ;\n if ( bugs ) SSL_CTX_set_options ( ctx2 , SSL_OP_ALL ) ;\n if ( hack ) SSL_CTX_set_options ( ctx2 , SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG ) ;\n SSL_CTX_set_options ( ctx2 , off ) ;\n if ( state ) SSL_CTX_set_info_callback ( ctx2 , apps_ssl_info_callback ) ;\n if ( no_cache ) SSL_CTX_set_session_cache_mode ( ctx2 , SSL_SESS_CACHE_OFF ) ;\n else SSL_CTX_sess_set_cache_size ( ctx2 , 128 ) ;\n if ( ( ! SSL_CTX_load_verify_locations ( ctx2 , CAfile , CApath ) ) || ( ! SSL_CTX_set_default_verify_paths ( ctx2 ) ) ) {\n ERR_print_errors ( bio_err ) ;\n }\n if ( vpm ) SSL_CTX_set1_param ( ctx2 , vpm ) ;\n }\n # ifndef OPENSSL_NO_NEXTPROTONEG if ( next_proto . data ) SSL_CTX_set_next_protos_advertised_cb ( ctx , next_proto_cb , & next_proto ) ;\n # endif # endif # ifndef OPENSSL_NO_DH if ( ! no_dhe ) {\n DH * dh = NULL ;\n if ( dhfile ) dh = load_dh_param ( dhfile ) ;\n else if ( s_cert_file ) dh = load_dh_param ( s_cert_file ) ;\n if ( dh != NULL ) {\n BIO_printf ( bio_s_out , \"Setting temp DH parameters\\n\" ) ;\n }\n else {\n BIO_printf ( bio_s_out , \"Using default temp DH parameters\\n\" ) ;\n dh = get_dh2048 ( ) ;\n if ( dh == NULL ) {\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n }\n ( void ) BIO_flush ( bio_s_out ) ;\n SSL_CTX_set_tmp_dh ( ctx , dh ) ;\n # ifndef OPENSSL_NO_TLSEXT if ( ctx2 ) {\n if ( ! dhfile ) {\n DH * dh2 = load_dh_param ( s_cert_file2 ) ;\n if ( dh2 != NULL ) {\n BIO_printf ( bio_s_out , \"Setting temp DH parameters\\n\" ) ;\n ( void ) BIO_flush ( bio_s_out ) ;\n DH_free ( dh ) ;\n dh = dh2 ;\n }\n }\n SSL_CTX_set_tmp_dh ( ctx2 , dh ) ;\n }\n # endif DH_free ( dh ) ;\n }\n # endif # ifndef OPENSSL_NO_ECDH if ( ! no_ecdhe ) {\n EC_KEY * ecdh = NULL ;\n if ( named_curve ) {\n int nid = OBJ_sn2nid ( named_curve ) ;\n if ( nid == 0 ) {\n BIO_printf ( bio_err , \"unknown curve name (%s)\\n\" , named_curve ) ;\n goto end ;\n }\n ecdh = EC_KEY_new_by_curve_name ( nid ) ;\n if ( ecdh == NULL ) {\n BIO_printf ( bio_err , \"unable to create curve (%s)\\n\" , named_curve ) ;\n goto end ;\n }\n }\n if ( ecdh != NULL ) {\n BIO_printf ( bio_s_out , \"Setting temp ECDH parameters\\n\" ) ;\n }\n else {\n BIO_printf ( bio_s_out , \"Using default temp ECDH parameters\\n\" ) ;\n ecdh = EC_KEY_new_by_curve_name ( NID_X9_62_prime256v1 ) ;\n if ( ecdh == NULL ) {\n BIO_printf ( bio_err , \"unable to create curve (nistp256)\\n\" ) ;\n goto end ;\n }\n }\n ( void ) BIO_flush ( bio_s_out ) ;\n SSL_CTX_set_tmp_ecdh ( ctx , ecdh ) ;\n # ifndef OPENSSL_NO_TLSEXT if ( ctx2 ) SSL_CTX_set_tmp_ecdh ( ctx2 , ecdh ) ;\n # endif EC_KEY_free ( ecdh ) ;\n }\n # endif if ( ! set_cert_key_stuff ( ctx , s_cert , s_key ) ) goto end ;\n # ifndef OPENSSL_NO_TLSEXT if ( ctx2 && ! set_cert_key_stuff ( ctx2 , s_cert2 , s_key2 ) ) goto end ;\n # endif if ( s_dcert != NULL ) {\n if ( ! set_cert_key_stuff ( ctx , s_dcert , s_dkey ) ) goto end ;\n }\n # ifndef OPENSSL_NO_RSA # if 1 if ( ! no_tmp_rsa ) {\n SSL_CTX_set_tmp_rsa_callback ( ctx , tmp_rsa_cb ) ;\n # ifndef OPENSSL_NO_TLSEXT if ( ctx2 ) SSL_CTX_set_tmp_rsa_callback ( ctx2 , tmp_rsa_cb ) ;\n # endif }\n # else if ( ! no_tmp_rsa && SSL_CTX_need_tmp_RSA ( ctx ) ) {\n RSA * rsa ;\n BIO_printf ( bio_s_out , \"Generating temp (512 bit) RSA key...\" ) ;\n BIO_flush ( bio_s_out ) ;\n rsa = RSA_generate_key ( 512 , RSA_F4 , NULL ) ;\n if ( ! SSL_CTX_set_tmp_rsa ( ctx , rsa ) ) {\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n # ifndef OPENSSL_NO_TLSEXT if ( ctx2 ) {\n if ( ! SSL_CTX_set_tmp_rsa ( ctx2 , rsa ) ) {\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n }\n # endif RSA_free ( rsa ) ;\n BIO_printf ( bio_s_out , \"\\n\" ) ;\n }\n # endif # endif # ifndef OPENSSL_NO_PSK # ifdef OPENSSL_NO_JPAKE if ( psk_key != NULL ) # else if ( psk_key != NULL || jpake_secret ) # endif {\n if ( s_debug ) BIO_printf ( bio_s_out , \"PSK key given or JPAKE in use, setting server callback\\n\" ) ;\n SSL_CTX_set_psk_server_callback ( ctx , psk_server_cb ) ;\n }\n if ( ! SSL_CTX_use_psk_identity_hint ( ctx , psk_identity_hint ) ) {\n BIO_printf ( bio_err , \"error setting PSK identity hint to context\\n\" ) ;\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n # endif if ( cipher != NULL ) {\n if ( ! SSL_CTX_set_cipher_list ( ctx , cipher ) ) {\n BIO_printf ( bio_err , \"error setting cipher list\\n\" ) ;\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n # ifndef OPENSSL_NO_TLSEXT if ( ctx2 && ! SSL_CTX_set_cipher_list ( ctx2 , cipher ) ) {\n BIO_printf ( bio_err , \"error setting cipher list\\n\" ) ;\n ERR_print_errors ( bio_err ) ;\n goto end ;\n }\n # endif }\n SSL_CTX_set_verify ( ctx , s_server_verify , verify_callback ) ;\n SSL_CTX_set_session_id_context ( ctx , ( void * ) & s_server_session_id_context , sizeof s_server_session_id_context ) ;\n SSL_CTX_set_cookie_generate_cb ( ctx , generate_cookie_callback ) ;\n SSL_CTX_set_cookie_verify_cb ( ctx , verify_cookie_callback ) ;\n # ifndef OPENSSL_NO_TLSEXT if ( ctx2 ) {\n SSL_CTX_set_verify ( ctx2 , s_server_verify , verify_callback ) ;\n SSL_CTX_set_session_id_context ( ctx2 , ( void * ) & s_server_session_id_context , sizeof s_server_session_id_context ) ;\n tlsextcbp . biodebug = bio_s_out ;\n SSL_CTX_set_tlsext_servername_callback ( ctx2 , ssl_servername_cb ) ;\n SSL_CTX_set_tlsext_servername_arg ( ctx2 , & tlsextcbp ) ;\n SSL_CTX_set_tlsext_servername_callback ( ctx , ssl_servername_cb ) ;\n SSL_CTX_set_tlsext_servername_arg ( ctx , & tlsextcbp ) ;\n }\n # endif # ifndef OPENSSL_NO_SRP if ( srp_verifier_file != NULL ) {\n srp_callback_parm . vb = SRP_VBASE_new ( srpuserseed ) ;\n srp_callback_parm . user = NULL ;\n srp_callback_parm . login = NULL ;\n if ( ( ret = SRP_VBASE_init ( srp_callback_parm . vb , srp_verifier_file ) ) != SRP_NO_ERROR ) {\n BIO_printf ( bio_err , \"Cannot initialize SRP verifier file \\\"%s\\\":ret=%d\\n\" , srp_verifier_file , ret ) ;\n goto end ;\n }\n SSL_CTX_set_verify ( ctx , SSL_VERIFY_NONE , verify_callback ) ;\n SSL_CTX_set_srp_cb_arg ( ctx , & srp_callback_parm ) ;\n SSL_CTX_set_srp_username_callback ( ctx , ssl_srp_server_param_cb ) ;\n }\n else # endif if ( CAfile != NULL ) {\n SSL_CTX_set_client_CA_list ( ctx , SSL_load_client_CA_file ( CAfile ) ) ;\n # ifndef OPENSSL_NO_TLSEXT if ( ctx2 ) SSL_CTX_set_client_CA_list ( ctx2 , SSL_load_client_CA_file ( CAfile ) ) ;\n # endif }\n BIO_printf ( bio_s_out , \"ACCEPT\\n\" ) ;\n ( void ) BIO_flush ( bio_s_out ) ;\n if ( www ) do_server ( port , socket_type , & accept_socket , www_body , context ) ;\n else do_server ( port , socket_type , & accept_socket , sv_body , context ) ;\n print_stats ( bio_s_out , ctx ) ;\n ret = 0 ;\n end : if ( ctx != NULL ) SSL_CTX_free ( ctx ) ;\n if ( s_cert ) X509_free ( s_cert ) ;\n if ( s_dcert ) X509_free ( s_dcert ) ;\n if ( s_key ) EVP_PKEY_free ( s_key ) ;\n if ( s_dkey ) EVP_PKEY_free ( s_dkey ) ;\n if ( pass ) OPENSSL_free ( pass ) ;\n if ( dpass ) OPENSSL_free ( dpass ) ;\n if ( vpm ) X509_VERIFY_PARAM_free ( vpm ) ;\n # ifndef OPENSSL_NO_TLSEXT if ( tlscstatp . host ) OPENSSL_free ( tlscstatp . host ) ;\n if ( tlscstatp . port ) OPENSSL_free ( tlscstatp . port ) ;\n if ( tlscstatp . path ) OPENSSL_free ( tlscstatp . path ) ;\n if ( ctx2 != NULL ) SSL_CTX_free ( ctx2 ) ;\n if ( s_cert2 ) X509_free ( s_cert2 ) ;\n if ( s_key2 ) EVP_PKEY_free ( s_key2 ) ;\n # endif if ( bio_s_out != NULL ) {\n BIO_free ( bio_s_out ) ;\n bio_s_out = NULL ;\n }\n apps_shutdown ( ) ;\n OPENSSL_EXIT ( ret ) ;\n }\n static void print_stats ( BIO * bio , SSL_CTX * ssl_ctx ) {\n BIO_printf ( bio , \"%4ld items in the session cache\\n\" , SSL_CTX_sess_number ( ssl_ctx ) ) ;\n BIO_printf ( bio , \"%4ld client connects (SSL_connect())\\n\" , SSL_CTX_sess_connect ( ssl_ctx ) ) ;\n BIO_printf ( bio , \"%4ld client renegotiates (SSL_connect())\\n\" , SSL_CTX_sess_connect_renegotiate ( ssl_ctx ) ) ;\n BIO_printf ( bio , \"%4ld client connects that finished\\n\" , SSL_CTX_sess_connect_good ( ssl_ctx ) ) ;\n BIO_printf ( bio , \"%4ld server accepts (SSL_accept())\\n\" , SSL_CTX_sess_accept ( ssl_ctx ) ) ;\n BIO_printf ( bio , \"%4ld server renegotiates (SSL_accept())\\n\" , SSL_CTX_sess_accept_renegotiate ( ssl_ctx ) ) ;\n BIO_printf ( bio , \"%4ld server accepts that finished\\n\" , SSL_CTX_sess_accept_good ( ssl_ctx ) ) ;\n BIO_printf ( bio , \"%4ld session cache hits\\n\" , SSL_CTX_sess_hits ( ssl_ctx ) ) ;\n BIO_printf ( bio , \"%4ld session cache misses\\n\" , SSL_CTX_sess_misses ( ssl_ctx ) ) ;\n BIO_printf ( bio , \"%4ld session cache timeouts\\n\" , SSL_CTX_sess_timeouts ( ssl_ctx ) ) ;\n BIO_printf ( bio , \"%4ld callback cache hits\\n\" , SSL_CTX_sess_cb_hits ( ssl_ctx ) ) ;\n BIO_printf ( bio , \"%4ld cache full overflows (%ld allowed)\\n\" , SSL_CTX_sess_cache_full ( ssl_ctx ) , SSL_CTX_sess_get_cache_size ( ssl_ctx ) ) ;\n }\n static int sv_body ( char * hostname , int s , unsigned char * context ) {\n char * buf = NULL ;\n fd_set readfds ;\n int ret = 1 , width ;\n int k , i ;\n unsigned long l ;\n SSL * con = NULL ;\n BIO * sbio ;\n # ifndef OPENSSL_NO_KRB5 KSSL_CTX * kctx ;\n # endif struct timeval timeout ;\n # if defined ( OPENSSL_SYS_WINDOWS ) || defined ( OPENSSL_SYS_MSDOS ) || defined ( OPENSSL_SYS_NETWARE ) || defined ( OPENSSL_SYS_BEOS_R5 ) struct timeval tv ;\n # else struct timeval * timeoutp ;\n # endif if ( ( buf = OPENSSL_malloc ( bufsize ) ) == NULL ) {\n BIO_printf ( bio_err , \"out of memory\\n\" ) ;\n goto err ;\n }\n # ifdef FIONBIO if ( s_nbio ) {\n unsigned long sl = 1 ;\n if ( ! s_quiet ) BIO_printf ( bio_err , \"turning on non blocking io\\n\" ) ;\n if ( BIO_socket_ioctl ( s , FIONBIO , & sl ) < 0 ) ERR_print_errors ( bio_err ) ;\n }\n # endif if ( con == NULL ) {\n con = SSL_new ( ctx ) ;\n # ifndef OPENSSL_NO_TLSEXT if ( s_tlsextdebug ) {\n SSL_set_tlsext_debug_callback ( con , tlsext_cb ) ;\n SSL_set_tlsext_debug_arg ( con , bio_s_out ) ;\n }\n if ( s_tlsextstatus ) {\n SSL_CTX_set_tlsext_status_cb ( ctx , cert_status_cb ) ;\n tlscstatp . err = bio_err ;\n SSL_CTX_set_tlsext_status_arg ( ctx , & tlscstatp ) ;\n }\n # endif # ifndef OPENSSL_NO_KRB5 if ( ( kctx = kssl_ctx_new ( ) ) != NULL ) {\n SSL_set0_kssl_ctx ( con , kctx ) ;\n kssl_ctx_setstring ( kctx , KSSL_SERVICE , KRB5SVC ) ;\n kssl_ctx_setstring ( kctx , KSSL_KEYTAB , KRB5KEYTAB ) ;\n }\n # endif if ( context ) SSL_set_session_id_context ( con , context , strlen ( ( char * ) context ) ) ;\n }\n SSL_clear ( con ) ;\n # if 0 # ifdef TLSEXT_TYPE_opaque_prf_input SSL_set_tlsext_opaque_prf_input ( con , \"Test server\" , 11 ) ;\n # endif # endif if ( SSL_version ( con ) == DTLS1_VERSION ) {\n sbio = BIO_new_dgram ( s , BIO_NOCLOSE ) ;\n if ( enable_timeouts ) {\n timeout . tv_sec = 0 ;\n timeout . tv_usec = DGRAM_RCV_TIMEOUT ;\n BIO_ctrl ( sbio , BIO_CTRL_DGRAM_SET_RECV_TIMEOUT , 0 , & timeout ) ;\n timeout . tv_sec = 0 ;\n timeout . tv_usec = DGRAM_SND_TIMEOUT ;\n BIO_ctrl ( sbio , BIO_CTRL_DGRAM_SET_SEND_TIMEOUT , 0 , & timeout ) ;\n }\n if ( socket_mtu ) {\n if ( socket_mtu < DTLS_get_link_min_mtu ( con ) ) {\n BIO_printf ( bio_err , \"MTU too small. Must be at least %ld\\n\" , DTLS_get_link_min_mtu ( con ) ) ;\n ret = - 1 ;\n BIO_free ( sbio ) ;\n goto err ;\n }\n SSL_set_options ( con , SSL_OP_NO_QUERY_MTU ) ;\n if ( ! DTLS_set_link_mtu ( con , socket_mtu ) ) {\n BIO_printf ( bio_err , \"Failed to set MTU\\n\" ) ;\n ret = - 1 ;\n BIO_free ( sbio ) ;\n goto err ;\n }\n }\n else BIO_ctrl ( sbio , BIO_CTRL_DGRAM_MTU_DISCOVER , 0 , NULL ) ;\n SSL_set_options ( con , SSL_OP_COOKIE_EXCHANGE ) ;\n }\n else sbio = BIO_new_socket ( s , BIO_NOCLOSE ) ;\n if ( s_nbio_test ) {\n BIO * test ;\n test = BIO_new ( BIO_f_nbio_test ( ) ) ;\n sbio = BIO_push ( test , sbio ) ;\n }\n # ifndef OPENSSL_NO_JPAKE if ( jpake_secret ) jpake_server_auth ( bio_s_out , sbio , jpake_secret ) ;\n # endif SSL_set_bio ( con , sbio , sbio ) ;\n SSL_set_accept_state ( con ) ;\n if ( s_debug ) {\n SSL_set_debug ( con , 1 ) ;\n BIO_set_callback ( SSL_get_rbio ( con ) , bio_dump_callback ) ;\n BIO_set_callback_arg ( SSL_get_rbio ( con ) , ( char * ) bio_s_out ) ;\n }\n if ( s_msg ) {\n SSL_set_msg_callback ( con , msg_cb ) ;\n SSL_set_msg_callback_arg ( con , bio_s_out ) ;\n }\n # ifndef OPENSSL_NO_TLSEXT if ( s_tlsextdebug ) {\n SSL_set_tlsext_debug_callback ( con , tlsext_cb ) ;\n SSL_set_tlsext_debug_arg ( con , bio_s_out ) ;\n }\n # endif width = s + 1 ;\n for ( ;\n ;\n ) {\n int read_from_terminal ;\n int read_from_sslcon ;\n read_from_terminal = 0 ;\n read_from_sslcon = SSL_pending ( con ) ;\n if ( ! read_from_sslcon ) {\n FD_ZERO ( & readfds ) ;\n # if ! defined ( OPENSSL_SYS_WINDOWS ) && ! defined ( OPENSSL_SYS_MSDOS ) && ! defined ( OPENSSL_SYS_NETWARE ) && ! defined ( OPENSSL_SYS_BEOS_R5 ) openssl_fdset ( fileno ( stdin ) , & readfds ) ;\n # endif openssl_fdset ( s , & readfds ) ;\n # if defined ( OPENSSL_SYS_WINDOWS ) || defined ( OPENSSL_SYS_MSDOS ) || defined ( OPENSSL_SYS_NETWARE ) tv . tv_sec = 1 ;\n tv . tv_usec = 0 ;\n i = select ( width , ( void * ) & readfds , NULL , NULL , & tv ) ;\n if ( ( i < 0 ) || ( ! i && ! _kbhit ( ) ) ) continue ;\n if ( _kbhit ( ) ) read_from_terminal = 1 ;\n # elif defined ( OPENSSL_SYS_BEOS_R5 ) tv . tv_sec = 1 ;\n tv . tv_usec = 0 ;\n ( void ) fcntl ( fileno ( stdin ) , F_SETFL , O_NONBLOCK ) ;\n i = select ( width , ( void * ) & readfds , NULL , NULL , & tv ) ;\n if ( ( i < 0 ) || ( ! i && read ( fileno ( stdin ) , buf , 0 ) < 0 ) ) continue ;\n if ( read ( fileno ( stdin ) , buf , 0 ) >= 0 ) read_from_terminal = 1 ;\n ( void ) fcntl ( fileno ( stdin ) , F_SETFL , 0 ) ;\n # else if ( ( SSL_version ( con ) == DTLS1_VERSION ) && DTLSv1_get_timeout ( con , & timeout ) ) timeoutp = & timeout ;\n else timeoutp = NULL ;\n i = select ( width , ( void * ) & readfds , NULL , NULL , timeoutp ) ;\n if ( ( SSL_version ( con ) == DTLS1_VERSION ) && DTLSv1_handle_timeout ( con ) > 0 ) {\n BIO_printf ( bio_err , \"TIMEOUT occured\\n\" ) ;\n }\n if ( i <= 0 ) continue ;\n if ( FD_ISSET ( fileno ( stdin ) , & readfds ) ) read_from_terminal = 1 ;\n # endif if ( FD_ISSET ( s , & readfds ) ) read_from_sslcon = 1 ;\n }\n if ( read_from_terminal ) {\n if ( s_crlf ) {\n int j , lf_num ;\n i = raw_read_stdin ( buf , bufsize / 2 ) ;\n lf_num = 0 ;\n for ( j = 0 ;\n j < i ;\n j ++ ) if ( buf [ j ] == '\\n' ) lf_num ++ ;\n for ( j = i - 1 ;\n j >= 0 ;\n j -- ) {\n buf [ j + lf_num ] = buf [ j ] ;\n if ( buf [ j ] == '\\n' ) {\n lf_num -- ;\n i ++ ;\n buf [ j + lf_num ] = '\\r' ;\n }\n }\n assert ( lf_num == 0 ) ;\n }\n else i = raw_read_stdin ( buf , bufsize ) ;\n if ( ! s_quiet ) {\n if ( ( i <= 0 ) || ( buf [ 0 ] == 'Q' ) ) {\n BIO_printf ( bio_s_out , \"DONE\\n\" ) ;\n SHUTDOWN ( s ) ;\n close_accept_socket ( ) ;\n ret = - 11 ;\n goto err ;\n }\n if ( ( i <= 0 ) || ( buf [ 0 ] == 'q' ) ) {\n BIO_printf ( bio_s_out , \"DONE\\n\" ) ;\n if ( SSL_version ( con ) != DTLS1_VERSION ) SHUTDOWN ( s ) ;\n goto err ;\n }\n # ifndef OPENSSL_NO_HEARTBEATS if ( ( buf [ 0 ] == 'B' ) && ( ( buf [ 1 ] == '\\n' ) || ( buf [ 1 ] == '\\r' ) ) ) {\n BIO_printf ( bio_err , \"HEARTBEATING\\n\" ) ;\n SSL_heartbeat ( con ) ;\n i = 0 ;\n continue ;\n }\n # endif if ( ( buf [ 0 ] == 'r' ) && ( ( buf [ 1 ] == '\\n' ) || ( buf [ 1 ] == '\\r' ) ) ) {\n SSL_renegotiate ( con ) ;\n i = SSL_do_handshake ( con ) ;\n printf ( \"SSL_do_handshake -> %d\\n\" , i ) ;\n i = 0 ;\n continue ;\n }\n if ( ( buf [ 0 ] == 'R' ) && ( ( buf [ 1 ] == '\\n' ) || ( buf [ 1 ] == '\\r' ) ) ) {\n SSL_set_verify ( con , SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE , NULL ) ;\n SSL_renegotiate ( con ) ;\n i = SSL_do_handshake ( con ) ;\n printf ( \"SSL_do_handshake -> %d\\n\" , i ) ;\n i = 0 ;\n continue ;\n }\n if ( buf [ 0 ] == 'P' ) {\n static const char * str = \"Lets print some clear text\\n\" ;\n BIO_write ( SSL_get_wbio ( con ) , str , strlen ( str ) ) ;\n }\n if ( buf [ 0 ] == 'S' ) {\n print_stats ( bio_s_out , SSL_get_SSL_CTX ( con ) ) ;\n }\n }\n # ifdef CHARSET_EBCDIC ebcdic2ascii ( buf , buf , i ) ;\n # endif l = k = 0 ;\n for ( ;\n ;\n ) {\n # ifdef RENEG {\n static count = 0 ;\n if ( ++ count == 100 ) {\n count = 0 ;\n SSL_renegotiate ( con ) ;\n }\n }\n # endif k = SSL_write ( con , & ( buf [ l ] ) , ( unsigned int ) i ) ;\n # ifndef OPENSSL_NO_SRP while ( SSL_get_error ( con , k ) == SSL_ERROR_WANT_X509_LOOKUP ) {\n BIO_printf ( bio_s_out , \"LOOKUP renego during write\\n\" ) ;\n srp_callback_parm . user = SRP_VBASE_get_by_user ( srp_callback_parm . vb , srp_callback_parm . login ) ;\n if ( srp_callback_parm . user ) BIO_printf ( bio_s_out , \"LOOKUP done %s\\n\" , srp_callback_parm . user -> info ) ;\n else BIO_printf ( bio_s_out , \"LOOKUP not successful\\n\" ) ;\n k = SSL_write ( con , & ( buf [ l ] ) , ( unsigned int ) i ) ;\n }\n # endif switch ( SSL_get_error ( con , k ) ) {\n case SSL_ERROR_NONE : break ;\n case SSL_ERROR_WANT_WRITE : case SSL_ERROR_WANT_READ : case SSL_ERROR_WANT_X509_LOOKUP : BIO_printf ( bio_s_out , \"Write BLOCK\\n\" ) ;\n break ;\n case SSL_ERROR_SYSCALL : case SSL_ERROR_SSL : BIO_printf ( bio_s_out , \"ERROR\\n\" ) ;\n ERR_print_errors ( bio_err ) ;\n ret = 1 ;\n goto err ;\n case SSL_ERROR_ZERO_RETURN : BIO_printf ( bio_s_out , \"DONE\\n\" ) ;\n ret = 1 ;\n goto err ;\n }\n if ( k > 0 ) {\n l += k ;\n i -= k ;\n }\n if ( i <= 0 ) break ;\n }\n }\n if ( read_from_sslcon ) {\n if ( ! SSL_is_init_finished ( con ) ) {\n i = init_ssl_connection ( con ) ;\n if ( i < 0 ) {\n ret = 0 ;\n goto err ;\n }\n else if ( i == 0 ) {\n ret = 1 ;\n goto err ;\n }\n }\n else {\n again : i = SSL_read ( con , ( char * ) buf , bufsize ) ;\n # ifndef OPENSSL_NO_SRP while ( SSL_get_error ( con , i ) == SSL_ERROR_WANT_X509_LOOKUP ) {\n BIO_printf ( bio_s_out , \"LOOKUP renego during read\\n\" ) ;\n srp_callback_parm . user = SRP_VBASE_get_by_user ( srp_callback_parm . vb , srp_callback_parm . login ) ;\n if ( srp_callback_parm . user ) BIO_printf ( bio_s_out , \"LOOKUP done %s\\n\" , srp_callback_parm . user -> info ) ;\n else BIO_printf ( bio_s_out , \"LOOKUP not successful\\n\" ) ;\n i = SSL_read ( con , ( char * ) buf , bufsize ) ;\n }\n # endif switch ( SSL_get_error ( con , i ) ) {\n case SSL_ERROR_NONE : # ifdef CHARSET_EBCDIC ascii2ebcdic ( buf , buf , i ) ;\n # endif raw_write_stdout ( buf , ( unsigned int ) i ) ;\n if ( SSL_pending ( con ) ) goto again ;\n break ;\n case SSL_ERROR_WANT_WRITE : case SSL_ERROR_WANT_READ : BIO_printf ( bio_s_out , \"Read BLOCK\\n\" ) ;\n break ;\n case SSL_ERROR_SYSCALL : case SSL_ERROR_SSL : BIO_printf ( bio_s_out , \"ERROR\\n\" ) ;\n ERR_print_errors ( bio_err ) ;\n ret = 1 ;\n goto err ;\n case SSL_ERROR_ZERO_RETURN : BIO_printf ( bio_s_out , \"DONE\\n\" ) ;\n ret = 1 ;\n goto err ;\n }\n }\n }\n }\n err : if ( con != NULL ) {\n BIO_printf ( bio_s_out , \"shutting down SSL\\n\" ) ;\n # if 1 SSL_set_shutdown ( con , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;\n # else SSL_shutdown ( con ) ;\n # endif SSL_free ( con ) ;\n }\n BIO_printf ( bio_s_out , \"CONNECTION CLOSED\\n\" ) ;\n if ( buf != NULL ) {\n OPENSSL_cleanse ( buf , bufsize ) ;\n OPENSSL_free ( buf ) ;\n }\n if ( ret >= 0 ) BIO_printf ( bio_s_out , \"ACCEPT\\n\" ) ;\n return ( ret ) ;\n }\n static void close_accept_socket ( void ) {\n BIO_printf ( bio_err , \"shutdown accept socket\\n\" ) ;\n if ( accept_socket >= 0 ) {\n SHUTDOWN2 ( accept_socket ) ;\n }\n }\n static int init_ssl_connection ( SSL * con ) {\n int i ;\n const char * str ;\n X509 * peer ;\n long verify_error ;\n MS_STATIC char buf [ BUFSIZ ] ;\n # ifndef OPENSSL_NO_KRB5 char * client_princ ;\n # endif # if ! defined ( OPENSSL_NO_TLSEXT ) && ! defined ( OPENSSL_NO_NEXTPROTONEG ) const unsigned char * next_proto_neg ;\n unsigned next_proto_neg_len ;\n # endif unsigned char * exportedkeymat ;\n i = SSL_accept ( con ) ;\n # ifndef OPENSSL_NO_SRP while ( i <= 0 && SSL_get_error ( con , i ) == SSL_ERROR_WANT_X509_LOOKUP ) {\n BIO_printf ( bio_s_out , \"LOOKUP during accept %s\\n\" , srp_callback_parm . login ) ;\n srp_callback_parm . user = SRP_VBASE_get_by_user ( srp_callback_parm . vb , srp_callback_parm . login ) ;\n if ( srp_callback_parm . user ) BIO_printf ( bio_s_out , \"LOOKUP done %s\\n\" , srp_callback_parm . user -> info ) ;\n else BIO_printf ( bio_s_out , \"LOOKUP not successful\\n\" ) ;\n i = SSL_accept ( con ) ;\n }\n # endif if ( i <= 0 ) {\n if ( BIO_sock_should_retry ( i ) ) {\n BIO_printf ( bio_s_out , \"DELAY\\n\" ) ;\n return ( 1 ) ;\n }\n BIO_printf ( bio_err , \"ERROR\\n\" ) ;\n verify_error = SSL_get_verify_result ( con ) ;\n if ( verify_error != X509_V_OK ) {\n BIO_printf ( bio_err , \"verify error:%s\\n\" , X509_verify_cert_error_string ( verify_error ) ) ;\n }\n else ERR_print_errors ( bio_err ) ;\n return ( 0 ) ;\n }\n PEM_write_bio_SSL_SESSION ( bio_s_out , SSL_get_session ( con ) ) ;\n peer = SSL_get_peer_certificate ( con ) ;\n if ( peer != NULL ) {\n BIO_printf ( bio_s_out , \"Client certificate\\n\" ) ;\n PEM_write_bio_X509 ( bio_s_out , peer ) ;\n X509_NAME_oneline ( X509_get_subject_name ( peer ) , buf , sizeof buf ) ;\n BIO_printf ( bio_s_out , \"subject=%s\\n\" , buf ) ;\n X509_NAME_oneline ( X509_get_issuer_name ( peer ) , buf , sizeof buf ) ;\n BIO_printf ( bio_s_out , \"issuer=%s\\n\" , buf ) ;\n X509_free ( peer ) ;\n }\n if ( SSL_get_shared_ciphers ( con , buf , sizeof buf ) != NULL ) BIO_printf ( bio_s_out , \"Shared ciphers:%s\\n\" , buf ) ;\n str = SSL_CIPHER_get_name ( SSL_get_current_cipher ( con ) ) ;\n BIO_printf ( bio_s_out , \"CIPHER is %s\\n\" , ( str != NULL ) ? str : \"(NONE)\" ) ;\n # if ! defined ( OPENSSL_NO_TLSEXT ) && ! defined ( OPENSSL_NO_NEXTPROTONEG ) SSL_get0_next_proto_negotiated ( con , & next_proto_neg , & next_proto_neg_len ) ;\n if ( next_proto_neg ) {\n BIO_printf ( bio_s_out , \"NEXTPROTO is \" ) ;\n BIO_write ( bio_s_out , next_proto_neg , next_proto_neg_len ) ;\n BIO_printf ( bio_s_out , \"\\n\" ) ;\n }\n # endif # ifndef OPENSSL_NO_SRTP {\n SRTP_PROTECTION_PROFILE * srtp_profile = SSL_get_selected_srtp_profile ( con ) ;\n if ( srtp_profile ) BIO_printf ( bio_s_out , \"SRTP Extension negotiated, profile=%s\\n\" , srtp_profile -> name ) ;\n }\n # endif if ( SSL_cache_hit ( con ) ) BIO_printf ( bio_s_out , \"Reused session-id\\n\" ) ;\n if ( SSL_ctrl ( con , SSL_CTRL_GET_FLAGS , 0 , NULL ) & TLS1_FLAGS_TLS_PADDING_BUG ) BIO_printf ( bio_s_out , \"Peer has incorrect TLSv1 block padding\\n\" ) ;\n # ifndef OPENSSL_NO_KRB5 client_princ = kssl_ctx_get0_client_princ ( SSL_get0_kssl_ctx ( con ) ) ;\n if ( client_princ != NULL ) {\n BIO_printf ( bio_s_out , \"Kerberos peer principal is %s\\n\" , client_princ ) ;\n }\n # endif BIO_printf ( bio_s_out , \"Secure Renegotiation IS%s supported\\n\" , SSL_get_secure_renegotiation_support ( con ) ? \"\" : \" NOT\" ) ;\n if ( keymatexportlabel != NULL ) {\n BIO_printf ( bio_s_out , \"Keying material exporter:\\n\" ) ;\n BIO_printf ( bio_s_out , \" Label: '%s'\\n\" , keymatexportlabel ) ;\n BIO_printf ( bio_s_out , \" Length: %i bytes\\n\" , keymatexportlen ) ;\n exportedkeymat = OPENSSL_malloc ( keymatexportlen ) ;\n if ( exportedkeymat != NULL ) {\n if ( ! SSL_export_keying_material ( con , exportedkeymat , keymatexportlen , keymatexportlabel , strlen ( keymatexportlabel ) , NULL , 0 , 0 ) ) {\n BIO_printf ( bio_s_out , \" Error\\n\" ) ;\n }\n else {\n BIO_printf ( bio_s_out , \" Keying material: \" ) ;\n for ( i = 0 ;\n i < keymatexportlen ;\n i ++ ) BIO_printf ( bio_s_out , \"%02X\" , exportedkeymat [ i ] ) ;\n BIO_printf ( bio_s_out , \"\\n\" ) ;\n }\n OPENSSL_free ( exportedkeymat ) ;\n }\n }\n return ( 1 ) ;\n }\n # ifndef OPENSSL_NO_DH static DH * load_dh_param ( const char * dhfile ) {\n DH * ret = NULL ;\n BIO * bio ;\n if ( ( bio = BIO_new_file ( dhfile , \"r\" ) ) == NULL ) goto err ;\n ret = PEM_read_bio_DHparams ( bio , NULL , NULL , NULL ) ;\n err : if ( bio != NULL ) BIO_free ( bio ) ;\n return ( ret ) ;\n }\n # endif # ifndef OPENSSL_NO_KRB5 char * client_princ ;\n # endif # if 0 static int load_CA ( SSL_CTX * ctx , char * file ) {\n FILE * in ;\n X509 * x = NULL ;\n if ( ( in = fopen ( file , \"r\" ) ) == NULL ) return ( 0 ) ;\n for ( ;\n ;\n ) {\n if ( PEM_read_X509 ( in , & x , NULL ) == NULL ) break ;\n SSL_CTX_add_client_CA ( ctx , x ) ;\n }\n if ( x != NULL ) X509_free ( x ) ;\n fclose ( in ) ;\n return ( 1 ) ;\n }\n # endif static int www_body ( char * hostname , int s , unsigned char * context ) {\n char * buf = NULL ;\n int ret = 1 ;\n int i , j , k , dot ;\n SSL * con ;\n const SSL_CIPHER * c ;\n BIO * io , * ssl_bio , * sbio ;\n # ifndef OPENSSL_NO_KRB5 KSSL_CTX * kctx ;\n # endif buf = OPENSSL_malloc ( bufsize ) ;\n if ( buf == NULL ) return ( 0 ) ;\n io = BIO_new ( BIO_f_buffer ( ) ) ;\n ssl_bio = BIO_new ( BIO_f_ssl ( ) ) ;\n if ( ( io == NULL ) || ( ssl_bio == NULL ) ) goto err ;\n # ifdef FIONBIO if ( s_nbio ) {\n unsigned long sl = 1 ;\n if ( ! s_quiet ) BIO_printf ( bio_err , \"turning on non blocking io\\n\" ) ;\n if ( BIO_socket_ioctl ( s , FIONBIO , & sl ) < 0 ) ERR_print_errors ( bio_err ) ;\n }\n # endif if ( ! BIO_set_write_buffer_size ( io , bufsize ) ) goto err ;\n if ( ( con = SSL_new ( ctx ) ) == NULL ) goto err ;\n # ifndef OPENSSL_NO_TLSEXT if ( s_tlsextdebug ) {\n SSL_set_tlsext_debug_callback ( con , tlsext_cb ) ;\n SSL_set_tlsext_debug_arg ( con , bio_s_out ) ;\n }\n # endif # ifndef OPENSSL_NO_KRB5 if ( ( kctx = kssl_ctx_new ( ) ) != NULL ) {\n kssl_ctx_setstring ( kctx , KSSL_SERVICE , KRB5SVC ) ;\n kssl_ctx_setstring ( kctx , KSSL_KEYTAB , KRB5KEYTAB ) ;\n }\n # endif if ( context ) SSL_set_session_id_context ( con , context , strlen ( ( char * ) context ) ) ;\n sbio = BIO_new_socket ( s , BIO_NOCLOSE ) ;\n if ( s_nbio_test ) {\n BIO * test ;\n test = BIO_new ( BIO_f_nbio_test ( ) ) ;\n sbio = BIO_push ( test , sbio ) ;\n }\n SSL_set_bio ( con , sbio , sbio ) ;\n SSL_set_accept_state ( con ) ;\n BIO_set_ssl ( ssl_bio , con , BIO_CLOSE ) ;\n BIO_push ( io , ssl_bio ) ;\n # ifdef CHARSET_EBCDIC io = BIO_push ( BIO_new ( BIO_f_ebcdic_filter ( ) ) , io ) ;\n # endif if ( s_debug ) {\n SSL_set_debug ( con , 1 ) ;\n BIO_set_callback ( SSL_get_rbio ( con ) , bio_dump_callback ) ;\n BIO_set_callback_arg ( SSL_get_rbio ( con ) , ( char * ) bio_s_out ) ;\n }\n if ( s_msg ) {\n SSL_set_msg_callback ( con , msg_cb ) ;\n SSL_set_msg_callback_arg ( con , bio_s_out ) ;\n }\n for ( ;\n ;\n ) {\n if ( hack ) {\n i = SSL_accept ( con ) ;\n # ifndef OPENSSL_NO_SRP while ( i <= 0 && SSL_get_error ( con , i ) == SSL_ERROR_WANT_X509_LOOKUP ) {\n BIO_printf ( bio_s_out , \"LOOKUP during accept %s\\n\" , srp_callback_parm . login ) ;\n srp_callback_parm . user = SRP_VBASE_get_by_user ( srp_callback_parm . vb , srp_callback_parm . login ) ;\n if ( srp_callback_parm . user ) BIO_printf ( bio_s_out , \"LOOKUP done %s\\n\" , srp_callback_parm . user -> info ) ;\n else BIO_printf ( bio_s_out , \"LOOKUP not successful\\n\" ) ;\n i = SSL_accept ( con ) ;\n }\n # endif switch ( SSL_get_error ( con , i ) ) {\n case SSL_ERROR_NONE : break ;\n case SSL_ERROR_WANT_WRITE : case SSL_ERROR_WANT_READ : case SSL_ERROR_WANT_X509_LOOKUP : continue ;\n case SSL_ERROR_SYSCALL : case SSL_ERROR_SSL : case SSL_ERROR_ZERO_RETURN : ret = 1 ;\n goto err ;\n }\n SSL_renegotiate ( con ) ;\n SSL_write ( con , NULL , 0 ) ;\n }\n i = BIO_gets ( io , buf , bufsize - 1 ) ;\n if ( i < 0 ) {\n if ( ! BIO_should_retry ( io ) ) {\n if ( ! s_quiet ) ERR_print_errors ( bio_err ) ;\n goto err ;\n }\n else {\n BIO_printf ( bio_s_out , \"read R BLOCK\\n\" ) ;\n # ifndef OPENSSL_NO_SRP if ( BIO_should_io_special ( io ) && BIO_get_retry_reason ( io ) == BIO_RR_SSL_X509_LOOKUP ) {\n BIO_printf ( bio_s_out , \"LOOKUP renego during read\\n\" ) ;\n srp_callback_parm . user = SRP_VBASE_get_by_user ( srp_callback_parm . vb , srp_callback_parm . login ) ;\n if ( srp_callback_parm . user ) BIO_printf ( bio_s_out , \"LOOKUP done %s\\n\" , srp_callback_parm . user -> info ) ;\n else BIO_printf ( bio_s_out , \"LOOKUP not successful\\n\" ) ;\n continue ;\n }\n # endif # if defined ( OPENSSL_SYS_NETWARE ) delay ( 1000 ) ;\n # elif ! defined ( OPENSSL_SYS_MSDOS ) && ! defined ( __DJGPP__ ) sleep ( 1 ) ;\n # endif continue ;\n }\n }\n else if ( i == 0 ) {\n ret = 1 ;\n goto end ;\n }\n if ( ( ( www == 1 ) && ( strncmp ( \"GET \" , buf , 4 ) == 0 ) ) || ( ( www == 2 ) && ( strncmp ( \"GET /stats \" , buf , 11 ) == 0 ) ) ) {\n char * p ;\n X509 * peer ;\n STACK_OF ( SSL_CIPHER ) * sk ;\n static const char * space = \" \" ;\n BIO_puts ( io , \"HTTP/1.0 200 ok\\r\\nContent-type: text/html\\r\\n\\r\\n\" ) ;\n BIO_puts ( io , \"<HTML><BODY BGCOLOR=\\\"#ffffff\\\">\\n\" ) ;\n BIO_puts ( io , \"<pre>\\n\" ) ;\n BIO_puts ( io , \"\\n\" ) ;\n for ( i = 0 ;\n i < local_argc ;\n i ++ ) {\n BIO_puts ( io , local_argv [ i ] ) ;\n BIO_write ( io , \" \" , 1 ) ;\n }\n BIO_puts ( io , \"\\n\" ) ;\n BIO_printf ( io , \"Secure Renegotiation IS%s supported\\n\" , SSL_get_secure_renegotiation_support ( con ) ? \"\" : \" NOT\" ) ;\n BIO_printf ( io , \"Ciphers supported in s_server binary\\n\" ) ;\n sk = SSL_get_ciphers ( con ) ;\n j = sk_SSL_CIPHER_num ( sk ) ;\n for ( i = 0 ;\n i < j ;\n i ++ ) {\n c = sk_SSL_CIPHER_value ( sk , i ) ;\n BIO_printf ( io , \"%-11s:%-25s\" , SSL_CIPHER_get_version ( c ) , SSL_CIPHER_get_name ( c ) ) ;\n if ( ( ( ( i + 1 ) % 2 ) == 0 ) && ( i + 1 != j ) ) BIO_puts ( io , \"\\n\" ) ;\n }\n BIO_puts ( io , \"\\n\" ) ;\n p = SSL_get_shared_ciphers ( con , buf , bufsize ) ;\n if ( p != NULL ) {\n BIO_printf ( io , \"---\\nCiphers common between both SSL end points:\\n\" ) ;\n j = i = 0 ;\n while ( * p ) {\n if ( * p == ':' ) {\n BIO_write ( io , space , 26 - j ) ;\n i ++ ;\n j = 0 ;\n BIO_write ( io , ( ( i % 3 ) ? \" \" : \"\\n\" ) , 1 ) ;\n }\n else {\n BIO_write ( io , p , 1 ) ;\n j ++ ;\n }\n p ++ ;\n }\n BIO_puts ( io , \"\\n\" ) ;\n }\n BIO_printf ( io , ( SSL_cache_hit ( con ) ? \"---\\nReused, \" : \"---\\nNew, \" ) ) ;\n c = SSL_get_current_cipher ( con ) ;\n BIO_printf ( io , \"%s, Cipher is %s\\n\" , SSL_CIPHER_get_version ( c ) , SSL_CIPHER_get_name ( c ) ) ;\n SSL_SESSION_print ( io , SSL_get_session ( con ) ) ;\n BIO_printf ( io , \"---\\n\" ) ;\n print_stats ( io , SSL_get_SSL_CTX ( con ) ) ;\n BIO_printf ( io , \"---\\n\" ) ;\n peer = SSL_get_peer_certificate ( con ) ;\n if ( peer != NULL ) {\n BIO_printf ( io , \"Client certificate\\n\" ) ;\n X509_print ( io , peer ) ;\n PEM_write_bio_X509 ( io , peer ) ;\n }\n else BIO_puts ( io , \"no client certificate available\\n\" ) ;\n BIO_puts ( io , \"</BODY></HTML>\\r\\n\\r\\n\" ) ;\n break ;\n }\n else if ( ( www == 2 || www == 3 ) && ( strncmp ( \"GET /\" , buf , 5 ) == 0 ) ) {\n BIO * file ;\n char * p , * e ;\n static const char * text = \"HTTP/1.0 200 ok\\r\\nContent-type: text/plain\\r\\n\\r\\n\" ;\n p = & ( buf [ 5 ] ) ;\n dot = 1 ;\n for ( e = p ;\n * e != '\\0' ;\n e ++ ) {\n if ( e [ 0 ] == ' ' ) break ;\n switch ( dot ) {\n case 1 : dot = ( e [ 0 ] == '.' ) ? 2 : 0 ;\n break ;\n case 2 : dot = ( e [ 0 ] == '.' ) ? 3 : 0 ;\n break ;\n case 3 : dot = ( e [ 0 ] == '/' ) ? - 1 : 0 ;\n break ;\n }\n if ( dot == 0 ) dot = ( e [ 0 ] == '/' ) ? 1 : 0 ;\n }\n dot = ( dot == 3 ) || ( dot == - 1 ) ;\n if ( * e == '\\0' ) {\n BIO_puts ( io , text ) ;\n BIO_printf ( io , \"'%s' is an invalid file name\\r\\n\" , p ) ;\n break ;\n }\n * e = '\\0' ;\n if ( dot ) {\n BIO_puts ( io , text ) ;\n BIO_printf ( io , \"'%s' contains '..' reference\\r\\n\" , p ) ;\n break ;\n }\n if ( * p == '/' ) {\n BIO_puts ( io , text ) ;\n BIO_printf ( io , \"'%s' is an invalid path\\r\\n\" , p ) ;\n break ;\n }\n # if 0 if ( e [ - 1 ] == '/' ) strcat ( p , \"index.html\" ) ;\n # endif if ( app_isdir ( p ) > 0 ) {\n # if 0 strcat ( p , \"/index.html\" ) ;\n # else BIO_puts ( io , text ) ;\n BIO_printf ( io , \"'%s' is a directory\\r\\n\" , p ) ;\n break ;\n # endif }\n if ( ( file = BIO_new_file ( p , \"r\" ) ) == NULL ) {\n BIO_puts ( io , text ) ;\n BIO_printf ( io , \"Error opening '%s'\\r\\n\" , p ) ;\n ERR_print_errors ( io ) ;\n break ;\n }\n if ( ! s_quiet ) BIO_printf ( bio_err , \"FILE:%s\\n\" , p ) ;\n if ( www == 2 ) {\n i = strlen ( p ) ;\n if ( ( ( i > 5 ) && ( strcmp ( & ( p [ i - 5 ] ) , \".html\" ) == 0 ) ) || ( ( i > 4 ) && ( strcmp ( & ( p [ i - 4 ] ) , \".php\" ) == 0 ) ) || ( ( i > 4 ) && ( strcmp ( & ( p [ i - 4 ] ) , \".htm\" ) == 0 ) ) ) BIO_puts ( io , \"HTTP/1.0 200 ok\\r\\nContent-type: text/html\\r\\n\\r\\n\" ) ;\n else BIO_puts ( io , \"HTTP/1.0 200 ok\\r\\nContent-type: text/plain\\r\\n\\r\\n\" ) ;\n }\n for ( ;\n ;\n ) {\n i = BIO_read ( file , buf , bufsize ) ;\n if ( i <= 0 ) break ;\n # ifdef RENEG total_bytes += i ;\n fprintf ( stderr , \"%d\\n\" , i ) ;\n if ( total_bytes > 3 * 1024 ) {\n total_bytes = 0 ;\n fprintf ( stderr , \"RENEGOTIATE\\n\" ) ;\n SSL_renegotiate ( con ) ;\n }\n # endif for ( j = 0 ;\n j < i ;\n ) {\n # ifdef RENEG {\n static count = 0 ;\n if ( ++ count == 13 ) {\n SSL_renegotiate ( con ) ;\n }\n }\n # endif k = BIO_write ( io , & ( buf [ j ] ) , i - j ) ;\n if ( k <= 0 ) {\n if ( ! BIO_should_retry ( io ) ) goto write_error ;\n else {\n BIO_printf ( bio_s_out , \"rwrite W BLOCK\\n\" ) ;\n }\n }\n else {\n j += k ;\n }\n }\n }\n write_error : BIO_free ( file ) ;\n break ;\n }\n }\n for ( ;\n ;\n ) {\n i = ( int ) BIO_flush ( io ) ;\n if ( i <= 0 ) {\n if ( ! BIO_should_retry ( io ) ) break ;\n }\n else break ;\n }\n end : # if 1 SSL_set_shutdown ( con , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ;\n # else # endif err : if ( ret >= 0 ) BIO_printf ( bio_s_out , \"ACCEPT\\n\" ) ;\n if ( buf != NULL ) OPENSSL_free ( buf ) ;\n if ( io != NULL ) BIO_free_all ( io ) ;\n return ( ret ) ;\n }\n # ifndef OPENSSL_NO_RSA static RSA MS_CALLBACK * tmp_rsa_cb ( SSL * s , int is_export , int keylength ) {\n BIGNUM * bn = NULL ;\n static RSA * rsa_tmp = NULL ;\n if ( ! rsa_tmp && ( ( bn = BN_new ( ) ) == NULL ) ) BIO_printf ( bio_err , \"Allocation error in generating RSA key\\n\" ) ;\n if ( ! rsa_tmp && bn ) {\n if ( ! s_quiet ) {\n BIO_printf ( bio_err , \"Generating temp (%d bit) RSA key...\" , keylength ) ;\n ( void ) BIO_flush ( bio_err ) ;\n }\n if ( ! BN_set_word ( bn , RSA_F4 ) || ( ( rsa_tmp = RSA_new ( ) ) == NULL ) || ! RSA_generate_key_ex ( rsa_tmp , keylength , bn , NULL ) ) {\n if ( rsa_tmp ) RSA_free ( rsa_tmp ) ;\n rsa_tmp = NULL ;\n }\n if ( ! s_quiet ) {\n BIO_printf ( bio_err , \"\\n\" ) ;\n ( void ) BIO_flush ( bio_err ) ;\n }\n BN_free ( bn ) ;\n }\n return ( rsa_tmp ) ;\n }\n # endif # define MAX_SESSION_ID_ATTEMPTS 10 static int generate_session_id ( const SSL * ssl , unsigned char * id , unsigned int * id_len ) {\n unsigned int count = 0 ;\n do {\n if ( RAND_pseudo_bytes ( id , * id_len ) < 0 ) return 0 ;\n memcpy ( id , session_id_prefix , ( strlen ( session_id_prefix ) < * id_len ) ? strlen ( session_id_prefix ) : * id_len ) ;\n }\n while ( SSL_has_matching_session_id ( ssl , id , * id_len ) && ( ++ count < MAX_SESSION_ID_ATTEMPTS ) ) ;\n if ( count >= MAX_SESSION_ID_ATTEMPTS ) return 0 ;\n return 1 ;\n }", "hash": 7106543544839418610, "project": "debian", "size": 1464, "target": 1, "idx": 21547}
{"code": "static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING ) ;\n # ifdef _MSC_VER # pragma warning ( push ) # pragma warning ( disable : 4090 ) # endif DEFINE_LHASH_OF ( OPENSSL_CSTRING )", "hash": -331579171381918893, "project": "debian", "size": 17, "target": 1, "idx": 21553}
{"code": "static ossl_inline void lh_ ## type ## _node_usage_stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_node_usage_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline void lh_ ## type ## _stats_bio ( const LHASH_OF ( type ) * lh , BIO * out ) {\n OPENSSL_LH_stats_bio ( ( const OPENSSL_LHASH * ) lh , out ) ;\n }\n static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )", "hash": -331579171381918893, "project": "debian", "size": 19, "target": 1, "idx": 21557}
{"code": "static ossl_inline unsigned long lh_ ## type ## _get_down_load ( LHASH_OF ( type ) * lh ) {\n return OPENSSL_LH_get_down_load ( ( OPENSSL_LHASH * ) lh ) ;\n }\n static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING ) ;\n # ifdef _MSC_VER # pragma warning ( push ) # pragma warning ( disable : 4090 ) # endif DEFINE_LHASH_OF ( OPENSSL_CSTRING )", "hash": -331579171381918893, "project": "debian", "size": 14, "target": 1, "idx": 21558}
{"code": "tdata_t _TIFFmalloc ( tsize_t s ) {\n if ( s == 0 ) return ( ( void * ) NULL ) ;\n return ( malloc ( ( size_t ) s ) ) ;\n }", "hash": -6468986929796051453, "project": "debian", "size": 4, "target": 1, "idx": 21562}
{"code": "void ppc_prep_init ( int ram_size , int vga_ram_size , int boot_device , DisplayState * ds , const char * * fd_filename , int snapshot , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename ) {\n char buf [ 1024 ] ;\n int PPC_io_memory ;\n int ret , linux_boot , initrd_size , i , nb_nics1 , fd ;\n linux_boot = ( kernel_filename != NULL ) ;\n cpu_register_physical_memory ( 0 , ram_size , 0 ) ;\n isa_mem_base = 0xc0000000 ;\n if ( linux_boot ) {\n ret = load_image ( kernel_filename , phys_ram_base + KERNEL_LOAD_ADDR ) ;\n if ( ret < 0 ) {\n fprintf ( stderr , \"qemu: could not load kernel '%s'\\n\" , kernel_filename ) ;\n exit ( 1 ) ;\n }\n initrd_size = 0 ;\n # if 0 if ( initrd_filename ) {\n initrd_size = load_image ( initrd_filename , phys_ram_base + INITRD_LOAD_ADDR ) ;\n if ( initrd_size < 0 ) {\n fprintf ( stderr , \"qemu: could not load initial ram disk '%s'\\n\" , initrd_filename ) ;\n exit ( 1 ) ;\n }\n }\n # endif PPC_init_hw ( ram_size , KERNEL_LOAD_ADDR , ret , KERNEL_STACK_ADDR , boot_device , initrd_filename ) ;\n }\n else {\n snprintf ( buf , sizeof ( buf ) , \"%s\" , BIOS_FILENAME ) ;\n printf ( \"load BIOS at %p\\n\" , phys_ram_base + 0x000f0000 ) ;\n ret = load_image ( buf , phys_ram_base + 0x000f0000 ) ;\n if ( ret != 0x10000 ) {\n fprintf ( stderr , \"qemu: could not load PPC bios '%s' (%d)\\n%m\\n\" , buf , ret ) ;\n exit ( 1 ) ;\n }\n }\n vga_initialize ( ds , phys_ram_base + ram_size , ram_size , vga_ram_size ) ;\n rtc_init ( 0x70 , 8 ) ;\n pic_init ( ) ;\n fd = serial_open_device ( ) ;\n serial_init ( 0x3f8 , 4 , fd ) ;\n # if 1 nb_nics1 = nb_nics ;\n if ( nb_nics1 > NE2000_NB_MAX ) nb_nics1 = NE2000_NB_MAX ;\n for ( i = 0 ;\n i < nb_nics1 ;\n i ++ ) {\n ne2000_init ( ne2000_io [ i ] , ne2000_irq [ i ] , & nd_table [ i ] ) ;\n }\n # endif for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n ide_init ( ide_iobase [ i ] , ide_iobase2 [ i ] , ide_irq [ i ] , bs_table [ 2 * i ] , bs_table [ 2 * i + 1 ] ) ;\n }\n kbd_init ( ) ;\n AUD_init ( ) ;\n DMA_init ( ) ;\n fdctrl_init ( 6 , 2 , 0 , 0x3f0 , fd_table ) ;\n PPC_io_memory = cpu_register_io_memory ( 0 , PPC_io_read , PPC_io_write ) ;\n cpu_register_physical_memory ( 0x80000000 , 0x10000 , PPC_io_memory ) ;\n register_ioport_read ( 0x398 , 2 , 1 , & PREP_io_read , NULL ) ;\n register_ioport_write ( 0x398 , 2 , 1 , & PREP_io_write , NULL ) ;\n register_ioport_write ( 0x0092 , 0x1 , 1 , & PREP_io_800_writeb , NULL ) ;\n register_ioport_read ( 0x0800 , 0x52 , 1 , & PREP_io_800_readb , NULL ) ;\n register_ioport_write ( 0x0800 , 0x52 , 1 , & PREP_io_800_writeb , NULL ) ;\n PPC_io_memory = cpu_register_io_memory ( 0 , PPC_ioB_read , PPC_ioB_write ) ;\n cpu_register_physical_memory ( 0xBFFFFFF0 , 0x4 , PPC_io_memory ) ;\n prep_NVRAM_init ( ) ;\n PPC_end_init ( ) ;\n }", "hash": 8460430819945784394, "project": "debian", "size": 65, "target": 1, "idx": 21570}
{"code": "__attribute__ ( ( format ( printf , 2 , 3 ) ) ) static int cmd_submitf ( int id , const char * fmt , ... ) {\n char cmd [ MAX_EXTERNAL_COMMAND_LENGTH ] ;\n const char * command ;\n int len , len2 ;\n va_list ap ;\n command = extcmd_get_name ( id ) ;\n len = snprintf ( cmd , sizeof ( cmd ) - 1 , \"[%lu] %s;\n\" , time ( NULL ) , command ) ;\n if ( len < 0 ) return ERROR ;\n if ( fmt ) {\n va_start ( ap , fmt ) ;\n len2 = vsnprintf ( & cmd [ len ] , sizeof ( cmd ) - len - 1 , fmt , ap ) ;\n va_end ( ap ) ;\n if ( len2 < 0 ) return ERROR ;\n }\n return write_command_to_file ( cmd ) ;\n }", "hash": 9173144338563772419, "project": "debian", "size": 17, "target": 1, "idx": 21587}
{"code": "static int parse_picture_segment ( AVCodecContext * avctx , const uint8_t * buf , int buf_size ) {\n PGSSubContext * ctx = avctx -> priv_data ;\n uint8_t sequence_desc ;\n unsigned int rle_bitmap_len , width , height ;\n uint16_t picture_id ;\n if ( buf_size <= 4 ) return - 1 ;\n buf_size -= 4 ;\n picture_id = bytestream_get_be16 ( & buf ) ;\n buf ++ ;\n sequence_desc = bytestream_get_byte ( & buf ) ;\n if ( ! ( sequence_desc & 0x80 ) ) {\n if ( buf_size > ctx -> pictures [ picture_id ] . rle_remaining_len ) return - 1 ;\n memcpy ( ctx -> pictures [ picture_id ] . rle + ctx -> pictures [ picture_id ] . rle_data_len , buf , buf_size ) ;\n ctx -> pictures [ picture_id ] . rle_data_len += buf_size ;\n ctx -> pictures [ picture_id ] . rle_remaining_len -= buf_size ;\n return 0 ;\n }\n if ( buf_size <= 7 ) return - 1 ;\n buf_size -= 7 ;\n rle_bitmap_len = bytestream_get_be24 ( & buf ) - 2 * 2 ;\n width = bytestream_get_be16 ( & buf ) ;\n height = bytestream_get_be16 ( & buf ) ;\n if ( avctx -> width < width || avctx -> height < height ) {\n av_log ( avctx , AV_LOG_ERROR , \"Bitmap dimensions larger than video.\\n\" ) ;\n return - 1 ;\n }\n ctx -> pictures [ picture_id ] . w = width ;\n ctx -> pictures [ picture_id ] . h = height ;\n av_fast_malloc ( & ctx -> pictures [ picture_id ] . rle , & ctx -> pictures [ picture_id ] . rle_buffer_size , rle_bitmap_len ) ;\n if ( ! ctx -> pictures [ picture_id ] . rle ) return - 1 ;\n memcpy ( ctx -> pictures [ picture_id ] . rle , buf , buf_size ) ;\n ctx -> pictures [ picture_id ] . rle_data_len = buf_size ;\n ctx -> pictures [ picture_id ] . rle_remaining_len = rle_bitmap_len - buf_size ;\n return 0 ;\n }", "hash": 3322961578925988960, "project": "debian", "size": 35, "target": 1, "idx": 21601}
{"code": "static int dissect_h225_CallProceeding_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 483 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_CallProceeding_UUIE , CallProceeding_UUIE_sequence ) ;\n # line 487 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_CALL_PROCEDING ;\n if ( contains_faststart == TRUE ) g_snprintf ( h225_pi -> frame_label , 50 , \"%s OLC (%s)\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) , h225_pi -> frame_label ) ;\n else g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 11, "target": 1, "idx": 21617}
{"code": "static int dissect_h225_NonStandardIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 771 \"./asn1/h225/h225.cnf\" gint32 value ;\n nsiOID = \"\" ;\n h221NonStandard = 0 ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_NonStandardIdentifier , NonStandardIdentifier_choice , & value ) ;\n switch ( value ) {\n case 0 : nsp_handle = dissector_get_string_handle ( nsp_object_dissector_table , nsiOID ) ;\n break ;\n case 1 : nsp_handle = dissector_get_uint_handle ( nsp_h221_dissector_table , h221NonStandard ) ;\n break ;\n default : nsp_handle = NULL ;\n }\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 14, "target": 1, "idx": 21622}
{"code": "static int dissect_h225_Connect_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 528 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Connect_UUIE , Connect_UUIE_sequence ) ;\n # line 532 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_CONNECT ;\n if ( contains_faststart == TRUE ) g_snprintf ( h225_pi -> frame_label , 50 , \"%s OLC (%s)\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) , h225_pi -> frame_label ) ;\n else g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 11, "target": 1, "idx": 21631}
{"code": "static int dissect_h225_T_h245Tunnelling ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 454 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n offset = dissect_per_boolean ( tvb , offset , actx , tree , hf_index , & ( h225_pi -> is_h245Tunneling ) ) ;\n # line 462 \"./asn1/h225/h225.cnf\" }\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 8, "target": 1, "idx": 21642}
{"code": "static int dissect_h225_AdmissionRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 657 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_AdmissionRejectReason , AdmissionRejectReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 10, "target": 1, "idx": 21648}
{"code": "static int dissect_h225_RequestSeqNum ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 724 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 65535U , & ( h225_pi -> requestSeqNum ) , FALSE ) ;\n # line 732 \"./asn1/h225/h225.cnf\" }\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 8, "target": 1, "idx": 21649}
{"code": "static int dissect_h225_SetupAcknowledge_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 428 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_SetupAcknowledge_UUIE , SetupAcknowledge_UUIE_sequence ) ;\n # line 432 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_SETUP_ACK ;\n g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }", "hash": 4489017523191997023, "project": "debian", "size": 10, "target": 1, "idx": 21653}
{"code": "enum nss_status CONCAT ( _nss_files_set , ENTNAME ) ( int stayopen ) {\n enum nss_status status ;\n __libc_lock_lock ( lock ) ;\n status = internal_setent ( stayopen ) ;\n if ( status == NSS_STATUS_SUCCESS && fgetpos ( stream , & position ) < 0 ) {\n fclose ( stream ) ;\n stream = NULL ;\n status = NSS_STATUS_UNAVAIL ;\n }\n last_use = getent ;\n __libc_lock_unlock ( lock ) ;\n return status ;\n }", "hash": -942846491258578486, "project": "debian", "size": 13, "target": 1, "idx": 21700}
{"code": "static PyObject * authGSSServerUserName ( PyObject * self , PyObject * args ) {\n gss_server_state * state ;\n PyObject * pystate ;\n if ( ! PyArg_ParseTuple ( args , \"O\" , & pystate ) ) return NULL ;\n # if PY_MAJOR_VERSION >= 3 if ( ! PyCapsule_CheckExact ( pystate ) ) {\n # else if ( ! PyCObject_Check ( pystate ) ) {\n # endif PyErr_SetString ( PyExc_TypeError , \"Expected a context object\" ) ;\n return NULL ;\n }\n # if PY_MAJOR_VERSION >= 3 state = PyCapsule_GetPointer ( pystate , NULL ) ;\n # else state = ( gss_client_state * ) PyCObject_AsVoidPtr ( pystate ) ;\n # endif if ( state == NULL ) return NULL ;\n return Py_BuildValue ( \"s\" , state -> username ) ;\n }", "hash": 1750726979859153417, "project": "debian", "size": 14, "target": 1, "idx": 21710}
{"code": "static byte * gs_heap_alloc_bytes ( gs_memory_t * mem , uint size , client_name_t cname ) {\n gs_malloc_memory_t * mmem = ( gs_malloc_memory_t * ) mem ;\n byte * ptr = 0 ;\n # ifdef DEBUG const char * msg ;\n static const char * const ok_msg = \"OK\" ;\n # define set_msg ( str ) ( msg = ( str ) ) # else # define set_msg ( str ) DO_NOTHING # endif if ( mmem -> monitor ) gx_monitor_enter ( mmem -> monitor ) ;\n if ( size > mmem -> limit - sizeof ( gs_malloc_block_t ) ) {\n set_msg ( \"exceeded limit\" ) ;\n }\n else {\n uint added = size + sizeof ( gs_malloc_block_t ) ;\n if ( mmem -> limit - added < mmem -> used ) set_msg ( \"exceeded limit\" ) ;\n else if ( ( ptr = ( byte * ) Memento_label ( malloc ( added ) , cname ) ) == 0 ) set_msg ( \"failed\" ) ;\n else {\n gs_malloc_block_t * bp = ( gs_malloc_block_t * ) ptr ;\n set_msg ( ok_msg ) ;\n if ( mmem -> allocated ) mmem -> allocated -> prev = bp ;\n bp -> next = mmem -> allocated ;\n bp -> prev = 0 ;\n bp -> size = size ;\n bp -> type = & st_bytes ;\n bp -> cname = cname ;\n mmem -> allocated = bp ;\n ptr = ( byte * ) ( bp + 1 ) ;\n mmem -> used += size + sizeof ( gs_malloc_block_t ) ;\n if ( mmem -> used > mmem -> max_used ) mmem -> max_used = mmem -> used ;\n }\n }\n if ( mmem -> monitor ) gx_monitor_leave ( mmem -> monitor ) ;\n if ( ptr ) gs_alloc_fill ( ptr , gs_alloc_fill_alloc , size ) ;\n # ifdef DEBUG if ( gs_debug_c ( 'a' ) || msg != ok_msg ) dmlprintf6 ( mem , \"[a+]gs_malloc(%s)(%u) = 0x%lx: %s, used=%ld, max=%ld\\n\" , client_name_string ( cname ) , size , ( ulong ) ptr , msg , mmem -> used , mmem -> max_used ) ;\n # endif return ptr ;\n # undef set_msg }", "hash": -6252714751027237823, "project": "debian", "size": 33, "target": 1, "idx": 21733}
{"code": "const char * SSL_state_string_long ( const SSL * s ) {\n const char * str ;\n switch ( s -> state ) {\n case SSL_ST_BEFORE : str = \"before SSL initialization\" ;\n break ;\n case SSL_ST_ACCEPT : str = \"before accept initialization\" ;\n break ;\n case SSL_ST_CONNECT : str = \"before connect initialization\" ;\n break ;\n case SSL_ST_OK : str = \"SSL negotiation finished successfully\" ;\n break ;\n case SSL_ST_RENEGOTIATE : str = \"SSL renegotiate ciphers\" ;\n break ;\n case SSL_ST_BEFORE | SSL_ST_CONNECT : str = \"before/connect initialization\" ;\n break ;\n case SSL_ST_OK | SSL_ST_CONNECT : str = \"ok/connect SSL initialization\" ;\n break ;\n case SSL_ST_BEFORE | SSL_ST_ACCEPT : str = \"before/accept initialization\" ;\n break ;\n case SSL_ST_OK | SSL_ST_ACCEPT : str = \"ok/accept SSL initialization\" ;\n break ;\n # ifndef OPENSSL_NO_SSL2 case SSL2_ST_CLIENT_START_ENCRYPTION : str = \"SSLv2 client start encryption\" ;\n break ;\n case SSL2_ST_SERVER_START_ENCRYPTION : str = \"SSLv2 server start encryption\" ;\n break ;\n case SSL2_ST_SEND_CLIENT_HELLO_A : str = \"SSLv2 write client hello A\" ;\n break ;\n case SSL2_ST_SEND_CLIENT_HELLO_B : str = \"SSLv2 write client hello B\" ;\n break ;\n case SSL2_ST_GET_SERVER_HELLO_A : str = \"SSLv2 read server hello A\" ;\n break ;\n case SSL2_ST_GET_SERVER_HELLO_B : str = \"SSLv2 read server hello B\" ;\n break ;\n case SSL2_ST_SEND_CLIENT_MASTER_KEY_A : str = \"SSLv2 write client master key A\" ;\n break ;\n case SSL2_ST_SEND_CLIENT_MASTER_KEY_B : str = \"SSLv2 write client master key B\" ;\n break ;\n case SSL2_ST_SEND_CLIENT_FINISHED_A : str = \"SSLv2 write client finished A\" ;\n break ;\n case SSL2_ST_SEND_CLIENT_FINISHED_B : str = \"SSLv2 write client finished B\" ;\n break ;\n case SSL2_ST_SEND_CLIENT_CERTIFICATE_A : str = \"SSLv2 write client certificate A\" ;\n break ;\n case SSL2_ST_SEND_CLIENT_CERTIFICATE_B : str = \"SSLv2 write client certificate B\" ;\n break ;\n case SSL2_ST_SEND_CLIENT_CERTIFICATE_C : str = \"SSLv2 write client certificate C\" ;\n break ;\n case SSL2_ST_SEND_CLIENT_CERTIFICATE_D : str = \"SSLv2 write client certificate D\" ;\n break ;\n case SSL2_ST_GET_SERVER_VERIFY_A : str = \"SSLv2 read server verify A\" ;\n break ;\n case SSL2_ST_GET_SERVER_VERIFY_B : str = \"SSLv2 read server verify B\" ;\n break ;\n case SSL2_ST_GET_SERVER_FINISHED_A : str = \"SSLv2 read server finished A\" ;\n break ;\n case SSL2_ST_GET_SERVER_FINISHED_B : str = \"SSLv2 read server finished B\" ;\n break ;\n case SSL2_ST_GET_CLIENT_HELLO_A : str = \"SSLv2 read client hello A\" ;\n break ;\n case SSL2_ST_GET_CLIENT_HELLO_B : str = \"SSLv2 read client hello B\" ;\n break ;\n case SSL2_ST_GET_CLIENT_HELLO_C : str = \"SSLv2 read client hello C\" ;\n break ;\n case SSL2_ST_SEND_SERVER_HELLO_A : str = \"SSLv2 write server hello A\" ;\n break ;\n case SSL2_ST_SEND_SERVER_HELLO_B : str = \"SSLv2 write server hello B\" ;\n break ;\n case SSL2_ST_GET_CLIENT_MASTER_KEY_A : str = \"SSLv2 read client master key A\" ;\n break ;\n case SSL2_ST_GET_CLIENT_MASTER_KEY_B : str = \"SSLv2 read client master key B\" ;\n break ;\n case SSL2_ST_SEND_SERVER_VERIFY_A : str = \"SSLv2 write server verify A\" ;\n break ;\n case SSL2_ST_SEND_SERVER_VERIFY_B : str = \"SSLv2 write server verify B\" ;\n break ;\n case SSL2_ST_SEND_SERVER_VERIFY_C : str = \"SSLv2 write server verify C\" ;\n break ;\n case SSL2_ST_GET_CLIENT_FINISHED_A : str = \"SSLv2 read client finished A\" ;\n break ;\n case SSL2_ST_GET_CLIENT_FINISHED_B : str = \"SSLv2 read client finished B\" ;\n break ;\n case SSL2_ST_SEND_SERVER_FINISHED_A : str = \"SSLv2 write server finished A\" ;\n break ;\n case SSL2_ST_SEND_SERVER_FINISHED_B : str = \"SSLv2 write server finished B\" ;\n break ;\n case SSL2_ST_SEND_REQUEST_CERTIFICATE_A : str = \"SSLv2 write request certificate A\" ;\n break ;\n case SSL2_ST_SEND_REQUEST_CERTIFICATE_B : str = \"SSLv2 write request certificate B\" ;\n break ;\n case SSL2_ST_SEND_REQUEST_CERTIFICATE_C : str = \"SSLv2 write request certificate C\" ;\n break ;\n case SSL2_ST_SEND_REQUEST_CERTIFICATE_D : str = \"SSLv2 write request certificate D\" ;\n break ;\n case SSL2_ST_X509_GET_SERVER_CERTIFICATE : str = \"SSLv2 X509 read server certificate\" ;\n break ;\n case SSL2_ST_X509_GET_CLIENT_CERTIFICATE : str = \"SSLv2 X509 read client certificate\" ;\n break ;\n # endif # ifndef OPENSSL_NO_SSL3 case SSL3_ST_CW_CLNT_HELLO_A : str = \"SSLv3 write client hello A\" ;\n break ;\n case SSL3_ST_CW_CLNT_HELLO_B : str = \"SSLv3 write client hello B\" ;\n break ;\n case SSL3_ST_CR_SRVR_HELLO_A : str = \"SSLv3 read server hello A\" ;\n break ;\n case SSL3_ST_CR_SRVR_HELLO_B : str = \"SSLv3 read server hello B\" ;\n break ;\n case SSL3_ST_CR_CERT_A : str = \"SSLv3 read server certificate A\" ;\n break ;\n case SSL3_ST_CR_CERT_B : str = \"SSLv3 read server certificate B\" ;\n break ;\n case SSL3_ST_CR_KEY_EXCH_A : str = \"SSLv3 read server key exchange A\" ;\n break ;\n case SSL3_ST_CR_KEY_EXCH_B : str = \"SSLv3 read server key exchange B\" ;\n break ;\n case SSL3_ST_CR_CERT_REQ_A : str = \"SSLv3 read server certificate request A\" ;\n break ;\n case SSL3_ST_CR_CERT_REQ_B : str = \"SSLv3 read server certificate request B\" ;\n break ;\n case SSL3_ST_CR_SESSION_TICKET_A : str = \"SSLv3 read server session ticket A\" ;\n break ;\n case SSL3_ST_CR_SESSION_TICKET_B : str = \"SSLv3 read server session ticket B\" ;\n break ;\n case SSL3_ST_CR_SRVR_DONE_A : str = \"SSLv3 read server done A\" ;\n break ;\n case SSL3_ST_CR_SRVR_DONE_B : str = \"SSLv3 read server done B\" ;\n break ;\n case SSL3_ST_CW_CERT_A : str = \"SSLv3 write client certificate A\" ;\n break ;\n case SSL3_ST_CW_CERT_B : str = \"SSLv3 write client certificate B\" ;\n break ;\n case SSL3_ST_CW_CERT_C : str = \"SSLv3 write client certificate C\" ;\n break ;\n case SSL3_ST_CW_CERT_D : str = \"SSLv3 write client certificate D\" ;\n break ;\n case SSL3_ST_CW_KEY_EXCH_A : str = \"SSLv3 write client key exchange A\" ;\n break ;\n case SSL3_ST_CW_KEY_EXCH_B : str = \"SSLv3 write client key exchange B\" ;\n break ;\n case SSL3_ST_CW_CERT_VRFY_A : str = \"SSLv3 write certificate verify A\" ;\n break ;\n case SSL3_ST_CW_CERT_VRFY_B : str = \"SSLv3 write certificate verify B\" ;\n break ;\n case SSL3_ST_CW_CHANGE_A : case SSL3_ST_SW_CHANGE_A : str = \"SSLv3 write change cipher spec A\" ;\n break ;\n case SSL3_ST_CW_CHANGE_B : case SSL3_ST_SW_CHANGE_B : str = \"SSLv3 write change cipher spec B\" ;\n break ;\n case SSL3_ST_CW_FINISHED_A : case SSL3_ST_SW_FINISHED_A : str = \"SSLv3 write finished A\" ;\n break ;\n case SSL3_ST_CW_FINISHED_B : case SSL3_ST_SW_FINISHED_B : str = \"SSLv3 write finished B\" ;\n break ;\n case SSL3_ST_CR_CHANGE_A : case SSL3_ST_SR_CHANGE_A : str = \"SSLv3 read change cipher spec A\" ;\n break ;\n case SSL3_ST_CR_CHANGE_B : case SSL3_ST_SR_CHANGE_B : str = \"SSLv3 read change cipher spec B\" ;\n break ;\n case SSL3_ST_CR_FINISHED_A : case SSL3_ST_SR_FINISHED_A : str = \"SSLv3 read finished A\" ;\n break ;\n case SSL3_ST_CR_FINISHED_B : case SSL3_ST_SR_FINISHED_B : str = \"SSLv3 read finished B\" ;\n break ;\n case SSL3_ST_CW_FLUSH : case SSL3_ST_SW_FLUSH : str = \"SSLv3 flush data\" ;\n break ;\n case SSL3_ST_SR_CLNT_HELLO_A : str = \"SSLv3 read client hello A\" ;\n break ;\n case SSL3_ST_SR_CLNT_HELLO_B : str = \"SSLv3 read client hello B\" ;\n break ;\n case SSL3_ST_SR_CLNT_HELLO_C : str = \"SSLv3 read client hello C\" ;\n break ;\n case SSL3_ST_SW_HELLO_REQ_A : str = \"SSLv3 write hello request A\" ;\n break ;\n case SSL3_ST_SW_HELLO_REQ_B : str = \"SSLv3 write hello request B\" ;\n break ;\n case SSL3_ST_SW_HELLO_REQ_C : str = \"SSLv3 write hello request C\" ;\n break ;\n case SSL3_ST_SW_SRVR_HELLO_A : str = \"SSLv3 write server hello A\" ;\n break ;\n case SSL3_ST_SW_SRVR_HELLO_B : str = \"SSLv3 write server hello B\" ;\n break ;\n case SSL3_ST_SW_CERT_A : str = \"SSLv3 write certificate A\" ;\n break ;\n case SSL3_ST_SW_CERT_B : str = \"SSLv3 write certificate B\" ;\n break ;\n case SSL3_ST_SW_KEY_EXCH_A : str = \"SSLv3 write key exchange A\" ;\n break ;\n case SSL3_ST_SW_KEY_EXCH_B : str = \"SSLv3 write key exchange B\" ;\n break ;\n case SSL3_ST_SW_CERT_REQ_A : str = \"SSLv3 write certificate request A\" ;\n break ;\n case SSL3_ST_SW_CERT_REQ_B : str = \"SSLv3 write certificate request B\" ;\n break ;\n case SSL3_ST_SW_SESSION_TICKET_A : str = \"SSLv3 write session ticket A\" ;\n break ;\n case SSL3_ST_SW_SESSION_TICKET_B : str = \"SSLv3 write session ticket B\" ;\n break ;\n case SSL3_ST_SW_SRVR_DONE_A : str = \"SSLv3 write server done A\" ;\n break ;\n case SSL3_ST_SW_SRVR_DONE_B : str = \"SSLv3 write server done B\" ;\n break ;\n case SSL3_ST_SR_CERT_A : str = \"SSLv3 read client certificate A\" ;\n break ;\n case SSL3_ST_SR_CERT_B : str = \"SSLv3 read client certificate B\" ;\n break ;\n case SSL3_ST_SR_KEY_EXCH_A : str = \"SSLv3 read client key exchange A\" ;\n break ;\n case SSL3_ST_SR_KEY_EXCH_B : str = \"SSLv3 read client key exchange B\" ;\n break ;\n case SSL3_ST_SR_CERT_VRFY_A : str = \"SSLv3 read certificate verify A\" ;\n break ;\n case SSL3_ST_SR_CERT_VRFY_B : str = \"SSLv3 read certificate verify B\" ;\n break ;\n # endif case SSL23_ST_CW_CLNT_HELLO_A : str = \"SSLv2/v3 write client hello A\" ;\n break ;\n case SSL23_ST_CW_CLNT_HELLO_B : str = \"SSLv2/v3 write client hello B\" ;\n break ;\n case SSL23_ST_CR_SRVR_HELLO_A : str = \"SSLv2/v3 read server hello A\" ;\n break ;\n case SSL23_ST_CR_SRVR_HELLO_B : str = \"SSLv2/v3 read server hello B\" ;\n break ;\n case SSL23_ST_SR_CLNT_HELLO_A : str = \"SSLv2/v3 read client hello A\" ;\n break ;\n case SSL23_ST_SR_CLNT_HELLO_B : str = \"SSLv2/v3 read client hello B\" ;\n break ;\n case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A : str = \"DTLS1 read hello verify request A\" ;\n break ;\n case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B : str = \"DTLS1 read hello verify request B\" ;\n break ;\n case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A : str = \"DTLS1 write hello verify request A\" ;\n break ;\n case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B : str = \"DTLS1 write hello verify request B\" ;\n break ;\n default : str = \"unknown state\" ;\n break ;\n }\n return ( str ) ;\n }", "hash": 6380456053173444622, "project": "debian", "size": 232, "target": 1, "idx": 21742}
{"code": "bool chal_reply_h ( connection_t * c ) {\n char hishash [ MAX_STRING_SIZE ] ;\n char myhash [ EVP_MAX_MD_SIZE ] ;\n EVP_MD_CTX * ctx ;\n if ( sscanf ( c -> buffer , \"%*d \" MAX_STRING , hishash ) != 1 ) {\n logger ( LOG_ERR , \"Got bad %s from %s (%s)\" , \"CHAL_REPLY\" , c -> name , c -> hostname ) ;\n return false ;\n }\n if ( strlen ( hishash ) != ( size_t ) EVP_MD_size ( c -> outdigest ) * 2 ) {\n logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong challenge reply length\" ) ;\n return false ;\n }\n if ( ! hex2bin ( hishash , hishash , EVP_MD_size ( c -> outdigest ) ) ) {\n logger ( LOG_ERR , \"Got bad %s from %s(%s): %s\" , \"CHAL_REPLY\" , c -> name , c -> hostname , \"invalid hash\" ) ;\n return false ;\n }\n ctx = EVP_MD_CTX_create ( ) ;\n if ( ! ctx ) {\n abort ( ) ;\n }\n if ( ! EVP_DigestInit ( ctx , c -> outdigest ) || ! EVP_DigestUpdate ( ctx , c -> hischallenge , RSA_size ( c -> rsa_key ) ) || ! EVP_DigestFinal ( ctx , ( unsigned char * ) myhash , NULL ) ) {\n EVP_MD_CTX_destroy ( ctx ) ;\n logger ( LOG_ERR , \"Error during calculation of response from %s (%s): %s\" , c -> name , c -> hostname , ERR_error_string ( ERR_get_error ( ) , NULL ) ) ;\n return false ;\n }\n EVP_MD_CTX_destroy ( ctx ) ;\n if ( memcmp ( hishash , myhash , EVP_MD_size ( c -> outdigest ) ) ) {\n logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong challenge reply\" ) ;\n ifdebug ( SCARY_THINGS ) {\n bin2hex ( myhash , hishash , SHA_DIGEST_LENGTH ) ;\n hishash [ SHA_DIGEST_LENGTH * 2 ] = '\\0' ;\n logger ( LOG_DEBUG , \"Expected challenge reply: %s\" , hishash ) ;\n }\n return false ;\n }\n c -> allow_request = ACK ;\n return send_ack ( c ) ;\n }", "hash": 4372812923566076695, "project": "debian", "size": 38, "target": 1, "idx": 21747}
{"code": "int BIO_vprintf ( BIO * bio , const char * format , va_list args ) {\n int ret ;\n size_t retlen ;\n char hugebuf [ 1024 * 2 ] ;\n char * hugebufp = hugebuf ;\n size_t hugebufsize = sizeof ( hugebuf ) ;\n char * dynbuf = NULL ;\n int ignored ;\n dynbuf = NULL ;\n CRYPTO_push_info ( \"doapr()\" ) ;\n _dopr ( & hugebufp , & dynbuf , & hugebufsize , & retlen , & ignored , format , args ) ;\n if ( dynbuf ) {\n ret = BIO_write ( bio , dynbuf , ( int ) retlen ) ;\n OPENSSL_free ( dynbuf ) ;\n }\n else {\n ret = BIO_write ( bio , hugebuf , ( int ) retlen ) ;\n }\n CRYPTO_pop_info ( ) ;\n return ( ret ) ;\n }", "hash": -789251383577298283, "project": "debian", "size": 21, "target": 1, "idx": 21768}
{"code": "int BIO_vsnprintf ( char * buf , size_t n , const char * format , va_list args ) {\n size_t retlen ;\n int truncated ;\n _dopr ( & buf , NULL , & n , & retlen , & truncated , format , args ) ;\n if ( truncated ) return - 1 ;\n else return ( retlen <= INT_MAX ) ? ( int ) retlen : - 1 ;\n }", "hash": -789251383577298283, "project": "debian", "size": 7, "target": 1, "idx": 21769}
{"code": "static void output ( code_int code , GifCtx * ctx ) {\n ctx -> cur_accum &= masks [ ctx -> cur_bits ] ;\n if ( ctx -> cur_bits > 0 ) {\n ctx -> cur_accum |= ( ( long ) code << ctx -> cur_bits ) ;\n }\n else {\n ctx -> cur_accum = code ;\n }\n ctx -> cur_bits += ctx -> n_bits ;\n while ( ctx -> cur_bits >= 8 ) {\n char_out ( ( unsigned int ) ( ctx -> cur_accum & 0xff ) , ctx ) ;\n ctx -> cur_accum >>= 8 ;\n ctx -> cur_bits -= 8 ;\n }\n if ( ctx -> free_ent > ctx -> maxcode || ctx -> clear_flg ) {\n if ( ctx -> clear_flg ) {\n ctx -> maxcode = MAXCODE ( ctx -> n_bits = ctx -> g_init_bits ) ;\n ctx -> clear_flg = 0 ;\n }\n else {\n ++ ( ctx -> n_bits ) ;\n if ( ctx -> n_bits == maxbits ) {\n ctx -> maxcode = maxmaxcode ;\n }\n else {\n ctx -> maxcode = MAXCODE ( ctx -> n_bits ) ;\n }\n }\n }\n if ( code == ctx -> EOFCode ) {\n while ( ctx -> cur_bits > 0 ) {\n char_out ( ( unsigned int ) ( ctx -> cur_accum & 0xff ) , ctx ) ;\n ctx -> cur_accum >>= 8 ;\n ctx -> cur_bits -= 8 ;\n }\n flush_char ( ctx ) ;\n }\n }", "hash": 5452557062588481527, "project": "debian", "size": 38, "target": 1, "idx": 21780}
{"code": "static int dissect_mac_fdd_fach ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n guint8 hdr , tctf ;\n guint16 bitoffs = 0 ;\n guint16 tctf_len , chan ;\n proto_tree * fach_tree = NULL ;\n proto_item * channel_type ;\n tvbuff_t * next_tvb ;\n umts_mac_info * macinf ;\n fp_info * fpinf ;\n rlc_info * rlcinf ;\n struct rrc_info * rrcinf ;\n proto_item * ti = NULL ;\n gint c_t ;\n hdr = tvb_get_guint8 ( tvb , 0 ) ;\n tctf = fach_fdd_tctf ( hdr , & bitoffs ) ;\n tctf_len = bitoffs ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"MAC\" ) ;\n col_set_str ( pinfo -> cinfo , COL_INFO , val_to_str_const ( tctf , fach_fdd_tctf_vals , \"Unknown TCTF\" ) ) ;\n ti = proto_tree_add_item ( tree , proto_umts_mac , tvb , 0 , - 1 , ENC_NA ) ;\n fach_tree = proto_item_add_subtree ( ti , ett_mac_fach ) ;\n macinf = ( umts_mac_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 ) ;\n fpinf = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 ) ;\n rlcinf = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 ) ;\n if ( ! macinf || ! fpinf ) {\n proto_tree_add_expert ( fach_tree , pinfo , & ei_mac_per_frame_info_missing , tvb , 0 , - 1 ) ;\n return 1 ;\n }\n proto_tree_add_bits_item ( fach_tree , hf_mac_fach_fdd_tctf , tvb , 0 , tctf_len , ENC_BIG_ENDIAN ) ;\n if ( tctf == TCTF_DCCH_DTCH_FACH_FDD ) {\n macinf -> ctmux [ fpinf -> cur_tb ] = 1 ;\n bitoffs = tree_add_common_dcch_dtch_fields ( tvb , pinfo , fach_tree , bitoffs , fpinf , macinf , rlcinf ) ;\n }\n chan = fpinf -> cur_chan ;\n switch ( tctf ) {\n case TCTF_CCCH_FACH_FDD : proto_item_append_text ( ti , \" (CCCH)\" ) ;\n channel_type = proto_tree_add_uint ( fach_tree , hf_mac_channel , tvb , 0 , 0 , MAC_CCCH ) ;\n PROTO_ITEM_SET_GENERATED ( channel_type ) ;\n next_tvb = tvb_new_subset_remaining ( tvb , 1 ) ;\n call_dissector_with_data ( rlc_ccch_handle , next_tvb , pinfo , tree , data ) ;\n break ;\n case TCTF_DCCH_DTCH_FACH_FDD : c_t = tvb_get_bits8 ( tvb , bitoffs - 4 , 4 ) ;\n rlcinf -> mode [ fpinf -> cur_tb ] = lchId_rlc_map [ c_t + 1 ] ;\n macinf -> content [ fpinf -> cur_tb ] = lchId_type_table [ c_t + 1 ] ;\n switch ( macinf -> content [ fpinf -> cur_tb ] ) {\n case MAC_CONTENT_DCCH : proto_item_append_text ( ti , \" (DCCH)\" ) ;\n channel_type = proto_tree_add_uint ( fach_tree , hf_mac_channel , tvb , 0 , 0 , MAC_DCCH ) ;\n PROTO_ITEM_SET_GENERATED ( channel_type ) ;\n next_tvb = tvb_new_octet_aligned ( tvb , bitoffs , fpinf -> chan_tf_size [ chan ] - bitoffs ) ;\n add_new_data_source ( pinfo , next_tvb , \"Octet-Aligned DCCH Data\" ) ;\n call_dissector_with_data ( rlc_dcch_handle , next_tvb , pinfo , tree , data ) ;\n break ;\n case MAC_CONTENT_PS_DTCH : proto_item_append_text ( ti , \" (PS DTCH)\" ) ;\n channel_type = proto_tree_add_uint ( fach_tree , hf_mac_channel , tvb , 0 , 0 , MAC_DTCH ) ;\n PROTO_ITEM_SET_GENERATED ( channel_type ) ;\n next_tvb = tvb_new_octet_aligned ( tvb , bitoffs , fpinf -> chan_tf_size [ chan ] - bitoffs ) ;\n add_new_data_source ( pinfo , next_tvb , \"Octet-Aligned DCCH Data\" ) ;\n call_dissector_with_data ( rlc_ps_dtch_handle , next_tvb , pinfo , tree , data ) ;\n break ;\n case MAC_CONTENT_CS_DTCH : proto_item_append_text ( ti , \" (CS DTCH)\" ) ;\n expert_add_info ( pinfo , NULL , & ei_mac_cs_dtch_not_implemented ) ;\n break ;\n default : proto_item_append_text ( ti , \" (Unknown FACH Content\" ) ;\n expert_add_info_format ( pinfo , NULL , & ei_mac_unknown_content , \"Unknown FACH Content for this transportblock\" ) ;\n }\n break ;\n case TCTF_CTCH_FACH_FDD : proto_item_append_text ( ti , \" (CTCH)\" ) ;\n channel_type = proto_tree_add_uint ( fach_tree , hf_mac_channel , tvb , 0 , 0 , MAC_CTCH ) ;\n PROTO_ITEM_SET_GENERATED ( channel_type ) ;\n next_tvb = tvb_new_subset_remaining ( tvb , 1 ) ;\n call_dissector_with_data ( rlc_ctch_handle , next_tvb , pinfo , tree , data ) ;\n break ;\n case TCTF_BCCH_FACH_FDD : proto_item_append_text ( ti , \" (BCCH)\" ) ;\n channel_type = proto_tree_add_uint ( fach_tree , hf_mac_channel , tvb , 0 , 0 , MAC_BCCH ) ;\n PROTO_ITEM_SET_GENERATED ( channel_type ) ;\n next_tvb = tvb_new_octet_aligned ( tvb , 2 , ( tvb_reported_length ( tvb ) * 8 ) - 2 ) ;\n add_new_data_source ( pinfo , next_tvb , \"Octet-Aligned BCCH Data\" ) ;\n rrcinf = ( rrc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rrc , 0 ) ;\n if ( ! rrcinf ) {\n rrcinf = wmem_new0 ( wmem_file_scope ( ) , struct rrc_info ) ;\n p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rrc , 0 , rrcinf ) ;\n }\n rrcinf -> msgtype [ fpinf -> cur_tb ] = RRC_MESSAGE_TYPE_BCCH_FACH ;\n call_dissector_with_data ( rrc_handle , next_tvb , pinfo , tree , data ) ;\n break ;\n case TCTF_MSCH_FACH_FDD : case TCTF_MCCH_FACH_FDD : case TCTF_MTCH_FACH_FDD : expert_add_info ( pinfo , NULL , & ei_mac_fach_content_type_unknown ) ;\n break ;\n default : proto_item_append_text ( ti , \" (Unknown FACH Content)\" ) ;\n expert_add_info_format ( pinfo , NULL , & ei_mac_unknown_content , \" Unknown FACH Content\" ) ;\n break ;\n }\n return tvb_captured_length ( tvb ) ;\n }", "hash": 1742637512846796448, "project": "debian", "size": 92, "target": 1, "idx": 21796}
{"code": "proto_item * proto_tree_add_text_internal ( proto_tree * tree , tvbuff_t * tvb , gint start , gint length , const char * format , ... ) {\n proto_item * pi ;\n va_list ap ;\n header_field_info * hfinfo ;\n CHECK_FOR_NULL_TREE ( tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( tree , hf_text_only , hfinfo ) ;\n pi = proto_tree_add_text_node ( tree , tvb , start , length ) ;\n TRY_TO_FAKE_THIS_REPR ( pi ) ;\n va_start ( ap , format ) ;\n proto_tree_set_representation ( pi , format , ap ) ;\n va_end ( ap ) ;\n return pi ;\n }", "hash": -1315695702746584250, "project": "debian", "size": 13, "target": 1, "idx": 21803}
{"code": "static void f_parser ( lua_State * L , void * ud ) {\n int i ;\n Proto * tf ;\n Closure * cl ;\n struct SParser * p = cast ( struct SParser * , ud ) ;\n int c = luaZ_lookahead ( p -> z ) ;\n luaC_checkGC ( L ) ;\n tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z , & p -> buff , p -> name ) ;\n cl = luaF_newLclosure ( L , tf -> nups , hvalue ( gt ( L ) ) ) ;\n cl -> l . p = tf ;\n for ( i = 0 ;\n i < tf -> nups ;\n i ++ ) cl -> l . upvals [ i ] = luaF_newupval ( L ) ;\n setclvalue ( L , L -> top , cl ) ;\n incr_top ( L ) ;\n }", "hash": -5357254031401749470, "project": "debian", "size": 16, "target": 1, "idx": 21806}
{"code": "static void tb_invalidate_phys_page ( tb_page_addr_t addr , uintptr_t pc , void * puc ) {\n TranslationBlock * tb ;\n PageDesc * p ;\n int n ;\n # ifdef TARGET_HAS_PRECISE_SMC TranslationBlock * current_tb = NULL ;\n CPUArchState * env = cpu_single_env ;\n CPUState * cpu = NULL ;\n int current_tb_modified = 0 ;\n target_ulong current_pc = 0 ;\n target_ulong current_cs_base = 0 ;\n int current_flags = 0 ;\n # endif addr &= TARGET_PAGE_MASK ;\n p = page_find ( addr >> TARGET_PAGE_BITS ) ;\n if ( ! p ) {\n return ;\n }\n tb = p -> first_tb ;\n # ifdef TARGET_HAS_PRECISE_SMC if ( tb && pc != 0 ) {\n current_tb = tb_find_pc ( pc ) ;\n }\n if ( env != NULL ) {\n cpu = ENV_GET_CPU ( env ) ;\n }\n # endif while ( tb != NULL ) {\n n = ( uintptr_t ) tb & 3 ;\n tb = ( TranslationBlock * ) ( ( uintptr_t ) tb & ~ 3 ) ;\n # ifdef TARGET_HAS_PRECISE_SMC if ( current_tb == tb && ( current_tb -> cflags & CF_COUNT_MASK ) != 1 ) {\n current_tb_modified = 1 ;\n cpu_restore_state_from_tb ( current_tb , env , pc ) ;\n cpu_get_tb_cpu_state ( env , & current_pc , & current_cs_base , & current_flags ) ;\n }\n # endif tb_phys_invalidate ( tb , addr ) ;\n tb = tb -> page_next [ n ] ;\n }\n p -> first_tb = NULL ;\n # ifdef TARGET_HAS_PRECISE_SMC if ( current_tb_modified ) {\n cpu -> current_tb = NULL ;\n tb_gen_code ( env , current_pc , current_cs_base , current_flags , 1 ) ;\n cpu_resume_from_signal ( env , puc ) ;\n }\n # endif }", "hash": 1458662858915721428, "project": "debian", "size": 41, "target": 1, "idx": 21810}
{"code": "void tb_invalidate_phys_page_range ( tb_page_addr_t start , tb_page_addr_t end , int is_cpu_write_access ) {\n TranslationBlock * tb , * tb_next , * saved_tb ;\n CPUArchState * env = cpu_single_env ;\n CPUState * cpu = NULL ;\n tb_page_addr_t tb_start , tb_end ;\n PageDesc * p ;\n int n ;\n # ifdef TARGET_HAS_PRECISE_SMC int current_tb_not_found = is_cpu_write_access ;\n TranslationBlock * current_tb = NULL ;\n int current_tb_modified = 0 ;\n target_ulong current_pc = 0 ;\n target_ulong current_cs_base = 0 ;\n int current_flags = 0 ;\n # endif p = page_find ( start >> TARGET_PAGE_BITS ) ;\n if ( ! p ) {\n return ;\n }\n if ( ! p -> code_bitmap && ++ p -> code_write_count >= SMC_BITMAP_USE_THRESHOLD && is_cpu_write_access ) {\n build_page_bitmap ( p ) ;\n }\n if ( env != NULL ) {\n cpu = ENV_GET_CPU ( env ) ;\n }\n tb = p -> first_tb ;\n while ( tb != NULL ) {\n n = ( uintptr_t ) tb & 3 ;\n tb = ( TranslationBlock * ) ( ( uintptr_t ) tb & ~ 3 ) ;\n tb_next = tb -> page_next [ n ] ;\n if ( n == 0 ) {\n tb_start = tb -> page_addr [ 0 ] + ( tb -> pc & ~ TARGET_PAGE_MASK ) ;\n tb_end = tb_start + tb -> size ;\n }\n else {\n tb_start = tb -> page_addr [ 1 ] ;\n tb_end = tb_start + ( ( tb -> pc + tb -> size ) & ~ TARGET_PAGE_MASK ) ;\n }\n if ( ! ( tb_end <= start || tb_start >= end ) ) {\n # ifdef TARGET_HAS_PRECISE_SMC if ( current_tb_not_found ) {\n current_tb_not_found = 0 ;\n current_tb = NULL ;\n if ( env -> mem_io_pc ) {\n current_tb = tb_find_pc ( env -> mem_io_pc ) ;\n }\n }\n if ( current_tb == tb && ( current_tb -> cflags & CF_COUNT_MASK ) != 1 ) {\n current_tb_modified = 1 ;\n cpu_restore_state_from_tb ( current_tb , env , env -> mem_io_pc ) ;\n cpu_get_tb_cpu_state ( env , & current_pc , & current_cs_base , & current_flags ) ;\n }\n # endif saved_tb = NULL ;\n if ( cpu != NULL ) {\n saved_tb = cpu -> current_tb ;\n cpu -> current_tb = NULL ;\n }\n tb_phys_invalidate ( tb , - 1 ) ;\n if ( cpu != NULL ) {\n cpu -> current_tb = saved_tb ;\n if ( cpu -> interrupt_request && cpu -> current_tb ) {\n cpu_interrupt ( cpu , cpu -> interrupt_request ) ;\n }\n }\n }\n tb = tb_next ;\n }\n # if ! defined ( CONFIG_USER_ONLY ) if ( ! p -> first_tb ) {\n invalidate_page_bitmap ( p ) ;\n if ( is_cpu_write_access ) {\n tlb_unprotect_code_phys ( env , start , env -> mem_io_vaddr ) ;\n }\n }\n # endif # ifdef TARGET_HAS_PRECISE_SMC if ( current_tb_modified ) {\n cpu -> current_tb = NULL ;\n tb_gen_code ( env , current_pc , current_cs_base , current_flags , 1 ) ;\n cpu_resume_from_signal ( env , NULL ) ;\n }\n # endif }", "hash": 1458662858915721428, "project": "debian", "size": 76, "target": 1, "idx": 21811}
{"code": "static uint64_t mpc8544_guts_read ( void * opaque , hwaddr addr , unsigned size ) {\n uint32_t value = 0 ;\n CPUPPCState * env = cpu_single_env ;\n addr &= MPC8544_GUTS_MMIO_SIZE - 1 ;\n switch ( addr ) {\n case MPC8544_GUTS_ADDR_PVR : value = env -> spr [ SPR_PVR ] ;\n break ;\n case MPC8544_GUTS_ADDR_SVR : value = env -> spr [ SPR_E500_SVR ] ;\n break ;\n default : fprintf ( stderr , \"guts: Unknown register read: %x\\n\" , ( int ) addr ) ;\n break ;\n }\n return value ;\n }", "hash": -4978182697885785366, "project": "debian", "size": 14, "target": 1, "idx": 21818}
{"code": "static int get_current_cpu ( void ) {\n CPUState * cpu_single_cpu ;\n if ( ! cpu_single_env ) {\n return - 1 ;\n }\n cpu_single_cpu = ENV_GET_CPU ( cpu_single_env ) ;\n return cpu_single_cpu -> cpu_index ;\n }", "hash": -1919011628477388936, "project": "debian", "size": 8, "target": 1, "idx": 21824}
{"code": "static uint32_t vmport_cmd_get_version ( void * opaque , uint32_t addr ) {\n CPUX86State * env = cpu_single_env ;\n env -> regs [ R_EBX ] = VMPORT_MAGIC ;\n return 6 ;\n }", "hash": 3528176083733952042, "project": "debian", "size": 5, "target": 1, "idx": 21836}
{"code": "void stp_print ( netdissect_options * ndo , const u_char * p , u_int length ) {\n const struct stp_bpdu_ * stp_bpdu ;\n u_int mstp_len ;\n u_int spb_len ;\n stp_bpdu = ( const struct stp_bpdu_ * ) p ;\n if ( length < 4 ) goto trunc ;\n ND_TCHECK ( stp_bpdu -> protocol_id ) ;\n if ( EXTRACT_16BITS ( & stp_bpdu -> protocol_id ) ) {\n ND_PRINT ( ( ndo , \"unknown STP version, length %u\" , length ) ) ;\n return ;\n }\n ND_TCHECK ( stp_bpdu -> protocol_version ) ;\n ND_PRINT ( ( ndo , \"STP %s\" , tok2str ( stp_proto_values , \"Unknown STP protocol (0x%02x)\" , stp_bpdu -> protocol_version ) ) ) ;\n switch ( stp_bpdu -> protocol_version ) {\n case STP_PROTO_REGULAR : case STP_PROTO_RAPID : case STP_PROTO_MSTP : case STP_PROTO_SPB : break ;\n default : return ;\n }\n ND_TCHECK ( stp_bpdu -> bpdu_type ) ;\n ND_PRINT ( ( ndo , \", %s\" , tok2str ( stp_bpdu_type_values , \"Unknown BPDU Type (0x%02x)\" , stp_bpdu -> bpdu_type ) ) ) ;\n switch ( stp_bpdu -> bpdu_type ) {\n case STP_BPDU_TYPE_CONFIG : if ( length < sizeof ( struct stp_bpdu_ ) - 1 ) {\n goto trunc ;\n }\n if ( ! stp_print_config_bpdu ( ndo , stp_bpdu , length ) ) goto trunc ;\n break ;\n case STP_BPDU_TYPE_RSTP : if ( stp_bpdu -> protocol_version == STP_PROTO_RAPID ) {\n if ( length < sizeof ( struct stp_bpdu_ ) ) {\n goto trunc ;\n }\n if ( ! stp_print_config_bpdu ( ndo , stp_bpdu , length ) ) goto trunc ;\n }\n else if ( stp_bpdu -> protocol_version == STP_PROTO_MSTP || stp_bpdu -> protocol_version == STP_PROTO_SPB ) {\n if ( length < STP_BPDU_MSTP_MIN_LEN ) {\n goto trunc ;\n }\n ND_TCHECK ( stp_bpdu -> v1_length ) ;\n if ( stp_bpdu -> v1_length != 0 ) {\n goto trunc ;\n }\n ND_TCHECK_16BITS ( p + MST_BPDU_VER3_LEN_OFFSET ) ;\n mstp_len = EXTRACT_16BITS ( p + MST_BPDU_VER3_LEN_OFFSET ) ;\n mstp_len += 2 ;\n if ( length < ( sizeof ( struct stp_bpdu_ ) + mstp_len ) ) {\n goto trunc ;\n }\n if ( ! stp_print_mstp_bpdu ( ndo , stp_bpdu , length ) ) goto trunc ;\n if ( stp_bpdu -> protocol_version == STP_PROTO_SPB ) {\n spb_len = EXTRACT_16BITS ( p + MST_BPDU_VER3_LEN_OFFSET + mstp_len ) ;\n spb_len += 2 ;\n if ( length < ( sizeof ( struct stp_bpdu_ ) + mstp_len + spb_len ) || spb_len < SPB_BPDU_MIN_LEN ) {\n goto trunc ;\n }\n if ( ! stp_print_spb_bpdu ( ndo , stp_bpdu , ( sizeof ( struct stp_bpdu_ ) + mstp_len ) ) ) goto trunc ;\n }\n }\n break ;\n case STP_BPDU_TYPE_TOPO_CHANGE : break ;\n default : break ;\n }\n return ;\n trunc : ND_PRINT ( ( ndo , \"[|stp %d]\" , length ) ) ;\n }", "hash": -2971164434690241379, "project": "debian", "size": 62, "target": 1, "idx": 21843}
{"code": "static VALUE ossl_cipher_update ( int argc , VALUE * argv , VALUE self ) {\n EVP_CIPHER_CTX * ctx ;\n unsigned char * in ;\n long in_len , out_len ;\n VALUE data , str ;\n rb_scan_args ( argc , argv , \"11\" , & data , & str ) ;\n StringValue ( data ) ;\n in = ( unsigned char * ) RSTRING_PTR ( data ) ;\n if ( ( in_len = RSTRING_LEN ( data ) ) == 0 ) ossl_raise ( rb_eArgError , \"data must not be empty\" ) ;\n GetCipher ( self , ctx ) ;\n out_len = in_len + EVP_CIPHER_CTX_block_size ( ctx ) ;\n if ( out_len <= 0 ) {\n ossl_raise ( rb_eRangeError , \"data too big to make output buffer: %ld bytes\" , in_len ) ;\n }\n if ( NIL_P ( str ) ) {\n str = rb_str_new ( 0 , out_len ) ;\n }\n else {\n StringValue ( str ) ;\n rb_str_resize ( str , out_len ) ;\n }\n if ( ! ossl_cipher_update_long ( ctx , ( unsigned char * ) RSTRING_PTR ( str ) , & out_len , in , in_len ) ) ossl_raise ( eCipherError , NULL ) ;\n assert ( out_len < RSTRING_LEN ( str ) ) ;\n rb_str_set_len ( str , out_len ) ;\n return str ;\n }", "hash": 1896723564367514490, "project": "debian", "size": 26, "target": 1, "idx": 21849}
{"code": "void Init_ossl_cipher ( void ) {\n # if 0 mOSSL = rb_define_module ( \"OpenSSL\" ) ;\n eOSSLError = rb_define_class_under ( mOSSL , \"OpenSSLError\" , rb_eStandardError ) ;\n # endif cCipher = rb_define_class_under ( mOSSL , \"Cipher\" , rb_cObject ) ;\n eCipherError = rb_define_class_under ( cCipher , \"CipherError\" , eOSSLError ) ;\n rb_define_alloc_func ( cCipher , ossl_cipher_alloc ) ;\n rb_define_copy_func ( cCipher , ossl_cipher_copy ) ;\n rb_define_module_function ( cCipher , \"ciphers\" , ossl_s_ciphers , 0 ) ;\n rb_define_method ( cCipher , \"initialize\" , ossl_cipher_initialize , 1 ) ;\n rb_define_method ( cCipher , \"reset\" , ossl_cipher_reset , 0 ) ;\n rb_define_method ( cCipher , \"encrypt\" , ossl_cipher_encrypt , - 1 ) ;\n rb_define_method ( cCipher , \"decrypt\" , ossl_cipher_decrypt , - 1 ) ;\n rb_define_method ( cCipher , \"pkcs5_keyivgen\" , ossl_cipher_pkcs5_keyivgen , - 1 ) ;\n rb_define_method ( cCipher , \"update\" , ossl_cipher_update , - 1 ) ;\n rb_define_method ( cCipher , \"final\" , ossl_cipher_final , 0 ) ;\n rb_define_method ( cCipher , \"name\" , ossl_cipher_name , 0 ) ;\n rb_define_method ( cCipher , \"key=\" , ossl_cipher_set_key , 1 ) ;\n rb_define_method ( cCipher , \"auth_data=\" , ossl_cipher_set_auth_data , 1 ) ;\n rb_define_method ( cCipher , \"auth_tag=\" , ossl_cipher_set_auth_tag , 1 ) ;\n rb_define_method ( cCipher , \"auth_tag\" , ossl_cipher_get_auth_tag , - 1 ) ;\n rb_define_method ( cCipher , \"auth_tag_len=\" , ossl_cipher_set_auth_tag_len , 1 ) ;\n rb_define_method ( cCipher , \"authenticated?\" , ossl_cipher_is_authenticated , 0 ) ;\n rb_define_method ( cCipher , \"key_len=\" , ossl_cipher_set_key_length , 1 ) ;\n rb_define_method ( cCipher , \"key_len\" , ossl_cipher_key_length , 0 ) ;\n rb_define_method ( cCipher , \"iv=\" , ossl_cipher_set_iv , 1 ) ;\n rb_define_method ( cCipher , \"iv_len=\" , ossl_cipher_set_iv_length , 1 ) ;\n rb_define_method ( cCipher , \"iv_len\" , ossl_cipher_iv_length , 0 ) ;\n rb_define_method ( cCipher , \"block_size\" , ossl_cipher_block_size , 0 ) ;\n rb_define_method ( cCipher , \"padding=\" , ossl_cipher_set_padding , 1 ) ;\n id_auth_tag_len = rb_intern_const ( \"auth_tag_len\" ) ;\n }", "hash": 1896723564367514490, "project": "debian", "size": 31, "target": 1, "idx": 21850}
{"code": "static int _ar_read_header ( struct archive_read * a , struct archive_entry * entry , struct ar * ar , const char * h , size_t * unconsumed ) {\n char filename [ AR_name_size + 1 ] ;\n uint64_t number ;\n size_t bsd_name_length , entry_size ;\n char * p , * st ;\n const void * b ;\n int r ;\n if ( strncmp ( h + AR_fmag_offset , \"`\\n\" , 2 ) != 0 ) {\n archive_set_error ( & a -> archive , EINVAL , \"Incorrect file header signature\" ) ;\n return ( ARCHIVE_WARN ) ;\n }\n strncpy ( filename , h + AR_name_offset , AR_name_size ) ;\n filename [ AR_name_size ] = '\\0' ;\n if ( a -> archive . archive_format == ARCHIVE_FORMAT_AR ) {\n if ( strncmp ( filename , \"#1/\" , 3 ) == 0 ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_BSD ;\n else if ( strchr ( filename , '/' ) != NULL ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_GNU ;\n else if ( strncmp ( filename , \"__.SYMDEF\" , 9 ) == 0 ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_BSD ;\n }\n if ( a -> archive . archive_format == ARCHIVE_FORMAT_AR_GNU ) a -> archive . archive_format_name = \"ar (GNU/SVR4)\" ;\n else if ( a -> archive . archive_format == ARCHIVE_FORMAT_AR_BSD ) a -> archive . archive_format_name = \"ar (BSD)\" ;\n else a -> archive . archive_format_name = \"ar\" ;\n p = filename + AR_name_size - 1 ;\n while ( p >= filename && * p == ' ' ) {\n * p = '\\0' ;\n p -- ;\n }\n if ( filename [ 0 ] != '/' && * p == '/' ) * p = '\\0' ;\n if ( strcmp ( filename , \"//\" ) == 0 ) {\n ar_parse_common_header ( ar , entry , h ) ;\n archive_entry_copy_pathname ( entry , filename ) ;\n archive_entry_set_filetype ( entry , AE_IFREG ) ;\n number = ar_atol10 ( h + AR_size_offset , AR_size_size ) ;\n if ( number > SIZE_MAX ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Filename table too large\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n entry_size = ( size_t ) number ;\n if ( entry_size == 0 ) {\n archive_set_error ( & a -> archive , EINVAL , \"Invalid string table\" ) ;\n return ( ARCHIVE_WARN ) ;\n }\n if ( ar -> strtab != NULL ) {\n archive_set_error ( & a -> archive , EINVAL , \"More than one string tables exist\" ) ;\n return ( ARCHIVE_WARN ) ;\n }\n st = malloc ( entry_size ) ;\n if ( st == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate filename table buffer\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n ar -> strtab = st ;\n ar -> strtab_size = entry_size ;\n if ( * unconsumed ) {\n __archive_read_consume ( a , * unconsumed ) ;\n * unconsumed = 0 ;\n }\n if ( ( b = __archive_read_ahead ( a , entry_size , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ;\n memcpy ( st , b , entry_size ) ;\n __archive_read_consume ( a , entry_size ) ;\n ar -> entry_bytes_remaining = 0 ;\n archive_entry_set_size ( entry , ar -> entry_bytes_remaining ) ;\n return ( ar_parse_gnu_filename_table ( a ) ) ;\n }\n if ( filename [ 0 ] == '/' && filename [ 1 ] >= '0' && filename [ 1 ] <= '9' ) {\n number = ar_atol10 ( h + AR_name_offset + 1 , AR_name_size - 1 ) ;\n if ( ar -> strtab == NULL || number > ar -> strtab_size ) {\n archive_set_error ( & a -> archive , EINVAL , \"Can't find long filename for entry\" ) ;\n archive_entry_copy_pathname ( entry , filename ) ;\n ar_parse_common_header ( ar , entry , h ) ;\n return ( ARCHIVE_WARN ) ;\n }\n archive_entry_copy_pathname ( entry , & ar -> strtab [ ( size_t ) number ] ) ;\n return ( ar_parse_common_header ( ar , entry , h ) ) ;\n }\n if ( strncmp ( filename , \"#1/\" , 3 ) == 0 ) {\n ar_parse_common_header ( ar , entry , h ) ;\n number = ar_atol10 ( h + AR_name_offset + 3 , AR_name_size - 3 ) ;\n bsd_name_length = ( size_t ) number ;\n if ( number > ( uint64_t ) ( bsd_name_length + 1 ) || ( int64_t ) bsd_name_length > ar -> entry_bytes_remaining ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Bad input file size\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n ar -> entry_bytes_remaining -= bsd_name_length ;\n archive_entry_set_size ( entry , ar -> entry_bytes_remaining ) ;\n if ( * unconsumed ) {\n __archive_read_consume ( a , * unconsumed ) ;\n * unconsumed = 0 ;\n }\n if ( ( b = __archive_read_ahead ( a , bsd_name_length , NULL ) ) == NULL ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Truncated input file\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n p = ( char * ) malloc ( bsd_name_length + 1 ) ;\n if ( p == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate fname buffer\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n strncpy ( p , b , bsd_name_length ) ;\n p [ bsd_name_length ] = '\\0' ;\n __archive_read_consume ( a , bsd_name_length ) ;\n archive_entry_copy_pathname ( entry , p ) ;\n free ( p ) ;\n return ( ARCHIVE_OK ) ;\n }\n if ( strcmp ( filename , \"/\" ) == 0 ) {\n archive_entry_copy_pathname ( entry , \"/\" ) ;\n r = ar_parse_common_header ( ar , entry , h ) ;\n archive_entry_set_filetype ( entry , AE_IFREG ) ;\n return ( r ) ;\n }\n if ( strcmp ( filename , \"__.SYMDEF\" ) == 0 ) {\n archive_entry_copy_pathname ( entry , filename ) ;\n return ( ar_parse_common_header ( ar , entry , h ) ) ;\n }\n archive_entry_copy_pathname ( entry , filename ) ;\n return ( ar_parse_common_header ( ar , entry , h ) ) ;\n }", "hash": -8575765905118000367, "project": "debian", "size": 117, "target": 1, "idx": 21856}
{"code": "int ieee80211_radiotap_iterator_next ( struct ieee80211_radiotap_iterator * iterator ) {\n while ( 1 ) {\n int hit = 0 ;\n int pad , align , size , subns ;\n guint32 oui ;\n if ( ( iterator -> _arg_index % 32 ) == IEEE80211_RADIOTAP_EXT && ! ( iterator -> _bitmap_shifter & 1 ) ) return - ENOENT ;\n if ( ! ( iterator -> _bitmap_shifter & 1 ) ) goto next_entry ;\n switch ( iterator -> _arg_index % 32 ) {\n case IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE : case IEEE80211_RADIOTAP_EXT : align = 1 ;\n size = 0 ;\n break ;\n case IEEE80211_RADIOTAP_VENDOR_NAMESPACE : align = 2 ;\n size = 6 ;\n break ;\n default : # ifdef RADIOTAP_SUPPORT_OVERRIDES if ( find_override ( iterator , & align , & size ) ) {\n }\n else # endif if ( ! iterator -> current_namespace || iterator -> _arg_index >= iterator -> current_namespace -> n_bits ) {\n if ( iterator -> current_namespace == & radiotap_ns ) return - ENOENT ;\n align = 0 ;\n }\n else {\n align = iterator -> current_namespace -> align_size [ iterator -> _arg_index ] . align ;\n size = iterator -> current_namespace -> align_size [ iterator -> _arg_index ] . size ;\n }\n if ( ! align ) {\n iterator -> _arg = iterator -> _next_ns_data ;\n iterator -> current_namespace = NULL ;\n goto next_entry ;\n }\n break ;\n }\n pad = ( int ) ( ( iterator -> _arg - ( unsigned char * ) iterator -> _rtheader ) & ( align - 1 ) ) ;\n if ( pad ) iterator -> _arg += align - pad ;\n if ( iterator -> _arg_index % 32 == IEEE80211_RADIOTAP_VENDOR_NAMESPACE ) {\n int vnslen ;\n if ( ! ITERATOR_VALID ( iterator , size ) ) return - EINVAL ;\n oui = ( * iterator -> _arg << 16 ) | ( * ( iterator -> _arg + 1 ) << 8 ) | * ( iterator -> _arg + 2 ) ;\n subns = * ( iterator -> _arg + 3 ) ;\n find_ns ( iterator , oui , subns ) ;\n vnslen = get_unaligned_le16 ( iterator -> _arg + 4 ) ;\n iterator -> _next_ns_data = iterator -> _arg + size + vnslen ;\n if ( ! iterator -> current_namespace ) size += vnslen ;\n }\n iterator -> this_arg_index = iterator -> _arg_index ;\n iterator -> this_arg = iterator -> _arg ;\n iterator -> this_arg_size = size ;\n iterator -> _arg += size ;\n if ( ! ITERATOR_VALID ( iterator , 0 ) ) return - EINVAL ;\n switch ( iterator -> _arg_index % 32 ) {\n case IEEE80211_RADIOTAP_VENDOR_NAMESPACE : iterator -> _reset_on_ext = 1 ;\n iterator -> is_radiotap_ns = 0 ;\n iterator -> this_arg_index = IEEE80211_RADIOTAP_VENDOR_NAMESPACE ;\n if ( ! iterator -> current_namespace ) hit = 1 ;\n goto next_entry ;\n case IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE : iterator -> _reset_on_ext = 1 ;\n iterator -> current_namespace = & radiotap_ns ;\n iterator -> is_radiotap_ns = 1 ;\n goto next_entry ;\n case IEEE80211_RADIOTAP_EXT : iterator -> _bitmap_shifter = get_unaligned_le32 ( iterator -> _next_bitmap ) ;\n iterator -> _next_bitmap ++ ;\n if ( iterator -> _reset_on_ext ) iterator -> _arg_index = 0 ;\n else iterator -> _arg_index ++ ;\n iterator -> _reset_on_ext = 0 ;\n break ;\n default : hit = 1 ;\n next_entry : iterator -> _bitmap_shifter >>= 1 ;\n iterator -> _arg_index ++ ;\n }\n if ( hit ) return 0 ;\n }\n }", "hash": 72378500491506723, "project": "debian", "size": 71, "target": 1, "idx": 21858}
{"code": "static void vga_draw_line8 ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {\n uint32_t * palette ;\n int x ;\n palette = s1 -> last_palette ;\n width >>= 3 ;\n for ( x = 0 ;\n x < width ;\n x ++ ) {\n ( ( uint32_t * ) d ) [ 0 ] = palette [ s [ 0 ] ] ;\n ( ( uint32_t * ) d ) [ 1 ] = palette [ s [ 1 ] ] ;\n ( ( uint32_t * ) d ) [ 2 ] = palette [ s [ 2 ] ] ;\n ( ( uint32_t * ) d ) [ 3 ] = palette [ s [ 3 ] ] ;\n ( ( uint32_t * ) d ) [ 4 ] = palette [ s [ 4 ] ] ;\n ( ( uint32_t * ) d ) [ 5 ] = palette [ s [ 5 ] ] ;\n ( ( uint32_t * ) d ) [ 6 ] = palette [ s [ 6 ] ] ;\n ( ( uint32_t * ) d ) [ 7 ] = palette [ s [ 7 ] ] ;\n d += 32 ;\n s += 8 ;\n }\n }", "hash": 369115599810341094, "project": "debian", "size": 20, "target": 1, "idx": 21884}
{"code": "static void vga_draw_line32_le ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {\n # ifndef HOST_WORDS_BIGENDIAN memcpy ( d , s , width * 4 ) ;\n # else int w ;\n uint32_t r , g , b ;\n w = width ;\n do {\n b = s [ 0 ] ;\n g = s [ 1 ] ;\n r = s [ 2 ] ;\n ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;\n s += 4 ;\n d += 4 ;\n }\n while ( -- w != 0 ) ;\n # endif }", "hash": 369115599810341094, "project": "debian", "size": 15, "target": 1, "idx": 21888}
{"code": "static rfbBool rectSwapIfLEAndClip ( uint16_t * x , uint16_t * y , uint16_t * w , uint16_t * h , rfbClientPtr cl ) {\n int x1 = Swap16IfLE ( * x ) ;\n int y1 = Swap16IfLE ( * y ) ;\n int w1 = Swap16IfLE ( * w ) ;\n int h1 = Swap16IfLE ( * h ) ;\n rfbScaledCorrection ( cl -> scaledScreen , cl -> screen , & x1 , & y1 , & w1 , & h1 , \"rectSwapIfLEAndClip\" ) ;\n * x = x1 ;\n * y = y1 ;\n * w = w1 ;\n * h = h1 ;\n if ( * w > cl -> screen -> width - * x ) * w = cl -> screen -> width - * x ;\n if ( * w > cl -> screen -> width - * x ) return FALSE ;\n if ( * h > cl -> screen -> height - * y ) * h = cl -> screen -> height - * y ;\n if ( * h > cl -> screen -> height - * y ) return FALSE ;\n return TRUE ;\n }", "hash": 6250095321513210169, "project": "debian", "size": 16, "target": 1, "idx": 21905}
{"code": "static void dec_build_inter_predictors ( MACROBLOCKD * xd , int plane , int block , int bw , int bh , int x , int y , int w , int h , int mi_x , int mi_y ) {\n struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;\n const MODE_INFO * mi = xd -> mi [ 0 ] ;\n const int is_compound = has_second_ref ( & mi -> mbmi ) ;\n const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ;\n int ref ;\n for ( ref = 0 ;\n ref < 1 + is_compound ;\n ++ ref ) {\n const struct scale_factors * const sf = & xd -> block_refs [ ref ] -> sf ;\n struct buf_2d * const pre_buf = & pd -> pre [ ref ] ;\n struct buf_2d * const dst_buf = & pd -> dst ;\n uint8_t * const dst = dst_buf -> buf + dst_buf -> stride * y + x ;\n const MV mv = mi -> mbmi . sb_type < BLOCK_8X8 ? average_split_mvs ( pd , mi , ref , block ) : mi -> mbmi . mv [ ref ] . as_mv ;\n const MV mv_q4 = clamp_mv_to_umv_border_sb ( xd , & mv , bw , bh , pd -> subsampling_x , pd -> subsampling_y ) ;\n MV32 scaled_mv ;\n int xs , ys , x0 , y0 , x0_16 , y0_16 , frame_width , frame_height , buf_stride , subpel_x , subpel_y ;\n uint8_t * ref_frame , * buf_ptr ;\n const YV12_BUFFER_CONFIG * ref_buf = xd -> block_refs [ ref ] -> buf ;\n if ( plane == 0 ) {\n frame_width = ref_buf -> y_crop_width ;\n frame_height = ref_buf -> y_crop_height ;\n ref_frame = ref_buf -> y_buffer ;\n }\n else {\n frame_width = ref_buf -> uv_crop_width ;\n frame_height = ref_buf -> uv_crop_height ;\n ref_frame = plane == 1 ? ref_buf -> u_buffer : ref_buf -> v_buffer ;\n }\n if ( vp9_is_scaled ( sf ) ) {\n int x_start = ( - xd -> mb_to_left_edge >> ( 3 + pd -> subsampling_x ) ) ;\n int y_start = ( - xd -> mb_to_top_edge >> ( 3 + pd -> subsampling_y ) ) ;\n x0_16 = ( x_start + x ) << SUBPEL_BITS ;\n y0_16 = ( y_start + y ) << SUBPEL_BITS ;\n x0_16 = sf -> scale_value_x ( x0_16 , sf ) ;\n y0_16 = sf -> scale_value_y ( y0_16 , sf ) ;\n x0 = sf -> scale_value_x ( x_start + x , sf ) ;\n y0 = sf -> scale_value_y ( y_start + y , sf ) ;\n scaled_mv = vp9_scale_mv ( & mv_q4 , mi_x + x , mi_y + y , sf ) ;\n xs = sf -> x_step_q4 ;\n ys = sf -> y_step_q4 ;\n }\n else {\n x0 = ( - xd -> mb_to_left_edge >> ( 3 + pd -> subsampling_x ) ) + x ;\n y0 = ( - xd -> mb_to_top_edge >> ( 3 + pd -> subsampling_y ) ) + y ;\n x0_16 = x0 << SUBPEL_BITS ;\n y0_16 = y0 << SUBPEL_BITS ;\n scaled_mv . row = mv_q4 . row ;\n scaled_mv . col = mv_q4 . col ;\n xs = ys = 16 ;\n }\n subpel_x = scaled_mv . col & SUBPEL_MASK ;\n subpel_y = scaled_mv . row & SUBPEL_MASK ;\n x0 += scaled_mv . col >> SUBPEL_BITS ;\n y0 += scaled_mv . row >> SUBPEL_BITS ;\n x0_16 += scaled_mv . col ;\n y0_16 += scaled_mv . row ;\n buf_ptr = ref_frame + y0 * pre_buf -> stride + x0 ;\n buf_stride = pre_buf -> stride ;\n if ( scaled_mv . col || scaled_mv . row || ( frame_width & 0x7 ) || ( frame_height & 0x7 ) ) {\n int x1 = ( ( x0_16 + ( w - 1 ) * xs ) >> SUBPEL_BITS ) + 1 ;\n int y1 = ( ( y0_16 + ( h - 1 ) * ys ) >> SUBPEL_BITS ) + 1 ;\n int x_pad = 0 , y_pad = 0 ;\n if ( subpel_x || ( sf -> x_step_q4 & SUBPEL_MASK ) ) {\n x0 -= VP9_INTERP_EXTEND - 1 ;\n x1 += VP9_INTERP_EXTEND ;\n x_pad = 1 ;\n }\n if ( subpel_y || ( sf -> y_step_q4 & SUBPEL_MASK ) ) {\n y0 -= VP9_INTERP_EXTEND - 1 ;\n y1 += VP9_INTERP_EXTEND ;\n y_pad = 1 ;\n }\n if ( x0 < 0 || x0 > frame_width - 1 || x1 < 0 || x1 > frame_width - 1 || y0 < 0 || y0 > frame_height - 1 || y1 < 0 || y1 > frame_height - 1 ) {\n uint8_t * buf_ptr1 = ref_frame + y0 * pre_buf -> stride + x0 ;\n build_mc_border ( buf_ptr1 , pre_buf -> stride , xd -> mc_buf , x1 - x0 + 1 , x0 , y0 , x1 - x0 + 1 , y1 - y0 + 1 , frame_width , frame_height ) ;\n buf_stride = x1 - x0 + 1 ;\n buf_ptr = xd -> mc_buf + y_pad * 3 * buf_stride + x_pad * 3 ;\n }\n }\n inter_predictor ( buf_ptr , buf_stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys ) ;\n }\n }", "hash": -7137859843679922870, "project": "chrome", "size": 83, "target": 1, "idx": 21914}
{"code": "void vp9_idct8x8_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {\n if ( eob == 1 ) vp9_idct8x8_1_add ( input , dest , stride ) ;\n else if ( eob <= 12 ) vp9_idct8x8_12_add ( input , dest , stride ) ;\n else vp9_idct8x8_64_add ( input , dest , stride ) ;\n }", "hash": 8320716512483418415, "project": "chrome", "size": 5, "target": 1, "idx": 21920}
{"code": "void vp9_idct16x16_10_add_c ( const int16_t * input , uint8_t * dest , int stride ) {\n int16_t out [ 16 * 16 ] = {\n 0 }\n ;\n int16_t * outptr = out ;\n int i , j ;\n int16_t temp_in [ 16 ] , temp_out [ 16 ] ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n idct16 ( input , outptr ) ;\n input += 16 ;\n outptr += 16 ;\n }\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n for ( j = 0 ;\n j < 16 ;\n ++ j ) temp_in [ j ] = out [ j * 16 + i ] ;\n idct16 ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 16 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;\n }\n }", "hash": 8320716512483418415, "project": "chrome", "size": 26, "target": 1, "idx": 21929}
{"code": "void vp9_ ## type ## _predictor_ ## size ## x ## size ## _c ( uint8_t * dst , ptrdiff_t stride , const uint8_t * above , const uint8_t * left ) {\n type ## _predictor ( dst , stride , size , above , left ) ;\n }\n # define intra_pred_allsizes ( type ) intra_pred_sized ( type , 4 ) intra_pred_sized ( type , 8 ) intra_pred_sized ( type , 16 ) intra_pred_sized ( type , 32 ) static INLINE void d207_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) above ;\n for ( r = 0 ;\n r < bs - 1 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] , 1 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( r = 0 ;\n r < bs - 2 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] * 2 + left [ r + 2 ] , 2 ) ;\n dst [ ( bs - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ bs - 2 ] + left [ bs - 1 ] * 3 , 2 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ ( bs - 1 ) * stride + c ] = left [ bs - 1 ] ;\n for ( r = bs - 2 ;\n r >= 0 ;\n -- r ) for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ r * stride + c ] = dst [ ( r + 1 ) * stride + c - 2 ] ;\n }\n intra_pred_allsizes ( d207 ) static INLINE void d63_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) dst [ c ] = r & 1 ? ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] * 2 + above [ r / 2 + c + 2 ] , 2 ) : ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] , 1 ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d63 )", "hash": -755883256379441954, "project": "chrome", "size": 39, "target": 1, "idx": 21952}
{"code": "void vp9_ ## type ## _predictor_ ## size ## x ## size ## _c ( uint8_t * dst , ptrdiff_t stride , const uint8_t * above , const uint8_t * left ) {\n type ## _predictor ( dst , stride , size , above , left ) ;\n }\n # define intra_pred_allsizes ( type ) intra_pred_sized ( type , 4 ) intra_pred_sized ( type , 8 ) intra_pred_sized ( type , 16 ) intra_pred_sized ( type , 32 ) static INLINE void d207_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) above ;\n for ( r = 0 ;\n r < bs - 1 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] , 1 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( r = 0 ;\n r < bs - 2 ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r ] + left [ r + 1 ] * 2 + left [ r + 2 ] , 2 ) ;\n dst [ ( bs - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ bs - 2 ] + left [ bs - 1 ] * 3 , 2 ) ;\n dst [ ( bs - 1 ) * stride ] = left [ bs - 1 ] ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ ( bs - 1 ) * stride + c ] = left [ bs - 1 ] ;\n for ( r = bs - 2 ;\n r >= 0 ;\n -- r ) for ( c = 0 ;\n c < bs - 2 ;\n ++ c ) dst [ r * stride + c ] = dst [ ( r + 1 ) * stride + c - 2 ] ;\n }\n intra_pred_allsizes ( d207 ) static INLINE void d63_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) dst [ c ] = r & 1 ? ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] * 2 + above [ r / 2 + c + 2 ] , 2 ) : ROUND_POWER_OF_TWO ( above [ r / 2 + c ] + above [ r / 2 + c + 1 ] , 1 ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d63 ) static INLINE void d45_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs ;\n ++ c ) dst [ c ] = r + c + 2 < bs * 2 ? ROUND_POWER_OF_TWO ( above [ r + c ] + above [ r + c + 1 ] * 2 + above [ r + c + 2 ] , 2 ) : above [ bs * 2 - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d45 ) static INLINE void d117_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n for ( c = 0 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] , 1 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst += stride ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 3 ;\n r < bs ;\n ++ r ) dst [ ( r - 2 ) * stride ] = ROUND_POWER_OF_TWO ( left [ r - 3 ] + left [ r - 2 ] * 2 + left [ r - 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - 2 * stride + c - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d117 ) static INLINE void d135_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 2 ] + above [ c - 1 ] * 2 + above [ c ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n ++ r ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 1 ;\n c < bs ;\n c ++ ) dst [ c ] = dst [ - stride + c - 1 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d135 ) static INLINE void d153_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r , c ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] , 1 ) ;\n for ( r = 1 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 1 ] + left [ r ] , 1 ) ;\n dst ++ ;\n dst [ 0 ] = ROUND_POWER_OF_TWO ( left [ 0 ] + above [ - 1 ] * 2 + above [ 0 ] , 2 ) ;\n dst [ stride ] = ROUND_POWER_OF_TWO ( above [ - 1 ] + left [ 0 ] * 2 + left [ 1 ] , 2 ) ;\n for ( r = 2 ;\n r < bs ;\n r ++ ) dst [ r * stride ] = ROUND_POWER_OF_TWO ( left [ r - 2 ] + left [ r - 1 ] * 2 + left [ r ] , 2 ) ;\n dst ++ ;\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = ROUND_POWER_OF_TWO ( above [ c - 1 ] + above [ c ] * 2 + above [ c + 1 ] , 2 ) ;\n dst += stride ;\n for ( r = 1 ;\n r < bs ;\n ++ r ) {\n for ( c = 0 ;\n c < bs - 2 ;\n c ++ ) dst [ c ] = dst [ - stride + c - 2 ] ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( d153 ) static INLINE void v_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r ;\n ( void ) left ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memcpy ( dst , above , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( v ) static INLINE void h_predictor ( uint8_t * dst , ptrdiff_t stride , int bs , const uint8_t * above , const uint8_t * left ) {\n int r ;\n ( void ) above ;\n for ( r = 0 ;\n r < bs ;\n r ++ ) {\n vpx_memset ( dst , left [ r ] , bs ) ;\n dst += stride ;\n }\n }\n intra_pred_allsizes ( h )", "hash": -755883256379441954, "project": "chrome", "size": 141, "target": 1, "idx": 21962}
{"code": "static void tokenize_b ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) {\n struct tokenize_b_args * const args = arg ;\n VP9_COMP * cpi = args -> cpi ;\n MACROBLOCKD * xd = args -> xd ;\n TOKENEXTRA * * tp = args -> tp ;\n uint8_t token_cache [ 32 * 32 ] ;\n struct macroblock_plane * p = & cpi -> mb . plane [ plane ] ;\n struct macroblockd_plane * pd = & xd -> plane [ plane ] ;\n MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;\n int pt ;\n int c ;\n TOKENEXTRA * t = * tp ;\n int eob = p -> eobs [ block ] ;\n const PLANE_TYPE type = pd -> plane_type ;\n const int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ;\n const int segment_id = mbmi -> segment_id ;\n const int16_t * scan , * nb ;\n const scan_order * so ;\n const int ref = is_inter_block ( mbmi ) ;\n unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = cpi -> coef_counts [ tx_size ] [ type ] [ ref ] ;\n vp9_prob ( * const coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = cpi -> common . fc . coef_probs [ tx_size ] [ type ] [ ref ] ;\n unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] = cpi -> common . counts . eob_branch [ tx_size ] [ type ] [ ref ] ;\n const uint8_t * const band = get_band_translate ( tx_size ) ;\n const int seg_eob = get_tx_eob ( & cpi -> common . seg , segment_id , tx_size ) ;\n int aoff , loff ;\n txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & aoff , & loff ) ;\n pt = get_entropy_context ( tx_size , pd -> above_context + aoff , pd -> left_context + loff ) ;\n so = get_scan ( xd , tx_size , type , block ) ;\n scan = so -> scan ;\n nb = so -> neighbors ;\n c = 0 ;\n while ( c < eob ) {\n int v = 0 ;\n int skip_eob = 0 ;\n v = qcoeff [ scan [ c ] ] ;\n while ( ! v ) {\n add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , ZERO_TOKEN , skip_eob , counts [ band [ c ] ] [ pt ] ) ;\n eob_branch [ band [ c ] ] [ pt ] += ! skip_eob ;\n skip_eob = 1 ;\n token_cache [ scan [ c ] ] = 0 ;\n ++ c ;\n pt = get_coef_context ( nb , token_cache , c ) ;\n v = qcoeff [ scan [ c ] ] ;\n }\n add_token ( & t , coef_probs [ band [ c ] ] [ pt ] , vp9_dct_value_tokens_ptr [ v ] . extra , ( uint8_t ) vp9_dct_value_tokens_ptr [ v ] . token , ( uint8_t ) skip_eob , counts [ band [ c ] ] [ pt ] ) ;\n eob_branch [ band [ c ] ] [ pt ] += ! skip_eob ;\n token_cache [ scan [ c ] ] = vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ v ] . token ] ;\n ++ c ;\n pt = get_coef_context ( nb , token_cache , c ) ;\n }\n if ( c < seg_eob ) {\n add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , EOB_TOKEN , 0 , counts [ band [ c ] ] [ pt ] ) ;\n ++ eob_branch [ band [ c ] ] [ pt ] ;\n }\n * tp = t ;\n vp9_set_contexts ( xd , pd , plane_bsize , tx_size , c > 0 , aoff , loff ) ;\n }", "hash": -8925552398357902286, "project": "chrome", "size": 57, "target": 1, "idx": 21973}
{"code": "void vp9_temporal_filter ( VP9_COMP * cpi , int distance ) {\n VP9_COMMON * const cm = & cpi -> common ;\n RATE_CONTROL * const rc = & cpi -> rc ;\n int frame ;\n int frames_to_blur ;\n int start_frame ;\n int strength ;\n int frames_to_blur_backward ;\n int frames_to_blur_forward ;\n struct scale_factors sf ;\n YV12_BUFFER_CONFIG * frames [ MAX_LAG_BUFFERS ] = {\n NULL }\n ;\n adjust_arnr_filter ( cpi , distance , rc -> gfu_boost , & frames_to_blur , & strength ) ;\n frames_to_blur_backward = ( frames_to_blur / 2 ) ;\n frames_to_blur_forward = ( ( frames_to_blur - 1 ) / 2 ) ;\n start_frame = distance + frames_to_blur_forward ;\n for ( frame = 0 ;\n frame < frames_to_blur ;\n ++ frame ) {\n const int which_buffer = start_frame - frame ;\n struct lookahead_entry * buf = vp9_lookahead_peek ( cpi -> lookahead , which_buffer ) ;\n frames [ frames_to_blur - 1 - frame ] = & buf -> img ;\n }\n if ( is_two_pass_svc ( cpi ) ) {\n int frame_used = 0 ;\n vp9_setup_scale_factors_for_frame ( & sf , get_frame_new_buffer ( cm ) -> y_crop_width , get_frame_new_buffer ( cm ) -> y_crop_height , get_frame_new_buffer ( cm ) -> y_crop_width , get_frame_new_buffer ( cm ) -> y_crop_height ) ;\n for ( frame = 0 ;\n frame < frames_to_blur ;\n ++ frame ) {\n if ( cm -> mi_cols * MI_SIZE != frames [ frame ] -> y_width || cm -> mi_rows * MI_SIZE != frames [ frame ] -> y_height ) {\n if ( vp9_realloc_frame_buffer ( & cpi -> svc . scaled_frames [ frame_used ] , cm -> width , cm -> height , cm -> subsampling_x , cm -> subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , NULL , NULL , NULL ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , \"Failed to reallocate alt_ref_buffer\" ) ;\n frames [ frame ] = vp9_scale_if_required ( cm , frames [ frame ] , & cpi -> svc . scaled_frames [ frame_used ] ) ;\n ++ frame_used ;\n }\n }\n }\n else {\n vp9_setup_scale_factors_for_frame ( & sf , get_frame_new_buffer ( cm ) -> y_crop_width , get_frame_new_buffer ( cm ) -> y_crop_height , cm -> width , cm -> height ) ;\n }\n temporal_filter_iterate_c ( cpi , frames , frames_to_blur , frames_to_blur_backward , strength , & sf ) ;\n }", "hash": 5829728328403223446, "project": "chrome", "size": 42, "target": 1, "idx": 21978}
{"code": "static void print_mi_data ( VP9_COMMON * cm , FILE * file , const char * descriptor , size_t member_offset ) {\n int mi_row , mi_col ;\n int mi_index = 0 ;\n MODE_INFO * * mi = cm -> mi_grid_visible ;\n int rows = cm -> mi_rows ;\n int cols = cm -> mi_cols ;\n char prefix = descriptor [ 0 ] ;\n log_frame_info ( cm , descriptor , file ) ;\n mi_index = 0 ;\n for ( mi_row = 0 ;\n mi_row < rows ;\n mi_row ++ ) {\n fprintf ( file , \"%c \" , prefix ) ;\n for ( mi_col = 0 ;\n mi_col < cols ;\n mi_col ++ ) {\n fprintf ( file , \"%2d \" , * ( ( int * ) ( ( char * ) ( & mi [ mi_index ] -> mbmi ) + member_offset ) ) ) ;\n mi_index ++ ;\n }\n fprintf ( file , \"\\n\" ) ;\n mi_index += 8 ;\n }\n fprintf ( file , \"\\n\" ) ;\n }", "hash": 7364333987762519984, "project": "chrome", "size": 24, "target": 1, "idx": 21984}
{"code": "static int compute_rd_thresh_factor ( int qindex ) {\n const int q = ( int ) ( pow ( vp9_dc_quant ( qindex , 0 ) / 4.0 , RD_THRESH_POW ) * 5.12 ) ;\n return MAX ( q , 8 ) ;\n }", "hash": 1911881859629730975, "project": "chrome", "size": 4, "target": 1, "idx": 21990}
{"code": "static void parse_command_line ( int argc , const char * * argv_ , AppInput * app_input , SvcContext * svc_ctx , vpx_codec_enc_cfg_t * enc_cfg ) {\n struct arg arg = {\n 0 }\n ;\n char * * argv = NULL ;\n char * * argi = NULL ;\n char * * argj = NULL ;\n vpx_codec_err_t res ;\n int passes = 0 ;\n int pass = 0 ;\n const char * fpf_file_name = NULL ;\n unsigned int min_bitrate = 0 ;\n unsigned int max_bitrate = 0 ;\n svc_ctx -> log_level = SVC_LOG_DEBUG ;\n svc_ctx -> spatial_layers = default_spatial_layers ;\n svc_ctx -> temporal_layers = default_temporal_layers ;\n res = vpx_codec_enc_config_default ( vpx_codec_vp9_cx ( ) , enc_cfg , 0 ) ;\n if ( res ) {\n die ( \"Failed to get config: %s\\n\" , vpx_codec_err_to_string ( res ) ) ;\n }\n enc_cfg -> g_w = default_width ;\n enc_cfg -> g_h = default_height ;\n enc_cfg -> g_timebase . num = default_timebase_num ;\n enc_cfg -> g_timebase . den = default_timebase_den ;\n enc_cfg -> rc_target_bitrate = default_bitrate ;\n enc_cfg -> kf_min_dist = default_kf_dist ;\n enc_cfg -> kf_max_dist = default_kf_dist ;\n enc_cfg -> rc_end_usage = VPX_CQ ;\n app_input -> frames_to_code = default_frames_to_code ;\n app_input -> frames_to_skip = default_frames_to_skip ;\n argv = argv_dup ( argc - 1 , argv_ + 1 ) ;\n for ( argi = argj = argv ;\n ( * argj = * argi ) ;\n argi += arg . argv_step ) {\n arg . argv_step = 1 ;\n if ( arg_match ( & arg , & frames_arg , argi ) ) {\n app_input -> frames_to_code = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & width_arg , argi ) ) {\n enc_cfg -> g_w = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & height_arg , argi ) ) {\n enc_cfg -> g_h = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & timebase_arg , argi ) ) {\n enc_cfg -> g_timebase = arg_parse_rational ( & arg ) ;\n }\n else if ( arg_match ( & arg , & bitrate_arg , argi ) ) {\n enc_cfg -> rc_target_bitrate = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & skip_frames_arg , argi ) ) {\n app_input -> frames_to_skip = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & spatial_layers_arg , argi ) ) {\n svc_ctx -> spatial_layers = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & temporal_layers_arg , argi ) ) {\n svc_ctx -> temporal_layers = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & kf_dist_arg , argi ) ) {\n enc_cfg -> kf_min_dist = arg_parse_uint ( & arg ) ;\n enc_cfg -> kf_max_dist = enc_cfg -> kf_min_dist ;\n }\n else if ( arg_match ( & arg , & scale_factors_arg , argi ) ) {\n vpx_svc_set_scale_factors ( svc_ctx , arg . val ) ;\n }\n else if ( arg_match ( & arg , & quantizers_arg , argi ) ) {\n vpx_svc_set_quantizers ( svc_ctx , arg . val ) ;\n }\n else if ( arg_match ( & arg , & passes_arg , argi ) ) {\n passes = arg_parse_uint ( & arg ) ;\n if ( passes < 1 || passes > 2 ) {\n die ( \"Error: Invalid number of passes (%d)\\n\" , passes ) ;\n }\n }\n else if ( arg_match ( & arg , & pass_arg , argi ) ) {\n pass = arg_parse_uint ( & arg ) ;\n if ( pass < 1 || pass > 2 ) {\n die ( \"Error: Invalid pass selected (%d)\\n\" , pass ) ;\n }\n }\n else if ( arg_match ( & arg , & fpf_name_arg , argi ) ) {\n fpf_file_name = arg . val ;\n }\n else if ( arg_match ( & arg , & min_q_arg , argi ) ) {\n enc_cfg -> rc_min_quantizer = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & max_q_arg , argi ) ) {\n enc_cfg -> rc_max_quantizer = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & min_bitrate_arg , argi ) ) {\n min_bitrate = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & max_bitrate_arg , argi ) ) {\n max_bitrate = arg_parse_uint ( & arg ) ;\n }\n else {\n ++ argj ;\n }\n }\n if ( passes == 0 || passes == 1 ) {\n if ( pass ) {\n fprintf ( stderr , \"pass is ignored since there's only one pass\\n\" ) ;\n }\n enc_cfg -> g_pass = VPX_RC_ONE_PASS ;\n }\n else {\n if ( pass == 0 ) {\n die ( \"pass must be specified when passes is 2\\n\" ) ;\n }\n if ( fpf_file_name == NULL ) {\n die ( \"fpf must be specified when passes is 2\\n\" ) ;\n }\n if ( pass == 1 ) {\n enc_cfg -> g_pass = VPX_RC_FIRST_PASS ;\n if ( ! stats_open_file ( & app_input -> rc_stats , fpf_file_name , 0 ) ) {\n fatal ( \"Failed to open statistics store\" ) ;\n }\n }\n else {\n enc_cfg -> g_pass = VPX_RC_LAST_PASS ;\n if ( ! stats_open_file ( & app_input -> rc_stats , fpf_file_name , 1 ) ) {\n fatal ( \"Failed to open statistics store\" ) ;\n }\n enc_cfg -> rc_twopass_stats_in = stats_get ( & app_input -> rc_stats ) ;\n }\n app_input -> passes = passes ;\n app_input -> pass = pass ;\n }\n if ( enc_cfg -> rc_target_bitrate > 0 ) {\n if ( min_bitrate > 0 ) {\n enc_cfg -> rc_2pass_vbr_minsection_pct = min_bitrate * 100 / enc_cfg -> rc_target_bitrate ;\n }\n if ( max_bitrate > 0 ) {\n enc_cfg -> rc_2pass_vbr_maxsection_pct = max_bitrate * 100 / enc_cfg -> rc_target_bitrate ;\n }\n }\n for ( argi = argv ;\n * argi ;\n ++ argi ) if ( argi [ 0 ] [ 0 ] == '-' && strlen ( argi [ 0 ] ) > 1 ) die ( \"Error: Unrecognized option %s\\n\" , * argi ) ;\n if ( argv [ 0 ] == NULL || argv [ 1 ] == 0 ) {\n usage_exit ( ) ;\n }\n app_input -> input_filename = argv [ 0 ] ;\n app_input -> output_filename = argv [ 1 ] ;\n free ( argv ) ;\n if ( enc_cfg -> g_w < 16 || enc_cfg -> g_w % 2 || enc_cfg -> g_h < 16 || enc_cfg -> g_h % 2 ) die ( \"Invalid resolution: %d x %d\\n\" , enc_cfg -> g_w , enc_cfg -> g_h ) ;\n printf ( \"Codec %s\\nframes: %d, skip: %d\\n\" \"layers: %d\\n\" \"width %d, height: %d,\\n\" \"num: %d, den: %d, bitrate: %d,\\n\" \"gop size: %d\\n\" , vpx_codec_iface_name ( vpx_codec_vp9_cx ( ) ) , app_input -> frames_to_code , app_input -> frames_to_skip , svc_ctx -> spatial_layers , enc_cfg -> g_w , enc_cfg -> g_h , enc_cfg -> g_timebase . num , enc_cfg -> g_timebase . den , enc_cfg -> rc_target_bitrate , enc_cfg -> kf_max_dist ) ;\n }", "hash": 6809509104003465181, "project": "chrome", "size": 149, "target": 1, "idx": 22032}
{"code": "static void update_state_rt ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , int mi_row , int mi_col , int bsize ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;\n const struct segmentation * const seg = & cm -> seg ;\n * ( xd -> mi [ 0 ] ) = ctx -> mic ;\n if ( ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) && seg -> enabled ) {\n vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] -> mbmi , mi_row , mi_col , bsize , 1 ) ;\n vp9_init_plane_quantizers ( cpi , x ) ;\n }\n if ( is_inter_block ( mbmi ) ) {\n vp9_update_mv_count ( cm , xd ) ;\n if ( cm -> interp_filter == SWITCHABLE ) {\n const int pred_ctx = vp9_get_pred_context_switchable_interp ( xd ) ;\n ++ cm -> counts . switchable_interp [ pred_ctx ] [ mbmi -> interp_filter ] ;\n }\n }\n x -> skip = ctx -> skip ;\n x -> skip_txfm [ 0 ] = mbmi -> segment_id ? 0 : ctx -> skip_txfm [ 0 ] ;\n }", "hash": -5706788925640467782, "project": "chrome", "size": 21, "target": 1, "idx": 22051}
{"code": "int16_t vp9_ac_quant ( int qindex , int delta ) {\n return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;\n }", "hash": 6827449473891484617, "project": "chrome", "size": 3, "target": 1, "idx": 22077}
{"code": "int y4m_input_fetch_frame ( y4m_input * _y4m , FILE * _fin , vpx_image_t * _img ) {\n char frame [ 6 ] ;\n int pic_sz ;\n int c_w ;\n int c_h ;\n int c_sz ;\n int bytes_per_sample = _y4m -> bit_depth > 8 ? 2 : 1 ;\n if ( ! file_read ( frame , 6 , _fin ) ) return 0 ;\n if ( memcmp ( frame , \"FRAME\" , 5 ) ) {\n fprintf ( stderr , \"Loss of framing in Y4M input data\\n\" ) ;\n return - 1 ;\n }\n if ( frame [ 5 ] != '\\n' ) {\n char c ;\n int j ;\n for ( j = 0 ;\n j < 79 && file_read ( & c , 1 , _fin ) && c != '\\n' ;\n j ++ ) {\n }\n if ( j == 79 ) {\n fprintf ( stderr , \"Error parsing Y4M frame header\\n\" ) ;\n return - 1 ;\n }\n }\n if ( ! file_read ( _y4m -> dst_buf , _y4m -> dst_buf_read_sz , _fin ) ) {\n fprintf ( stderr , \"Error reading Y4M frame data.\\n\" ) ;\n return - 1 ;\n }\n if ( ! file_read ( _y4m -> aux_buf , _y4m -> aux_buf_read_sz , _fin ) ) {\n fprintf ( stderr , \"Error reading Y4M frame data.\\n\" ) ;\n return - 1 ;\n }\n ( * _y4m -> convert ) ( _y4m , _y4m -> dst_buf , _y4m -> aux_buf ) ;\n memset ( _img , 0 , sizeof ( * _img ) ) ;\n _img -> fmt = _y4m -> vpx_fmt ;\n _img -> w = _img -> d_w = _y4m -> pic_w ;\n _img -> h = _img -> d_h = _y4m -> pic_h ;\n _img -> x_chroma_shift = _y4m -> dst_c_dec_h >> 1 ;\n _img -> y_chroma_shift = _y4m -> dst_c_dec_v >> 1 ;\n _img -> bps = _y4m -> bps ;\n pic_sz = _y4m -> pic_w * _y4m -> pic_h * bytes_per_sample ;\n c_w = ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ;\n c_w *= bytes_per_sample ;\n c_h = ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ;\n c_sz = c_w * c_h ;\n _img -> stride [ PLANE_Y ] = _img -> stride [ PLANE_ALPHA ] = _y4m -> pic_w * bytes_per_sample ;\n _img -> stride [ PLANE_U ] = _img -> stride [ PLANE_V ] = c_w ;\n _img -> planes [ PLANE_Y ] = _y4m -> dst_buf ;\n _img -> planes [ PLANE_U ] = _y4m -> dst_buf + pic_sz ;\n _img -> planes [ PLANE_V ] = _y4m -> dst_buf + pic_sz + c_sz ;\n _img -> planes [ PLANE_ALPHA ] = _y4m -> dst_buf + pic_sz + 2 * c_sz ;\n return 1 ;\n }", "hash": -5018199117312371093, "project": "chrome", "size": 53, "target": 1, "idx": 22084}
{"code": "static double calc_frame_boost ( const TWO_PASS * twopass , const FIRSTPASS_STATS * this_frame , double this_frame_mv_in_out ) {\n double frame_boost ;\n if ( this_frame -> intra_error > twopass -> gf_intra_err_min ) frame_boost = ( IIFACTOR * this_frame -> intra_error / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ;\n else frame_boost = ( IIFACTOR * twopass -> gf_intra_err_min / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ;\n if ( this_frame_mv_in_out > 0.0 ) frame_boost += frame_boost * ( this_frame_mv_in_out * 2.0 ) ;\n else frame_boost += frame_boost * ( this_frame_mv_in_out / 2.0 ) ;\n return MIN ( frame_boost , GF_RMAX ) ;\n }", "hash": -4960438251319819237, "project": "chrome", "size": 8, "target": 1, "idx": 22097}
{"code": "static void define_gf_group ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame ) {\n RATE_CONTROL * const rc = & cpi -> rc ;\n const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;\n TWO_PASS * const twopass = & cpi -> twopass ;\n FIRSTPASS_STATS next_frame ;\n const FIRSTPASS_STATS * const start_pos = twopass -> stats_in ;\n int i ;\n double boost_score = 0.0 ;\n double old_boost_score = 0.0 ;\n double gf_group_err = 0.0 ;\n double gf_first_frame_err = 0.0 ;\n double mod_frame_err = 0.0 ;\n double mv_ratio_accumulator = 0.0 ;\n double decay_accumulator = 1.0 ;\n double zero_motion_accumulator = 1.0 ;\n double loop_decay_rate = 1.00 ;\n double last_loop_decay_rate = 1.00 ;\n double this_frame_mv_in_out = 0.0 ;\n double mv_in_out_accumulator = 0.0 ;\n double abs_mv_in_out_accumulator = 0.0 ;\n double mv_ratio_accumulator_thresh ;\n unsigned int allow_alt_ref = is_altref_enabled ( cpi ) ;\n int f_boost = 0 ;\n int b_boost = 0 ;\n int flash_detected ;\n int active_max_gf_interval ;\n int64_t gf_group_bits ;\n double gf_group_error_left ;\n int gf_arf_bits ;\n if ( cpi -> common . frame_type != KEY_FRAME ) {\n vp9_zero ( twopass -> gf_group ) ;\n }\n vp9_clear_system_state ( ) ;\n vp9_zero ( next_frame ) ;\n mod_frame_err = calculate_modified_err ( twopass , oxcf , this_frame ) ;\n gf_first_frame_err = mod_frame_err ;\n if ( cpi -> common . frame_type == KEY_FRAME || rc -> source_alt_ref_active ) gf_group_err -= gf_first_frame_err ;\n mv_ratio_accumulator_thresh = ( cpi -> common . width + cpi -> common . height ) / 10.0 ;\n if ( cpi -> multi_arf_allowed ) {\n active_max_gf_interval = rc -> max_gf_interval ;\n }\n else {\n active_max_gf_interval = + ( ( int ) vp9_convert_qindex_to_q ( rc -> last_q [ INTER_FRAME ] ) >> 5 ) ;\n if ( active_max_gf_interval > rc -> max_gf_interval ) active_max_gf_interval = rc -> max_gf_interval ;\n }\n i = 0 ;\n while ( i < rc -> static_scene_max_gf_interval && i < rc -> frames_to_key ) {\n ++ i ;\n mod_frame_err = calculate_modified_err ( twopass , oxcf , this_frame ) ;\n gf_group_err += mod_frame_err ;\n if ( EOF == input_stats ( twopass , & next_frame ) ) break ;\n flash_detected = detect_flash ( twopass , 0 ) ;\n accumulate_frame_motion_stats ( & next_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ;\n if ( ! flash_detected ) {\n last_loop_decay_rate = loop_decay_rate ;\n loop_decay_rate = get_prediction_decay_rate ( & cpi -> common , & next_frame ) ;\n decay_accumulator = decay_accumulator * loop_decay_rate ;\n zero_motion_accumulator = MIN ( zero_motion_accumulator , get_zero_motion_factor ( & next_frame ) ) ;\n if ( detect_transition_to_still ( twopass , i , 5 , loop_decay_rate , last_loop_decay_rate ) ) {\n allow_alt_ref = 0 ;\n break ;\n }\n }\n boost_score += decay_accumulator * calc_frame_boost ( twopass , & next_frame , this_frame_mv_in_out ) ;\n if ( ( i >= active_max_gf_interval && ( zero_motion_accumulator < 0.995 ) ) || ( ( i > MIN_GF_INTERVAL ) && ( ( boost_score > 125.0 ) || ( next_frame . pcnt_inter < 0.75 ) ) && ( ! flash_detected ) && ( ( mv_ratio_accumulator > mv_ratio_accumulator_thresh ) || ( abs_mv_in_out_accumulator > 3.0 ) || ( mv_in_out_accumulator < - 2.0 ) || ( ( boost_score - old_boost_score ) < IIFACTOR ) ) ) ) {\n boost_score = old_boost_score ;\n break ;\n }\n * this_frame = next_frame ;\n old_boost_score = boost_score ;\n }\n twopass -> gf_zeromotion_pct = ( int ) ( zero_motion_accumulator * 1000.0 ) ;\n if ( ( rc -> frames_to_key - i ) < MIN_GF_INTERVAL ) {\n while ( i < ( rc -> frames_to_key + ! rc -> next_key_frame_forced ) ) {\n ++ i ;\n if ( EOF == input_stats ( twopass , this_frame ) ) break ;\n if ( i < rc -> frames_to_key ) {\n mod_frame_err = calculate_modified_err ( twopass , oxcf , this_frame ) ;\n gf_group_err += mod_frame_err ;\n }\n }\n }\n if ( cpi -> common . frame_type == KEY_FRAME || rc -> source_alt_ref_active ) rc -> baseline_gf_interval = i - 1 ;\n else rc -> baseline_gf_interval = i ;\n if ( is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) {\n int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ;\n int new_gf_interval = ( rc -> baseline_gf_interval + count ) & ( ~ count ) ;\n int j ;\n for ( j = 0 ;\n j < new_gf_interval - rc -> baseline_gf_interval ;\n ++ j ) {\n if ( EOF == input_stats ( twopass , this_frame ) ) break ;\n gf_group_err += calculate_modified_err ( twopass , oxcf , this_frame ) ;\n }\n rc -> baseline_gf_interval = new_gf_interval ;\n }\n rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ;\n if ( allow_alt_ref && ( i < cpi -> oxcf . lag_in_frames ) && ( i >= MIN_GF_INTERVAL ) && ( rc -> next_key_frame_forced || ( i <= ( rc -> frames_to_key - MIN_GF_INTERVAL ) ) ) ) {\n rc -> gfu_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ;\n rc -> source_alt_ref_pending = 1 ;\n cpi -> multi_arf_enabled = ( cpi -> multi_arf_allowed && ( rc -> baseline_gf_interval >= 6 ) && ( zero_motion_accumulator < 0.995 ) ) ? 1 : 0 ;\n }\n else {\n rc -> gfu_boost = ( int ) boost_score ;\n rc -> source_alt_ref_pending = 0 ;\n }\n reset_fpf_position ( twopass , start_pos ) ;\n gf_group_bits = calculate_total_gf_group_bits ( cpi , gf_group_err ) ;\n {\n int q = rc -> last_q [ INTER_FRAME ] ;\n int boost = ( rc -> gfu_boost * gfboost_qadjust ( q ) ) / 100 ;\n boost = clamp ( boost , 125 , ( rc -> baseline_gf_interval + 1 ) * 200 ) ;\n gf_arf_bits = calculate_boost_bits ( rc -> baseline_gf_interval , boost , gf_group_bits ) ;\n }\n twopass -> kf_group_error_left -= ( int64_t ) gf_group_err ;\n if ( rc -> source_alt_ref_pending ) {\n gf_group_error_left = gf_group_err - mod_frame_err ;\n }\n else if ( cpi -> common . frame_type != KEY_FRAME ) {\n gf_group_error_left = gf_group_err - gf_first_frame_err ;\n }\n else {\n gf_group_error_left = gf_group_err ;\n }\n allocate_gf_group_bits ( cpi , gf_group_bits , gf_group_error_left , gf_arf_bits ) ;\n reset_fpf_position ( twopass , start_pos ) ;\n if ( cpi -> common . frame_type != KEY_FRAME ) {\n twopass -> section_intra_rating = calculate_section_intra_ratio ( start_pos , twopass -> stats_in_end , rc -> baseline_gf_interval ) ;\n }\n }", "hash": -4960438251319819237, "project": "chrome", "size": 130, "target": 1, "idx": 22110}
{"code": "static int64_t rd_pick_intra_sub_8x8_y_mode ( VP9_COMP * cpi , MACROBLOCK * mb , int * rate , int * rate_y , int64_t * distortion , int64_t best_rd ) {\n int i , j ;\n const MACROBLOCKD * const xd = & mb -> e_mbd ;\n MODE_INFO * const mic = xd -> mi [ 0 ] ;\n const MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ;\n const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ;\n const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;\n const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ;\n const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ;\n int idx , idy ;\n int cost = 0 ;\n int64_t total_distortion = 0 ;\n int tot_rate_y = 0 ;\n int64_t total_rd = 0 ;\n ENTROPY_CONTEXT t_above [ 4 ] , t_left [ 4 ] ;\n const int * bmode_costs = cpi -> mbmode_cost ;\n vpx_memcpy ( t_above , xd -> plane [ 0 ] . above_context , sizeof ( t_above ) ) ;\n vpx_memcpy ( t_left , xd -> plane [ 0 ] . left_context , sizeof ( t_left ) ) ;\n for ( idy = 0 ;\n idy < 2 ;\n idy += num_4x4_blocks_high ) {\n for ( idx = 0 ;\n idx < 2 ;\n idx += num_4x4_blocks_wide ) {\n PREDICTION_MODE best_mode = DC_PRED ;\n int r = INT_MAX , ry = INT_MAX ;\n int64_t d = INT64_MAX , this_rd = INT64_MAX ;\n i = idy * 2 + idx ;\n if ( cpi -> common . frame_type == KEY_FRAME ) {\n const PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , i ) ;\n const PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , i ) ;\n bmode_costs = cpi -> y_mode_costs [ A ] [ L ] ;\n }\n this_rd = rd_pick_intra4x4block ( cpi , mb , i , & best_mode , bmode_costs , t_above + idx , t_left + idy , & r , & ry , & d , bsize , best_rd - total_rd ) ;\n if ( this_rd >= best_rd - total_rd ) return INT64_MAX ;\n total_rd += this_rd ;\n cost += r ;\n total_distortion += d ;\n tot_rate_y += ry ;\n mic -> bmi [ i ] . as_mode = best_mode ;\n for ( j = 1 ;\n j < num_4x4_blocks_high ;\n ++ j ) mic -> bmi [ i + j * 2 ] . as_mode = best_mode ;\n for ( j = 1 ;\n j < num_4x4_blocks_wide ;\n ++ j ) mic -> bmi [ i + j ] . as_mode = best_mode ;\n if ( total_rd >= best_rd ) return INT64_MAX ;\n }\n }\n * rate = cost ;\n * rate_y = tot_rate_y ;\n * distortion = total_distortion ;\n mic -> mbmi . mode = mic -> bmi [ 3 ] . as_mode ;\n return RDCOST ( mb -> rdmult , mb -> rddiv , cost , total_distortion ) ;\n }", "hash": 3887066622454352196, "project": "chrome", "size": 55, "target": 1, "idx": 22123}
{"code": "static void super_block_uvrd ( const VP9_COMP * cpi , MACROBLOCK * x , int * rate , int64_t * distortion , int * skippable , int64_t * sse , BLOCK_SIZE bsize , int64_t ref_best_rd ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;\n const TX_SIZE uv_tx_size = get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] ) ;\n int plane ;\n int pnrate = 0 , pnskip = 1 ;\n int64_t pndist = 0 , pnsse = 0 ;\n if ( ref_best_rd < 0 ) goto term ;\n if ( is_inter_block ( mbmi ) ) {\n int plane ;\n for ( plane = 1 ;\n plane < MAX_MB_PLANE ;\n ++ plane ) vp9_subtract_plane ( x , bsize , plane ) ;\n }\n * rate = 0 ;\n * distortion = 0 ;\n * sse = 0 ;\n * skippable = 1 ;\n for ( plane = 1 ;\n plane < MAX_MB_PLANE ;\n ++ plane ) {\n txfm_rd_in_plane ( x , & pnrate , & pndist , & pnskip , & pnsse , ref_best_rd , plane , bsize , uv_tx_size , cpi -> sf . use_fast_coef_costing ) ;\n if ( pnrate == INT_MAX ) goto term ;\n * rate += pnrate ;\n * distortion += pndist ;\n * sse += pnsse ;\n * skippable &= pnskip ;\n }\n return ;\n term : * rate = INT_MAX ;\n * distortion = INT64_MAX ;\n * sse = INT64_MAX ;\n * skippable = 0 ;\n return ;\n }", "hash": 3887066622454352196, "project": "chrome", "size": 35, "target": 1, "idx": 22134}
{"code": "static void setup_buffer_inter ( VP9_COMP * cpi , MACROBLOCK * x , const TileInfo * const tile , MV_REFERENCE_FRAME ref_frame , BLOCK_SIZE block_size , int mi_row , int mi_col , int_mv frame_nearest_mv [ MAX_REF_FRAMES ] , int_mv frame_near_mv [ MAX_REF_FRAMES ] , struct buf_2d yv12_mb [ 4 ] [ MAX_MB_PLANE ] ) {\n const VP9_COMMON * cm = & cpi -> common ;\n const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , ref_frame ) ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MODE_INFO * const mi = xd -> mi [ 0 ] ;\n int_mv * const candidates = mi -> mbmi . ref_mvs [ ref_frame ] ;\n const struct scale_factors * const sf = & cm -> frame_refs [ ref_frame - 1 ] . sf ;\n vp9_setup_pred_block ( xd , yv12_mb [ ref_frame ] , yv12 , mi_row , mi_col , sf , sf ) ;\n vp9_find_mv_refs ( cm , xd , tile , mi , ref_frame , candidates , mi_row , mi_col ) ;\n vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , candidates , & frame_nearest_mv [ ref_frame ] , & frame_near_mv [ ref_frame ] ) ;\n if ( ! vp9_is_scaled ( sf ) && block_size >= BLOCK_8X8 ) vp9_mv_pred ( cpi , x , yv12_mb [ ref_frame ] [ 0 ] . buf , yv12 -> y_stride , ref_frame , block_size ) ;\n }", "hash": 3887066622454352196, "project": "chrome", "size": 12, "target": 1, "idx": 22145}
{"code": "int64_t vp9_rd_pick_inter_mode_sub8x8 ( VP9_COMP * cpi , MACROBLOCK * x , const TileInfo * const tile , int mi_row , int mi_col , int * returnrate , int64_t * returndistortion , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd_so_far ) {\n VP9_COMMON * const cm = & cpi -> common ;\n RD_OPT * const rd_opt = & cpi -> rd ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;\n const struct segmentation * const seg = & cm -> seg ;\n MV_REFERENCE_FRAME ref_frame , second_ref_frame ;\n unsigned char segment_id = mbmi -> segment_id ;\n int comp_pred , i ;\n int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ;\n struct buf_2d yv12_mb [ 4 ] [ MAX_MB_PLANE ] ;\n static const int flag_list [ 4 ] = {\n 0 , VP9_LAST_FLAG , VP9_GOLD_FLAG , VP9_ALT_FLAG }\n ;\n int64_t best_rd = best_rd_so_far ;\n int64_t best_yrd = best_rd_so_far ;\n static const int64_t best_tx_diff [ TX_MODES ] = {\n 0 }\n ;\n int64_t best_pred_diff [ REFERENCE_MODES ] ;\n int64_t best_pred_rd [ REFERENCE_MODES ] ;\n int64_t best_filter_rd [ SWITCHABLE_FILTER_CONTEXTS ] ;\n int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ;\n MB_MODE_INFO best_mbmode ;\n int ref_index , best_ref_index = 0 ;\n unsigned int ref_costs_single [ MAX_REF_FRAMES ] , ref_costs_comp [ MAX_REF_FRAMES ] ;\n vp9_prob comp_mode_p ;\n int64_t best_inter_rd = INT64_MAX ;\n MV_REFERENCE_FRAME best_inter_ref_frame = LAST_FRAME ;\n INTERP_FILTER tmp_best_filter = SWITCHABLE ;\n int rate_uv_intra , rate_uv_tokenonly ;\n int64_t dist_uv ;\n int skip_uv ;\n PREDICTION_MODE mode_uv = DC_PRED ;\n int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ;\n int_mv seg_mvs [ 4 ] [ MAX_REF_FRAMES ] ;\n b_mode_info best_bmodes [ 4 ] ;\n int best_skip2 = 0 ;\n int mode_skip_mask = 0 ;\n x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ;\n vpx_memset ( x -> zcoeff_blk [ TX_4X4 ] , 0 , 4 ) ;\n vp9_zero ( best_mbmode ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n int j ;\n for ( j = 0 ;\n j < MAX_REF_FRAMES ;\n j ++ ) seg_mvs [ i ] [ j ] . as_int = INVALID_MV ;\n }\n estimate_ref_frame_costs ( cm , xd , segment_id , ref_costs_single , ref_costs_comp , & comp_mode_p ) ;\n for ( i = 0 ;\n i < REFERENCE_MODES ;\n ++ i ) best_pred_rd [ i ] = INT64_MAX ;\n for ( i = 0 ;\n i < SWITCHABLE_FILTER_CONTEXTS ;\n i ++ ) best_filter_rd [ i ] = INT64_MAX ;\n rate_uv_intra = INT_MAX ;\n * returnrate = INT_MAX ;\n for ( ref_frame = LAST_FRAME ;\n ref_frame <= ALTREF_FRAME ;\n ref_frame ++ ) {\n if ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) {\n setup_buffer_inter ( cpi , x , tile , ref_frame , bsize , mi_row , mi_col , frame_mv [ NEARESTMV ] , frame_mv [ NEARMV ] , yv12_mb ) ;\n }\n frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ;\n frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ;\n }\n for ( ref_index = 0 ;\n ref_index < MAX_REFS ;\n ++ ref_index ) {\n int mode_excluded = 0 ;\n int64_t this_rd = INT64_MAX ;\n int disable_skip = 0 ;\n int compmode_cost = 0 ;\n int rate2 = 0 , rate_y = 0 , rate_uv = 0 ;\n int64_t distortion2 = 0 , distortion_y = 0 , distortion_uv = 0 ;\n int skippable = 0 ;\n int i ;\n int this_skip2 = 0 ;\n int64_t total_sse = INT_MAX ;\n int early_term = 0 ;\n ref_frame = vp9_ref_order [ ref_index ] . ref_frame [ 0 ] ;\n second_ref_frame = vp9_ref_order [ ref_index ] . ref_frame [ 1 ] ;\n if ( ref_index > 2 && cpi -> sf . mode_skip_start < MAX_MODES ) {\n if ( ref_index == 3 ) {\n switch ( vp9_ref_order [ best_ref_index ] . ref_frame [ 0 ] ) {\n case INTRA_FRAME : mode_skip_mask = 0 ;\n break ;\n case LAST_FRAME : mode_skip_mask = 0x0010 ;\n break ;\n case GOLDEN_FRAME : mode_skip_mask = 0x0008 ;\n break ;\n case ALTREF_FRAME : mode_skip_mask = 0x0000 ;\n break ;\n case NONE : case MAX_REF_FRAMES : assert ( 0 && \"Invalid Reference frame\" ) ;\n break ;\n }\n }\n if ( mode_skip_mask & ( 1 << ref_index ) ) continue ;\n }\n if ( rd_less_than_thresh ( best_rd , rd_opt -> threshes [ segment_id ] [ bsize ] [ ref_index ] , rd_opt -> thresh_freq_fact [ bsize ] [ ref_index ] ) ) continue ;\n if ( ref_frame > INTRA_FRAME && ! ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) ) {\n continue ;\n }\n comp_pred = second_ref_frame > INTRA_FRAME ;\n if ( comp_pred ) {\n if ( ! cm -> allow_comp_inter_inter ) continue ;\n if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) continue ;\n if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) continue ;\n if ( ( cpi -> sf . mode_search_skip_flags & FLAG_SKIP_COMP_BESTINTRA ) && vp9_ref_order [ best_ref_index ] . ref_frame [ 0 ] == INTRA_FRAME ) continue ;\n if ( ( cpi -> sf . mode_search_skip_flags & FLAG_SKIP_COMP_REFMISMATCH ) && ref_frame != best_inter_ref_frame && second_ref_frame != best_inter_ref_frame ) continue ;\n }\n if ( ref_frame > INTRA_FRAME && vp9_is_scaled ( & cm -> frame_refs [ ref_frame - 1 ] . sf ) ) continue ;\n if ( second_ref_frame > INTRA_FRAME && vp9_is_scaled ( & cm -> frame_refs [ second_ref_frame - 1 ] . sf ) ) continue ;\n if ( comp_pred ) mode_excluded = cm -> reference_mode == SINGLE_REFERENCE ;\n else if ( ref_frame != INTRA_FRAME ) mode_excluded = cm -> reference_mode == COMPOUND_REFERENCE ;\n if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && vp9_get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) {\n continue ;\n }\n else if ( ! vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) {\n if ( cpi -> rc . is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) continue ;\n }\n mbmi -> tx_size = TX_4X4 ;\n mbmi -> uv_mode = DC_PRED ;\n mbmi -> ref_frame [ 0 ] = ref_frame ;\n mbmi -> ref_frame [ 1 ] = second_ref_frame ;\n mbmi -> interp_filter = cm -> interp_filter == SWITCHABLE ? EIGHTTAP : cm -> interp_filter ;\n x -> skip = 0 ;\n set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ;\n for ( i = 0 ;\n i < MAX_MB_PLANE ;\n i ++ ) {\n xd -> plane [ i ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ i ] ;\n if ( comp_pred ) xd -> plane [ i ] . pre [ 1 ] = yv12_mb [ second_ref_frame ] [ i ] ;\n }\n if ( ref_frame == INTRA_FRAME ) {\n int rate ;\n if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate , & rate_y , & distortion_y , best_rd ) >= best_rd ) continue ;\n rate2 += rate ;\n rate2 += intra_cost_penalty ;\n distortion2 += distortion_y ;\n if ( rate_uv_intra == INT_MAX ) {\n choose_intra_uv_mode ( cpi , ctx , bsize , TX_4X4 , & rate_uv_intra , & rate_uv_tokenonly , & dist_uv , & skip_uv , & mode_uv ) ;\n }\n rate2 += rate_uv_intra ;\n rate_uv = rate_uv_tokenonly ;\n distortion2 += dist_uv ;\n distortion_uv = dist_uv ;\n mbmi -> uv_mode = mode_uv ;\n }\n else {\n int rate ;\n int64_t distortion ;\n int64_t this_rd_thresh ;\n int64_t tmp_rd , tmp_best_rd = INT64_MAX , tmp_best_rdu = INT64_MAX ;\n int tmp_best_rate = INT_MAX , tmp_best_ratey = INT_MAX ;\n int64_t tmp_best_distortion = INT_MAX , tmp_best_sse , uv_sse ;\n int tmp_best_skippable = 0 ;\n int switchable_filter_index ;\n int_mv * second_ref = comp_pred ? & mbmi -> ref_mvs [ second_ref_frame ] [ 0 ] : NULL ;\n b_mode_info tmp_best_bmodes [ 16 ] ;\n MB_MODE_INFO tmp_best_mbmode ;\n BEST_SEG_INFO bsi [ SWITCHABLE_FILTERS ] ;\n int pred_exists = 0 ;\n int uv_skippable ;\n this_rd_thresh = ( ref_frame == LAST_FRAME ) ? rd_opt -> threshes [ segment_id ] [ bsize ] [ THR_LAST ] : rd_opt -> threshes [ segment_id ] [ bsize ] [ THR_ALTR ] ;\n this_rd_thresh = ( ref_frame == GOLDEN_FRAME ) ? rd_opt -> threshes [ segment_id ] [ bsize ] [ THR_GOLD ] : this_rd_thresh ;\n rd_opt -> mask_filter = 0 ;\n for ( i = 0 ;\n i < SWITCHABLE_FILTER_CONTEXTS ;\n ++ i ) rd_opt -> filter_cache [ i ] = INT64_MAX ;\n if ( cm -> interp_filter != BILINEAR ) {\n tmp_best_filter = EIGHTTAP ;\n if ( x -> source_variance < cpi -> sf . disable_filter_search_var_thresh ) {\n tmp_best_filter = EIGHTTAP ;\n }\n else if ( cpi -> sf . adaptive_pred_interp_filter == 1 && ctx -> pred_interp_filter < SWITCHABLE ) {\n tmp_best_filter = ctx -> pred_interp_filter ;\n }\n else if ( cpi -> sf . adaptive_pred_interp_filter == 2 ) {\n tmp_best_filter = ctx -> pred_interp_filter < SWITCHABLE ? ctx -> pred_interp_filter : 0 ;\n }\n else {\n for ( switchable_filter_index = 0 ;\n switchable_filter_index < SWITCHABLE_FILTERS ;\n ++ switchable_filter_index ) {\n int newbest , rs ;\n int64_t rs_rd ;\n mbmi -> interp_filter = switchable_filter_index ;\n tmp_rd = rd_pick_best_sub8x8_mode ( cpi , x , tile , & mbmi -> ref_mvs [ ref_frame ] [ 0 ] , second_ref , best_yrd , & rate , & rate_y , & distortion , & skippable , & total_sse , ( int ) this_rd_thresh , seg_mvs , bsi , switchable_filter_index , mi_row , mi_col ) ;\n if ( tmp_rd == INT64_MAX ) continue ;\n rs = vp9_get_switchable_rate ( cpi ) ;\n rs_rd = RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ;\n rd_opt -> filter_cache [ switchable_filter_index ] = tmp_rd ;\n rd_opt -> filter_cache [ SWITCHABLE_FILTERS ] = MIN ( rd_opt -> filter_cache [ SWITCHABLE_FILTERS ] , tmp_rd + rs_rd ) ;\n if ( cm -> interp_filter == SWITCHABLE ) tmp_rd += rs_rd ;\n rd_opt -> mask_filter = MAX ( rd_opt -> mask_filter , tmp_rd ) ;\n newbest = ( tmp_rd < tmp_best_rd ) ;\n if ( newbest ) {\n tmp_best_filter = mbmi -> interp_filter ;\n tmp_best_rd = tmp_rd ;\n }\n if ( ( newbest && cm -> interp_filter == SWITCHABLE ) || ( mbmi -> interp_filter == cm -> interp_filter && cm -> interp_filter != SWITCHABLE ) ) {\n tmp_best_rdu = tmp_rd ;\n tmp_best_rate = rate ;\n tmp_best_ratey = rate_y ;\n tmp_best_distortion = distortion ;\n tmp_best_sse = total_sse ;\n tmp_best_skippable = skippable ;\n tmp_best_mbmode = * mbmi ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n tmp_best_bmodes [ i ] = xd -> mi [ 0 ] -> bmi [ i ] ;\n x -> zcoeff_blk [ TX_4X4 ] [ i ] = ! x -> plane [ 0 ] . eobs [ i ] ;\n }\n pred_exists = 1 ;\n if ( switchable_filter_index == 0 && cpi -> sf . use_rd_breakout && best_rd < INT64_MAX ) {\n if ( tmp_best_rdu / 2 > best_rd ) {\n tmp_best_filter = mbmi -> interp_filter ;\n tmp_best_rdu = INT64_MAX ;\n break ;\n }\n }\n }\n }\n }\n }\n if ( tmp_best_rdu == INT64_MAX && pred_exists ) continue ;\n mbmi -> interp_filter = ( cm -> interp_filter == SWITCHABLE ? tmp_best_filter : cm -> interp_filter ) ;\n if ( ! pred_exists ) {\n tmp_rd = rd_pick_best_sub8x8_mode ( cpi , x , tile , & mbmi -> ref_mvs [ ref_frame ] [ 0 ] , second_ref , best_yrd , & rate , & rate_y , & distortion , & skippable , & total_sse , ( int ) this_rd_thresh , seg_mvs , bsi , 0 , mi_row , mi_col ) ;\n if ( tmp_rd == INT64_MAX ) continue ;\n }\n else {\n total_sse = tmp_best_sse ;\n rate = tmp_best_rate ;\n rate_y = tmp_best_ratey ;\n distortion = tmp_best_distortion ;\n skippable = tmp_best_skippable ;\n * mbmi = tmp_best_mbmode ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) xd -> mi [ 0 ] -> bmi [ i ] = tmp_best_bmodes [ i ] ;\n }\n rate2 += rate ;\n distortion2 += distortion ;\n if ( cm -> interp_filter == SWITCHABLE ) rate2 += vp9_get_switchable_rate ( cpi ) ;\n if ( ! mode_excluded ) mode_excluded = comp_pred ? cm -> reference_mode == SINGLE_REFERENCE : cm -> reference_mode == COMPOUND_REFERENCE ;\n compmode_cost = vp9_cost_bit ( comp_mode_p , comp_pred ) ;\n tmp_best_rdu = best_rd - MIN ( RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) , RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) ;\n if ( tmp_best_rdu > 0 ) {\n vp9_build_inter_predictors_sbuv ( & x -> e_mbd , mi_row , mi_col , BLOCK_8X8 ) ;\n super_block_uvrd ( cpi , x , & rate_uv , & distortion_uv , & uv_skippable , & uv_sse , BLOCK_8X8 , tmp_best_rdu ) ;\n if ( rate_uv == INT_MAX ) continue ;\n rate2 += rate_uv ;\n distortion2 += distortion_uv ;\n skippable = skippable && uv_skippable ;\n total_sse += uv_sse ;\n }\n }\n if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) rate2 += compmode_cost ;\n if ( second_ref_frame > INTRA_FRAME ) {\n rate2 += ref_costs_comp [ ref_frame ] ;\n }\n else {\n rate2 += ref_costs_single [ ref_frame ] ;\n }\n if ( ! disable_skip ) {\n if ( ref_frame != INTRA_FRAME && ! xd -> lossless ) {\n if ( RDCOST ( x -> rdmult , x -> rddiv , rate_y + rate_uv , distortion2 ) < RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) {\n rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ;\n }\n else {\n rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ;\n distortion2 = total_sse ;\n assert ( total_sse >= 0 ) ;\n rate2 -= ( rate_y + rate_uv ) ;\n rate_y = 0 ;\n rate_uv = 0 ;\n this_skip2 = 1 ;\n }\n }\n else {\n rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ;\n }\n this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ;\n }\n if ( is_inter_block ( mbmi ) && ! has_second_ref ( mbmi ) && ! mode_excluded && this_rd < best_inter_rd ) {\n best_inter_rd = this_rd ;\n best_inter_ref_frame = ref_frame ;\n }\n if ( ! disable_skip && ref_frame == INTRA_FRAME ) {\n for ( i = 0 ;\n i < REFERENCE_MODES ;\n ++ i ) best_pred_rd [ i ] = MIN ( best_pred_rd [ i ] , this_rd ) ;\n for ( i = 0 ;\n i < SWITCHABLE_FILTER_CONTEXTS ;\n i ++ ) best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , this_rd ) ;\n }\n if ( this_rd < best_rd || x -> skip ) {\n if ( ! mode_excluded ) {\n int max_plane = MAX_MB_PLANE ;\n best_ref_index = ref_index ;\n if ( ref_frame == INTRA_FRAME ) {\n mbmi -> mv [ 0 ] . as_int = 0 ;\n max_plane = 1 ;\n }\n * returnrate = rate2 ;\n * returndistortion = distortion2 ;\n best_rd = this_rd ;\n best_yrd = best_rd - RDCOST ( x -> rdmult , x -> rddiv , rate_uv , distortion_uv ) ;\n best_mbmode = * mbmi ;\n best_skip2 = this_skip2 ;\n if ( ! x -> select_tx_size ) swap_block_ptr ( x , ctx , 1 , 0 , 0 , max_plane ) ;\n vpx_memcpy ( ctx -> zcoeff_blk , x -> zcoeff_blk [ TX_4X4 ] , sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) best_bmodes [ i ] = xd -> mi [ 0 ] -> bmi [ i ] ;\n if ( ( cpi -> sf . mode_search_skip_flags & FLAG_EARLY_TERMINATE ) && ( ref_index > MIN_EARLY_TERM_INDEX ) ) {\n const int qstep = xd -> plane [ 0 ] . dequant [ 1 ] ;\n int scale = 4 ;\n if ( x -> source_variance < UINT_MAX ) {\n const int var_adjust = ( x -> source_variance < 16 ) ;\n scale -= var_adjust ;\n }\n if ( ref_frame > INTRA_FRAME && distortion2 * scale < qstep * qstep ) {\n early_term = 1 ;\n }\n }\n }\n }\n if ( ! disable_skip && ref_frame != INTRA_FRAME ) {\n int64_t single_rd , hybrid_rd , single_rate , hybrid_rate ;\n if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) {\n single_rate = rate2 - compmode_cost ;\n hybrid_rate = rate2 ;\n }\n else {\n single_rate = rate2 ;\n hybrid_rate = rate2 + compmode_cost ;\n }\n single_rd = RDCOST ( x -> rdmult , x -> rddiv , single_rate , distortion2 ) ;\n hybrid_rd = RDCOST ( x -> rdmult , x -> rddiv , hybrid_rate , distortion2 ) ;\n if ( ! comp_pred && single_rd < best_pred_rd [ SINGLE_REFERENCE ] ) {\n best_pred_rd [ SINGLE_REFERENCE ] = single_rd ;\n }\n else if ( comp_pred && single_rd < best_pred_rd [ COMPOUND_REFERENCE ] ) {\n best_pred_rd [ COMPOUND_REFERENCE ] = single_rd ;\n }\n if ( hybrid_rd < best_pred_rd [ REFERENCE_MODE_SELECT ] ) best_pred_rd [ REFERENCE_MODE_SELECT ] = hybrid_rd ;\n }\n if ( ! mode_excluded && ! disable_skip && ref_frame != INTRA_FRAME && cm -> interp_filter != BILINEAR ) {\n int64_t ref = rd_opt -> filter_cache [ cm -> interp_filter == SWITCHABLE ? SWITCHABLE_FILTERS : cm -> interp_filter ] ;\n int64_t adj_rd ;\n for ( i = 0 ;\n i < SWITCHABLE_FILTER_CONTEXTS ;\n i ++ ) {\n if ( ref == INT64_MAX ) adj_rd = 0 ;\n else if ( rd_opt -> filter_cache [ i ] == INT64_MAX ) adj_rd = rd_opt -> mask_filter - ref + 10 ;\n else adj_rd = rd_opt -> filter_cache [ i ] - ref ;\n adj_rd += this_rd ;\n best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , adj_rd ) ;\n }\n }\n if ( early_term ) break ;\n if ( x -> skip && ! comp_pred ) break ;\n }\n if ( best_rd >= best_rd_so_far ) return INT64_MAX ;\n if ( cpi -> sf . use_uv_intra_rd_estimate ) {\n if ( vp9_ref_order [ best_ref_index ] . ref_frame [ 0 ] == INTRA_FRAME ) {\n * mbmi = best_mbmode ;\n rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv_intra , & rate_uv_tokenonly , & dist_uv , & skip_uv , BLOCK_8X8 , TX_4X4 ) ;\n }\n }\n if ( best_rd == INT64_MAX ) {\n * returnrate = INT_MAX ;\n * returndistortion = INT64_MAX ;\n return best_rd ;\n }\n assert ( ( cm -> interp_filter == SWITCHABLE ) || ( cm -> interp_filter == best_mbmode . interp_filter ) || ! is_inter_block ( & best_mbmode ) ) ;\n update_rd_thresh_fact ( cpi , bsize , best_ref_index ) ;\n * mbmi = best_mbmode ;\n x -> skip |= best_skip2 ;\n if ( ! is_inter_block ( & best_mbmode ) ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) xd -> mi [ 0 ] -> bmi [ i ] . as_mode = best_bmodes [ i ] . as_mode ;\n }\n else {\n for ( i = 0 ;\n i < 4 ;\n ++ i ) vpx_memcpy ( & xd -> mi [ 0 ] -> bmi [ i ] , & best_bmodes [ i ] , sizeof ( b_mode_info ) ) ;\n mbmi -> mv [ 0 ] . as_int = xd -> mi [ 0 ] -> bmi [ 3 ] . as_mv [ 0 ] . as_int ;\n mbmi -> mv [ 1 ] . as_int = xd -> mi [ 0 ] -> bmi [ 3 ] . as_mv [ 1 ] . as_int ;\n }\n for ( i = 0 ;\n i < REFERENCE_MODES ;\n ++ i ) {\n if ( best_pred_rd [ i ] == INT64_MAX ) best_pred_diff [ i ] = INT_MIN ;\n else best_pred_diff [ i ] = best_rd - best_pred_rd [ i ] ;\n }\n if ( ! x -> skip ) {\n for ( i = 0 ;\n i < SWITCHABLE_FILTER_CONTEXTS ;\n i ++ ) {\n if ( best_filter_rd [ i ] == INT64_MAX ) best_filter_diff [ i ] = 0 ;\n else best_filter_diff [ i ] = best_rd - best_filter_rd [ i ] ;\n }\n if ( cm -> interp_filter == SWITCHABLE ) assert ( best_filter_diff [ SWITCHABLE_FILTERS ] == 0 ) ;\n }\n else {\n vp9_zero ( best_filter_diff ) ;\n }\n set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ;\n store_coding_context ( x , ctx , best_ref_index , best_pred_diff , best_tx_diff , best_filter_diff , 0 ) ;\n return best_rd ;\n }", "hash": 3887066622454352196, "project": "chrome", "size": 419, "target": 1, "idx": 22147}
{"code": "void vp9_change_config ( struct VP9_COMP * cpi , const VP9EncoderConfig * oxcf ) {\n VP9_COMMON * const cm = & cpi -> common ;\n RATE_CONTROL * const rc = & cpi -> rc ;\n if ( cm -> profile != oxcf -> profile ) cm -> profile = oxcf -> profile ;\n cm -> bit_depth = oxcf -> bit_depth ;\n if ( cm -> profile <= PROFILE_1 ) assert ( cm -> bit_depth == VPX_BITS_8 ) ;\n else assert ( cm -> bit_depth > VPX_BITS_8 ) ;\n cpi -> oxcf = * oxcf ;\n rc -> baseline_gf_interval = DEFAULT_GF_INTERVAL ;\n cpi -> refresh_golden_frame = 0 ;\n cpi -> refresh_last_frame = 1 ;\n cm -> refresh_frame_context = 1 ;\n cm -> reset_frame_context = 0 ;\n vp9_reset_segment_features ( & cm -> seg ) ;\n vp9_set_high_precision_mv ( cpi , 0 ) ;\n {\n int i ;\n for ( i = 0 ;\n i < MAX_SEGMENTS ;\n i ++ ) cpi -> segment_encode_breakout [ i ] = cpi -> oxcf . encode_breakout ;\n }\n cpi -> encode_breakout = cpi -> oxcf . encode_breakout ;\n set_rc_buffer_sizes ( rc , & cpi -> oxcf ) ;\n rc -> bits_off_target = MIN ( rc -> bits_off_target , rc -> maximum_buffer_size ) ;\n rc -> buffer_level = MIN ( rc -> buffer_level , rc -> maximum_buffer_size ) ;\n vp9_new_framerate ( cpi , cpi -> framerate ) ;\n rc -> worst_quality = cpi -> oxcf . worst_allowed_q ;\n rc -> best_quality = cpi -> oxcf . best_allowed_q ;\n cm -> interp_filter = cpi -> sf . default_interp_filter ;\n cm -> display_width = cpi -> oxcf . width ;\n cm -> display_height = cpi -> oxcf . height ;\n if ( cpi -> initial_width ) {\n assert ( cm -> width <= cpi -> initial_width ) ;\n assert ( cm -> height <= cpi -> initial_height ) ;\n }\n update_frame_size ( cpi ) ;\n if ( ( cpi -> svc . number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) || ( ( cpi -> svc . number_temporal_layers > 1 || cpi -> svc . number_spatial_layers > 1 ) && cpi -> oxcf . pass == 2 ) ) {\n vp9_update_layer_context_change_config ( cpi , ( int ) cpi -> oxcf . target_bandwidth ) ;\n }\n cpi -> alt_ref_source = NULL ;\n rc -> is_src_frame_alt_ref = 0 ;\n # if 0 cpi -> frame_distortion = 0 ;\n cpi -> last_frame_distortion = 0 ;\n # endif set_tile_limits ( cpi ) ;\n cpi -> ext_refresh_frame_flags_pending = 0 ;\n cpi -> ext_refresh_frame_context_pending = 0 ;\n # if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) {\n vp9_denoiser_alloc ( & ( cpi -> denoiser ) , cm -> width , cm -> height , cm -> subsampling_x , cm -> subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS ) ;\n }\n # endif }", "hash": -2222463888415249941, "project": "chrome", "size": 50, "target": 1, "idx": 22158}
{"code": "void vp9_init_plane_quantizers ( VP9_COMP * cpi , MACROBLOCK * x ) {\n const VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n QUANTS * const quants = & cpi -> quants ;\n const int segment_id = xd -> mi [ 0 ] -> mbmi . segment_id ;\n const int qindex = vp9_get_qindex ( & cm -> seg , segment_id , cm -> base_qindex ) ;\n const int rdmult = vp9_compute_rd_mult ( cpi , qindex + cm -> y_dc_delta_q ) ;\n const int zbin = cpi -> zbin_mode_boost ;\n int i ;\n x -> plane [ 0 ] . quant = quants -> y_quant [ qindex ] ;\n x -> plane [ 0 ] . quant_fp = quants -> y_quant_fp [ qindex ] ;\n x -> plane [ 0 ] . round_fp = quants -> y_round_fp [ qindex ] ;\n x -> plane [ 0 ] . quant_shift = quants -> y_quant_shift [ qindex ] ;\n x -> plane [ 0 ] . zbin = quants -> y_zbin [ qindex ] ;\n x -> plane [ 0 ] . round = quants -> y_round [ qindex ] ;\n x -> plane [ 0 ] . quant_thred [ 0 ] = cm -> y_dequant [ qindex ] [ 0 ] * cm -> y_dequant [ qindex ] [ 0 ] ;\n x -> plane [ 0 ] . quant_thred [ 1 ] = cm -> y_dequant [ qindex ] [ 1 ] * cm -> y_dequant [ qindex ] [ 1 ] ;\n x -> plane [ 0 ] . zbin_extra = ( int16_t ) ( ( cm -> y_dequant [ qindex ] [ 1 ] * zbin ) >> 7 ) ;\n xd -> plane [ 0 ] . dequant = cm -> y_dequant [ qindex ] ;\n for ( i = 1 ;\n i < 3 ;\n i ++ ) {\n x -> plane [ i ] . quant = quants -> uv_quant [ qindex ] ;\n x -> plane [ i ] . quant_fp = quants -> uv_quant_fp [ qindex ] ;\n x -> plane [ i ] . round_fp = quants -> uv_round_fp [ qindex ] ;\n x -> plane [ i ] . quant_shift = quants -> uv_quant_shift [ qindex ] ;\n x -> plane [ i ] . zbin = quants -> uv_zbin [ qindex ] ;\n x -> plane [ i ] . round = quants -> uv_round [ qindex ] ;\n x -> plane [ i ] . quant_thred [ 0 ] = cm -> y_dequant [ qindex ] [ 0 ] * cm -> y_dequant [ qindex ] [ 0 ] ;\n x -> plane [ i ] . quant_thred [ 1 ] = cm -> y_dequant [ qindex ] [ 1 ] * cm -> y_dequant [ qindex ] [ 1 ] ;\n x -> plane [ i ] . zbin_extra = ( int16_t ) ( ( cm -> uv_dequant [ qindex ] [ 1 ] * zbin ) >> 7 ) ;\n xd -> plane [ i ] . dequant = cm -> uv_dequant [ qindex ] ;\n }\n x -> skip_block = vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ;\n x -> q_index = qindex ;\n x -> errorperbit = rdmult >> 6 ;\n x -> errorperbit += ( x -> errorperbit == 0 ) ;\n vp9_initialize_me_consts ( cpi , x -> q_index ) ;\n }", "hash": 4423867112908498696, "project": "chrome", "size": 39, "target": 1, "idx": 22166}
{"code": "static vpx_codec_err_t parse_scale_factors ( SvcContext * svc_ctx , const char * scale_factors ) {\n char * input_string ;\n char * token ;\n const char * delim = \",\" ;\n char * save_ptr ;\n int found = 0 ;\n int i ;\n int64_t num , den ;\n vpx_codec_err_t res = VPX_CODEC_OK ;\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n if ( scale_factors == NULL || strlen ( scale_factors ) == 0 ) {\n input_string = strdup ( DEFAULT_SCALE_FACTORS ) ;\n }\n else {\n input_string = strdup ( scale_factors ) ;\n }\n token = strtok_r ( input_string , delim , & save_ptr ) ;\n for ( i = 0 ;\n i < svc_ctx -> spatial_layers ;\n ++ i ) {\n num = den = 0 ;\n if ( token != NULL ) {\n num = strtol ( token , & token , 10 ) ;\n if ( num <= 0 ) {\n log_invalid_scale_factor ( svc_ctx , token ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n break ;\n }\n if ( * token ++ != '/' ) {\n log_invalid_scale_factor ( svc_ctx , token ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n break ;\n }\n den = strtol ( token , & token , 10 ) ;\n if ( den <= 0 ) {\n log_invalid_scale_factor ( svc_ctx , token ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n break ;\n }\n token = strtok_r ( NULL , delim , & save_ptr ) ;\n found = i + 1 ;\n }\n si -> scaling_factor_num [ i + VPX_SS_MAX_LAYERS - svc_ctx -> spatial_layers ] = ( int ) num ;\n si -> scaling_factor_den [ i + VPX_SS_MAX_LAYERS - svc_ctx -> spatial_layers ] = ( int ) den ;\n }\n if ( res == VPX_CODEC_OK && found != svc_ctx -> spatial_layers ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc: scale-factors: %d values required, but only %d specified\\n\" , svc_ctx -> spatial_layers , found ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n }\n free ( input_string ) ;\n return res ;\n }", "hash": 5400542917484463750, "project": "chrome", "size": 52, "target": 1, "idx": 22207}
{"code": "static int estimate_bits_at_q ( FRAME_TYPE frame_type , int q , int mbs , double correction_factor ) {\n const int bpm = ( int ) ( vp9_rc_bits_per_mb ( frame_type , q , correction_factor ) ) ;\n return ( ( uint64_t ) bpm * mbs ) >> BPER_MB_NORMBITS ;\n }", "hash": -7117046864335130087, "project": "chrome", "size": 4, "target": 1, "idx": 22217}
{"code": "int vp9_rc_bits_per_mb ( FRAME_TYPE frame_type , int qindex , double correction_factor ) {\n const double q = vp9_convert_qindex_to_q ( qindex ) ;\n int enumerator = frame_type == KEY_FRAME ? 3300000 : 2250000 ;\n enumerator += ( int ) ( enumerator * q ) >> 12 ;\n return ( int ) ( enumerator * correction_factor / q ) ;\n }", "hash": -7117046864335130087, "project": "chrome", "size": 6, "target": 1, "idx": 22219}
{"code": "static int rc_pick_q_and_bounds_one_pass_cbr ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) {\n const VP9_COMMON * const cm = & cpi -> common ;\n const RATE_CONTROL * const rc = & cpi -> rc ;\n int active_best_quality ;\n int active_worst_quality = calc_active_worst_quality_one_pass_cbr ( cpi ) ;\n int q ;\n if ( frame_is_intra_only ( cm ) ) {\n active_best_quality = rc -> best_quality ;\n if ( rc -> this_key_frame_forced ) {\n int qindex = rc -> last_boosted_qindex ;\n double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ;\n int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , ( last_boosted_q * 0.75 ) ) ;\n active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ;\n }\n else if ( cm -> current_video_frame > 0 ) {\n double q_adj_factor = 1.0 ;\n double q_val ;\n active_best_quality = get_kf_active_quality ( rc , rc -> avg_frame_qindex [ KEY_FRAME ] ) ;\n if ( ( cm -> width * cm -> height ) <= ( 352 * 288 ) ) {\n q_adj_factor -= 0.25 ;\n }\n q_val = vp9_convert_qindex_to_q ( active_best_quality ) ;\n active_best_quality += vp9_compute_qdelta ( rc , q_val , q_val * q_adj_factor ) ;\n }\n }\n else if ( ! rc -> is_src_frame_alt_ref && ! cpi -> use_svc && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) {\n if ( rc -> frames_since_key > 1 && rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) {\n q = rc -> avg_frame_qindex [ INTER_FRAME ] ;\n }\n else {\n q = active_worst_quality ;\n }\n active_best_quality = get_gf_active_quality ( rc , q ) ;\n }\n else {\n if ( cm -> current_video_frame > 1 ) {\n if ( rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) active_best_quality = rtc_minq [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ;\n else active_best_quality = rtc_minq [ active_worst_quality ] ;\n }\n else {\n if ( rc -> avg_frame_qindex [ KEY_FRAME ] < active_worst_quality ) active_best_quality = rtc_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ;\n else active_best_quality = rtc_minq [ active_worst_quality ] ;\n }\n }\n active_best_quality = clamp ( active_best_quality , rc -> best_quality , rc -> worst_quality ) ;\n active_worst_quality = clamp ( active_worst_quality , active_best_quality , rc -> worst_quality ) ;\n * top_index = active_worst_quality ;\n * bottom_index = active_best_quality ;\n # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced && ! ( cm -> current_video_frame == 0 ) ) {\n int qdelta = 0 ;\n vp9_clear_system_state ( ) ;\n qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 ) ;\n * top_index = active_worst_quality + qdelta ;\n * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index ;\n }\n # endif if ( cm -> frame_type == KEY_FRAME && rc -> this_key_frame_forced ) {\n q = rc -> last_boosted_qindex ;\n }\n else {\n q = vp9_rc_regulate_q ( cpi , rc -> this_frame_target , active_best_quality , active_worst_quality ) ;\n if ( q > * top_index ) {\n if ( rc -> this_frame_target >= rc -> max_frame_bandwidth ) * top_index = q ;\n else q = * top_index ;\n }\n }\n assert ( * top_index <= rc -> worst_quality && * top_index >= rc -> best_quality ) ;\n assert ( * bottom_index <= rc -> worst_quality && * bottom_index >= rc -> best_quality ) ;\n assert ( q <= rc -> worst_quality && q >= rc -> best_quality ) ;\n return q ;\n }", "hash": -7117046864335130087, "project": "chrome", "size": 70, "target": 1, "idx": 22225}
{"code": "void vp9_rc_update_rate_correction_factors ( VP9_COMP * cpi , int damp_var ) {\n const VP9_COMMON * const cm = & cpi -> common ;\n int correction_factor = 100 ;\n double rate_correction_factor = get_rate_correction_factor ( cpi ) ;\n double adjustment_limit ;\n int projected_size_based_on_q = 0 ;\n if ( cpi -> rc . is_src_frame_alt_ref ) return ;\n vp9_clear_system_state ( ) ;\n projected_size_based_on_q = estimate_bits_at_q ( cm -> frame_type , cm -> base_qindex , cm -> MBs , rate_correction_factor ) ;\n if ( projected_size_based_on_q > 0 ) correction_factor = ( 100 * cpi -> rc . projected_frame_size ) / projected_size_based_on_q ;\n switch ( damp_var ) {\n case 0 : adjustment_limit = 0.75 ;\n break ;\n case 1 : adjustment_limit = 0.375 ;\n break ;\n case 2 : default : adjustment_limit = 0.25 ;\n break ;\n }\n if ( correction_factor > 102 ) {\n correction_factor = ( int ) ( 100 + ( ( correction_factor - 100 ) * adjustment_limit ) ) ;\n rate_correction_factor = ( rate_correction_factor * correction_factor ) / 100 ;\n if ( rate_correction_factor > MAX_BPB_FACTOR ) rate_correction_factor = MAX_BPB_FACTOR ;\n }\n else if ( correction_factor < 99 ) {\n correction_factor = ( int ) ( 100 - ( ( 100 - correction_factor ) * adjustment_limit ) ) ;\n rate_correction_factor = ( rate_correction_factor * correction_factor ) / 100 ;\n if ( rate_correction_factor < MIN_BPB_FACTOR ) rate_correction_factor = MIN_BPB_FACTOR ;\n }\n set_rate_correction_factor ( cpi , rate_correction_factor ) ;\n }", "hash": -7117046864335130087, "project": "chrome", "size": 30, "target": 1, "idx": 22226}
{"code": "void vp9_lpf_horizontal_8_dual_sse2 ( uint8_t * s , int p , const uint8_t * _blimit0 , const uint8_t * _limit0 , const uint8_t * _thresh0 , const uint8_t * _blimit1 , const uint8_t * _limit1 , const uint8_t * _thresh1 ) {\n DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , flat_op2 , 16 ) ;\n DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , flat_op1 , 16 ) ;\n DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , flat_op0 , 16 ) ;\n DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , flat_oq2 , 16 ) ;\n DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , flat_oq1 , 16 ) ;\n DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , flat_oq0 , 16 ) ;\n const __m128i zero = _mm_set1_epi16 ( 0 ) ;\n const __m128i blimit = _mm_unpacklo_epi64 ( _mm_load_si128 ( ( const __m128i * ) _blimit0 ) , _mm_load_si128 ( ( const __m128i * ) _blimit1 ) ) ;\n const __m128i limit = _mm_unpacklo_epi64 ( _mm_load_si128 ( ( const __m128i * ) _limit0 ) , _mm_load_si128 ( ( const __m128i * ) _limit1 ) ) ;\n const __m128i thresh = _mm_unpacklo_epi64 ( _mm_load_si128 ( ( const __m128i * ) _thresh0 ) , _mm_load_si128 ( ( const __m128i * ) _thresh1 ) ) ;\n __m128i mask , hev , flat ;\n __m128i p3 , p2 , p1 , p0 , q0 , q1 , q2 , q3 ;\n p3 = _mm_loadu_si128 ( ( __m128i * ) ( s - 4 * p ) ) ;\n p2 = _mm_loadu_si128 ( ( __m128i * ) ( s - 3 * p ) ) ;\n p1 = _mm_loadu_si128 ( ( __m128i * ) ( s - 2 * p ) ) ;\n p0 = _mm_loadu_si128 ( ( __m128i * ) ( s - 1 * p ) ) ;\n q0 = _mm_loadu_si128 ( ( __m128i * ) ( s - 0 * p ) ) ;\n q1 = _mm_loadu_si128 ( ( __m128i * ) ( s + 1 * p ) ) ;\n q2 = _mm_loadu_si128 ( ( __m128i * ) ( s + 2 * p ) ) ;\n q3 = _mm_loadu_si128 ( ( __m128i * ) ( s + 3 * p ) ) ;\n {\n const __m128i abs_p1p0 = _mm_or_si128 ( _mm_subs_epu8 ( p1 , p0 ) , _mm_subs_epu8 ( p0 , p1 ) ) ;\n const __m128i abs_q1q0 = _mm_or_si128 ( _mm_subs_epu8 ( q1 , q0 ) , _mm_subs_epu8 ( q0 , q1 ) ) ;\n const __m128i one = _mm_set1_epi8 ( 1 ) ;\n const __m128i fe = _mm_set1_epi8 ( 0xfe ) ;\n const __m128i ff = _mm_cmpeq_epi8 ( abs_p1p0 , abs_p1p0 ) ;\n __m128i abs_p0q0 = _mm_or_si128 ( _mm_subs_epu8 ( p0 , q0 ) , _mm_subs_epu8 ( q0 , p0 ) ) ;\n __m128i abs_p1q1 = _mm_or_si128 ( _mm_subs_epu8 ( p1 , q1 ) , _mm_subs_epu8 ( q1 , p1 ) ) ;\n __m128i work ;\n flat = _mm_max_epu8 ( abs_p1p0 , abs_q1q0 ) ;\n hev = _mm_subs_epu8 ( flat , thresh ) ;\n hev = _mm_xor_si128 ( _mm_cmpeq_epi8 ( hev , zero ) , ff ) ;\n abs_p0q0 = _mm_adds_epu8 ( abs_p0q0 , abs_p0q0 ) ;\n abs_p1q1 = _mm_srli_epi16 ( _mm_and_si128 ( abs_p1q1 , fe ) , 1 ) ;\n mask = _mm_subs_epu8 ( _mm_adds_epu8 ( abs_p0q0 , abs_p1q1 ) , blimit ) ;\n mask = _mm_xor_si128 ( _mm_cmpeq_epi8 ( mask , zero ) , ff ) ;\n mask = _mm_max_epu8 ( flat , mask ) ;\n work = _mm_max_epu8 ( _mm_or_si128 ( _mm_subs_epu8 ( p2 , p1 ) , _mm_subs_epu8 ( p1 , p2 ) ) , _mm_or_si128 ( _mm_subs_epu8 ( p3 , p2 ) , _mm_subs_epu8 ( p2 , p3 ) ) ) ;\n mask = _mm_max_epu8 ( work , mask ) ;\n work = _mm_max_epu8 ( _mm_or_si128 ( _mm_subs_epu8 ( q2 , q1 ) , _mm_subs_epu8 ( q1 , q2 ) ) , _mm_or_si128 ( _mm_subs_epu8 ( q3 , q2 ) , _mm_subs_epu8 ( q2 , q3 ) ) ) ;\n mask = _mm_max_epu8 ( work , mask ) ;\n mask = _mm_subs_epu8 ( mask , limit ) ;\n mask = _mm_cmpeq_epi8 ( mask , zero ) ;\n work = _mm_max_epu8 ( _mm_or_si128 ( _mm_subs_epu8 ( p2 , p0 ) , _mm_subs_epu8 ( p0 , p2 ) ) , _mm_or_si128 ( _mm_subs_epu8 ( q2 , q0 ) , _mm_subs_epu8 ( q0 , q2 ) ) ) ;\n flat = _mm_max_epu8 ( work , flat ) ;\n work = _mm_max_epu8 ( _mm_or_si128 ( _mm_subs_epu8 ( p3 , p0 ) , _mm_subs_epu8 ( p0 , p3 ) ) , _mm_or_si128 ( _mm_subs_epu8 ( q3 , q0 ) , _mm_subs_epu8 ( q0 , q3 ) ) ) ;\n flat = _mm_max_epu8 ( work , flat ) ;\n flat = _mm_subs_epu8 ( flat , one ) ;\n flat = _mm_cmpeq_epi8 ( flat , zero ) ;\n flat = _mm_and_si128 ( flat , mask ) ;\n }\n {\n const __m128i four = _mm_set1_epi16 ( 4 ) ;\n unsigned char * src = s ;\n int i = 0 ;\n do {\n __m128i workp_a , workp_b , workp_shft ;\n p3 = _mm_unpacklo_epi8 ( _mm_loadl_epi64 ( ( __m128i * ) ( src - 4 * p ) ) , zero ) ;\n p2 = _mm_unpacklo_epi8 ( _mm_loadl_epi64 ( ( __m128i * ) ( src - 3 * p ) ) , zero ) ;\n p1 = _mm_unpacklo_epi8 ( _mm_loadl_epi64 ( ( __m128i * ) ( src - 2 * p ) ) , zero ) ;\n p0 = _mm_unpacklo_epi8 ( _mm_loadl_epi64 ( ( __m128i * ) ( src - 1 * p ) ) , zero ) ;\n q0 = _mm_unpacklo_epi8 ( _mm_loadl_epi64 ( ( __m128i * ) ( src - 0 * p ) ) , zero ) ;\n q1 = _mm_unpacklo_epi8 ( _mm_loadl_epi64 ( ( __m128i * ) ( src + 1 * p ) ) , zero ) ;\n q2 = _mm_unpacklo_epi8 ( _mm_loadl_epi64 ( ( __m128i * ) ( src + 2 * p ) ) , zero ) ;\n q3 = _mm_unpacklo_epi8 ( _mm_loadl_epi64 ( ( __m128i * ) ( src + 3 * p ) ) , zero ) ;\n workp_a = _mm_add_epi16 ( _mm_add_epi16 ( p3 , p3 ) , _mm_add_epi16 ( p2 , p1 ) ) ;\n workp_a = _mm_add_epi16 ( _mm_add_epi16 ( workp_a , four ) , p0 ) ;\n workp_b = _mm_add_epi16 ( _mm_add_epi16 ( q0 , p2 ) , p3 ) ;\n workp_shft = _mm_srli_epi16 ( _mm_add_epi16 ( workp_a , workp_b ) , 3 ) ;\n _mm_storel_epi64 ( ( __m128i * ) & flat_op2 [ i * 8 ] , _mm_packus_epi16 ( workp_shft , workp_shft ) ) ;\n workp_b = _mm_add_epi16 ( _mm_add_epi16 ( q0 , q1 ) , p1 ) ;\n workp_shft = _mm_srli_epi16 ( _mm_add_epi16 ( workp_a , workp_b ) , 3 ) ;\n _mm_storel_epi64 ( ( __m128i * ) & flat_op1 [ i * 8 ] , _mm_packus_epi16 ( workp_shft , workp_shft ) ) ;\n workp_a = _mm_add_epi16 ( _mm_sub_epi16 ( workp_a , p3 ) , q2 ) ;\n workp_b = _mm_add_epi16 ( _mm_sub_epi16 ( workp_b , p1 ) , p0 ) ;\n workp_shft = _mm_srli_epi16 ( _mm_add_epi16 ( workp_a , workp_b ) , 3 ) ;\n _mm_storel_epi64 ( ( __m128i * ) & flat_op0 [ i * 8 ] , _mm_packus_epi16 ( workp_shft , workp_shft ) ) ;\n workp_a = _mm_add_epi16 ( _mm_sub_epi16 ( workp_a , p3 ) , q3 ) ;\n workp_b = _mm_add_epi16 ( _mm_sub_epi16 ( workp_b , p0 ) , q0 ) ;\n workp_shft = _mm_srli_epi16 ( _mm_add_epi16 ( workp_a , workp_b ) , 3 ) ;\n _mm_storel_epi64 ( ( __m128i * ) & flat_oq0 [ i * 8 ] , _mm_packus_epi16 ( workp_shft , workp_shft ) ) ;\n workp_a = _mm_add_epi16 ( _mm_sub_epi16 ( workp_a , p2 ) , q3 ) ;\n workp_b = _mm_add_epi16 ( _mm_sub_epi16 ( workp_b , q0 ) , q1 ) ;\n workp_shft = _mm_srli_epi16 ( _mm_add_epi16 ( workp_a , workp_b ) , 3 ) ;\n _mm_storel_epi64 ( ( __m128i * ) & flat_oq1 [ i * 8 ] , _mm_packus_epi16 ( workp_shft , workp_shft ) ) ;\n workp_a = _mm_add_epi16 ( _mm_sub_epi16 ( workp_a , p1 ) , q3 ) ;\n workp_b = _mm_add_epi16 ( _mm_sub_epi16 ( workp_b , q1 ) , q2 ) ;\n workp_shft = _mm_srli_epi16 ( _mm_add_epi16 ( workp_a , workp_b ) , 3 ) ;\n _mm_storel_epi64 ( ( __m128i * ) & flat_oq2 [ i * 8 ] , _mm_packus_epi16 ( workp_shft , workp_shft ) ) ;\n src += 8 ;\n }\n while ( ++ i < 2 ) ;\n }\n {\n const __m128i t4 = _mm_set1_epi8 ( 4 ) ;\n const __m128i t3 = _mm_set1_epi8 ( 3 ) ;\n const __m128i t80 = _mm_set1_epi8 ( 0x80 ) ;\n const __m128i te0 = _mm_set1_epi8 ( 0xe0 ) ;\n const __m128i t1f = _mm_set1_epi8 ( 0x1f ) ;\n const __m128i t1 = _mm_set1_epi8 ( 0x1 ) ;\n const __m128i t7f = _mm_set1_epi8 ( 0x7f ) ;\n const __m128i ps1 = _mm_xor_si128 ( _mm_loadu_si128 ( ( __m128i * ) ( s - 2 * p ) ) , t80 ) ;\n const __m128i ps0 = _mm_xor_si128 ( _mm_loadu_si128 ( ( __m128i * ) ( s - 1 * p ) ) , t80 ) ;\n const __m128i qs0 = _mm_xor_si128 ( _mm_loadu_si128 ( ( __m128i * ) ( s + 0 * p ) ) , t80 ) ;\n const __m128i qs1 = _mm_xor_si128 ( _mm_loadu_si128 ( ( __m128i * ) ( s + 1 * p ) ) , t80 ) ;\n __m128i filt ;\n __m128i work_a ;\n __m128i filter1 , filter2 ;\n filt = _mm_and_si128 ( _mm_subs_epi8 ( ps1 , qs1 ) , hev ) ;\n work_a = _mm_subs_epi8 ( qs0 , ps0 ) ;\n filt = _mm_adds_epi8 ( filt , work_a ) ;\n filt = _mm_adds_epi8 ( filt , work_a ) ;\n filt = _mm_adds_epi8 ( filt , work_a ) ;\n filt = _mm_and_si128 ( filt , mask ) ;\n filter1 = _mm_adds_epi8 ( filt , t4 ) ;\n filter2 = _mm_adds_epi8 ( filt , t3 ) ;\n work_a = _mm_cmpgt_epi8 ( zero , filter1 ) ;\n filter1 = _mm_srli_epi16 ( filter1 , 3 ) ;\n work_a = _mm_and_si128 ( work_a , te0 ) ;\n filter1 = _mm_and_si128 ( filter1 , t1f ) ;\n filter1 = _mm_or_si128 ( filter1 , work_a ) ;\n work_a = _mm_cmpgt_epi8 ( zero , filter2 ) ;\n filter2 = _mm_srli_epi16 ( filter2 , 3 ) ;\n work_a = _mm_and_si128 ( work_a , te0 ) ;\n filter2 = _mm_and_si128 ( filter2 , t1f ) ;\n filter2 = _mm_or_si128 ( filter2 , work_a ) ;\n filt = _mm_adds_epi8 ( filter1 , t1 ) ;\n work_a = _mm_cmpgt_epi8 ( zero , filt ) ;\n filt = _mm_srli_epi16 ( filt , 1 ) ;\n work_a = _mm_and_si128 ( work_a , t80 ) ;\n filt = _mm_and_si128 ( filt , t7f ) ;\n filt = _mm_or_si128 ( filt , work_a ) ;\n filt = _mm_andnot_si128 ( hev , filt ) ;\n work_a = _mm_xor_si128 ( _mm_subs_epi8 ( qs0 , filter1 ) , t80 ) ;\n q0 = _mm_load_si128 ( ( __m128i * ) flat_oq0 ) ;\n work_a = _mm_andnot_si128 ( flat , work_a ) ;\n q0 = _mm_and_si128 ( flat , q0 ) ;\n q0 = _mm_or_si128 ( work_a , q0 ) ;\n work_a = _mm_xor_si128 ( _mm_subs_epi8 ( qs1 , filt ) , t80 ) ;\n q1 = _mm_load_si128 ( ( __m128i * ) flat_oq1 ) ;\n work_a = _mm_andnot_si128 ( flat , work_a ) ;\n q1 = _mm_and_si128 ( flat , q1 ) ;\n q1 = _mm_or_si128 ( work_a , q1 ) ;\n work_a = _mm_loadu_si128 ( ( __m128i * ) ( s + 2 * p ) ) ;\n q2 = _mm_load_si128 ( ( __m128i * ) flat_oq2 ) ;\n work_a = _mm_andnot_si128 ( flat , work_a ) ;\n q2 = _mm_and_si128 ( flat , q2 ) ;\n q2 = _mm_or_si128 ( work_a , q2 ) ;\n work_a = _mm_xor_si128 ( _mm_adds_epi8 ( ps0 , filter2 ) , t80 ) ;\n p0 = _mm_load_si128 ( ( __m128i * ) flat_op0 ) ;\n work_a = _mm_andnot_si128 ( flat , work_a ) ;\n p0 = _mm_and_si128 ( flat , p0 ) ;\n p0 = _mm_or_si128 ( work_a , p0 ) ;\n work_a = _mm_xor_si128 ( _mm_adds_epi8 ( ps1 , filt ) , t80 ) ;\n p1 = _mm_load_si128 ( ( __m128i * ) flat_op1 ) ;\n work_a = _mm_andnot_si128 ( flat , work_a ) ;\n p1 = _mm_and_si128 ( flat , p1 ) ;\n p1 = _mm_or_si128 ( work_a , p1 ) ;\n work_a = _mm_loadu_si128 ( ( __m128i * ) ( s - 3 * p ) ) ;\n p2 = _mm_load_si128 ( ( __m128i * ) flat_op2 ) ;\n work_a = _mm_andnot_si128 ( flat , work_a ) ;\n p2 = _mm_and_si128 ( flat , p2 ) ;\n p2 = _mm_or_si128 ( work_a , p2 ) ;\n _mm_storeu_si128 ( ( __m128i * ) ( s - 3 * p ) , p2 ) ;\n _mm_storeu_si128 ( ( __m128i * ) ( s - 2 * p ) , p1 ) ;\n _mm_storeu_si128 ( ( __m128i * ) ( s - 1 * p ) , p0 ) ;\n _mm_storeu_si128 ( ( __m128i * ) ( s + 0 * p ) , q0 ) ;\n _mm_storeu_si128 ( ( __m128i * ) ( s + 1 * p ) , q1 ) ;\n _mm_storeu_si128 ( ( __m128i * ) ( s + 2 * p ) , q2 ) ;\n }\n }", "hash": 4701140738883197535, "project": "chrome", "size": 172, "target": 1, "idx": 22239}
{"code": "IN_PROC_BROWSER_TEST_F ( ClientHintsBrowserTest , ClientHintsLifetimeNotPersistedCookiesBlocked ) {\n scoped_refptr < content_settings : : CookieSettings > cookie_settings_ = CookieSettingsFactory : : GetForProfile ( browser ( ) -> profile ( ) ) ;\n base : : HistogramTester histogram_tester ;\n ContentSettingsForOneType host_settings ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> SetContentSettingDefaultScope ( accept_ch_without_lifetime_url ( ) , GURL ( ) , CONTENT_SETTINGS_TYPE_COOKIES , std : : string ( ) , CONTENT_SETTING_BLOCK ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_with_lifetime_url ( ) ) ;\n histogram_tester . ExpectTotalCount ( \"ClientHints.UpdateEventCount\" , 0 ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;\n EXPECT_EQ ( 0u , host_settings . size ( ) ) ;\n cookie_settings_ -> SetCookieSetting ( accept_ch_without_lifetime_url ( ) , CONTENT_SETTING_ALLOW ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_with_lifetime_url ( ) ) ;\n histogram_tester . ExpectTotalCount ( \"ClientHints.UpdateEventCount\" , 1 ) ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;\n EXPECT_EQ ( 1u , host_settings . size ( ) ) ;\n }", "hash": 6752827389510428348, "project": "chrome", "size": 15, "target": 1, "idx": 22251}
{"code": "IN_PROC_BROWSER_TEST_F ( ExternalProtocolDialogBrowserTest , TestCloseWithChecked ) {\n ShowDialog ( ) ;\n SetChecked ( true ) ;\n EXPECT_TRUE ( dialog_ -> Close ( ) ) ;\n EXPECT_TRUE ( called_ ) ;\n EXPECT_FALSE ( accept_ ) ;\n EXPECT_TRUE ( cancel_ ) ;\n EXPECT_FALSE ( dont_block_ ) ;\n histogram_tester_ . ExpectTotalCount ( ExternalProtocolHandler : : kRememberCheckboxMetric , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( ExternalProtocolHandler : : kHandleStateMetric , 0 ) ;\n }", "hash": -770464550770502023, "project": "chrome", "size": 11, "target": 1, "idx": 22261}
{"code": "int main ( int argc , char * * argv ) {\n using std : : string ;\n if ( argc != 2 ) {\n fprintf ( stderr , \"One argument, the input filename, must be provided.\\n\" ) ;\n return 1 ;\n }\n string filename ( argv [ 1 ] ) ;\n string outfilename = filename . substr ( 0 , filename . find_last_of ( \".\" ) ) + \".ttf\" ;\n fprintf ( stdout , \"Processing %s => %s\\n\" , filename . c_str ( ) , outfilename . c_str ( ) ) ;\n string input = woff2 : : GetFileContent ( filename ) ;\n size_t decompressed_size = woff2 : : ComputeWOFF2FinalSize ( reinterpret_cast < const uint8_t * > ( input . data ( ) ) , input . size ( ) ) ;\n string output ( decompressed_size , 0 ) ;\n const bool ok = woff2 : : ConvertWOFF2ToTTF ( reinterpret_cast < uint8_t * > ( & output [ 0 ] ) , decompressed_size , reinterpret_cast < const uint8_t * > ( input . data ( ) ) , input . size ( ) ) ;\n if ( ! ok ) {\n fprintf ( stderr , \"Decompression failed\\n\" ) ;\n return 1 ;\n }\n woff2 : : SetFileContents ( outfilename , output ) ;\n return 0 ;\n }", "hash": 2898965519451754076, "project": "chrome", "size": 20, "target": 1, "idx": 22265}
{"code": "static void _LMBCSClose ( UConverter * _this ) {\n if ( _this -> extraInfo != NULL ) {\n ulmbcs_byte_t Ix ;\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) _this -> extraInfo ;\n for ( Ix = 0 ;\n Ix <= ULMBCS_GRP_LAST ;\n Ix ++ ) {\n if ( extraInfo -> OptGrpConverter [ Ix ] != NULL ) ucnv_unloadSharedDataIfReady ( extraInfo -> OptGrpConverter [ Ix ] ) ;\n }\n if ( ! _this -> isExtraLocal ) {\n uprv_free ( _this -> extraInfo ) ;\n _this -> extraInfo = NULL ;\n }\n }\n }", "hash": 7072059544915633710, "project": "chrome", "size": 15, "target": 1, "idx": 22280}
{"code": "static void _LMBCSOpen ## n ( UConverter * _this , UConverterLoadArgs * pArgs , UErrorCode * err ) \\ {\n _LMBCSOpenWorker ( _this , pArgs , err , n ) ;\n }\n static void _LMBCSOpenWorker ( UConverter * _this , UConverterLoadArgs * pArgs , UErrorCode * err , ulmbcs_byte_t OptGroup ) {\n UConverterDataLMBCS * extraInfo = _this -> extraInfo = ( UConverterDataLMBCS * ) uprv_malloc ( sizeof ( UConverterDataLMBCS ) ) ;\n if ( extraInfo != NULL ) {\n UConverterNamePieces stackPieces ;\n UConverterLoadArgs stackArgs = {\n ( int32_t ) sizeof ( UConverterLoadArgs ) }\n ;\n ulmbcs_byte_t i ;\n uprv_memset ( extraInfo , 0 , sizeof ( UConverterDataLMBCS ) ) ;\n stackArgs . onlyTestIsLoadable = pArgs -> onlyTestIsLoadable ;\n for ( i = 0 ;\n i <= ULMBCS_GRP_LAST && U_SUCCESS ( * err ) ;\n i ++ ) {\n if ( OptGroupByteToCPName [ i ] != NULL ) {\n extraInfo -> OptGrpConverter [ i ] = ucnv_loadSharedData ( OptGroupByteToCPName [ i ] , & stackPieces , & stackArgs , err ) ;\n }\n }\n if ( U_FAILURE ( * err ) || pArgs -> onlyTestIsLoadable ) {\n _LMBCSClose ( _this ) ;\n return ;\n }\n extraInfo -> OptGroup = OptGroup ;\n extraInfo -> localeConverterIndex = FindLMBCSLocale ( pArgs -> locale ) ;\n }\n else {\n * err = U_MEMORY_ALLOCATION_ERROR ;\n }\n }\n static void _LMBCSClose ( UConverter * _this ) {\n if ( _this -> extraInfo != NULL ) {\n ulmbcs_byte_t Ix ;\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) _this -> extraInfo ;\n for ( Ix = 0 ;\n Ix <= ULMBCS_GRP_LAST ;\n Ix ++ ) {\n if ( extraInfo -> OptGrpConverter [ Ix ] != NULL ) ucnv_unloadSharedDataIfReady ( extraInfo -> OptGrpConverter [ Ix ] ) ;\n }\n if ( ! _this -> isExtraLocal ) {\n uprv_free ( _this -> extraInfo ) ;\n _this -> extraInfo = NULL ;\n }\n }\n }\n typedef struct LMBCSClone {\n UConverter cnv ;\n UConverterDataLMBCS lmbcs ;\n }\n LMBCSClone ;\n static UConverter * _LMBCSSafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {\n LMBCSClone * newLMBCS ;\n UConverterDataLMBCS * extraInfo ;\n int32_t i ;\n if ( * pBufferSize <= 0 ) {\n * pBufferSize = ( int32_t ) sizeof ( LMBCSClone ) ;\n return NULL ;\n }\n extraInfo = ( UConverterDataLMBCS * ) cnv -> extraInfo ;\n newLMBCS = ( LMBCSClone * ) stackBuffer ;\n uprv_memcpy ( & newLMBCS -> lmbcs , extraInfo , sizeof ( UConverterDataLMBCS ) ) ;\n for ( i = 0 ;\n i <= ULMBCS_GRP_LAST ;\n ++ i ) {\n if ( extraInfo -> OptGrpConverter [ i ] != NULL ) {\n ucnv_incrementRefCount ( extraInfo -> OptGrpConverter [ i ] ) ;\n }\n }\n newLMBCS -> cnv . extraInfo = & newLMBCS -> lmbcs ;\n newLMBCS -> cnv . isExtraLocal = TRUE ;\n return & newLMBCS -> cnv ;\n }\n static size_t LMBCSConversionWorker ( UConverterDataLMBCS * extraInfo , ulmbcs_byte_t group , ulmbcs_byte_t * pStartLMBCS , UChar * pUniChar , ulmbcs_byte_t * lastConverterIndex , UBool * groups_tried ) {\n ulmbcs_byte_t * pLMBCS = pStartLMBCS ;\n UConverterSharedData * xcnv = extraInfo -> OptGrpConverter [ group ] ;\n int bytesConverted ;\n uint32_t value ;\n ulmbcs_byte_t firstByte ;\n U_ASSERT ( xcnv ) ;\n U_ASSERT ( group < ULMBCS_GRP_UNICODE ) ;\n bytesConverted = ucnv_MBCSFromUChar32 ( xcnv , * pUniChar , & value , FALSE ) ;\n if ( bytesConverted > 0 ) {\n firstByte = ( ulmbcs_byte_t ) ( value >> ( ( bytesConverted - 1 ) * 8 ) ) ;\n }\n else {\n groups_tried [ group ] = TRUE ;\n return 0 ;\n }\n * lastConverterIndex = group ;\n U_ASSERT ( ( firstByte <= ULMBCS_C0END ) || ( firstByte >= ULMBCS_C1START ) || ( group == ULMBCS_GRP_EXCEPT ) ) ;\n if ( group != ULMBCS_GRP_EXCEPT && extraInfo -> OptGroup != group ) {\n * pLMBCS ++ = group ;\n if ( bytesConverted == 1 && group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n * pLMBCS ++ = group ;\n }\n }\n if ( bytesConverted == 1 && firstByte < 0x20 ) return 0 ;\n switch ( bytesConverted ) {\n case 4 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 24 ) ;\n U_FALLTHROUGH ;\n case 3 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 16 ) ;\n U_FALLTHROUGH ;\n case 2 : * pLMBCS ++ = ( ulmbcs_byte_t ) ( value >> 8 ) ;\n U_FALLTHROUGH ;\n case 1 : * pLMBCS ++ = ( ulmbcs_byte_t ) value ;\n U_FALLTHROUGH ;\n default : break ;\n }\n return ( pLMBCS - pStartLMBCS ) ;\n }\n static size_t LMBCSConvertUni ( ulmbcs_byte_t * pLMBCS , UChar uniChar ) {\n uint8_t LowCh = ( uint8_t ) ( uniChar & 0x00FF ) ;\n uint8_t HighCh = ( uint8_t ) ( uniChar >> 8 ) ;\n * pLMBCS ++ = ULMBCS_GRP_UNICODE ;\n if ( LowCh == 0 ) {\n * pLMBCS ++ = ULMBCS_UNICOMPATZERO ;\n * pLMBCS ++ = HighCh ;\n }\n else {\n * pLMBCS ++ = HighCh ;\n * pLMBCS ++ = LowCh ;\n }\n return ULMBCS_UNICODE_SIZE ;\n }\n static void _LMBCSFromUnicode ( UConverterFromUnicodeArgs * args , UErrorCode * err ) {\n ulmbcs_byte_t lastConverterIndex = 0 ;\n UChar uniChar ;\n ulmbcs_byte_t LMBCS [ ULMBCS_CHARSIZE_MAX ] ;\n ulmbcs_byte_t * pLMBCS ;\n int32_t bytes_written ;\n UBool groups_tried [ ULMBCS_GRP_LAST + 1 ] ;\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n int sourceIndex = 0 ;\n ulmbcs_byte_t OldConverterIndex = 0 ;\n while ( args -> source < args -> sourceLimit && ! U_FAILURE ( * err ) ) {\n OldConverterIndex = extraInfo -> localeConverterIndex ;\n if ( args -> target >= args -> targetLimit ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n uniChar = * ( args -> source ) ;\n bytes_written = 0 ;\n pLMBCS = LMBCS ;\n if ( ( uniChar >= 0x80 ) && ( uniChar <= 0xff ) && ( uniChar != 0xB1 ) && ( uniChar != 0xD7 ) && ( uniChar != 0xF7 ) && ( uniChar != 0xB0 ) && ( uniChar != 0xB4 ) && ( uniChar != 0xB6 ) && ( uniChar != 0xA7 ) && ( uniChar != 0xA8 ) ) {\n extraInfo -> localeConverterIndex = ULMBCS_GRP_L1 ;\n }\n if ( ( ( uniChar > ULMBCS_C0END ) && ( uniChar < ULMBCS_C1START ) ) || uniChar == 0 || uniChar == ULMBCS_HT || uniChar == ULMBCS_CR || uniChar == ULMBCS_LF || uniChar == ULMBCS_123SYSTEMRANGE ) {\n * pLMBCS ++ = ( ulmbcs_byte_t ) uniChar ;\n bytes_written = 1 ;\n }\n if ( ! bytes_written ) {\n ulmbcs_byte_t group = FindLMBCSUniRange ( uniChar ) ;\n if ( group == ULMBCS_GRP_UNICODE ) {\n pLMBCS += LMBCSConvertUni ( pLMBCS , uniChar ) ;\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n else if ( group == ULMBCS_GRP_CTRL ) {\n if ( uniChar <= ULMBCS_C0END ) {\n * pLMBCS ++ = ULMBCS_GRP_CTRL ;\n * pLMBCS ++ = ( ulmbcs_byte_t ) ( ULMBCS_CTRLOFFSET + uniChar ) ;\n }\n else if ( uniChar >= ULMBCS_C1START && uniChar <= ULMBCS_C1START + ULMBCS_CTRLOFFSET ) {\n * pLMBCS ++ = ULMBCS_GRP_CTRL ;\n * pLMBCS ++ = ( ulmbcs_byte_t ) ( uniChar & 0x00FF ) ;\n }\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n else if ( group < ULMBCS_GRP_UNICODE ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , group , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n uprv_memset ( groups_tried , 0 , sizeof ( groups_tried ) ) ;\n if ( ( extraInfo -> OptGroup != 1 ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , extraInfo -> OptGroup ) ) ) {\n if ( extraInfo -> localeConverterIndex < ULMBCS_DOUBLEOPTGROUP_START ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_L1 , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n if ( ! bytes_written ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_EXCEPT , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n bytes_written = LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n else {\n bytes_written = LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written && ( extraInfo -> localeConverterIndex ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , extraInfo -> localeConverterIndex ) ) ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , extraInfo -> localeConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written && ( lastConverterIndex ) && ( ULMBCS_AMBIGUOUS_MATCH ( group , lastConverterIndex ) ) ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , lastConverterIndex , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n if ( ! bytes_written ) {\n ulmbcs_byte_t grp_start ;\n ulmbcs_byte_t grp_end ;\n ulmbcs_byte_t grp_ix ;\n grp_start = ( ulmbcs_byte_t ) ( ( group == ULMBCS_AMBIGUOUS_MBCS ) ? ULMBCS_DOUBLEOPTGROUP_START : ULMBCS_GRP_L1 ) ;\n grp_end = ( ulmbcs_byte_t ) ( ( group == ULMBCS_AMBIGUOUS_MBCS ) ? ULMBCS_GRP_LAST : ULMBCS_GRP_TH ) ;\n if ( group == ULMBCS_AMBIGUOUS_ALL ) {\n grp_start = ULMBCS_GRP_L1 ;\n grp_end = ULMBCS_GRP_LAST ;\n }\n for ( grp_ix = grp_start ;\n grp_ix <= grp_end && ! bytes_written ;\n grp_ix ++ ) {\n if ( extraInfo -> OptGrpConverter [ grp_ix ] && ! groups_tried [ grp_ix ] ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , grp_ix , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written && grp_start == ULMBCS_GRP_L1 ) {\n bytes_written = ( int32_t ) LMBCSConversionWorker ( extraInfo , ULMBCS_GRP_EXCEPT , pLMBCS , & uniChar , & lastConverterIndex , groups_tried ) ;\n }\n }\n if ( ! bytes_written ) {\n pLMBCS += LMBCSConvertUni ( pLMBCS , uniChar ) ;\n bytes_written = ( int32_t ) ( pLMBCS - LMBCS ) ;\n }\n }\n }\n args -> source ++ ;\n pLMBCS = LMBCS ;\n while ( args -> target < args -> targetLimit && bytes_written -- ) {\n * ( args -> target ) ++ = * pLMBCS ++ ;\n if ( args -> offsets ) {\n * ( args -> offsets ) ++ = sourceIndex ;\n }\n }\n sourceIndex ++ ;\n if ( bytes_written > 0 ) {\n uint8_t * pErrorBuffer = args -> converter -> charErrorBuffer ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n args -> converter -> charErrorBufferLength = ( int8_t ) bytes_written ;\n while ( bytes_written -- ) {\n * pErrorBuffer ++ = * pLMBCS ++ ;\n }\n }\n extraInfo -> localeConverterIndex = OldConverterIndex ;\n }\n }\n static UChar GetUniFromLMBCSUni ( char const * * ppLMBCSin ) {\n uint8_t HighCh = * ( * ppLMBCSin ) ++ ;\n uint8_t LowCh = * ( * ppLMBCSin ) ++ ;\n if ( HighCh == ULMBCS_UNICOMPATZERO ) {\n HighCh = LowCh ;\n LowCh = 0 ;\n }\n return ( UChar ) ( ( HighCh << 8 ) | LowCh ) ;\n }\n # define CHECK_SOURCE_LIMIT ( index ) if ( args -> source + index > args -> sourceLimit ) {\n * err = U_TRUNCATED_CHAR_FOUND ;\n args -> source = args -> sourceLimit ;\n return 0xffff ;\n }\n static UChar32 _LMBCSGetNextUCharWorker ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n UChar32 uniChar = 0 ;\n ulmbcs_byte_t CurByte ;\n if ( args -> source >= args -> sourceLimit ) {\n * err = U_ILLEGAL_ARGUMENT_ERROR ;\n return 0xffff ;\n }\n CurByte = * ( ( ulmbcs_byte_t * ) ( args -> source ++ ) ) ;\n if ( ( ( CurByte > ULMBCS_C0END ) && ( CurByte < ULMBCS_C1START ) ) || ( CurByte == 0 ) || CurByte == ULMBCS_HT || CurByte == ULMBCS_CR || CurByte == ULMBCS_LF || CurByte == ULMBCS_123SYSTEMRANGE ) {\n uniChar = CurByte ;\n }\n else {\n UConverterDataLMBCS * extraInfo ;\n ulmbcs_byte_t group ;\n UConverterSharedData * cnv ;\n if ( CurByte == ULMBCS_GRP_CTRL ) {\n ulmbcs_byte_t C0C1byte ;\n CHECK_SOURCE_LIMIT ( 1 ) ;\n C0C1byte = * ( args -> source ) ++ ;\n uniChar = ( C0C1byte < ULMBCS_C1START ) ? C0C1byte - ULMBCS_CTRLOFFSET : C0C1byte ;\n }\n else if ( CurByte == ULMBCS_GRP_UNICODE ) {\n CHECK_SOURCE_LIMIT ( 2 ) ;\n return GetUniFromLMBCSUni ( & ( args -> source ) ) ;\n }\n else if ( CurByte <= ULMBCS_CTRLOFFSET ) {\n group = CurByte ;\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n if ( group > ULMBCS_GRP_LAST || ( cnv = extraInfo -> OptGrpConverter [ group ] ) == NULL ) {\n * err = U_INVALID_CHAR_FOUND ;\n }\n else if ( group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n CHECK_SOURCE_LIMIT ( 2 ) ;\n if ( * args -> source == group ) {\n ++ args -> source ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source , 1 , FALSE ) ;\n ++ args -> source ;\n }\n else {\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source , 2 , FALSE ) ;\n args -> source += 2 ;\n }\n }\n else {\n CHECK_SOURCE_LIMIT ( 1 ) ;\n CurByte = * ( args -> source ) ++ ;\n if ( CurByte >= ULMBCS_C1START ) {\n uniChar = _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP ( cnv , CurByte ) ;\n }\n else {\n char bytes [ 2 ] ;\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n cnv = extraInfo -> OptGrpConverter [ ULMBCS_GRP_EXCEPT ] ;\n bytes [ 0 ] = group ;\n bytes [ 1 ] = CurByte ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , bytes , 2 , FALSE ) ;\n }\n }\n }\n else if ( CurByte >= ULMBCS_C1START ) {\n extraInfo = ( UConverterDataLMBCS * ) args -> converter -> extraInfo ;\n group = extraInfo -> OptGroup ;\n cnv = extraInfo -> OptGrpConverter [ group ] ;\n if ( group >= ULMBCS_DOUBLEOPTGROUP_START ) {\n if ( ! ucnv_MBCSIsLeadByte ( cnv , CurByte ) ) {\n CHECK_SOURCE_LIMIT ( 0 ) ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source - 1 , 1 , FALSE ) ;\n }\n else {\n CHECK_SOURCE_LIMIT ( 1 ) ;\n uniChar = ucnv_MBCSSimpleGetNextUChar ( cnv , args -> source - 1 , 2 , FALSE ) ;\n ++ args -> source ;\n }\n }\n else {\n uniChar = _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP ( cnv , CurByte ) ;\n }\n }\n }\n return uniChar ;\n }\n static void _LMBCSToUnicodeWithOffsets ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n char LMBCS [ ULMBCS_CHARSIZE_MAX ] ;\n UChar uniChar ;\n const char * saveSource ;\n const char * pStartLMBCS = args -> source ;\n const char * errSource = NULL ;\n int8_t savebytes = 0 ;\n while ( U_SUCCESS ( * err ) && args -> sourceLimit > args -> source && args -> targetLimit > args -> target ) {\n saveSource = args -> source ;\n if ( args -> converter -> toULength ) {\n const char * saveSourceLimit ;\n size_t size_old = args -> converter -> toULength ;\n size_t size_new_maybe_1 = sizeof ( LMBCS ) - size_old ;\n size_t size_new_maybe_2 = args -> sourceLimit - args -> source ;\n size_t size_new = ( size_new_maybe_1 < size_new_maybe_2 ) ? size_new_maybe_1 : size_new_maybe_2 ;\n uprv_memcpy ( LMBCS , args -> converter -> toUBytes , size_old ) ;\n uprv_memcpy ( LMBCS + size_old , args -> source , size_new ) ;\n saveSourceLimit = args -> sourceLimit ;\n args -> source = errSource = LMBCS ;\n args -> sourceLimit = LMBCS + size_old + size_new ;\n savebytes = ( int8_t ) ( size_old + size_new ) ;\n uniChar = ( UChar ) _LMBCSGetNextUCharWorker ( args , err ) ;\n args -> source = saveSource + ( ( args -> source - LMBCS ) - size_old ) ;\n args -> sourceLimit = saveSourceLimit ;\n if ( * err == U_TRUNCATED_CHAR_FOUND ) {\n args -> converter -> toULength = savebytes ;\n uprv_memcpy ( args -> converter -> toUBytes , LMBCS , savebytes ) ;\n args -> source = args -> sourceLimit ;\n * err = U_ZERO_ERROR ;\n return ;\n }\n else {\n args -> converter -> toULength = 0 ;\n }\n }\n else {\n errSource = saveSource ;\n uniChar = ( UChar ) _LMBCSGetNextUCharWorker ( args , err ) ;\n savebytes = ( int8_t ) ( args -> source - saveSource ) ;\n }\n if ( U_SUCCESS ( * err ) ) {\n if ( uniChar < 0xfffe ) {\n * ( args -> target ) ++ = uniChar ;\n if ( args -> offsets ) {\n * ( args -> offsets ) ++ = ( int32_t ) ( saveSource - pStartLMBCS ) ;\n }\n }\n else if ( uniChar == 0xfffe ) {\n * err = U_INVALID_CHAR_FOUND ;\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n }\n if ( U_SUCCESS ( * err ) && args -> sourceLimit > args -> source && args -> targetLimit <= args -> target ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n else if ( U_FAILURE ( * err ) ) {\n args -> converter -> toULength = savebytes ;\n if ( savebytes > 0 ) {\n uprv_memcpy ( args -> converter -> toUBytes , errSource , savebytes ) ;\n }\n if ( * err == U_TRUNCATED_CHAR_FOUND ) {\n * err = U_ZERO_ERROR ;\n }\n }\n }\n DEFINE_LMBCS_OPEN ( 1 ) DEFINE_LMBCS_OPEN ( 2 ) DEFINE_LMBCS_OPEN ( 3 ) DEFINE_LMBCS_OPEN ( 4 ) DEFINE_LMBCS_OPEN ( 5 ) DEFINE_LMBCS_OPEN ( 6 ) DEFINE_LMBCS_OPEN ( 8 ) DEFINE_LMBCS_OPEN ( 11 )", "hash": 7072059544915633710, "project": "chrome", "size": 404, "target": 1, "idx": 22281}
{"code": "inline UChar * toUCharPtr ( char16_t * p ) {\n # ifdef U_ALIASING_BARRIER U_ALIASING_BARRIER ( p ) ;\n # endif return reinterpret_cast < UChar * > ( p ) ;\n }", "hash": 7275725035785508796, "project": "chrome", "size": 4, "target": 1, "idx": 22292}
{"code": "static void _appendLDMLExtensionAsKeywords ( const char * ldmlext , ExtensionListEntry * * appendTo , char * buf , int32_t bufSize , UBool * posixVariant , UErrorCode * status ) {\n const char * pTag ;\n const char * pKwds ;\n UBool variantExists = * posixVariant ;\n ExtensionListEntry * kwdFirst = NULL ;\n ExtensionListEntry * kwd , * nextKwd ;\n AttributeListEntry * attrFirst = NULL ;\n AttributeListEntry * attr , * nextAttr ;\n int32_t len ;\n int32_t bufIdx = 0 ;\n char attrBuf [ ULOC_KEYWORD_AND_VALUES_CAPACITY ] ;\n int32_t attrBufIdx = 0 ;\n * posixVariant = FALSE ;\n pTag = ldmlext ;\n pKwds = NULL ;\n while ( * pTag ) {\n for ( len = 0 ;\n * ( pTag + len ) && * ( pTag + len ) != SEP ;\n len ++ ) ;\n if ( ultag_isUnicodeLocaleKey ( pTag , len ) ) {\n pKwds = pTag ;\n break ;\n }\n attr = ( AttributeListEntry * ) uprv_malloc ( sizeof ( AttributeListEntry ) ) ;\n if ( attr == NULL ) {\n * status = U_MEMORY_ALLOCATION_ERROR ;\n goto cleanup ;\n }\n if ( len < ( int32_t ) sizeof ( attrBuf ) - attrBufIdx ) {\n uprv_memcpy ( & attrBuf [ attrBufIdx ] , pTag , len ) ;\n attrBuf [ attrBufIdx + len ] = 0 ;\n attr -> attribute = & attrBuf [ attrBufIdx ] ;\n attrBufIdx += ( len + 1 ) ;\n }\n else {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n goto cleanup ;\n }\n if ( ! _addAttributeToList ( & attrFirst , attr ) ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n uprv_free ( attr ) ;\n goto cleanup ;\n }\n pTag += len ;\n if ( * pTag ) {\n pTag ++ ;\n }\n }\n if ( attrFirst ) {\n if ( attrBufIdx > bufSize ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n goto cleanup ;\n }\n kwd = ( ExtensionListEntry * ) uprv_malloc ( sizeof ( ExtensionListEntry ) ) ;\n if ( kwd == NULL ) {\n * status = U_MEMORY_ALLOCATION_ERROR ;\n goto cleanup ;\n }\n kwd -> key = LOCALE_ATTRIBUTE_KEY ;\n kwd -> value = buf ;\n attr = attrFirst ;\n while ( attr != NULL ) {\n nextAttr = attr -> next ;\n if ( attr != attrFirst ) {\n * ( buf + bufIdx ) = SEP ;\n bufIdx ++ ;\n }\n len = uprv_strlen ( attr -> attribute ) ;\n uprv_memcpy ( buf + bufIdx , attr -> attribute , len ) ;\n bufIdx += len ;\n attr = nextAttr ;\n }\n * ( buf + bufIdx ) = 0 ;\n bufIdx ++ ;\n if ( ! _addExtensionToList ( & kwdFirst , kwd , FALSE ) ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n uprv_free ( kwd ) ;\n goto cleanup ;\n }\n attr = attrFirst ;\n while ( attr != NULL ) {\n nextAttr = attr -> next ;\n uprv_free ( attr ) ;\n attr = nextAttr ;\n }\n attrFirst = NULL ;\n }\n if ( pKwds ) {\n const char * pBcpKey = NULL ;\n const char * pBcpType = NULL ;\n int32_t bcpKeyLen = 0 ;\n int32_t bcpTypeLen = 0 ;\n UBool isDone = FALSE ;\n pTag = pKwds ;\n while ( ! isDone ) {\n const char * pNextBcpKey = NULL ;\n int32_t nextBcpKeyLen = 0 ;\n UBool emitKeyword = FALSE ;\n if ( * pTag ) {\n for ( len = 0 ;\n * ( pTag + len ) && * ( pTag + len ) != SEP ;\n len ++ ) ;\n if ( ultag_isUnicodeLocaleKey ( pTag , len ) ) {\n if ( pBcpKey ) {\n emitKeyword = TRUE ;\n pNextBcpKey = pTag ;\n nextBcpKeyLen = len ;\n }\n else {\n pBcpKey = pTag ;\n bcpKeyLen = len ;\n }\n }\n else {\n U_ASSERT ( pBcpKey != NULL ) ;\n if ( pBcpType ) {\n bcpTypeLen += ( len + 1 ) ;\n }\n else {\n pBcpType = pTag ;\n bcpTypeLen = len ;\n }\n }\n pTag += len ;\n if ( * pTag ) {\n pTag ++ ;\n }\n }\n else {\n emitKeyword = TRUE ;\n isDone = TRUE ;\n }\n if ( emitKeyword ) {\n const char * pKey = NULL ;\n const char * pType = NULL ;\n char bcpKeyBuf [ 9 ] ;\n U_ASSERT ( pBcpKey != NULL ) ;\n if ( bcpKeyLen >= sizeof ( bcpKeyBuf ) ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n goto cleanup ;\n }\n uprv_strncpy ( bcpKeyBuf , pBcpKey , bcpKeyLen ) ;\n bcpKeyBuf [ bcpKeyLen ] = 0 ;\n pKey = uloc_toLegacyKey ( bcpKeyBuf ) ;\n if ( pKey == NULL ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n goto cleanup ;\n }\n if ( pKey == bcpKeyBuf ) {\n T_CString_toLowerCase ( bcpKeyBuf ) ;\n if ( bufSize - bufIdx - 1 >= bcpKeyLen ) {\n uprv_memcpy ( buf + bufIdx , bcpKeyBuf , bcpKeyLen ) ;\n pKey = buf + bufIdx ;\n bufIdx += bcpKeyLen ;\n * ( buf + bufIdx ) = 0 ;\n bufIdx ++ ;\n }\n else {\n * status = U_BUFFER_OVERFLOW_ERROR ;\n goto cleanup ;\n }\n }\n if ( pBcpType ) {\n char bcpTypeBuf [ 128 ] ;\n if ( bcpTypeLen >= sizeof ( bcpTypeBuf ) ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n goto cleanup ;\n }\n uprv_strncpy ( bcpTypeBuf , pBcpType , bcpTypeLen ) ;\n bcpTypeBuf [ bcpTypeLen ] = 0 ;\n pType = uloc_toLegacyType ( pKey , bcpTypeBuf ) ;\n if ( pType == NULL ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n goto cleanup ;\n }\n if ( pType == bcpTypeBuf ) {\n T_CString_toLowerCase ( bcpTypeBuf ) ;\n if ( bufSize - bufIdx - 1 >= bcpTypeLen ) {\n uprv_memcpy ( buf + bufIdx , bcpTypeBuf , bcpTypeLen ) ;\n pType = buf + bufIdx ;\n bufIdx += bcpTypeLen ;\n * ( buf + bufIdx ) = 0 ;\n bufIdx ++ ;\n }\n else {\n * status = U_BUFFER_OVERFLOW_ERROR ;\n goto cleanup ;\n }\n }\n }\n else {\n pType = LOCALE_TYPE_YES ;\n }\n if ( ! variantExists && ! uprv_strcmp ( pKey , POSIX_KEY ) && ! uprv_strcmp ( pType , POSIX_VALUE ) ) {\n * posixVariant = TRUE ;\n }\n else {\n kwd = ( ExtensionListEntry * ) uprv_malloc ( sizeof ( ExtensionListEntry ) ) ;\n if ( kwd == NULL ) {\n * status = U_MEMORY_ALLOCATION_ERROR ;\n goto cleanup ;\n }\n kwd -> key = pKey ;\n kwd -> value = pType ;\n if ( ! _addExtensionToList ( & kwdFirst , kwd , FALSE ) ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n uprv_free ( kwd ) ;\n goto cleanup ;\n }\n }\n pBcpKey = pNextBcpKey ;\n bcpKeyLen = pNextBcpKey != NULL ? nextBcpKeyLen : 0 ;\n pBcpType = NULL ;\n bcpTypeLen = 0 ;\n }\n }\n }\n kwd = kwdFirst ;\n while ( kwd != NULL ) {\n nextKwd = kwd -> next ;\n _addExtensionToList ( appendTo , kwd , FALSE ) ;\n kwd = nextKwd ;\n }\n return ;\n cleanup : attr = attrFirst ;\n while ( attr != NULL ) {\n nextAttr = attr -> next ;\n uprv_free ( attr ) ;\n attr = nextAttr ;\n }\n kwd = kwdFirst ;\n while ( kwd != NULL ) {\n nextKwd = kwd -> next ;\n uprv_free ( kwd ) ;\n kwd = nextKwd ;\n }\n }", "hash": -5697857125570093892, "project": "chrome", "size": 237, "target": 1, "idx": 22299}
{"code": "static int32_t _appendKeywordsToLanguageTag ( const char * localeID , char * appendAt , int32_t capacity , UBool strict , UBool hadPosix , UErrorCode * status ) {\n char buf [ ULOC_KEYWORD_AND_VALUES_CAPACITY ] ;\n char attrBuf [ ULOC_KEYWORD_AND_VALUES_CAPACITY ] = {\n 0 }\n ;\n int32_t attrBufLength = 0 ;\n UEnumeration * keywordEnum = NULL ;\n int32_t reslen = 0 ;\n keywordEnum = uloc_openKeywords ( localeID , status ) ;\n if ( U_FAILURE ( * status ) && ! hadPosix ) {\n uenum_close ( keywordEnum ) ;\n return 0 ;\n }\n if ( keywordEnum != NULL || hadPosix ) {\n int32_t len ;\n const char * key ;\n ExtensionListEntry * firstExt = NULL ;\n ExtensionListEntry * ext ;\n AttributeListEntry * firstAttr = NULL ;\n AttributeListEntry * attr ;\n char * attrValue ;\n char extBuf [ ULOC_KEYWORD_AND_VALUES_CAPACITY ] ;\n char * pExtBuf = extBuf ;\n int32_t extBufCapacity = sizeof ( extBuf ) ;\n const char * bcpKey , * bcpValue ;\n UErrorCode tmpStatus = U_ZERO_ERROR ;\n int32_t keylen ;\n UBool isBcpUExt ;\n while ( TRUE ) {\n key = uenum_next ( keywordEnum , NULL , status ) ;\n if ( key == NULL ) {\n break ;\n }\n len = uloc_getKeywordValue ( localeID , key , buf , sizeof ( buf ) , & tmpStatus ) ;\n if ( U_FAILURE ( tmpStatus ) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING ) {\n if ( strict ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n break ;\n }\n tmpStatus = U_ZERO_ERROR ;\n continue ;\n }\n keylen = ( int32_t ) uprv_strlen ( key ) ;\n isBcpUExt = ( keylen > 1 ) ;\n if ( uprv_strcmp ( key , LOCALE_ATTRIBUTE_KEY ) == 0 ) {\n if ( len > 0 ) {\n int32_t i = 0 ;\n while ( TRUE ) {\n attrBufLength = 0 ;\n for ( ;\n i < len ;\n i ++ ) {\n if ( buf [ i ] != '-' ) {\n attrBuf [ attrBufLength ++ ] = buf [ i ] ;\n }\n else {\n i ++ ;\n break ;\n }\n }\n if ( attrBufLength > 0 ) {\n attrBuf [ attrBufLength ] = 0 ;\n }\n else if ( i >= len ) {\n break ;\n }\n attr = ( AttributeListEntry * ) uprv_malloc ( sizeof ( AttributeListEntry ) ) ;\n if ( attr == NULL ) {\n * status = U_MEMORY_ALLOCATION_ERROR ;\n break ;\n }\n attrValue = ( char * ) uprv_malloc ( attrBufLength + 1 ) ;\n if ( attrValue == NULL ) {\n * status = U_MEMORY_ALLOCATION_ERROR ;\n break ;\n }\n uprv_strcpy ( attrValue , attrBuf ) ;\n attr -> attribute = attrValue ;\n if ( ! _addAttributeToList ( & firstAttr , attr ) ) {\n uprv_free ( attr ) ;\n uprv_free ( attrValue ) ;\n if ( strict ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n break ;\n }\n }\n }\n bcpKey = LOCALE_ATTRIBUTE_KEY ;\n bcpValue = NULL ;\n }\n }\n else if ( isBcpUExt ) {\n bcpKey = uloc_toUnicodeLocaleKey ( key ) ;\n if ( bcpKey == NULL ) {\n if ( strict ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n break ;\n }\n continue ;\n }\n bcpValue = uloc_toUnicodeLocaleType ( key , buf ) ;\n if ( bcpValue == NULL ) {\n if ( strict ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n break ;\n }\n continue ;\n }\n if ( bcpValue == buf ) {\n int32_t bcpValueLen = uprv_strlen ( bcpValue ) ;\n if ( bcpValueLen < extBufCapacity ) {\n uprv_strcpy ( pExtBuf , bcpValue ) ;\n T_CString_toLowerCase ( pExtBuf ) ;\n bcpValue = pExtBuf ;\n pExtBuf += ( bcpValueLen + 1 ) ;\n extBufCapacity -= ( bcpValueLen + 1 ) ;\n }\n else {\n if ( strict ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n break ;\n }\n continue ;\n }\n }\n }\n else {\n if ( * key == PRIVATEUSE ) {\n if ( ! _isPrivateuseValueSubtags ( buf , len ) ) {\n if ( strict ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n break ;\n }\n continue ;\n }\n }\n else {\n if ( ! _isExtensionSingleton ( key , keylen ) || ! _isExtensionSubtags ( buf , len ) ) {\n if ( strict ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n break ;\n }\n continue ;\n }\n }\n bcpKey = key ;\n if ( ( len + 1 ) < extBufCapacity ) {\n uprv_memcpy ( pExtBuf , buf , len ) ;\n bcpValue = pExtBuf ;\n pExtBuf += len ;\n * pExtBuf = 0 ;\n pExtBuf ++ ;\n extBufCapacity -= ( len + 1 ) ;\n }\n else {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n break ;\n }\n }\n ext = ( ExtensionListEntry * ) uprv_malloc ( sizeof ( ExtensionListEntry ) ) ;\n if ( ext == NULL ) {\n * status = U_MEMORY_ALLOCATION_ERROR ;\n break ;\n }\n ext -> key = bcpKey ;\n ext -> value = bcpValue ;\n if ( ! _addExtensionToList ( & firstExt , ext , TRUE ) ) {\n uprv_free ( ext ) ;\n if ( strict ) {\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n break ;\n }\n }\n }\n if ( hadPosix ) {\n ext = ( ExtensionListEntry * ) uprv_malloc ( sizeof ( ExtensionListEntry ) ) ;\n if ( ext == NULL ) {\n * status = U_MEMORY_ALLOCATION_ERROR ;\n goto cleanup ;\n }\n ext -> key = POSIX_KEY ;\n ext -> value = POSIX_VALUE ;\n if ( ! _addExtensionToList ( & firstExt , ext , TRUE ) ) {\n uprv_free ( ext ) ;\n }\n }\n if ( U_SUCCESS ( * status ) && ( firstExt != NULL || firstAttr != NULL ) ) {\n UBool startLDMLExtension = FALSE ;\n for ( ext = firstExt ;\n ext ;\n ext = ext -> next ) {\n if ( ! startLDMLExtension && uprv_strlen ( ext -> key ) > 1 ) {\n if ( reslen < capacity ) {\n * ( appendAt + reslen ) = SEP ;\n }\n reslen ++ ;\n if ( reslen < capacity ) {\n * ( appendAt + reslen ) = LDMLEXT ;\n }\n reslen ++ ;\n startLDMLExtension = TRUE ;\n }\n if ( uprv_strcmp ( ext -> key , LOCALE_ATTRIBUTE_KEY ) == 0 ) {\n for ( attr = firstAttr ;\n attr ;\n attr = attr -> next ) {\n if ( reslen < capacity ) {\n * ( appendAt + reslen ) = SEP ;\n }\n reslen ++ ;\n len = ( int32_t ) uprv_strlen ( attr -> attribute ) ;\n if ( reslen < capacity ) {\n uprv_memcpy ( appendAt + reslen , attr -> attribute , uprv_min ( len , capacity - reslen ) ) ;\n }\n reslen += len ;\n }\n }\n else {\n if ( reslen < capacity ) {\n * ( appendAt + reslen ) = SEP ;\n }\n reslen ++ ;\n len = ( int32_t ) uprv_strlen ( ext -> key ) ;\n if ( reslen < capacity ) {\n uprv_memcpy ( appendAt + reslen , ext -> key , uprv_min ( len , capacity - reslen ) ) ;\n }\n reslen += len ;\n if ( reslen < capacity ) {\n * ( appendAt + reslen ) = SEP ;\n }\n reslen ++ ;\n len = ( int32_t ) uprv_strlen ( ext -> value ) ;\n if ( reslen < capacity ) {\n uprv_memcpy ( appendAt + reslen , ext -> value , uprv_min ( len , capacity - reslen ) ) ;\n }\n reslen += len ;\n }\n }\n }\n cleanup : ext = firstExt ;\n while ( ext != NULL ) {\n ExtensionListEntry * tmpExt = ext -> next ;\n uprv_free ( ext ) ;\n ext = tmpExt ;\n }\n attr = firstAttr ;\n while ( attr != NULL ) {\n AttributeListEntry * tmpAttr = attr -> next ;\n char * pValue = ( char * ) attr -> attribute ;\n uprv_free ( pValue ) ;\n uprv_free ( attr ) ;\n attr = tmpAttr ;\n }\n uenum_close ( keywordEnum ) ;\n if ( U_FAILURE ( * status ) ) {\n return 0 ;\n }\n }\n return u_terminateChars ( appendAt , capacity , reslen , status ) ;\n }", "hash": -5697857125570093892, "project": "chrome", "size": 260, "target": 1, "idx": 22302}
{"code": "static void _HZ_GetUnicodeSet ( const UConverter * cnv , const USetAdder * sa , UConverterUnicodeSet which , UErrorCode * pErrorCode ) {\n sa -> addRange ( sa -> set , 0 , 0x7f ) ;\n ucnv_MBCSGetFilteredUnicodeSetForUnicode ( ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> gbConverter -> sharedData , sa , which , UCNV_SET_FILTER_HZ , pErrorCode ) ;\n }", "hash": 237530479040685467, "project": "chrome", "size": 4, "target": 1, "idx": 22311}
{"code": "static void _UTF16Reset ( UConverter * cnv , UConverterResetChoice choice ) {\n if ( choice <= UCNV_RESET_TO_UNICODE ) {\n cnv -> mode = 0 ;\n }\n if ( choice != UCNV_RESET_TO_UNICODE ) {\n cnv -> fromUnicodeStatus = UCNV_NEED_TO_WRITE_BOM ;\n }\n }", "hash": -7049333455584635197, "project": "chrome", "size": 8, "target": 1, "idx": 22322}
{"code": "static void UConverter_fromUnicode_ISCII_OFFSETS_LOGIC ( UConverterFromUnicodeArgs * args , UErrorCode * err ) {\n const UChar * source = args -> source ;\n const UChar * sourceLimit = args -> sourceLimit ;\n unsigned char * target = ( unsigned char * ) args -> target ;\n unsigned char * targetLimit = ( unsigned char * ) args -> targetLimit ;\n int32_t * offsets = args -> offsets ;\n uint32_t targetByteUnit = 0x0000 ;\n UChar32 sourceChar = 0x0000 ;\n UChar32 tempContextFromUnicode = 0x0000 ;\n UConverterDataISCII * converterData ;\n uint16_t newDelta = 0 ;\n uint16_t range = 0 ;\n UBool deltaChanged = FALSE ;\n if ( ( args -> converter == NULL ) || ( args -> targetLimit < args -> target ) || ( args -> sourceLimit < args -> source ) ) {\n * err = U_ILLEGAL_ARGUMENT_ERROR ;\n return ;\n }\n converterData = ( UConverterDataISCII * ) args -> converter -> extraInfo ;\n newDelta = converterData -> currentDeltaFromUnicode ;\n range = ( uint16_t ) ( newDelta / DELTA ) ;\n if ( ( sourceChar = args -> converter -> fromUChar32 ) != 0 ) {\n goto getTrail ;\n }\n while ( source < sourceLimit ) {\n if ( args -> converter -> fromUnicodeStatus == LF ) {\n targetByteUnit = ATR << 8 ;\n targetByteUnit += ( uint8_t ) lookupInitialData [ range ] . isciiLang ;\n args -> converter -> fromUnicodeStatus = 0x0000 ;\n WRITE_TO_TARGET_FROM_U ( args , offsets , source , target , targetLimit , targetByteUnit , err ) ;\n if ( U_FAILURE ( * err ) ) {\n break ;\n }\n }\n sourceChar = * source ++ ;\n tempContextFromUnicode = converterData -> contextCharFromUnicode ;\n targetByteUnit = missingCharMarker ;\n if ( sourceChar <= ASCII_END ) {\n args -> converter -> fromUnicodeStatus = sourceChar ;\n WRITE_TO_TARGET_FROM_U ( args , offsets , source , target , targetLimit , sourceChar , err ) ;\n if ( U_FAILURE ( * err ) ) {\n break ;\n }\n continue ;\n }\n switch ( sourceChar ) {\n case ZWNJ : if ( converterData -> contextCharFromUnicode ) {\n converterData -> contextCharFromUnicode = 0x00 ;\n targetByteUnit = ISCII_HALANT ;\n }\n else {\n converterData -> contextCharFromUnicode = 0x00 ;\n continue ;\n }\n break ;\n case ZWJ : if ( converterData -> contextCharFromUnicode ) {\n targetByteUnit = ISCII_NUKTA ;\n }\n else {\n targetByteUnit = ISCII_INV ;\n }\n converterData -> contextCharFromUnicode = 0x00 ;\n break ;\n default : if ( ( uint16_t ) ( INDIC_BLOCK_END - sourceChar ) <= INDIC_RANGE ) {\n if ( sourceChar != DANDA && sourceChar != DOUBLE_DANDA ) {\n range = ( uint16_t ) ( ( sourceChar - INDIC_BLOCK_BEGIN ) / DELTA ) ;\n newDelta = ( uint16_t ) ( range * DELTA ) ;\n if ( newDelta != converterData -> currentDeltaFromUnicode || converterData -> isFirstBuffer ) {\n converterData -> currentDeltaFromUnicode = newDelta ;\n converterData -> currentMaskFromUnicode = lookupInitialData [ range ] . maskEnum ;\n deltaChanged = TRUE ;\n converterData -> isFirstBuffer = FALSE ;\n }\n if ( converterData -> currentDeltaFromUnicode == PNJ_DELTA ) {\n if ( sourceChar == PNJ_TIPPI ) {\n sourceChar = PNJ_BINDI ;\n }\n else if ( sourceChar == PNJ_ADHAK ) {\n converterData -> contextCharFromUnicode = PNJ_ADHAK ;\n }\n }\n sourceChar -= converterData -> currentDeltaFromUnicode ;\n }\n targetByteUnit = fromUnicodeTable [ ( uint8_t ) sourceChar ] ;\n if ( ( validityTable [ ( uint8_t ) sourceChar ] & converterData -> currentMaskFromUnicode ) == 0 ) {\n if ( converterData -> currentDeltaFromUnicode != ( TELUGU_DELTA ) || sourceChar != VOCALLIC_RR ) {\n targetByteUnit = missingCharMarker ;\n }\n }\n if ( deltaChanged ) {\n uint32_t temp = 0 ;\n temp = ( uint16_t ) ( ATR << 8 ) ;\n temp += ( uint16_t ) ( ( uint8_t ) lookupInitialData [ range ] . isciiLang ) ;\n deltaChanged = FALSE ;\n WRITE_TO_TARGET_FROM_U ( args , offsets , source , target , targetLimit , temp , err ) ;\n if ( U_FAILURE ( * err ) ) {\n break ;\n }\n }\n if ( converterData -> currentDeltaFromUnicode == PNJ_DELTA && ( sourceChar + PNJ_DELTA ) == PNJ_ADHAK ) {\n continue ;\n }\n }\n converterData -> contextCharFromUnicode = 0x00 ;\n break ;\n }\n if ( converterData -> currentDeltaFromUnicode == PNJ_DELTA && tempContextFromUnicode == PNJ_ADHAK && isPNJConsonant ( ( sourceChar + PNJ_DELTA ) ) ) {\n converterData -> contextCharFromUnicode = 0x0000 ;\n targetByteUnit = targetByteUnit << 16 | ISCII_HALANT << 8 | targetByteUnit ;\n WRITE_TO_TARGET_FROM_U ( args , offsets , source , target , targetLimit , targetByteUnit , err ) ;\n if ( U_FAILURE ( * err ) ) {\n break ;\n }\n }\n else if ( targetByteUnit != missingCharMarker ) {\n if ( targetByteUnit == ISCII_HALANT ) {\n converterData -> contextCharFromUnicode = ( UChar ) targetByteUnit ;\n }\n WRITE_TO_TARGET_FROM_U ( args , offsets , source , target , targetLimit , targetByteUnit , err ) ;\n if ( U_FAILURE ( * err ) ) {\n break ;\n }\n }\n else {\n if ( U16_IS_SURROGATE ( sourceChar ) ) {\n if ( U16_IS_SURROGATE_LEAD ( sourceChar ) ) {\n getTrail : if ( source < sourceLimit ) {\n UChar trail = ( * source ) ;\n if ( U16_IS_TRAIL ( trail ) ) {\n source ++ ;\n sourceChar = U16_GET_SUPPLEMENTARY ( sourceChar , trail ) ;\n * err = U_INVALID_CHAR_FOUND ;\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n else {\n * err = U_ZERO_ERROR ;\n }\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n }\n else {\n * err = U_INVALID_CHAR_FOUND ;\n }\n args -> converter -> fromUChar32 = sourceChar ;\n break ;\n }\n }\n args -> source = source ;\n args -> target = ( char * ) target ;\n }", "hash": -4136373206107992781, "project": "chrome", "size": 154, "target": 1, "idx": 22329}
{"code": "static void UConverter_toUnicode_ISCII_OFFSETS_LOGIC ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n const char * source = ( char * ) args -> source ;\n UChar * target = args -> target ;\n const char * sourceLimit = args -> sourceLimit ;\n const UChar * targetLimit = args -> targetLimit ;\n uint32_t targetUniChar = 0x0000 ;\n uint8_t sourceChar = 0x0000 ;\n UConverterDataISCII * data ;\n UChar32 * toUnicodeStatus = NULL ;\n UChar32 tempTargetUniChar = 0x0000 ;\n UChar * contextCharToUnicode = NULL ;\n UBool found ;\n int i ;\n int offset = 0 ;\n if ( ( args -> converter == NULL ) || ( target < args -> target ) || ( source < args -> source ) ) {\n * err = U_ILLEGAL_ARGUMENT_ERROR ;\n return ;\n }\n data = ( UConverterDataISCII * ) ( args -> converter -> extraInfo ) ;\n contextCharToUnicode = & data -> contextCharToUnicode ;\n toUnicodeStatus = ( UChar32 * ) & args -> converter -> toUnicodeStatus ;\n while ( U_SUCCESS ( * err ) && source < sourceLimit ) {\n targetUniChar = missingCharMarker ;\n if ( target < targetLimit ) {\n sourceChar = ( unsigned char ) * ( source ) ++ ;\n if ( * contextCharToUnicode == ATR ) {\n if ( ( uint8_t ) ( PNJ - sourceChar ) <= PNJ - DEV ) {\n data -> currentDeltaToUnicode = ( uint16_t ) ( lookupTable [ sourceChar & 0x0F ] [ 0 ] * DELTA ) ;\n data -> currentMaskToUnicode = ( MaskEnum ) lookupTable [ sourceChar & 0x0F ] [ 1 ] ;\n }\n else if ( sourceChar == DEF ) {\n data -> currentDeltaToUnicode = data -> defDeltaToUnicode ;\n data -> currentMaskToUnicode = data -> defMaskToUnicode ;\n }\n else {\n if ( ( sourceChar >= 0x21 && sourceChar <= 0x3F ) ) {\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n * contextCharToUnicode = NO_CHAR_MARKER ;\n goto CALLBACK ;\n }\n }\n * contextCharToUnicode = NO_CHAR_MARKER ;\n continue ;\n }\n else if ( * contextCharToUnicode == EXT ) {\n if ( ( uint8_t ) ( EXT_RANGE_END - sourceChar ) <= ( EXT_RANGE_END - EXT_RANGE_BEGIN ) ) {\n if ( sourceChar == 0xBF || sourceChar == 0xB8 ) {\n targetUniChar = ( sourceChar == 0xBF ) ? DEV_ABBR_SIGN : DEV_ANUDATTA ;\n if ( validityTable [ ( uint8_t ) targetUniChar ] & data -> currentMaskToUnicode ) {\n * contextCharToUnicode = NO_CHAR_MARKER ;\n if ( data -> prevToUnicodeStatus ) {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 1 ) , data -> prevToUnicodeStatus , 0 , err ) ;\n data -> prevToUnicodeStatus = 0x0000 ;\n }\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 2 ) , targetUniChar , data -> currentDeltaToUnicode , err ) ;\n continue ;\n }\n }\n targetUniChar = missingCharMarker ;\n * err = U_INVALID_CHAR_FOUND ;\n }\n else {\n * contextCharToUnicode = NO_CHAR_MARKER ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n goto CALLBACK ;\n }\n else if ( * contextCharToUnicode == ISCII_INV ) {\n if ( sourceChar == ISCII_HALANT ) {\n targetUniChar = 0x0020 ;\n }\n else {\n targetUniChar = ZWJ ;\n }\n if ( data -> prevToUnicodeStatus ) {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 1 ) , data -> prevToUnicodeStatus , 0 , err ) ;\n data -> prevToUnicodeStatus = 0x0000 ;\n }\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 2 ) , targetUniChar , data -> currentDeltaToUnicode , err ) ;\n * contextCharToUnicode = NO_CHAR_MARKER ;\n }\n switch ( sourceChar ) {\n case ISCII_INV : case EXT : case ATR : * contextCharToUnicode = ( UChar ) sourceChar ;\n if ( * toUnicodeStatus != missingCharMarker ) {\n if ( data -> prevToUnicodeStatus ) {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 1 ) , data -> prevToUnicodeStatus , 0 , err ) ;\n data -> prevToUnicodeStatus = 0x0000 ;\n }\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 2 ) , * toUnicodeStatus , data -> currentDeltaToUnicode , err ) ;\n * toUnicodeStatus = missingCharMarker ;\n }\n continue ;\n case ISCII_DANDA : if ( * contextCharToUnicode == ISCII_DANDA ) {\n targetUniChar = DOUBLE_DANDA ;\n * contextCharToUnicode = NO_CHAR_MARKER ;\n * toUnicodeStatus = missingCharMarker ;\n }\n else {\n GET_MAPPING ( sourceChar , targetUniChar , data ) ;\n * contextCharToUnicode = sourceChar ;\n }\n break ;\n case ISCII_HALANT : if ( * contextCharToUnicode == ISCII_HALANT ) {\n targetUniChar = ZWNJ ;\n * contextCharToUnicode = NO_CHAR_MARKER ;\n }\n else {\n GET_MAPPING ( sourceChar , targetUniChar , data ) ;\n * contextCharToUnicode = sourceChar ;\n }\n break ;\n case 0x0A : case 0x0D : data -> resetToDefaultToUnicode = TRUE ;\n GET_MAPPING ( sourceChar , targetUniChar , data ) ;\n * contextCharToUnicode = sourceChar ;\n break ;\n case ISCII_VOWEL_SIGN_E : i = 1 ;\n found = FALSE ;\n for ( ;\n i < vowelSignESpecialCases [ 0 ] [ 0 ] ;\n i ++ ) {\n U_ASSERT ( i < UPRV_LENGTHOF ( vowelSignESpecialCases ) ) ;\n if ( vowelSignESpecialCases [ i ] [ 0 ] == ( uint8_t ) * contextCharToUnicode ) {\n targetUniChar = vowelSignESpecialCases [ i ] [ 1 ] ;\n found = TRUE ;\n break ;\n }\n }\n if ( found ) {\n if ( validityTable [ ( uint8_t ) targetUniChar ] & data -> currentMaskToUnicode ) {\n * contextCharToUnicode = NO_CHAR_MARKER ;\n * toUnicodeStatus = missingCharMarker ;\n break ;\n }\n }\n GET_MAPPING ( sourceChar , targetUniChar , data ) ;\n * contextCharToUnicode = sourceChar ;\n break ;\n case ISCII_NUKTA : if ( * contextCharToUnicode == ISCII_HALANT ) {\n targetUniChar = ZWJ ;\n * contextCharToUnicode = NO_CHAR_MARKER ;\n break ;\n }\n else if ( data -> currentDeltaToUnicode == PNJ_DELTA && data -> contextCharToUnicode == 0xc0 ) {\n if ( data -> prevToUnicodeStatus ) {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 1 ) , data -> prevToUnicodeStatus , 0 , err ) ;\n data -> prevToUnicodeStatus = 0x0000 ;\n }\n targetUniChar = PNJ_RRA ;\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source ) - 2 , targetUniChar , 0 , err ) ;\n if ( U_SUCCESS ( * err ) ) {\n targetUniChar = PNJ_SIGN_VIRAMA ;\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source ) - 2 , targetUniChar , 0 , err ) ;\n if ( U_SUCCESS ( * err ) ) {\n targetUniChar = PNJ_HA ;\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source ) - 2 , targetUniChar , 0 , err ) ;\n }\n else {\n args -> converter -> UCharErrorBuffer [ args -> converter -> UCharErrorBufferLength ++ ] = PNJ_HA ;\n }\n }\n else {\n args -> converter -> UCharErrorBuffer [ args -> converter -> UCharErrorBufferLength ++ ] = PNJ_SIGN_VIRAMA ;\n args -> converter -> UCharErrorBuffer [ args -> converter -> UCharErrorBufferLength ++ ] = PNJ_HA ;\n }\n * toUnicodeStatus = missingCharMarker ;\n data -> contextCharToUnicode = NO_CHAR_MARKER ;\n continue ;\n }\n else {\n i = 1 ;\n found = FALSE ;\n for ( ;\n i < nuktaSpecialCases [ 0 ] [ 0 ] ;\n i ++ ) {\n if ( nuktaSpecialCases [ i ] [ 0 ] == ( uint8_t ) * contextCharToUnicode ) {\n targetUniChar = nuktaSpecialCases [ i ] [ 1 ] ;\n found = TRUE ;\n break ;\n }\n }\n if ( found ) {\n if ( validityTable [ ( uint8_t ) targetUniChar ] & data -> currentMaskToUnicode ) {\n * contextCharToUnicode = NO_CHAR_MARKER ;\n * toUnicodeStatus = missingCharMarker ;\n if ( data -> currentDeltaToUnicode == PNJ_DELTA ) {\n if ( data -> prevToUnicodeStatus ) {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 1 ) , data -> prevToUnicodeStatus , 0 , err ) ;\n data -> prevToUnicodeStatus = 0x0000 ;\n }\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 2 ) , targetUniChar , data -> currentDeltaToUnicode , err ) ;\n continue ;\n }\n break ;\n }\n }\n U_FALLTHROUGH ;\n }\n default : GET_MAPPING ( sourceChar , targetUniChar , data ) ;\n * contextCharToUnicode = sourceChar ;\n break ;\n }\n if ( * toUnicodeStatus != missingCharMarker ) {\n if ( data -> currentDeltaToUnicode == PNJ_DELTA && data -> prevToUnicodeStatus != 0 && isPNJConsonant ( data -> prevToUnicodeStatus ) && ( * toUnicodeStatus + PNJ_DELTA ) == PNJ_SIGN_VIRAMA && ( targetUniChar + PNJ_DELTA ) == data -> prevToUnicodeStatus ) {\n offset = ( int ) ( source - args -> source - 3 ) ;\n tempTargetUniChar = PNJ_ADHAK ;\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , offset , tempTargetUniChar , 0 , err ) ;\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , offset , data -> prevToUnicodeStatus , 0 , err ) ;\n data -> prevToUnicodeStatus = 0x0000 ;\n * toUnicodeStatus = missingCharMarker ;\n continue ;\n }\n else {\n if ( data -> prevToUnicodeStatus ) {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 1 ) , data -> prevToUnicodeStatus , 0 , err ) ;\n data -> prevToUnicodeStatus = 0x0000 ;\n }\n if ( data -> currentDeltaToUnicode == PNJ_DELTA && ( targetUniChar + PNJ_DELTA ) == PNJ_BINDI && isPNJBindiTippi ( ( * toUnicodeStatus + PNJ_DELTA ) ) ) {\n targetUniChar = PNJ_TIPPI - PNJ_DELTA ;\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 2 ) , * toUnicodeStatus , PNJ_DELTA , err ) ;\n }\n else if ( data -> currentDeltaToUnicode == PNJ_DELTA && ( targetUniChar + PNJ_DELTA ) == PNJ_SIGN_VIRAMA && isPNJConsonant ( ( * toUnicodeStatus + PNJ_DELTA ) ) ) {\n data -> prevToUnicodeStatus = * toUnicodeStatus + PNJ_DELTA ;\n }\n else {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 2 ) , * toUnicodeStatus , data -> currentDeltaToUnicode , err ) ;\n }\n }\n * toUnicodeStatus = missingCharMarker ;\n }\n if ( targetUniChar != missingCharMarker ) {\n * toUnicodeStatus = ( UChar ) targetUniChar ;\n if ( data -> resetToDefaultToUnicode == TRUE ) {\n data -> currentDeltaToUnicode = data -> defDeltaToUnicode ;\n data -> currentMaskToUnicode = data -> defMaskToUnicode ;\n data -> resetToDefaultToUnicode = FALSE ;\n }\n }\n else {\n * err = U_INVALID_CHAR_FOUND ;\n CALLBACK : args -> converter -> toUBytes [ 0 ] = ( uint8_t ) sourceChar ;\n args -> converter -> toULength = 1 ;\n break ;\n }\n }\n else {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n }\n if ( U_SUCCESS ( * err ) && args -> flush && source == sourceLimit ) {\n UConverter * cnv = args -> converter ;\n if ( * contextCharToUnicode == ATR || * contextCharToUnicode == EXT || * contextCharToUnicode == ISCII_INV ) {\n cnv -> toUBytes [ 0 ] = ( uint8_t ) * contextCharToUnicode ;\n cnv -> toULength = 1 ;\n * contextCharToUnicode = NO_CHAR_MARKER ;\n }\n else {\n cnv -> toULength = 0 ;\n }\n if ( * toUnicodeStatus != missingCharMarker ) {\n WRITE_TO_TARGET_TO_U ( args , source , target , args -> offsets , ( source - args -> source - 1 ) , * toUnicodeStatus , data -> currentDeltaToUnicode , err ) ;\n * toUnicodeStatus = missingCharMarker ;\n }\n }\n args -> target = target ;\n args -> source = source ;\n }", "hash": -4136373206107992781, "project": "chrome", "size": 269, "target": 1, "idx": 22333}
{"code": "static UChar32 ucnv_getNextUChar_UTF8 ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n UConverter * cnv ;\n const uint8_t * sourceInitial ;\n const uint8_t * source ;\n uint16_t extraBytesToWrite ;\n uint8_t myByte ;\n UChar32 ch ;\n int8_t i , isLegalSequence ;\n cnv = args -> converter ;\n sourceInitial = source = ( const uint8_t * ) args -> source ;\n if ( source >= ( const uint8_t * ) args -> sourceLimit ) {\n * err = U_INDEX_OUTOFBOUNDS_ERROR ;\n return 0xffff ;\n }\n myByte = ( uint8_t ) * ( source ++ ) ;\n if ( myByte < 0x80 ) {\n args -> source = ( const char * ) source ;\n return ( UChar32 ) myByte ;\n }\n extraBytesToWrite = ( uint16_t ) bytesFromUTF8 [ myByte ] ;\n if ( extraBytesToWrite == 0 ) {\n cnv -> toUBytes [ 0 ] = myByte ;\n cnv -> toULength = 1 ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n args -> source = ( const char * ) source ;\n return 0xffff ;\n }\n if ( ( ( const char * ) source + extraBytesToWrite - 1 ) > args -> sourceLimit ) {\n cnv -> toUBytes [ 0 ] = myByte ;\n i = 1 ;\n * err = U_TRUNCATED_CHAR_FOUND ;\n while ( source < ( const uint8_t * ) args -> sourceLimit ) {\n if ( U8_IS_TRAIL ( myByte = * source ) ) {\n cnv -> toUBytes [ i ++ ] = myByte ;\n ++ source ;\n }\n else {\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n cnv -> toULength = i ;\n args -> source = ( const char * ) source ;\n return 0xffff ;\n }\n isLegalSequence = 1 ;\n ch = myByte << 6 ;\n switch ( extraBytesToWrite ) {\n case 6 : ch += ( myByte = * source ) ;\n ch <<= 6 ;\n if ( ! U8_IS_TRAIL ( myByte ) ) {\n isLegalSequence = 0 ;\n break ;\n }\n ++ source ;\n U_FALLTHROUGH ;\n case 5 : ch += ( myByte = * source ) ;\n ch <<= 6 ;\n if ( ! U8_IS_TRAIL ( myByte ) ) {\n isLegalSequence = 0 ;\n break ;\n }\n ++ source ;\n U_FALLTHROUGH ;\n case 4 : ch += ( myByte = * source ) ;\n ch <<= 6 ;\n if ( ! U8_IS_TRAIL ( myByte ) ) {\n isLegalSequence = 0 ;\n break ;\n }\n ++ source ;\n U_FALLTHROUGH ;\n case 3 : ch += ( myByte = * source ) ;\n ch <<= 6 ;\n if ( ! U8_IS_TRAIL ( myByte ) ) {\n isLegalSequence = 0 ;\n break ;\n }\n ++ source ;\n U_FALLTHROUGH ;\n case 2 : ch += ( myByte = * source ) ;\n if ( ! U8_IS_TRAIL ( myByte ) ) {\n isLegalSequence = 0 ;\n break ;\n }\n ++ source ;\n }\n ;\n ch -= offsetsFromUTF8 [ extraBytesToWrite ] ;\n args -> source = ( const char * ) source ;\n if ( isLegalSequence && ( uint32_t ) ch <= MAXIMUM_UTF && ( uint32_t ) ch >= utf8_minChar32 [ extraBytesToWrite ] && ! U_IS_SURROGATE ( ch ) ) {\n return ch ;\n }\n for ( i = 0 ;\n sourceInitial < source ;\n ++ i ) {\n cnv -> toUBytes [ i ] = * sourceInitial ++ ;\n }\n cnv -> toULength = i ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n return 0xffff ;\n }", "hash": -7899851216763489956, "project": "chrome", "size": 102, "target": 1, "idx": 22339}
{"code": "static void ucnv_toUnicode_UTF8 ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n UConverter * cnv = args -> converter ;\n const unsigned char * mySource = ( unsigned char * ) args -> source ;\n UChar * myTarget = args -> target ;\n const unsigned char * sourceLimit = ( unsigned char * ) args -> sourceLimit ;\n const UChar * targetLimit = args -> targetLimit ;\n unsigned char * toUBytes = cnv -> toUBytes ;\n UBool isCESU8 = hasCESU8Data ( cnv ) ;\n uint32_t ch , ch2 = 0 ;\n int32_t i , inBytes ;\n if ( cnv -> toUnicodeStatus && myTarget < targetLimit ) {\n inBytes = cnv -> mode ;\n i = cnv -> toULength ;\n cnv -> toULength = 0 ;\n ch = cnv -> toUnicodeStatus ;\n cnv -> toUnicodeStatus = 0 ;\n goto morebytes ;\n }\n while ( mySource < sourceLimit && myTarget < targetLimit ) {\n ch = * ( mySource ++ ) ;\n if ( ch < 0x80 ) {\n * ( myTarget ++ ) = ( UChar ) ch ;\n }\n else {\n toUBytes [ 0 ] = ( char ) ch ;\n inBytes = bytesFromUTF8 [ ch ] ;\n i = 1 ;\n morebytes : while ( i < inBytes ) {\n if ( mySource < sourceLimit ) {\n toUBytes [ i ] = ( char ) ( ch2 = * mySource ) ;\n if ( ! U8_IS_TRAIL ( ch2 ) ) {\n break ;\n }\n ch = ( ch << 6 ) + ch2 ;\n ++ mySource ;\n i ++ ;\n }\n else {\n cnv -> toUnicodeStatus = ch ;\n cnv -> mode = inBytes ;\n cnv -> toULength = ( int8_t ) i ;\n goto donefornow ;\n }\n }\n ch -= offsetsFromUTF8 [ inBytes ] ;\n if ( i == inBytes && ch <= MAXIMUM_UTF && ch >= utf8_minChar32 [ i ] && ( isCESU8 ? i <= 3 : ! U_IS_SURROGATE ( ch ) ) ) {\n if ( ch <= MAXIMUM_UCS2 ) {\n * ( myTarget ++ ) = ( UChar ) ch ;\n }\n else {\n ch -= HALF_BASE ;\n * ( myTarget ++ ) = ( UChar ) ( ( ch >> HALF_SHIFT ) + SURROGATE_HIGH_START ) ;\n ch = ( ch & HALF_MASK ) + SURROGATE_LOW_START ;\n if ( myTarget < targetLimit ) {\n * ( myTarget ++ ) = ( UChar ) ch ;\n }\n else {\n cnv -> UCharErrorBuffer [ 0 ] = ( UChar ) ch ;\n cnv -> UCharErrorBufferLength = 1 ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n }\n }\n else {\n cnv -> toULength = ( int8_t ) i ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n }\n donefornow : if ( mySource < sourceLimit && myTarget >= targetLimit && U_SUCCESS ( * err ) ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n args -> target = myTarget ;\n args -> source = ( const char * ) mySource ;\n }", "hash": -7899851216763489956, "project": "chrome", "size": 77, "target": 1, "idx": 22340}
{"code": "static void ucnv_UTF8FromUTF8 ( UConverterFromUnicodeArgs * pFromUArgs , UConverterToUnicodeArgs * pToUArgs , UErrorCode * pErrorCode ) {\n UConverter * utf8 ;\n const uint8_t * source , * sourceLimit ;\n uint8_t * target ;\n int32_t targetCapacity ;\n int32_t count ;\n int8_t oldToULength , toULength , toULimit ;\n UChar32 c ;\n uint8_t b , t1 , t2 ;\n utf8 = pToUArgs -> converter ;\n source = ( uint8_t * ) pToUArgs -> source ;\n sourceLimit = ( uint8_t * ) pToUArgs -> sourceLimit ;\n target = ( uint8_t * ) pFromUArgs -> target ;\n targetCapacity = ( int32_t ) ( pFromUArgs -> targetLimit - pFromUArgs -> target ) ;\n c = ( UChar32 ) utf8 -> toUnicodeStatus ;\n if ( c != 0 ) {\n toULength = oldToULength = utf8 -> toULength ;\n toULimit = ( int8_t ) utf8 -> mode ;\n }\n else {\n toULength = oldToULength = toULimit = 0 ;\n }\n count = ( int32_t ) ( sourceLimit - source ) + oldToULength ;\n if ( count < toULimit ) {\n }\n else if ( targetCapacity < toULimit ) {\n * pErrorCode = U_USING_DEFAULT_WARNING ;\n return ;\n }\n else {\n int32_t i ;\n if ( count > targetCapacity ) {\n count = targetCapacity ;\n }\n i = 0 ;\n while ( i < 3 && i < ( count - toULimit ) ) {\n b = source [ count - oldToULength - i - 1 ] ;\n if ( U8_IS_TRAIL ( b ) ) {\n ++ i ;\n }\n else {\n if ( i < U8_COUNT_TRAIL_BYTES ( b ) ) {\n count -= i + 1 ;\n }\n break ;\n }\n }\n }\n if ( c != 0 ) {\n utf8 -> toUnicodeStatus = 0 ;\n utf8 -> toULength = 0 ;\n goto moreBytes ;\n }\n while ( count > 0 ) {\n b = * source ++ ;\n if ( ( int8_t ) b >= 0 ) {\n * target ++ = b ;\n -- count ;\n continue ;\n }\n else {\n if ( b > 0xe0 ) {\n if ( ( t1 = source [ 0 ] ) >= 0x80 && ( ( b < 0xed && ( t1 <= 0xbf ) ) || ( b == 0xed && ( t1 <= 0x9f ) ) ) && ( t2 = source [ 1 ] ) >= 0x80 && t2 <= 0xbf ) {\n source += 2 ;\n * target ++ = b ;\n * target ++ = t1 ;\n * target ++ = t2 ;\n count -= 3 ;\n continue ;\n }\n }\n else if ( b < 0xe0 ) {\n if ( b >= 0xc2 && ( t1 = * source ) >= 0x80 && t1 <= 0xbf ) {\n ++ source ;\n * target ++ = b ;\n * target ++ = t1 ;\n count -= 2 ;\n continue ;\n }\n }\n else if ( b == 0xe0 ) {\n if ( ( t1 = source [ 0 ] ) >= 0xa0 && t1 <= 0xbf && ( t2 = source [ 1 ] ) >= 0x80 && t2 <= 0xbf ) {\n source += 2 ;\n * target ++ = b ;\n * target ++ = t1 ;\n * target ++ = t2 ;\n count -= 3 ;\n continue ;\n }\n }\n oldToULength = 0 ;\n toULength = 1 ;\n toULimit = U8_COUNT_TRAIL_BYTES ( b ) + 1 ;\n c = b ;\n moreBytes : while ( toULength < toULimit ) {\n if ( source < sourceLimit ) {\n b = * source ;\n if ( U8_IS_TRAIL ( b ) ) {\n ++ source ;\n ++ toULength ;\n c = ( c << 6 ) + b ;\n }\n else {\n break ;\n }\n }\n else {\n source -= ( toULength - oldToULength ) ;\n while ( oldToULength < toULength ) {\n utf8 -> toUBytes [ oldToULength ++ ] = * source ++ ;\n }\n utf8 -> toUnicodeStatus = c ;\n utf8 -> toULength = toULength ;\n utf8 -> mode = toULimit ;\n pToUArgs -> source = ( char * ) source ;\n pFromUArgs -> target = ( char * ) target ;\n return ;\n }\n }\n if ( toULength == toULimit && ( toULength == 3 || toULength == 2 ) && ( c -= utf8_offsets [ toULength ] ) >= utf8_minLegal [ toULength ] && ( c <= 0xd7ff || 0xe000 <= c ) ) {\n }\n else if ( toULength == toULimit && toULength == 4 && ( 0x10000 <= ( c -= utf8_offsets [ 4 ] ) && c <= 0x10ffff ) ) {\n }\n else {\n source -= ( toULength - oldToULength ) ;\n while ( oldToULength < toULength ) {\n utf8 -> toUBytes [ oldToULength ++ ] = * source ++ ;\n }\n utf8 -> toULength = toULength ;\n pToUArgs -> source = ( char * ) source ;\n pFromUArgs -> target = ( char * ) target ;\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n return ;\n }\n {\n int8_t i ;\n for ( i = 0 ;\n i < oldToULength ;\n ++ i ) {\n * target ++ = utf8 -> toUBytes [ i ] ;\n }\n source -= ( toULength - oldToULength ) ;\n for ( ;\n i < toULength ;\n ++ i ) {\n * target ++ = * source ++ ;\n }\n count -= toULength ;\n }\n }\n }\n if ( U_SUCCESS ( * pErrorCode ) && source < sourceLimit ) {\n if ( target == ( const uint8_t * ) pFromUArgs -> targetLimit ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n }\n else {\n b = * source ;\n toULimit = U8_COUNT_TRAIL_BYTES ( b ) + 1 ;\n if ( toULimit > ( sourceLimit - source ) ) {\n toULength = 0 ;\n c = b ;\n for ( ;\n ;\n ) {\n utf8 -> toUBytes [ toULength ++ ] = b ;\n if ( ++ source == sourceLimit ) {\n utf8 -> toUnicodeStatus = c ;\n utf8 -> toULength = toULength ;\n utf8 -> mode = toULimit ;\n break ;\n }\n else if ( ! U8_IS_TRAIL ( b = * source ) ) {\n utf8 -> toULength = toULength ;\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n c = ( c << 6 ) + b ;\n }\n }\n else {\n * pErrorCode = U_USING_DEFAULT_WARNING ;\n }\n }\n }\n pToUArgs -> source = ( char * ) source ;\n pFromUArgs -> target = ( char * ) target ;\n }", "hash": -7899851216763489956, "project": "chrome", "size": 187, "target": 1, "idx": 22341}
{"code": "static uint32_t U_CALLCONV _enumTypeValue ( const void * context , uint32_t value ) {\n return GET_CATEGORY ( value ) ;\n }", "hash": -2544050834216939451, "project": "chrome", "size": 3, "target": 1, "idx": 22343}
{"code": "static void _UTF7FromUnicodeWithOffsets ( UConverterFromUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n UConverter * cnv ;\n const UChar * source , * sourceLimit ;\n uint8_t * target , * targetLimit ;\n int32_t * offsets ;\n int32_t length , targetCapacity , sourceIndex ;\n UChar c ;\n const UBool * encodeDirectly ;\n uint8_t bits ;\n int8_t base64Counter ;\n UBool inDirectMode ;\n cnv = pArgs -> converter ;\n source = pArgs -> source ;\n sourceLimit = pArgs -> sourceLimit ;\n target = ( uint8_t * ) pArgs -> target ;\n targetLimit = ( uint8_t * ) pArgs -> targetLimit ;\n offsets = pArgs -> offsets ;\n {\n uint32_t status = cnv -> fromUnicodeStatus ;\n encodeDirectly = status < 0x10000000 ? encodeDirectlyMaximum : encodeDirectlyRestricted ;\n inDirectMode = ( UBool ) ( ( status >> 24 ) & 1 ) ;\n base64Counter = ( int8_t ) ( status >> 16 ) ;\n bits = ( uint8_t ) status ;\n U_ASSERT ( bits <= UPRV_LENGTHOF ( toBase64 ) ) ;\n }\n sourceIndex = 0 ;\n if ( inDirectMode ) {\n directMode : length = ( int32_t ) ( sourceLimit - source ) ;\n targetCapacity = ( int32_t ) ( targetLimit - target ) ;\n if ( length > targetCapacity ) {\n length = targetCapacity ;\n }\n while ( length > 0 ) {\n c = * source ++ ;\n if ( c <= 127 && encodeDirectly [ c ] ) {\n * target ++ = ( uint8_t ) c ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ++ ;\n }\n }\n else if ( c == PLUS ) {\n * target ++ = PLUS ;\n if ( target < targetLimit ) {\n * target ++ = MINUS ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ++ ;\n }\n goto directMode ;\n }\n else {\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ++ ;\n }\n cnv -> charErrorBuffer [ 0 ] = MINUS ;\n cnv -> charErrorBufferLength = 1 ;\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n }\n else {\n -- source ;\n * target ++ = PLUS ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n }\n inDirectMode = FALSE ;\n base64Counter = 0 ;\n goto unicodeMode ;\n }\n -- length ;\n }\n if ( source < sourceLimit && target >= targetLimit ) {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n }\n }\n else {\n unicodeMode : while ( source < sourceLimit ) {\n if ( target < targetLimit ) {\n c = * source ++ ;\n if ( c <= 127 && encodeDirectly [ c ] ) {\n inDirectMode = TRUE ;\n -- source ;\n if ( base64Counter != 0 ) {\n * target ++ = toBase64 [ bits ] ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex - 1 ;\n }\n }\n if ( fromBase64 [ c ] != - 1 ) {\n if ( target < targetLimit ) {\n * target ++ = MINUS ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex - 1 ;\n }\n }\n else {\n cnv -> charErrorBuffer [ 0 ] = MINUS ;\n cnv -> charErrorBufferLength = 1 ;\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n }\n goto directMode ;\n }\n else {\n switch ( base64Counter ) {\n case 0 : * target ++ = toBase64 [ c >> 10 ] ;\n if ( target < targetLimit ) {\n * target ++ = toBase64 [ ( c >> 4 ) & 0x3f ] ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ++ ;\n }\n }\n else {\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ++ ;\n }\n cnv -> charErrorBuffer [ 0 ] = toBase64 [ ( c >> 4 ) & 0x3f ] ;\n cnv -> charErrorBufferLength = 1 ;\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n }\n bits = ( uint8_t ) ( ( c & 15 ) << 2 ) ;\n base64Counter = 1 ;\n break ;\n case 1 : * target ++ = toBase64 [ bits | ( c >> 14 ) ] ;\n if ( target < targetLimit ) {\n * target ++ = toBase64 [ ( c >> 8 ) & 0x3f ] ;\n if ( target < targetLimit ) {\n * target ++ = toBase64 [ ( c >> 2 ) & 0x3f ] ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ++ ;\n }\n }\n else {\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ++ ;\n }\n cnv -> charErrorBuffer [ 0 ] = toBase64 [ ( c >> 2 ) & 0x3f ] ;\n cnv -> charErrorBufferLength = 1 ;\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n }\n }\n else {\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ++ ;\n }\n cnv -> charErrorBuffer [ 0 ] = toBase64 [ ( c >> 8 ) & 0x3f ] ;\n cnv -> charErrorBuffer [ 1 ] = toBase64 [ ( c >> 2 ) & 0x3f ] ;\n cnv -> charErrorBufferLength = 2 ;\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n }\n bits = ( uint8_t ) ( ( c & 3 ) << 4 ) ;\n base64Counter = 2 ;\n break ;\n case 2 : * target ++ = toBase64 [ bits | ( c >> 12 ) ] ;\n if ( target < targetLimit ) {\n * target ++ = toBase64 [ ( c >> 6 ) & 0x3f ] ;\n if ( target < targetLimit ) {\n * target ++ = toBase64 [ c & 0x3f ] ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ++ ;\n }\n }\n else {\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ;\n * offsets ++ = sourceIndex ++ ;\n }\n cnv -> charErrorBuffer [ 0 ] = toBase64 [ c & 0x3f ] ;\n cnv -> charErrorBufferLength = 1 ;\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n }\n }\n else {\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex ++ ;\n }\n cnv -> charErrorBuffer [ 0 ] = toBase64 [ ( c >> 6 ) & 0x3f ] ;\n cnv -> charErrorBuffer [ 1 ] = toBase64 [ c & 0x3f ] ;\n cnv -> charErrorBufferLength = 2 ;\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n }\n bits = 0 ;\n base64Counter = 0 ;\n break ;\n default : break ;\n }\n }\n }\n else {\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n break ;\n }\n }\n }\n if ( pArgs -> flush && source >= sourceLimit ) {\n if ( ! inDirectMode ) {\n if ( base64Counter != 0 ) {\n if ( target < targetLimit ) {\n * target ++ = toBase64 [ bits ] ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex - 1 ;\n }\n }\n else {\n cnv -> charErrorBuffer [ cnv -> charErrorBufferLength ++ ] = toBase64 [ bits ] ;\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n }\n }\n if ( target < targetLimit ) {\n * target ++ = MINUS ;\n if ( offsets != NULL ) {\n * offsets ++ = sourceIndex - 1 ;\n }\n }\n else {\n cnv -> charErrorBuffer [ cnv -> charErrorBufferLength ++ ] = MINUS ;\n * pErrorCode = U_BUFFER_OVERFLOW_ERROR ;\n }\n }\n cnv -> fromUnicodeStatus = ( cnv -> fromUnicodeStatus & 0xf0000000 ) | 0x1000000 ;\n }\n else {\n cnv -> fromUnicodeStatus = ( cnv -> fromUnicodeStatus & 0xf0000000 ) | ( ( uint32_t ) inDirectMode << 24 ) | ( ( uint32_t ) base64Counter << 16 ) | ( uint32_t ) bits ;\n }\n pArgs -> source = source ;\n pArgs -> target = ( char * ) target ;\n pArgs -> offsets = offsets ;\n return ;\n }", "hash": 6453796474132805955, "project": "chrome", "size": 237, "target": 1, "idx": 22350}
{"code": "static UChar32 _UTF32GetNextUChar ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n switch ( pArgs -> converter -> mode ) {\n case 8 : return T_UConverter_getNextUChar_UTF32_BE ( pArgs , pErrorCode ) ;\n case 9 : return T_UConverter_getNextUChar_UTF32_LE ( pArgs , pErrorCode ) ;\n default : return UCNV_GET_NEXT_UCHAR_USE_TO_U ;\n }\n }", "hash": 1891617106617090004, "project": "chrome", "size": 7, "target": 1, "idx": 22361}
{"code": "static void T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC ( UConverterFromUnicodeArgs * args , UErrorCode * err ) {\n const UChar * mySource = args -> source ;\n unsigned char * myTarget ;\n int32_t * myOffsets ;\n const UChar * sourceLimit = args -> sourceLimit ;\n const unsigned char * targetLimit = ( unsigned char * ) args -> targetLimit ;\n UChar32 ch , ch2 ;\n unsigned int indexToWrite ;\n unsigned char temp [ sizeof ( uint32_t ) ] ;\n int32_t offsetNum = 0 ;\n if ( mySource >= sourceLimit ) {\n return ;\n }\n if ( args -> converter -> fromUnicodeStatus == UCNV_NEED_TO_WRITE_BOM ) {\n static const char bom [ ] = {\n ( char ) 0xff , ( char ) 0xfe , 0 , 0 }\n ;\n ucnv_fromUWriteBytes ( args -> converter , bom , 4 , & args -> target , args -> targetLimit , & args -> offsets , - 1 , err ) ;\n args -> converter -> fromUnicodeStatus = 0 ;\n }\n myTarget = ( unsigned char * ) args -> target ;\n myOffsets = args -> offsets ;\n temp [ 3 ] = 0 ;\n if ( args -> converter -> fromUChar32 ) {\n ch = args -> converter -> fromUChar32 ;\n args -> converter -> fromUChar32 = 0 ;\n goto lowsurogate ;\n }\n while ( mySource < sourceLimit && myTarget < targetLimit ) {\n ch = * ( mySource ++ ) ;\n if ( U16_IS_SURROGATE ( ch ) ) {\n if ( U16_IS_LEAD ( ch ) ) {\n lowsurogate : if ( mySource < sourceLimit ) {\n ch2 = * mySource ;\n if ( U16_IS_TRAIL ( ch2 ) ) {\n ch = ( ( ch - SURROGATE_HIGH_START ) << HALF_SHIFT ) + ch2 + SURROGATE_LOW_BASE ;\n mySource ++ ;\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n if ( args -> flush ) {\n * err = U_ILLEGAL_CHAR_FOUND ;\n }\n break ;\n }\n }\n else {\n args -> converter -> fromUChar32 = ch ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n break ;\n }\n }\n temp [ 2 ] = ( uint8_t ) ( ch >> 16 & 0x1F ) ;\n temp [ 1 ] = ( uint8_t ) ( ch >> 8 ) ;\n temp [ 0 ] = ( uint8_t ) ( ch ) ;\n for ( indexToWrite = 0 ;\n indexToWrite <= sizeof ( uint32_t ) - 1 ;\n indexToWrite ++ ) {\n if ( myTarget < targetLimit ) {\n * ( myTarget ++ ) = temp [ indexToWrite ] ;\n * ( myOffsets ++ ) = offsetNum ;\n }\n else {\n args -> converter -> charErrorBuffer [ args -> converter -> charErrorBufferLength ++ ] = temp [ indexToWrite ] ;\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n }\n offsetNum = offsetNum + 1 + ( temp [ 2 ] != 0 ) ;\n }\n if ( mySource < sourceLimit && myTarget >= targetLimit && U_SUCCESS ( * err ) ) {\n * err = U_BUFFER_OVERFLOW_ERROR ;\n }\n args -> target = ( char * ) myTarget ;\n args -> source = mySource ;\n args -> offsets = myOffsets ;\n }", "hash": 1891617106617090004, "project": "chrome", "size": 82, "target": 1, "idx": 22372}
{"code": "static int32_t u_scanf_hex_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n int32_t len ;\n int32_t skipped ;\n void * num = ( void * ) ( args [ 0 ] . ptrValue ) ;\n int64_t result ;\n skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;\n ufile_fill_uchar_buffer ( input ) ;\n len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;\n if ( info -> fWidth != - 1 ) len = ufmt_min ( len , info -> fWidth ) ;\n if ( * ( input -> str . fPos ) == 0x0030 && ( * ( input -> str . fPos + 1 ) == 0x0078 || * ( input -> str . fPos + 1 ) == 0x0058 ) ) {\n input -> str . fPos += 2 ;\n len -= 2 ;\n }\n result = ufmt_uto64 ( input -> str . fPos , & len , 16 ) ;\n input -> str . fPos += len ;\n if ( ! info -> fSkipArg ) {\n if ( info -> fIsShort ) * ( int16_t * ) num = ( int16_t ) ( UINT16_MAX & result ) ;\n else if ( info -> fIsLongLong ) * ( int64_t * ) num = result ;\n else * ( int32_t * ) num = ( int32_t ) ( UINT32_MAX & result ) ;\n }\n * argConverted = ! info -> fSkipArg ;\n return len + skipped ;\n }", "hash": -8704451445127642833, "project": "chrome", "size": 23, "target": 1, "idx": 22381}
{"code": "static int32_t u_printf_ustring_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n int32_t len , written ;\n const UChar * arg = ( const UChar * ) ( args [ 0 ] . ptrValue ) ;\n if ( arg == NULL ) {\n arg = gNullStr ;\n }\n len = u_strlen ( arg ) ;\n if ( info -> fPrecision != - 1 && info -> fPrecision < len ) {\n len = info -> fPrecision ;\n }\n written = handler -> pad_and_justify ( context , info , arg , len ) ;\n return written ;\n }", "hash": 1981604082870872490, "project": "chrome", "size": 13, "target": 1, "idx": 22404}
{"code": "static void _SCSUClose ( UConverter * cnv ) {\n if ( cnv -> extraInfo != NULL ) {\n if ( ! cnv -> isExtraLocal ) {\n uprv_free ( cnv -> extraInfo ) ;\n }\n cnv -> extraInfo = NULL ;\n }\n }", "hash": -4032982860280343776, "project": "chrome", "size": 8, "target": 1, "idx": 22415}
{"code": "static int xmlHashGrow ( xmlHashTablePtr table , int size ) {\n unsigned long key ;\n int oldsize , i ;\n xmlHashEntryPtr iter , next ;\n struct _xmlHashEntry * oldtable ;\n # ifdef DEBUG_GROW unsigned long nbElem = 0 ;\n # endif if ( table == NULL ) return ( - 1 ) ;\n if ( size < 8 ) return ( - 1 ) ;\n if ( size > 8 * 2048 ) return ( - 1 ) ;\n oldsize = table -> size ;\n oldtable = table -> table ;\n if ( oldtable == NULL ) return ( - 1 ) ;\n table -> table = xmlMalloc ( size * sizeof ( xmlHashEntry ) ) ;\n if ( table -> table == NULL ) {\n table -> table = oldtable ;\n return ( - 1 ) ;\n }\n memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;\n table -> size = size ;\n for ( i = 0 ;\n i < oldsize ;\n i ++ ) {\n if ( oldtable [ i ] . valid == 0 ) continue ;\n key = xmlHashComputeKey ( table , oldtable [ i ] . name , oldtable [ i ] . name2 , oldtable [ i ] . name3 ) ;\n memcpy ( & ( table -> table [ key ] ) , & ( oldtable [ i ] ) , sizeof ( xmlHashEntry ) ) ;\n table -> table [ key ] . next = NULL ;\n }\n for ( i = 0 ;\n i < oldsize ;\n i ++ ) {\n iter = oldtable [ i ] . next ;\n while ( iter ) {\n next = iter -> next ;\n key = xmlHashComputeKey ( table , iter -> name , iter -> name2 , iter -> name3 ) ;\n if ( table -> table [ key ] . valid == 0 ) {\n memcpy ( & ( table -> table [ key ] ) , iter , sizeof ( xmlHashEntry ) ) ;\n table -> table [ key ] . next = NULL ;\n xmlFree ( iter ) ;\n }\n else {\n iter -> next = table -> table [ key ] . next ;\n table -> table [ key ] . next = iter ;\n }\n # ifdef DEBUG_GROW nbElem ++ ;\n # endif iter = next ;\n }\n }\n xmlFree ( oldtable ) ;\n # ifdef DEBUG_GROW xmlGenericError ( xmlGenericErrorContext , \"xmlHashGrow : from %d to %d, %d elems\\n\" , oldsize , size , nbElem ) ;\n # endif return ( 0 ) ;\n }", "hash": -4239386405881995323, "project": "chrome", "size": 51, "target": 1, "idx": 22423}
{"code": "void xmlHashScan3 ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , const xmlChar * name3 , xmlHashScanner f , void * data ) {\n xmlHashScanFull3 ( table , name , name2 , name3 , ( xmlHashScannerFull ) f , data ) ;\n }", "hash": -4239386405881995323, "project": "chrome", "size": 3, "target": 1, "idx": 22431}
{"code": "void exsltSaxonRegister ( void ) {\n xsltRegisterExtModule ( SAXON_NAMESPACE , ( xsltExtInitFunction ) exsltSaxonInit , ( xsltExtShutdownFunction ) exsltSaxonShutdown ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"expression\" , SAXON_NAMESPACE , exsltSaxonExpressionFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"eval\" , SAXON_NAMESPACE , exsltSaxonEvalFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"evaluate\" , SAXON_NAMESPACE , exsltSaxonEvaluateFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"line-number\" , SAXON_NAMESPACE , exsltSaxonLineNumberFunction ) ;\n }", "hash": 2120840145598099861, "project": "chrome", "size": 7, "target": 1, "idx": 22434}
{"code": "const xmlChar * xsltEvalStaticAttrValueTemplate ( xsltStylesheetPtr style , xmlNodePtr inst , const xmlChar * name , const xmlChar * ns , int * found ) {\n const xmlChar * ret ;\n xmlChar * expr ;\n if ( ( style == NULL ) || ( inst == NULL ) || ( name == NULL ) ) return ( NULL ) ;\n expr = xsltGetNsProp ( inst , name , ns ) ;\n if ( expr == NULL ) {\n * found = 0 ;\n return ( NULL ) ;\n }\n * found = 1 ;\n ret = xmlStrchr ( expr , '{\n' ) ;\n if ( ret != NULL ) {\n xmlFree ( expr ) ;\n return ( NULL ) ;\n }\n ret = xmlDictLookup ( style -> dict , expr , - 1 ) ;\n xmlFree ( expr ) ;\n return ( ret ) ;\n }", "hash": 103178053094187415, "project": "chrome", "size": 20, "target": 1, "idx": 22440}
{"code": "xmlAttrPtr xsltAttrListTemplateProcess ( xsltTransformContextPtr ctxt , xmlNodePtr target , xmlAttrPtr attrs ) {\n xmlAttrPtr attr , copy , last ;\n xmlNodePtr oldInsert , text ;\n xmlNsPtr origNs = NULL , copyNs = NULL ;\n const xmlChar * value ;\n xmlChar * valueAVT ;\n if ( ( ctxt == NULL ) || ( target == NULL ) || ( attrs == NULL ) ) return ( NULL ) ;\n oldInsert = ctxt -> insert ;\n ctxt -> insert = target ;\n if ( target -> properties ) {\n last = target -> properties ;\n while ( last -> next != NULL ) last = last -> next ;\n }\n else {\n last = NULL ;\n }\n attr = attrs ;\n do {\n # ifdef XSLT_REFACTORED if ( attr -> psvi == xsltXSLTAttrMarker ) {\n goto next_attribute ;\n }\n # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) {\n goto next_attribute ;\n }\n # endif if ( attr -> children != NULL ) {\n if ( ( attr -> children -> type != XML_TEXT_NODE ) || ( attr -> children -> next != NULL ) ) {\n xsltTransformError ( ctxt , NULL , attr -> parent , \"Internal error: The children of an attribute node of a \" \"literal result element are not in the expected form.\\n\" ) ;\n goto error ;\n }\n value = attr -> children -> content ;\n if ( value == NULL ) value = xmlDictLookup ( ctxt -> dict , BAD_CAST \"\" , 0 ) ;\n }\n else value = xmlDictLookup ( ctxt -> dict , BAD_CAST \"\" , 0 ) ;\n copy = xmlNewDocProp ( target -> doc , attr -> name , NULL ) ;\n if ( copy == NULL ) {\n if ( attr -> ns ) {\n xsltTransformError ( ctxt , NULL , attr -> parent , \"Internal error: Failed to create attribute '{\n%s}\n%s'.\\n\" , attr -> ns -> href , attr -> name ) ;\n }\n else {\n xsltTransformError ( ctxt , NULL , attr -> parent , \"Internal error: Failed to create attribute '%s'.\\n\" , attr -> name ) ;\n }\n goto error ;\n }\n copy -> parent = target ;\n if ( last == NULL ) {\n target -> properties = copy ;\n last = copy ;\n }\n else {\n last -> next = copy ;\n copy -> prev = last ;\n last = copy ;\n }\n if ( attr -> ns != origNs ) {\n origNs = attr -> ns ;\n if ( attr -> ns != NULL ) {\n # ifdef XSLT_REFACTORED copyNs = xsltGetSpecialNamespace ( ctxt , attr -> parent , attr -> ns -> href , attr -> ns -> prefix , target ) ;\n # else copyNs = xsltGetNamespace ( ctxt , attr -> parent , attr -> ns , target ) ;\n # endif if ( copyNs == NULL ) goto error ;\n }\n else copyNs = NULL ;\n }\n copy -> ns = copyNs ;\n text = xmlNewText ( NULL ) ;\n if ( text != NULL ) {\n copy -> last = copy -> children = text ;\n text -> parent = ( xmlNodePtr ) copy ;\n text -> doc = copy -> doc ;\n if ( attr -> psvi != NULL ) {\n valueAVT = xsltEvalAVT ( ctxt , attr -> psvi , attr -> parent ) ;\n if ( valueAVT == NULL ) {\n if ( attr -> ns ) {\n xsltTransformError ( ctxt , NULL , attr -> parent , \"Internal error: Failed to evaluate the AVT \" \"of attribute '{\n%s}\n%s'.\\n\" , attr -> ns -> href , attr -> name ) ;\n }\n else {\n xsltTransformError ( ctxt , NULL , attr -> parent , \"Internal error: Failed to evaluate the AVT \" \"of attribute '%s'.\\n\" , attr -> name ) ;\n }\n text -> content = xmlStrdup ( BAD_CAST \"\" ) ;\n goto error ;\n }\n else {\n text -> content = valueAVT ;\n }\n }\n else if ( ( ctxt -> internalized ) && ( target -> doc != NULL ) && ( target -> doc -> dict == ctxt -> dict ) && xmlDictOwns ( ctxt -> dict , value ) ) {\n text -> content = ( xmlChar * ) value ;\n }\n else {\n text -> content = xmlStrdup ( value ) ;\n }\n if ( ( copy != NULL ) && ( text != NULL ) && ( xmlIsID ( copy -> doc , copy -> parent , copy ) ) ) xmlAddID ( NULL , copy -> doc , text -> content , copy ) ;\n }\n next_attribute : attr = attr -> next ;\n }\n while ( attr != NULL ) ;\n attr = attrs ;\n do {\n # ifdef XSLT_REFACTORED if ( ( attr -> psvi == xsltXSLTAttrMarker ) && xmlStrEqual ( attr -> name , ( const xmlChar * ) \"use-attribute-sets\" ) ) {\n xsltApplyAttributeSet ( ctxt , ctxt -> node , ( xmlNodePtr ) attr , NULL ) ;\n }\n # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> name , ( const xmlChar * ) \"use-attribute-sets\" ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) {\n xsltApplyAttributeSet ( ctxt , ctxt -> node , ( xmlNodePtr ) attr , NULL ) ;\n }\n # endif attr = attr -> next ;\n }\n while ( attr != NULL ) ;\n ctxt -> insert = oldInsert ;\n return ( target -> properties ) ;\n error : ctxt -> insert = oldInsert ;\n return ( NULL ) ;\n }", "hash": 103178053094187415, "project": "chrome", "size": 115, "target": 1, "idx": 22441}
{"code": "int xmlListCopy ( xmlListPtr cur , const xmlListPtr old ) {\n xmlLinkPtr lk ;\n if ( ( old == NULL ) || ( cur == NULL ) ) return ( 1 ) ;\n for ( lk = old -> sentinel -> next ;\n lk != old -> sentinel ;\n lk = lk -> next ) {\n if ( 0 != xmlListInsert ( cur , lk -> data ) ) {\n xmlListDelete ( cur ) ;\n return ( 1 ) ;\n }\n }\n return ( 0 ) ;\n }", "hash": -4558261210024070448, "project": "chrome", "size": 13, "target": 1, "idx": 22462}
{"code": "int xmlListPushBack ( xmlListPtr l , void * data ) {\n xmlLinkPtr lkPlace , lkNew ;\n if ( l == NULL ) return ( 0 ) ;\n lkPlace = l -> sentinel -> prev ;\n if ( NULL == ( lkNew = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ) ) {\n xmlGenericError ( xmlGenericErrorContext , \"Cannot initialize memory for new link\" ) ;\n return ( 0 ) ;\n }\n lkNew -> data = data ;\n lkNew -> next = lkPlace -> next ;\n ( lkPlace -> next ) -> prev = lkNew ;\n lkPlace -> next = lkNew ;\n lkNew -> prev = lkPlace ;\n return 1 ;\n }", "hash": -4558261210024070448, "project": "chrome", "size": 15, "target": 1, "idx": 22467}
{"code": "static void DangerousDownloadValidated ( JNIEnv * env , const JavaParamRef < jclass > & clazz , const JavaParamRef < jobject > & tab , jint download_id , jboolean accept ) {\n TabAndroid * tab_android = TabAndroid : : GetNativeTab ( env , tab ) ;\n content : : DownloadControllerAndroid : : Get ( ) -> DangerousDownloadValidated ( tab_android -> web_contents ( ) , download_id , accept ) ;\n }", "hash": 1020583704101101585, "project": "chrome", "size": 4, "target": 1, "idx": 22468}
{"code": "IN_PROC_BROWSER_TEST_F ( SupervisedUserNavigationThrottleNotSupervisedTest , DontBlock ) {\n BlockHost ( kExampleHost ) ;\n WebContents * tab = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n GURL blocked_url = embedded_test_server ( ) -> GetURL ( kExampleHost , \"/supervised_user/simple.html\" ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , blocked_url ) ;\n EXPECT_FALSE ( tab -> ShowingInterstitialPage ( ) ) ;\n }", "hash": -3151614232349488244, "project": "chrome", "size": 7, "target": 1, "idx": 22471}
{"code": "TEST_F ( MultiBufferTest , LRUTest ) {\n int64_t max_size = 17 ;\n int64_t current_size = 0 ;\n lru_ -> IncrementMaxSize ( max_size ) ;\n multibuffer_ . SetMaxWriters ( 1 ) ;\n size_t pos = 0 ;\n size_t end = 10000 ;\n multibuffer_ . SetFileSize ( 10000 ) ;\n media : : MultiBufferReader reader ( & multibuffer_ , pos , end , base : : Callback < void ( int64_t , int64_t ) > ( ) ) ;\n reader . SetPreload ( 10000 , 10000 ) ;\n EXPECT_EQ ( current_size , lru_ -> Size ( ) ) ;\n current_size += max_size ;\n while ( AdvanceAll ( ) ) ;\n EXPECT_EQ ( current_size , lru_ -> Size ( ) ) ;\n lru_ -> IncrementMaxSize ( - max_size ) ;\n lru_ -> Prune ( 3 ) ;\n current_size -= 3 ;\n EXPECT_EQ ( current_size , lru_ -> Size ( ) ) ;\n lru_ -> Prune ( 3 ) ;\n current_size -= 3 ;\n EXPECT_EQ ( current_size , lru_ -> Size ( ) ) ;\n lru_ -> Prune ( 1000 ) ;\n EXPECT_EQ ( 0 , lru_ -> Size ( ) ) ;\n }", "hash": -8562506069584692324, "project": "chrome", "size": 24, "target": 1, "idx": 22484}
{"code": "TEST_F ( MultiBufferTest , ReadAll ) {\n multibuffer_ . SetMaxWriters ( 1 ) ;\n size_t pos = 0 ;\n size_t end = 10000 ;\n multibuffer_ . SetFileSize ( 10000 ) ;\n multibuffer_ . SetMustReadWholeFile ( true ) ;\n media : : MultiBufferReader reader ( & multibuffer_ , pos , end , base : : Callback < void ( int64_t , int64_t ) > ( ) ) ;\n reader . SetMaxBuffer ( 2000 , 5000 ) ;\n reader . SetPreload ( 1000 , 1000 ) ;\n while ( pos < end ) {\n unsigned char buffer [ 27 ] ;\n buffer [ 17 ] = 17 ;\n size_t to_read = std : : min < size_t > ( end - pos , 17 ) ;\n int64_t bytes_read = reader . TryRead ( buffer , to_read ) ;\n if ( bytes_read ) {\n EXPECT_EQ ( buffer [ 17 ] , 17 ) ;\n for ( int64_t i = 0 ;\n i < bytes_read ;\n i ++ ) {\n uint8_t expected = static_cast < uint8_t > ( ( pos * 15485863 ) >> 16 ) ;\n EXPECT_EQ ( expected , buffer [ i ] ) << \" pos = \" << pos ;\n pos ++ ;\n }\n }\n else {\n Advance ( ) ;\n }\n }\n }", "hash": -8562506069584692324, "project": "chrome", "size": 29, "target": 1, "idx": 22485}
{"code": "TEST_F ( ProtocolHandlerRegistryTest , TestReplaceRemovesStaleHandlers ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/%s\" ) , \"test1\" ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/updated-url/%s\" ) , \"test2\" ) ;\n ProtocolHandler ph3 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/third/%s\" ) , \"test\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph2 ) ;\n ASSERT_TRUE ( registry ( ) -> AttemptReplace ( ph3 ) ) ;\n const ProtocolHandler & handler ( registry ( ) -> GetHandlerFor ( \"mailto\" ) ) ;\n ASSERT_EQ ( handler . url ( ) , ph3 . url ( ) ) ;\n registry ( ) -> RemoveHandler ( ph3 ) ;\n ASSERT_TRUE ( registry ( ) -> GetHandlerFor ( \"mailto\" ) . IsEmpty ( ) ) ;\n }", "hash": 8461782184979846246, "project": "chrome", "size": 12, "target": 1, "idx": 22502}
{"code": "TEST_F ( ProtocolHandlerRegistryTest , TestSilentlyRegisterHandler ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"test\" , GURL ( \"http://test/%s\" ) , \"test1\" ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"test\" , GURL ( \"http://test/%s\" ) , \"test2\" ) ;\n ProtocolHandler ph3 = CreateProtocolHandler ( \"ignore\" , GURL ( \"http://test/%s\" ) , \"ignore1\" ) ;\n ProtocolHandler ph4 = CreateProtocolHandler ( \"ignore\" , GURL ( \"http://test/%s\" ) , \"ignore2\" ) ;\n ASSERT_FALSE ( registry ( ) -> SilentlyHandleRegisterHandlerRequest ( ph1 ) ) ;\n ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph1 ) ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n ASSERT_TRUE ( registry ( ) -> IsRegistered ( ph1 ) ) ;\n ASSERT_TRUE ( registry ( ) -> SilentlyHandleRegisterHandlerRequest ( ph2 ) ) ;\n ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph1 ) ) ;\n ASSERT_TRUE ( registry ( ) -> IsRegistered ( ph2 ) ) ;\n ASSERT_FALSE ( registry ( ) -> SilentlyHandleRegisterHandlerRequest ( ph3 ) ) ;\n ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph3 ) ) ;\n registry ( ) -> OnIgnoreRegisterProtocolHandler ( ph3 ) ;\n ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph3 ) ) ;\n ASSERT_TRUE ( registry ( ) -> IsIgnored ( ph3 ) ) ;\n ASSERT_TRUE ( registry ( ) -> SilentlyHandleRegisterHandlerRequest ( ph4 ) ) ;\n ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph4 ) ) ;\n ASSERT_TRUE ( registry ( ) -> HasIgnoredEquivalent ( ph4 ) ) ;\n }", "hash": 8461782184979846246, "project": "chrome", "size": 21, "target": 1, "idx": 22503}
{"code": "INDIC_TABLE_ELEMENT_TYPE hb_indic_get_categories ( hb_codepoint_t u ) {\n switch ( u >> 12 ) {\n case 0x0u : if ( hb_in_range ( u , 0x0028u , 0x0040u ) ) return indic_table [ u - 0x0028u + indic_offset_0x0028u ] ;\n if ( hb_in_range ( u , 0x00D0u , 0x00D8u ) ) return indic_table [ u - 0x00D0u + indic_offset_0x00d0u ] ;\n if ( hb_in_range ( u , 0x0900u , 0x0DF8u ) ) return indic_table [ u - 0x0900u + indic_offset_0x0900u ] ;\n if ( unlikely ( u == 0x00A0u ) ) return _ ( CP , x ) ;\n break ;\n case 0x1u : if ( hb_in_range ( u , 0x1000u , 0x10A0u ) ) return indic_table [ u - 0x1000u + indic_offset_0x1000u ] ;\n if ( hb_in_range ( u , 0x1700u , 0x17F0u ) ) return indic_table [ u - 0x1700u + indic_offset_0x1700u ] ;\n if ( hb_in_range ( u , 0x1900u , 0x1AA0u ) ) return indic_table [ u - 0x1900u + indic_offset_0x1900u ] ;\n if ( hb_in_range ( u , 0x1B00u , 0x1C50u ) ) return indic_table [ u - 0x1B00u + indic_offset_0x1b00u ] ;\n if ( hb_in_range ( u , 0x1CD0u , 0x1CF8u ) ) return indic_table [ u - 0x1CD0u + indic_offset_0x1cd0u ] ;\n break ;\n case 0x2u : if ( hb_in_range ( u , 0x2008u , 0x2018u ) ) return indic_table [ u - 0x2008u + indic_offset_0x2008u ] ;\n if ( unlikely ( u == 0x25CCu ) ) return _ ( CP , x ) ;\n break ;\n case 0xAu : if ( hb_in_range ( u , 0xA800u , 0xAAF8u ) ) return indic_table [ u - 0xA800u + indic_offset_0xa800u ] ;\n if ( hb_in_range ( u , 0xABC0u , 0xAC00u ) ) return indic_table [ u - 0xABC0u + indic_offset_0xabc0u ] ;\n break ;\n case 0x10u : if ( hb_in_range ( u , 0x10A00u , 0x10A48u ) ) return indic_table [ u - 0x10A00u + indic_offset_0x10a00u ] ;\n break ;\n case 0x11u : if ( hb_in_range ( u , 0x11000u , 0x110C0u ) ) return indic_table [ u - 0x11000u + indic_offset_0x11000u ] ;\n if ( hb_in_range ( u , 0x11100u , 0x11238u ) ) return indic_table [ u - 0x11100u + indic_offset_0x11100u ] ;\n if ( hb_in_range ( u , 0x112B0u , 0x11378u ) ) return indic_table [ u - 0x112B0u + indic_offset_0x112b0u ] ;\n if ( hb_in_range ( u , 0x11480u , 0x114E0u ) ) return indic_table [ u - 0x11480u + indic_offset_0x11480u ] ;\n if ( hb_in_range ( u , 0x11580u , 0x115C8u ) ) return indic_table [ u - 0x11580u + indic_offset_0x11580u ] ;\n if ( hb_in_range ( u , 0x11600u , 0x116D0u ) ) return indic_table [ u - 0x11600u + indic_offset_0x11600u ] ;\n break ;\n default : break ;\n }\n return _ ( x , x ) ;\n }", "hash": -2214740494935555658, "project": "chrome", "size": 32, "target": 1, "idx": 22509}
{"code": "IN_PROC_BROWSER_TEST_F ( SiteDetailsBrowserTest , PlatformAppsNotIsolated ) {\n if ( content : : AreAllSitesIsolatedForTesting ( ) ) return ;\n CreateAppWithSandboxPage ( \"Extension One\" ) ;\n scoped_refptr < TestMemoryDetails > details = new TestMemoryDetails ( ) ;\n details -> StartFetchAndWait ( ) ;\n EXPECT_EQ ( 0 , details -> GetOutOfProcessIframeCount ( ) ) ;\n }", "hash": 515706766097680840, "project": "chrome", "size": 7, "target": 1, "idx": 22514}
{"code": "static void final_reordering_syllable ( const hb_ot_shape_plan_t * plan , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n const indic_shape_plan_t * indic_plan = ( const indic_shape_plan_t * ) plan -> data ;\n hb_glyph_info_t * info = buffer -> info ;\n if ( indic_plan -> virama_glyph ) {\n unsigned int virama_glyph = indic_plan -> virama_glyph ;\n for ( unsigned int i = start ;\n i < end ;\n i ++ ) if ( info [ i ] . codepoint == virama_glyph && _hb_glyph_info_ligated ( & info [ i ] ) && _hb_glyph_info_multiplied ( & info [ i ] ) ) {\n info [ i ] . indic_category ( ) = OT_H ;\n _hb_glyph_info_clear_ligated_and_multiplied ( & info [ i ] ) ;\n }\n }\n bool try_pref = ! ! indic_plan -> mask_array [ PREF ] ;\n unsigned int base ;\n for ( base = start ;\n base < end ;\n base ++ ) if ( info [ base ] . indic_position ( ) >= POS_BASE_C ) {\n if ( try_pref && base + 1 < end && indic_plan -> config -> pref_len == 2 ) {\n for ( unsigned int i = base + 1 ;\n i < end ;\n i ++ ) if ( ( info [ i ] . mask & indic_plan -> mask_array [ PREF ] ) != 0 ) {\n if ( ! ( _hb_glyph_info_substituted ( & info [ i ] ) && _hb_glyph_info_ligated_and_didnt_multiply ( & info [ i ] ) ) ) {\n base = i ;\n while ( base < end && is_halant_or_coeng ( info [ base ] ) ) base ++ ;\n info [ base ] . indic_position ( ) = POS_BASE_C ;\n try_pref = false ;\n }\n break ;\n }\n }\n if ( start < base && info [ base ] . indic_position ( ) > POS_BASE_C ) base -- ;\n break ;\n }\n if ( base == end && start < base && is_one_of ( info [ base - 1 ] , FLAG ( OT_ZWJ ) ) ) base -- ;\n if ( base < end ) while ( start < base && is_one_of ( info [ base ] , ( FLAG ( OT_N ) | HALANT_OR_COENG_FLAGS ) ) ) base -- ;\n if ( start + 1 < end && start < base ) {\n unsigned int new_pos = base == end ? base - 2 : base - 1 ;\n if ( buffer -> props . script != HB_SCRIPT_MALAYALAM && buffer -> props . script != HB_SCRIPT_TAMIL ) {\n while ( new_pos > start && ! ( is_one_of ( info [ new_pos ] , ( FLAG ( OT_M ) | HALANT_OR_COENG_FLAGS ) ) ) ) new_pos -- ;\n if ( is_halant_or_coeng ( info [ new_pos ] ) && info [ new_pos ] . indic_position ( ) != POS_PRE_M ) {\n if ( new_pos + 1 < end && is_joiner ( info [ new_pos + 1 ] ) ) new_pos ++ ;\n }\n else new_pos = start ;\n }\n if ( start < new_pos && info [ new_pos ] . indic_position ( ) != POS_PRE_M ) {\n for ( unsigned int i = new_pos ;\n i > start ;\n i -- ) if ( info [ i - 1 ] . indic_position ( ) == POS_PRE_M ) {\n unsigned int old_pos = i - 1 ;\n hb_glyph_info_t tmp = info [ old_pos ] ;\n memmove ( & info [ old_pos ] , & info [ old_pos + 1 ] , ( new_pos - old_pos ) * sizeof ( info [ 0 ] ) ) ;\n info [ new_pos ] = tmp ;\n if ( old_pos < base && base <= new_pos ) base -- ;\n buffer -> merge_clusters ( new_pos , MIN ( end , base + 1 ) ) ;\n new_pos -- ;\n }\n }\n else {\n for ( unsigned int i = start ;\n i < base ;\n i ++ ) if ( info [ i ] . indic_position ( ) == POS_PRE_M ) {\n buffer -> merge_clusters ( i , MIN ( end , base + 1 ) ) ;\n break ;\n }\n }\n }\n if ( start + 1 < end && info [ start ] . indic_position ( ) == POS_RA_TO_BECOME_REPH && ( ( info [ start ] . indic_category ( ) == OT_Repha ) ^ _hb_glyph_info_ligated_and_didnt_multiply ( & info [ start ] ) ) ) {\n unsigned int new_reph_pos ;\n reph_position_t reph_pos = indic_plan -> config -> reph_pos ;\n assert ( reph_pos != REPH_POS_DONT_CARE ) ;\n if ( reph_pos == REPH_POS_AFTER_POST ) {\n goto reph_step_5 ;\n }\n {\n new_reph_pos = start + 1 ;\n while ( new_reph_pos < base && ! is_halant_or_coeng ( info [ new_reph_pos ] ) ) new_reph_pos ++ ;\n if ( new_reph_pos < base && is_halant_or_coeng ( info [ new_reph_pos ] ) ) {\n if ( new_reph_pos + 1 < base && is_joiner ( info [ new_reph_pos + 1 ] ) ) new_reph_pos ++ ;\n goto reph_move ;\n }\n }\n if ( reph_pos == REPH_POS_AFTER_MAIN ) {\n new_reph_pos = base ;\n while ( new_reph_pos + 1 < end && info [ new_reph_pos + 1 ] . indic_position ( ) <= POS_AFTER_MAIN ) new_reph_pos ++ ;\n if ( new_reph_pos < end ) goto reph_move ;\n }\n if ( reph_pos == REPH_POS_AFTER_SUB ) {\n new_reph_pos = base ;\n while ( new_reph_pos < end && ! ( FLAG ( info [ new_reph_pos + 1 ] . indic_position ( ) ) & ( FLAG ( POS_POST_C ) | FLAG ( POS_AFTER_POST ) | FLAG ( POS_SMVD ) ) ) ) new_reph_pos ++ ;\n if ( new_reph_pos < end ) goto reph_move ;\n }\n reph_step_5 : {\n new_reph_pos = start + 1 ;\n while ( new_reph_pos < base && ! is_halant_or_coeng ( info [ new_reph_pos ] ) ) new_reph_pos ++ ;\n if ( new_reph_pos < base && is_halant_or_coeng ( info [ new_reph_pos ] ) ) {\n if ( new_reph_pos + 1 < base && is_joiner ( info [ new_reph_pos + 1 ] ) ) new_reph_pos ++ ;\n goto reph_move ;\n }\n }\n {\n new_reph_pos = end - 1 ;\n while ( new_reph_pos > start && info [ new_reph_pos ] . indic_position ( ) == POS_SMVD ) new_reph_pos -- ;\n if ( ! hb_options ( ) . uniscribe_bug_compatible && unlikely ( is_halant_or_coeng ( info [ new_reph_pos ] ) ) ) {\n for ( unsigned int i = base + 1 ;\n i < new_reph_pos ;\n i ++ ) if ( info [ i ] . indic_category ( ) == OT_M ) {\n new_reph_pos -- ;\n }\n }\n goto reph_move ;\n }\n reph_move : {\n buffer -> merge_clusters ( start , new_reph_pos + 1 ) ;\n hb_glyph_info_t reph = info [ start ] ;\n memmove ( & info [ start ] , & info [ start + 1 ] , ( new_reph_pos - start ) * sizeof ( info [ 0 ] ) ) ;\n info [ new_reph_pos ] = reph ;\n if ( start < base && base <= new_reph_pos ) base -- ;\n }\n }\n if ( try_pref && base + 1 < end ) {\n unsigned int pref_len = indic_plan -> config -> pref_len ;\n for ( unsigned int i = base + 1 ;\n i < end ;\n i ++ ) if ( ( info [ i ] . mask & indic_plan -> mask_array [ PREF ] ) != 0 ) {\n if ( _hb_glyph_info_substituted ( & info [ i ] ) && ( ( pref_len == 1 ) ^ _hb_glyph_info_ligated_and_didnt_multiply ( & info [ i ] ) ) ) {\n unsigned int new_pos = base ;\n if ( buffer -> props . script != HB_SCRIPT_MALAYALAM && buffer -> props . script != HB_SCRIPT_TAMIL ) {\n while ( new_pos > start && ! ( is_one_of ( info [ new_pos - 1 ] , FLAG ( OT_M ) | HALANT_OR_COENG_FLAGS ) ) ) new_pos -- ;\n if ( new_pos > start && info [ new_pos - 1 ] . indic_category ( ) == OT_M ) {\n unsigned int old_pos = i ;\n for ( unsigned int i = base + 1 ;\n i < old_pos ;\n i ++ ) if ( info [ i ] . indic_category ( ) == OT_M ) {\n new_pos -- ;\n break ;\n }\n }\n }\n if ( new_pos > start && is_halant_or_coeng ( info [ new_pos - 1 ] ) ) {\n if ( new_pos < end && is_joiner ( info [ new_pos ] ) ) new_pos ++ ;\n }\n {\n unsigned int old_pos = i ;\n buffer -> merge_clusters ( new_pos , old_pos + 1 ) ;\n hb_glyph_info_t tmp = info [ old_pos ] ;\n memmove ( & info [ new_pos + 1 ] , & info [ new_pos ] , ( old_pos - new_pos ) * sizeof ( info [ 0 ] ) ) ;\n info [ new_pos ] = tmp ;\n if ( new_pos <= base && base < old_pos ) base ++ ;\n }\n }\n break ;\n }\n }\n if ( info [ start ] . indic_position ( ) == POS_PRE_M && ( ! start || ! ( FLAG ( _hb_glyph_info_get_general_category ( & info [ start - 1 ] ) ) & FLAG_RANGE ( HB_UNICODE_GENERAL_CATEGORY_FORMAT , HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK ) ) ) ) info [ start ] . mask |= indic_plan -> mask_array [ INIT ] ;\n if ( hb_options ( ) . uniscribe_bug_compatible ) {\n switch ( ( hb_tag_t ) plan -> props . script ) {\n case HB_SCRIPT_TAMIL : case HB_SCRIPT_SINHALA : break ;\n default : buffer -> merge_clusters ( start , end ) ;\n break ;\n }\n }\n }", "hash": -3165961362620712443, "project": "chrome", "size": 162, "target": 1, "idx": 22522}
{"code": "static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }", "hash": -4527380754569407959, "project": "chrome", "size": 6, "target": 1, "idx": 22541}
{"code": "static void user_data_key_destroy ( hb_user_data_key_t l ) {\n }", "hash": -4527380754569407959, "project": "chrome", "size": 2, "target": 1, "idx": 22543}
{"code": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs )", "hash": -4527380754569407959, "project": "chrome", "size": 10, "target": 1, "idx": 22561}
{"code": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , AlwaysInBackground ) {\n StartHttpsServer ( false ) ;\n StartHttpServer ( ) ;\n NavigateInBackgroundAndClose ( https_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n NavigateInBackgroundAndClose ( http_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n }", "hash": 8206514580434225668, "project": "chrome", "size": 8, "target": 1, "idx": 22598}
{"code": "TEST_F ( TtsControllerTest , TestGetMatchingVoice ) {\n std : : unique_ptr < TestableTtsController > tts_controller = std : : make_unique < TestableTtsController > ( ) ;\n # if defined ( OS_CHROMEOS ) TestingPrefServiceSimple pref_service_ ;\n std : : unique_ptr < base : : DictionaryValue > lang_to_voices = std : : make_unique < base : : DictionaryValue > ( ) ;\n lang_to_voices -> SetKey ( \"es\" , base : : Value ( \"{\n\\\"name\\\":\\\"Voice8\\\",\\\"extension\\\":\\\"id8\\\"}\n\" ) ) ;\n lang_to_voices -> SetKey ( \"noLanguage\" , base : : Value ( \"{\n\\\"name\\\":\\\"Android\\\",\\\"extension\\\":\\\"\\\"}\n\" ) ) ;\n pref_service_ . registry ( ) -> RegisterDictionaryPref ( prefs : : kTextToSpeechLangToVoiceName , std : : move ( lang_to_voices ) ) ;\n tts_controller -> pref_service_ = & pref_service_ ;\n # endif {\n Utterance utterance ( nullptr ) ;\n std : : vector < VoiceData > voices ;\n EXPECT_EQ ( - 1 , tts_controller -> GetMatchingVoice ( & utterance , voices ) ) ;\n }\n {\n Utterance utterance ( nullptr ) ;\n std : : vector < VoiceData > voices ;\n voices . push_back ( VoiceData ( ) ) ;\n voices . push_back ( VoiceData ( ) ) ;\n EXPECT_EQ ( 0 , tts_controller -> GetMatchingVoice ( & utterance , voices ) ) ;\n }\n {\n Utterance utterance ( nullptr ) ;\n std : : vector < VoiceData > voices ;\n VoiceData fr_voice ;\n fr_voice . lang = \"fr\" ;\n voices . push_back ( fr_voice ) ;\n VoiceData en_voice ;\n en_voice . lang = \"en\" ;\n voices . push_back ( en_voice ) ;\n VoiceData de_voice ;\n de_voice . lang = \"de\" ;\n voices . push_back ( de_voice ) ;\n EXPECT_EQ ( 1 , tts_controller -> GetMatchingVoice ( & utterance , voices ) ) ;\n }\n {\n std : : vector < VoiceData > voices ;\n VoiceData voice0 ;\n voices . push_back ( voice0 ) ;\n VoiceData voice1 ;\n voice1 . gender = TTS_GENDER_FEMALE ;\n voices . push_back ( voice1 ) ;\n VoiceData voice2 ;\n voice2 . events . insert ( TTS_EVENT_WORD ) ;\n voices . push_back ( voice2 ) ;\n VoiceData voice3 ;\n voice3 . lang = \"de-DE\" ;\n voices . push_back ( voice3 ) ;\n VoiceData voice4 ;\n voice4 . lang = \"fr-CA\" ;\n voices . push_back ( voice4 ) ;\n VoiceData voice5 ;\n voice5 . name = \"Voice5\" ;\n voices . push_back ( voice5 ) ;\n VoiceData voice6 ;\n voice6 . extension_id = \"id6\" ;\n voices . push_back ( voice6 ) ;\n VoiceData voice7 ;\n voice7 . extension_id = \"id7\" ;\n voice7 . name = \"Voice7\" ;\n voice7 . lang = \"es-es\" ;\n voices . push_back ( voice7 ) ;\n VoiceData voice8 ;\n voice8 . extension_id = \"id8\" ;\n voice8 . name = \"Voice8\" ;\n voice8 . lang = \"es-mx\" ;\n voices . push_back ( voice8 ) ;\n VoiceData voice9 ;\n voice9 . extension_id = \"\" ;\n voice9 . name = \"Android\" ;\n voice9 . lang = \"\" ;\n voice9 . native = true ;\n voices . push_back ( voice9 ) ;\n Utterance utterance ( nullptr ) ;\n EXPECT_EQ ( 0 , tts_controller -> GetMatchingVoice ( & utterance , voices ) ) ;\n utterance . set_gender ( TTS_GENDER_FEMALE ) ;\n EXPECT_EQ ( 1 , tts_controller -> GetMatchingVoice ( & utterance , voices ) ) ;\n std : : set < TtsEventType > types ;\n types . insert ( TTS_EVENT_WORD ) ;\n utterance . set_required_event_types ( types ) ;\n EXPECT_EQ ( 2 , tts_controller -> GetMatchingVoice ( & utterance , voices ) ) ;\n utterance . set_lang ( \"de-DE\" ) ;\n EXPECT_EQ ( 3 , tts_controller -> GetMatchingVoice ( & utterance , voices ) ) ;\n utterance . set_lang ( \"fr-FR\" ) ;\n EXPECT_EQ ( 4 , tts_controller -> GetMatchingVoice ( & utterance , voices ) ) ;\n utterance . set_voice_name ( \"Voice5\" ) ;\n EXPECT_EQ ( 5 , tts_controller -> GetMatchingVoice ( & utterance , voices ) ) ;\n utterance . set_voice_name ( \"\" ) ;\n utterance . set_extension_id ( \"id6\" ) ;\n EXPECT_EQ ( 6 , tts_controller -> GetMatchingVoice ( & utterance , voices ) ) ;\n # if defined ( OS_CHROMEOS ) utterance . set_extension_id ( \"\" ) ;\n utterance . set_lang ( \"es-es\" ) ;\n EXPECT_EQ ( 7 , tts_controller -> GetMatchingVoice ( & utterance , voices ) ) ;\n utterance . set_extension_id ( \"\" ) ;\n utterance . set_lang ( \"es-ar\" ) ;\n EXPECT_EQ ( 8 , tts_controller -> GetMatchingVoice ( & utterance , voices ) ) ;\n utterance . set_voice_name ( \"Android\" ) ;\n utterance . set_extension_id ( \"\" ) ;\n utterance . set_lang ( \"\" ) ;\n EXPECT_EQ ( 9 , tts_controller -> GetMatchingVoice ( & utterance , voices ) ) ;\n # endif }\n }", "hash": 6263651552746807254, "project": "chrome", "size": 105, "target": 1, "idx": 22605}
{"code": "static void sbr_turnoff ( SpectralBandReplication * sbr ) {\n sbr -> start = 0 ;\n sbr -> kx [ 1 ] = 32 ;\n sbr -> m [ 1 ] = 0 ;\n sbr -> data [ 0 ] . e_a [ 1 ] = sbr -> data [ 1 ] . e_a [ 1 ] = - 1 ;\n memset ( & sbr -> spectrum_params , - 1 , sizeof ( SpectrumParameters ) ) ;\n }", "hash": -4106680724983638989, "project": "chrome", "size": 7, "target": 1, "idx": 22614}
{"code": "static int sbr_make_f_master ( AACContext * ac , SpectralBandReplication * sbr , SpectrumParameters * spectrum ) {\n unsigned int temp , max_qmf_subbands = 0 ;\n unsigned int start_min , stop_min ;\n int k ;\n const int8_t * sbr_offset_ptr ;\n int16_t stop_dk [ 13 ] ;\n if ( sbr -> sample_rate < 32000 ) {\n temp = 3000 ;\n }\n else if ( sbr -> sample_rate < 64000 ) {\n temp = 4000 ;\n }\n else temp = 5000 ;\n switch ( sbr -> sample_rate ) {\n case 16000 : sbr_offset_ptr = sbr_offset [ 0 ] ;\n break ;\n case 22050 : sbr_offset_ptr = sbr_offset [ 1 ] ;\n break ;\n case 24000 : sbr_offset_ptr = sbr_offset [ 2 ] ;\n break ;\n case 32000 : sbr_offset_ptr = sbr_offset [ 3 ] ;\n break ;\n case 44100 : case 48000 : case 64000 : sbr_offset_ptr = sbr_offset [ 4 ] ;\n break ;\n case 88200 : case 96000 : case 128000 : case 176400 : case 192000 : sbr_offset_ptr = sbr_offset [ 5 ] ;\n break ;\n default : av_log ( ac -> avctx , AV_LOG_ERROR , \"Unsupported sample rate for SBR: %d\\n\" , sbr -> sample_rate ) ;\n return - 1 ;\n }\n start_min = ( ( temp << 7 ) + ( sbr -> sample_rate >> 1 ) ) / sbr -> sample_rate ;\n stop_min = ( ( temp << 8 ) + ( sbr -> sample_rate >> 1 ) ) / sbr -> sample_rate ;\n sbr -> k [ 0 ] = start_min + sbr_offset_ptr [ spectrum -> bs_start_freq ] ;\n if ( spectrum -> bs_stop_freq < 14 ) {\n sbr -> k [ 2 ] = stop_min ;\n make_bands ( stop_dk , stop_min , 64 , 13 ) ;\n qsort ( stop_dk , 13 , sizeof ( stop_dk [ 0 ] ) , qsort_comparison_function_int16 ) ;\n for ( k = 0 ;\n k < spectrum -> bs_stop_freq ;\n k ++ ) sbr -> k [ 2 ] += stop_dk [ k ] ;\n }\n else if ( spectrum -> bs_stop_freq == 14 ) {\n sbr -> k [ 2 ] = 2 * sbr -> k [ 0 ] ;\n }\n else if ( spectrum -> bs_stop_freq == 15 ) {\n sbr -> k [ 2 ] = 3 * sbr -> k [ 0 ] ;\n }\n else {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Invalid bs_stop_freq: %d\\n\" , spectrum -> bs_stop_freq ) ;\n return - 1 ;\n }\n sbr -> k [ 2 ] = FFMIN ( 64 , sbr -> k [ 2 ] ) ;\n if ( sbr -> sample_rate <= 32000 ) {\n max_qmf_subbands = 48 ;\n }\n else if ( sbr -> sample_rate == 44100 ) {\n max_qmf_subbands = 35 ;\n }\n else if ( sbr -> sample_rate >= 48000 ) max_qmf_subbands = 32 ;\n else av_assert0 ( 0 ) ;\n if ( sbr -> k [ 2 ] - sbr -> k [ 0 ] > max_qmf_subbands ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Invalid bitstream, too many QMF subbands: %d\\n\" , sbr -> k [ 2 ] - sbr -> k [ 0 ] ) ;\n return - 1 ;\n }\n if ( ! spectrum -> bs_freq_scale ) {\n int dk , k2diff ;\n dk = spectrum -> bs_alter_scale + 1 ;\n sbr -> n_master = ( ( sbr -> k [ 2 ] - sbr -> k [ 0 ] + ( dk & 2 ) ) >> dk ) << 1 ;\n if ( check_n_master ( ac -> avctx , sbr -> n_master , sbr -> spectrum_params . bs_xover_band ) ) return - 1 ;\n for ( k = 1 ;\n k <= sbr -> n_master ;\n k ++ ) sbr -> f_master [ k ] = dk ;\n k2diff = sbr -> k [ 2 ] - sbr -> k [ 0 ] - sbr -> n_master * dk ;\n if ( k2diff < 0 ) {\n sbr -> f_master [ 1 ] -- ;\n sbr -> f_master [ 2 ] -= ( k2diff < - 1 ) ;\n }\n else if ( k2diff ) {\n sbr -> f_master [ sbr -> n_master ] ++ ;\n }\n sbr -> f_master [ 0 ] = sbr -> k [ 0 ] ;\n for ( k = 1 ;\n k <= sbr -> n_master ;\n k ++ ) sbr -> f_master [ k ] += sbr -> f_master [ k - 1 ] ;\n }\n else {\n int half_bands = 7 - spectrum -> bs_freq_scale ;\n int two_regions , num_bands_0 ;\n int vdk0_max , vdk1_min ;\n int16_t vk0 [ 49 ] ;\n if ( 49 * sbr -> k [ 2 ] > 110 * sbr -> k [ 0 ] ) {\n two_regions = 1 ;\n sbr -> k [ 1 ] = 2 * sbr -> k [ 0 ] ;\n }\n else {\n two_regions = 0 ;\n sbr -> k [ 1 ] = sbr -> k [ 2 ] ;\n }\n num_bands_0 = lrintf ( half_bands * log2f ( sbr -> k [ 1 ] / ( float ) sbr -> k [ 0 ] ) ) * 2 ;\n if ( num_bands_0 <= 0 ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Invalid num_bands_0: %d\\n\" , num_bands_0 ) ;\n return - 1 ;\n }\n vk0 [ 0 ] = 0 ;\n make_bands ( vk0 + 1 , sbr -> k [ 0 ] , sbr -> k [ 1 ] , num_bands_0 ) ;\n qsort ( vk0 + 1 , num_bands_0 , sizeof ( vk0 [ 1 ] ) , qsort_comparison_function_int16 ) ;\n vdk0_max = vk0 [ num_bands_0 ] ;\n vk0 [ 0 ] = sbr -> k [ 0 ] ;\n for ( k = 1 ;\n k <= num_bands_0 ;\n k ++ ) {\n if ( vk0 [ k ] <= 0 ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Invalid vDk0[%d]: %d\\n\" , k , vk0 [ k ] ) ;\n return - 1 ;\n }\n vk0 [ k ] += vk0 [ k - 1 ] ;\n }\n if ( two_regions ) {\n int16_t vk1 [ 49 ] ;\n float invwarp = spectrum -> bs_alter_scale ? 0.76923076923076923077f : 1.0f ;\n int num_bands_1 = lrintf ( half_bands * invwarp * log2f ( sbr -> k [ 2 ] / ( float ) sbr -> k [ 1 ] ) ) * 2 ;\n make_bands ( vk1 + 1 , sbr -> k [ 1 ] , sbr -> k [ 2 ] , num_bands_1 ) ;\n vdk1_min = array_min_int16 ( vk1 + 1 , num_bands_1 ) ;\n if ( vdk1_min < vdk0_max ) {\n int change ;\n qsort ( vk1 + 1 , num_bands_1 , sizeof ( vk1 [ 1 ] ) , qsort_comparison_function_int16 ) ;\n change = FFMIN ( vdk0_max - vk1 [ 1 ] , ( vk1 [ num_bands_1 ] - vk1 [ 1 ] ) >> 1 ) ;\n vk1 [ 1 ] += change ;\n vk1 [ num_bands_1 ] -= change ;\n }\n qsort ( vk1 + 1 , num_bands_1 , sizeof ( vk1 [ 1 ] ) , qsort_comparison_function_int16 ) ;\n vk1 [ 0 ] = sbr -> k [ 1 ] ;\n for ( k = 1 ;\n k <= num_bands_1 ;\n k ++ ) {\n if ( vk1 [ k ] <= 0 ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Invalid vDk1[%d]: %d\\n\" , k , vk1 [ k ] ) ;\n return - 1 ;\n }\n vk1 [ k ] += vk1 [ k - 1 ] ;\n }\n sbr -> n_master = num_bands_0 + num_bands_1 ;\n if ( check_n_master ( ac -> avctx , sbr -> n_master , sbr -> spectrum_params . bs_xover_band ) ) return - 1 ;\n memcpy ( & sbr -> f_master [ 0 ] , vk0 , ( num_bands_0 + 1 ) * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n memcpy ( & sbr -> f_master [ num_bands_0 + 1 ] , vk1 + 1 , num_bands_1 * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n }\n else {\n sbr -> n_master = num_bands_0 ;\n if ( check_n_master ( ac -> avctx , sbr -> n_master , sbr -> spectrum_params . bs_xover_band ) ) return - 1 ;\n memcpy ( sbr -> f_master , vk0 , ( num_bands_0 + 1 ) * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n }\n }\n return 0 ;\n }", "hash": -4106680724983638989, "project": "chrome", "size": 153, "target": 1, "idx": 22616}
{"code": "static void sbr_make_f_tablelim ( SpectralBandReplication * sbr ) {\n int k ;\n if ( sbr -> bs_limiter_bands > 0 ) {\n static const float bands_warped [ 3 ] = {\n 1.32715174233856803909f , 1.18509277094158210129f , 1.11987160404675912501f }\n ;\n const float lim_bands_per_octave_warped = bands_warped [ sbr -> bs_limiter_bands - 1 ] ;\n int16_t patch_borders [ 7 ] ;\n uint16_t * in = sbr -> f_tablelim + 1 , * out = sbr -> f_tablelim ;\n patch_borders [ 0 ] = sbr -> kx [ 1 ] ;\n for ( k = 1 ;\n k <= sbr -> num_patches ;\n k ++ ) patch_borders [ k ] = patch_borders [ k - 1 ] + sbr -> patch_num_subbands [ k - 1 ] ;\n memcpy ( sbr -> f_tablelim , sbr -> f_tablelow , ( sbr -> n [ 0 ] + 1 ) * sizeof ( sbr -> f_tablelow [ 0 ] ) ) ;\n if ( sbr -> num_patches > 1 ) memcpy ( sbr -> f_tablelim + sbr -> n [ 0 ] + 1 , patch_borders + 1 , ( sbr -> num_patches - 1 ) * sizeof ( patch_borders [ 0 ] ) ) ;\n qsort ( sbr -> f_tablelim , sbr -> num_patches + sbr -> n [ 0 ] , sizeof ( sbr -> f_tablelim [ 0 ] ) , qsort_comparison_function_int16 ) ;\n sbr -> n_lim = sbr -> n [ 0 ] + sbr -> num_patches - 1 ;\n while ( out < sbr -> f_tablelim + sbr -> n_lim ) {\n if ( * in >= * out * lim_bands_per_octave_warped ) {\n * ++ out = * in ++ ;\n }\n else if ( * in == * out || ! in_table_int16 ( patch_borders , sbr -> num_patches , * in ) ) {\n in ++ ;\n sbr -> n_lim -- ;\n }\n else if ( ! in_table_int16 ( patch_borders , sbr -> num_patches , * out ) ) {\n * out = * in ++ ;\n sbr -> n_lim -- ;\n }\n else {\n * ++ out = * in ++ ;\n }\n }\n }\n else {\n sbr -> f_tablelim [ 0 ] = sbr -> f_tablelow [ 0 ] ;\n sbr -> f_tablelim [ 1 ] = sbr -> f_tablelow [ sbr -> n [ 0 ] ] ;\n sbr -> n_lim = 1 ;\n }\n }", "hash": -4106680724983638989, "project": "chrome", "size": 40, "target": 1, "idx": 22633}
{"code": "static int read_sbr_single_channel_element ( AACContext * ac , SpectralBandReplication * sbr , GetBitContext * gb ) {\n if ( get_bits1 ( gb ) ) skip_bits ( gb , 4 ) ;\n if ( read_sbr_grid ( ac , sbr , gb , & sbr -> data [ 0 ] ) ) return - 1 ;\n read_sbr_dtdf ( sbr , gb , & sbr -> data [ 0 ] ) ;\n read_sbr_invf ( sbr , gb , & sbr -> data [ 0 ] ) ;\n read_sbr_envelope ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ;\n read_sbr_noise ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ;\n if ( ( sbr -> data [ 0 ] . bs_add_harmonic_flag = get_bits1 ( gb ) ) ) get_bits1_vector ( gb , sbr -> data [ 0 ] . bs_add_harmonic , sbr -> n [ 1 ] ) ;\n return 0 ;\n }", "hash": -4106680724983638989, "project": "chrome", "size": 10, "target": 1, "idx": 22634}
{"code": "IN_PROC_BROWSER_TEST_F ( WebRtcApprtcBrowserTest , MAYBE_MANUAL_FirefoxApprtcInteropTest ) {\n DetectErrorsInJavaScript ( ) ;\n ASSERT_TRUE ( LaunchApprtcInstanceOnLocalhost ( \"9999\" ) ) ;\n ASSERT_TRUE ( LaunchColliderOnLocalHost ( \"http://localhost:9999\" , \"8089\" ) ) ;\n while ( ! LocalApprtcInstanceIsUp ( ) ) DVLOG ( 1 ) << \"Waiting for AppRTC to come up...\" ;\n GURL room_url = GURL ( \"http://localhost:9999/r/some_room\" \"?wshpp=localhost:8089&wstls=false\" \"&firefox_fake_device=1\" ) ;\n chrome : : AddTabAt ( browser ( ) , GURL ( ) , - 1 , true ) ;\n content : : WebContents * chrome_tab = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n PermissionBubbleManager : : FromWebContents ( chrome_tab ) -> set_auto_response_for_test ( PermissionBubbleManager : : ACCEPT_ALL ) ;\n InfoBarResponder infobar_responder ( InfoBarService : : FromWebContents ( chrome_tab ) , InfoBarResponder : : ACCEPT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , room_url ) ;\n ASSERT_TRUE ( LaunchFirefoxWithUrl ( room_url ) ) ;\n ASSERT_TRUE ( WaitForCallToComeUp ( chrome_tab ) ) ;\n ASSERT_TRUE ( DetectRemoteVideoPlaying ( chrome_tab ) ) ;\n }", "hash": 6627875687115906550, "project": "chrome", "size": 15, "target": 1, "idx": 22646}
{"code": "void evsignal_dealloc ( struct event_base * base ) {\n int i = 0 ;\n if ( base -> sig . ev_signal_added ) {\n event_del ( & base -> sig . ev_signal ) ;\n base -> sig . ev_signal_added = 0 ;\n }\n for ( i = 0 ;\n i < NSIG ;\n ++ i ) {\n if ( i < base -> sig . sh_old_max && base -> sig . sh_old [ i ] != NULL ) _evsignal_restore_handler ( base , i ) ;\n }\n EVUTIL_CLOSESOCKET ( base -> sig . ev_signal_pair [ 0 ] ) ;\n base -> sig . ev_signal_pair [ 0 ] = - 1 ;\n EVUTIL_CLOSESOCKET ( base -> sig . ev_signal_pair [ 1 ] ) ;\n base -> sig . ev_signal_pair [ 1 ] = - 1 ;\n base -> sig . sh_old_max = 0 ;\n free ( base -> sig . sh_old ) ;\n }", "hash": 6980637897759012306, "project": "chrome", "size": 18, "target": 1, "idx": 22652}
{"code": "static void evsignal_cb ( int fd , short what , void * arg ) {\n static char signals [ 1 ] ;\n # ifdef WIN32 SSIZE_T n ;\n # else ssize_t n ;\n # endif n = recv ( fd , signals , sizeof ( signals ) , 0 ) ;\n if ( n == - 1 ) event_err ( 1 , \"%s: read\" , __func__ ) ;\n }", "hash": 6980637897759012306, "project": "chrome", "size": 7, "target": 1, "idx": 22654}
{"code": "struct event_base * event_base_new ( void ) {\n int i ;\n struct event_base * base ;\n if ( ( base = calloc ( 1 , sizeof ( struct event_base ) ) ) == NULL ) event_err ( 1 , \"%s: calloc\" , __func__ ) ;\n gettime ( base , & base -> event_tv ) ;\n min_heap_ctor ( & base -> timeheap ) ;\n TAILQ_INIT ( & base -> eventqueue ) ;\n base -> sig . ev_signal_pair [ 0 ] = - 1 ;\n base -> sig . ev_signal_pair [ 1 ] = - 1 ;\n base -> evbase = NULL ;\n for ( i = 0 ;\n eventops [ i ] && ! base -> evbase ;\n i ++ ) {\n base -> evsel = eventops [ i ] ;\n base -> evbase = base -> evsel -> init ( base ) ;\n }\n if ( base -> evbase == NULL ) event_errx ( 1 , \"%s: no event mechanism available\" , __func__ ) ;\n if ( evutil_getenv ( \"EVENT_SHOW_METHOD\" ) ) event_msgx ( \"libevent using: %s\\n\" , base -> evsel -> name ) ;\n event_base_priority_init ( base , 1 ) ;\n return ( base ) ;\n }", "hash": 8461266595329035000, "project": "chrome", "size": 21, "target": 1, "idx": 22658}
{"code": "static void test_evbuffer_find ( void ) {\n u_char * p ;\n const char * test1 = \"1234567890\\r\\n\" ;\n const char * test2 = \"1234567890\\r\" ;\n # define EVBUFFER_INITIAL_LENGTH 256 char test3 [ EVBUFFER_INITIAL_LENGTH ] ;\n unsigned int i ;\n struct evbuffer * buf = evbuffer_new ( ) ;\n fprintf ( stdout , \"Testing evbuffer_find 1: \" ) ;\n evbuffer_add ( buf , ( u_char * ) test1 , strlen ( test1 ) ) ;\n evbuffer_drain ( buf , strlen ( test1 ) ) ;\n evbuffer_add ( buf , ( u_char * ) test2 , strlen ( test2 ) ) ;\n p = evbuffer_find ( buf , ( u_char * ) \"\\r\\n\" , 2 ) ;\n if ( p == NULL ) {\n fprintf ( stdout , \"OK\\n\" ) ;\n }\n else {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n fprintf ( stdout , \"Testing evbuffer_find 2: \" ) ;\n evbuffer_drain ( buf , strlen ( test2 ) ) ;\n for ( i = 0 ;\n i < EVBUFFER_INITIAL_LENGTH ;\n ++ i ) test3 [ i ] = 'a' ;\n test3 [ EVBUFFER_INITIAL_LENGTH - 1 ] = 'x' ;\n evbuffer_add ( buf , ( u_char * ) test3 , EVBUFFER_INITIAL_LENGTH ) ;\n p = evbuffer_find ( buf , ( u_char * ) \"xy\" , 2 ) ;\n if ( p == NULL ) {\n printf ( \"OK\\n\" ) ;\n }\n else {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n fprintf ( stdout , \"Testing evbuffer_find 3: \" ) ;\n p = evbuffer_find ( buf , ( u_char * ) \"ax\" , 2 ) ;\n if ( p != NULL && strncmp ( ( char * ) p , \"ax\" , 2 ) == 0 ) {\n printf ( \"OK\\n\" ) ;\n }\n else {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n evbuffer_free ( buf ) ;\n }", "hash": 5347874611477979643, "project": "chrome", "size": 45, "target": 1, "idx": 22663}
{"code": "int main ( int argc , char * * argv ) {\n struct event signal_int ;\n event_init ( ) ;\n event_set ( & signal_int , SIGINT , EV_SIGNAL | EV_PERSIST , signal_cb , & signal_int ) ;\n event_add ( & signal_int , NULL ) ;\n event_dispatch ( ) ;\n return ( 0 ) ;\n }", "hash": 2058562589071273546, "project": "chrome", "size": 8, "target": 1, "idx": 22666}
{"code": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , IgnoreDownloads ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n base : : ScopedAllowBlockingForTesting allow_blocking ;\n base : : ScopedTempDir downloads_directory ;\n ASSERT_TRUE ( downloads_directory . CreateUniqueTempDir ( ) ) ;\n browser ( ) -> profile ( ) -> GetPrefs ( ) -> SetFilePath ( prefs : : kDownloadDefaultDirectory , downloads_directory . GetPath ( ) ) ;\n content : : DownloadTestObserverTerminal downloads_observer ( content : : BrowserContext : : GetDownloadManager ( browser ( ) -> profile ( ) ) , 1 , content : : DownloadTestObserver : : ON_DANGEROUS_DOWNLOAD_FAIL ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/download-test3.gif\" ) ) ;\n downloads_observer . WaitForFinished ( ) ;\n NavigateToUntrackedUrl ( ) ;\n EXPECT_TRUE ( NoPageLoadMetricsRecorded ( ) ) << \"Recorded metrics: \" << GetRecordedPageLoadMetricNames ( ) ;\n }", "hash": 927123821003322045, "project": "chrome", "size": 12, "target": 1, "idx": 22692}
{"code": "TEST_F ( ExternalProtocolHandlerTest , TestClearProfileState ) {\n base : : DictionaryValue prefs ;\n prefs . SetBoolean ( \"tel\" , true ) ;\n profile_ -> GetPrefs ( ) -> Set ( prefs : : kExcludedSchemes , prefs ) ;\n EXPECT_FALSE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n ExternalProtocolHandler : : ClearData ( profile_ . get ( ) ) ;\n EXPECT_TRUE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n }", "hash": 7823043019110226810, "project": "chrome", "size": 8, "target": 1, "idx": 22703}
{"code": "TEST_F ( ExternalProtocolHandlerTest , TestGetBlockStateDefaultDontBlock ) {\n ExternalProtocolHandler : : BlockState block_state = ExternalProtocolHandler : : GetBlockState ( \"mailto\" , profile_ . get ( ) ) ;\n EXPECT_EQ ( ExternalProtocolHandler : : DONT_BLOCK , block_state ) ;\n EXPECT_TRUE ( local_state_ -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n EXPECT_FALSE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n }", "hash": 7823043019110226810, "project": "chrome", "size": 6, "target": 1, "idx": 22706}
{"code": "TEST_F ( AutocompleteResultTest , SortAndCullDuplicateSearchURLs ) {\n TemplateURLData url_data ;\n url_data . SetShortName ( base : : ASCIIToUTF16 ( \"unittest\" ) ) ;\n url_data . SetKeyword ( base : : ASCIIToUTF16 ( \"foo\" ) ) ;\n url_data . SetURL ( \"http://www.foo.com/s?q={\nsearchTerms}\n\" ) ;\n template_url_service_ . get ( ) -> Add ( new TemplateURL ( url_data ) ) ;\n TestData data [ ] = {\n {\n 0 , 1 , 1300 , true }\n , {\n 1 , 1 , 1200 , true }\n , {\n 2 , 1 , 1100 , true }\n , {\n 3 , 1 , 1000 , true }\n , {\n 4 , 2 , 900 , true }\n , }\n ;\n ACMatches matches ;\n PopulateAutocompleteMatches ( data , arraysize ( data ) , & matches ) ;\n matches [ 0 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo\" ) ;\n matches [ 1 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo2\" ) ;\n matches [ 2 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo&oq=f\" ) ;\n matches [ 3 ] . destination_url = GURL ( \"http://www.foo.com/s?q=foo&aqs=0\" ) ;\n matches [ 4 ] . destination_url = GURL ( \"http://www.foo.com/\" ) ;\n AutocompleteInput input ( base : : string16 ( ) , base : : string16 : : npos , std : : string ( ) , GURL ( ) , OmniboxEventProto : : INVALID_SPEC , false , false , false , true , false , TestSchemeClassifier ( ) ) ;\n AutocompleteResult result ;\n result . AppendMatches ( input , matches ) ;\n result . SortAndCull ( input , std : : string ( ) , template_url_service_ . get ( ) ) ;\n ASSERT_EQ ( 3U , result . size ( ) ) ;\n EXPECT_EQ ( \"http://www.foo.com/s?q=foo\" , result . match_at ( 0 ) -> destination_url . spec ( ) ) ;\n EXPECT_EQ ( 1300 , result . match_at ( 0 ) -> relevance ) ;\n EXPECT_EQ ( \"http://www.foo.com/s?q=foo2\" , result . match_at ( 1 ) -> destination_url . spec ( ) ) ;\n EXPECT_EQ ( 1200 , result . match_at ( 1 ) -> relevance ) ;\n EXPECT_EQ ( \"http://www.foo.com/\" , result . match_at ( 2 ) -> destination_url . spec ( ) ) ;\n EXPECT_EQ ( 900 , result . match_at ( 2 ) -> relevance ) ;\n }", "hash": 8073241806104522127, "project": "chrome", "size": 40, "target": 1, "idx": 22732}
